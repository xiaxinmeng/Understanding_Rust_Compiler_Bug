{"sha": "871338c3aed87cb84f02ebd7fd9b447966d5b05d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTMzOGMzYWVkODdjYjg0ZjAyZWJkN2ZkOWI0NDc5NjZkNWIwNWQ=", "commit": {"author": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-02-13T06:46:14Z"}, "committer": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-02-13T06:46:14Z"}, "message": "Merging master", "tree": {"sha": "a2e1315d7d17d0b9f3463686ed2fbf36f3238ec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2e1315d7d17d0b9f3463686ed2fbf36f3238ec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/871338c3aed87cb84f02ebd7fd9b447966d5b05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/871338c3aed87cb84f02ebd7fd9b447966d5b05d", "html_url": "https://github.com/rust-lang/rust/commit/871338c3aed87cb84f02ebd7fd9b447966d5b05d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/871338c3aed87cb84f02ebd7fd9b447966d5b05d/comments", "author": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef34a5a39641846e824b6450a705d6031002beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef34a5a39641846e824b6450a705d6031002beb", "html_url": "https://github.com/rust-lang/rust/commit/1ef34a5a39641846e824b6450a705d6031002beb"}, {"sha": "0f949c2fcc696d0260a99196d5e5400c59a26a54", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f949c2fcc696d0260a99196d5e5400c59a26a54", "html_url": "https://github.com/rust-lang/rust/commit/0f949c2fcc696d0260a99196d5e5400c59a26a54"}], "stats": {"total": 32221, "additions": 17717, "deletions": 14504}, "files": [{"sha": "d603e4575159df2edea87b55d70debd64bceeb7c", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -44,3 +44,6 @@\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n \tbranch = rustc/8.0-2019-01-16\n+[submodule \"src/doc/embedded-book\"]\n+\tpath = src/doc/embedded-book\n+\turl = https://github.com/rust-embedded/book.git\n\\ No newline at end of file"}, {"sha": "d265f45c5cafa6e90cd8f5c78d25ef8940c0556e", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -155,6 +155,7 @@ Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>\n Matthijs Hofstra <thiezz@gmail.com>\n+Melody Horn <melody@boringcactus.com> <mathphreak@gmail.com>\n Michael Williams <m.t.williams@live.com>\n Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>"}, {"sha": "a36df24359df7024bd655cd4a7388271397b4a03", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n [[package]]\n name = \"adler32\"\n version = \"1.0.3\"\n@@ -75,8 +77,8 @@ dependencies = [\n  \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"environment 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -237,7 +239,7 @@ dependencies = [\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -530,7 +532,7 @@ name = \"crates-io\"\n version = \"0.23.0\"\n dependencies = [\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -841,16 +843,16 @@ dependencies = [\n \n [[package]]\n name = \"failure\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"failure_derive\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1232,7 +1234,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"9.0.0\"\n+version = \"10.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1352,7 +1354,7 @@ dependencies = [\n \n [[package]]\n name = \"lsp-codec\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bytes 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1362,7 +1364,7 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.54.0\"\n+version = \"0.55.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1503,7 +1505,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.26\"\n+version = \"0.0.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1677,8 +1679,8 @@ name = \"opener\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2045,7 +2047,7 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.16\"\n+version = \"2.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2246,26 +2248,26 @@ dependencies = [\n \n [[package]]\n name = \"rls\"\n-version = \"1.31.6\"\n+version = \"1.34.0\"\n dependencies = [\n  \"cargo 0.35.0\",\n- \"cargo_metadata 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy_lints 0.0.212\",\n  \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jsonrpc-core 9.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jsonrpc-core 10.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lsp-codec 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lsp-types 0.54.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-types 0.55.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2992,7 +2994,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"minifier 0.0.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3014,7 +3016,7 @@ name = \"rustfix\"\n version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3032,7 +3034,7 @@ dependencies = [\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3818,7 +3820,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3997,8 +3999,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum environment 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f4b14e20978669064c33b4c1e0fb4083412e40fe56cbea2eae80fd7591503ee\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n-\"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7\"\n-\"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\"\n+\"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n+\"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n@@ -4040,7 +4042,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum jemalloc-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bfc62c8e50e381768ce8ee0428ee53741929f7ebd73e4d83f669bcf7693e00ae\"\n \"checksum jobserver 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd80e58f77e0cdea53ba96acc5e04479e5ffc5d869626a6beafe50fed867eace\"\n \"checksum json 0.11.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n-\"checksum jsonrpc-core 9.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e9cbeda300803d381390fb65e8158437728c39e6987ed23bee82728b73511a7\"\n+\"checksum jsonrpc-core 10.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a5152c3fda235dfd68341b3edf4121bc4428642c93acbd6de88c26bf95fc5d7\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n \"checksum lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a374c89b9db55895453a74c1e38861d9deec0b01b405a82516e9d5de4820dea1\"\n@@ -4053,8 +4055,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lock_api 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"949826a5ccf18c1b3a7c3d57692778d21768b79e46eb9dd07bfc4c2160036c54\"\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n \"checksum log_settings 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n-\"checksum lsp-codec 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b29e3d1632fef13c1286b0b2f8545a7d894ae565a7fac013b90a17ee5bfbc91\"\n-\"checksum lsp-types 0.54.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a252cc2be87d9329dd91c505a951996b3263582ba304870960faaae77b642183\"\n+\"checksum lsp-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3570f641b984e3e4613a1ca34db2ea72549bbc3c0316d33f5af91ab514dcbff\"\n+\"checksum lsp-types 0.55.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ca49aeb430780992121d582520170411658b1e41bf968b917d85fd0fb6da3c5\"\n \"checksum lzma-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1eaa027402541975218bb0eec67d6b0412f6233af96e0d096d31dbdfd22e614\"\n \"checksum mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c41e0c4fef86961ac6d6f8a82609f55f31b05e4fce149ac5710e439df7619ba4\"\n \"checksum macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2c4deaccc2ead6a28c16c0ba82f07d52b6475397415ce40876e559b0b0ea510\"\n@@ -4066,7 +4068,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a3eb002f0535929f1199681417029ebea04aadc0c7a4224b46be99c7f5d6a16\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n-\"checksum minifier 0.0.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f299df45afd73332044ea9f717c816a84fc90c8b631409abf339ba93642a7985\"\n+\"checksum minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a2898502751dcc9d66b6fff57f3cf63cc91605e83e1a33515396f5027f8e4ca\"\n \"checksum miniz-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n \"checksum miniz_oxide 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n \"checksum miniz_oxide_c_api 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\"\n@@ -4123,7 +4125,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9949cfe66888ffe1d53e6ec9d9f3b70714083854be20fd5e271b232a017401e8\"\n \"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n-\"checksum racer 2.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbfcf2686b50f75a279cb42d9c6d253a1e68a475b415ea4baf7fb177ce94839a\"\n+\"checksum racer 2.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11db0de64c3eed7ee25f7b0af2109d296a67efa1efe7566ed17cc01115f961c8\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n \"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n \"checksum rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\""}, {"sha": "78ba1d376be79bd8e77967879bd34b13093722d6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -60,17 +60,17 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Primary function to execute this rule. Can call `builder.ensure(...)`\n+    /// Primary function to execute this rule. Can call `builder.ensure()`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n-    /// when we are not passed any paths; in that case, make_run is called\n+    /// when we are not passed any paths; in that case, `make_run` is called\n     /// directly.\n     fn should_run(run: ShouldRun) -> ShouldRun;\n \n-    /// Build up a \"root\" rule, either as a default rule or from a path passed\n+    /// Builds up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n     ///\n     /// When path is `None`, we are executing in a context where no paths were\n@@ -400,6 +400,7 @@ impl<'a> Builder<'a> {\n                 test::TheBook,\n                 test::UnstableBook,\n                 test::RustcBook,\n+                test::EmbeddedBook,\n                 test::Rustfmt,\n                 test::Miri,\n                 test::Clippy,\n@@ -430,6 +431,7 @@ impl<'a> Builder<'a> {\n                 doc::RustByExample,\n                 doc::RustcBook,\n                 doc::CargoBook,\n+                doc::EmbeddedBook,\n                 doc::EditionGuide,\n             ),\n             Kind::Dist => describe!(\n@@ -646,7 +648,7 @@ impl<'a> Builder<'a> {\n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n-    /// Get a path to the compiler specified.\n+    /// Gets a path to the compiler specified.\n     pub fn rustc(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n@@ -657,7 +659,7 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    /// Get the paths to all of the compiler's codegen backends.\n+    /// Gets the paths to all of the compiler's codegen backends.\n     fn codegen_backends(&self, compiler: Compiler) -> impl Iterator<Item = PathBuf> {\n         fs::read_dir(self.sysroot_codegen_backends(compiler))\n             .into_iter()\n@@ -1017,8 +1019,7 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n-        // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful.\n-        if self.config.deny_warnings && !(mode == Mode::Std && stage == 0) {\n+        if self.config.deny_warnings {\n             cargo.env(\"RUSTC_DENY_WARNINGS\", \"1\");\n         }\n "}, {"sha": "5f84816789a689cb09690954c3f240facc974c4f", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -227,10 +227,10 @@ lazy_static! {\n     pub static ref INTERNER: Interner = Interner::default();\n }\n \n-/// This is essentially a HashMap which allows storing any type in its input and\n+/// This is essentially a `HashMap` which allows storing any type in its input and\n /// any type in its output. It is a write-once cache; values are never evicted,\n /// which means that references to the value can safely be returned from the\n-/// get() method.\n+/// `get()` method.\n #[derive(Debug)]\n pub struct Cache(\n     RefCell<HashMap<"}, {"sha": "2a2533a3c1407d773667f281968bdbcecdea5950", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -66,7 +66,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "b52e1a7b0e6816032c9ca07f4d500888f7637592", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,7 +3,7 @@\n //! Responsible for cleaning out a build directory of all old and stale\n //! artifacts to prepare for a fresh build. Currently doesn't remove the\n //! `build/cache` directory (download cache) or the `build/$target/llvm`\n-//! directory unless the --all flag is present.\n+//! directory unless the `--all` flag is present.\n \n use std::fs;\n use std::io::{self, ErrorKind};"}, {"sha": "8fabb8c3fd08f504f4c2bb56a8d80f98aee8adfb", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n         });\n     }\n \n-    /// Build the standard library.\n+    /// Builds the standard library.\n     ///\n     /// This will build the standard library for a particular stage of the build\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n@@ -269,7 +269,7 @@ impl Step for StartupObjects {\n         });\n     }\n \n-    /// Build and prepare startup objects like rsbegin.o and rsend.o\n+    /// Builds and prepare startup objects like rsbegin.o and rsend.o\n     ///\n     /// These are primarily used on Windows right now for linking executables/dlls.\n     /// They don't require any library support as they're just plain old object\n@@ -334,7 +334,7 @@ impl Step for Test {\n         });\n     }\n \n-    /// Build libtest.\n+    /// Builds libtest.\n     ///\n     /// This will build libtest and supporting libraries for a particular stage of\n     /// the build using the `compiler` targeting the `target` architecture. The\n@@ -455,7 +455,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "bc1fdad356be3eee5e959b3063dbb3a62acde22d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -342,7 +342,7 @@ impl Step for Mingw {\n         run.builder.ensure(Mingw { host: run.target });\n     }\n \n-    /// Build the `rust-mingw` installer component.\n+    /// Builds the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc)."}, {"sha": "d14b23e5988cbb85266875a5dee55de259e19eef", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -61,6 +61,7 @@ macro_rules! book {\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n     EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook1;\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n     Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook1;\n     Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook1;\n@@ -71,10 +72,6 @@ book!(\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n enum RustbookVersion {\n     MdBook1,\n-\n-    /// Note: Currently no books use mdBook v2, but we want the option\n-    /// to be available\n-    #[allow(dead_code)]\n     MdBook2,\n }\n \n@@ -262,7 +259,7 @@ impl Step for TheBook {\n         });\n     }\n \n-    /// Build the book and associated stuff.\n+    /// Builds the book and associated stuff.\n     ///\n     /// We need to build:\n     ///\n@@ -614,7 +611,7 @@ impl Step for WhitelistedRustc {\n         });\n     }\n \n-    /// Generate whitelisted compiler crate documentation.\n+    /// Generates whitelisted compiler crate documentation.\n     ///\n     /// This will generate all documentation for crates that are whitelisted\n     /// to be included in the standard documentation. This documentation is\n@@ -686,7 +683,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure\n@@ -787,7 +784,7 @@ impl Step for Rustdoc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure"}, {"sha": "6a93c95c3d97fb4d6012a876c1fcb7e076ebf9c0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -69,7 +69,7 @@\n //! ## Copying stage0 {std,test,rustc}\n //!\n //! This copies the build output from Cargo into\n-//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: This step's\n+//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: this step's\n //! documentation should be expanded -- the information already here may be\n //! incorrect.\n //!\n@@ -504,7 +504,7 @@ impl Build {\n         cleared\n     }\n \n-    /// Get the space-separated set of activated features for the standard\n+    /// Gets the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n         let mut features = \"panic-unwind\".to_string();\n@@ -521,7 +521,7 @@ impl Build {\n         features\n     }\n \n-    /// Get the space-separated set of activated features for the compiler.\n+    /// Gets the space-separated set of activated features for the compiler.\n     fn rustc_features(&self) -> String {\n         let mut features = String::new();\n         if self.config.jemalloc {\n@@ -609,7 +609,7 @@ impl Build {\n         self.out.join(&*target).join(\"crate-docs\")\n     }\n \n-    /// Returns true if no custom `llvm-config` is set for the specified target.\n+    /// Returns `true` if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n     fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n@@ -857,13 +857,13 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n-    /// Returns true if this is a no-std `target`, if defined\n+    /// Returns `true` if this is a no-std `target`, if defined\n     fn no_std(&self, target: Interned<String>) -> Option<bool> {\n         self.config.target_config.get(&target)\n             .map(|t| t.no_std)\n     }\n \n-    /// Returns whether the target will be tested using the `remote-test-client`\n+    /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n         self.qemu_rootfs(target).is_some() || target.contains(\"android\") ||\n@@ -1059,7 +1059,7 @@ impl Build {\n         self.rust_info.version(self, channel::CFG_RELEASE_NUM)\n     }\n \n-    /// Return the full commit hash\n+    /// Returns the full commit hash.\n     fn rust_sha(&self) -> Option<&str> {\n         self.rust_info.sha()\n     }\n@@ -1079,7 +1079,7 @@ impl Build {\n         panic!(\"failed to find version in {}'s Cargo.toml\", package)\n     }\n \n-    /// Returns whether unstable features should be enabled for the compiler\n+    /// Returns `true` if unstable features should be enabled for the compiler\n     /// we're building.\n     fn unstable_features(&self) -> bool {\n         match &self.config.channel[..] {\n@@ -1327,7 +1327,7 @@ impl<'a> Compiler {\n         self\n     }\n \n-    /// Returns whether this is a snapshot compiler for `build`'s configuration\n+    /// Returns `true` if this is a snapshot compiler for `build`'s configuration\n     pub fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.build\n     }"}, {"sha": "a882550f734f40ead12195582c15e84dc2dedc9a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -30,9 +30,9 @@ const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n pub enum TestKind {\n-    /// Run `cargo test`\n+    /// Run `cargo test`.\n     Test,\n-    /// Run `cargo bench`\n+    /// Run `cargo bench`.\n     Bench,\n }\n \n@@ -1288,7 +1288,7 @@ impl Step for DocTest {\n         run.never()\n     }\n \n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    /// Runs `rustdoc --test` for all documentation in `src/doc`.\n     ///\n     /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n@@ -1383,6 +1383,7 @@ test_book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n     RustcBook, \"src/doc/rustc\", \"rustc\", default=true;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", default=false;\n     TheBook, \"src/doc/book\", \"book\", default=false;\n     UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n );\n@@ -1407,7 +1408,7 @@ impl Step for ErrorIndex {\n         });\n     }\n \n-    /// Run the error index generator tool to execute the tests located in the error\n+    /// Runs the error index generator tool to execute the tests located in the error\n     /// index.\n     ///\n     /// The `error_index_generator` tool lives in `src/tools` and is used to\n@@ -1613,7 +1614,7 @@ impl Step for Crate {\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// Runs all unit tests plus documentation tests for a given crate defined\n     /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n@@ -1832,7 +1833,7 @@ fn envify(s: &str) -> String {\n /// the standard library and such to the emulator ahead of time. This step\n /// represents this and is a dependency of all test suites.\n ///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n+/// Most of the time this is a no-op. For some steps such as shipping data to\n /// QEMU we have to build our own tools so we've got conditional dependencies\n /// on those programs as well. Note that the remote test client is built for\n /// the build target (us) and the server is built for the target.\n@@ -1903,7 +1904,7 @@ impl Step for Distcheck {\n         run.builder.ensure(Distcheck);\n     }\n \n-    /// Run \"distcheck\", a 'make check' from a tarball\n+    /// Runs \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder) {\n         builder.info(\"Distcheck\");\n         let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n@@ -1964,7 +1965,7 @@ impl Step for Bootstrap {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    /// Test the build system itself\n+    /// Tests the build system itself.\n     fn run(self, builder: &Builder) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")"}, {"sha": "c09e9332895d87f12b84671d215d6b62afc34025", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -40,7 +40,7 @@ impl Step for ToolBuild {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n+    /// Builds a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n@@ -621,7 +621,7 @@ tool_extended!((self, builder),\n );\n \n impl<'a> Builder<'a> {\n-    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// Gets a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));"}, {"sha": "29aa98971fb567a846b7cd18d5cf5197f355a571", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -33,7 +33,7 @@ pub fn exe(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Returns whether the file name given looks like a dynamic library.\n+/// Returns `true` if the file name given looks like a dynamic library.\n pub fn is_dylib(name: &str) -> bool {\n     name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n }"}, {"sha": "04c7820b45665feb9fe465f3936d086dc5b907f7", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n name = \"build_helper\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n \n [lib]\n name = \"build_helper\""}, {"sha": "bd99dc118e66a36ab2f819aac565669f2fc947c3", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rust_2018_idioms)]\n+\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -161,7 +163,7 @@ pub fn mtime(path: &Path) -> SystemTime {\n         .unwrap_or(UNIX_EPOCH)\n }\n \n-/// Returns whether `dst` is up to date given that the file or files in `src`\n+/// Returns `true` if `dst` is up to date given that the file or files in `src`\n /// are used to generate it.\n ///\n /// Uses last-modified time checks to verify this.\n@@ -188,12 +190,12 @@ pub struct NativeLibBoilerplate {\n }\n \n impl NativeLibBoilerplate {\n-    /// On OSX we don't want to ship the exact filename that compiler-rt builds.\n+    /// On macOS we don't want to ship the exact filename that compiler-rt builds.\n     /// This conflicts with the system and ours is likely a wildly different\n     /// version, so they can't be substituted.\n     ///\n     /// As a result, we rename it here but we need to also use\n-    /// `install_name_tool` on OSX to rename the commands listed inside of it to\n+    /// `install_name_tool` on macOS to rename the commands listed inside of it to\n     /// ensure it's linked against correctly.\n     pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n         if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {"}, {"sha": "3343716419ff459a473a69a4488f99251fcc7ab0", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -23,6 +23,7 @@ python2.7 \"$X_PY\" test --no-fail-fast \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n+    src/doc/embedded-book \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\"}, {"sha": "42d0d7db5964ca59a2e444e1aed0dc80ab43f795", "filename": "src/ci/run.sh", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -121,14 +121,7 @@ fi\n travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n-  # This `set +e` followed by capturing the return value is a temporary measure\n-  # to help debug \"error with exit 259\" on AppVeyor temporarily, otherwise all\n-  # that's needed here is the `sh`\n-  set +e\n   sh -x -c \"$SCRIPT\"\n-  ret=$?\n-  echo \"script exited with $ret\"\n-  exit $ret\n else\n   do_make() {\n     travis_fold start \"make-$1\""}, {"sha": "bd2778f304989ee52be8201504d6ec621dd60ca9", "filename": "src/doc/embedded-book", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -0,0 +1 @@\n+Subproject commit bd2778f304989ee52be8201504d6ec621dd60ca9"}, {"sha": "0a2a80e8fd6e2b4d62dcf9a93f2dc5983b0da249", "filename": "src/doc/index.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -52,6 +52,12 @@ If reading multiple hundreds of pages about a language isn't your style, then\n a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n minimum. It also includes exercises!\n \n+## Rustlings\n+\n+[Rustlings](https://github.com/rust-lang/rustlings) guides you through downloading and setting up the Rust toolchain,\n+and teaches you the basics of reading and writing Rust syntax. It's an\n+alternative to Rust by Example that works with your own environment.\n+\n # Use Rust\n \n Once you've gotten familiar with the language, these resources can help you\n@@ -117,3 +123,19 @@ Rust. It's also sometimes called \"the 'nomicon.\"\n [The `rustc` Guide](https://rust-lang.github.io/rustc-guide/) documents how\n the compiler works and how to contribute to it. This is useful if you want to build\n or modify the Rust compiler from source (e.g. to target something non-standard).\n+\n+# Specialize Rust\n+\n+When using Rust in specific domain areas, consider using the following resources tailored to each domain.\n+\n+## Embedded Systems\n+\n+When developing for Bare Metal or Embedded Linux systems, you may find these resources maintained by the [Embedded Working Group] useful.\n+\n+[Embedded Working Group]: https://github.com/rust-embedded\n+\n+### The Embedded Rust Book\n+\n+[The Embedded Rust Book] is targeted at developers familiar with embedded development and familiar with Rust, but have not used Rust for embedded development.\n+\n+[The Embedded Rust Book]: embedded-book/index.html"}, {"sha": "3463cdb126cc6b558e977dd2391782ca3da31e68", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,8 @@\n # Unstable features\n \n Rustdoc is under active development, and like the Rust compiler, some features are only available\n-on the nightly releases. Some of these are new and need some more testing before they're able to get\n-released to the world at large, and some of them are tied to features in the Rust compiler that are\n-themselves unstable. Several features here require a matching `#![feature(...)]` attribute to\n+on nightly releases. Some of these features are new and need some more testing before they're able to be\n+released to the world at large, and some of them are tied to features in the Rust compiler that are unstable. Several features here require a matching `#![feature(...)]` attribute to\n enable, and thus are more fully documented in the [Unstable Book]. Those sections will link over\n there as necessary.\n \n@@ -428,4 +427,4 @@ $ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdo\n \n This flag allows you to keep doctest executables around after they're compiled or run.\n Usually, rustdoc will immediately discard a compiled doctest after it's been tested, but\n-with this option, you can keep those binaries around for farther testing.\n\\ No newline at end of file\n+with this option, you can keep those binaries around for farther testing."}, {"sha": "415c6ebe8b4bcfe7e45026f4e0dda575da807bcb", "filename": "src/doc/unstable-book/src/language-features/repr-align-enum.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -0,0 +1,42 @@\n+# `repr_align_enum`\n+\n+The tracking issue for this feature is: [#57996]\n+\n+[#57996]: https://github.com/rust-lang/rust/issues/57996\n+\n+------------------------\n+\n+The `repr_align_enum` feature allows using the `#[repr(align(x))]` attribute\n+on enums, similarly to structs.\n+\n+# Examples\n+\n+```rust\n+#![feature(repr_align_enum)]\n+\n+#[repr(align(8))]\n+enum Aligned {\n+    Foo,\n+    Bar { value: u32 },\n+}\n+\n+fn main() {\n+    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n+}\n+```\n+\n+This is equivalent to using an aligned wrapper struct everywhere:\n+\n+```rust\n+#[repr(align(8))]\n+struct Aligned(Unaligned);\n+\n+enum Unaligned {\n+    Foo,\n+    Bar { value: u32 },\n+}\n+\n+fn main() {\n+    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n+}\n+```"}, {"sha": "40c71f12cd8a6320e9751024c25fcc81716440cd", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -137,11 +137,11 @@ impl<T> ToOwned for T\n /// ```\n /// use std::borrow::{Cow, ToOwned};\n ///\n-/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned=Vec<X>> {\n+/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,\n /// }\n ///\n-/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned=Vec<X>> {\n+/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n ///     fn new(v: Cow<'a, [X]>) -> Self {\n ///         Items { values: v }\n ///     }"}, {"sha": "3b94379b58f8f03c2e09e09bba1254263b53b423", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -248,14 +248,18 @@ impl<T: Ord> Drop for PeekMut<'_, T> {\n impl<T: Ord> Deref for PeekMut<'_, T> {\n     type Target = T;\n     fn deref(&self) -> &T {\n-        &self.heap.data[0]\n+        debug_assert!(!self.heap.is_empty());\n+        // SAFE: PeekMut is only instantiated for non-empty heaps\n+        unsafe { self.heap.data.get_unchecked(0) }\n     }\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        &mut self.heap.data[0]\n+        debug_assert!(!self.heap.is_empty());\n+        // SAFE: PeekMut is only instantiated for non-empty heaps\n+        unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n }\n \n@@ -859,13 +863,14 @@ struct Hole<'a, T: 'a> {\n }\n \n impl<'a, T> Hole<'a, T> {\n-    /// Create a new Hole at index `pos`.\n+    /// Create a new `Hole` at index `pos`.\n     ///\n     /// Unsafe because pos must be within the data slice.\n     #[inline]\n     unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n         debug_assert!(pos < data.len());\n-        let elt = ptr::read(&data[pos]);\n+        // SAFE: pos should be inside the slice\n+        let elt = ptr::read(data.get_unchecked(pos));\n         Hole {\n             data,\n             elt: ManuallyDrop::new(elt),"}, {"sha": "5ec5064b735150b45465fc1c0fc996daf52ac285", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2368,7 +2368,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n-    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n     /// [`into_mut`]: #method.into_mut"}, {"sha": "eb0667228d1fff347f64b859fede02b99e8dc88f", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -50,11 +50,11 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n /// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n /// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n struct NodeHeader<K, V, K2 = ()> {\n@@ -1295,7 +1295,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n     /// a node to hold the combination of the nodes to the left and right of this handle along\n     /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n@@ -1573,7 +1573,7 @@ unsafe fn move_edges<K, V>(\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n-    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n+    /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}, {"sha": "870e3e47692b02ba605dea74239aa740e088c452", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -556,7 +556,7 @@ impl<T: Ord> BTreeSet<T> {\n         Recover::replace(&mut self.map, value)\n     }\n \n-    /// Removes a value from the set. Returns `true` if the value was\n+    /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type,\n@@ -988,7 +988,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n         (None, _) => short,"}, {"sha": "b6fdaa89992122f98c94938e9e091cfedf41a0e4", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -124,7 +124,7 @@ impl<T> VecDeque<T> {\n         ptr::write(self.ptr().add(off), value);\n     }\n \n-    /// Returns `true` if and only if the buffer is at full capacity.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n         self.cap() - self.len() == 1\n@@ -560,7 +560,7 @@ impl<T> VecDeque<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -924,15 +924,15 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    /// Create a draining iterator that removes the specified range in the\n+    /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is not\n     /// consumed until the end.\n     ///\n     /// Note 2: It is unspecified how many elements are removed from the deque,\n     /// if the `Drain` value is not dropped, but the borrow it holds expires\n-    /// (eg. due to mem::forget).\n+    /// (e.g., due to `mem::forget`).\n     ///\n     /// # Panics\n     ///\n@@ -1922,7 +1922,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `mid` is greater than `len()`.  Note that `mid == len()`\n+    /// If `mid` is greater than `len()`. Note that `mid == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity\n@@ -1967,7 +1967,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `k` is greater than `len()`.  Note that `k == len()`\n+    /// If `k` is greater than `len()`. Note that `k == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity"}, {"sha": "d2ba9b001916c572e142fedfbc6d312842928cb0", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -27,7 +27,7 @@\n //! will then parse the format string and determine if the list of arguments\n //! provided is suitable to pass to this format string.\n //!\n-//! To convert a single value to a string, use the [`to_string`] method.  This\n+//! To convert a single value to a string, use the [`to_string`] method. This\n //! will use the [`Display`] formatting trait.\n //!\n //! ## Positional parameters\n@@ -102,7 +102,7 @@\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n //! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n-//! well as [`isize`]).  The current mapping of types to traits is:\n+//! well as [`isize`]). The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n@@ -427,7 +427,7 @@\n //! 3. An asterisk `.*`:\n //!\n //!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print.  Note that\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!"}, {"sha": "95b9dacf8565aa5ea9357e26bded9031129ac3d6", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -55,9 +55,7 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n@@ -70,7 +68,6 @@\n #![warn(intra_doc_link_resolution_failure)]\n #![warn(missing_debug_implementations)]\n \n-#![cfg_attr(not(test), feature(fn_traits))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n \n@@ -88,6 +85,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n+#![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(futures_api)]\n #![feature(lang_items)]\n@@ -102,6 +100,7 @@\n #![feature(receiver_trait)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]"}, {"sha": "eb3410078513de3e25a945caaf58645462afab1f", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -34,7 +34,8 @@\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(box_syntax))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n macro_rules! vec {\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n@@ -62,18 +63,18 @@ macro_rules! vec {\n \n /// Creates a `String` using interpolation of runtime expressions.\n ///\n-/// The first argument `format!` receives is a format string.  This must be a string\n-/// literal.  The power of the formatting string is in the `{}`s contained.\n+/// The first argument `format!` receives is a format string. This must be a string\n+/// literal. The power of the formatting string is in the `{}`s contained.\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the\n /// formatting string in the order given unless named or positional parameters\n-/// are used, see [`std::fmt`][fmt] for more information.\n+/// are used; see [`std::fmt`][fmt] for more information.\n ///\n /// A common use for `format!` is concatenation and interpolation of strings.\n /// The same convention is used with [`print!`] and [`write!`] macros,\n /// depending on the intended destination of the string.\n ///\n-/// To convert a single value to a string, use the [`to_string`] method.  This\n+/// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n /// [fmt]: ../std/fmt/index.html"}, {"sha": "fe28fe5095ccef29333311057ac65cb415f31da0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -335,7 +335,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///\n@@ -504,7 +504,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///"}, {"sha": "12f75d84211e6f03e555b4c7e32e2aabc7c5255c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -512,7 +512,7 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n     /// this inner value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -561,7 +561,7 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Rc`s point to the same value (not\n+    /// Returns `true` if the two `Rc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1334,8 +1334,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {\n@@ -1345,7 +1345,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "c4f4a80a017df80aed003097f3252e0bea645b67", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -205,10 +205,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`."}, {"sha": "a36804bddff32ec16b048e5ae2e2f1d3534071a6", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -29,8 +29,6 @@\n #![allow(unused_imports)]\n \n use core::borrow::Borrow;\n-use core::fmt;\n-use core::str as core_str;\n use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n@@ -443,45 +441,6 @@ impl str {\n         return s;\n     }\n \n-    /// Escapes each char in `s` with [`char::escape_debug`].\n-    ///\n-    /// Note: only extended grapheme codepoints that begin the string will be\n-    /// escaped.\n-    ///\n-    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_debug(&self) -> String {\n-        let mut string = String::with_capacity(self.len());\n-        let mut chars = self.chars();\n-        if let Some(first) = chars.next() {\n-            string.extend(first.escape_debug_ext(true))\n-        }\n-        string.extend(chars.flat_map(|c| c.escape_debug_ext(false)));\n-        string\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_default`].\n-    ///\n-    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_unicode`].\n-    ///\n-    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n     /// [`String`]: string/struct.String.html\n@@ -612,3 +571,4 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     Box::from_raw(Box::into_raw(v) as *mut str)\n }\n+"}, {"sha": "84c35c6f1bd2b0b943faa86cbf24d65fe87114e1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -963,7 +963,7 @@ impl String {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -1377,9 +1377,7 @@ impl String {\n         self.vec.len()\n     }\n \n-    /// Returns `true` if this `String` has a length of zero.\n-    ///\n-    /// Returns `false` otherwise.\n+    /// Returns `true` if this `String` has a length of zero, and `false` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b7d7995b540bac75fd23000e8351cd76c66bfd1b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -560,7 +560,7 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Arc`s point to the same value (not\n+    /// Returns `true` if the two `Arc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1191,8 +1191,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {\n@@ -1202,7 +1202,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "7c5a8926126e36dd3f63904aa6f9fabdc06a6170", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::any::Any;\n use std::sync::{Arc, Weak};\n use std::cell::RefCell;"}, {"sha": "c1a1c5d88781ffaa0ba7702c4307d66ab97be574", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -282,6 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n+#[cfg(not(miri))]\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "653b3f5bcb49d7b62d7b57135f9c346a6da80aa6", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n mod map;\n mod set;\n "}, {"sha": "7bc1aac7c8b59643723339646360a8abaf439564", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,8 @@\n+#![cfg(not(miri))]\n+\n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// https://github.com/rust-lang/rust/issues/45955\n+/// Issue #45955.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)"}, {"sha": "2b63ac5c7d2f990707c31f476610206544396e98", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,7 +5,6 @@\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n #![feature(slice_sort_by_cached_key)]\n-#![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(vecdeque_rotate)]"}, {"sha": "1be01d1a7ce1a1bbd279007e260df0651f85b7bf", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::any::Any;\n use std::rc::{Rc, Weak};\n use std::cell::RefCell;"}, {"sha": "2a9fdfa9324d5218f70bdb59102dcd17db627b49", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;"}, {"sha": "a1dc763f6d8ffc2d928b9f8185e912a37fb4a512", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -31,6 +31,7 @@ fn test_rfind() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_collect() {\n     let empty = \"\";\n     let s: String = empty.chars().collect();\n@@ -118,6 +119,7 @@ fn test_concat_for_different_types() {\n #[test]\n fn test_concat_for_different_lengths() {\n     let empty: &[&str] = &[];\n+    #[cfg(not(miri))]\n     test_concat!(\"\", empty);\n     test_concat!(\"a\", [\"a\"]);\n     test_concat!(\"ab\", [\"a\", \"b\"]);\n@@ -146,6 +148,7 @@ fn test_join_for_different_types() {\n #[test]\n fn test_join_for_different_lengths() {\n     let empty: &[&str] = &[];\n+    #[cfg(not(miri))]\n     test_join!(\"\", empty, \"-\");\n     test_join!(\"a\", [\"a\"], \"-\");\n     test_join!(\"a-b\", [\"a\", \"b\"], \"-\");\n@@ -159,13 +162,15 @@ fn test_join_for_different_lengths_with_long_separator() {\n     assert_eq!(\"\uff5e\uff5e\uff5e\uff5e\uff5e\".len(), 15);\n \n     let empty: &[&str] = &[];\n+    #[cfg(not(miri))]\n     test_join!(\"\", empty, \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"a\", [\"a\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"a\uff5e\uff5e\uff5e\uff5e\uff5eb\", [\"a\", \"b\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"\uff5e\uff5e\uff5e\uff5e\uff5ea\uff5e\uff5e\uff5e\uff5e\uff5ebc\", [\"\", \"a\", \"bc\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_unsafe_slice() {\n     assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n     assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n@@ -238,6 +243,7 @@ fn test_replacen() {\n #[test]\n fn test_replace() {\n     let a = \"a\";\n+    #[cfg(not(miri))]\n     assert_eq!(\"\".replace(a, \"b\"), \"\");\n     assert_eq!(\"a\".replace(a, \"b\"), \"b\");\n     assert_eq!(\"ab\".replace(a, \"b\"), \"bb\");\n@@ -297,6 +303,7 @@ fn test_replace_pattern() {\n // The current implementation of SliceIndex fails to handle methods\n // orthogonally from range types; therefore, it is worth testing\n // all of the indexing operations on each input.\n+#[cfg(not(miri))]\n mod slice_index {\n     // Test a slicing operation **that should succeed,**\n     // testing it on all of the indexing methods.\n@@ -679,6 +686,7 @@ fn test_str_slice_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_str_slice_rangetoinclusive_notok() {\n     let s = \"abc\u03b1\u03b2\u03b3\";\n     &s[..=3];\n@@ -694,6 +702,7 @@ fn test_str_slicemut_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_str_slicemut_rangetoinclusive_notok() {\n     let mut s = \"abc\u03b1\u03b2\u03b3\".to_owned();\n     let s: &mut str = &mut s;\n@@ -883,6 +892,7 @@ fn test_as_bytes() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_as_bytes_fail() {\n     // Don't double free. (I'm not sure if this exercises the\n     // original problem code path anymore.)\n@@ -972,22 +982,23 @@ fn test_split_at_mut() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     s.split_at(1);\n }\n \n #[test]\n fn test_escape_unicode() {\n-    assert_eq!(\"abc\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n-    assert_eq!(\"a c\".escape_unicode(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n-    assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n-    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{fb00}\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n-    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), \"\\\\u{1d4ea}\\\\u{d}\");\n+    assert_eq!(\"abc\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n+    assert_eq!(\"a c\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_unicode().to_string(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n+    assert_eq!(\"'\\\"\\\\\".escape_unicode().to_string(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n+    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode().to_string(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{fb00}\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n+    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode().to_string(), \"\\\\u{1d4ea}\\\\u{d}\");\n }\n \n #[test]\n@@ -998,31 +1009,32 @@ fn test_escape_debug() {\n     // they are escaped. However, when the character is unescaped (e.g., for\n     // printable characters), only a single backslash appears (as the character\n     // itself appears in the debug string).\n-    assert_eq!(\"abc\".escape_debug(), \"abc\");\n-    assert_eq!(\"a c\".escape_debug(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug(), \"\u00e9\u00e8\u00ea\");\n-    assert_eq!(\"\\r\\n\\t\".escape_debug(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_debug(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug(), \"\\\\u{7f}\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug(), \"\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug(), \"\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_debug(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug(), \"\\\\u{10d4ea}\\\\r\");\n-    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug(), \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n+    assert_eq!(\"abc\".escape_debug().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_debug().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug().to_string(), \"\u00e9\u00e8\u00ea\");\n+    assert_eq!(\"\\r\\n\\t\".escape_debug().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_debug().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug().to_string(), \"\\\\u{7f}\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug().to_string(), \"\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug().to_string(), \"\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_debug().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug().to_string(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug().to_string(),\n+               \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n }\n \n #[test]\n fn test_escape_default() {\n-    assert_eq!(\"abc\".escape_default(), \"abc\");\n-    assert_eq!(\"a c\".escape_default(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default(), \"\\\\u{7f}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_default(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_default(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"abc\".escape_default().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_default().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default().to_string(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_default().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_default().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default().to_string(), \"\\\\u{7f}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_default().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_default().to_string(), \"\\\\u{10d4ea}\\\\r\");\n }\n \n #[test]\n@@ -1066,6 +1078,7 @@ fn test_rev_iterator() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_chars_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1077,6 +1090,7 @@ fn test_chars_decoding() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_chars_rev_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1306,6 +1320,7 @@ fn test_splitator() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_str_default() {\n     use std::default::Default;\n \n@@ -1365,6 +1380,7 @@ fn test_bool_from_str() {\n     assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n+#[cfg(not(miri))]\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n@@ -1375,6 +1391,7 @@ fn check_contains_all_substrings(s: &str) {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn strslice_issue_16589() {\n     assert!(\"bananas\".contains(\"nana\"));\n \n@@ -1384,13 +1401,15 @@ fn strslice_issue_16589() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn strslice_issue_16878() {\n     assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n     assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n }\n \n \n #[test]\n+#[cfg(not(miri))]\n fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);\n@@ -1528,6 +1547,7 @@ fn trim_ws() {\n \n #[test]\n fn to_lowercase() {\n+    #[cfg(not(miri))]\n     assert_eq!(\"\".to_lowercase(), \"\");\n     assert_eq!(\"A\u00c9\u01c5a\u00e9 \".to_lowercase(), \"a\u00e9\u01c6a\u00e9 \");\n \n@@ -1561,6 +1581,7 @@ fn to_lowercase() {\n \n #[test]\n fn to_uppercase() {\n+    #[cfg(not(miri))]\n     assert_eq!(\"\".to_uppercase(), \"\");\n     assert_eq!(\"a\u00e9\u01c5\u00df\ufb01\u1f80\".to_uppercase(), \"A\u00c9\u01c4SSFI\u1f08\u0399\");\n }\n@@ -1592,6 +1613,7 @@ fn test_cow_from() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_repeat() {\n     assert_eq!(\"\".repeat(3), \"\");\n     assert_eq!(\"abc\".repeat(0), \"\");"}, {"sha": "e6ca54c4088653b9420fe7e055f2c0c05d4003b2", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::borrow::Cow;\n use std::collections::CollectionAllocErr::*;\n use std::mem::size_of;"}, {"sha": "545332bcd6a2f3985c5243bcb08b7f3417e7ce7f", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};"}, {"sha": "b47e7c867e675441de41e2bccb9a567e8be8b149", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -108,6 +108,7 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_index_out_of_bounds() {\n     let mut deq = VecDeque::new();\n     for i in 1..4 {\n@@ -906,20 +907,24 @@ fn test_append() {\n     // normal append\n     a.append(&mut b);\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    #[cfg(not(miri))]\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n     // append nothing to something\n     a.append(&mut b);\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    #[cfg(not(miri))]\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n     // append something to nothing\n     b.append(&mut a);\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    #[cfg(not(miri))]\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_append_permutations() {\n     fn construct_vec_deque(\n         push_back: usize,\n@@ -1120,6 +1125,7 @@ fn test_reserve_exact_2() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -1221,6 +1227,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "57723e4d2128182001b917c90a7ba81b39bd2710", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -463,7 +463,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n@@ -525,7 +525,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -738,7 +738,7 @@ impl<T> Vec<T> {\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n-    /// invariants of the type.  Normally changing the length of a vector\n+    /// invariants of the type. Normally changing the length of a vector\n     /// is done using one of the safe operations instead, such as\n     /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n     ///\n@@ -2608,7 +2608,7 @@ impl<T> Drain<'_, T> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n         let vec = self.vec.as_mut();\n         let range_start = vec.len;\n@@ -2628,7 +2628,7 @@ impl<T> Drain<'_, T> {\n         true\n     }\n \n-    /// Make room for inserting more elements before the tail.\n+    /// Makes room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n         let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;"}, {"sha": "82fc64ba64e331645d075fbd879a6696e04cf523", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,11 +2,12 @@\n authors = [\"The Rust Project Developers\"]\n name = \"arena\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"arena\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "8ae046c0796bc53e8f57eaa413af43a7e1bad17e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -8,22 +8,20 @@\n //! This crate implements `TypedArena`, a simple arena that can only hold\n //! objects of a single type.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(nll)]\n #![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]\n \n extern crate alloc;\n-extern crate rustc_data_structures;\n \n use rustc_data_structures::sync::MTLock;\n \n@@ -478,7 +476,7 @@ impl SyncDroplessArena {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n+    use test::Bencher;\n     use super::TypedArena;\n     use std::cell::Cell;\n \n@@ -513,15 +511,15 @@ mod tests {\n \n         impl<'a> Wrap<'a> {\n             fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI = self.0.alloc(EI::I(f()));\n+                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n                 if let &EI::I(ref i) = r {\n                     i\n                 } else {\n                     panic!(\"mismatch\");\n                 }\n             }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n-                let r: &EI = self.0.alloc(EI::O(f()));\n+            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n+                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n                 if let &EI::O(ref o) = r {\n                     o\n                 } else {\n@@ -611,7 +609,7 @@ mod tests {\n         count: &'a Cell<u32>,\n     }\n \n-    impl<'a> Drop for DropCounter<'a> {\n+    impl Drop for DropCounter<'_> {\n         fn drop(&mut self) {\n             self.count.set(self.count.get() + 1);\n         }\n@@ -621,7 +619,7 @@ mod tests {\n     fn test_typed_arena_drop_count() {\n         let counter = Cell::new(0);\n         {\n-            let arena: TypedArena<DropCounter> = TypedArena::default();\n+            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak.\n                 arena.alloc(DropCounter { count: &counter });\n@@ -633,7 +631,7 @@ mod tests {\n     #[test]\n     fn test_typed_arena_drop_on_clear() {\n         let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter> = TypedArena::default();\n+        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n         for i in 0..10 {\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak."}, {"sha": "f49e226a5cb68ed04b5064008cb102f41982ca5c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -425,7 +425,7 @@ impl fmt::Display for CannotReallocInPlace {\n /// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n ///   be lifted in the future, but currently a panic from any of these\n ///   functions may lead to memory unsafety.\n ///"}, {"sha": "01ab523a4c3f6ce8bd3c825d2b7c2e735034419b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n-//! concrete type.  We want to give special treatment to certain types: in this\n+//! concrete type. We want to give special treatment to certain types: in this\n //! case printing out the length of String values prior to their value.\n //! We don't know the concrete type of our value at compile time, so we need to\n //! use runtime reflection instead.\n@@ -31,8 +31,8 @@\n //! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &dyn Any;\n //!\n-//!     // try to convert our value to a String.  If successful, we want to\n-//!     // output the String's length as well as its value.  If not, it's a\n+//!     // Try to convert our value to a `String`. If successful, we want to\n+//!     // output the String`'s length as well as its value. If not, it's a\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {"}, {"sha": "8383d305518ab39e7ea822ab67ef3715358c7213", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -130,7 +130,7 @@\n //!\n //! This is simply a special - but common - case of the previous: hiding mutability for operations\n //! that appear to be immutable. The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\n //! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n //! `Cell<T>`.\n //!\n@@ -1133,7 +1133,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// `Ref::clone(...)`. A `Clone` implementation or a method would interfere\n     /// with the widespread use of `r.borrow().clone()` to clone the contents of\n     /// a `RefCell`.\n     #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n@@ -1145,7 +1145,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a component of the borrowed data.\n+    /// Makes a new `Ref` for a component of the borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n@@ -1174,7 +1174,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Split a `Ref` into multiple `Ref`s for different components of the\n+    /// Splits a `Ref` into multiple `Ref`s for different components of the\n     /// borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n@@ -1217,13 +1217,13 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n+    /// Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// `RefMut::map(...)`. A method would interfere with methods of the same\n     /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Examples\n@@ -1253,7 +1253,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Split a `RefMut` into multiple `RefMut`s for different components of the\n+    /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n     /// borrowed data.\n     ///\n     /// The underlying `RefCell` will remain mutably borrowed until both\n@@ -1416,7 +1416,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n /// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n /// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples"}, {"sha": "133c9169df858c050e3bf536cb8b988c82dfd030", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -20,7 +20,7 @@ pub struct DecodeUtf16Error {\n     code: u16,\n }\n \n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`,\n /// returning unpaired surrogates as `Err`s.\n ///\n /// # Examples"}, {"sha": "122e5f3affdc2455cdd61db2dae60c9912ae339a", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -189,10 +189,8 @@ impl char {\n     /// An extended version of `escape_debug` that optionally permits escaping\n     /// Extended Grapheme codepoints. This allows us to format characters like\n     /// nonspacing marks better when they're at the start of a string.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"str_internals\", issue = \"0\")]\n     #[inline]\n-    pub fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n+    pub(crate) fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n             '\\r' => EscapeDefaultState::Backslash('r'),\n@@ -524,7 +522,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n     ///\n     /// # Examples\n     ///\n@@ -548,7 +546,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Start' is a Unicode Derived Property specified in\n@@ -562,7 +560,7 @@ impl char {\n         derived_property::XID_Start(self)\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n@@ -576,7 +574,7 @@ impl char {\n         derived_property::XID_Continue(self)\n     }\n \n-    /// Returns true if this `char` is lowercase, and false otherwise.\n+    /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n@@ -604,7 +602,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is uppercase, and false otherwise.\n+    /// Returns `true` if this `char` is uppercase.\n     ///\n     /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n@@ -632,7 +630,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is whitespace, and false otherwise.\n+    /// Returns `true` if this `char` is whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n     /// Property `White_Space`.\n@@ -659,7 +657,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is alphanumeric, and false otherwise.\n+    /// Returns `true` if this `char` is alphanumeric.\n     ///\n     /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n@@ -684,7 +682,7 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns true if this `char` is a control code point, and false otherwise.\n+    /// Returns `true` if this `char` is a control code point.\n     ///\n     /// 'Control code point' is defined in terms of the Unicode General\n     /// Category `Cc`.\n@@ -704,7 +702,7 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns true if this `char` is an extended grapheme character, and false otherwise.\n+    /// Returns `true` if this `char` is an extended grapheme character.\n     ///\n     /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n     /// Category `Grapheme_Extend`.\n@@ -713,7 +711,7 @@ impl char {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns true if this `char` is numeric, and false otherwise.\n+    /// Returns `true` if this `char` is numeric.\n     ///\n     /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No'."}, {"sha": "81fcdeee12d29e96614069f3b52e9ae79c2b8790", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -26,7 +26,7 @@ use self::Ordering::*;\n /// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):"}, {"sha": "4a7c6e15a4df1bf947384c8304ffc2cc290feb54", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -17,7 +17,10 @@\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n //! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n-//! blanket implementation in the standard library.\n+//! blanket implementation in the standard library.  However, there are some cases\n+//! where this is not possible, such as creating conversions into a type defined\n+//! outside your library, so implementing [`Into`] instead of [`From`] is\n+//! sometimes necessary.\n //!\n //! # Generic Implementations\n //!\n@@ -217,7 +220,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// There is one exception to implementing `Into`, and it's kind of esoteric.\n /// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly.  For example,\n+/// generic variable, then you can't implement `From` directly. For example,\n /// take this crate:\n ///\n /// ```compile_fail"}, {"sha": "5ad05b3824764f5ba3038c638357c988ce44a89b", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -54,7 +54,7 @@\n ///\n /// ## How can I implement `Default`?\n ///\n-/// Provide an implementation for the `default()` method that returns the value of\n+/// Provides an implementation for the `default()` method that returns the value of\n /// your type that should be the default:\n ///\n /// ```"}, {"sha": "d88793f2801e72abdf5449d8f8cf19b5ae66fa2c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -184,7 +184,7 @@ impl<'a> VaList<'a> {\n         va_arg(self)\n     }\n \n-    /// Copy the `va_list` at the current location.\n+    /// Copies the `va_list` at the current location.\n     #[unstable(feature = \"c_variadic\",\n                reason = \"the `c_variadic` feature has not been properly tested on \\\n                          all supported platforms\",\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// `va_copy`.\n     fn va_end(ap: &mut VaList);\n \n-    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    /// Copies the current location of arglist `src` to the arglist `dst`.\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                   not(target_arch = \"x86_64\")),\n               windows))]"}, {"sha": "2ce58c803b878ec2b153d063183b130fbe86b1e5", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -483,12 +483,12 @@ impl Display for Arguments<'_> {\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n-/// Pretty printing with `#?`:\n+/// Pretty-printing with `#?`:\n ///\n /// ```\n /// #[derive(Debug)]"}, {"sha": "02457e00054c8eb0f19f8d95a1d9a2300f53f942", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -61,7 +61,7 @@ pub trait Future {\n     /// progress, meaning that each time the current task is woken up, it should\n     /// actively re-`poll` pending futures that it still has an interest in.\n     ///\n-    /// The `poll` function is not called repeatedly in a tight loop-- instead,\n+    /// The `poll` function is not called repeatedly in a tight loop -- instead,\n     /// it should only be called when the future indicates that it is ready to\n     /// make progress (by calling `wake()`). If you're familiar with the\n     /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures"}, {"sha": "235c79307ab8dfa3b48844c165a55afdb288e063", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -10,7 +10,7 @@ use mem;\n /// An implementation of SipHash 1-3.\n ///\n /// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n+/// (e.g., `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n@@ -90,7 +90,7 @@ macro_rules! compress {\n     });\n }\n \n-/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n /// to load it from a possibly unaligned address.\n ///\n@@ -107,7 +107,7 @@ macro_rules! load_int_le {\n     });\n }\n \n-/// Load an u64 using up to 7 bytes of a byte slice.\n+/// Loads an u64 using up to 7 bytes of a byte slice.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "89de5c1bc8af80d5c2652849fe760ca5247e19d0", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -34,7 +34,7 @@ use intrinsics;\n ///     use std::hint::unreachable_unchecked;\n ///\n ///     // `b.saturating_add(1)` is always positive (not zero),\n-///     // hence `checked_div` will never return None.\n+///     // hence `checked_div` will never return `None`.\n ///     // Therefore, the else branch is unreachable.\n ///     a.checked_div(b.saturating_add(1))\n ///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })"}, {"sha": "9f0f6fd49fba1e930c41bfc08c4abc2b6d92d31f", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -75,3 +75,47 @@ macro_rules! forward_ref_op_assign {\n         }\n     }\n }\n+\n+/// Create a zero-size type similar to a closure type, but named.\n+#[unstable(feature = \"std_internals\", issue = \"0\")]\n+macro_rules! impl_fn_for_zst {\n+    ($(\n+        $( #[$attr: meta] )*\n+        // FIXME: when libcore is in the 2018 edition, use `?` repetition in\n+        // $( <$( $li : lifetime ),+> )?\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )* Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+            $body: block;\n+    )+) => {\n+        $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )* Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+    }\n+}"}, {"sha": "f6de7566be914281686e5109f20760886c7abfd0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-//! rustc compiler intrinsics.\n+//! Compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc_codegen_llvm/intrinsic.rs.\n+//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n //!\n //! # Volatiles\n //!\n@@ -315,35 +315,35 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -556,31 +556,31 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n@@ -697,7 +697,7 @@ extern \"rust-intrinsic\" {\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n     pub fn init<T>() -> T;\n@@ -857,7 +857,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n-    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // same `Vec` internals. Therefore, the new inner type must have the\n     /// // exact same size, and the same alignment, as the old type.\n     /// // The same caveats exist for this method as transmute, for\n     /// // the original inner type (`&i32`) to the converted inner type\n@@ -875,8 +875,8 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// use std::{slice, mem};\n     ///\n-    /// // There are multiple ways to do this; and there are multiple problems\n-    /// // with the following, transmute, way.\n+    /// // There are multiple ways to do this, and there are multiple problems\n+    /// // with the following (transmute) way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n     ///                              -> (&mut [T], &mut [T]) {\n     ///     let len = slice.len();\n@@ -988,7 +988,7 @@ extern \"rust-intrinsic\" {\n     ///   beginning at `dst` with the same size.\n     ///\n     /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1055,7 +1055,7 @@ extern \"rust-intrinsic\" {\n     /// [`copy_nonoverlapping`] can be used instead.\n     ///\n     /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped.  Copying takes place as if the bytes were copied from `src`\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n     /// to a temporary array and then copied from the array to `dst`.\n     ///\n     /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n@@ -1072,7 +1072,7 @@ extern \"rust-intrinsic\" {\n     /// * Both `src` and `dst` must be properly aligned.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1200,19 +1200,19 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// Perform a volatile load from the `src` pointer.\n+    /// Performs a volatile load from the `src` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n-    /// Perform a volatile load from the `src` pointer\n+    /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n "}, {"sha": "a3e9cfa94931297cfbfc32aab5fb55e81ddf2990", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -20,19 +20,19 @@ pub trait Step: Clone + PartialOrd + Sized {\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning itself\n+    /// Replaces this step with `1`, returning itself.\n     fn replace_one(&mut self) -> Self;\n \n-    /// Replaces this step with `0`, returning itself\n+    /// Replaces this step with `0`, returning itself.\n     fn replace_zero(&mut self) -> Self;\n \n-    /// Adds one to this step, returning the result\n+    /// Adds one to this step, returning the result.\n     fn add_one(&self) -> Self;\n \n-    /// Subtracts one to this step, returning the result\n+    /// Subtracts one to this step, returning the result.\n     fn sub_one(&self) -> Self;\n \n-    /// Add an usize, returning None on overflow\n+    /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n }\n "}, {"sha": "6f45f082d6a3714be887c7e1e001b92d6053742e", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -504,10 +504,8 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n /// [`FusedIterator`]: trait.FusedIterator.html\n /// [`Iterator::size_hint`]: trait.Iterator.html#method.size_hint\n ///\n-/// The closure can use its its captures and environment\n-/// to track state across iterations.\n-/// Depending on how the iterator is used,\n-/// this may require specifying the `move` keyword on the closure.\n+/// The closure can use captures and its environment to track state across iterations. Depending on\n+/// how the iterator is used, this may require specifying the `move` keyword on the closure.\n ///\n /// # Examples\n ///"}, {"sha": "d6eab40213edb0fe9902fb95838ca294a99c82e9", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -104,7 +104,7 @@ pub trait ExactSizeIterator: Iterator {\n         lower\n     }\n \n-    /// Returns whether the iterator is empty.\n+    /// Returns `true` if the iterator is empty.\n     ///\n     /// This method has a default implementation using `self.len()`, so you\n     /// don't need to implement it yourself."}, {"sha": "861e9c3157a790d51da98e72c698566f2b5b1391", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -120,7 +120,7 @@ pub trait Iterator {\n     /// // ... and then None once it's over.\n     /// assert_eq!(None, iter.next());\n     ///\n-    /// // More calls may or may not return None. Here, they always will.\n+    /// // More calls may or may not return `None`. Here, they always will.\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n@@ -564,9 +564,9 @@ pub trait Iterator {\n     /// Calls a closure on each element of an iterator.\n     ///\n     /// This is equivalent to using a [`for`] loop on the iterator, although\n-    /// `break` and `continue` are not possible from a closure.  It's generally\n+    /// `break` and `continue` are not possible from a closure. It's generally\n     /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n-    /// when processing items at the end of longer iterator chains.  In some\n+    /// when processing items at the end of longer iterator chains. In some\n     /// cases `for_each` may also be faster than a loop, because it will use\n     /// internal iteration on adaptors like `Chain`.\n     ///\n@@ -952,8 +952,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// The `3` is no longer there, because it was consumed in order to see if\n-    /// the iteration should stop, but wasn't placed back into the iterator or\n-    /// some similar thing.\n+    /// the iteration should stop, but wasn't placed back into the iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n@@ -1216,7 +1215,7 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(4));\n     /// assert_eq!(iter.next(), None);\n     ///\n-    /// // it will always return None after the first time.\n+    /// // it will always return `None` after the first time.\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n@@ -1516,7 +1515,7 @@ pub trait Iterator {\n     /// is propagated back to the caller immediately (short-circuiting).\n     ///\n     /// The initial value is the value the accumulator will have on the first\n-    /// call.  If applying the closure succeeded against every element of the\n+    /// call. If applying the closure succeeded against every element of the\n     /// iterator, `try_fold()` returns the final accumulator as success.\n     ///\n     /// Folding is useful whenever you have a collection of something, and want\n@@ -1529,10 +1528,10 @@ pub trait Iterator {\n     /// do something better than the default `for` loop implementation.\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n-    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// from which this iterator is composed. If multiple calls are needed,\n     /// the `?` operator may be convenient for chaining the accumulator value\n     /// along, but beware any invariants that need to be upheld before those\n-    /// early returns.  This is a `&mut self` method, so iteration needs to be\n+    /// early returns. This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples"}, {"sha": "419980225c3358840380b0b4fd2e2cc5775a0862", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -24,7 +24,7 @@\n //!   often generated by LLVM. Additionally, this library can make explicit\n //!   calls to these functions. Their signatures are the same as found in C.\n //!   These functions are often provided by the system libc, but can also be\n-//!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n+//!   provided by the [compiler-builtins crate](https://crates.io/crates/compiler_builtins).\n //!\n //! * `rust_begin_panic` - This function takes four arguments, a\n //!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n@@ -51,9 +51,7 @@\n #![cfg(not(test))]\n \n #![stable(feature = \"core\", since = \"1.6.0\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(deny(warnings))),\n@@ -97,6 +95,7 @@\n #![feature(simd_ffi)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "2eb506cedd4f83a02e951d1e9ad93f783bb4fe78", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,7 @@\n-/// Entry point of thread panic, for details, see std::macros\n+/// Entry point of thread panic. For details, see `std::macros`.\n #[macro_export]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(core_panic, __rust_unstable_column))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -409,7 +410,8 @@ macro_rules! write {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(format_args_nl))]\n macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")\n@@ -432,7 +434,7 @@ macro_rules! writeln {\n /// * Iterators that dynamically terminate.\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n-/// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n+/// program immediately terminates with a [`panic!`]. The function [`unreachable_unchecked`],\n /// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///\n@@ -493,7 +495,7 @@ macro_rules! unreachable {\n /// A standardized placeholder for marking unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck, or if you're implementing a trait that requires multiple\n+/// code type-check, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n /// # Panics\n@@ -555,12 +557,12 @@ macro_rules! unimplemented {\n #[macro_export]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n-    // This `into_inner` is safe because an array of `MaybeUninit` does not\n+    // This `into_initialized` is safe because an array of `MaybeUninit` does not\n     // require initialization.\n     // FIXME(#49147): Could be replaced by an array initializer, once those can\n     // be any const expression.\n     ($t:ty; $size:expr) => (unsafe {\n-        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_inner()\n+        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_initialized()\n     });\n }\n "}, {"sha": "2a493e88fe89617ccdb0121fb42befc58e5848a5", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 70, "deletions": 19, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -15,6 +15,7 @@ use ptr;\n use ops::{Deref, DerefMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use intrinsics::transmute;\n \n /// Takes ownership and \"forgets\" about the value **without running its destructor**.\n@@ -294,7 +295,7 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n@@ -402,7 +403,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns whether dropping values of type `T` matters.\n+/// Returns `true` if dropping values of type `T` matters.\n ///\n /// This is purely an optimization hint, and may be implemented conservatively:\n /// it may return `true` for types that don't actually need to be dropped.\n@@ -957,7 +958,7 @@ impl<T> ManuallyDrop<T> {\n         ManuallyDrop { value }\n     }\n \n-    /// Extract the value from the `ManuallyDrop` container.\n+    /// Extracts the value from the `ManuallyDrop` container.\n     ///\n     /// This allows the value to be dropped again.\n     ///\n@@ -1034,7 +1035,46 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A newtype to construct uninitialized instances of `T`\n+/// A newtype to construct uninitialized instances of `T`.\n+///\n+/// The compiler, in general, assumes that variables are properly initialized\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n+/// type causes instantaneous undefined behavior, no matter whether that reference\n+/// ever gets used to access memory:\n+///\n+/// ```rust,no_run\n+/// use std::mem;\n+///\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// ```\n+///\n+/// This is exploited by the compiler for various optimizations, such as eliding\n+/// run-time checks and optimizing `enum` layout.\n+///\n+/// Not initializing memory at all (instead of zero--initializing it) causes the same\n+/// issue: after all, the initial value of the variable might just happen to be\n+/// one that violates the invariant.\n+///\n+/// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n+/// it is a signal to the compiler indicating that the data here might *not*\n+/// be initialized:\n+///\n+/// ```rust\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::MaybeUninit;\n+///\n+/// // Create an explicitly uninitialized reference.\n+/// let mut x = MaybeUninit::<&i32>::uninitialized();\n+/// // Set it to a valid value.\n+/// x.set(&0);\n+/// // Extract the initialized data -- this is only allowed *after* properly\n+/// // initializing `x`!\n+/// let x = unsafe { x.into_initialized() };\n+/// ```\n+///\n+/// The compiler then knows to not optimize this code.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n // NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n@@ -1054,7 +1094,7 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit` in an uninitialized state.\n     ///\n     /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1064,8 +1104,8 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n@@ -1082,16 +1122,19 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n+    /// contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub fn set(&mut self, val: T) {\n+    pub fn set(&mut self, val: T) -> &mut T {\n         unsafe {\n             self.value = ManuallyDrop::new(val);\n+            self.get_mut()\n         }\n     }\n \n-    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n@@ -1101,12 +1144,20 @@ impl<T> MaybeUninit<T> {\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub unsafe fn into_inner(self) -> T {\n+    pub unsafe fn into_initialized(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n-    /// Get a reference to the contained value.\n+    /// Deprecated alternative to `into_initialized`. Will never get stabilized.\n+    /// Exists only to transition stdsimd to `into_initialized`.\n+    #[inline(always)]\n+    #[allow(unused)]\n+    pub(crate) unsafe fn into_inner(self) -> T {\n+        self.into_initialized()\n+    }\n+\n+    /// Gets a reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1118,7 +1169,7 @@ impl<T> MaybeUninit<T> {\n         &*self.value\n     }\n \n-    /// Get a mutable reference to the contained value.\n+    /// Gets a mutable reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1133,30 +1184,30 @@ impl<T> MaybeUninit<T> {\n         &mut *self.value\n     }\n \n-    /// Get a pointer to the contained value. Reading from this pointer will be undefined\n-    /// behavior unless the `MaybeUninit` is initialized.\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n-    /// Get a mutable pointer to the contained value. Reading from this pointer will be undefined\n-    /// behavior unless the `MaybeUninit` is initialized.\n+    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Get a pointer to the first element of the array.\n+    /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n-    /// Get a mutable pointer to the first element of the array.\n+    /// Gets a mutable pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {"}, {"sha": "3b57bb7544b35bb3b8b18d4422f01527ab7da3c3", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -61,7 +61,7 @@ mod fpu_precision {\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n-    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n+    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n     pub fn set_precision<T>() -> FPUControlWord {\n         let cw = 0u16;\n "}, {"sha": "47ea5aa5ff000b8c8b1b08f8656375112e4b0802", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -37,7 +37,7 @@\n //!\n //! In addition, there are numerous helper functions that are used in the paper but not available\n //! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n-//! overflow and underflow and the desire to handle subnormal numbers.  Bellerophon and\n+//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n //! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n //! Algorithm M (with the modifications described in section 8 of the paper) well before the\n //! inputs get into the critical region.\n@@ -54,7 +54,7 @@\n //! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n //! and round *exactly once, at the end*, by considering all truncated bits at once.\n //!\n-//! FIXME Although some code duplication is necessary, perhaps parts of the code could be shuffled\n+//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n //! around such that less code is duplicated. Large parts of the algorithms are independent of the\n //! float type to output, or only needs access to a few constants, which could be passed in as\n //! parameters.\n@@ -148,7 +148,7 @@ macro_rules! from_str_float_impl {\n             /// # Return value\n             ///\n             /// `Err(ParseFloatError)` if the string did not represent a valid\n-            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n             /// number represented by `src`.\n             #[inline]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n@@ -209,7 +209,7 @@ fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n-/// Split decimal string into sign and the rest, without inspecting or validating the rest.\n+/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\n fn extract_sign(s: &str) -> (Sign, &str) {\n     match s.as_bytes()[0] {\n         b'+' => (Sign::Positive, &s[1..]),\n@@ -219,7 +219,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n     }\n }\n \n-/// Convert a decimal string into a floating point number.\n+/// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n         return Err(pfe_empty())"}, {"sha": "126713185711b3fecd0a4046e8e8bf4c0bee8ccc", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -27,7 +27,7 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n     Equal\n }\n \n-/// Convert an ASCII string containing only decimal digits to a `u64`.\n+/// Converts an ASCII string containing only decimal digits to a `u64`.\n ///\n /// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n /// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n@@ -44,7 +44,7 @@ pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'\n     result\n }\n \n-/// Convert a string of ASCII digits into a bignum.\n+/// Converts a string of ASCII digits into a bignum.\n ///\n /// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n@@ -69,7 +69,7 @@ pub fn to_u64(x: &Big) -> u64 {\n }\n \n \n-/// Extract a range of bits.\n+/// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual.\n /// Panics if asked to extract more bits than fit into the return type."}, {"sha": "933f8c1d3f781e959c7dbe309a92fbc9ca784bb6", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -42,7 +42,7 @@ pub enum ParseResult<'a> {\n     Invalid,\n }\n \n-/// Check if the input string is a valid floating point number and if so, locate the integral\n+/// Checks if the input string is a valid floating point number and if so, locate the integral\n /// part, the fractional part, and the exponent in it. Does not handle signs.\n pub fn parse_decimal(s: &str) -> ParseResult {\n     if s.is_empty() {"}, {"sha": "b65f539b29c97c105df01ada310443a104a0eb9f", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -59,10 +59,10 @@ pub trait RawFloat\n     /// Type used by `to_bits` and `from_bits`.\n     type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n \n-    /// Raw transmutation to integer.\n+    /// Performs a raw transmutation to an integer.\n     fn to_bits(self) -> Self::Bits;\n \n-    /// Raw transmutation from integer.\n+    /// Performs a raw transmutation from an integer.\n     fn from_bits(v: Self::Bits) -> Self;\n \n     /// Returns the category that this number falls into.\n@@ -71,14 +71,14 @@ pub trait RawFloat\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Decode the float.\n+    /// Decodes the float.\n     fn unpack(self) -> Unpacked;\n \n-    /// Cast from a small integer that can be represented exactly.  Panic if the integer can't be\n+    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10<sup>e</sup> from a pre-computed table.\n+    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n     /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n     fn short_fast_pow10(e: usize) -> Self;\n \n@@ -240,7 +240,7 @@ impl RawFloat for f64 {\n     fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n-/// Convert an Fp to the closest machine float type.\n+/// Converts an `Fp` to the closest machine float type.\n /// Does not handle subnormal results.\n pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let x = x.normalize();\n@@ -319,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     }\n }\n \n-/// Find the largest floating point number strictly smaller than the argument.\n+/// Finds the largest floating point number strictly smaller than the argument.\n /// Does not handle subnormals, zero, or exponent underflow.\n pub fn prev_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {"}, {"sha": "dc0580764acb74838221593997cb5a194337c153", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f32\"]\n #[cfg(not(test))]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -169,8 +169,8 @@ impl f32 {\n         f32::from_bits(self.to_bits() & 0x7fff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -272,7 +272,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -288,7 +288,7 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "c3677f8c8faea466532e864c1d68110fff0ffc3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f64\"]\n #[cfg(not(test))]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -169,8 +169,8 @@ impl f64 {\n         f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -272,7 +272,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -296,7 +296,7 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "6fb67ea9c9acbf7536caccc37ca7282618b8ddd5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -52,7 +52,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n             }\n \n             impl $Ty {\n-                /// Create a non-zero without checking the value.\n+                /// Creates a non-zero without checking the value.\n                 ///\n                 /// # Safety\n                 ///\n@@ -63,7 +63,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                     $Ty(n)\n                 }\n \n-                /// Create a non-zero if the given value is not zero.\n+                /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n@@ -882,17 +882,38 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_add(rhs) {\n                     Some(x) => x,\n                     None if rhs >= 0 => Self::max_value(),\n                     None => Self::min_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_add(self, rhs)\n-                }\n+            }\n+\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n+bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n+\"::max_value());\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n             }\n         }\n \n@@ -912,17 +933,36 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_sub(rhs) {\n                     Some(x) => x,\n                     None if rhs >= 0 => Self::min_value(),\n                     None => Self::max_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_sub(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n+assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n+\"::min_value());\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n             }\n         }\n \n@@ -2753,16 +2793,34 @@ assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_add(rhs) {\n                     Some(x) => x,\n                     None => Self::max_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_add(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n+the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n             }\n         }\n \n@@ -2780,16 +2838,33 @@ assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_sub(rhs) {\n                     Some(x) => x,\n                     None => Self::min_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_sub(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\n+at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n+assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n             }\n         }\n "}, {"sha": "0252edee231254a0afe3e0786e3701cd5cfb5669", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -49,7 +49,7 @@\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Add<Output=T>> Add for Point<T> {\n+/// impl<T: Add<Output = T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn add(self, other: Point<T>) -> Point<T> {\n@@ -157,7 +157,7 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Sub<Output=T>> Sub for Point<T> {\n+/// impl<T: Sub<Output = T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn sub(self, other: Point<T>) -> Point<T> {\n@@ -518,7 +518,7 @@ pub trait Rem<RHS=Self> {\n \n macro_rules! rem_impl_integer {\n     ($($t:ty)*) => ($(\n-        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// This operation satisfies `n % d == n - (n / d) * d`. The\n         /// result has the same sign as the left operand.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {"}, {"sha": "c69f5fd989696d5d1d3f50b15ec9a1aed8b36163", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -62,7 +62,7 @@\n     label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait Fn<Args> : FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -141,7 +141,7 @@ pub trait Fn<Args> : FnMut<Args> {\n     label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -220,7 +220,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n     label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]"}, {"sha": "b3dd5d20299c1706ec50582ca7f1cf8180b64d86", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -52,7 +52,7 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.  It is empty unless `start < end`.\n+/// `x < end`. It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n@@ -297,7 +297,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// A range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.  It is empty unless `start <= end`.\n+/// and `x <= end`. It is empty unless `start <= end`.\n ///\n /// This iterator is [fused], but the specific values of `start` and `end` after\n /// iteration has finished are **unspecified** other than that [`.is_empty()`]"}, {"sha": "9fa2c81954ee16a8ffc4a31bf6cd4f94f525f15f", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n /// A trait for customizing the behavior of the `?` operator.\n ///\n /// A type implementing `Try` is one that has a canonical way to view it\n-/// in terms of a success/failure dichotomy.  This trait allows both\n+/// in terms of a success/failure dichotomy. This trait allows both\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "76ef36ac30962d19dfef4a5792f742b03ee0bbb5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -214,7 +214,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n     /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -395,7 +395,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n     ///\n     /// [`String`]: ../../std/string/struct.String.html\n     /// [`usize`]: ../../std/primitive.usize.html\n@@ -963,7 +963,7 @@ impl<T: Default> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning\n     /// [`None`] on error."}, {"sha": "ee9098d73ee92ff8ad2933dbfd7ea0a5c91e9602", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -199,7 +199,7 @@ impl<P: Deref> Pin<P> {\n         Pin { pointer }\n     }\n \n-    /// Get a pinned shared reference from this pinned pointer.\n+    /// Gets a pinned shared reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -208,7 +208,7 @@ impl<P: Deref> Pin<P> {\n }\n \n impl<P: DerefMut> Pin<P> {\n-    /// Get a pinned mutable reference from this pinned pointer.\n+    /// Gets a pinned mutable reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n@@ -247,7 +247,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n         Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Get a shared reference out of a pin.\n+    /// Gets a shared reference out of a pin.\n     ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n@@ -262,14 +262,14 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n-    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// This requires that the data inside this `Pin` is `Unpin`.\n     ///\n@@ -286,7 +286,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         self.pointer\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// # Safety\n     ///"}, {"sha": "866c8d0896b3c637a714d13dd8f4106b115ae98b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -12,7 +12,7 @@\n //! to access only a single value, in which case the documentation omits the size\n //! and implicitly assumes it to be `size_of::<T>()` bytes.\n //!\n-//! The precise rules for validity are not determined yet.  The guarantees that are\n+//! The precise rules for validity are not determined yet. The guarantees that are\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n@@ -104,7 +104,7 @@ pub use intrinsics::write_bytes;\n ///\n /// * `to_drop` must be [valid] for reads.\n ///\n-/// * `to_drop` must be properly aligned.  See the example below for how to drop\n+/// * `to_drop` must be properly aligned. See the example below for how to drop\n ///   an unaligned pointer.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n@@ -135,7 +135,7 @@ pub use intrinsics::write_bytes;\n /// unsafe {\n ///     // Get a raw pointer to the last element in `v`.\n ///     let ptr = &mut v[1] as *mut _;\n-///     // Shorten `v` to prevent the last item from being dropped.  We do that first,\n+///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n ///     // to prevent issues if the `drop_in_place` below panics.\n ///     v.set_len(1);\n ///     // Without a call `drop_in_place`, the last item would never be dropped,\n@@ -531,7 +531,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n ///\n /// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n /// If `T` is not [`Copy`], using both the returned value and the value at\n-/// `*src` can violate memory safety.  Note that assigning to `*src` counts as a\n+/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n /// [`write`] can be used to overwrite data without causing it to be dropped.\n@@ -573,7 +573,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp = MaybeUninit::<T>::uninitialized();\n     copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.into_inner()\n+    tmp.into_initialized()\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -588,7 +588,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// * `src` must be [valid] for reads.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n@@ -642,7 +642,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     copy_nonoverlapping(src as *const u8,\n                         tmp.as_mut_ptr() as *mut u8,\n                         mem::size_of::<T>());\n-    tmp.into_inner()\n+    tmp.into_initialized()\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -825,7 +825,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -839,7 +839,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// * `src` must be properly aligned.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n@@ -903,7 +903,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -1093,7 +1093,7 @@ impl<T: ?Sized> *const T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -1712,7 +1712,7 @@ impl<T: ?Sized> *mut T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -2473,7 +2473,7 @@ impl<T: ?Sized> PartialEq for *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Eq for *mut T {}\n \n-/// Compare raw pointers for equality.\n+/// Compares raw pointers for equality.\n ///\n /// This is the same as using the `==` operator, but less generic:\n /// the arguments have to be `*const T` raw pointers,"}, {"sha": "92d29f6ee8a30c83ba9ec50c9cbf7983c61fc22b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -896,7 +896,7 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n     /// [`Err`] on error."}, {"sha": "cbba546b8dabad1137a3cc235c199cad5a424faa", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -11,7 +11,7 @@ const HI_U64: u64 = 0x8080808080808080;\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n \n-/// Returns whether `x` contains any zero byte.\n+/// Returns `true` if `x` contains any zero byte.\n ///\n /// From *Matters Computational*, J. Arndt:\n ///"}, {"sha": "acca9748372ca15b521a7e4c82a37aa481f1092b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1197,7 +1197,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -3145,7 +3145,7 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -3247,7 +3247,7 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n     /// to consume the iterator.\n@@ -4123,7 +4123,7 @@ pub struct ChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4247,7 +4247,7 @@ pub struct ChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4619,7 +4619,7 @@ pub struct RChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4744,7 +4744,7 @@ pub struct RChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "9b35b51349a02612de93e6f276f6316a1ab7cfcf", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -26,7 +26,7 @@ impl<T> RawArray<T> {\n }\n \n /// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n-/// becomes the first element.  Equivalently, rotates the range `left`\n+/// becomes the first element. Equivalently, rotates the range `left`\n /// elements to the left or `right` elements to the right.\n ///\n /// # Safety\n@@ -36,10 +36,10 @@ impl<T> RawArray<T> {\n /// # Algorithm\n ///\n /// For longer rotations, swap the left-most `delta = min(left, right)`\n-/// elements with the right-most `delta` elements.  LLVM vectorizes this,\n+/// elements with the right-most `delta` elements. LLVM vectorizes this,\n /// which is profitable as we only reach this step for a \"large enough\"\n-/// rotation.  Doing this puts `delta` elements on the larger side into the\n-/// correct position, leaving a smaller rotate problem.  Demonstration:\n+/// rotation. Doing this puts `delta` elements on the larger side into the\n+/// correct position, leaving a smaller rotate problem. Demonstration:\n ///\n /// ```text\n /// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]"}, {"sha": "363eae04f039c6d080fc6e7ef281f5a2ed41402c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 274, "deletions": 145, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,17 +1,20 @@\n-//! String manipulation\n+//! String manipulation.\n //!\n-//! For more details, see std::str\n+//! For more details, see the `std::str` module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use fmt;\n+use fmt::{self, Write};\n use iter::{Map, Cloned, FusedIterator, TrustedLen, TrustedRandomAccess, Filter};\n+use iter::{Flatten, FlatMap, Chain};\n use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n+use ops::Try;\n+use option;\n \n pub mod pattern;\n \n@@ -226,7 +229,7 @@ impl Utf8Error {\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n \n-    /// Provide more information about the failure:\n+    /// Provides more information about the failure:\n     ///\n     /// * `None`: the end of the input was reached unexpectedly.\n     ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n@@ -612,7 +615,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n impl FusedIterator for Chars<'_> {}\n \n impl<'a> Chars<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -702,7 +705,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n impl FusedIterator for CharIndices<'_> {}\n \n impl<'a> CharIndices<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -1345,33 +1348,14 @@ impl FusedIterator for Lines<'_> {}\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, cloneable fn type\n-#[derive(Clone)]\n-struct LinesAnyMap;\n-\n-impl<'a> Fn<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n+impl_fn_for_zst! {\n+    /// A nameable, cloneable fn type\n+    #[derive(Clone)]\n+    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n         let l = line.len();\n         if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n         else { line }\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&*self, (line,))\n-    }\n-}\n-\n-impl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n-    type Output = &'a str;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&self, (line,))\n-    }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1579,9 +1563,9 @@ mod traits {\n \n     /// Implements ordering of strings.\n     ///\n-    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n+    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1607,9 +1591,9 @@ mod traits {\n \n     /// Implements comparison operations on strings.\n     ///\n-    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n+    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2643,7 +2627,7 @@ impl str {\n         Bytes(self.as_bytes().iter().cloned())\n     }\n \n-    /// Split a string slice by whitespace.\n+    /// Splits a string slice by whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of whitespace.\n@@ -2686,7 +2670,7 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n-    /// Split a string slice by ASCII whitespace.\n+    /// Splits a string slice by ASCII whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of ASCII whitespace.\n@@ -2727,7 +2711,7 @@ impl str {\n         let inner = self\n             .as_bytes()\n             .split(IsAsciiWhitespace)\n-            .filter(IsNotEmpty)\n+            .filter(BytesIsNotEmpty)\n             .map(UnsafeBytesToStr);\n         SplitAsciiWhitespace { inner }\n     }\n@@ -2961,8 +2945,8 @@ impl str {\n     /// An iterator over substrings of this string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3078,8 +3062,8 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3128,8 +3112,8 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// Equivalent to [`split`], except that the trailing substring\n     /// is skipped if empty.\n@@ -3175,8 +3159,8 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     /// Additional libraries might provide more complex patterns like\n     /// regular expressions.\n     ///\n@@ -3222,8 +3206,8 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3275,8 +3259,8 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3319,8 +3303,8 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3504,7 +3488,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3541,7 +3525,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3787,7 +3771,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3819,7 +3803,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3964,6 +3948,146 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// Note: only extended grapheme codepoints that begin the string will be\n+    /// escaped.\n+    ///\n+    /// [`char::escape_debug`]: ../std/primitive.char.html#method.escape_debug\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_debug() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_debug());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\u2764\\\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_debug().to_string(), \"\u2764\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_debug(&self) -> EscapeDebug {\n+        let mut chars = self.chars();\n+        EscapeDebug {\n+            inner: chars.next()\n+                .map(|first| first.escape_debug_ext(true))\n+                .into_iter()\n+                .flatten()\n+                .chain(chars.flat_map(CharEscapeDebugContinue))\n+        }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: ../std/primitive.char.html#method.escape_default\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_default() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_default());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_default(&self) -> EscapeDefault {\n+        EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: ../std/primitive.char.html#method.escape_unicode\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_unicode() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_unicode());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_unicode(&self) -> EscapeUnicode {\n+        EscapeUnicode { inner: self.chars().flat_map(CharEscapeUnicode) }\n+    }\n+}\n+\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n+        c.escape_debug_ext(false)\n+    };\n+\n+    #[derive(Clone)]\n+    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n+        c.escape_unicode()\n+    };\n+    #[derive(Clone)]\n+    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n+        c.escape_default()\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4011,102 +4135,36 @@ pub struct SplitWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n-}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsAsciiWhitespace;\n-\n-impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n-        self.call_mut(arg)\n-    }\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n-impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n-        arg.0.is_ascii_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n-\n-impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct IsWhitespace impl Fn = |c: char| -> bool {\n+        c.is_whitespace()\n+    };\n \n-#[derive(Clone)]\n-struct UnsafeBytesToStr;\n+    #[derive(Clone)]\n+    struct IsAsciiWhitespace impl Fn = |byte: &u8| -> bool {\n+        byte.is_ascii_whitespace()\n+    };\n \n-impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n-    type Output = &'a str;\n+    #[derive(Clone)]\n+    struct IsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b str| -> bool {\n+        !s.is_empty()\n+    };\n \n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n-        self.call_mut(arg)\n-    }\n-}\n+    #[derive(Clone)]\n+    struct BytesIsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b [u8]| -> bool {\n+        !s.is_empty()\n+    };\n \n-impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n-        unsafe { from_utf8_unchecked(arg.0) }\n-    }\n+    #[derive(Clone)]\n+    struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        unsafe { from_utf8_unchecked(bytes) }\n+    };\n }\n \n-\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n@@ -4216,3 +4274,74 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EncodeUtf16<'_> {}\n+\n+/// The return type of [`str::escape_debug`].\n+///\n+/// [`str::escape_debug`]: ../../std/primitive.str.html#method.escape_debug\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug<'a> {\n+    inner: Chain<\n+        Flatten<option::IntoIter<char::EscapeDebug>>,\n+        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>\n+    >,\n+}\n+\n+/// The return type of [`str::escape_default`].\n+///\n+/// [`str::escape_default`]: ../../std/primitive.str.html#method.escape_default\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDefault<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n+}\n+\n+/// The return type of [`str::escape_unicode`].\n+///\n+/// [`str::escape_unicode`]: ../../std/primitive.str.html#method.escape_unicode\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeUnicode<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n+}\n+\n+macro_rules! escape_types_impls {\n+    ($( $Name: ident ),+) => {$(\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> fmt::Display for $Name<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                self.clone().try_for_each(|c| f.write_char(c))\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> Iterator for $Name<'a> {\n+            type Item = char;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<char> { self.inner.next() }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+            #[inline]\n+            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+            {\n+                self.inner.try_fold(init, fold)\n+            }\n+\n+            #[inline]\n+            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n+            {\n+                self.inner.fold(init, fold)\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> FusedIterator for $Name<'a> {}\n+    )+}\n+}\n+\n+escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "2571780ad0bab11987bd02cff0fb79cdb30ac55a", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n //! The string Pattern API.\n //!\n-//! For more details, see the traits `Pattern`, `Searcher`,\n-//! `ReverseSearcher` and `DoubleEndedSearcher`.\n+//! For more details, see the traits [`Pattern`], [`Searcher`],\n+//! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n #![unstable(feature = \"pattern\",\n             reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -117,7 +117,7 @@ pub unsafe trait Searcher<'a> {\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next()`\n+    /// Finds the next `Match` result. See `next()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_reject will overlap. This will return (start_match, end_match),\n@@ -134,7 +134,7 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next `Reject` result. See `next()` and `next_match()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_match will overlap.\n@@ -185,7 +185,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next_back()`\n+    /// Finds the next `Match` result. See `next_back()`\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -197,7 +197,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next_back()`\n+    /// Finds the next `Reject` result. See `next_back()`\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n         loop {"}, {"sha": "c811f96ace3baba30f317458db80230eaca8837e", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -7,6 +7,7 @@ use result::Result;\n \n /// Indicates whether a value is available or if the current task has been\n /// scheduled to receive a wakeup instead.\n+#[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n@@ -21,7 +22,7 @@ pub enum Poll<T> {\n }\n \n impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n+    /// Changes the ready value of this `Poll` with the closure provided.\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n         where F: FnOnce(T) -> U\n     {\n@@ -31,7 +32,7 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Ready`\n+    /// Returns `true` if this is `Poll::Ready`\n     #[inline]\n     pub fn is_ready(&self) -> bool {\n         match *self {\n@@ -40,15 +41,15 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Pending`\n+    /// Returns `true` if this is `Poll::Pending`\n     #[inline]\n     pub fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n }\n \n impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n+    /// Changes the success value of this `Poll` with the closure provided.\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n         where F: FnOnce(T) -> U\n     {\n@@ -59,7 +60,7 @@ impl<T, E> Poll<Result<T, E>> {\n         }\n     }\n \n-    /// Change the error value of this `Poll` with the closure provided\n+    /// Changes the error value of this `Poll` with the closure provided.\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n         where F: FnOnce(E) -> U\n     {"}, {"sha": "73bdaab5861e6bb3f62a7309f0f9360c0bf696b8", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use core::cell::*;\n use core::default::Default;\n use std::mem::drop;"}, {"sha": "b10b63fc484cb820985485f35cb9201c64503d0b", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n mod builders;\n mod float;\n mod num;"}, {"sha": "bf3039a7e51e8c33c9c503ae48ebfc495fd3d2a0", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n mod sip;\n \n use std::hash::{Hash, Hasher};"}, {"sha": "51a6017de1b5fead95d446117fa7f452118da28f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -190,6 +190,7 @@ fn test_iterator_step_by() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_iterator_step_by_nth() {\n     let mut it = (0..16).step_by(5);\n     assert_eq!(it.nth(0), Some(0));\n@@ -208,6 +209,7 @@ fn test_iterator_step_by_nth() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_iterator_step_by_nth_overflow() {\n     #[cfg(target_pointer_width = \"8\")]\n     type Bigger = u16;\n@@ -253,12 +255,14 @@ fn test_iterator_step_by_nth_overflow() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_iterator_step_by_zero() {\n     let mut it = (0..).step_by(0);\n     it.next();\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_iterator_step_by_size_hint() {\n     struct StubSizeHint(usize, Option<usize>);\n     impl Iterator for StubSizeHint {\n@@ -877,7 +881,7 @@ fn test_iterator_flat_map() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `FlatMap::fold` with items already picked off the front and back,\n+/// Tests `FlatMap::fold` with items already picked off the front and back,\n /// to make sure all parts of the `FlatMap` are folded correctly.\n #[test]\n fn test_iterator_flat_map_fold() {\n@@ -915,7 +919,7 @@ fn test_iterator_flatten() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `Flatten::fold` with items already picked off the front and back,\n+/// Tests `Flatten::fold` with items already picked off the front and back,\n /// to make sure all parts of the `Flatten` are folded correctly.\n #[test]\n fn test_iterator_flatten_fold() {\n@@ -1413,6 +1417,7 @@ fn test_rposition() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_rposition_panic() {\n     let v: [(Box<_>, Box<_>); 4] =\n         [(box 0, box 0), (box 0, box 0),\n@@ -1652,6 +1657,7 @@ fn test_range_inclusive_nth() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_range_step() {\n     #![allow(deprecated)]\n \n@@ -1675,13 +1681,15 @@ fn test_range_step() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_step_by_skip() {\n     assert_eq!((0..640).step_by(128).skip(1).collect::<Vec<_>>(), [128, 256, 384, 512]);\n     assert_eq!((0..=50).step_by(10).nth(3), Some(30));\n     assert_eq!((200..=255u8).step_by(10).nth(3), Some(230));\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_range_inclusive_step() {\n     assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);\n     assert_eq!((0..=5).step_by(1).collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5]);"}, {"sha": "ab638e06cc10dbcfc31d65d5c3ed9b4426234763", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use core::convert::{TryFrom, TryInto};\n use core::cmp::PartialEq;\n use core::fmt::Debug;"}, {"sha": "1ba886ce037ee0eaf426c42e6b2b2241abade460", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -69,6 +69,7 @@ fn test_option_dance() {\n }\n \n #[test] #[should_panic]\n+#[cfg(not(miri))]\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -129,13 +130,15 @@ fn test_unwrap() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_unwrap_panic1() {\n     let x: Option<isize> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();"}, {"sha": "5784559082266336e030a0050ac452cd0881ffe0", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use core::ptr::*;\n use core::cell::RefCell;\n "}, {"sha": "7bfd396f68d1700212979c8f6d2c9a217527d99b", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -117,6 +117,7 @@ fn test_unwrap_or_else() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))]\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n@@ -138,6 +139,7 @@ pub fn test_expect_ok() {\n }\n #[test]\n #[should_panic(expected=\"Got expected error: \\\"All good\\\"\")]\n+#[cfg(not(miri))]\n pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n@@ -151,6 +153,7 @@ pub fn test_expect_err_err() {\n }\n #[test]\n #[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n+#[cfg(not(miri))]\n pub fn test_expect_err_ok() {\n     let err: Result<&'static str, isize> = Ok(\"All good\");\n     err.expect_err(\"Got expected ok\");"}, {"sha": "04d646ea01d038842c2709ce328d633a17fd1f9f", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -782,6 +782,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n+    #[cfg(not(miri))]\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n@@ -791,6 +792,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n+    #[cfg(not(miri))]\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n@@ -840,6 +842,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))]\n                 fn index_fail() {\n                     let v = $data;\n                     let v: &[_] = &v;\n@@ -848,6 +851,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))]\n                 fn index_mut_fail() {\n                     let mut v = $data;\n                     let v: &mut [_] = &mut v;\n@@ -1011,6 +1015,7 @@ fn test_rotate_right() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(miri))]\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n@@ -1166,6 +1171,7 @@ pub mod memchr {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_align_to_simple() {\n     let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n@@ -1181,6 +1187,7 @@ fn test_align_to_simple() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_align_to_zst() {\n     let bytes = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<()>() };\n@@ -1189,6 +1196,7 @@ fn test_align_to_zst() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_align_to_non_trivial() {\n     #[repr(align(8))] struct U64(u64, u64);\n     #[repr(align(8))] struct U64U64U32(u64, u64, u32);\n@@ -1200,6 +1208,7 @@ fn test_align_to_non_trivial() {\n }\n \n #[test]\n+#[cfg(not(miri))]\n fn test_align_to_empty_mid() {\n     use core::mem;\n \n@@ -1297,6 +1306,7 @@ fn test_copy_within() {\n \n #[test]\n #[should_panic(expected = \"src is out of bounds\")]\n+#[cfg(not(miri))]\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1305,13 +1315,15 @@ fn test_copy_within_panics_src_too_long() {\n \n #[test]\n #[should_panic(expected = \"dest is out of bounds\")]\n+#[cfg(not(miri))]\n fn test_copy_within_panics_dest_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n #[should_panic(expected = \"src end is before src start\")]\n+#[cfg(not(miri))]\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "d39bd06930a36a83eb715a47733384ee5a993d82", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use core::time::Duration;\n \n #[test]"}, {"sha": "ac7e11754aa3a21955d9036134dd0ce055140403", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -43,7 +43,7 @@ pub const NANOSECOND: Duration = Duration::from_nanos(1);\n /// timeouts.\n ///\n /// Each `Duration` is composed of a whole number of seconds and a fractional part\n-/// represented in nanoseconds.  If the underlying system does not support\n+/// represented in nanoseconds. If the underlying system does not support\n /// nanosecond-level precision, APIs binding a system timeout will typically round up\n /// the number of nanoseconds.\n ///\n@@ -515,7 +515,7 @@ impl Duration {\n         }\n     }\n \n-    /// Multiply `Duration` by `f64`.\n+    /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n     /// This method will panic if result is not finite, negative or overflows `Duration`."}, {"sha": "50779a2d9ad08d526e5c9a02def260618c422fe7", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"fmt_macros\""}, {"sha": "aacd6cec565a5a971576f7ae79cf00e273387f67", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,20 +4,20 @@\n //! Parsing does not happen at runtime: structures of `std::fmt::rt` are\n //! generated instead.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n #![feature(rustc_private)]\n \n-pub use self::Piece::*;\n-pub use self::Position::*;\n-pub use self::Alignment::*;\n-pub use self::Flag::*;\n-pub use self::Count::*;\n+pub use Piece::*;\n+pub use Position::*;\n+pub use Alignment::*;\n+pub use Flag::*;\n+pub use Count::*;\n \n use std::str;\n use std::string;"}, {"sha": "a6a3c1a249d64285e1fbb154f766f196fa926909", "filename": "src/libgraphviz/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibgraphviz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibgraphviz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"graphviz\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"graphviz\""}, {"sha": "489020d4ee778483ed03fbbc801b799ddf390284", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -271,15 +271,14 @@\n //!\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n-#![feature(str_escape)]\n \n-use self::LabelText::*;\n+use LabelText::*;\n \n use std::borrow::Cow;\n use std::io::prelude::*;\n@@ -393,7 +392,7 @@ impl<'a> Id<'a> {\n     /// digit (i.e., the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n     ///\n     /// (Note: this format is a strict subset of the `ID` format\n-    /// defined by the DOT language.  This function may change in the\n+    /// defined by the DOT language. This function may change in the\n     /// future to accept a broader subset, or the entirety, of DOT's\n     /// `ID` format.)\n     ///\n@@ -530,15 +529,15 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Decomposes content into string suitable for making EscStr that\n-    /// yields same content as self.  The result obeys the law\n+    /// yields same content as self. The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n             LabelStr(s) => {\n                 if s.contains('\\\\') {\n-                    (&*s).escape_default().into()\n+                    (&*s).escape_default().to_string().into()\n                 } else {\n                     s\n                 }\n@@ -548,12 +547,12 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Puts `prefix` on a line above this label, with a blank line separator.\n-    pub fn prefix_line(self, prefix: LabelText) -> LabelText<'static> {\n+    pub fn prefix_line(self, prefix: LabelText<'_>) -> LabelText<'static> {\n         prefix.suffix_line(self)\n     }\n \n     /// Puts `suffix` on a line below this label, with a blank line separator.\n-    pub fn suffix_line(self, suffix: LabelText) -> LabelText<'static> {\n+    pub fn suffix_line(self, suffix: LabelText<'_>) -> LabelText<'static> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n@@ -686,7 +685,7 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n \n #[cfg(test)]\n mod tests {\n-    use self::NodeLabels::*;\n+    use NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n     use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n     use std::io;"}, {"sha": "2bee0b716c750f4836068ea38b85e74cceb09b7d", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"panic_abort\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "edc97cd28a52af89d4d65147286cdf864904c821", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,12 +5,12 @@\n \n #![no_std]\n #![unstable(feature = \"panic_abort\", issue = \"32837\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n #![panic_runtime]\n+\n #![allow(unused_features)]\n+#![deny(rust_2018_idioms)]\n \n #![feature(core_intrinsics)]\n #![feature(libc)]\n@@ -46,7 +46,6 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n \n     #[cfg(any(unix, target_os = \"cloudabi\"))]\n     unsafe fn abort() -> ! {\n-        extern crate libc;\n         libc::abort();\n     }\n "}, {"sha": "3a00d6376658c1a64751ddd349181ff7325ab23c", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-//! Unwinding for wasm32\n+//! Unwinding for *wasm32* target.\n //!\n-//! Right now we don't support this, so this is just stubs\n+//! Right now we don't support this, so this is just stubs.\n \n use alloc::boxed::Box;\n use core::any::Any;"}, {"sha": "ce24406b556420af262f0b33198014ad95367132", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,7 +6,7 @@\n //!   http://www.airs.com/blog/archives/464\n //!\n //! A reference implementation may be found in the GCC source tree\n-//! (<root>/libgcc/unwind-c.c as of this writing)\n+//! (`<root>/libgcc/unwind-c.c` as of this writing).\n \n #![allow(non_upper_case_globals)]\n #![allow(unused)]"}, {"sha": "0360696426dc94ba8441e7c1cbdc9bfb6a1bb671", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for parsing DWARF-encoded data streams.\n-//! See http://www.dwarfstd.org,\n+//! See <http://www.dwarfstd.org>,\n //! DWARF-4 standard, Section 7 - \"Data Representation\"\n \n // This module is used only by x86_64-pc-windows-gnu for now, but we"}, {"sha": "1f5ccfb0f121032070fb484dff5150b82e90bcca", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n-//! Unwinding for emscripten\n+//! Unwinding for *emscripten* target.\n //!\n //! Whereas Rust's usual unwinding implementation for Unix platforms\n-//! calls into the libunwind APIs directly, on emscripten we instead\n+//! calls into the libunwind APIs directly, on Emscripten we instead\n //! call into the C++ unwinding APIs. This is just an expedience since\n-//! emscripten's runtime always implements those APIs and does not\n+//! Emscripten's runtime always implements those APIs and does not\n //! implement libunwind.\n \n #![allow(private_no_mangle_fns)]"}, {"sha": "607fe28e3f28de7021de6bded40a5825be2f25f1", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-//! Implementation of panics backed by libgcc/libunwind (in some form)\n+//! Implementation of panics backed by libgcc/libunwind (in some form).\n //!\n //! For background on exception handling and stack unwinding please see\n //! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n@@ -23,14 +23,14 @@\n //!\n //! In the search phase, the job of a personality routine is to examine\n //! exception object being thrown, and to decide whether it should be caught at\n-//! that stack frame.  Once the handler frame has been identified, cleanup phase\n+//! that stack frame. Once the handler frame has been identified, cleanup phase\n //! begins.\n //!\n //! In the cleanup phase, the unwinder invokes each personality routine again.\n //! This time it decides which (if any) cleanup code needs to be run for\n-//! the current stack frame.  If so, the control is transferred to a special\n+//! the current stack frame. If so, the control is transferred to a special\n //! branch in the function body, the \"landing pad\", which invokes destructors,\n-//! frees memory, etc.  At the end of the landing pad, control is transferred\n+//! frees memory, etc. At the end of the landing pad, control is transferred\n //! back to the unwinder and unwinding resumes.\n //!\n //! Once stack has been unwound down to the handler frame level, unwinding stops\n@@ -39,7 +39,7 @@\n //! ## `eh_personality` and `eh_unwind_resume`\n //!\n //! These language items are used by the compiler when generating unwind info.\n-//! The first one is the personality routine described above.  The second one\n+//! The first one is the personality routine described above. The second one\n //! allows compilation target to customize the process of resuming unwind at the\n //! end of the landing pads. `eh_unwind_resume` is used only if\n //! `custom_unwind_resume` flag in the target options is set."}, {"sha": "fa7a0916d429bc10074a55f75ceba5be9954018d", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -14,9 +14,7 @@\n \n #![no_std]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n \n #![feature(allocator_api)]"}, {"sha": "b3d0ee94f0e12f4ae52f3bc48ebb144dd2aca443", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "0d8cc552d61ab3cdbd86ec1d39f1d6527ddb3aa9", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,7 +6,7 @@ use std::ops::{Deref, DerefMut};\n use std::slice;\n \n #[repr(C)]\n-struct Slice<'a, T: 'a> {\n+struct Slice<'a, T> {\n     data: &'a [T; 0],\n     len: usize,\n }\n@@ -42,7 +42,7 @@ pub struct Buffer<T: Copy> {\n     data: *mut T,\n     len: usize,\n     capacity: usize,\n-    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<T>) -> Buffer<T>,\n+    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<'_, T>) -> Buffer<T>,\n     drop: extern \"C\" fn(Buffer<T>),\n }\n \n@@ -139,7 +139,7 @@ impl<T: Copy> From<Vec<T>> for Buffer<T> {\n             }\n         }\n \n-        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<T>) -> Buffer<T> {\n+        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<'_, T>) -> Buffer<T> {\n             let mut v = to_vec(b);\n             v.extend_from_slice(&xs);\n             Buffer::from(v)"}, {"sha": "b198bdb144699908a7c1feb4a2ed411722912d29", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -66,7 +66,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n                 for Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n                     s.$oty.take(handle::Handle::decode(r, &mut ()))\n                 }\n             }\n@@ -80,7 +80,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n                 for &'s Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n                     &s.$oty[handle::Handle::decode(r, &mut ())]\n                 }\n             }\n@@ -94,7 +94,10 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n                 for &'s mut Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &'s mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(\n+                    r: &mut Reader<'_>,\n+                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n+                ) -> Self {\n                     &mut s.$oty[handle::Handle::decode(r, &mut ())]\n                 }\n             }\n@@ -108,7 +111,7 @@ macro_rules! define_handles {\n             }\n \n             impl<S> DecodeMut<'_, '_, S> for $oty {\n-                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                     $oty(handle::Handle::decode(r, s))\n                 }\n             }\n@@ -130,7 +133,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n                 for Marked<S::$ity, $ity>\n             {\n-                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n                     s.$ity.copy(handle::Handle::decode(r, &mut ()))\n                 }\n             }\n@@ -144,7 +147,7 @@ macro_rules! define_handles {\n             }\n \n             impl<S> DecodeMut<'_, '_, S> for $ity {\n-                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                     $ity(handle::Handle::decode(r, s))\n                 }\n             }\n@@ -200,7 +203,7 @@ impl Clone for Literal {\n \n // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n     }\n }\n@@ -212,7 +215,7 @@ impl Clone for SourceFile {\n }\n \n impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n     }\n }\n@@ -275,7 +278,7 @@ impl BridgeState<'_> {\n     ///\n     /// N.B., while `f` is running, the thread-local state\n     /// is `BridgeState::InUse`.\n-    fn with<R>(f: impl FnOnce(&mut BridgeState) -> R) -> R {\n+    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n         BRIDGE_STATE.with(|state| {\n             state.replace(BridgeState::InUse, |mut state| {\n                 // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n@@ -306,7 +309,7 @@ impl Bridge<'_> {\n         BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n     }\n \n-    fn with<R>(f: impl FnOnce(&mut Bridge) -> R) -> R {\n+    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n         BridgeState::with(|state| match state {\n             BridgeState::NotConnected => {\n                 panic!(\"procedural macro API is used outside of a procedural macro\");\n@@ -331,15 +334,15 @@ impl Bridge<'_> {\n #[derive(Copy, Clone)]\n pub struct Client<F> {\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-    pub(super) run: extern \"C\" fn(Bridge, F) -> Buffer<u8>,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n     pub(super) f: F,\n }\n \n // FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n // affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n pub extern \"C\" fn __run_expand1(\n-    mut bridge: Bridge,\n-    f: fn(::TokenStream) -> ::TokenStream,\n+    mut bridge: Bridge<'_>,\n+    f: fn(crate::TokenStream) -> crate::TokenStream,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n@@ -352,7 +355,7 @@ pub extern \"C\" fn __run_expand1(\n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(::TokenStream(input)).0;\n+            let output = f(crate::TokenStream(input)).0;\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -378,8 +381,8 @@ pub extern \"C\" fn __run_expand1(\n     b\n }\n \n-impl Client<fn(::TokenStream) -> ::TokenStream> {\n-    pub const fn expand1(f: fn(::TokenStream) -> ::TokenStream) -> Self {\n+impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+    pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n         Client {\n             get_handle_counters: HandleCounters::get,\n             run: __run_expand1,\n@@ -391,8 +394,8 @@ impl Client<fn(::TokenStream) -> ::TokenStream> {\n // FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n // affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n pub extern \"C\" fn __run_expand2(\n-    mut bridge: Bridge,\n-    f: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+    mut bridge: Bridge<'_>,\n+    f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n@@ -406,7 +409,7 @@ pub extern \"C\" fn __run_expand2(\n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(::TokenStream(input), ::TokenStream(input2)).0;\n+            let output = f(crate::TokenStream(input), crate::TokenStream(input2)).0;\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -432,8 +435,10 @@ pub extern \"C\" fn __run_expand2(\n     b\n }\n \n-impl Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n-    pub const fn expand2(f: fn(::TokenStream, ::TokenStream) -> ::TokenStream) -> Self {\n+impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+    pub const fn expand2(\n+        f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream\n+    ) -> Self {\n         Client {\n             get_handle_counters: HandleCounters::get,\n             run: __run_expand2,\n@@ -448,25 +453,25 @@ pub enum ProcMacro {\n     CustomDerive {\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n     },\n \n     Attr {\n         name: &'static str,\n-        client: Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n     },\n \n     Bang {\n         name: &'static str,\n-        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n     },\n }\n \n impl ProcMacro {\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        expand: fn(::TokenStream) -> ::TokenStream,\n+        expand: fn(crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::CustomDerive {\n             trait_name,\n@@ -477,15 +482,18 @@ impl ProcMacro {\n \n     pub const fn attr(\n         name: &'static str,\n-        expand: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::Attr {\n             name,\n             client: Client::expand2(expand),\n         }\n     }\n \n-    pub const fn bang(name: &'static str, expand: fn(::TokenStream) -> ::TokenStream) -> Self {\n+    pub const fn bang(\n+        name: &'static str,\n+        expand: fn(crate::TokenStream) -> crate::TokenStream\n+    ) -> Self {\n         ProcMacro::Bang {\n             name,\n             client: Client::expand1(expand),"}, {"sha": "3173651b0395128bf59232f23578b63854881cc0", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -17,7 +17,7 @@ use std::panic;\n use std::sync::atomic::AtomicUsize;\n use std::sync::Once;\n use std::thread;\n-use {Delimiter, Level, LineColumn, Spacing};\n+use crate::{Delimiter, Level, LineColumn, Spacing};\n \n /// Higher-order macro describing the server RPC API, allowing automatic\n /// generation of type-safe Rust APIs, both client-side and server-side.\n@@ -196,9 +196,9 @@ mod scoped_cell;\n #[forbid(unsafe_code)]\n pub mod server;\n \n-use self::buffer::Buffer;\n-pub use self::rpc::PanicMessage;\n-use self::rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n+use buffer::Buffer;\n+pub use rpc::PanicMessage;\n+use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n \n /// An active connection between a server and a client.\n /// The server creates the bridge (`Bridge::run_server` in `server.rs`),"}, {"sha": "a3bc0d229084679e232db6d554c626647cac6022", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -40,7 +40,7 @@ macro_rules! rpc_encode_decode {\n         }\n \n         impl<S> DecodeMut<'_, '_, S> for $ty {\n-            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                 let mut byte = 0x80;\n                 let mut v = 0;\n                 let mut shift = 0;\n@@ -61,7 +61,7 @@ macro_rules! rpc_encode_decode {\n         }\n \n         impl<S> DecodeMut<'_, '_, S> for $name {\n-            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                 $name {\n                     $($field: DecodeMut::decode(r, s)),*\n                 }\n@@ -119,7 +119,7 @@ impl<S> Encode<S> for () {\n }\n \n impl<S> DecodeMut<'_, '_, S> for () {\n-    fn decode(_: &mut Reader, _: &mut S) -> Self {}\n+    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n }\n \n impl<S> Encode<S> for u8 {\n@@ -129,7 +129,7 @@ impl<S> Encode<S> for u8 {\n }\n \n impl<S> DecodeMut<'_, '_, S> for u8 {\n-    fn decode(r: &mut Reader, _: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n         let x = r[0];\n         *r = &r[1..];\n         x\n@@ -146,7 +146,7 @@ impl<S> Encode<S> for bool {\n }\n \n impl<S> DecodeMut<'_, '_, S> for bool {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         match u8::decode(r, s) {\n             0 => false,\n             1 => true,\n@@ -162,7 +162,7 @@ impl<S> Encode<S> for char {\n }\n \n impl<S> DecodeMut<'_, '_, S> for char {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         char::from_u32(u32::decode(r, s)).unwrap()\n     }\n }\n@@ -174,7 +174,7 @@ impl<S> Encode<S> for NonZeroU32 {\n }\n \n impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         Self::new(u32::decode(r, s)).unwrap()\n     }\n }\n@@ -251,7 +251,7 @@ impl<S> Encode<S> for String {\n }\n \n impl<S> DecodeMut<'_, '_, S> for String {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         <&str>::decode(r, s).to_string()\n     }\n }\n@@ -306,7 +306,7 @@ impl<S> Encode<S> for PanicMessage {\n }\n \n impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         match Option::<String>::decode(r, s) {\n             Some(s) => PanicMessage::String(s),\n             None => PanicMessage::Unknown,"}, {"sha": "6f7965095b638504873c644ccc7a6804234cd6e4", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -38,7 +38,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         ScopedCell(Cell::new(value))\n     }\n \n-    /// Set the value in `self` to `replacement` while\n+    /// Sets the value in `self` to `replacement` while\n     /// running `f`, which gets the old value, mutably.\n     /// The old value will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n@@ -73,7 +73,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n     }\n \n-    /// Set the value in `self` to `value` while running `f`.\n+    /// Sets the value in `self` to `value` while running `f`.\n     pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n         self.replace(value, |_| f())\n     }"}, {"sha": "75806eb9d17602edbae8da9143391ba067d81897", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -131,7 +131,7 @@ pub trait ExecutionStrategy {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8>;\n }\n@@ -143,7 +143,7 @@ impl ExecutionStrategy for SameThread {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         let mut dispatch = |b| dispatcher.dispatch(b);\n@@ -168,7 +168,7 @@ impl ExecutionStrategy for CrossThread1 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         use std::sync::mpsc::channel;\n@@ -206,7 +206,7 @@ impl ExecutionStrategy for CrossThread2 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         use std::sync::{Arc, Mutex};\n@@ -273,7 +273,7 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n     client_data: D,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher = Dispatcher {\n@@ -289,7 +289,7 @@ fn run_server<\n     Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n }\n \n-impl client::Client<fn(::TokenStream) -> ::TokenStream> {\n+impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n@@ -313,7 +313,7 @@ impl client::Client<fn(::TokenStream) -> ::TokenStream> {\n     }\n }\n \n-impl client::Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n+impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,"}, {"sha": "65eebb5ec37374a47fcbf356ac7e5e390d8316b8", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use Span;\n+use crate::Span;\n \n /// An enum representing a diagnostic level.\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -56,7 +56,7 @@ pub struct Diagnostic {\n \n macro_rules! diagnostic_child_methods {\n     ($spanned:ident, $regular:ident, $level:expr) => (\n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -67,7 +67,7 @@ macro_rules! diagnostic_child_methods {\n             self\n         }\n \n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n@@ -80,7 +80,7 @@ macro_rules! diagnostic_child_methods {\n /// Iterator over the children diagnostics of a `Diagnostic`.\n #[derive(Debug, Clone)]\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n-pub struct Children<'a>(::std::slice::Iter<'a, Diagnostic>);\n+pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl<'a> Iterator for Children<'a> {\n@@ -93,7 +93,7 @@ impl<'a> Iterator for Children<'a> {\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl Diagnostic {\n-    /// Create a new diagnostic with the given `level` and `message`.\n+    /// Creates a new diagnostic with the given `level` and `message`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n@@ -104,7 +104,7 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Create a new diagnostic with the given `level` and `message` pointing to\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n     /// the given set of `spans`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n@@ -161,22 +161,22 @@ impl Diagnostic {\n \n     /// Returns an iterator over the children diagnostics of `self`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n-    pub fn children(&self) -> Children {\n+    pub fn children(&self) -> Children<'_> {\n         Children(self.children.iter())\n     }\n \n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> ::bridge::client::MultiSpan {\n-            let mut multi_span = ::bridge::client::MultiSpan::new();\n+        fn to_internal(spans: Vec<Span>) -> crate::bridge::client::MultiSpan {\n+            let mut multi_span = crate::bridge::client::MultiSpan::new();\n             for span in spans {\n                 multi_span.push(span.0);\n             }\n             multi_span\n         }\n \n-        let mut diag = ::bridge::client::Diagnostic::new(\n+        let mut diag = crate::bridge::client::Diagnostic::new(\n             self.level,\n             &self.message[..],\n             to_internal(self.spans),"}, {"sha": "238f8f635415b5a1a9cbcb411b29392411087b11", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -9,14 +9,14 @@\n \n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #![deny(missing_docs)]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(const_fn)]\n@@ -89,7 +89,7 @@ impl TokenStream {\n /// or characters not existing in the language.\n /// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n-/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n@@ -114,15 +114,15 @@ impl ToString for TokenStream {\n /// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n /// Prints token in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(\"TokenStream \")?;\n         f.debug_list().entries(self.clone()).finish()\n     }\n@@ -183,7 +183,7 @@ impl Extend<TokenStream> for TokenStream {\n /// Public implementation details for the `TokenStream` type, such as iterators.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub mod token_stream {\n-    use {bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n+    use crate::{bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n@@ -245,7 +245,7 @@ impl !Sync for Span {}\n \n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n-        /// Create a new `Diagnostic` with the given `message` at the span\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n@@ -291,19 +291,19 @@ impl Span {\n         Span(self.0.source())\n     }\n \n-    /// Get the starting line/column in the source file for this span.\n+    /// Gets the starting line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn start(&self) -> LineColumn {\n         self.0.start()\n     }\n \n-    /// Get the ending line/column in the source file for this span.\n+    /// Gets the ending line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn end(&self) -> LineColumn {\n         self.0.end()\n     }\n \n-    /// Create a new span encompassing `self` and `other`.\n+    /// Creates a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n@@ -340,7 +340,7 @@ impl Span {\n /// Prints a span in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n@@ -369,7 +369,7 @@ impl !Sync for LineColumn {}\n pub struct SourceFile(bridge::client::SourceFile);\n \n impl SourceFile {\n-    /// Get the path to this source file.\n+    /// Gets the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n@@ -398,7 +398,7 @@ impl SourceFile {\n \n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl fmt::Debug for SourceFile {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SourceFile\")\n             .field(\"path\", &self.path())\n             .field(\"is_real\", &self.is_real())\n@@ -483,7 +483,7 @@ impl TokenTree {\n /// Prints token tree in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Each of these has the name in the struct type in the derived debug,\n         // so don't bother with an extra layer of indirection\n         match *self {\n@@ -542,7 +542,7 @@ impl ToString for TokenTree {\n /// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n@@ -667,14 +667,14 @@ impl ToString for Group {\n /// with `Delimiter::None` delimiters.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Group\")\n             .field(\"delimiter\", &self.delimiter())\n             .field(\"stream\", &self.stream())\n@@ -763,14 +763,14 @@ impl ToString for Punct {\n /// back into the same character.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Punct\")\n             .field(\"ch\", &self.as_char())\n             .field(\"spacing\", &self.spacing())\n@@ -842,14 +842,14 @@ impl ToString for Ident {\n /// back into the same identifier.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Ident\")\n             .field(\"ident\", &self.to_string())\n             .field(\"span\", &self.span())\n@@ -1092,14 +1092,14 @@ impl ToString for Literal {\n /// back into the same literal (except for possible rounding for floating point literals).\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n         self.0.fmt(f)\n     }"}, {"sha": "e3d31b78f4a09258b398160bd9185d5f2671e80a", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,7 +4,7 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+use crate::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n \n macro_rules! quote_tt {\n     (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n@@ -63,7 +63,7 @@ macro_rules! quote {\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {\n-        return quote!(::TokenStream::new());\n+        return quote!(crate::TokenStream::new());\n     }\n     let mut after_dollar = false;\n     let tokens = stream\n@@ -73,7 +73,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                 after_dollar = false;\n                 match tree {\n                     TokenTree::Ident(_) => {\n-                        return Some(quote!(Into::<::TokenStream>::into(\n+                        return Some(quote!(Into::<crate::TokenStream>::into(\n                         Clone::clone(&(@ tree))),));\n                     }\n                     TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n@@ -86,33 +86,33 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                 }\n             }\n \n-            Some(quote!(::TokenStream::from((@ match tree {\n-                TokenTree::Punct(tt) => quote!(::TokenTree::Punct(::Punct::new(\n+            Some(quote!(crate::TokenStream::from((@ match tree {\n+                TokenTree::Punct(tt) => quote!(crate::TokenTree::Punct(crate::Punct::new(\n                     (@ TokenTree::from(Literal::character(tt.as_char()))),\n                     (@ match tt.spacing() {\n-                        Spacing::Alone => quote!(::Spacing::Alone),\n-                        Spacing::Joint => quote!(::Spacing::Joint),\n+                        Spacing::Alone => quote!(crate::Spacing::Alone),\n+                        Spacing::Joint => quote!(crate::Spacing::Joint),\n                     }),\n                 ))),\n-                TokenTree::Group(tt) => quote!(::TokenTree::Group(::Group::new(\n+                TokenTree::Group(tt) => quote!(crate::TokenTree::Group(crate::Group::new(\n                     (@ match tt.delimiter() {\n-                        Delimiter::Parenthesis => quote!(::Delimiter::Parenthesis),\n-                        Delimiter::Brace => quote!(::Delimiter::Brace),\n-                        Delimiter::Bracket => quote!(::Delimiter::Bracket),\n-                        Delimiter::None => quote!(::Delimiter::None),\n+                        Delimiter::Parenthesis => quote!(crate::Delimiter::Parenthesis),\n+                        Delimiter::Brace => quote!(crate::Delimiter::Brace),\n+                        Delimiter::Bracket => quote!(crate::Delimiter::Bracket),\n+                        Delimiter::None => quote!(crate::Delimiter::None),\n                     }),\n                     (@ quote(tt.stream())),\n                 ))),\n-                TokenTree::Ident(tt) => quote!(::TokenTree::Ident(::Ident::new(\n+                TokenTree::Ident(tt) => quote!(crate::TokenTree::Ident(crate::Ident::new(\n                     (@ TokenTree::from(Literal::string(&tt.to_string()))),\n                     (@ quote_span(tt.span())),\n                 ))),\n-                TokenTree::Literal(tt) => quote!(::TokenTree::Literal({\n+                TokenTree::Literal(tt) => quote!(crate::TokenTree::Literal({\n                     let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n-                        .parse::<::TokenStream>()\n+                        .parse::<crate::TokenStream>()\n                         .unwrap()\n                         .into_iter();\n-                    if let (Some(::TokenTree::Literal(mut lit)), None) =\n+                    if let (Some(crate::TokenTree::Literal(mut lit)), None) =\n                         (iter.next(), iter.next())\n                     {\n                         lit.set_span((@ quote_span(tt.span())));\n@@ -129,12 +129,12 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n         panic!(\"unexpected trailing `$` in `quote!`\");\n     }\n \n-    quote!([(@ tokens)].iter().cloned().collect::<::TokenStream>())\n+    quote!([(@ tokens)].iter().cloned().collect::<crate::TokenStream>())\n }\n \n /// Quote a `Span` into a `TokenStream`.\n /// This is needed to implement a custom quoter.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote_span(_: Span) -> TokenStream {\n-    quote!(::Span::def_site())\n+    quote!(crate::Span::def_site())\n }"}, {"sha": "0d36bd0b39d76b69a3f7e835e5e5c579828425f4", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,6 +3,7 @@ authors = [\"The Rust Project Developers\"]\n build = \"build.rs\"\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"profiler_builtins\""}, {"sha": "ff52a03d9dd9725fc0fed1c280be447e1ff7dec9", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,8 +2,6 @@\n //!\n //! See the build.rs for libcompiler_builtins crate for details.\n \n-extern crate cc;\n-\n use std::env;\n use std::path::Path;\n "}, {"sha": "2ce1a110b44c0c8f8d080599ee008f71a7f0dabb", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -7,3 +7,4 @@\n #![allow(unused_features)]\n #![feature(nll)]\n #![feature(staged_api)]\n+#![deny(rust_2018_idioms)]"}, {"sha": "c9a04f4c6834da2f571c2b26f9bc2167dbfeb106", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc\""}, {"sha": "f7ffbe8c65833af10c0a040c39df216296a7cd42", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,11 +1,11 @@\n-use cfg::*;\n-use middle::region;\n+use crate::cfg::*;\n+use crate::middle::region;\n use rustc_data_structures::graph::implementation as graph;\n use syntax::ptr::P;\n-use ty::{self, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n \n-use hir::{self, PatKind};\n-use hir::def_id::DefId;\n+use crate::hir::{self, PatKind};\n+use crate::hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -99,7 +99,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let hir_id = self.tcx.hir().node_to_hir_id(stmt.id);\n         let exit = match stmt.node {\n             hir::StmtKind::Local(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n@@ -113,7 +112,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.expr(&expr, pred)\n             }\n         };\n-        self.add_ast_node(hir_id.local_id, &[exit])\n+        self.add_ast_node(stmt.hir_id.local_id, &[exit])\n     }\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {"}, {"sha": "969c38bd663298142a3501de55325566ca8f999f", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,9 +4,9 @@\n // For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use cfg;\n-use hir;\n-use ty::TyCtxt;\n+use crate::cfg;\n+use crate::hir;\n+use crate::ty::TyCtxt;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;"}, {"sha": "345dff88b5f0b14e1b481b9d9ff294ef9527e908", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,9 +2,9 @@\n //! Uses `Graph` as the underlying representation.\n \n use rustc_data_structures::graph::implementation as graph;\n-use ty::TyCtxt;\n-use hir;\n-use hir::def_id::DefId;\n+use crate::ty::TyCtxt;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;"}, {"sha": "13f6f9533297340d1b52c052f72cf32977d1e6e2", "filename": "src/librustc/dep_graph/cgu_reuse_tracker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,7 +2,7 @@\n //! compilation. This is used for incremental compilation tests and debug\n //! output.\n \n-use session::Session;\n+use crate::session::Session;\n use rustc_data_structures::fx::FxHashMap;\n use std::sync::{Arc, Mutex};\n use syntax_pos::Span;"}, {"sha": "f18ee3dced72d10c0e47de8af2c0ba7ef341f630", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -22,7 +22,7 @@ impl DepNodeFilter {\n         }\n     }\n \n-    /// True if all nodes always pass the filter.\n+    /// Returns `true` if all nodes always pass the filter.\n     pub fn accepts_all(&self) -> bool {\n         self.text.is_empty()\n     }"}, {"sha": "796739c8721741df37065610fe8e541524dd4bb7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -49,25 +49,25 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use mir::interpret::GlobalId;\n-use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n-use hir::map::DefPathHash;\n-use hir::HirId;\n+use crate::mir::interpret::GlobalId;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use crate::hir::map::DefPathHash;\n+use crate::hir::HirId;\n \n-use ich::{Fingerprint, StableHashingContext};\n+use crate::ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits;\n-use traits::query::{\n+use crate::traits;\n+use crate::traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n     CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n-use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n+use crate::ty::{TyCtxt, FnSig, Instance, InstanceDef,\n          ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n+use crate::ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n@@ -302,7 +302,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Create a new, parameterless DepNode. This method will assert\n+            /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n             #[inline(always)]\n@@ -314,7 +314,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Extract the DefId corresponding to this DepNode. This will work\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n             /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n@@ -389,7 +389,7 @@ impl fmt::Debug for DepNode {\n \n         write!(f, \"(\")?;\n \n-        ::ty::tls::with_opt(|opt_tcx| {\n+        crate::ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n                 if let Some(def_id) = self.extract_def_id(tcx) {\n                     write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n@@ -798,7 +798,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These ids do not have a DefId but rather\n+/// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n@@ -825,6 +825,6 @@ impl WorkProductId {\n     }\n }\n \n-impl_stable_hash_for!(struct ::dep_graph::WorkProductId {\n+impl_stable_hash_for!(struct crate::dep_graph::WorkProductId {\n     hash\n });"}, {"sha": "94b832bea628ef915287bb3e293191aa27764173", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use util::common::MemoizationMap;\n+use crate::util::common::MemoizationMap;\n \n use super::{DepKind, DepNodeIndex, DepGraph};\n \n@@ -43,7 +43,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// Here, `[op]` represents whatever nodes `op` reads in the\n     /// course of execution; `Map(key)` represents the node for this\n-    /// map; and `CurrentTask` represents the current task when\n+    /// map, and `CurrentTask` represents the current task when\n     /// `memoize` is invoked.\n     ///\n     /// **Important:** when `op` is invoked, the current task will be"}, {"sha": "59ec459de964160d70b9161ca67dd17a8ae234b5", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 82, "deletions": 63, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n+use crate::errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -7,11 +7,11 @@ use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n-use ty::{self, TyCtxt};\n-use util::common::{ProfileQueriesMsg, profq_msg};\n+use crate::ty::{self, TyCtxt};\n+use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n-use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n+use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n@@ -61,13 +61,13 @@ struct DepGraphData {\n \n     colors: DepNodeColorMap,\n \n-    /// A set of loaded diagnostics which has been emitted.\n+    /// A set of loaded diagnostics that have been emitted.\n     emitted_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n \n     /// Used to wait for diagnostics to be emitted.\n     emitted_diagnostics_cond_var: Condvar,\n \n-    /// When we load, there may be `.o` files, cached mir, or other such\n+    /// When we load, there may be `.o` files, cached MIR, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n@@ -79,6 +79,16 @@ struct DepGraphData {\n     loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n+pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+where\n+    R: for<'a> HashStable<StableHashingContext<'a>>,\n+{\n+    let mut stable_hasher = StableHasher::new();\n+    result.hash_stable(hcx, &mut stable_hasher);\n+\n+    Some(stable_hasher.finish())\n+}\n+\n impl DepGraph {\n \n     pub fn new(prev_graph: PreviousDepGraph,\n@@ -105,7 +115,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// True if we are actually building the full dep-graph.\n+    /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n         self.data.is_some()\n@@ -178,14 +188,16 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc guide]: https://rust-lang.github.io/rustc-guide/incremental-compilation.html\n-    pub fn with_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    pub fn with_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_key| Some(TaskDeps {\n@@ -196,17 +208,18 @@ impl DepGraph {\n             }),\n             |data, key, fingerprint, task| {\n                 data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     /// Creates a new dep-graph input with value `input`\n-    pub fn input_task<'gcx, C, R>(&self,\n+    pub fn input_task<'a, C, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    input: R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'a>,\n+              R: for<'b> HashStable<StableHashingContext<'b>>,\n     {\n         fn identity_fn<C, A>(_: C, arg: A) -> A {\n             arg\n@@ -216,10 +229,11 @@ impl DepGraph {\n             |_| None,\n             |data, key, fingerprint, _| {\n                 data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n-            })\n+            },\n+            hash_result::<R>)\n     }\n \n-    fn with_task_impl<'gcx, C, A, R>(\n+    fn with_task_impl<'a, C, A, R>(\n         &self,\n         key: DepNode,\n         cx: C,\n@@ -230,11 +244,11 @@ impl DepGraph {\n         finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n                                           DepNode,\n                                           Fingerprint,\n-                                          Option<TaskDeps>) -> DepNodeIndex\n+                                          Option<TaskDeps>) -> DepNodeIndex,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-        R: HashStable<StableHashingContext<'gcx>>,\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(|deps| Lock::new(deps));\n@@ -269,31 +283,33 @@ impl DepGraph {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let mut stable_hasher = StableHasher::new();\n-            result.hash_stable(&mut hcx, &mut stable_hasher);\n-\n-            let current_fingerprint = stable_hasher.finish();\n+            let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode(\n                 &data.current,\n                 key,\n-                current_fingerprint,\n+                current_fingerprint.unwrap_or(Fingerprint::ZERO),\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n                 let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if current_fingerprint == prev_fingerprint {\n-                    DepNodeColor::Green(dep_node_index)\n+                let color = if let Some(current_fingerprint) = current_fingerprint {\n+                    if current_fingerprint == prev_fingerprint {\n+                        DepNodeColor::Green(dep_node_index)\n+                    } else {\n+                        DepNodeColor::Red\n+                    }\n                 } else {\n+                    // Mark the node as Red if we can't hash the result\n                     DepNodeColor::Red\n                 };\n \n                 debug_assert!(data.colors.get(prev_index).is_none(),\n-                              \"DepGraph::with_task() - Duplicate DepNodeColor \\\n-                               insertion for {:?}\", key);\n+                            \"DepGraph::with_task() - Duplicate DepNodeColor \\\n+                            insertion for {:?}\", key);\n \n                 data.colors.insert(prev_index, color);\n             }\n@@ -304,8 +320,8 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"anonymous\" task, that is, a task the\n-    /// DepNode of which is determined by the list of inputs it read from.\n+    /// Executes something within an \"anonymous\" task, that is, a task the\n+    /// `DepNode` of which is determined by the list of inputs it read from.\n     pub fn with_anon_task<OP,R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n         where OP: FnOnce() -> R\n     {\n@@ -340,16 +356,18 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"eval-always\" task which is a task\n-    // that runs whenever anything changes.\n-    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    /// Executes something within an \"eval-always\" task which is a task\n+    /// that runs whenever anything changes.\n+    pub fn with_eval_always_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n@@ -359,7 +377,8 @@ impl DepGraph {\n                     &DepNode::new_no_params(DepKind::Krate)\n                 ];\n                 current.alloc_node(key, smallvec![krate_idx], fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     #[inline]\n@@ -419,7 +438,7 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n-    /// Check whether a previous work product exists for `v` and, if\n+    /// Checks whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n         self.data\n@@ -570,7 +589,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// Try to mark a dep-node which existed in the previous compilation session as green\n+    /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'tcx>,\n@@ -669,7 +688,7 @@ impl DepGraph {\n                     // We failed to mark it green, so we try to force the query.\n                     debug!(\"try_mark_previous_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n-                    if ::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n+                    if crate::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n@@ -754,8 +773,8 @@ impl DepGraph {\n         Some(dep_node_index)\n     }\n \n-    /// Atomically emits some loaded diagnotics assuming that this only gets called with\n-    /// did_allocation set to true on one thread\n+    /// Atomically emits some loaded diagnotics, assuming that this only gets called with\n+    /// `did_allocation` set to `true` on a single thread.\n     #[cold]\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n@@ -894,7 +913,7 @@ impl DepGraph {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved files associated with this CGU\n+    /// Saved files associated with this CGU.\n     pub saved_files: Vec<(WorkProductFileKind, String)>,\n }\n \n@@ -918,17 +937,17 @@ pub(super) struct CurrentDepGraph {\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n-    // Anonymous DepNodes are nodes the ID of which we compute from the list of\n-    // their edges. This has the beneficial side-effect that multiple anonymous\n-    // nodes can be coalesced into one without changing the semantics of the\n-    // dependency graph. However, the merging of nodes can lead to a subtle\n-    // problem during red-green marking: The color of an anonymous node from\n-    // the current session might \"shadow\" the color of the node with the same\n-    // ID from the previous session. In order to side-step this problem, we make\n-    // sure that anon-node IDs allocated in different sessions don't overlap.\n-    // This is implemented by mixing a session-key into the ID fingerprint of\n-    // each anon node. The session-key is just a random number generated when\n-    // the DepGraph is created.\n+    /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n+    /// their edges. This has the beneficial side-effect that multiple anonymous\n+    /// nodes can be coalesced into one without changing the semantics of the\n+    /// dependency graph. However, the merging of nodes can lead to a subtle\n+    /// problem during red-green marking: The color of an anonymous node from\n+    /// the current session might \"shadow\" the color of the node with the same\n+    /// ID from the previous session. In order to side-step this problem, we make\n+    /// sure that anonymous `NodeId`s allocated in different sessions don't overlap.\n+    /// This is implemented by mixing a session-key into the ID fingerprint of\n+    /// each anon node. The session-key is just a random number generated when\n+    /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n     total_read_count: u64,"}, {"sha": "b84d2ad145889bf1fab96fc39d908e98c508a874", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -10,7 +10,7 @@ pub mod cgu_reuse_tracker;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "d971690bbe317788f2cd887289fd8fbabcc3c049", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use ich::Fingerprint;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use super::dep_node::DepNode;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};"}, {"sha": "fc767defe9c712b4aed37c0dc8fc89fe71149581", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n //! The `DepGraphSafe` trait\n \n-use hir::BodyId;\n-use hir::def_id::DefId;\n+use crate::hir::BodyId;\n+use crate::hir::def_id::DefId;\n use syntax::ast::NodeId;\n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n \n /// The `DepGraphSafe` trait is used to specify what kinds of values\n /// are safe to \"leak\" into a task. The idea is that this should be"}, {"sha": "b64f71ed908d823b079ced68670c3ae55389755a", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n //! The data that we will serialize and deserialize.\n \n-use dep_graph::DepNode;\n-use ich::Fingerprint;\n+use crate::dep_graph::DepNode;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n newtype_index! {"}, {"sha": "ddc1eebe645ae4b3cbba047bea93ec7f47cd3749", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,12 +5,12 @@\n //! item.\n \n \n-use ty::TyCtxt;\n-use ty::query::Providers;\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n-use hir;\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use std::fmt::{self, Display};\n use syntax_pos::Span;\n \n@@ -91,7 +91,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n-    /// Check any attribute.\n+    /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         self.check_used(item, target);\n     }\n \n-    /// Check if an `#[inline]` is applied to a function or a closure.\n+    /// Checks if an `#[inline]` is applied to a function or a closure.\n     fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n         if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[non_exhaustive]` attribute on an `item` is valid.\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid.\n     fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Struct | Target::Enum => { /* Valid */ },\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[marker]` attribute on an `item` is valid.\n+    /// Checks if the `#[marker]` attribute on an `item` is valid.\n     fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Trait => { /* Valid */ },\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[repr]` attributes on `item` are valid.\n+    /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n@@ -186,8 +186,8 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             };\n \n             let (article, allowed_targets) = match &*name.as_str() {\n-                \"C\" => {\n-                    is_c = true;\n+                \"C\" | \"align\" => {\n+                    is_c |= name == \"C\";\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n@@ -212,14 +212,6 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n-                \"align\" => {\n-                    if target != Target::Struct &&\n-                            target != Target::Union {\n-                        (\"a\", \"struct or union\")\n-                    } else {\n-                        continue\n-                    }\n-                }\n                 \"transparent\" => {\n                     is_transparent = true;\n                     if target != Target::Struct {"}, {"sha": "b15bea017762ea277a443d94a2e1160cbf7d03c0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n-use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, DefIdMap};\n+use crate::hir::def_id::DefId;\n+use crate::util::nodemap::{NodeMap, DefIdMap};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n-use hir;\n-use ty;\n+use crate::hir;\n+use crate::ty;\n \n use self::Namespace::*;\n \n@@ -52,6 +52,7 @@ pub enum Def {\n     AssociatedExistential(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n+    ConstParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n@@ -181,7 +182,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n }\n \n impl<T> PerNS<Option<T>> {\n-    /// Returns whether all the items in this collection are `None`.\n+    /// Returns `true` if all the items in this collection are `None`.\n     pub fn is_empty(&self) -> bool {\n         self.type_ns.is_none() && self.value_ns.is_none() && self.macro_ns.is_none()\n     }\n@@ -265,7 +266,8 @@ impl Def {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) |\n             Def::TyAlias(id) | Def::TraitAlias(id) |\n-            Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+            Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n+            Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n             Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n@@ -322,6 +324,7 @@ impl Def {\n             Def::Const(..) => \"constant\",\n             Def::AssociatedConst(..) => \"associated constant\",\n             Def::TyParam(..) => \"type parameter\",\n+            Def::ConstParam(..) => \"const parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\",\n             Def::Upvar(..) => \"closure capture\","}, {"sha": "ed1c15a73c260fc33128cb19f9095c00c1464390", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use ty;\n-use ty::TyCtxt;\n-use hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n+use crate::ty;\n+use crate::ty::TyCtxt;\n+use crate::hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n@@ -229,7 +229,7 @@ impl fmt::Debug for DefId {\n }\n \n impl DefId {\n-    /// Make a local `DefId` with the given index.\n+    /// Makes a local `DefId` from the given `DefIndex`.\n     #[inline]\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }"}, {"sha": "9436c600c9fd3a06c20f269d3a93a02ce6f8163d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,7 +4,7 @@\n //! `super::itemlikevisit::ItemLikeVisitor` trait.**\n //!\n //! If you have decided to use this visitor, here are some general\n-//! notes on how to do it:\n+//! notes on how to do so:\n //!\n //! Each overridden visit method has full control over what\n //! happens with its node, it can do its own traversal of the node's children,\n@@ -33,9 +33,9 @@\n \n use syntax::ast::{NodeId, CRATE_NODE_ID, Ident, Name, Attribute};\n use syntax_pos::Span;\n-use hir::*;\n-use hir::def::Def;\n-use hir::map::Map;\n+use crate::hir::*;\n+use crate::hir::def::Def;\n+use crate::hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n #[derive(Copy, Clone)]\n@@ -86,7 +86,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),\n \n-    /// Visit all nested things, including item-likes.\n+    /// Visits all nested things, including item-likes.\n     ///\n     /// **This is an unusual choice.** It is used when you want to\n     /// process everything within their lexical context. Typically you\n@@ -96,7 +96,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n \n impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     /// Returns the map to use for an \"intra item-like\" thing (if any).\n-    /// e.g., function body.\n+    /// E.g., function body.\n     pub fn intra(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -106,7 +106,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     }\n \n     /// Returns the map to use for an \"item-like\" thing (if any).\n-    /// e.g., item, impl-item.\n+    /// E.g., item, impl-item.\n     pub fn inter(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -117,7 +117,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n-/// overridden.  Each method's default implementation recursively visits\n+/// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g., the `visit_mod` method by default calls `intravisit::walk_mod`.\n ///\n@@ -129,7 +129,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// on `visit_nested_item` for details on how to visit nested items.\n ///\n /// If you want to ensure that your code handles every variant\n-/// explicitly, you need to override each method.  (And you also need\n+/// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n@@ -203,7 +203,7 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n-    /// Visit the top-level item and (optionally) nested items / impl items. See\n+    /// Visits the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n@@ -214,7 +214,7 @@ pub trait Visitor<'v> : Sized {\n     }\n \n     /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor.  This method converts a \"intra-visit\"\n+    /// item-like visitor. This method converts a \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n     /// If you use this, you probably don't want to process the\n     /// contents of nested item-like things, since the outer loop will"}, {"sha": "6ff4db750044a793f02d3bc66ae81faded362752", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 109, "deletions": 68, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,24 +3,24 @@\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n //! much like a fold. Where lowering involves a bit more work things get more\n //! interesting and there are some invariants you should know about. These mostly\n-//! concern spans and ids.\n+//! concern spans and IDs.\n //!\n //! Spans are assigned to AST nodes during parsing and then are modified during\n //! expansion to indicate the origin of a node and the process it went through\n-//! being expanded. Ids are assigned to AST nodes just before lowering.\n+//! being expanded. IDs are assigned to AST nodes just before lowering.\n //!\n-//! For the simpler lowering steps, ids and spans should be preserved. Unlike\n+//! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new id using `next_id()`.\n+//! 'folding' an existing one), then you create a new ID using `next_id()`.\n //!\n-//! You must ensure that ids are unique. That means that you should only use the\n-//! id from an AST node in a single HIR node (you can assume that AST node ids\n-//! are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-//! If you do, you must then set the new node's id to a fresh one.\n+//! You must ensure that IDs are unique. That means that you should only use the\n+//! ID from an AST node in a single HIR node (you can assume that AST node IDs\n+//! are unique). Every new node must have a unique ID. Avoid cloning HIR nodes.\n+//! If you do, you must then set the new node's ID to a fresh one.\n //!\n //! Spans are used for error messages and for tools to map semantics back to\n-//! source code. It is therefore not as important with spans as ids to be strict\n+//! source code. It is therefore not as important with spans as IDs to be strict\n //! about use (you can't break the compiler by screwing up a span). Obviously, a\n //! HIR node can only have a single span. But multiple nodes can have the same\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n@@ -30,24 +30,25 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-use dep_graph::DepGraph;\n-use errors::Applicability;\n-use hir::{self, ParamName};\n-use hir::HirVec;\n-use hir::map::{DefKey, DefPathData, Definitions};\n-use hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use hir::def::{Def, PathResolution, PerNS};\n-use hir::GenericArg;\n-use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+use crate::dep_graph::DepGraph;\n+use crate::errors::Applicability;\n+use crate::hir::{self, ParamName};\n+use crate::hir::HirVec;\n+use crate::hir::map::{DefKey, DefPathData, Definitions};\n+use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n+use crate::hir::def::{Def, PathResolution, PerNS};\n+use crate::hir::GenericArg;\n+use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n-use middle::cstore::CrateStore;\n+use crate::middle::cstore::CrateStore;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n-use session::Session;\n-use session::config::nightly_options;\n-use util::common::FN_OUTPUT_NAME;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use rustc_data_structures::sync::Lrc;\n+use crate::session::Session;\n+use crate::session::config::nightly_options;\n+use crate::util::common::FN_OUTPUT_NAME;\n+use crate::util::nodemap::{DefIdMap, NodeMap};\n \n use std::collections::{BTreeSet, BTreeMap};\n use std::fmt::Debug;\n@@ -144,7 +145,7 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a node-id.\n+    /// Obtain the resolution for a `NodeId`.\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n     /// Obtain the possible resolutions for the given `use` statement.\n@@ -273,10 +274,10 @@ enum ParenthesizedGenericArgs {\n }\n \n /// What to do when we encounter an **anonymous** lifetime\n-/// reference. Anonymous lifetime references come in two flavors.  You\n+/// reference. Anonymous lifetime references come in two flavors. You\n /// have implicit, or fully elided, references to lifetimes, like the\n /// one in `&T` or `Ref<T>`, and you have `'_` lifetimes, like `&'_ T`\n-/// or `Ref<'_, T>`.  These often behave the same, but not always:\n+/// or `Ref<'_, T>`. These often behave the same, but not always:\n ///\n /// - certain usages of implicit references are deprecated, like\n ///   `Ref<T>`, and we sometimes just give hard errors in those cases\n@@ -681,13 +682,20 @@ impl<'a> LoweringContext<'a> {\n         Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n-    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    fn mark_span_with_reason(\n+        &self,\n+        reason: CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(source_map::ExpnInfo {\n             call_site: span,\n             def_site: Some(span),\n             format: source_map::CompilerDesugaring(reason),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: source_map::hygiene::default_edition(),\n@@ -964,7 +972,13 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n+        let unstable_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Async,\n+            span,\n+            Some(vec![\n+                Symbol::intern(\"gen_future\"),\n+            ].into()),\n+        );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n@@ -1157,6 +1171,15 @@ impl<'a> LoweringContext<'a> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n+            ast::GenericArg::Const(ct) => {\n+                // FIXME(const_generics): const generics are not yet defined in the HIR.\n+                self.sess.struct_span_err(\n+                    ct.value.span,\n+                    \"const generics in any position are currently unsupported\",\n+                ).emit();\n+                self.sess.abort_if_errors();\n+                bug!();\n+            }\n         }\n     }\n \n@@ -1351,9 +1374,10 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.allow_internal_unstable(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n+            None,\n         );\n \n         let exist_ty_def_index = self\n@@ -2441,7 +2465,7 @@ impl<'a> LoweringContext<'a> {\n             |this| this.lower_param_bounds(&param.bounds, itctx.reborrow()),\n         );\n \n-        match param.kind {\n+        let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n                 self.is_collecting_in_band_lifetimes = false;\n@@ -2457,22 +2481,14 @@ impl<'a> LoweringContext<'a> {\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n-                let param = hir::GenericParam {\n-                    id: lt.id,\n-                    hir_id: lt.hir_id,\n-                    name: param_name,\n-                    span: lt.span,\n-                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n-                    attrs: self.lower_attrs(&param.attrs),\n-                    bounds,\n-                    kind: hir::GenericParamKind::Lifetime {\n-                        kind: hir::LifetimeParamKind::Explicit,\n-                    }\n+\n+                let kind = hir::GenericParamKind::Lifetime {\n+                    kind: hir::LifetimeParamKind::Explicit\n                 };\n \n                 self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n \n-                param\n+                (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n@@ -2491,27 +2507,41 @@ impl<'a> LoweringContext<'a> {\n                                    .chain(params)\n                                    .collect();\n                 }\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n \n-                hir::GenericParam {\n-                    id: node_id,\n-                    hir_id,\n-                    name: hir::ParamName::Plain(ident),\n-                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n-                    attrs: self.lower_attrs(&param.attrs),\n-                    bounds,\n-                    span: ident.span,\n-                    kind: hir::GenericParamKind::Type {\n-                        default: default.as_ref().map(|x| {\n-                            self.lower_ty(x, ImplTraitContext::disallowed())\n-                        }),\n-                        synthetic: param.attrs.iter()\n-                                              .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n-                                              .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                                              .next(),\n-                    }\n-                }\n+                let kind = hir::GenericParamKind::Type {\n+                    default: default.as_ref().map(|x| {\n+                        self.lower_ty(x, ImplTraitContext::disallowed())\n+                    }),\n+                    synthetic: param.attrs.iter()\n+                                          .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                          .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                                          .next(),\n+                };\n+\n+                (hir::ParamName::Plain(ident), kind)\n+            }\n+            GenericParamKind::Const { .. } => {\n+                // FIXME(const_generics): const generics are not yet defined in the HIR.\n+                self.sess.struct_span_err(\n+                    param.ident.span,\n+                    \"const generics in any position are currently unsupported\",\n+                ).emit();\n+                self.sess.abort_if_errors();\n+                bug!();\n             }\n+        };\n+\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n+\n+        hir::GenericParam {\n+            id: node_id,\n+            hir_id,\n+            name,\n+            span: param.ident.span,\n+            pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+            attrs: self.lower_attrs(&param.attrs),\n+            bounds,\n+            kind,\n         }\n     }\n \n@@ -3272,7 +3302,7 @@ impl<'a> LoweringContext<'a> {\n \n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// node-ids. (See e.g., #56128.)\n+    /// `NodeId`s. (See, e.g., #56128.)\n     fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n@@ -3912,8 +3942,13 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span =\n-                        this.allow_internal_unstable(CompilerDesugaringKind::TryBlock, body.span);\n+                    let unstable_span = this.mark_span_with_reason(\n+                        CompilerDesugaringKind::TryBlock,\n+                        body.span,\n+                        Some(vec![\n+                            Symbol::intern(\"try_trait\"),\n+                        ].into()),\n+                    );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n@@ -4345,9 +4380,10 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.allow_internal_unstable(\n+                let desugared_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n+                    None,\n                 );\n \n                 let iter = self.str_to_ident(\"iter\");\n@@ -4510,8 +4546,13 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span =\n-                    self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n+                let unstable_span = self.mark_span_with_reason(\n+                    CompilerDesugaringKind::QuestionMark,\n+                    e.span,\n+                    Some(vec![\n+                        Symbol::intern(\"try_trait\")\n+                    ].into()),\n+                );\n \n                 // `Try::into_result(<expr>)`\n                 let discr = {"}, {"sha": "6919628c7675552c18863a5724712dca46295ab7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,20 +1,20 @@\n //! This module provides a simplified abstraction for working with\n-//! code blocks identified by their integer node-id.  In particular,\n+//! code blocks identified by their integer `NodeId`. In particular,\n //! it captures a common set of attributes that all \"function-like\n-//! things\" (represented by `FnLike` instances) share.  For example,\n+//! things\" (represented by `FnLike` instances) share. For example,\n //! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred).  And all `FnLike` instances have a body, i.e., the code\n+//! inferred). And all `FnLike` instances have a body, i.e., the code\n //! that is run when the function-like thing it represents is invoked.\n //!\n //! With the above abstraction in place, one can treat the program\n //! text as a collection of blocks of code (and most such blocks are\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-use hir as ast;\n-use hir::map;\n-use hir::{Expr, FnDecl, Node};\n-use hir::intravisit::FnKind;\n+use crate::hir as ast;\n+use crate::hir::map;\n+use crate::hir::{Expr, FnDecl, Node};\n+use crate::hir::intravisit::FnKind;\n use syntax::ast::{Attribute, Ident, NodeId};\n use syntax_pos::Span;\n "}, {"sha": "37552f18f4a08112582e146ac9ede7d4d78a50a6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,18 +1,19 @@\n use super::*;\n-use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n-use hir::def_id::{LOCAL_CRATE, CrateNum};\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::dep_graph::{DepGraph, DepKind, DepNodeIndex};\n+use crate::hir;\n+use crate::hir::def_id::{LOCAL_CRATE, CrateNum};\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n-use ich::Fingerprint;\n-use middle::cstore::CrateStore;\n-use session::CrateDisambiguator;\n-use session::Session;\n+use crate::ich::Fingerprint;\n+use crate::middle::cstore::CrateStore;\n+use crate::session::CrateDisambiguator;\n+use crate::session::Session;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n@@ -28,6 +29,8 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: NodeId,\n \n+    parent_hir: hir::HirId,\n+\n     // These fields keep track of the currently relevant DepNodes during\n     // the visitor's traversal.\n     current_dep_node_owner: DefIndex,\n@@ -45,14 +48,14 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n \n-fn input_dep_node_and_hash<'a, I>(\n+fn input_dep_node_and_hash<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     dep_node: DepNode,\n     input: I,\n ) -> (DepNodeIndex, Fingerprint)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let dep_node_index = dep_graph.input_task(dep_node, &mut *hcx, &input).1;\n \n@@ -67,15 +70,15 @@ where\n     (dep_node_index, hash)\n }\n \n-fn alloc_hir_dep_nodes<'a, I>(\n+fn alloc_hir_dep_nodes<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     def_path_hash: DefPathHash,\n     item_like: I,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n ) -> (DepNodeIndex, DepNodeIndex)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let sig = dep_graph.input_task(\n         def_path_hash.to_dep_node(DepKind::Hir),\n@@ -145,6 +148,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             source_map: sess.source_map(),\n             map: repeat(None).take(sess.current_node_id_count()).collect(),\n             parent_node: CRATE_NODE_ID,\n+            parent_hir: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n@@ -156,6 +160,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         };\n         collector.insert_entry(CRATE_NODE_ID, Entry {\n             parent: CRATE_NODE_ID,\n+            parent_hir: hir::CRATE_HIR_ID,\n             dep_node: root_mod_sig_dep_index,\n             node: Node::Crate,\n         });\n@@ -226,6 +231,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     fn insert(&mut self, span: Span, id: NodeId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n+            parent_hir: self.parent_hir,\n             dep_node: if self.currently_in_body {\n                 self.current_full_dep_index\n             } else {\n@@ -247,7 +253,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     None => format!(\"{:?}\", node)\n                 };\n \n-                let forgot_str = if hir_id == ::hir::DUMMY_HIR_ID {\n+                let forgot_str = if hir_id == crate::hir::DUMMY_HIR_ID {\n                     format!(\"\\nMaybe you forgot to lower the node id {:?}?\", id)\n                 } else {\n                     String::new()\n@@ -280,7 +286,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+    fn with_dep_node_owner<T: for<'b> HashStable<StableHashingContext<'b>>,\n                            F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n                                                  item_like: &T,"}, {"sha": "8fe10a85ef380de12a3e00b874dc3a6ed53adefd", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use hir::map::definitions::*;\n-use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n-use session::CrateDisambiguator;\n+use crate::hir::map::definitions::*;\n+use crate::hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n+use crate::session::CrateDisambiguator;\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -10,9 +10,9 @@ use syntax::symbol::Symbol;\n use syntax::parse::token::{self, Token};\n use syntax_pos::Span;\n \n-use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n+use crate::hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n-/// Creates def ids for nodes in the AST.\n+/// Creates `DefId`s for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n@@ -218,6 +218,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeParam(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeParam(name),\n+            GenericParamKind::Const { .. } => DefPathData::ConstParam(name),\n         };\n         self.create_def(param.id, def_path_data, REGULAR_SPACE, param.ident.span);\n "}, {"sha": "f454d691d4188c41ad65c39980038ac9a0fe7ffe", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,26 +1,26 @@\n-//! For each definition, we track the following data.  A definition\n-//! here is defined somewhat circularly as \"something with a def-id\",\n+//! For each definition, we track the following data. A definition\n+//! here is defined somewhat circularly as \"something with a `DefId`\",\n //! but it generally corresponds to things like structs, enums, etc.\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n \n-use hir;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n                   CRATE_DEF_INDEX};\n-use ich::Fingerprint;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n-use session::CrateDisambiguator;\n+use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use util::nodemap::NodeMap;\n+use crate::util::nodemap::NodeMap;\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n@@ -163,10 +163,10 @@ pub struct Definitions {\n /// any) with a `DisambiguatedDefPathData`.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n-    /// Parent path.\n+    /// The parent path.\n     pub parent: Option<DefIndex>,\n \n-    /// Identifier of this node.\n+    /// The identifier of this node.\n     pub disambiguated_data: DisambiguatedDefPathData,\n }\n \n@@ -207,12 +207,12 @@ impl DefKey {\n     }\n }\n \n-/// Pair of `DefPathData` and an integer disambiguator. The integer is\n+/// A pair of `DefPathData` and an integer disambiguator. The integer is\n /// normally 0, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have (e.g.) two impls for the same type in\n-/// the same module, they do get distinct def-ids.\n+/// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n@@ -221,10 +221,10 @@ pub struct DisambiguatedDefPathData {\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n-    /// the path leading from the crate root to the item\n+    /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n \n-    /// what krate root is this path relative to?\n+    /// The crate root this path is relative to.\n     pub krate: CrateNum,\n }\n \n@@ -260,9 +260,9 @@ impl DefPath {\n         DefPath { data: data, krate: krate }\n     }\n \n-    /// Returns a string representation of the DefPath without\n+    /// Returns a string representation of the `DefPath` without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_string_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -277,7 +277,7 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah with the\n+    /// Returns a filename-friendly string for the `DefPath`, with the\n     /// crate-prefix.\n     pub fn to_string_friendly<F>(&self, crate_imported_name: F) -> String\n         where F: FnOnce(CrateNum) -> Symbol\n@@ -302,9 +302,9 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah without\n+    /// Returns a filename-friendly string of the `DefPath`, without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_filename_friendly_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -356,10 +356,12 @@ pub enum DefPathData {\n     /// A closure expression\n     ClosureExpr,\n     // Subportions of items\n-    /// A type parameter (generic parameter)\n+    /// A type (generic) parameter\n     TypeParam(InternedString),\n-    /// A lifetime definition\n+    /// A lifetime (generic) parameter\n     LifetimeParam(InternedString),\n+    /// A const (generic) parameter\n+    ConstParam(InternedString),\n     /// A variant of a enum\n     EnumVariant(InternedString),\n     /// A struct field\n@@ -392,18 +394,18 @@ impl Borrow<Fingerprint> for DefPathHash {\n }\n \n impl Definitions {\n-    /// Create new empty definition map.\n+    /// Creates new empty definition map.\n     ///\n-    /// The DefIndex returned from a new Definitions are as follows:\n-    /// 1. At DefIndexAddressSpace::Low,\n+    /// The `DefIndex` returned from a new `Definitions` are as follows:\n+    /// 1. At `DefIndexAddressSpace::Low`,\n     ///     CRATE_ROOT has index 0:0, and then new indexes are allocated in\n     ///     ascending order.\n-    /// 2. At DefIndexAddressSpace::High,\n-    ///     the first FIRST_FREE_HIGH_DEF_INDEX indexes are reserved for\n-    ///     internal use, then 1:FIRST_FREE_HIGH_DEF_INDEX are allocated in\n+    /// 2. At `DefIndexAddressSpace::High`,\n+    ///     the first `FIRST_FREE_HIGH_DEF_INDEX` indexes are reserved for\n+    ///     internal use, then `1:FIRST_FREE_HIGH_DEF_INDEX` are allocated in\n     ///     ascending order.\n-    ///\n-    /// FIXME: there is probably a better place to put this comment.\n+    //\n+    // FIXME: there is probably a better place to put this comment.\n     pub fn new() -> Self {\n         Self::default()\n     }\n@@ -412,7 +414,7 @@ impl Definitions {\n         &self.table\n     }\n \n-    /// Get the number of definitions.\n+    /// Gets the number of definitions.\n     pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n         (self.table.index_to_key[DefIndexAddressSpace::Low.index()].len(),\n          self.table.index_to_key[DefIndexAddressSpace::High.index()].len())\n@@ -467,6 +469,21 @@ impl Definitions {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n+        if def_id.krate == LOCAL_CRATE {\n+            let hir_id = self.def_index_to_hir_id(def_id.index);\n+            if hir_id != hir::DUMMY_HIR_ID {\n+                Some(hir_id)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_to_hir_id[node_id]\n@@ -480,8 +497,8 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n-    /// Retrieve the span of the given `DefId` if `DefId` is in the local crate, the span exists and\n-    /// it's not DUMMY_SP\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n+    /// and it's not `DUMMY_SP`.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n@@ -491,7 +508,7 @@ impl Definitions {\n         }\n     }\n \n-    /// Add a definition with a parent definition.\n+    /// Adds a root definition (no parent).\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -589,7 +606,7 @@ impl Definitions {\n         index\n     }\n \n-    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {\n@@ -626,6 +643,7 @@ impl DefPathData {\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeParam(name) |\n+            ConstParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => Some(name),\n@@ -654,6 +672,7 @@ impl DefPathData {\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeParam(name) |\n+            ConstParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => {"}, {"sha": "2c3ff4c9b5c05bdd48f40518939a47046ea60147", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use hir::{self, intravisit, HirId, ItemLocalId};\n+use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use crate::hir::{self, intravisit, HirId, ItemLocalId};\n use syntax::ast::NodeId;\n-use hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n "}, {"sha": "692b7fd37d28d2868fa94f21fd5e81c9d3379855", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 182, "deletions": 29, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,11 +3,11 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n+use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n+use crate::hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n-use middle::cstore::CrateStoreDyn;\n+use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n@@ -17,15 +17,15 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use hir::*;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir::print::Nested;\n-use util::nodemap::FxHashMap;\n-use util::common::time;\n+use crate::hir::*;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::print::Nested;\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use std::io;\n use std::result::Result::Err;\n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n \n pub mod blocks;\n mod collector;\n@@ -36,10 +36,11 @@ mod hir_id_validator;\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n-/// Represents an entry and its parent NodeId.\n+/// Represents an entry and its parent `NodeId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: NodeId,\n+    parent_hir: HirId,\n     dep_node: DepNodeIndex,\n     node: Node<'hir>,\n }\n@@ -161,8 +162,7 @@ impl Forest {\n     }\n }\n \n-/// Represents a mapping from Node IDs to AST elements and their parent\n-/// Node IDs\n+/// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n@@ -208,6 +208,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn read_by_hir_id(&self, hir_id: HirId) {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.read(node_id);\n+    }\n+\n     #[inline]\n     pub fn definitions(&self) -> &'hir Definitions {\n         self.definitions\n@@ -224,6 +230,11 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn def_path_from_hir_id(&self, id: HirId) -> DefPath {\n+        self.def_path(self.local_def_id_from_hir_id(id))\n+    }\n+\n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n         self.definitions.def_path(def_id.index)\n@@ -237,6 +248,23 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.opt_local_def_id(node_id).unwrap_or_else(|| {\n+            bug!(\"local_def_id_from_hir_id: no entry for `{:?}`, which has a map of `{:?}`\",\n+                 hir_id, self.find_entry(node_id))\n+        })\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn opt_local_def_id_from_hir_id(&self, hir_id: HirId) -> Option<DefId> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.definitions.opt_local_def_id(node_id)\n+    }\n+\n     #[inline]\n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n@@ -247,6 +275,12 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+        self.definitions.as_local_hir_id(def_id)\n+    }\n+\n     #[inline]\n     pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n         self.hir_to_node_id[&hir_id]\n@@ -336,16 +370,19 @@ impl<'hir> Map<'hir> {\n                 let def_id = self.local_def_id(variant.node.data.id());\n                 Some(Def::Variant(def_id))\n             }\n-            Node::Field(_) |\n+            Node::StructCtor(variant) => {\n+                let def_id = self.local_def_id(variant.id());\n+                Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n+            }\n             Node::AnonConst(_) |\n+            Node::Field(_) |\n             Node::Expr(_) |\n             Node::Stmt(_) |\n             Node::PathSegment(_) |\n             Node::Ty(_) |\n             Node::TraitRef(_) |\n             Node::Pat(_) |\n             Node::Binding(_) |\n-            Node::StructCtor(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n@@ -366,6 +403,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn describe_def_by_hir_id(&self, hir_id: HirId) -> Option<Def> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.describe_def(node_id)\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }\n@@ -410,6 +453,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.fn_decl(node_id)\n+    }\n+\n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n@@ -423,7 +472,7 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n-    /// Given a node id, returns the `BodyId` associated with it,\n+    /// Given a `NodeId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(id) {\n@@ -508,7 +557,7 @@ impl<'hir> Map<'hir> {\n         self.trait_auto_impl(trait_did).is_some()\n     }\n \n-    /// Get the attributes on the krate. This is preferable to\n+    /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n@@ -566,6 +615,12 @@ impl<'hir> Map<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find node id {} in the AST map\", id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get(node_id)\n+    }\n+\n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n         self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n@@ -597,8 +652,7 @@ impl<'hir> Map<'hir> {\n         self.get_generics(id).map(|generics| generics.span).filter(|sp| *sp != DUMMY_SP)\n     }\n \n-    /// Retrieve the Node corresponding to `id`, returning None if\n-    /// cannot be found.\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let result = self.find_entry(id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n@@ -613,6 +667,12 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.find(node_id)\n+    }\n+\n     /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n     /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n@@ -621,8 +681,8 @@ impl<'hir> Map<'hir> {\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n     /// never appear as the parent_node. So you can always walk the `parent_nodes`\n-    /// from a node to the root of the ast (unless you get the same id back here\n-    /// that can happen if the id is not in the map itself or is just weird).\n+    /// from a node to the root of the ast (unless you get the same ID back here\n+    /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = self.node_to_hir_id(id).owner;\n@@ -633,6 +693,13 @@ impl<'hir> Map<'hir> {\n         self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_node_by_hir_id(&self, id: HirId) -> HirId {\n+        let node_id = self.hir_to_node_id(id);\n+        let parent_node_id = self.get_parent_node(node_id);\n+        self.node_to_hir_id(parent_node_id)\n+    }\n+\n     /// Check if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n@@ -656,7 +723,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good node id we found. Note that reaching the crate root (`id == 0`),\n+    /// last good `NodeId` we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -692,7 +759,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s enclosing method, unless there's a\n+    /// Retrieves the `NodeId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n@@ -740,7 +807,7 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n@@ -757,6 +824,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_item(&self, id: HirId) -> HirId {\n+        let node_id = self.hir_to_node_id(id);\n+        let parent_node_id = self.get_parent(node_id);\n+        self.node_to_hir_id(parent_node_id)\n+    }\n+\n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n@@ -794,6 +868,12 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.get_parent(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_parent_did(node_id)\n+    }\n+\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         if let Some(entry) = self.find_entry(parent) {\n@@ -807,28 +887,54 @@ impl<'hir> Map<'hir> {\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_foreign_abi_by_hir_id(&self, id: HirId) -> Abi {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_foreign_abi(node_id)\n+    }\n+\n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_item(node_id)\n+    }\n+\n     pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n             Some(Node::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_impl_item_by_hir_id(&self, id: HirId) -> &'hir ImplItem {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_impl_item(node_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_trait_item_by_hir_id(&self, id: HirId) -> &'hir TraitItem {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_trait_item(node_id)\n+    }\n+\n     pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n             Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n+    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n+        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n+\n         match self.find(id) {\n             Some(Node::Item(i)) => {\n                 match i.node {\n@@ -843,7 +949,9 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n+    pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n+        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n+\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n@@ -864,6 +972,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_expr(node_id)\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -881,6 +995,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n+        let node_id = self.hir_to_node_id(id);\n+        self.name(node_id)\n+    }\n+\n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n@@ -903,6 +1023,12 @@ impl<'hir> Map<'hir> {\n         attrs.unwrap_or(&[])\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+        let node_id = self.hir_to_node_id(id);\n+        self.attrs(node_id)\n+    }\n+\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -952,6 +1078,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn span_by_hir_id(&self, id: HirId) -> Span {\n+        let node_id = self.hir_to_node_id(id);\n+        self.span(node_id)\n+    }\n+\n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n@@ -960,13 +1092,28 @@ impl<'hir> Map<'hir> {\n         node_id_to_string(self, id, true)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_string(&self, id: HirId) -> String {\n+        hir_id_to_string(self, id, true)\n+    }\n+\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_user_string(&self, id: HirId) -> String {\n+        hir_id_to_string(self, id, false)\n+    }\n+\n     pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n         print::to_string(self, |s| s.print_node(self.get(id)))\n     }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n+        print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n@@ -977,7 +1124,7 @@ pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n }\n \n impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n-    /// Returns true only if some suffix of the module path for parent\n+    /// Returns `true` only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n     /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n@@ -1070,13 +1217,13 @@ impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n-pub fn map_crate<'hir>(sess: &::session::Session,\n+pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let ((map, crate_hash), hir_to_node_id) = join(|| {\n-        let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,\n@@ -1187,7 +1334,7 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n     let path_str = || {\n         // This functionality is used for debugging, try to use TyCtxt to get\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n-        ::ty::tls::with_opt(|tcx| {\n+        crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 tcx.node_path_str(id)\n             } else if let Some(path) = map.def_path_from_id(id) {\n@@ -1310,6 +1457,12 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n     }\n }\n \n+// FIXME(@ljedrz): replace the NodeId variant\n+fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n+    let node_id = map.hir_to_node_id(id);\n+    node_id_to_string(map, node_id, include_id)\n+}\n+\n pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         tcx.hir().describe_def(node_id)"}, {"sha": "d9759da9dfca8080eb8a1f2d75501a1d183326e7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 184, "deletions": 187, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -10,11 +10,11 @@ pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n-use errors::FatalError;\n-use hir::def::Def;\n-use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n-use util::nodemap::{NodeMap, FxHashSet};\n-use mir::mono::Linkage;\n+use crate::errors::FatalError;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n+use crate::util::nodemap::{NodeMap, FxHashSet};\n+use crate::mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n@@ -27,10 +27,10 @@ use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n-use ty::AdtKind;\n-use ty::query::Providers;\n+use crate::ty::AdtKind;\n+use crate::ty::query::Providers;\n \n-use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope};\n+use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n \n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n@@ -62,14 +62,14 @@ pub mod map;\n pub mod pat_util;\n pub mod print;\n \n-/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n-/// composed of the `owner`, which is the DefIndex of the directly enclosing\n-/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e., the closest \"item-like\"),\n+/// Uniquely identifies a node in the HIR of the current crate. It is\n+/// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n+/// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property in\n+/// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -130,7 +130,7 @@ mod item_local_id_inner {\n \n pub use self::item_local_id_inner::ItemLocalId;\n \n-/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+/// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_INDEX`.\n pub const CRATE_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n     local_id: ItemLocalId::from_u32_const(0)\n@@ -149,8 +149,8 @@ pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n \n-    /// Either \"'a\", referring to a named lifetime definition,\n-    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    /// Either \"`'a`\", referring to a named lifetime definition,\n+    /// or \"``\" (i.e., `keywords::Invalid`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n@@ -163,8 +163,9 @@ pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n \n-    /// Synthetic name generated when user elided a lifetime in an impl header,\n-    /// e.g., the lifetimes in cases like these:\n+    /// Synthetic name generated when user elided a lifetime in an impl header.\n+    ///\n+    /// E.g., the lifetimes in cases like these:\n     ///\n     ///     impl Foo for &u32\n     ///     impl Foo<'_> for u32\n@@ -180,7 +181,7 @@ pub enum ParamName {\n \n     /// Indicates an illegal name was given and an error has been\n     /// repored (so we should squelch other derived errors). Occurs\n-    /// when e.g., `'_` is used in the wrong place.\n+    /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }\n \n@@ -205,17 +206,17 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n \n-    /// User typed nothing. e.g., the lifetime in `&u32`.\n+    /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n \n-    /// User typed `'_`.\n+    /// User wrote specifies `'_`.\n     Underscore,\n \n-    /// User wrote `'static`\n+    /// User wrote `'static`.\n     Static,\n }\n \n@@ -280,7 +281,7 @@ impl Lifetime {\n     }\n }\n \n-/// A \"Path\" is essentially Rust's notion of a name; for instance:\n+/// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -340,7 +341,7 @@ pub struct PathSegment {\n }\n \n impl PathSegment {\n-    /// Convert an identifier to the corresponding segment.\n+    /// Converts an identifier to the corresponding segment.\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n@@ -597,14 +598,14 @@ impl Generics {\n     }\n }\n \n-/// Synthetic Type Parameters are converted to an other form during lowering, this allows\n-/// to track the original form they had. Useful for error messages.\n+/// Synthetic type parameters are converted to another form during lowering; this allows\n+/// us to track the original form they had, and is useful for error messages.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n-/// A `where` clause in a definition\n+/// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n@@ -624,7 +625,7 @@ impl WhereClause {\n     }\n }\n \n-/// A single predicate in a `where` clause\n+/// A single predicate in a where-clause.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n@@ -645,27 +646,27 @@ impl WherePredicate {\n     }\n }\n \n-/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n+/// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n-    /// Any generics from a `for` binding\n+    /// Any generics from a `for` binding.\n     pub bound_generic_params: HirVec<GenericParam>,\n-    /// The type being bounded\n+    /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n-    /// Trait and lifetime bounds (`Clone+Send+'static`)\n+    /// Trait and lifetime bounds (e.g., `Clone + Send + 'static`).\n     pub bounds: GenericBounds,\n }\n \n-/// A lifetime predicate, e.g., `'a: 'b+'c`\n+/// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n-/// An equality predicate (unsupported), e.g., `T=int`\n+/// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -759,27 +760,21 @@ impl Crate {\n         }\n     }\n \n-    /// A parallel version of visit_all_item_likes\n+    /// A parallel version of `visit_all_item_likes`.\n     pub fn par_visit_all_item_likes<'hir, V>(&'hir self, visitor: &V)\n         where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n     {\n-        scope(|s| {\n-            s.spawn(|_| {\n-                par_iter(&self.items).for_each(|(_, item)| {\n-                    visitor.visit_item(item);\n-                });\n+        parallel!({\n+            par_iter(&self.items).for_each(|(_, item)| {\n+                visitor.visit_item(item);\n             });\n-\n-            s.spawn(|_| {\n-                par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n-                    visitor.visit_trait_item(trait_item);\n-                });\n+        }, {\n+            par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n+                visitor.visit_trait_item(trait_item);\n             });\n-\n-            s.spawn(|_| {\n-                par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n-                    visitor.visit_impl_item(impl_item);\n-                });\n+        }, {\n+            par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n+                visitor.visit_impl_item(impl_item);\n             });\n         });\n     }\n@@ -806,14 +801,14 @@ pub struct MacroDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Block {\n-    /// Statements in a block\n+    /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n-    /// without a semicolon, if any\n+    /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n@@ -880,18 +875,18 @@ impl Pat {\n     }\n }\n \n-/// A single field in a struct pattern\n+/// A single field in a struct pattern.\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n-/// except is_shorthand is true\n+/// except `is_shorthand` is true.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FieldPat {\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// The identifier for the field\n+    /// The identifier for the field.\n     pub ident: Ident,\n-    /// The pattern the field is destructured to\n+    /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n@@ -928,41 +923,41 @@ pub enum RangeEnd {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum PatKind {\n-    /// Represents a wildcard pattern (`_`)\n+    /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `NodeId` is the canonical ID for the variable being bound,\n-    /// e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n     Binding(BindingAnnotation, NodeId, HirId, Ident, Option<P<Pat>>),\n \n-    /// A struct or struct variant pattern, e.g., `Variant {x, y, ..}`.\n+    /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n-    /// A tuple pattern `(a, b)`.\n+    /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n-    /// A `box` pattern\n+    /// A `box` pattern.\n     Box(P<Pat>),\n-    /// A reference pattern, e.g., `&mut (a, b)`\n+    /// A reference pattern (e.g., `&mut (a, b)`).\n     Ref(P<Pat>, Mutability),\n-    /// A literal\n+    /// A literal.\n     Lit(P<Expr>),\n-    /// A range pattern, e.g., `1...2` or `1..2`\n+    /// A range pattern (e.g., `1...2` or `1..2`).\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n+    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`.\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n@@ -973,7 +968,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Return MutMutable only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both arguments are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -984,41 +979,41 @@ impl Mutability {\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum BinOpKind {\n-    /// The `+` operator (addition)\n+    /// The `+` operator (addition).\n     Add,\n-    /// The `-` operator (subtraction)\n+    /// The `-` operator (subtraction).\n     Sub,\n-    /// The `*` operator (multiplication)\n+    /// The `*` operator (multiplication).\n     Mul,\n-    /// The `/` operator (division)\n+    /// The `/` operator (division).\n     Div,\n-    /// The `%` operator (modulus)\n+    /// The `%` operator (modulus).\n     Rem,\n-    /// The `&&` operator (logical and)\n+    /// The `&&` operator (logical and).\n     And,\n-    /// The `||` operator (logical or)\n+    /// The `||` operator (logical or).\n     Or,\n-    /// The `^` operator (bitwise xor)\n+    /// The `^` operator (bitwise xor).\n     BitXor,\n-    /// The `&` operator (bitwise and)\n+    /// The `&` operator (bitwise and).\n     BitAnd,\n-    /// The `|` operator (bitwise or)\n+    /// The `|` operator (bitwise or).\n     BitOr,\n-    /// The `<<` operator (shift left)\n+    /// The `<<` operator (shift left).\n     Shl,\n-    /// The `>>` operator (shift right)\n+    /// The `>>` operator (shift right).\n     Shr,\n-    /// The `==` operator (equality)\n+    /// The `==` operator (equality).\n     Eq,\n-    /// The `<` operator (less than)\n+    /// The `<` operator (less than).\n     Lt,\n-    /// The `<=` operator (less than or equal to)\n+    /// The `<=` operator (less than or equal to).\n     Le,\n-    /// The `!=` operator (not equal to)\n+    /// The `!=` operator (not equal to).\n     Ne,\n-    /// The `>=` operator (greater than or equal to)\n+    /// The `>=` operator (greater than or equal to).\n     Ge,\n-    /// The `>` operator (greater than)\n+    /// The `>` operator (greater than).\n     Gt,\n }\n \n@@ -1083,7 +1078,7 @@ impl BinOpKind {\n         }\n     }\n \n-    /// Returns `true` if the binary operator takes its arguments by value\n+    /// Returns `true` if the binary operator takes its arguments by value.\n     pub fn is_by_value(self) -> bool {\n         !self.is_comparison()\n     }\n@@ -1118,11 +1113,11 @@ pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum UnOp {\n-    /// The `*` operator for dereferencing\n+    /// The `*` operator (deferencing).\n     UnDeref,\n-    /// The `!` operator for logical inversion\n+    /// The `!` operator (logical negation).\n     UnNot,\n-    /// The `-` operator for negation\n+    /// The `-` operator (negation).\n     UnNeg,\n }\n \n@@ -1135,7 +1130,7 @@ impl UnOp {\n         }\n     }\n \n-    /// Returns `true` if the unary operator takes its argument by value\n+    /// Returns `true` if the unary operator takes its argument by value.\n     pub fn is_by_value(self) -> bool {\n         match self {\n             UnNeg | UnNot => true,\n@@ -1144,7 +1139,7 @@ impl UnOp {\n     }\n }\n \n-/// A statement\n+/// A statement.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub id: NodeId,\n@@ -1162,15 +1157,15 @@ impl fmt::Debug for Stmt {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n-    /// A local (let) binding:\n+    /// A local (`let`) binding.\n     Local(P<Local>),\n-    /// An item binding:\n+    /// An item binding.\n     Item(P<ItemId>),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n+    /// An expression without a trailing semi-colon (must have unit type).\n     Expr(P<Expr>),\n \n-    /// Expr with trailing semi-colon (may have any type):\n+    /// An expression with a trailing semi-colon (may have any type).\n     Semi(P<Expr>),\n }\n \n@@ -1185,12 +1180,12 @@ impl StmtKind {\n     }\n }\n \n-/// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n+/// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n-    /// Initializer expression to set the value, if any\n+    /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n@@ -1199,7 +1194,7 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-/// represents one arm of a 'match'\n+/// Represents a single arm of a `match` expression.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n@@ -1425,16 +1420,16 @@ impl fmt::Debug for Expr {\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n-    /// An array (`[a, b, c, d]`)\n+    /// An array (e.g., `[a, b, c, d]`).\n     Array(HirVec<Expr>),\n-    /// A function call\n+    /// A function call.\n     ///\n     /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n     Call(P<Expr>, HirVec<Expr>),\n-    /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n+    /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n     /// (within the angle brackets).\n@@ -1444,63 +1439,64 @@ pub enum ExprKind {\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n     MethodCall(PathSegment, Span, HirVec<Expr>),\n-    /// A tuple (`(a, b, c ,d)`)\n+    /// A tuple (e.g., `(a, b, c ,d)`).\n     Tup(HirVec<Expr>),\n-    /// A binary operation (For example: `a + b`, `a * b`)\n+    /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n-    /// A unary operation (For example: `!x`, `*x`)\n+    /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, P<Expr>),\n-    /// A literal (For example: `1`, `\"foo\"`)\n+    /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n-    /// A cast (`foo as f64`)\n+    /// A cast (e.g., `foo as f64`).\n     Cast(P<Expr>, P<Ty>),\n+    /// A type reference (e.g., `Foo`).\n     Type(P<Expr>, P<Ty>),\n-    /// An `if` block, with an optional else block\n+    /// An `if` block, with an optional else block.\n     ///\n-    /// `if expr { expr } else { expr }`\n+    /// I.e., `if <expr> { <expr> } else { <expr> }`.\n     If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n-    /// `'label: while expr { block }`\n+    /// I.e., `'label: while expr { <block> }`.\n     While(P<Expr>, P<Block>, Option<Label>),\n-    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n-    /// `'label: loop { block }`\n+    /// I.e., `'label: loop { <block> }`.\n     Loop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n-    /// A closure (for example, `move |a, b, c| {a + b + c}`).\n+    /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`\n+    /// The final span is the span of the argument block `|...|`.\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an GeneratorClause.\n+    /// in that case there is an `GeneratorClause`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n-    /// A block (`'label: { ... }`)\n+    /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n \n-    /// An assignment (`a = foo()`)\n+    /// An assignment (e.g., `a = foo()`).\n     Assign(P<Expr>, P<Expr>),\n-    /// An assignment with an operator\n+    /// An assignment with an operator.\n     ///\n-    /// For example, `a += 1`.\n+    /// E.g., `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n+    /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct or tuple field.\n     Field(P<Expr>, Ident),\n-    /// An indexing operation (`foo[2]`)\n+    /// An indexing operation (`foo[2]`).\n     Index(P<Expr>, P<Expr>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (`&a` or `&mut a`)\n+    /// A referencing operation (i.e., `&a` or `&mut a`).\n     AddrOf(Mutability, P<Expr>),\n-    /// A `break`, with an optional label to break\n+    /// A `break`, with an optional label to break.\n     Break(Destination, Option<P<Expr>>),\n-    /// A `continue`, with an optional label\n+    /// A `continue`, with an optional label.\n     Continue(Destination),\n-    /// A `return`, with an optional value to be returned\n+    /// A `return`, with an optional value to be returned.\n     Ret(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n@@ -1518,10 +1514,10 @@ pub enum ExprKind {\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, AnonConst),\n \n-    /// A suspension point for generators. This is `yield <expr>` in Rust.\n+    /// A suspension point for generators (i.e., `yield <expr>`).\n     Yield(P<Expr>),\n \n-    /// Placeholder for an expression that wasn't syntactically well formed in some way.\n+    /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }\n \n@@ -1531,12 +1527,12 @@ pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n-    /// e.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// E.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n     Resolved(Option<P<Ty>>, P<Path>),\n \n-    /// Type-related paths, e.g., `<T>::default` or `<T>::Output`.\n+    /// Type-related paths (e.g., `<T>::default` or `<T>::Output`).\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n@@ -1545,41 +1541,41 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n-/// Hints at the original code for a let statement\n+/// Hints at the original code for a let statement.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LocalSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n }\n \n-/// Hints at the original code for a `match _ { .. }`\n+/// Hints at the original code for a `match _ { .. }`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// An `if let _ = _ { .. }` (optionally with `else { .. }`)\n+    /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n     /// A `while let _ = _ { .. }` (which was desugared to a\n-    /// `loop { match _ { .. } }`)\n+    /// `loop { match _ { .. } }`).\n     WhileLetDesugar,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n-    /// A desugared `?` operator\n+    /// A desugared `?` operator.\n     TryDesugar,\n }\n \n-/// The loop type that yielded an ExprKind::Loop\n+/// The loop type that yielded an `ExprKind::Loop`.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LoopSource {\n-    /// A `loop { .. }` loop\n+    /// A `loop { .. }` loop.\n     Loop,\n-    /// A `while let _ = _ { .. }` loop\n+    /// A `while let _ = _ { .. }` loop.\n     WhileLet,\n-    /// A `for _ in _ { .. }` loop\n+    /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n \n@@ -1745,7 +1741,7 @@ impl fmt::Debug for Ty {\n     }\n }\n \n-/// Not represented directly in the AST, referred to by name through a ty_path.\n+/// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {\n     Int(IntTy),\n@@ -1772,38 +1768,38 @@ pub struct ExistTy {\n     pub impl_trait_fn: Option<DefId>,\n }\n \n+/// The various kinds of types recognized by the compiler.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-/// The different kinds of types recognized by the compiler\n pub enum TyKind {\n-    /// A variable length slice (`[T]`)\n+    /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n-    /// A fixed length array (`[T; n]`)\n+    /// A fixed length array (i.e., `[T; n]`).\n     Array(P<Ty>, AnonConst),\n-    /// A raw pointer (`*const T` or `*mut T`)\n+    /// A raw pointer (i.e., `*const T` or `*mut T`).\n     Ptr(MutTy),\n-    /// A reference (`&'a T` or `&'a mut T`)\n+    /// A reference (i.e., `&'a T` or `&'a mut T`).\n     Rptr(Lifetime, MutTy),\n-    /// A bare function (e.g., `fn(usize) -> bool`)\n+    /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(P<BareFnTy>),\n-    /// The never type (`!`)\n+    /// The never type (`!`).\n     Never,\n-    /// A tuple (`(A, B, C, D,...)`)\n+    /// A tuple (`(A, B, C, D,...)`).\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n-    /// associated type, e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`.\n+    /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n     /// A type definition itself. This is currently only used for the `existential type`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n-    /// The generic arg list are the lifetimes (and in the future possibly parameters) that are\n-    /// actually bound on the `impl Trait`.\n+    /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n+    /// that are actually bound on the `impl Trait`.\n     Def(ItemId, HirVec<GenericArg>),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// Unused for now\n+    /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n@@ -1833,15 +1829,15 @@ pub struct InlineAsm {\n     pub ctxt: SyntaxContext,\n }\n \n-/// represents an argument in a function header\n+/// Represents an argument in a function header.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n-/// Represents the header (not the body) of a function declaration\n+/// Represents the header (not the body) of a function declaration.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n@@ -1964,7 +1960,7 @@ pub enum FunctionRetTy {\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n-    /// Everything else\n+    /// Everything else.\n     Return(P<Ty>),\n }\n \n@@ -2017,7 +2013,7 @@ pub struct VariantKind {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n-    /// Explicit discriminant, e.g., `Foo = 1`\n+    /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n }\n \n@@ -2053,7 +2049,7 @@ pub struct TraitRef {\n }\n \n impl TraitRef {\n-    /// Get the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n+    /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.def {\n             Def::Trait(did) => did,\n@@ -2068,10 +2064,10 @@ impl TraitRef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct PolyTraitRef {\n-    /// The `'a` in `<'a> Foo<&'a T>`\n+    /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n \n-    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n \n     pub span: Span,\n@@ -2229,7 +2225,7 @@ pub struct FnHeader {\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// e.g., `extern crate foo` or `extern crate foo_bar as foo`\n+    /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n     ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2326,7 +2322,7 @@ impl ItemKind {\n /// contains the item's id, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItemRef {\n@@ -2338,10 +2334,10 @@ pub struct TraitItemRef {\n }\n \n /// A reference from an impl to one of its associated items. This\n-/// contains the item's id, naturally, but also the item's name and\n+/// contains the item's ID, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItemRef {\n@@ -2372,15 +2368,15 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-/// An item within an `extern` block\n+/// An item within an `extern` block.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ForeignItemKind {\n-    /// A foreign function\n+    /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n-    /// (the boolean is true when mutable)\n+    /// (the boolean is true when mutable).\n     Static(P<Ty>, bool),\n-    /// A foreign type\n+    /// A foreign type.\n     Type,\n }\n \n@@ -2464,36 +2460,37 @@ pub struct CodegenFnAttrs {\n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     pub struct CodegenFnAttrFlags: u32 {\n-        /// #[cold], a hint to LLVM that this function, when called, is never on\n-        /// the hot path\n+        /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n+        /// the hot path.\n         const COLD                      = 1 << 0;\n-        /// #[allocator], a hint to LLVM that the pointer returned from this\n-        /// function is never null\n+        /// `#[allocator]`: a hint to LLVM that the pointer returned from this\n+        /// function is never null.\n         const ALLOCATOR                 = 1 << 1;\n-        /// #[unwind], an indicator that this function may unwind despite what\n-        /// its ABI signature may otherwise imply\n+        /// `#[unwind]`: an indicator that this function may unwind despite what\n+        /// its ABI signature may otherwise imply.\n         const UNWIND                    = 1 << 2;\n-        /// #[rust_allocator_nounwind], an indicator that an imported FFI\n+        /// `#[rust_allocator_nounwind]`, an indicator that an imported FFI\n         /// function will never unwind. Probably obsolete by recent changes with\n         /// #[unwind], but hasn't been removed/migrated yet\n         const RUSTC_ALLOCATOR_NOUNWIND  = 1 << 3;\n-        /// #[naked], indicates to LLVM that no function prologue/epilogue\n-        /// should be generated\n+        /// `#[naked]`: an indicator to LLVM that no function prologue/epilogue\n+        /// should be generated.\n         const NAKED                     = 1 << 4;\n-        /// #[no_mangle], the function's name should be the same as its symbol\n+        /// `#[no_mangle]`: an indicator that the function's name should be the same\n+        /// as its symbol.\n         const NO_MANGLE                 = 1 << 5;\n-        /// #[rustc_std_internal_symbol], and indicator that this symbol is a\n+        /// `#[rustc_std_internal_symbol]`: an indicator that this symbol is a\n         /// \"weird symbol\" for the standard library in that it has slightly\n         /// different linkage, visibility, and reachability rules.\n         const RUSTC_STD_INTERNAL_SYMBOL = 1 << 6;\n-        /// #[no_debug], indicates that no debugging information should be\n-        /// generated for this function by LLVM\n+        /// `#[no_debug]`: an indicator that no debugging information should be\n+        /// generated for this function by LLVM.\n         const NO_DEBUG                  = 1 << 7;\n-        /// #[thread_local], indicates a static is actually a thread local\n+        /// `#[thread_local]`: indicates a static is actually a thread local\n         /// piece of memory\n         const THREAD_LOCAL              = 1 << 8;\n-        /// #[used], indicates that LLVM can't eliminate this function (but the\n-        /// linker can!)\n+        /// `#[used]`: indicates that LLVM can't eliminate this function (but the\n+        /// linker can!).\n         const USED                      = 1 << 9;\n     }\n }\n@@ -2512,7 +2509,7 @@ impl CodegenFnAttrs {\n         }\n     }\n \n-    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    /// Returns `true` if `#[inline]` or `#[inline(always)]` is present.\n     pub fn requests_inline(&self) -> bool {\n         match self.inline {\n             InlineAttr::Hint | InlineAttr::Always => true,"}, {"sha": "e2df290a455c4afb6f0118072d003f8b87e4f451", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use hir::{self, HirId, PatKind};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::hir::{self, HirId, PatKind};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -129,7 +129,7 @@ impl hir::Pat {\n         }\n     }\n \n-    /// Return variants that are necessary to exist for the pattern to match.\n+    /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n         self.walk(|p| {\n@@ -154,11 +154,9 @@ impl hir::Pat {\n \n     /// Checks if the pattern contains any `ref` or `ref mut` bindings, and if\n     /// yes whether it contains mutable or just immutables ones.\n-    ///\n-    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n-    /// ref bindings are be implicit after #42640 (default match binding modes).\n-    ///\n-    /// See #44848.\n+    //\n+    // FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n+    // ref bindings are be implicit after #42640 (default match binding modes). See issue #44848.\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {"}, {"sha": "9b6fcf259be14ba49f0373fbc0a5be44db5c6216", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -11,9 +11,9 @@ use syntax::symbol::keywords;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n-use hir;\n-use hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n-use hir::{GenericParam, GenericParamKind, GenericArg};\n+use crate::hir;\n+use crate::hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n+use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -2401,7 +2401,7 @@ fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n }\n \n fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n-    use hir::BinOpKind::*;\n+    use crate::hir::BinOpKind::*;\n     match op {\n         Add => AssocOp::Add,\n         Sub => AssocOp::Subtract,"}, {"sha": "e60fdd62debd1f6249e6e1421db5d6d9f66d909a", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,11 +1,11 @@\n-use hir;\n-use hir::def_id::{DefId, DefIndex};\n-use hir::map::DefPathHash;\n-use hir::map::definitions::Definitions;\n-use ich::{self, CachingSourceMapView, Fingerprint};\n-use middle::cstore::CrateStore;\n-use ty::{TyCtxt, fast_reject};\n-use session::Session;\n+use crate::hir;\n+use crate::hir::def_id::{DefId, DefIndex};\n+use crate::hir::map::DefPathHash;\n+use crate::hir::map::definitions::Definitions;\n+use crate::ich::{self, CachingSourceMapView, Fingerprint};\n+use crate::middle::cstore::CrateStore;\n+use crate::ty::{TyCtxt, fast_reject};\n+use crate::session::Session;\n \n use std::cmp::Ord;\n use std::hash as std_hash;\n@@ -218,7 +218,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> ::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n+impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n }\n \n "}, {"sha": "17ed1a79d45e0ae293a3248b1b3d750e0995cdb5", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,54 +1,52 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::middle::cstore in no particular order.\n \n-use middle;\n-\n-impl_stable_hash_for!(enum middle::cstore::DepKind {\n+impl_stable_hash_for!(enum crate::middle::cstore::DepKind {\n     UnexportedMacrosOnly,\n     MacrosOnly,\n     Implicit,\n     Explicit\n });\n \n-impl_stable_hash_for!(enum middle::cstore::NativeLibraryKind {\n+impl_stable_hash_for!(enum crate::middle::cstore::NativeLibraryKind {\n     NativeStatic,\n     NativeStaticNobundle,\n     NativeFramework,\n     NativeUnknown\n });\n \n-impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n+impl_stable_hash_for!(struct crate::middle::cstore::NativeLibrary {\n     kind,\n     name,\n     cfg,\n     foreign_module,\n     wasm_import_module\n });\n \n-impl_stable_hash_for!(struct middle::cstore::ForeignModule {\n+impl_stable_hash_for!(struct crate::middle::cstore::ForeignModule {\n     foreign_items,\n     def_id\n });\n \n-impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n+impl_stable_hash_for!(enum crate::middle::cstore::LinkagePreference {\n     RequireDynamic,\n     RequireStatic\n });\n \n-impl_stable_hash_for!(struct middle::cstore::ExternCrate {\n+impl_stable_hash_for!(struct crate::middle::cstore::ExternCrate {\n     src,\n     span,\n     path_len,\n     direct\n });\n \n-impl_stable_hash_for!(enum middle::cstore::ExternCrateSource {\n+impl_stable_hash_for!(enum crate::middle::cstore::ExternCrateSource {\n     Extern(def_id),\n     Use,\n     Path,\n });\n \n-impl_stable_hash_for!(struct middle::cstore::CrateSource {\n+impl_stable_hash_for!(struct crate::middle::cstore::CrateSource {\n     dylib,\n     rlib,\n     rmeta"}, {"sha": "712fd360fbb6fffd31e423b2ad96f18387a6de9a", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n //! This module contains `HashStable` implementations for various HIR data\n //! types in no particular order.\n \n-use hir;\n-use hir::map::DefPathHash;\n-use hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n-use ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n+use crate::hir;\n+use crate::hir::map::DefPathHash;\n+use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n+use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n@@ -619,7 +619,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use hir::MatchSource;\n+        use crate::hir::MatchSource;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -1046,6 +1046,7 @@ impl_stable_hash_for!(enum hir::def::Def {\n     AssociatedExistential(def_id),\n     PrimTy(prim_ty),\n     TyParam(def_id),\n+    ConstParam(def_id),\n     SelfTy(trait_def_id, impl_def_id),\n     ForeignTy(def_id),\n     Fn(def_id),\n@@ -1116,20 +1117,20 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl_stable_hash_for!(struct ::middle::lib_features::LibFeatures {\n+impl_stable_hash_for!(struct crate::middle::lib_features::LibFeatures {\n     stable,\n     unstable\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ::middle::lang_items::LangItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n+impl_stable_hash_for!(struct crate::middle::lang_items::LanguageItems {\n     items,\n     missing\n });"}, {"sha": "51fc78ffc866999844ffae550ed852d3d3de437d", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n //! This module contains `HashStable` implementations for various MIR data\n //! types in no particular order.\n \n-use ich::StableHashingContext;\n-use mir;\n+use crate::ich::StableHashingContext;\n+use crate::mir;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::mem;"}, {"sha": "8a388fafce5e8201717ca6262683abdb7dcc3f3d", "filename": "src/librustc/ich/impls_misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! that don't fit into any of the other impls_xxx modules.\n \n-impl_stable_hash_for!(enum ::session::search_paths::PathKind {\n+impl_stable_hash_for!(enum crate::session::search_paths::PathKind {\n     Native,\n     Crate,\n     Dependency,"}, {"sha": "f34423ccca655b065b3fe1a3eb706106646ed355", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from libsyntax in no particular order.\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n \n use std::hash as std_hash;\n use std::mem;\n@@ -13,7 +13,7 @@ use syntax::symbol::{InternedString, LocalInternedString};\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n-use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n+use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,"}, {"sha": "1e1dbd0b621ec2fbd303de733a5401227ed7a887", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,18 +1,18 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::hash as std_hash;\n use std::mem;\n-use middle::region;\n-use infer;\n-use traits;\n-use ty;\n-use mir;\n+use crate::middle::region;\n+use crate::infer;\n+use crate::traits;\n+use crate::ty;\n+use crate::mir;\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for &'gcx ty::List<T>\n@@ -306,7 +306,7 @@ impl_stable_hash_for!(\n         ByRef(id, alloc, offset),\n     }\n );\n-impl_stable_hash_for!(struct ::mir::interpret::RawConst<'tcx> {\n+impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {\n     alloc_id,\n     ty,\n });\n@@ -512,20 +512,22 @@ impl_stable_hash_for!(enum ty::GenericParamDefKind {\n });\n \n impl_stable_hash_for!(\n-    impl<T> for enum ::middle::resolve_lifetime::Set1<T> [ ::middle::resolve_lifetime::Set1 ] {\n+    impl<T> for enum crate::middle::resolve_lifetime::Set1<T>\n+        [ crate::middle::resolve_lifetime::Set1 ]\n+    {\n         Empty,\n         Many,\n         One(value),\n     }\n );\n \n-impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n+impl_stable_hash_for!(enum crate::middle::resolve_lifetime::LifetimeDefOrigin {\n     ExplicitOrElided,\n     InBand,\n     Error,\n });\n \n-impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n+impl_stable_hash_for!(enum crate::middle::resolve_lifetime::Region {\n     Static,\n     EarlyBound(index, decl, is_in_band),\n     LateBound(db_index, decl, is_in_band),\n@@ -547,9 +549,9 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(struct ::middle::region::Scope { id, data });\n+impl_stable_hash_for!(struct crate::middle::region::Scope { id, data });\n \n-impl_stable_hash_for!(enum ::middle::region::ScopeData {\n+impl_stable_hash_for!(enum crate::middle::region::ScopeData {\n     Node,\n     CallSite,\n     Arguments,\n@@ -588,7 +590,7 @@ for ty::TyKind<'gcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::TyKind::*;\n+        use crate::ty::TyKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -882,20 +884,20 @@ impl_stable_hash_for!(enum traits::Reveal {\n     All\n });\n \n-impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n+impl_stable_hash_for!(enum crate::middle::privacy::AccessLevel {\n     ReachableFromImplTrait,\n     Reachable,\n     Exported,\n     Public\n });\n \n impl<'a> HashStable<StableHashingContext<'a>>\n-for ::middle::privacy::AccessLevels {\n+for crate::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            let ::middle::privacy::AccessLevels {\n+            let crate::middle::privacy::AccessLevels {\n                 ref map\n             } = *self;\n \n@@ -908,14 +910,14 @@ impl_stable_hash_for!(struct ty::CrateInherentImpls {\n     inherent_impls\n });\n \n-impl_stable_hash_for!(enum ::session::CompileIncomplete {\n+impl_stable_hash_for!(enum crate::session::CompileIncomplete {\n     Stopped,\n     Errored(error_reported)\n });\n \n-impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n+impl_stable_hash_for!(struct crate::util::common::ErrorReported {});\n \n-impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n+impl_stable_hash_for!(tuple_struct crate::middle::reachable::ReachableSet {\n     reachable_set\n });\n \n@@ -924,7 +926,7 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::Vtable::*;\n+        use crate::traits::Vtable::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -1105,7 +1107,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WhereClause::*;\n+        use crate::traits::WhereClause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1121,7 +1123,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WellFormed::*;\n+        use crate::traits::WellFormed::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1135,7 +1137,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::FromEnv::*;\n+        use crate::traits::FromEnv::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1149,7 +1151,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::DomainGoal::*;\n+        use crate::traits::DomainGoal::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1165,7 +1167,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::GoalKind::*;\n+        use crate::traits::GoalKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1208,7 +1210,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::Clause::*;\n+        use crate::traits::Clause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {"}, {"sha": "34cd3ae5427e0ff849f6456615533a396bb3f5a6", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-//! A nice interface for working with the infcx.  The basic idea is to\n+//! A nice interface for working with the infcx. The basic idea is to\n //! do `infcx.at(cause, param_env)`, which sets the \"cause\" of the\n-//! operation as well as the surrounding parameter environment.  Then\n+//! operation as well as the surrounding parameter environment. Then\n //! you can do something like `.sub(a, b)` or `.eq(a, b)` to create a\n //! subtype or equality relationship respectively. The first argument\n //! is always the \"expected\" output from the POV of diagnostics.\n@@ -27,7 +27,7 @@\n \n use super::*;\n \n-use ty::relate::{Relate, TypeRelation};\n+use crate::ty::relate::{Relate, TypeRelation};\n \n pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Make `a <: b` where `a` may or may not be expected\n+    /// Makes `a <: b`, where `a` may or may not be expected.\n     pub fn sub_exp<T>(self,\n                       a_is_expected: bool,\n                       a: T,\n@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n     }\n \n-    /// Make `actual <: expected`. For example, if type-checking a\n+    /// Makes `actual <: expected`. For example, if type-checking a\n     /// call like `foo(x)`, where `foo: fn(i32)`, you might have\n     /// `sup(i32, x)`, since the \"expected\" type is the type that\n     /// appears in the signature.\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(false, actual, expected)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   expected: T,\n                   actual: T)\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(true, expected, actual)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq_exp<T>(self,\n                      a_is_expected: bool,\n                      a: T,\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq<T>(self,\n                  expected: T,\n                  actual: T)\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound, or mutual supertype, of two\n+    /// Computes the least-upper-bound, or mutual supertype, of two\n     /// values. The order of the arguments doesn't matter, but since\n     /// this can result in an error (e.g., if asked to compute LUB of\n     /// u32 and i32), it is meaningful to call one of them the\n@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace(expected, actual).lub(&expected, &actual)\n     }\n \n-    /// Compute the greatest-lower-bound, or mutual subtype, of two\n+    /// Computes the greatest-lower-bound, or mutual subtype, of two\n     /// values. As with `lub` order doesn't matter, except for error\n     /// cases.\n     pub fn glb<T>(self,\n@@ -210,9 +210,9 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n-    /// Make `a <: b` where `a` may or may not be expected (if\n+    /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   a: &T,\n                   b: &T)\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Make `a == b`; the expectation is set by the call to\n+    /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     pub fn eq<T>(self,\n                  a: &T,"}, {"sha": "d06334c3ba64377dba6a44cbb9986d0d0c477fd9", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,15 +5,15 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::{\n+use crate::infer::canonical::{\n     Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n     OriginalQueryValues,\n };\n-use infer::InferCtxt;\n+use crate::infer::InferCtxt;\n use std::sync::atomic::Ordering;\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use ty::subst::Kind;\n-use ty::{self, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -112,14 +112,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// A hacky variant of `canonicalize_query` that does not\n-    /// canonicalize `'static`.  Unfortunately, the existing leak\n+    /// canonicalize `'static`. Unfortunately, the existing leak\n     /// check treaks `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n-    ///\n-    /// FIXME(#48536) -- once we have universes, we can remove this and just use\n-    /// `canonicalize_query`.\n+    //\n+    // FIXME(#48536): once we have universes, we can remove this and just use\n+    // `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,\n@@ -595,7 +595,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             .var_universe(vid)\n     }\n \n-    /// Create a canonical variable (with the given `info`)\n+    /// Creates a canonical variable (with the given `info`)\n     /// representing the region `r`; return a region referencing it.\n     fn canonical_var_for_region(\n         &mut self,"}, {"sha": "613e153ae33d4c73d0659f4c230aa715a3c594a4", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -21,16 +21,16 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n+use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n use syntax::source_map::Span;\n-use ty::fold::TypeFoldable;\n-use ty::subst::Kind;\n-use ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -289,7 +289,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`).  It basically\n+    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once\n@@ -393,14 +393,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n }\n \n CloneTypeFoldableAndLiftImpls! {\n-    ::infer::canonical::Certainty,\n-    ::infer::canonical::CanonicalVarInfo,\n-    ::infer::canonical::CanonicalVarKind,\n+    crate::infer::canonical::Certainty,\n+    crate::infer::canonical::CanonicalVarInfo,\n+    crate::infer::canonical::CanonicalVarKind,\n }\n \n CloneTypeFoldableImpls! {\n     for <'tcx> {\n-        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n     }\n }\n \n@@ -424,14 +424,14 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         self.var_values.len()\n     }\n \n-    /// Make an identity substitution from this one: each bound var\n+    /// Makes an identity substitution from this one: each bound var\n     /// is matched to the same bound var, preserving the original kinds.\n     /// For example, if we have:\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n     pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        use ty::subst::UnpackedKind;\n+        use crate::ty::subst::UnpackedKind;\n \n         CanonicalVarValues {\n             var_values: self.var_values.iter()"}, {"sha": "aef0152b6ed7332764057c554fcdc6b65c09cd43", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -7,26 +7,26 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::substitute::substitute_value;\n-use infer::canonical::{\n+use crate::infer::canonical::substitute::substitute_value;\n+use crate::infer::canonical::{\n     Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n     OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n-use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::InferCtxtBuilder;\n-use infer::{InferCtxt, InferOk, InferResult};\n+use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n+use crate::infer::InferCtxtBuilder;\n+use crate::infer::{InferCtxt, InferOk, InferResult};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n use syntax_pos::DUMMY_SP;\n-use traits::query::{Fallible, NoSolution};\n-use traits::TraitEngine;\n-use traits::{Obligation, ObligationCause, PredicateObligation};\n-use ty::fold::TypeFoldable;\n-use ty::subst::{Kind, UnpackedKind};\n-use ty::{self, BoundVar, Lift, Ty, TyCtxt};\n-use util::captures::Captures;\n+use crate::traits::query::{Fallible, NoSolution};\n+use crate::traits::TraitEngine;\n+use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::{Kind, UnpackedKind};\n+use crate::ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use crate::util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -119,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// If you DO want to keep track of pending obligations (which\n     /// include all region obligations, so this includes all cases\n     /// that care about regions) with this function, you have to\n-    /// do it yourself, by e.g. having them be a part of the answer.\n+    /// do it yourself, by e.g., having them be a part of the answer.\n     pub fn make_query_response_ignoring_pending_obligations<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n@@ -267,7 +267,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///   they should be ignored).\n     /// - It **can happen** (though it rarely does currently) that\n     ///   equating types and things will give rise to subobligations\n-    ///   that must be processed.  In this case, those subobligations\n+    ///   that must be processed. In this case, those subobligations\n     ///   are propagated back in the return value.\n     /// - Finally, the query result (of type `R`) is propagated back,\n     ///   after applying the substitution `S`.\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Given a \"guess\" at the values for the canonical variables in\n     /// the input, try to unify with the *actual* values found in the\n-    /// query result.  Often, but not always, this is a no-op, because\n+    /// query result. Often, but not always, this is a no-op, because\n     /// we already found the mapping in the \"guessing\" step.\n     ///\n     /// See also: `query_response_substitution_guess`"}, {"sha": "5af4e8366818bfee581c52356dba8c459462dd2e", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,10 +6,10 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::{Canonical, CanonicalVarValues};\n-use ty::fold::TypeFoldable;\n-use ty::subst::UnpackedKind;\n-use ty::{self, TyCtxt};\n+use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::UnpackedKind;\n+use crate::ty::{self, TyCtxt};\n \n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value"}, {"sha": "361fbfea09798efa0d3b9356f6fa878e0f55e459", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -29,13 +29,13 @@ use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n \n-use hir::def_id::DefId;\n-use ty::{IntType, UintType};\n-use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use ty::subst::Substs;\n-use traits::{Obligation, PredicateObligations};\n+use crate::hir::def_id::DefId;\n+use crate::ty::{IntType, UintType};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::subst::Substs;\n+use crate::traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -165,8 +165,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n-    /// Here dir is either EqTo, SubtypeOf, or SupertypeOf. The\n-    /// idea is that we should ensure that the type `a_ty` is equal\n+    /// Here, `dir` is either `EqTo`, `SubtypeOf`, or `SupertypeOf`.\n+    /// The idea is that we should ensure that the type `a_ty` is equal\n     /// to, a subtype of, or a supertype of (respectively) the type\n     /// to which `b_vid` is bound.\n     ///\n@@ -280,7 +280,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n-    /// Span, used when creating new type variables and things.\n+    /// The span, used when creating new type variables and things.\n     span: Span,\n \n     /// The vid of the type variable that is in the process of being\n@@ -310,7 +310,7 @@ struct Generalization<'tcx> {\n     /// particular around 'bivariant' type parameters that are only\n     /// constrained by a where-clause. As an example, imagine a type:\n     ///\n-    ///     struct Foo<A, B> where A: Iterator<Item=B> {\n+    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n     ///         data: A\n     ///     }\n     ///\n@@ -323,7 +323,7 @@ struct Generalization<'tcx> {\n     /// <: ?C`, but no particular relationship between `?B` and `?D`\n     /// (after all, we do not know the variance of the normalized form\n     /// of `A::Item` with respect to `A`). If we do nothing else, this\n-    /// may mean that `?D` goes unconstrained (as in #41677).  So, in\n+    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n     /// this scenario where we create a new type variable in a\n     /// bivariant context, we set the `needs_wf` flag to true. This\n     /// will force the calling code to check that `WF(Foo<?C, ?D>)`"}, {"sha": "a4b62307a60b861a39b455a43935fe433d137c17", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,12 +1,12 @@\n use super::combine::{CombineFields, RelationDir};\n use super::{Subtype};\n \n-use hir::def_id::DefId;\n+use crate::hir::def_id::DefId;\n \n-use ty::{self, Ty, TyCtxt};\n-use ty::TyVar;\n-use ty::subst::Substs;\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::TyVar;\n+use crate::ty::subst::Substs;\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "89237b34c7f6b1cde1f3fc0967f095feadf0bb73", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -48,19 +48,18 @@\n use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n-use infer::{self, SuppressRegionErrors};\n+use crate::infer::{self, SuppressRegionErrors};\n \n-use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use hir;\n-use hir::def_id::DefId;\n-use hir::Node;\n-use middle::region;\n+use crate::errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::Node;\n+use crate::middle::region;\n use std::{cmp, fmt};\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty::error::TypeError;\n-use ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n+use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty::error::TypeError;\n+use crate::ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n \n mod note;\n \n@@ -182,8 +181,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n-        let node = self.hir().as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-        let tag = match self.hir().find(node) {\n+        let node = self.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+        let tag = match self.hir().find_by_hir_id(node) {\n             Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n@@ -192,7 +191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n+                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&br.name))\n@@ -205,7 +204,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, ref name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n+                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&name))\n@@ -217,15 +216,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span(node),\n+                    self.hir().span_by_hir_id(node),\n                 ),\n                 ty::BrFresh(_) => (\n                     \"an anonymous lifetime defined on\".to_owned(),\n-                    self.hir().span(node),\n+                    self.hir().span_by_hir_id(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                    cm.def_span(self.hir().span(node)),\n+                    cm.def_span(self.hir().span_by_hir_id(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -660,7 +659,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// Add a `,` to the type representation only if it is appropriate.\n+    /// Adds a `,` to the type representation only if it is appropriate.\n     fn push_comma(\n         &self,\n         value: &mut DiagnosticStyledString,\n@@ -716,7 +715,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs.truncate_to(self.tcx, &generics)\n     }\n \n-    /// Compare two given types, eliding parts that are the same between them and highlighting\n+    /// Compares two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n@@ -1451,8 +1450,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n@@ -1479,7 +1477,7 @@ enum FailureCode {\n impl<'tcx> ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n-        use traits::ObligationCauseCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n@@ -1509,7 +1507,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     fn as_requirement_str(&self) -> &'static str {\n-        use traits::ObligationCauseCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\","}, {"sha": "fac498bd6dd78e7104d793ddf7b9f8fd9fef0bf5", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,11 +1,11 @@\n-use hir::{self, Local, Pat, Body, HirId};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use infer::InferCtxt;\n-use infer::type_variable::TypeVariableOrigin;\n-use ty::{self, Ty, Infer, TyVar};\n+use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::infer::InferCtxt;\n+use crate::infer::type_variable::TypeVariableOrigin;\n+use crate::ty::{self, Ty, Infer, TyVar};\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n \n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "5d5a9b36087a256db4781bb480a52e94a9af2c12", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n-use util::common::ErrorReported;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::util::common::ErrorReported;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///     x.push(y);\n     ///     ^ ...but data from `y` flows into `x` here\n     /// }\n-    /// ````\n+    /// ```\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {"}, {"sha": "ea748874fc4e20a13e657fa68a0499119e5e22d1", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n-use hir;\n-use ty::{self, Region, TyCtxt};\n-use hir::Node;\n-use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::hir;\n+use crate::ty::{self, Region, TyCtxt};\n+use crate::hir::Node;\n+use crate::middle::resolve_lifetime as rl;\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters\n@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n             hir::TyKind::Rptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n-                let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n+                let hir_id = lifetime.hir_id;\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n                     // Find the index of the anonymous region that was part of the\n                     // error. We will then search the function parameters for a bound\n@@ -221,8 +221,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n-        match (self.tcx.named_region(hir_id), self.bound_region) {\n+        match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n             (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n                 if debruijn_index == self.current_index && anon_index == br_index {"}, {"sha": "dad1e3ba80da340ddf27a1fa634270f0c2a7dd3c", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n-use infer::InferCtxt;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n+use crate::infer::InferCtxt;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n use syntax::source_map::Span;\n-use ty::{self, TyCtxt};\n-use util::common::ErrorReported;\n+use crate::ty::{self, TyCtxt};\n+use crate::util::common::ErrorReported;\n \n mod different_lifetimes;\n mod find_anon_type;"}, {"sha": "d66bb274b34cef2b0d328724b2e494106c555571", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use ty;\n-use util::common::ErrorReported;\n-use errors::Applicability;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::ty;\n+use crate::util::common::ErrorReported;\n+use crate::errors::Applicability;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and"}, {"sha": "6432780de067032603fc247c36d942345e7c3089", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,13 +1,13 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::SubregionOrigin;\n-use ty::RegionKind;\n-use hir::{Expr, ExprKind::Closure};\n-use hir::Node;\n-use util::common::ErrorReported;\n-use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::SubregionOrigin;\n+use crate::ty::RegionKind;\n+use crate::hir::{Expr, ExprKind::Closure};\n+use crate::hir::Node;\n+use crate::util::common::ErrorReported;\n+use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when binding escapes a closure."}, {"sha": "6893a1fb168b8bc8cfd4f2d468bc7e86be1b7b5e", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,15 +1,15 @@\n-use errors::DiagnosticBuilder;\n-use hir::def_id::DefId;\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use infer::ValuePairs;\n-use infer::{SubregionOrigin, TypeTrace};\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty;\n-use ty::error::ExpectedFound;\n-use ty::subst::Substs;\n-use util::common::ErrorReported;\n-use util::ppaux::RegionHighlightMode;\n+use crate::errors::DiagnosticBuilder;\n+use crate::hir::def_id::DefId;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::ValuePairs;\n+use crate::infer::{SubregionOrigin, TypeTrace};\n+use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::subst::Substs;\n+use crate::util::common::ErrorReported;\n+use crate::util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and"}, {"sha": "3f0297952278a104bd8639b717b3d084495864ac", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n //! Error Reporting for static impl Traits.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use ty::{BoundRegion, FreeRegion, RegionKind};\n-use util::common::ErrorReported;\n-use errors::Applicability;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n+use crate::util::common::ErrorReported;\n+use crate::errors::Applicability;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait."}, {"sha": "f73f8d8bb82be1b546ba8b53bc0418205c82c867", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n \n-use hir;\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use ty::{self, Region, Ty};\n-use hir::def_id::DefId;\n+use crate::hir;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::ty::{self, Region, Ty};\n+use crate::hir::def_id::DefId;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region"}, {"sha": "6c481e8c0c11437a65cb740faaf3d023b4b80e80", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n-use infer::{self, InferCtxt, SubregionOrigin};\n-use middle::region;\n-use ty::{self, Region};\n-use ty::error::TypeError;\n-use errors::DiagnosticBuilder;\n+use crate::infer::{self, InferCtxt, SubregionOrigin};\n+use crate::middle::region;\n+use crate::ty::{self, Region};\n+use crate::ty::error::TypeError;\n+use crate::errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub(super) fn note_region_origin(&self,\n@@ -31,8 +31,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n             }\n@@ -164,8 +163,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,"}, {"sha": "201717b34ee41abfb18b89a5854c2e6925b26d69", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -31,9 +31,9 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::TypeFolder;\n-use util::nodemap::FxHashMap;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::fold::TypeFolder;\n+use crate::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n "}, {"sha": "5f6a8802b4defbe7a8b9f7b5e66a41d4384b6f80", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use infer::type_variable::TypeVariableMap;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use crate::infer::type_variable::TypeVariableMap;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n use super::InferCtxt;\n use super::RegionVariableOrigin;\n@@ -22,13 +22,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// closure `f`. In our example above, what this closure will do\n     /// is to unify the expectation (`Option<&[u32]>`) with the actual\n     /// return type (`Option<?T>`, where `?T` represents the variable\n-    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// instantiated for `T`). This will cause `?T` to be unified\n     /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n     /// input type (`?T`) is then returned by `f()`.\n     ///\n     /// At this point, `fudge_regions_if_ok` will normalize all type\n     /// variables, converting `?T` to `&?a [u32]` and end the\n-    /// snapshot.  The problem is that we can't just return this type\n+    /// snapshot. The problem is that we can't just return this type\n     /// out, because it references the region variable `?a`, and that\n     /// region variable was popped when we popped the snapshot.\n     ///"}, {"sha": "910c6571853dc078580721c9068b19672b41b876", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,9 +3,9 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n-use traits::ObligationCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "7f01078737d73cd3af8e7f0ff8acd17df1faaf53", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,8 +4,8 @@\n use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use ty::relate::{Relate, RelateResult, TypeRelation};\n-use ty::{self, Binder, TypeFoldable};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all regions (resp. types) bound by `binder` with placeholder\n+    /// Replaces all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n     /// placeholder region. This is the first step of checking subtyping\n     /// when higher-ranked things are involved."}, {"sha": "e40bb9724076354dfc36734dcfd90b0d0832b2d3", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n //! # Lattice Variables\n //!\n //! This file contains generic code for operating on inference variables\n-//! that are characterized by an upper- and lower-bound.  The logic and\n+//! that are characterized by an upper- and lower-bound. The logic and\n //! reasoning is explained in detail in the large comment in `infer.rs`.\n //!\n //! The code in here is defined quite generically so that it can be\n@@ -13,7 +13,7 @@\n //!\n //! Although all the functions are generic, we generally write the\n //! comments in a way that is specific to type variables and the LUB\n-//! operation.  It's just easier that way.\n+//! operation. It's just easier that way.\n //!\n //! In general all of the functions are defined parametrically\n //! over a `LatticeValue`, which is a value defined with respect to\n@@ -22,10 +22,10 @@\n use super::InferCtxt;\n use super::type_variable::TypeVariableOrigin;\n \n-use traits::ObligationCause;\n-use ty::TyVar;\n-use ty::{self, Ty};\n-use ty::relate::{RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::TyVar;\n+use crate::ty::{self, Ty};\n+use crate::ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;"}, {"sha": "073a3f74422c6ff2bdf82ca62f0e3fe2f7b4ecc6", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -8,14 +8,14 @@\n /// For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use hir::def_id::DefIndex;\n-use ty;\n-use middle::free_region::RegionRelations;\n-use middle::region;\n+use crate::hir::def_id::DefIndex;\n+use crate::ty;\n+use crate::middle::free_region::RegionRelations;\n+use crate::middle::region;\n use super::Constraint;\n-use infer::SubregionOrigin;\n-use infer::region_constraints::RegionConstraintData;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use crate::infer::SubregionOrigin;\n+use crate::infer::region_constraints::RegionConstraintData;\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;"}, {"sha": "03ade8825368273ff756a282d20cf7a6352bf8c4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,13 +1,13 @@\n-//! The code to do lexical region resolution.\n-\n-use infer::region_constraints::Constraint;\n-use infer::region_constraints::GenericKind;\n-use infer::region_constraints::RegionConstraintData;\n-use infer::region_constraints::VarInfos;\n-use infer::region_constraints::VerifyBound;\n-use infer::RegionVariableOrigin;\n-use infer::SubregionOrigin;\n-use middle::free_region::RegionRelations;\n+//! Lexical region resolution.\n+\n+use crate::infer::region_constraints::Constraint;\n+use crate::infer::region_constraints::GenericKind;\n+use crate::infer::region_constraints::RegionConstraintData;\n+use crate::infer::region_constraints::VarInfos;\n+use crate::infer::region_constraints::VerifyBound;\n+use crate::infer::RegionVariableOrigin;\n+use crate::infer::SubregionOrigin;\n+use crate::middle::free_region::RegionRelations;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n@@ -16,11 +16,11 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n use std::u32;\n-use ty::fold::TypeFoldable;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n-use ty::{Region, RegionVid};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use crate::ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n+use crate::ty::{Region, RegionVid};\n \n mod graphviz;\n \n@@ -492,20 +492,20 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n-                    /* Inference impossible, this value contains\n+                    /* Inference impossible: this value contains\n                        inconsistent constraints.\n \n                        I think that in this case we should report an\n-                       error now---unlike the case above, we can't\n+                       error now -- unlike the case above, we can't\n                        wait to see whether the user needs the result\n-                       of this variable.  The reason is that the mere\n+                       of this variable. The reason is that the mere\n                        existence of this variable implies that the\n                        region graph is inconsistent, whether or not it\n                        is used.\n \n                        For example, we may have created a region\n                        variable that is the GLB of two other regions\n-                       which do not have a GLB.  Even if that variable\n+                       which do not have a GLB. Even if that variable\n                        is not used, it implies that those two regions\n                        *should* have a GLB.\n "}, {"sha": "f9eb60d82d17b5c38d6aa61e5514dc4f8c0b65a7", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,9 +3,9 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n-use traits::ObligationCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "c183c1adb122d2ffccd83cabcdd235a62a452137", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,31 +5,31 @@ pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n-pub use ty::IntVarValue;\n+pub use crate::ty::IntVarValue;\n \n use arena::SyncDroplessArena;\n-use errors::DiagnosticBuilder;\n-use hir::def_id::DefId;\n-use infer::canonical::{Canonical, CanonicalVarValues};\n-use middle::free_region::RegionRelations;\n-use middle::lang_items;\n-use middle::region;\n+use crate::errors::DiagnosticBuilder;\n+use crate::hir::def_id::DefId;\n+use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::middle::free_region::RegionRelations;\n+use crate::middle::lang_items;\n+use crate::middle::region;\n use rustc_data_structures::unify as ut;\n-use session::config::BorrowckMode;\n+use crate::session::config::BorrowckMode;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use syntax_pos::symbol::InternedString;\n use syntax_pos::{self, Span};\n-use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n-use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n-use ty::subst::{Kind, Substs};\n-use ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n-use ty::{FloatVid, IntVid, TyVid};\n-use util::nodemap::FxHashMap;\n+use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::relate::RelateResult;\n+use crate::ty::subst::{Kind, Substs};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n+use crate::ty::{FloatVid, IntVid, TyVid};\n+use crate::util::nodemap::FxHashMap;\n \n use self::combine::CombineFields;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n@@ -221,7 +221,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n /// replaced with.\n pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n-/// See `error_reporting` module for more details\n+/// See the `error_reporting` module for more details.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -233,7 +233,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting` module for more details.\n+/// See the `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -454,9 +454,9 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-/// Helper type of a temporary returned by tcx.infer_ctxt().\n+/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n@@ -487,7 +487,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n     /// invoked with the new infcx, along with the instantiated value\n-    /// `V` and a substitution `S`.  This substitution `S` maps from\n+    /// `V` and a substitution `S`. This substitution `S` maps from\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n     pub fn enter_with_canonical<T, R>(\n@@ -563,7 +563,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n         }\n     }\n \n-    /// Extract `value`, registering any obligations into `fulfill_cx`\n+    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n     pub fn into_value_registering_obligations(\n         self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -617,8 +617,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use ty::error::UnconstrainedNumeric::Neither;\n-        use ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n+        use crate::ty::error::UnconstrainedNumeric::Neither;\n+        use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.sty {\n             ty::Infer(ty::IntVar(vid)) => {\n                 if self.int_unification_table\n@@ -794,7 +794,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .commit(region_constraints_snapshot);\n     }\n \n-    /// Execute `f` and commit the bindings\n+    /// Executes `f` and commit the bindings.\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce() -> R,\n@@ -806,7 +806,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n+    /// Executes `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n@@ -838,7 +838,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` then unroll any bindings it creates\n+    /// Executes `f` then unroll any bindings it creates.\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n@@ -996,14 +996,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n-    /// Create a fresh region variable with the next available index.\n+    /// Creates a fresh region variable with the next available index.\n     /// The variable will be created in the maximum universe created\n     /// thus far, allowing it to name any region created thus far.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var_in_universe(origin, self.universe())\n     }\n \n-    /// Create a fresh region variable with the next available index\n+    /// Creates a fresh region variable with the next available index\n     /// in the given universe; typically, you can use\n     /// `next_region_var` and just use the maximal universe.\n     pub fn next_region_var_in_universe(\n@@ -1069,8 +1069,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n-    /// True if errors have been reported since this infcx was\n-    /// created.  This is sometimes used as a heuristic to skip\n+    /// Returns `true` if errors have been reported since this infcx was\n+    /// created. This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n@@ -1278,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns true if `T` contains unresolved type variables. In the\n+    /// Returns `true` if `T` contains unresolved type variables. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1291,14 +1291,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.visit_with(&mut r)\n     }\n \n-    pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n@@ -1369,7 +1361,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n-    /// See `verify_generic_bound` method in `region_constraints`\n+    /// See the [`region_constraints::verify_generic_bound`] method.\n     pub fn verify_generic_bound(\n         &self,\n         origin: SubregionOrigin<'tcx>,\n@@ -1421,7 +1413,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure.  For closures, unlike\n+    /// Obtain the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state.\n@@ -1466,8 +1458,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attempting to select an Obligation while changing only\n-    /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n+    /// repeatedly attempting to select an `Obligation` while changing only\n+    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n@@ -1478,7 +1470,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.universe.get()\n     }\n \n-    /// Create and return a fresh universe that extends all previous\n+    /// Creates and return a fresh universe that extends all previous\n     /// universes. Updates `self.universe` to that new universe.\n     pub fn create_next_universe(&self) -> ty::UniverseIndex {\n         let u = self.universe.get().next_universe();"}, {"sha": "f37e24b292e0351e172ad633fdc068df1ea75c3b", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -47,17 +47,17 @@ where\n \n     /// How are we relating `a` and `b`?\n     ///\n-    /// - covariant means `a <: b`\n-    /// - contravariant means `b <: a`\n-    /// - invariant means `a == b\n-    /// - bivariant means that it doesn't matter\n+    /// - Covariant means `a <: b`.\n+    /// - Contravariant means `b <: a`.\n+    /// - Invariant means `a == b.\n+    /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n \n     /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// a `fn` type), we push a new bound region scope onto here. This\n     /// will contain the instantiated region for each region in those\n     /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the debruijn index `d` to find the right scope, and then\n+    /// use the De Bruijn index `d` to find the right scope, and then\n     /// bound region name `br` to find the specific instantiation from\n     /// within that scope. See `replace_bound_region`.\n     ///\n@@ -114,7 +114,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// Define the normalization strategy to use, eager or lazy.\n     fn normalization() -> NormalizationStrategy;\n \n-    /// Enable some optimizations if we do not expect inference variables\n+    /// Enables some optimizations if we do not expect inference variables\n     /// in the RHS of the relation.\n     fn forbid_inference_vars() -> bool;\n }\n@@ -208,7 +208,7 @@ where\n     /// When we encounter binders during the type traversal, we record\n     /// the value to substitute for each of the things contained in\n     /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the debruijn index\n+    /// an existential inference variable.) Given the De Bruijn index\n     /// `debruijn` (and name `br`) of some binder we have now\n     /// encountered, this routine finds the value that we instantiated\n     /// the region with; to do so, it indexes backwards into the list"}, {"sha": "0e2c49a00dafe90a2dc2887586940d93deebee27", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,16 +1,16 @@\n-use hir::def_id::DefId;\n-use hir;\n-use hir::Node;\n-use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n-use infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::hir::def_id::DefId;\n+use crate::hir;\n+use crate::hir::Node;\n+use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n+use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits::{self, PredicateObligation};\n-use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use ty::outlives::Component;\n-use ty::subst::{Kind, Substs, UnpackedKind};\n-use util::nodemap::DefIdMap;\n+use crate::traits::{self, PredicateObligation};\n+use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n+use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n+use crate::ty::outlives::Component;\n+use crate::ty::subst::{Kind, Substs, UnpackedKind};\n+use crate::util::nodemap::DefIdMap;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -46,7 +46,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// lifetime parameter on `foo`.)\n     pub concrete_ty: Ty<'tcx>,\n \n-    /// True if the `impl Trait` bounds include region bounds.\n+    /// Returns `true` if the `impl Trait` bounds include region bounds.\n     /// For example, this would be true for:\n     ///\n     ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n@@ -71,7 +71,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all opaque types in `value` with fresh inference variables\n+    /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n     ///     impl Iterator<Item = impl Debug>\n@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `parent_def_id` -- the def-id of the function in which the opaque type\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n     ///   is defined\n     /// - `body_id` -- the body-id with which the resulting obligations should\n     ///   be associated\n@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # The Problem\n     ///\n-    /// Let's work through an example to explain how it works.  Assume\n+    /// Let's work through an example to explain how it works. Assume\n     /// the current function is as follows:\n     ///\n     /// ```text\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n     /// fresh inference variables C1 and C2. We wish to use the values\n     /// of these variables to infer the underlying types of `Foo1` and\n-    /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n+    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n     /// constraints like:\n     ///\n     /// ```text\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Ordinarily, the subtyping rules would ensure that these are\n     /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default.  This\n+    /// type per se, we don't get such constraints by default. This\n     /// is where this function comes into play. It adds extra\n     /// constraints to ensure that all the regions which appear in the\n     /// inferred type are regions that could validly appear.\n@@ -813,7 +813,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `opaque_node_id` is a sibling or a child of a sibling of `def_id`\n+/// Returns `true` if `opaque_node_id` is a sibling or a child of a sibling of `def_id`.\n ///\n /// ```rust\n /// pub mod foo {\n@@ -827,11 +827,10 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` will be the `DefId` of the existential type `Baz`.\n-/// `opaque_node_id` is the `NodeId` of the reference to Baz --\n-///  so either the return type of f1 or f2.\n-/// We will return true if the reference is within the same module as the existential type\n-/// So true for f1, false for f2.\n+/// Here, `def_id` is the `DefId` of the existential type `Baz` and `opaque_node_id` is the\n+/// `NodeId` of the reference to `Baz` (i.e., the return type of both `f1` and `f2`).\n+/// We return `true` if the reference is within the same module as the existential type\n+/// (i.e., `true` for `f1`, `false` for `f2`).\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,"}, {"sha": "43afb60ee17317321148c749e43efd14dc5cf1c7", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n-use infer::outlives::free_region_map::FreeRegionMap;\n-use infer::{GenericKind, InferCtxt};\n+use crate::infer::outlives::free_region_map::FreeRegionMap;\n+use crate::infer::{GenericKind, InferCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use syntax_pos::Span;\n-use traits::query::outlives_bounds::{self, OutlivesBound};\n-use ty::{self, Ty};\n+use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n+use crate::ty::{self, Ty};\n \n /// The `OutlivesEnvironment` collects information about what outlives\n /// what in a given type-checking setting. For example, if we have a\n@@ -63,7 +63,7 @@ pub struct OutlivesEnvironment<'tcx> {\n }\n \n /// \"Region-bound pairs\" tracks outlives relations that are known to\n-/// be true, either because of explicit where clauses like `T: 'a` or\n+/// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n "}, {"sha": "78353e52ad46264b4ec1ce575ab84a9336e6feb3", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use ty::{self, Lift, TyCtxt, Region};\n+use crate::ty::{self, Lift, TyCtxt, Region};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n@@ -24,7 +24,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound of two free regions. In some\n+    /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details."}, {"sha": "c40fbfb25e42246972347f4fb0cc8c7e9c1c7f34", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -55,18 +55,18 @@\n //! fn foo<U, F: for<'a> FnMut(&'a U)>(_f: F) {}\n //! ```\n //!\n-//! the type of the closure's first argument would be `&'a ?U`.  We\n+//! the type of the closure's first argument would be `&'a ?U`. We\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n \n-use infer::outlives::env::RegionBoundPairs;\n-use infer::outlives::verify::VerifyBoundCx;\n-use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::outlives::verify::VerifyBoundCx;\n+use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits::ObligationCause;\n-use ty::outlives::Component;\n-use ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use crate::traits::ObligationCause;\n+use crate::ty::outlives::Component;\n+use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved"}, {"sha": "494f708c6a7b79b4a0c27c8b455b7cd8ee438ed8", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n-use hir::def_id::DefId;\n-use infer::outlives::env::RegionBoundPairs;\n-use infer::{GenericKind, VerifyBound};\n-use traits;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt};\n-use util::captures::Captures;\n+use crate::hir::def_id::DefId;\n+use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::{GenericKind, VerifyBound};\n+use crate::traits;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::util::captures::Captures;\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n@@ -74,7 +74,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// This is an \"approximate\" check -- it may not find all\n     /// applicable bounds, and not all the bounds it returns can be\n     /// relied upon. In particular, this check ignores region\n-    /// identity.  So, for example, if we have `<T as\n+    /// identity. So, for example, if we have `<T as\n     /// Trait<'0>>::Item` where `'0` is a region variable, and the\n     /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n     /// the clause from the environment only applies if `'0 = 'a`,\n@@ -96,7 +96,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Searches the where clauses in scope for regions that\n+    /// Searches the where-clauses in scope for regions that\n     /// `projection_ty` is known to outlive. Currently requires an\n     /// exact match.\n     pub fn projection_declared_bounds_from_trait(\n@@ -251,7 +251,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .map(move |r| r.subst(tcx, projection_ty.substs))\n     }\n \n-    /// Given the def-id of an associated item, returns any region\n+    /// Given the `DefId` of an associated item, returns any region\n     /// bounds attached to that associated item from the trait definition.\n     ///\n     /// For example:\n@@ -262,7 +262,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// If we were given the `DefId` of `Foo::Bar`, we would return\n     /// `'a`. You could then apply the substitutions from the\n     /// projection to convert this into your namespace. This also\n     /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on"}, {"sha": "65d25333c7179050b14bba2a3adc357c4d06fb34", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-//! See README.md\n+//! See `README.md`.\n \n use self::CombineMapType::*;\n use self::UndoLog::*;\n@@ -9,10 +9,10 @@ use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::unify as ut;\n-use ty::ReStatic;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{BrFresh, ReLateBound, ReVar};\n-use ty::{Region, RegionVid};\n+use crate::ty::ReStatic;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{BrFresh, ReLateBound, ReVar};\n+use crate::ty::{Region, RegionVid};\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n@@ -108,16 +108,16 @@ pub struct RegionConstraintData<'tcx> {\n     pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n-/// A constraint that influences the inference process.\n+/// Represents a constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n-    /// One region variable is subregion of another\n+    /// A region variable is a subregion of another.\n     VarSubVar(RegionVid, RegionVid),\n \n-    /// Concrete region is subregion of region variable\n+    /// A concrete region is a subregion of region variable.\n     RegSubVar(Region<'tcx>, RegionVid),\n \n-    /// Region variable is subregion of concrete region. This does not\n+    /// A region variable is a subregion of a concrete region. This does not\n     /// directly affect inference, but instead is checked after\n     /// inference is complete.\n     VarSubReg(RegionVid, Region<'tcx>),\n@@ -138,9 +138,9 @@ impl Constraint<'_> {\n     }\n }\n \n-/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n-/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n /// `i`. Inference variables may be involved (but this verification\n /// step doesn't influence inference).\n #[derive(Debug, Clone)]\n@@ -164,7 +164,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-/// Describes the things that some `GenericKind` value G is known to\n+/// Describes the things that some `GenericKind` value `G` is known to\n /// outlive. Each variant of `VerifyBound` can be thought of as a\n /// function:\n ///\n@@ -187,13 +187,15 @@ pub enum VerifyBound<'tcx> {\n     /// following, where `G` is the generic for which this verify\n     /// bound was created:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       if G == K {\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     if G == K {\n     ///         B(min)\n-    ///       } else {\n+    ///     } else {\n     ///         false\n-    ///       }\n     ///     }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if the generic `G` that we are checking is\n     /// equal to `K`, then check the associated verify bound\n@@ -202,45 +204,52 @@ pub enum VerifyBound<'tcx> {\n     /// This is used when we have something in the environment that\n     /// may or may not be relevant, depending on the region inference\n     /// results. For example, we may have `where <T as\n-    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n     /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n     /// this where-clause is only relevant if `'0` winds up inferred\n     /// to `'a`.\n     ///\n     /// So we would compile to a verify-bound like\n     ///\n-    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n+    /// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n     ///\n     /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n     /// (after inference), and `'a: min`, then `G: min`.\n     IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n     /// Given a region `R`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       R: min\n-    ///     }\n+    /// ```\n+    /// fn(min) -> bool {\n+    ///     R: min\n+    /// }\n+    /// ```\n     ///\n     /// This is used when we can establish that `G: R` -- therefore,\n     /// if `R: min`, then by transitivity `G: min`.\n     OutlivedBy(Region<'tcx>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       exists (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     exists (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet some bound in `B`, that suffices.\n-    /// This is used when all the bounds in `B` are known to apply to\n-    /// G.\n+    /// This is used when all the bounds in `B` are known to apply to `G`.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       forall (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     forall (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet *all* bounds in `B`, that suffices.\n     /// This is used when *some* bound in `B` is known to suffice, but\n@@ -256,19 +265,19 @@ struct TwoRegions<'tcx> {\n \n #[derive(Copy, Clone, PartialEq)]\n enum UndoLog<'tcx> {\n-    /// We added `RegionVid`\n+    /// We added `RegionVid`.\n     AddVar(RegionVid),\n \n-    /// We added the given `constraint`\n+    /// We added the given `constraint`.\n     AddConstraint(Constraint<'tcx>),\n \n-    /// We added the given `verify`\n+    /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`\n+    /// We added the given `given`.\n     AddGiven(Region<'tcx>, ty::RegionVid),\n \n-    /// We added a GLB/LUB \"combination variable\"\n+    /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo\n@@ -303,7 +312,7 @@ pub struct RegionSnapshot {\n /// When working with placeholder regions, we often wish to find all of\n /// the regions that are either reachable from a placeholder region, or\n /// which can reach a placeholder region, or both. We call such regions\n-/// *tainted* regions.  This struct allows you to decide what set of\n+/// *tainted* regions. This struct allows you to decide what set of\n /// tainted regions you want.\n #[derive(Debug)]\n pub struct TaintDirections {\n@@ -359,7 +368,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     /// Takes (and clears) the current set of constraints. Note that\n     /// the set of variables remains intact, but all relationships\n-    /// between them are reset.  This is used during NLL checking to\n+    /// between them are reset. This is used during NLL checking to\n     /// grab the set of constraints that arose from a particular\n     /// operation.\n     ///\n@@ -707,7 +716,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    /// See `Verify::VerifyGenericBound`\n+    /// See [`Verify::VerifyGenericBound`].\n     pub fn verify_generic_bound(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -837,7 +846,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             }).collect()\n     }\n \n-    /// See [`RegionInference::region_constraints_added_in_snapshot`]\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n     pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n         self.undo_log[mark.length..]\n             .iter()\n@@ -925,7 +934,8 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {\n-    /// True if this region constraint data contains no constraints.\n+    /// Returns `true` if this region constraint data contains no constraints, and `false`\n+    /// otherwise.\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,"}, {"sha": "4a8f0c34ead111381181dc6d756d89bc62c7c713", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n use super::{InferCtxt, FixupError, FixupResult};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER"}, {"sha": "0cff42742c30a813e74f74abab7da0209306e7c3", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,11 +1,11 @@\n use super::SubregionOrigin;\n use super::combine::{CombineFields, RelationDir};\n \n-use traits::Obligation;\n-use ty::{self, Ty, TyCtxt};\n-use ty::TyVar;\n-use ty::fold::TypeFoldable;\n-use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use crate::traits::Obligation;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::TyVar;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success."}, {"sha": "09a0a6ce9c97c56709b6af6b935b67fc4d518120", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n-use ty::{self, Ty};\n+use crate::ty::{self, Ty};\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -218,7 +218,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.find(vid)\n     }\n \n-    /// True if `a` and `b` have same \"sub-root\" (i.e., exists some\n+    /// Returns `true` if `a` and `b` have same \"sub-root\" (i.e., exists some\n     /// type X such that `forall i in {a, b}. (i <: X || X <: i)`.\n     pub fn sub_unified(&mut self, a: ty::TyVid, b: ty::TyVid) -> bool {\n         self.sub_root_var(a) == self.sub_root_var(b)\n@@ -245,9 +245,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// Creates a snapshot of the type variable state. This snapshot\n     /// must later be committed (`commit()`) or rolled back\n-    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// (`rollback_to()`). Nested snapshots are permitted, but must\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n@@ -306,7 +306,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n \n-    /// Find the set of type variables that existed *before* `s`\n+    /// Finds the set of type variables that existed *before* `s`\n     /// but which have only been unified since `s` started, and\n     /// return the types with which they were unified. So if we had\n     /// a type variable `V0`, then we started the snapshot, then we"}, {"sha": "09f800d9f9bfc97d8fce3c80dfacc95279a77928", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n+use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n \n pub trait ToType {"}, {"sha": "be1475564778af30338d40e13e6b00ef7a6a5815", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -26,9 +26,10 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+#![deny(rust_2018_idioms)]\n+#![allow(explicit_outlives_requirements)]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -64,41 +65,24 @@\n \n #![warn(elided_lifetimes_in_paths)]\n \n-extern crate arena;\n #[macro_use] extern crate bitflags;\n-extern crate core;\n-extern crate fmt_macros;\n extern crate getopts;\n-extern crate graphviz;\n-extern crate num_cpus;\n #[macro_use] extern crate lazy_static;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n-extern crate polonius_engine;\n-extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n-extern crate serialize;\n-extern crate parking_lot;\n-extern crate rustc_errors as errors;\n-extern crate rustc_rayon as rayon;\n-extern crate rustc_rayon_core as rayon_core;\n+\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-extern crate syntax_pos;\n-extern crate jobserver;\n-extern crate proc_macro;\n-extern crate chalk_engine;\n-extern crate rustc_fs_util;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n+// FIXME: This import is used by deriving `RustcDecodable` and `RustcEncodable`. Removing this\n+// results in a bunch of \"failed to resolve\" errors. Hopefully, the compiler moves to serde or\n+// something, and we can get rid of this.\n+#[allow(rust_2018_idioms)]\n+extern crate serialize as rustc_serialize;\n \n-extern crate rustc_apfloat;\n-extern crate byteorder;\n-extern crate backtrace;\n-\n-#[macro_use]\n-extern crate smallvec;\n+#[macro_use] extern crate smallvec;\n \n // Note that librustc doesn't actually depend on these crates, see the note in\n // `Cargo.toml` for this crate about why these are here.\n@@ -166,9 +150,11 @@ pub mod util {\n // `libstd` uses the same trick.\n #[doc(hidden)]\n mod rustc {\n-    pub use lint;\n+    pub use crate::lint;\n }\n \n+use rustc_errors as errors;\n+\n // FIXME(#27438): right now the unit tests of librustc don't refer to any actual\n //                functions generated in librustc_data_structures (all\n //                references are through generic functions), but statics are"}, {"sha": "cb31441ca47e1e23a97d4c7b93ad19e86c987314", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,9 +4,9 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use errors::{Applicability, DiagnosticBuilder};\n-use lint::{LintPass, LateLintPass, LintArray};\n-use session::Session;\n+use crate::errors::{Applicability, DiagnosticBuilder};\n+use crate::lint::{LintPass, LateLintPass, LintArray};\n+use crate::session::Session;\n use syntax::ast;\n use syntax::source_map::Span;\n \n@@ -352,6 +352,12 @@ declare_lint! {\n     \"outlives requirements can be inferred\"\n }\n \n+declare_lint! {\n+    pub DUPLICATE_MATCHER_BINDING_NAME,\n+    Warn,\n+    \"duplicate macro matcher binding name\"\n+}\n+\n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {\n@@ -467,6 +473,7 @@ pub enum BuiltinLintDiagnostics {\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n     UnknownCrateTypes(Span, String, String),\n+    UnusedImports(String, Vec<(Span, String)>),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -548,6 +555,15 @@ impl BuiltinLintDiagnostics {\n             BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n                 db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n             }\n+            BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                if !replaces.is_empty() {\n+                    db.multipart_suggestion(\n+                        &message,\n+                        replaces,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "b90ef4ea2213a905e93c25b244d99424432918a8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,41 +3,41 @@\n //! The lint checking is mostly consolidated into one pass which runs\n //! after all other analyses. Throughout compilation, lint warnings\n //! can be added via the `add_lint` method on the Session structure. This\n-//! requires a span and an id of the node that the lint is being added to. The\n+//! requires a span and an ID of the node that the lint is being added to. The\n //! lint isn't actually emitted at that time because it is unknown what the\n //! actual lint level at that location is.\n //!\n //! To actually emit lint warnings/errors, a separate pass is used.\n //! A context keeps track of the current state of all lint levels.\n //! Upon entering a node of the ast which can modify the lint settings, the\n //! previous lint state is pushed onto a stack and the ast is then recursed\n-//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n use self::TargetLint::*;\n \n use std::slice;\n use rustc_data_structures::sync::ReadGuard;\n-use lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n-use lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n-use lint::builtin::BuiltinLintDiagnostics;\n-use lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use middle::privacy::AccessLevels;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n-use session::{config, early_error, Session};\n-use ty::{self, TyCtxt, Ty};\n-use ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use util::nodemap::FxHashMap;\n-use util::common::time;\n+use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n+use crate::lint::builtin::BuiltinLintDiagnostics;\n+use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n+use crate::middle::privacy::AccessLevels;\n+use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n+use crate::session::{config, early_error, Session};\n+use crate::ty::{self, TyCtxt, Ty};\n+use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use std::default::Default as StdDefault;\n use syntax::ast;\n use syntax::edition;\n use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n-use errors::DiagnosticBuilder;\n-use hir;\n-use hir::def_id::LOCAL_CRATE;\n-use hir::intravisit as hir_visit;\n+use crate::errors::DiagnosticBuilder;\n+use crate::hir;\n+use crate::hir::def_id::LOCAL_CRATE;\n+use crate::hir::intravisit as hir_visit;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n \n@@ -703,7 +703,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     type PassObject = LateLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n impl<'a> LintContext<'a> for EarlyContext<'a> {\n     type PassObject = EarlyLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n     }\n@@ -1200,7 +1200,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n }\n \n \n-/// Perform lint checking on a crate.\n+/// Performs lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "62bd54de7c92934d7d52623ec09fb0a284e4c601", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,20 +1,20 @@\n use std::cmp;\n \n-use errors::{Applicability, DiagnosticBuilder};\n-use hir::HirId;\n-use ich::StableHashingContext;\n-use lint::builtin;\n-use lint::context::CheckLintNameResult;\n-use lint::{self, Lint, LintId, Level, LintSource};\n+use crate::errors::{Applicability, DiagnosticBuilder};\n+use crate::hir::HirId;\n+use crate::ich::StableHashingContext;\n+use crate::lint::builtin;\n+use crate::lint::context::CheckLintNameResult;\n+use crate::lint::{self, Lint, LintId, Level, LintSource};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n-use session::Session;\n+use crate::session::Session;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::Symbol;\n-use util::nodemap::FxHashMap;\n+use crate::util::nodemap::FxHashMap;\n \n pub struct LintLevelSets {\n     list: Vec<LintSet>,"}, {"sha": "9fcc3be66aa2530133caf27b536fd67142daa2ef", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -23,25 +23,25 @@ pub use self::LintSource::*;\n \n use rustc_data_structures::sync::{self, Lrc};\n \n-use errors::{DiagnosticBuilder, DiagnosticId};\n-use hir::def_id::{CrateNum, LOCAL_CRATE};\n-use hir::intravisit;\n-use hir;\n-use lint::builtin::BuiltinLintDiagnostics;\n-use lint::builtin::parser::{QUESTION_MARK_MACRO_SEP, ILL_FORMED_ATTRIBUTE_INPUT};\n-use session::{Session, DiagnosticMessageId};\n+use crate::errors::{DiagnosticBuilder, DiagnosticId};\n+use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use crate::hir::intravisit;\n+use crate::hir;\n+use crate::lint::builtin::{BuiltinLintDiagnostics, DUPLICATE_MATCHER_BINDING_NAME};\n+use crate::lint::builtin::parser::{QUESTION_MARK_MACRO_SEP, ILL_FORMED_ATTRIBUTE_INPUT};\n+use crate::session::{Session, DiagnosticMessageId};\n use std::{hash, ptr};\n use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use ty::TyCtxt;\n-use ty::query::Providers;\n-use util::nodemap::NodeMap;\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::NodeMap;\n \n-pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n+pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         check_crate, check_ast_crate, CheckLintNameResult,\n                         FutureIncompatibleInfo, BufferedEarlyLint};\n \n@@ -72,7 +72,7 @@ pub struct Lint {\n     /// `default_level`.\n     pub edition_lint_opts: Option<(Edition, Level)>,\n \n-    /// Whether this lint is reported even inside expansions of external macros\n+    /// `true` if this lint is reported even inside expansions of external macros.\n     pub report_in_external_macro: bool,\n }\n \n@@ -82,10 +82,11 @@ impl Lint {\n         match lint_id {\n             BufferedEarlyLintId::QuestionMarkMacroSep => QUESTION_MARK_MACRO_SEP,\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n+            BufferedEarlyLintId::DuplicateMacroMatcherBindingName => DUPLICATE_MATCHER_BINDING_NAME,\n         }\n     }\n \n-    /// Get the lint's name, with ASCII letters converted to lowercase.\n+    /// Gets the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n     }\n@@ -98,7 +99,7 @@ impl Lint {\n     }\n }\n \n-/// Declare a static item of type `&'static Lint`.\n+/// Declares a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n@@ -149,7 +150,7 @@ macro_rules! declare_tool_lint {\n     );\n }\n \n-/// Declare a static `LintArray` and return it as an expression.\n+/// Declares a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {\n     ($( $lint:expr ),* ,) => { lint_array!( $($lint),* ) };\n@@ -163,7 +164,7 @@ pub type LintArray = Vec<&'static Lint>;\n pub trait LintPass {\n     fn name(&self) -> &'static str;\n \n-    /// Get descriptions of the lints this `LintPass` object can emit.\n+    /// Gets descriptions of the lints this `LintPass` object can emit.\n     ///\n     /// N.B., there is no enforcement that the object only emits lints it registered.\n     /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n@@ -486,7 +487,7 @@ impl hash::Hash for LintId {\n }\n \n impl LintId {\n-    /// Get the `LintId` for a `Lint`.\n+    /// Gets the `LintId` for a `Lint`.\n     pub fn of(lint: &'static Lint) -> LintId {\n         LintId {\n             lint,\n@@ -497,7 +498,7 @@ impl LintId {\n         self.lint.name\n     }\n \n-    /// Get the name of the lint.\n+    /// Gets the name of the lint.\n     pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n     }\n@@ -517,7 +518,7 @@ impl_stable_hash_for!(enum self::Level {\n });\n \n impl Level {\n-    /// Convert a level to a lower-case string.\n+    /// Converts a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n         match self {\n             Allow => \"allow\",\n@@ -527,7 +528,7 @@ impl Level {\n         }\n     }\n \n-    /// Convert a lower-case string to a level.\n+    /// Converts a lower-case string to a level.\n     pub fn from_str(x: &str) -> Option<Level> {\n         match x {\n             \"allow\" => Some(Allow),\n@@ -678,7 +679,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n             \"this was previously accepted by the compiler but is being phased out; \\\n              it will become a hard error\";\n \n-        let explanation = if lint_id == LintId::of(::lint::builtin::UNSTABLE_NAME_COLLISIONS) {\n+        let explanation = if lint_id == LintId::of(crate::lint::builtin::UNSTABLE_NAME_COLLISIONS) {\n             \"once this method is added to the standard library, \\\n              the ambiguity may cause an error or change in behavior!\"\n                 .to_owned()"}, {"sha": "ccae9d3ad5a82792a3d9e4a9e8de75014d6bfa1e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -62,38 +62,36 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     // Enums\n-    // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n-    // them back when `?` is supported again.\n     (enum $enum_name:path {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n         impl_stable_hash_for!(\n             impl<> for enum $enum_name [ $enum_name ] { $( $variant\n-                $( ( $($field $(-> $delegate)*),* ) )*\n-                $( { $($named_field $(-> $named_delegate)*),* } )*\n+                $( ( $($field $(-> $delegate)?),* ) )?\n+                $( { $($named_field $(-> $named_delegate)?),* } )?\n             ),* }\n         );\n     };\n     // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n     // importing all the variants. Unfortunately it seems we have to take the name\n     // twice for this purpose\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n         for enum $enum_name:path\n         [ $enum_path:path ]\n     {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n             for $enum_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n@@ -107,26 +105,25 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n-                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n+                        $variant $( ( $(ref $field),* ) )? $( { $(ref $named_field),* } )? => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)?\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)?) );*)?\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n     // Structs\n-    // FIXME(mark-i-m): same here.\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),* $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)?),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -138,21 +135,20 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n     // Tuple structs\n-    // We cannot use normale parentheses here, the parser won't allow it\n-    // FIXME(mark-i-m): same here.\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    // We cannot use normal parentheses here, the parser won't allow it\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n-     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -164,7 +160,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "2799f9424d9190e6d11ba028bdd96070ae786b1e", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use ich::StableHashingContext;\n-use hir::HirId;\n-use util::nodemap::FxHashSet;\n+use crate::ich::StableHashingContext;\n+use crate::hir::HirId;\n+use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};"}, {"sha": "6e9552a1e920916038a4c0f652eae7a70887f746", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,13 +2,13 @@\n //! are *mostly* used as a part of that interface, but these should\n //! probably get a better home if someone can find one.\n \n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use hir::map as hir_map;\n-use hir::map::definitions::{DefKey, DefPathTable};\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use crate::hir::map as hir_map;\n+use crate::hir::map::definitions::{DefKey, DefPathTable};\n use rustc_data_structures::svh::Svh;\n-use ty::{self, TyCtxt};\n-use session::{Session, CrateDisambiguator};\n-use session::search_paths::PathKind;\n+use crate::ty::{self, TyCtxt};\n+use crate::session::{Session, CrateDisambiguator};\n+use crate::session::search_paths::PathKind;\n \n use std::any::Any;\n use std::path::{Path, PathBuf};"}, {"sha": "6dffe8efba612a0d14cc3355eda403f50d64abd0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,18 +2,18 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use hir::Node;\n-use hir::{self, PatKind};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-\n-use hir::def::Def;\n-use hir::CodegenFnAttrFlags;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use lint;\n-use middle::privacy;\n-use ty::{self, TyCtxt};\n-use util::nodemap::FxHashSet;\n+use crate::hir::Node;\n+use crate::hir::{self, PatKind};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+\n+use crate::hir::def::Def;\n+use crate::hir::CodegenFnAttrFlags;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::lint;\n+use crate::middle::privacy;\n+use crate::ty::{self, TyCtxt};\n+use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n "}, {"sha": "a24d25cba118453d49758cd0376e26d1f59841c0", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -51,13 +51,13 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use hir::def_id::CrateNum;\n+use crate::hir::def_id::CrateNum;\n \n-use session::config;\n-use ty::TyCtxt;\n-use middle::cstore::{self, DepKind};\n-use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use util::nodemap::FxHashMap;\n+use crate::session::config;\n+use crate::ty::TyCtxt;\n+use crate::middle::cstore::{self, DepKind};\n+use crate::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n+use crate::util::nodemap::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n /// A list of dependencies for a certain crate type."}, {"sha": "2d0e6c3917bb84822fa6c060941dd968dfd85c31", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,15 +1,15 @@\n-use hir::map as hir_map;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use session::{config, Session};\n-use session::config::EntryFnType;\n+use crate::hir::map as hir_map;\n+use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use crate::session::{config, Session};\n+use crate::session::config::EntryFnType;\n use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemKind, ImplItem, TraitItem};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use ty::TyCtxt;\n-use ty::query::Providers;\n+use crate::hir::{Item, ItemKind, ImplItem, TraitItem};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,"}, {"sha": "6c43068a227728428957817b188e2900b9c6f02c", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,11 +1,11 @@\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use ich::StableHashingContext;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n use std::cmp;\n use std::mem;\n-use ty;\n-use ty::subst::Substs;\n+use crate::ty;\n+use crate::ty::subst::Substs;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any"}, {"sha": "8da20ba426663f926d49610bd4d28ef29f4ba216", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-//! A different sort of visitor for walking fn bodies.  Unlike the\n+//! A different sort of visitor for walking fn bodies. Unlike the\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n@@ -9,20 +9,20 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use infer::InferCtxt;\n-use middle::mem_categorization as mc;\n-use middle::region;\n-use ty::{self, TyCtxt, adjustment};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::infer::InferCtxt;\n+use crate::middle::mem_categorization as mc;\n+use crate::middle::region;\n+use crate::ty::{self, TyCtxt, adjustment};\n \n-use hir::{self, PatKind};\n+use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use util::nodemap::ItemLocalSet;\n+use crate::util::nodemap::ItemLocalSet;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -800,8 +800,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&arm.body);\n     }\n \n-    /// Walks a pat that occurs in isolation (i.e., top-level of fn\n-    /// arg or let binding.  *Not* a match arm or nested pat.)\n+    /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n+    /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n         self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);"}, {"sha": "fc345df6551507bcea35dcd2c42e15529b8c8bdd", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,32 +1,30 @@\n-//! This file handles the relationships between free regions --\n-//! meaning lifetime parameters. Ordinarily, free regions are\n-//! unrelated to one another, but they can be related via implied or\n-//! explicit bounds.  In that case, we track the bounds using the\n-//! `TransitiveRelation` type and use that to decide when one free\n-//! region outlives another and so forth.\n+//! This module handles the relationships between \"free regions\", i.e., lifetime parameters.\n+//! Ordinarily, free regions are unrelated to one another, but they can be related via implied\n+//! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n+//! and use that to decide when one free region outlives another, and so forth.\n \n-use infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n-use hir::def_id::DefId;\n-use middle::region;\n-use ty::{self, TyCtxt, Region};\n+use crate::infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n+use crate::hir::def_id::DefId;\n+use crate::middle::region;\n+use crate::ty::{self, TyCtxt, Region};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n /// scopes) and a `FreeRegionMap` (which governs relationships between\n /// free regions) to yield a complete relation between concrete\n /// regions.\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n-/// move to NLL it'll all go away anyhow.\n+/// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    /// context used to fetch the region maps\n+    /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// region maps for the given context\n+    /// The region maps for the given context.\n     pub region_scope_tree: &'a region::ScopeTree,\n \n-    /// free-region relationships\n+    /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n@@ -45,7 +43,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// Determines whether one region is a subregion of another. This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n                            sub_region: ty::Region<'tcx>,\n@@ -86,7 +84,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Determines whether this free-region is required to be 'static\n+    /// Determines whether this free region is required to be `'static`.\n     fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n         match *super_region {"}, {"sha": "ee361e9776313048cc2295a387020035514b8fc6", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,14 +1,14 @@\n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n-use ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n-use ty::query::Providers;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n+use crate::ty::query::Providers;\n \n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &module in tcx.hir().krate().modules.keys() {"}, {"sha": "3f9230ab551d55b82ae9a5002cd6cc1bd8ae117a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -11,17 +11,17 @@\n \n pub use self::LangItem::*;\n \n-use hir::def_id::DefId;\n-use hir::check_attr::Target;\n-use ty::{self, TyCtxt};\n-use middle::weak_lang_items;\n-use util::nodemap::FxHashMap;\n+use crate::hir::def_id::DefId;\n+use crate::hir::check_attr::Target;\n+use crate::ty::{self, TyCtxt};\n+use crate::middle::weak_lang_items;\n+use crate::util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir;\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end."}, {"sha": "45095d9bc986b392df5cee9c11213b7cc99fccaf", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,13 +4,13 @@\n // and `#[unstable (..)]`), but are not declared in one single location\n // (unlike lang features), which means we need to collect them instead.\n \n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n use syntax_pos::Span;\n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use errors::DiagnosticId;\n+use crate::errors::DiagnosticId;\n \n pub struct LibFeatures {\n     // A map from feature to stabilisation version."}, {"sha": "a18574f030ced82c67e07d19861a1963e8034868", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,27 +1,27 @@\n-//! A classic liveness analysis based on dataflow over the AST.  Computes,\n+//! A classic liveness analysis based on dataflow over the AST. Computes,\n //! for each local variable in a function, whether that variable is live\n-//! at a given point.  Program execution points are identified by their\n-//! id.\n+//! at a given point. Program execution points are identified by their\n+//! IDs.\n //!\n //! # Basic idea\n //!\n-//! The basic model is that each local variable is assigned an index.  We\n+//! The basic model is that each local variable is assigned an index. We\n //! represent sets of local variables using a vector indexed by this\n-//! index.  The value in the vector is either 0, indicating the variable\n-//! is dead, or the id of an expression that uses the variable.\n+//! index. The value in the vector is either 0, indicating the variable\n+//! is dead, or the ID of an expression that uses the variable.\n //!\n-//! We conceptually walk over the AST in reverse execution order.  If we\n-//! find a use of a variable, we add it to the set of live variables.  If\n+//! We conceptually walk over the AST in reverse execution order. If we\n+//! find a use of a variable, we add it to the set of live variables. If\n //! we find an assignment to a variable, we remove it from the set of live\n-//! variables.  When we have to merge two flows, we take the union of\n-//! those two flows---if the variable is live on both paths, we simply\n-//! pick one id.  In the event of loops, we continue doing this until a\n+//! variables. When we have to merge two flows, we take the union of\n+//! those two flows -- if the variable is live on both paths, we simply\n+//! pick one ID. In the event of loops, we continue doing this until a\n //! fixed point is reached.\n //!\n //! ## Checking initialization\n //!\n-//! At the function entry point, all variables must be dead.  If this is\n-//! not the case, we can report an error using the id found in the set of\n+//! At the function entry point, all variables must be dead. If this is\n+//! not the case, we can report an error using the ID found in the set of\n //! live variables, which identifies a use of the variable which is not\n //! dominated by an assignment.\n //!\n@@ -38,20 +38,20 @@\n //!\n //! The actual implementation contains two (nested) walks over the AST.\n //! The outer walk has the job of building up the ir_maps instance for the\n-//! enclosing function.  On the way down the tree, it identifies those AST\n+//! enclosing function. On the way down the tree, it identifies those AST\n //! nodes and variable IDs that will be needed for the liveness analysis\n-//! and assigns them contiguous IDs.  The liveness id for an AST node is\n-//! called a `live_node` (it's a newtype'd u32) and the id for a variable\n-//! is called a `variable` (another newtype'd u32).\n+//! and assigns them contiguous IDs. The liveness ID for an AST node is\n+//! called a `live_node` (it's a newtype'd `u32`) and the ID for a variable\n+//! is called a `variable` (another newtype'd `u32`).\n //!\n //! On the way back up the tree, as we are about to exit from a function\n-//! declaration we allocate a `liveness` instance.  Now that we know\n+//! declaration we allocate a `liveness` instance. Now that we know\n //! precisely how many nodes and variables we need, we can allocate all\n-//! the various arrays that we will need to precisely the right size.  We then\n+//! the various arrays that we will need to precisely the right size. We then\n //! perform the actual propagation on the `liveness` instance.\n //!\n //! This propagation is encoded in the various `propagate_through_*()`\n-//! methods.  It effectively does a reverse walk of the AST; whenever we\n+//! methods. It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n //! ## The `RWU` struct\n@@ -60,21 +60,21 @@\n //! variable `V` (these are encapsulated in the `RWU` struct):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n-//!    that `V` holds on entry to `N`.  Formally: a node `M` such\n+//!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`.  If the `reader` is `invalid_node()`, then the current\n+//!    write `V`. If the `reader` is `invalid_node()`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n-//!    variable `V` and which is reachable from `N`.  Formally: a node `M`\n+//!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`.  If the `writer` is `invalid_node()`, then there is no writer\n+//!    `V`. If the `writer` is `invalid_node()`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n-//! - `used`: a boolean value indicating whether `V` is *used*.  We\n+//! - `used`: a boolean value indicating whether `V` is *used*. We\n //!   distinguish a *read* from a *use* in that a *use* is some read that\n-//!   is not just used to generate a new value.  For example, `x += 1` is\n-//!   a read but not a use.  This is used to generate better warnings.\n+//!   is not just used to generate a new value. For example, `x += 1` is\n+//!   a read but not a use. This is used to generate better warnings.\n //!\n //! ## Special Variables\n //!\n@@ -87,7 +87,7 @@\n //! - `fallthrough_ln`: a live node that represents a fallthrough\n //!\n //! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n-//!   fallthrough node.  It is only live if the function could converge\n+//!   fallthrough node. It is only live if the function could converge\n //!   via means other than an explicit `return` expression. That is, it is\n //!   only dead if the end of the function's block can never be reached.\n //!   It is the responsibility of typeck to ensure that there are no\n@@ -97,13 +97,13 @@ use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n-use hir::def::*;\n-use hir::Node;\n-use ty::{self, TyCtxt};\n-use ty::query::Providers;\n-use lint;\n-use errors::Applicability;\n-use util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n+use crate::hir::def::*;\n+use crate::hir::Node;\n+use crate::ty::{self, TyCtxt};\n+use crate::ty::query::Providers;\n+use crate::lint;\n+use crate::errors::Applicability;\n+use crate::util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n \n use std::collections::{BTreeMap, VecDeque};\n use std::{fmt, u32};\n@@ -115,10 +115,10 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use hir;\n-use hir::{Expr, HirId};\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use crate::hir;\n+use crate::hir::{Expr, HirId};\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -189,7 +189,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &module in tcx.hir().krate().modules.keys() {\n         tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n     }\n-    tcx.sess.abort_if_errors();\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -406,7 +405,7 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n-        use hir::PatKind::*;\n+        use crate::hir::PatKind::*;\n         match pat.node {\n             Binding(_, _, _, _, ref inner_pat) => {\n                 pats.extend(inner_pat.iter());"}, {"sha": "b98f094aef9214c5353d439c0b72d17f90adb877", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,7 +3,7 @@\n //! The job of the categorization module is to analyze an expression to\n //! determine what kind of memory is used in evaluating it (for example,\n //! where dereferences occur and what kind of pointer is dereferenced;\n-//! whether the memory is mutable; etc)\n+//! whether the memory is mutable, etc.).\n //!\n //! Categorization effectively transforms all of our expressions into\n //! expressions of the following forms (the actual enum has many more\n@@ -16,21 +16,21 @@\n //!       | E.comp    // access to an interior component\n //!\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found.  If Expr is a place, then this\n-//! is the address of the place.  If Expr is an rvalue, this is the address of\n+//! address where the result is to be found. If Expr is a place, then this\n+//! is the address of the place. If `Expr` is an rvalue, this is the address of\n //! some temporary spot in memory where the result is stored.\n //!\n-//! Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n+//! Now, `cat_expr()` classifies the expression `Expr` and the address `A = ToAddr(Expr)`\n //! as follows:\n //!\n-//! - cat: what kind of expression was this?  This is a subset of the\n+//! - `cat`: what kind of expression was this? This is a subset of the\n //!   full expression forms which only includes those that we care about\n //!   for the purpose of the analysis.\n-//! - mutbl: mutability of the address A\n-//! - ty: the type of data found at the address A\n+//! - `mutbl`: mutability of the address `A`.\n+//! - `ty`: the type of data found at the address `A`.\n //!\n //! The resulting categorization tree differs somewhat from the expressions\n-//! themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+//! themselves. For example, auto-derefs are explicit. Also, an index a[b] is\n //! decomposed into two operations: a dereference to reach the array data and\n //! then an index to jump forward to the relevant item.\n //!\n@@ -58,19 +58,19 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n-use middle::region;\n-use hir::def_id::{DefId, LocalDefId};\n-use hir::Node;\n-use infer::InferCtxt;\n-use hir::def::{Def, CtorKind};\n-use ty::adjustment;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::TypeFoldable;\n-use ty::layout::VariantIdx;\n-\n-use hir::{MutImmutable, MutMutable, PatKind};\n-use hir::pat_util::EnumerateAndAdjustIterator;\n-use hir;\n+use crate::middle::region;\n+use crate::hir::def_id::{DefId, LocalDefId};\n+use crate::hir::Node;\n+use crate::infer::InferCtxt;\n+use crate::hir::def::{Def, CtorKind};\n+use crate::ty::adjustment;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::layout::VariantIdx;\n+\n+use crate::hir::{MutImmutable, MutMutable, PatKind};\n+use crate::hir::pat_util::EnumerateAndAdjustIterator;\n+use crate::hir;\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n@@ -80,7 +80,7 @@ use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n-use util::nodemap::ItemLocalSet;\n+use crate::util::nodemap::ItemLocalSet;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {"}, {"sha": "1655d8356a5a7804755f3e4ea8181de00dbf5edd", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,7 +2,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use util::nodemap::{DefIdSet, FxHashMap};\n+use crate::util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;"}, {"sha": "99d0c5e88d6385aeecc58226ad4e99d0ee0de229", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,24 +5,24 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n-use hir::Node;\n-use hir::def::Def;\n-use hir::def_id::{DefId, CrateNum};\n+use crate::hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n+use crate::hir::Node;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n-use ty::{self, TyCtxt};\n-use ty::query::Providers;\n-use middle::privacy;\n-use session::config;\n-use util::nodemap::{NodeSet, FxHashSet};\n+use crate::ty::{self, TyCtxt};\n+use crate::ty::query::Providers;\n+use crate::middle::privacy;\n+use crate::session::config;\n+use crate::util::nodemap::{NodeSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use hir;\n-use hir::def_id::LOCAL_CRATE;\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir::intravisit;\n+use crate::hir;\n+use crate::hir::def_id::LOCAL_CRATE;\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::intravisit;\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n@@ -177,8 +177,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_node_id = self.tcx.hir().as_local_node_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item(impl_node_id).node {\n+                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n+                            match self.tcx.hir().expect_item_by_hir_id(impl_hir_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)"}, {"sha": "ea077220e0be37680a22a8957b0951a733ef94d7", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,7 +5,7 @@\n // this via an attribute on the crate like `#![recursion_limit=\"22\"]`. This pass\n // just peeks and looks for that attribute.\n \n-use session::Session;\n+use crate::session::Session;\n use syntax::ast;\n \n use rustc_data_structures::sync::Once;"}, {"sha": "fd188b33d7e1fd253fb8785b6dddccf88e11212f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,24 +6,24 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n-use ich::{StableHashingContext, NodeIdHashingMode};\n-use util::nodemap::{FxHashMap, FxHashSet};\n-use ty;\n+use crate::ich::{StableHashingContext, NodeIdHashingMode};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::ty;\n \n use std::mem;\n use std::fmt;\n use rustc_data_structures::sync::Lrc;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::TyCtxt;\n-use ty::query::Providers;\n-\n-use hir;\n-use hir::Node;\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+\n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -85,11 +85,11 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// values live long enough; phrased another way, the starting point\n /// of each range is not really the important thing in the above\n /// picture, but rather the ending point.\n-///\n-/// FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to\n-/// placate the same deriving in `ty::FreeRegion`, but we may want to\n-/// actually attach a more meaningful ordering to scopes than the one\n-/// generated via deriving here.\n+//\n+// FIXME(pnkfelix): this currently derives `PartialOrd` and `Ord` to\n+// placate the same deriving in `ty::FreeRegion`, but we may want to\n+// actually attach a more meaningful ordering to scopes than the one\n+// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n@@ -140,27 +140,27 @@ pub enum ScopeData {\n ///\n /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n ///\n-/// * the subscope with `first_statement_index == 0` is scope of both\n+/// * The subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n ///   but instead another `Scope` that encompasses the whole block,\n ///   e.g., `Scope::Node`.\n ///\n-/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+/// * The subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n \n newtype_index! {\n     pub struct FirstStatementIndex { .. }\n }\n \n-impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { private });\n+impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { private });\n \n // compilation error if size of `ScopeData` is not the same as a `u32`\n static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n \n impl Scope {\n-    /// Returns a item-local id associated with this scope.\n+    /// Returns a item-local ID associated with this scope.\n     ///\n     /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n@@ -180,8 +180,8 @@ impl Scope {\n         }\n     }\n \n-    /// Returns the span of this Scope.  Note that in general the\n-    /// returned span may not correspond to the span of any node id in\n+    /// Returns the span of this `Scope`. Note that in general the\n+    /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> Span {\n         let node_id = self.node_id(tcx, scope_tree);\n@@ -225,19 +225,19 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<ast::NodeId>,\n \n-    /// `parent_map` maps from a scope id to the enclosing scope id;\n+    /// `parent_map` maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n-    /// enclosing scope id for the block associated with a closure is\n+    /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding id to the block in\n+    /// `var_map` maps from a variable or binding ID to the block in\n     /// which that variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a node-id to the associated destruction scope (if any)\n+    /// maps from a `NodeId` to the associated destruction scope (if any)\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n@@ -252,8 +252,8 @@ pub struct ScopeTree {\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n-    /// the block that is the fn body. This map points from the id of\n-    /// that root block to the id of the root block for the enclosing\n+    /// the block that is the fn body. This map points from the ID of\n+    /// that root block to the ID of the root block for the enclosing\n     /// fn, if any. Thus the map structures the fn bodies into a\n     /// hierarchy based on their lexical mapping. This is used to\n     /// handle the relationships between regions in a fn and in a\n@@ -382,7 +382,7 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// upon exiting the parent scope, we cannot statically know how\n     /// many times the expression executed, and thus if the expression\n     /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// temporaries we would have to cleanup. Therefore, we ensure that\n     /// the temporaries never outlast the conditional/repeating\n     /// expression, preventing the need for dynamic checks and/or\n     /// arbitrary amounts of stack space. Terminating scopes end\n@@ -465,7 +465,7 @@ impl<'tcx> ScopeTree {\n     }\n \n     /// Records that `sub_closure` is defined within `sup_closure`. These ids\n-    /// should be the id of the block that is the fn body, which is\n+    /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n                              sub_closure: hir::ItemLocalId,\n@@ -551,8 +551,8 @@ impl<'tcx> ScopeTree {\n         self.is_subscope_of(scope2, scope1)\n     }\n \n-    /// Returns true if `subscope` is equal to or is lexically nested inside `superscope` and false\n-    /// otherwise.\n+    /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n+    /// `false` otherwise.\n     pub fn is_subscope_of(&self,\n                           subscope: Scope,\n                           superscope: Scope)\n@@ -575,7 +575,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the id of the innermost containing body\n+    /// Returns the ID of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -586,7 +586,7 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    /// Finds the nearest common ancestor of two scopes.  That is, finds the\n+    /// Finds the nearest common ancestor of two scopes. That is, finds the\n     /// smallest scope which is greater than or equal to both `scope_a` and\n     /// `scope_b`.\n     pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n@@ -840,7 +840,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.id).local_id;\n+    let stmt_id = stmt.hir_id.local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -1051,7 +1051,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         visitor.visit_pat(pat);\n     }\n \n-    /// True if `pat` match the `P&` nonterminal:\n+    /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n     ///     P& = ref X\n     ///        | StructName { ..., P&, ... }"}, {"sha": "4e42816b3c610f1c801aa57c65f98afe9dc8dcf5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,18 +3,18 @@\n //! Name resolution for lifetimes follows MUCH simpler rules than the\n //! full resolve. For example, lifetime names are never exported or\n //! used between functions, and they operate in a purely top-down\n-//! way. Therefore we break lifetime name resolution into a separate pass.\n+//! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use hir::map::Map;\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n-use ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use crate::hir::map::Map;\n+use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n+use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n-use errors::{Applicability, DiagnosticBuilder};\n-use rustc::lint;\n+use crate::errors::{Applicability, DiagnosticBuilder};\n+use crate::rustc::lint;\n use rustc_data_structures::sync::Lrc;\n-use session::Session;\n+use crate::session::Session;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::mem::replace;\n@@ -23,10 +23,10 @@ use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n+use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n \n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use hir::{self, GenericParamKind, LifetimeParamKind};\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use crate::hir::{self, GenericParamKind, LifetimeParamKind};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -207,7 +207,7 @@ struct NamedRegionMap {\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n-/// See `NamedRegionMap`.\n+/// See [`NamedRegionMap`].\n #[derive(Default)]\n pub struct ResolveLifetimes {\n     defs: FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Region>>>,\n@@ -216,7 +216,7 @@ pub struct ResolveLifetimes {\n         FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n }\n \n-impl_stable_hash_for!(struct ::middle::resolve_lifetime::ResolveLifetimes {\n+impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n     defs,\n     late_bound,\n     object_lifetime_defaults\n@@ -227,21 +227,19 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// Deep breath. Our representation for poly trait refs contains a single\n+    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n     /// binder and thus we only allow a single level of quantification. However,\n     /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the de Bruijn indices\n+    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n     /// correct when representing these constraints, we should only introduce one\n     /// scope. However, we want to support both locations for the quantifier and\n     /// during lifetime resolution we want precise information (so we can't\n     /// desugar in an earlier phase).\n     ///\n-    /// SO, if we encounter a quantifier at the outer scope, we set\n-    /// trait_ref_hack to true (and introduce a scope), and then if we encounter\n-    /// a quantifier at the inner scope, we error. If trait_ref_hack is false,\n+    /// So, if we encounter a quantifier at the outer scope, we set\n+    /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n+    /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n     /// then we introduce the scope at the inner quantifier.\n-    ///\n-    /// I'm sorry.\n     trait_ref_hack: bool,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n@@ -1248,12 +1246,12 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n-                        let node_id = tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span(node_id)),\n+                            original_lifetime(tcx.hir().span_by_hir_id(hir_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1676,7 +1674,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// If early bound lifetimes are present, we separate them into their own list (and likewise\n     /// for late bound). They will be numbered sequentially, starting from the lowest index that is\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n-    /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n+    /// bound lifetimes are resolved by name and associated with a binder ID (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n@@ -2593,12 +2591,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes, s, ..\n                 } => {\n                     if let Some(&def) = lifetimes.get(&param.name.modern()) {\n-                        let node_id = self.tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span(node_id)),\n+                            original_lifetime(self.tcx.hir().span_by_hir_id(hir_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2610,7 +2608,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns true if, in the current scope, replacing `'_` would be\n+    /// Returns `true` if, in the current scope, replacing `'_` would be\n     /// equivalent to a single-use lifetime.\n     fn track_lifetime_uses(&self) -> bool {\n         let mut scope = self.scope;\n@@ -2714,7 +2712,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// - it does not appear in a where-clause.\n ///\n /// \"Constrained\" basically means that it appears in any type but\n-/// not amongst the inputs to a projection.  In other words, `<&'a\n+/// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,"}, {"sha": "68ce4024ae4e6f7ad51dfd01db97b209dd2f318a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,23 +3,23 @@\n \n pub use self::StabilityLevel::*;\n \n-use lint::{self, Lint};\n-use hir::{self, Item, Generics, StructField, Variant, HirId};\n-use hir::def::Def;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use ty::query::Providers;\n-use middle::privacy::AccessLevels;\n-use session::{DiagnosticMessageId, Session};\n+use crate::lint::{self, Lint};\n+use crate::hir::{self, Item, Generics, StructField, Variant, HirId};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::query::Providers;\n+use crate::middle::privacy::AccessLevels;\n+use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n-use ty::{self, TyCtxt};\n-use util::nodemap::{FxHashSet, FxHashMap};\n+use crate::ty::{self, TyCtxt};\n+use crate::util::nodemap::{FxHashSet, FxHashMap};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -51,7 +51,7 @@ enum AnnotationKind {\n pub struct DeprecationEntry {\n     /// The metadata of the attribute associated with this entry.\n     pub attr: Deprecation,\n-    /// The def id where the attr was originally attached. `None` for non-local\n+    /// The `DefId` where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n     origin: Option<HirId>,\n }\n@@ -475,7 +475,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-/// Check whether an item marked with `deprecated(since=\"X\")` is currently\n+/// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(since: &str) -> bool {\n     fn parse_version(ver: &str) -> Vec<u32> {\n@@ -561,11 +561,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n     pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n-        if span.allows_unstable() {\n-            debug!(\"stability: skipping span={:?} since it is internal\", span);\n-            return EvalResult::Allow;\n-        }\n-\n         let lint_deprecated = |def_id: DefId,\n                                id: NodeId,\n                                note: Option<Symbol>,\n@@ -694,6 +689,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+                if span.allows_unstable(&feature.as_str()) {\n+                    debug!(\"stability: skipping span={:?} since it is internal\", span);\n+                    return EvalResult::Allow;\n+                }\n                 if self.stability().active_features.contains(&feature) {\n                     return EvalResult::Allow;\n                 }\n@@ -765,7 +764,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             EvalResult::Unmarked => {\n-                span_bug!(span, \"encountered unmarked API: {:?}\", def_id);\n+                // The API could be uncallable for other reasons, for example when a private module\n+                // was referenced.\n+                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n             }\n         }\n     }"}, {"sha": "312924e5e90f549418a5bc7565f383f0912a8fc4", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,18 +1,18 @@\n //! Validity checking for weak lang items\n \n-use session::config;\n-use middle::lang_items;\n+use crate::session::config;\n+use crate::middle::lang_items;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::PanicStrategy;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::def_id::DefId;\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::intravisit;\n-use hir;\n-use ty::TyCtxt;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::hir::intravisit;\n+use crate::hir;\n+use crate::ty::TyCtxt;\n \n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n@@ -54,7 +54,7 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     })\n }\n \n-/// Returns whether the specified `lang_item` doesn't actually need to be\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n /// present for this compilation.\n ///\n /// Not all lang items are always required for each compilation, particularly in"}, {"sha": "1cc927b1f720f3a549493b8d7b906f55fb97c349", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,10 +2,10 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n-use ich::StableHashingContext;\n-use mir::{Mir, BasicBlock};\n+use crate::ich::StableHashingContext;\n+use crate::mir::{Mir, BasicBlock};\n \n-use rustc_serialize as serialize;\n+use crate::rustc_serialize as serialize;\n \n #[derive(Clone, Debug)]\n pub struct Cache {"}, {"sha": "e96392edd64bfbb87b047a6d5f9578ea254d597f", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,14 +1,14 @@\n-//! The virtual memory representation of the MIR interpreter\n+//! The virtual memory representation of the MIR interpreter.\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n     truncate,\n };\n \n-use ty::layout::{Size, Align};\n+use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n-use mir;\n+use crate::mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::HasDataLayout;\n@@ -54,7 +54,7 @@ pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n     /// Hook for performing extra checks on a memory read access.\n     ///\n     /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n     /// need to mutate.\n     #[inline(always)]\n     fn memory_read(\n@@ -133,7 +133,7 @@ impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Alignment and bounds checks\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n-    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n     /// in-bounds!  This follows C's/LLVM's rules.\n     /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n@@ -145,7 +145,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         ptr.check_in_alloc(Size::from_bytes(allocation_size), InboundsCheck::Live)\n     }\n \n-    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n     #[inline(always)]\n     pub fn check_bounds(\n         &self,\n@@ -161,7 +161,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n /// Byte accessors\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n@@ -462,7 +462,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Return all relocations overlapping with the given ptr-offset pair.\n+    /// Returns all relocations overlapping with the given ptr-offset pair.\n     pub fn relocations(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -476,7 +476,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n-    /// Check that there are no relocations overlapping with the given range.\n+    /// Checks that there are no relocations overlapping with the given range.\n     #[inline(always)]\n     fn check_relocations(\n         &self,\n@@ -491,10 +491,10 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n     }\n \n-    /// Remove all relocations inside the given range.\n+    /// Removes all relocations inside the given range.\n     /// If there are relocations overlapping with the edges, they\n     /// are removed as well *and* the bytes they cover are marked as\n-    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n     fn clear_relocations(\n@@ -633,7 +633,7 @@ impl UndefMask {\n         m\n     }\n \n-    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    /// Checks whether the range `start..end` (end-exclusive) is entirely defined.\n     ///\n     /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n     /// at which the first undefined access begins."}, {"sha": "d456f29439d2c3972ed5bb3f30a582cb5dfe38d7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,25 +1,25 @@\n use std::{fmt, env};\n \n-use hir::map::definitions::DefPathData;\n-use mir;\n-use ty::{self, Ty, layout};\n-use ty::layout::{Size, Align, LayoutError};\n+use crate::hir::map::definitions::DefPathData;\n+use crate::mir;\n+use crate::ty::{self, Ty, layout};\n+use crate::ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n-use ty::query::TyCtxtAt;\n-use errors::DiagnosticBuilder;\n+use crate::ty::query::TyCtxtAt;\n+use crate::errors::DiagnosticBuilder;\n \n use syntax_pos::{Pos, Span};\n use syntax::ast;\n use syntax::symbol::Symbol;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum ErrorHandled {\n-    /// Already reported a lint or an error for this evaluation\n+    /// Already reported a lint or an error for this evaluation.\n     Reported,\n     /// Don't emit an error, the evaluation failed because the MIR was generic\n     /// and the substs didn't fully monomorphize it.\n@@ -42,7 +42,7 @@ pub type ConstEvalResult<'tcx> = Result<ty::Const<'tcx>, ErrorHandled>;\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub error: ::mir::interpret::EvalErrorKind<'tcx, u64>,\n+    pub error: crate::mir::interpret::EvalErrorKind<'tcx, u64>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n                 .next()\n                 .unwrap_or(lint_root);\n             tcx.struct_span_lint_node(\n-                ::rustc::lint::builtin::CONST_ERR,\n+                crate::rustc::lint::builtin::CONST_ERR,\n                 node_id,\n                 tcx.span,\n                 message,\n@@ -212,7 +212,7 @@ pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n-    /// match an existing variant\n+    /// match an existing variant.\n     MachineError(String),\n \n     FunctionAbiMismatch(Abi, Abi),"}, {"sha": "0c43fe4a79faa7115ab343335dd080f6a9f1517f", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -25,17 +25,17 @@ pub use self::allocation::{\n pub use self::pointer::{Pointer, PointerArithmetic};\n \n use std::fmt;\n-use mir;\n-use hir::def_id::DefId;\n-use ty::{self, TyCtxt, Instance};\n-use ty::layout::{self, Size};\n+use crate::mir;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::layout::{self, Size};\n use std::io;\n-use rustc_serialize::{Encoder, Decodable, Encodable};\n+use crate::rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n-use ty::codec::TyDecoder;\n+use crate::ty::codec::TyDecoder;\n use std::sync::atomic::{AtomicU32, Ordering};\n use std::num::NonZeroU32;\n \n@@ -53,8 +53,8 @@ pub struct GlobalId<'tcx> {\n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n-impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n-impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n+impl crate::rustc_serialize::UseSpecializedEncodable for AllocId {}\n+impl crate::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n #[derive(RustcDecodable, RustcEncodable)]\n enum AllocDiscriminant {\n@@ -260,23 +260,23 @@ impl fmt::Display for AllocId {\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n pub enum AllocKind<'tcx> {\n-    /// The alloc id is used as a function pointer\n+    /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),\n-    /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n+    /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n-    /// The alloc id points to memory\n+    /// The alloc ID points to memory.\n     Memory(&'tcx Allocation),\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an AllocId refers to\n+    /// Lets you know what an `AllocId` refers to.\n     id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n-    /// Used to ensure that statics only get one associated AllocId\n+    /// Used to ensure that statics only get one associated `AllocId`.\n     type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n-    /// The AllocId to assign to the next requested id.\n+    /// The `AllocId` to assign to the next requested ID.\n     /// Always incremented, never gets smaller.\n     next_id: AllocId,\n }\n@@ -318,14 +318,29 @@ impl<'tcx> AllocMap<'tcx> {\n         id\n     }\n \n-    /// Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n-    /// by the linker and functions can be duplicated across crates.\n-    /// We thus generate a new `AllocId` for every mention of a function. This means that\n-    /// `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n-        let id = self.reserve();\n-        self.id_to_kind.insert(id, AllocKind::Function(instance));\n-        id\n+        // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n+        // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n+        // duplicated across crates.\n+        // We thus generate a new `AllocId` for every mention of a function. This means that\n+        // `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n+        // However, formatting code relies on function identity (see #58320), so we only do\n+        // this for generic functions.  Lifetime parameters are ignored.\n+        let is_generic = instance.substs.into_iter().any(|kind| {\n+            match kind.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+        if is_generic {\n+            // Get a fresh ID\n+            let id = self.reserve();\n+            self.id_to_kind.insert(id, AllocKind::Function(instance));\n+            id\n+        } else {\n+            // Deduplicate\n+            self.intern(AllocKind::Function(instance))\n+        }\n     }\n \n     /// Returns `None` in case the `AllocId` is dangling. An `EvalContext` can still have a\n@@ -345,7 +360,7 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n-    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n         self.intern(AllocKind::Static(static_id))"}, {"sha": "551e7b2fd41ecd61053779c4eb12478a2f07b915", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,5 +1,5 @@\n-use mir;\n-use ty::layout::{self, HasDataLayout, Size};\n+use crate::mir;\n+use crate::ty::layout::{self, HasDataLayout, Size};\n \n use super::{\n     AllocId, EvalResult, InboundsCheck,"}, {"sha": "5ec7de4308a13da5c888fc802d2981c327ff5a1e", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -13,25 +13,26 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches the LocalState optimizations for easy conversions between Value and ConstValue.\n+/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n+/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs\n+    /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n-    /// Not using the enum `Value` to encode that this must not be `Undef`\n+    /// Not using the enum `Value` to encode that this must not be `Undef`.\n     Scalar(Scalar),\n \n-    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`, ...)\n+    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`,\n+    /// etc.).\n     ///\n     /// Empty slices don't necessarily have an address backed by an `AllocId`, thus we also need to\n     /// enable integer pointers. The `Scalar` type covers exactly those two cases. While we could\n     /// create dummy-`AllocId`s, the additional code effort for the conversions doesn't seem worth\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation + offset into the allocation.\n-    /// Invariant: The AllocId matches the allocation.\n+    /// An allocation together with an offset into the allocation.\n+    /// Invariant: the `AllocId` matches the allocation.\n     ByRef(AllocId, &'tcx Allocation, Size),\n }\n \n@@ -515,7 +516,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n }\n \n-impl_stable_hash_for!(enum ::mir::interpret::ScalarMaybeUndef {\n+impl_stable_hash_for!(enum crate::mir::interpret::ScalarMaybeUndef {\n     Scalar(v),\n     Undef\n });"}, {"sha": "3513d652b534672fb31fed9cf33dff7e251e9e6f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,11 +2,11 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use hir::def::CtorKind;\n-use hir::def_id::DefId;\n-use hir::{self, HirId, InlineAsm};\n-use mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n-use mir::visit::MirVisitable;\n+use crate::hir::def::CtorKind;\n+use crate::hir::def_id::DefId;\n+use crate::hir::{self, HirId, InlineAsm};\n+use crate::mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n+use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_data_structures::fx::FxHashSet;\n@@ -15,7 +15,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n-use rustc_serialize::{self as serialize};\n+use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -26,16 +26,16 @@ use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{Subst, Substs};\n-use ty::layout::VariantIdx;\n-use ty::{\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::layout::VariantIdx;\n+use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n-use util::ppaux;\n+use crate::util::ppaux;\n \n-pub use mir::interpret::AssertMessage;\n+pub use crate::mir::interpret::AssertMessage;\n \n mod cache;\n pub mod interpret;\n@@ -108,7 +108,7 @@ pub struct Mir<'tcx> {\n     /// in scope, but a separate set of locals.\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n-    /// Yield type of the function, if it is a generator.\n+    /// Yields type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue\n@@ -380,7 +380,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    /// Check if `sub` is a sub scope of `sup`\n+    /// Checks if `sub` is a sub scope of `sup`\n     pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n         while sub != sup {\n             match self.source_scopes[sub].parent_scope {\n@@ -391,12 +391,12 @@ impl<'tcx> Mir<'tcx> {\n         true\n     }\n \n-    /// Return the return type, it always return first element from `local_decls` array\n+    /// Returns the return type, it always return first element from `local_decls` array\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Get the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location {\n             block: bb,\n@@ -526,7 +526,7 @@ pub enum BorrowKind {\n     /// We can also report errors with this kind of borrow differently.\n     Shallow,\n \n-    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// Data must be immutable but not aliasable. This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure is\n     /// borrowing or mutating a mutable referent, e.g.:\n@@ -565,8 +565,8 @@ pub enum BorrowKind {\n \n     /// Data is mutable and not aliasable.\n     Mut {\n-        /// True if this borrow arose from method-call auto-ref\n-        /// (i.e., `adjustment::Adjust::Borrow`)\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n         allow_two_phase_borrow: bool,\n     },\n }\n@@ -610,7 +610,7 @@ pub struct VarBindingForm<'tcx> {\n     /// If an explicit type was provided for this variable binding,\n     /// this holds the source Span of that type.\n     ///\n-    /// NOTE: If you want to change this to a `HirId`, be wary that\n+    /// NOTE: if you want to change this to a `HirId`, be wary that\n     /// doing so breaks incremental compilation (as of this writing),\n     /// while a `Span` does not cause our tests to fail.\n     pub opt_ty_info: Option<Span>,\n@@ -676,7 +676,7 @@ impl_stable_hash_for!(enum self::MirPhase {\n });\n \n mod binding_form_impl {\n-    use ich::StableHashingContext;\n+    use crate::ich::StableHashingContext;\n     use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n@@ -737,7 +737,7 @@ pub struct LocalDecl<'tcx> {\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n     pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n \n-    /// True if this is an internal local\n+    /// `true` if this is an internal local.\n     ///\n     /// These locals are not based on types in the source code and are only used\n     /// for a few desugarings at the moment.\n@@ -864,7 +864,7 @@ pub struct LocalDecl<'tcx> {\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n-    /// Returns true only if local is a binding that can itself be\n+    /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n     /// something like the occurrences of `x` in:\n     /// - `fn foo(x: Type) { ... }`,\n@@ -886,7 +886,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Returns true if local is definitely not a `ref ident` or\n+    /// Returns `true` if local is definitely not a `ref ident` or\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n@@ -904,7 +904,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Create a new `LocalDecl` for a temporary.\n+    /// Creates a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, false, span)\n@@ -925,7 +925,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         self\n     }\n \n-    /// Create a new `LocalDecl` for a internal temporary.\n+    /// Creates a new `LocalDecl` for a internal temporary.\n     #[inline]\n     pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, true, span)\n@@ -1019,7 +1019,7 @@ pub struct BasicBlockData<'tcx> {\n \n     /// Terminator for this block.\n     ///\n-    /// NB. This should generally ONLY be `None` during construction.\n+    /// N.B., this should generally ONLY be `None` during construction.\n     /// Therefore, you should generally access it via the\n     /// `terminator()` or `terminator_mut()` methods. The only\n     /// exception is that certain passes, such as `simplify_cfg`, swap\n@@ -1637,7 +1637,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    /// Return the list of labels for the edges to the successor basic blocks.\n+    /// Returns the list of labels for the edges to the successor basic blocks.\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n@@ -1760,7 +1760,7 @@ pub enum StatementKind<'tcx> {\n     /// error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n-    /// never accessed still get some sanity checks for e.g. `let x: ! = ..;`\n+    /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1775,14 +1775,14 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Local),\n \n-    /// Execute a piece of inline Assembly.\n+    /// Executes a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Box<[Place<'tcx>]>,\n         inputs: Box<[(Span, Operand<'tcx>)]>,\n     },\n \n-    /// Retag references in the given place, ensuring they got fresh tags.  This is\n+    /// Retag references in the given place, ensuring they got fresh tags. This is\n     /// part of the Stacked Borrows model. These statements are currently only interpreted\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n@@ -1904,7 +1904,7 @@ pub enum Place<'tcx> {\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n \n-/// The def-id of a static, along with its normalized type (which is\n+/// The `DefId` of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n@@ -2009,10 +2009,10 @@ impl<'tcx> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n \n-    /// Find the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n-    ///\n-    /// FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    //\n+    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) |\n@@ -2024,7 +2024,7 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n-    /// Find the innermost `Local` from this `Place`.\n+    /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) => Some(*local),\n@@ -2141,7 +2141,7 @@ impl<'tcx> Debug for Operand<'tcx> {\n \n impl<'tcx> Operand<'tcx> {\n     /// Convenience helper to make a constant that refers to the fn\n-    /// with given def-id and substs. Since this is used to synthesize\n+    /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n     pub fn function_handle<'a>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -2154,7 +2154,7 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: tcx.intern_lazy_const(\n+            literal: tcx.mk_lazy_const(\n                 ty::LazyConst::Evaluated(ty::Const::zero_sized(ty)),\n             ),\n         })\n@@ -2199,7 +2199,7 @@ pub enum Rvalue<'tcx> {\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Place<'tcx>),\n \n-    /// Create an aggregate value, like a tuple or struct.  This is\n+    /// Creates an aggregate value, like a tuple or struct. This is\n     /// only needed because we want to distinguish `dest = Foo { x:\n     /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n     /// that `Foo` has a destructor. These rvalues can be optimized\n@@ -2211,13 +2211,13 @@ pub enum Rvalue<'tcx> {\n pub enum CastKind {\n     Misc,\n \n-    /// Convert unique, zero-sized type for a fn to fn()\n+    /// Converts unique, zero-sized type for a fn to fn()\n     ReifyFnPointer,\n \n-    /// Convert non capturing closure to fn()\n+    /// Converts non capturing closure to fn()\n     ClosureFnPointer,\n \n-    /// Convert safe fn() to unsafe fn()\n+    /// Converts safe fn() to unsafe fn()\n     UnsafeFnPointer,\n \n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n@@ -2301,9 +2301,9 @@ impl BinOp {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum NullOp {\n-    /// Return the size of a value of that type\n+    /// Returns the size of a value of that type\n     SizeOf,\n-    /// Create a new uninitialized box for a value of that type\n+    /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n@@ -2625,7 +2625,7 @@ CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n         let projs: Vec<_> = self.projs\n@@ -2671,7 +2671,7 @@ pub fn fmt_lazy_const_val(f: &mut impl Write, const_val: &ty::LazyConst<'_>) ->\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Result {\n-    use ty::TyKind::*;\n+    use crate::ty::TyKind::*;\n     let value = const_val.val;\n     let ty = const_val.ty;\n     // print some primitives\n@@ -2847,7 +2847,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns\n+    /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n@@ -2884,7 +2884,7 @@ pub struct BorrowCheckResult<'gcx> {\n \n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n-/// appear in the closure's signature or on its field types.  These\n+/// appear in the closure's signature or on its field types. These\n /// requirements are then verified and proved by the closure's\n /// creating function. This struct encodes those requirements.\n ///\n@@ -2934,7 +2934,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureRegionRequirements<'gcx> {\n-    /// The number of external regions defined on the closure.  In our\n+    /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n     /// make sure that the number of regions we see at the callsite\n@@ -3116,7 +3116,7 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::TerminatorKind::*;\n+        use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n@@ -3229,7 +3229,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::TerminatorKind::*;\n+        use crate::mir::TerminatorKind::*;\n \n         match self.kind {\n             SwitchInt {\n@@ -3301,7 +3301,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::Rvalue::*;\n+        use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n             Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n@@ -3343,7 +3343,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::Rvalue::*;\n+        use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n@@ -3395,7 +3395,7 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n         let elem = match self.elem {\n@@ -3409,7 +3409,7 @@ where\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         self.base.visit_with(visitor) || match self.elem {\n             Field(_, ref ty) => ty.visit_with(visitor),"}, {"sha": "2296fe5763c94740f291d7c7149254475dfae726", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,12 +1,12 @@\n-use hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use ty::{Instance, TyCtxt};\n-use util::nodemap::FxHashMap;\n+use crate::ty::{Instance, TyCtxt};\n+use crate::util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n                                            StableHasher};\n-use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use std::fmt;\n use std::hash::Hash;\n \n@@ -57,7 +57,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n \n pub struct CodegenUnit<'tcx> {\n     /// A name for this CGU. Incremental compilation requires that\n-    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// name be unique amongst **all** crates. Therefore, it should\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n     name: InternedString,"}, {"sha": "bf4ac7496d2e76e25c929afcb45d9a857a8d646e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,12 +3,12 @@\n  * building is complete.\n  */\n \n-use mir::*;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, Ty, TyCtxt};\n-use ty::layout::VariantIdx;\n-use hir;\n-use ty::util::IntTypeExt;\n+use crate::mir::*;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::layout::VariantIdx;\n+use crate::hir;\n+use crate::ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum PlaceTy<'tcx> {\n@@ -278,7 +278,7 @@ impl<'tcx> Rvalue<'tcx> {\n     }\n \n     #[inline]\n-    /// Returns whether this rvalue is deeply initialized (most rvalues) or\n+    /// Returns `true` if this rvalue is deeply initialized (most rvalues) or\n     /// whether its only shallowly initialized (`Rvalue::Box`).\n     pub fn initialization_state(&self) -> RvalueInitializationState {\n         match *self {"}, {"sha": "e5828039ac29cb33fb1510aa05359a75a9a7a7d4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 225, "deletions": 235, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use hir::def_id::DefId;\n-use ty::subst::Substs;\n-use ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n-use mir::*;\n+use crate::hir::def_id::DefId;\n+use crate::ty::subst::Substs;\n+use crate::ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n+use crate::mir::*;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -38,10 +38,10 @@ use syntax_pos::Span;\n // ```rust\n // fn super_basic_block_data(&mut self,\n //                           block: BasicBlock,\n-//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n //     let BasicBlockData {\n-//         ref $($mutability)* statements,\n-//         ref $($mutability)* terminator,\n+//         statements,\n+//         terminator,\n //         is_cleanup: _\n //     } = *data;\n //\n@@ -67,111 +67,111 @@ use syntax_pos::Span;\n // `is_cleanup` above.\n \n macro_rules! make_mir_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_mir(&mut self, mir: & $($mutability)* Mir<'tcx>) {\n+            fn visit_mir(&mut self, mir: & $($mutability)? Mir<'tcx>) {\n                 self.super_mir(mir);\n             }\n \n             fn visit_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 self.super_basic_block_data(block, data);\n             }\n \n             fn visit_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+                                           scope_data: & $($mutability)? SourceScopeData) {\n                 self.super_source_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 self.super_statement(block, statement, location);\n             }\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            place: & $($mutability)* Place<'tcx>,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_assign(block, place, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: & $($mutability)* Terminator<'tcx>,\n+                                terminator: & $($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n                 self.super_terminator(block, terminator, location);\n             }\n \n             fn visit_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      location: Location) {\n                 self.super_terminator_kind(block, kind, location);\n             }\n \n             fn visit_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 self.super_assert_message(msg, location);\n             }\n \n             fn visit_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n                 self.super_operand(operand, location);\n             }\n \n             fn visit_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n             fn visit_retag(&mut self,\n-                           kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.super_retag(kind, place, location);\n             }\n \n             fn visit_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_place(place, context, location);\n             }\n \n             fn visit_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_static(static_, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place: & $($mutability)* PlaceProjection<'tcx>,\n+                                place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(place, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     place: & $($mutability)* PlaceElem<'tcx>,\n+                                     place: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(place, location);\n             }\n@@ -183,101 +183,101 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 self.super_constant(constant, location);\n             }\n \n             fn visit_def_id(&mut self,\n-                            def_id: & $($mutability)* DefId,\n+                            def_id: & $($mutability)? DefId,\n                             _: Location) {\n                 self.super_def_id(def_id);\n             }\n \n             fn visit_span(&mut self,\n-                          span: & $($mutability)* Span) {\n+                          span: & $($mutability)? Span) {\n                 self.super_span(span);\n             }\n \n             fn visit_source_info(&mut self,\n-                                 source_info: & $($mutability)* SourceInfo) {\n+                                 source_info: & $($mutability)? SourceInfo) {\n                 self.super_source_info(source_info);\n             }\n \n             fn visit_ty(&mut self,\n-                        ty: & $($mutability)* Ty<'tcx>,\n+                        ty: & $($mutability)? Ty<'tcx>,\n                         _: TyContext) {\n                 self.super_ty(ty);\n             }\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n \n             fn visit_user_type_annotation(\n                 &mut self,\n                 index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n-                            region: & $($mutability)* ty::Region<'tcx>,\n+                            region: & $($mutability)? ty::Region<'tcx>,\n                             _: Location) {\n                 self.super_region(region);\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)* &'tcx ty::LazyConst<'tcx>,\n+                           constant: & $($mutability)? &'tcx ty::LazyConst<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n \n             fn visit_substs(&mut self,\n-                            substs: & $($mutability)* &'tcx Substs<'tcx>,\n+                            substs: & $($mutability)? &'tcx Substs<'tcx>,\n                             _: Location) {\n                 self.super_substs(substs);\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* ClosureSubsts<'tcx>,\n+                                    substs: & $($mutability)? ClosureSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_closure_substs(substs);\n             }\n \n             fn visit_generator_substs(&mut self,\n-                                      substs: & $($mutability)* GeneratorSubsts<'tcx>,\n+                                      substs: & $($mutability)? GeneratorSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_generator_substs(substs);\n             }\n \n             fn visit_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 self.super_local_decl(local, local_decl);\n             }\n \n             fn visit_local(&mut self,\n-                            _local: & $($mutability)* Local,\n+                            _local: & $($mutability)? Local,\n                             _context: PlaceContext<'tcx>,\n                             _location: Location) {\n             }\n \n             fn visit_source_scope(&mut self,\n-                                      scope: & $($mutability)* SourceScope) {\n+                                      scope: & $($mutability)? SourceScope) {\n                 self.super_source_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n-                         mir: & $($mutability)* Mir<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n+                         mir: & $($mutability)? Mir<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n@@ -291,45 +291,45 @@ macro_rules! make_mir_visitor {\n                     (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n                     () => (mir.basic_blocks().iter_enumerated());\n                 };\n-                for (bb, data) in basic_blocks!($($mutability)*) {\n+                for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)* mir.source_scopes {\n+                for scope in &$($mutability)? mir.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n+                self.visit_ty(&$($mutability)? mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n                 for local in mir.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n+                    self.visit_local_decl(local, & $($mutability)? mir.local_decls[local]);\n                 }\n \n                 macro_rules! type_annotations {\n                     (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n                     () => (mir.user_type_annotations.iter_enumerated());\n                 };\n \n-                for (index, annotation) in type_annotations!($($mutability)*) {\n+                for (index, annotation) in type_annotations!($($mutability)?) {\n                     self.visit_user_type_annotation(\n                         index, annotation\n                     );\n                 }\n \n-                self.visit_span(&$($mutability)* mir.span);\n+                self.visit_span(&$($mutability)? mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 let BasicBlockData {\n-                    ref $($mutability)* statements,\n-                    ref $($mutability)* terminator,\n+                    statements,\n+                    terminator,\n                     is_cleanup: _\n-                } = *data;\n+                } = data;\n \n                 let mut index = 0;\n                 for statement in statements {\n@@ -338,92 +338,83 @@ macro_rules! make_mir_visitor {\n                     index += 1;\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = *terminator {\n+                if let Some(terminator) = terminator {\n                     let location = Location { block: block, statement_index: index };\n                     self.visit_terminator(block, terminator, location);\n                 }\n             }\n \n-            fn super_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+            fn super_source_scope_data(&mut self, scope_data: & $($mutability)? SourceScopeData) {\n                 let SourceScopeData {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* parent_scope,\n-                } = *scope_data;\n+                    span,\n+                    parent_scope,\n+                } = scope_data;\n \n                 self.visit_span(span);\n-                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                if let Some(parent_scope) = parent_scope {\n                     self.visit_source_scope(parent_scope);\n                 }\n             }\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 let Statement {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *statement;\n+                    source_info,\n+                    kind,\n+                } = statement;\n \n                 self.visit_source_info(source_info);\n-                match *kind {\n-                    StatementKind::Assign(ref $($mutability)* place,\n-                                          ref $($mutability)* rvalue) => {\n+                match kind {\n+                    StatementKind::Assign(place, rvalue) => {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n-                    StatementKind::FakeRead(_, ref $($mutability)* place) => {\n+                    StatementKind::FakeRead(_, place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n-                    StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n+                    StatementKind::SetDiscriminant { place, .. } => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageLive(ref $($mutability)* local) => {\n+                    StatementKind::StorageLive(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageLive),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageDead(ref $($mutability)* local) => {\n+                    StatementKind::StorageDead(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageDead),\n                             location\n                         );\n                     }\n-                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n-                                               ref $($mutability)* inputs,\n-                                               asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n+                    StatementKind::InlineAsm { outputs, inputs, asm: _ } => {\n+                        for output in & $($mutability)? outputs[..] {\n                             self.visit_place(\n                                 output,\n                                 PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n                                 location\n                             );\n                         }\n-                        for (span, input) in & $($mutability)* inputs[..] {\n+                        for (span, input) in & $($mutability)? inputs[..] {\n                             self.visit_span(span);\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::Retag ( ref $($mutability)* kind,\n-                                           ref $($mutability)* place ) => {\n+                    StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(\n-                        ref $($mutability)* place,\n-                        ref $($mutability)* variance,\n-                        ref $($mutability)* user_ty,\n-                    ) => {\n+                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -432,8 +423,8 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            place: &$($mutability)* Place<'tcx>,\n-                            rvalue: &$($mutability)* Rvalue<'tcx>,\n+                            place: &$($mutability)? Place<'tcx>,\n+                            rvalue: &$($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.visit_place(\n                     place,\n@@ -445,34 +436,33 @@ macro_rules! make_mir_visitor {\n \n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: &$($mutability)* Terminator<'tcx>,\n+                                terminator: &$($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n-                let Terminator {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *terminator;\n+                let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind, location);\n             }\n \n             fn super_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      source_location: Location) {\n-                match *kind {\n+                match kind {\n                     TerminatorKind::Goto { target } => {\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                     }\n \n-                    TerminatorKind::SwitchInt { ref $($mutability)* discr,\n-                                                ref $($mutability)* switch_ty,\n-                                                values: _,\n-                                                ref targets } => {\n+                    TerminatorKind::SwitchInt {\n+                        discr,\n+                        switch_ty,\n+                        values: _,\n+                        targets\n+                    } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for &target in targets {\n-                            self.visit_branch(block, target);\n+                        for target in targets {\n+                            self.visit_branch(block, *target);\n                         }\n                     }\n \n@@ -483,113 +473,120 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Unreachable => {\n                     }\n \n-                    TerminatorKind::Drop { ref $($mutability)* location,\n-                                           target,\n-                                           unwind } => {\n+                    TerminatorKind::Drop {\n+                        location,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::DropAndReplace { ref $($mutability)* location,\n-                                                     ref $($mutability)* value,\n-                                                     target,\n-                                                     unwind } => {\n+                    TerminatorKind::DropAndReplace {\n+                        location,\n+                        value,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Call { ref $($mutability)* func,\n-                                           ref $($mutability)* args,\n-                                           ref $($mutability)* destination,\n-                                           cleanup,\n-                                           from_hir_call: _, } => {\n+                    TerminatorKind::Call {\n+                        func,\n+                        args,\n+                        destination,\n+                        cleanup,\n+                        from_hir_call: _,\n+                    } => {\n                         self.visit_operand(func, source_location);\n                         for arg in args {\n                             self.visit_operand(arg, source_location);\n                         }\n-                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                        if let Some((destination, target)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n                                 source_location\n                             );\n-                            self.visit_branch(block, target);\n+                            self.visit_branch(block, *target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Assert { ref $($mutability)* cond,\n-                                             expected: _,\n-                                             ref $($mutability)* msg,\n-                                             target,\n-                                             cleanup } => {\n+                    TerminatorKind::Assert {\n+                        cond,\n+                        expected: _,\n+                        msg,\n+                        target,\n+                        cleanup,\n+                    } => {\n                         self.visit_operand(cond, source_location);\n                         self.visit_assert_message(msg, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Yield { ref $($mutability)* value,\n-                                              resume,\n-                                              drop } => {\n+                    TerminatorKind::Yield {\n+                        value,\n+                        resume,\n+                        drop,\n+                    } => {\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, resume);\n+                        self.visit_branch(block, *resume);\n                         drop.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets} => {\n-                        self.visit_branch(block, real_target);\n+                    TerminatorKind::FalseEdges { real_target, imaginary_targets } => {\n+                        self.visit_branch(block, *real_target);\n                         for target in imaginary_targets {\n                             self.visit_branch(block, *target);\n                         }\n                     }\n \n                     TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                        self.visit_branch(block, real_target);\n+                        self.visit_branch(block, *real_target);\n                         if let Some(unwind) = unwind {\n-                            self.visit_branch(block, unwind);\n+                            self.visit_branch(block, *unwind);\n                         }\n                     }\n                 }\n             }\n \n             fn super_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use mir::interpret::EvalErrorKind::*;\n-                if let BoundsCheck {\n-                        ref $($mutability)* len,\n-                        ref $($mutability)* index\n-                    } = *msg {\n+                use crate::mir::interpret::EvalErrorKind::*;\n+                if let BoundsCheck { len, index } = msg {\n                     self.visit_operand(len, location);\n                     self.visit_operand(index, location);\n                 }\n             }\n \n             fn super_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n-                match *rvalue {\n-                    Rvalue::Use(ref $($mutability)* operand) => {\n+                match rvalue {\n+                    Rvalue::Use(operand) => {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n+                    Rvalue::Repeat(value, _) => {\n                         self.visit_operand(value, location);\n                     }\n \n-                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(r, bk, path) => {\n                         self.visit_region(r, location);\n                         let ctx = match bk {\n                             BorrowKind::Shared => PlaceContext::NonMutatingUse(\n@@ -607,71 +604,70 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n-                    Rvalue::Len(ref $($mutability)* path) => {\n+                    Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::Cast(_cast_kind,\n-                                 ref $($mutability)* operand,\n-                                 ref $($mutability)* ty) => {\n+                    Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::BinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) |\n-                    Rvalue::CheckedBinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) => {\n+                    Rvalue::BinaryOp(_bin_op, lhs, rhs)\n+                    | Rvalue::CheckedBinaryOp(_bin_op, lhs, rhs) => {\n                         self.visit_operand(lhs, location);\n                         self.visit_operand(rhs, location);\n                     }\n \n-                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, op) => {\n                         self.visit_operand(op, location);\n                     }\n \n-                    Rvalue::Discriminant(ref $($mutability)* place) => {\n+                    Rvalue::Discriminant(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n+                    Rvalue::NullaryOp(_op, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::Aggregate(ref $($mutability)* kind,\n-                                      ref $($mutability)* operands) => {\n-                        let kind = &$($mutability)* **kind;\n-                        match *kind {\n-                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                    Rvalue::Aggregate(kind, operands) => {\n+                        let kind = &$($mutability)? **kind;\n+                        match kind {\n+                            AggregateKind::Array(ty) => {\n                                 self.visit_ty(ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n-                            AggregateKind::Adt(_adt_def,\n-                                               _variant_index,\n-                                               ref $($mutability)* substs,\n-                                               _user_substs,\n-                                               _active_field_index) => {\n+                            AggregateKind::Adt(\n+                                _adt_def,\n+                                _variant_index,\n+                                substs,\n+                                _user_substs,\n+                                _active_field_index\n+                            ) => {\n                                 self.visit_substs(substs, location);\n                             }\n-                            AggregateKind::Closure(ref $($mutability)* def_id,\n-                                                   ref $($mutability)* closure_substs) => {\n+                            AggregateKind::Closure(\n+                                def_id,\n+                                closure_substs\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n-                            AggregateKind::Generator(ref $($mutability)* def_id,\n-                                                     ref $($mutability)* generator_substs,\n-                                                     _movability) => {\n+                            AggregateKind::Generator(\n+                                def_id,\n+                                generator_substs,\n+                                _movability,\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_generator_substs(generator_substs, location);\n                             }\n@@ -685,33 +681,33 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n-                match *operand {\n-                    Operand::Copy(ref $($mutability)* place) => {\n+                match operand {\n+                    Operand::Copy(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                             location\n                         );\n                     }\n-                    Operand::Move(ref $($mutability)* place) => {\n+                    Operand::Move(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n                             location\n                         );\n                     }\n-                    Operand::Constant(ref $($mutability)* constant) => {\n+                    Operand::Constant(constant) => {\n                         self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n             fn super_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     _variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     _variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -722,8 +718,8 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           _kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.visit_place(\n                     place,\n@@ -733,45 +729,39 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                match *place {\n-                    Place::Local(ref $($mutability)* local) => {\n+                match place {\n+                    Place::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(ref $($mutability)* static_) => {\n+                    Place::Static(static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(ref $($mutability)* promoted) => {\n-                        self.visit_ty(& $($mutability)* promoted.1, TyContext::Location(location));\n+                    Place::Promoted(promoted) => {\n+                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n-                    Place::Projection(ref $($mutability)* proj) => {\n+                    Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             _context: PlaceContext<'tcx>,\n                             location: Location) {\n-                let Static {\n-                    ref $($mutability)* def_id,\n-                    ref $($mutability)* ty,\n-                } = *static_;\n+                let Static { def_id, ty } = static_;\n                 self.visit_def_id(def_id, location);\n                 self.visit_ty(ty, TyContext::Location(location));\n             }\n \n             fn super_projection(&mut self,\n-                                proj: & $($mutability)* PlaceProjection<'tcx>,\n+                                proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n-                let Projection {\n-                    ref $($mutability)* base,\n-                    ref $($mutability)* elem,\n-                } = *proj;\n+                let Projection { base, elem } = proj;\n                 let context = if context.is_mutating_use() {\n                     PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n@@ -782,17 +772,17 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)* PlaceElem<'tcx>,\n+                                     proj: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n-                match *proj {\n+                match proj {\n                     ProjectionElem::Deref => {\n                     }\n                     ProjectionElem::Subslice { from: _, to: _ } => {\n                     }\n-                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                    ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n-                    ProjectionElem::Index(ref $($mutability)* local) => {\n+                    ProjectionElem::Index(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n@@ -810,32 +800,32 @@ macro_rules! make_mir_visitor {\n \n             fn super_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 let LocalDecl {\n                     mutability: _,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n+                    ty,\n+                    user_ty,\n                     name: _,\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* visibility_scope,\n+                    source_info,\n+                    visibility_scope,\n                     internal: _,\n                     is_user_variable: _,\n                     is_block_tail: _,\n-                } = *local_decl;\n+                } = local_decl;\n \n                 self.visit_ty(ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n-                for (user_ty, _) in & $($mutability)* user_ty.contents {\n+                for (user_ty, _) in & $($mutability)? user_ty.contents {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }\n \n             fn super_source_scope(&mut self,\n-                                      _scope: & $($mutability)* SourceScope) {\n+                                      _scope: & $($mutability)? SourceScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -844,82 +834,82 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 let Constant {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n-                    ref $($mutability)* literal,\n-                } = *constant;\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                } = constant;\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }\n \n-            fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {\n+            fn super_def_id(&mut self, _def_id: & $($mutability)? DefId) {\n             }\n \n-            fn super_span(&mut self, _span: & $($mutability)* Span) {\n+            fn super_span(&mut self, _span: & $($mutability)? Span) {\n             }\n \n-            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+            fn super_source_info(&mut self, source_info: & $($mutability)? SourceInfo) {\n                 let SourceInfo {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n-                } = *source_info;\n+                    span,\n+                    scope,\n+                } = source_info;\n \n                 self.visit_span(span);\n                 self.visit_source_scope(scope);\n             }\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n                 _index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n-                self.visit_span(& $($mutability)* ty.span);\n-                self.visit_ty(& $($mutability)* ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_span(& $($mutability)? ty.span);\n+                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n-            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            fn super_ty(&mut self, _ty: & $($mutability)? Ty<'tcx>) {\n             }\n \n-            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::LazyConst<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n             }\n \n-            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            fn super_substs(&mut self, _substs: & $($mutability)? &'tcx Substs<'tcx>) {\n             }\n \n             fn super_generator_substs(&mut self,\n-                                      _substs: & $($mutability)* GeneratorSubsts<'tcx>) {\n+                                      _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)? ClosureSubsts<'tcx>) {\n             }\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)* mir[location.block];\n+            fn visit_location(&mut self, mir: & $($mutability)? Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)? mir[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n-                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                    if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(location.block, terminator, location)\n                     }\n                 } else {\n-                    let statement = & $($mutability)*\n+                    let statement = & $($mutability)?\n                         basic_block.statements[location.statement_index];\n                     self.visit_statement(location.block, statement, location)\n                 }"}, {"sha": "b6c7ca11f1f2b059f5bf4b494d9932cbd7ccda03", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,13 +3,13 @@\n \n use std::str::FromStr;\n \n-use session::{early_error, early_warn, Session};\n-use session::search_paths::SearchPath;\n+use crate::session::{early_error, early_warn, Session};\n+use crate::session::search_paths::SearchPath;\n \n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n-use lint;\n-use middle::cstore;\n+use crate::lint;\n+use crate::middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n@@ -19,7 +19,7 @@ use syntax::parse;\n use syntax::symbol::Symbol;\n use syntax::feature_gate::UnstableFeatures;\n \n-use errors::{ColorConfig, FatalError, Handler};\n+use crate::errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n use std::collections::{BTreeMap, BTreeSet};\n@@ -475,7 +475,7 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Load source from file\n+    /// Loads source from file\n     File(PathBuf),\n     Str {\n         /// String that is shown in place of a filename\n@@ -523,7 +523,7 @@ impl OutputFilenames {\n             .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n-    /// Get the path where a compilation artifact of the given type for the\n+    /// Gets the path where a compilation artifact of the given type for the\n     /// given codegen unit should be placed on disk. If codegen_unit_name is\n     /// None, a path distinct from those of any codegen unit will be generated.\n     pub fn temp_path(&self, flavor: OutputType, codegen_unit_name: Option<&str>) -> PathBuf {\n@@ -532,7 +532,7 @@ impl OutputFilenames {\n     }\n \n     /// Like temp_path, but also supports things where there is no corresponding\n-    /// OutputType, like no-opt-bitcode or lto-bitcode.\n+    /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n \n@@ -616,7 +616,7 @@ impl Default for Options {\n }\n \n impl Options {\n-    /// True if there is a reason to build the dep graph.\n+    /// Returns `true` if there is a reason to build the dep graph.\n     pub fn build_dep_graph(&self) -> bool {\n         self.incremental.is_some() || self.debugging_opts.dump_dep_graph\n             || self.debugging_opts.query_dep_graph\n@@ -632,7 +632,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// True if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried\n@@ -1305,6 +1305,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print some statistics about AST and HIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata\"),\n+    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n+        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n@@ -2342,7 +2344,7 @@ pub mod nightly_options {\n     use getopts;\n     use syntax::feature_gate::UnstableFeatures;\n     use super::{ErrorOutputType, OptionStability, RustcOptGroup};\n-    use session::early_error;\n+    use crate::session::early_error;\n \n     pub fn is_unstable_enabled(matches: &getopts::Matches) -> bool {\n         is_nightly_build()\n@@ -2431,8 +2433,8 @@ impl fmt::Display for CrateType {\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n-    use lint;\n-    use middle::cstore;\n+    use crate::lint;\n+    use crate::middle::cstore;\n     use std::collections::BTreeMap;\n     use std::hash::Hash;\n     use std::path::PathBuf;\n@@ -2565,14 +2567,14 @@ mod dep_tracking {\n \n #[cfg(test)]\n mod tests {\n-    use errors;\n+    use crate::errors;\n     use getopts;\n-    use lint;\n-    use middle::cstore;\n-    use session::config::{build_configuration, build_session_options_and_crate_config};\n-    use session::config::{LtoCli, CrossLangLto};\n-    use session::build_session;\n-    use session::search_paths::SearchPath;\n+    use crate::lint;\n+    use crate::middle::cstore;\n+    use crate::session::config::{build_configuration, build_session_options_and_crate_config};\n+    use crate::session::config::{LtoCli, CrossLangLto};\n+    use crate::session::build_session;\n+    use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;"}, {"sha": "77f190e281229bb314cc46a14151dc410f900102", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -7,7 +7,7 @@ use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n \n-use session::search_paths::{SearchPath, PathKind};\n+use crate::session::search_paths::{SearchPath, PathKind};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n \n #[derive(Copy, Clone)]"}, {"sha": "51b6205facb9e9003dd299874ef7bbec2ec8892d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,36 +1,36 @@\n pub use self::code_stats::{DataTypeKind, SizeKind, FieldInfo, VariantInfo};\n use self::code_stats::CodeStats;\n \n-use dep_graph::cgu_reuse_tracker::CguReuseTracker;\n-use hir::def_id::CrateNum;\n+use crate::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n+use crate::hir::def_id::CrateNum;\n use rustc_data_structures::fingerprint::Fingerprint;\n \n-use lint;\n-use lint::builtin::BuiltinLintDiagnostics;\n-use middle::allocator::AllocatorKind;\n-use middle::dependency_format;\n-use session::config::{OutputType, Lto};\n-use session::search_paths::{PathKind, SearchPath};\n-use util::nodemap::{FxHashMap, FxHashSet};\n-use util::common::{duration_to_secs_str, ErrorReported};\n-use util::common::ProfileQueriesMsg;\n+use crate::lint;\n+use crate::lint::builtin::BuiltinLintDiagnostics;\n+use crate::middle::allocator::AllocatorKind;\n+use crate::middle::dependency_format;\n+use crate::session::config::{OutputType, Lto};\n+use crate::session::search_paths::{PathKind, SearchPath};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::common::{duration_to_secs_str, ErrorReported};\n+use crate::util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n     self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n     Ordering::SeqCst,\n };\n \n-use errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n-use errors::emitter::{Emitter, EmitterWriter};\n+use crate::errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n+use crate::errors::emitter::{Emitter, EmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n use syntax_pos::{MultiSpan, Span};\n-use util::profiling::SelfProfiler;\n+use crate::util::profiling::SelfProfiler;\n \n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n use rustc_data_structures::flock;\n@@ -51,7 +51,7 @@ pub mod filesearch;\n pub mod search_paths;\n \n pub struct OptimizationFuel {\n-    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n+    /// If `-zfuel=crate=n` is specified, initially set to `n`, otherwise `0`.\n     remaining: u64,\n     /// We're rejecting all further optimizations.\n     out_of_fuel: bool,\n@@ -64,7 +64,7 @@ pub struct Session {\n     pub host: Target,\n     pub opts: config::Options,\n     pub host_tlib_path: SearchPath,\n-    /// This is `None` if the host and target are the same.\n+    /// `None` if the host and target are the same.\n     pub target_tlib_path: Option<SearchPath>,\n     pub parse_sess: ParseSess,\n     pub sysroot: PathBuf,\n@@ -85,7 +85,7 @@ pub struct Session {\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n-    pub plugin_attributes: OneThread<RefCell<Vec<(String, AttributeType)>>>,\n+    pub plugin_attributes: Lock<Vec<(String, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`\n@@ -104,7 +104,7 @@ pub struct Session {\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Once<usize>,\n \n-    /// The maximum number of stackframes allowed in const eval\n+    /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n     /// The metadata::creader module may inject an allocator/panic_runtime\n@@ -123,13 +123,13 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by -Z profile-queries in util::common\n+    /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling_active: bool,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Lock<SelfProfiler>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -140,14 +140,14 @@ pub struct Session {\n \n     next_node_id: OneThread<Cell<ast::NodeId>>,\n \n-    /// If -zfuel=crate=n is specified, Some(crate).\n+    /// If `-zfuel=crate=n` is specified, `Some(crate)`.\n     optimization_fuel_crate: Option<String>,\n \n-    /// Tracks fuel info if If -zfuel=crate=n is specified\n+    /// Tracks fuel info if `-zfuel=crate=n` is specified.\n     optimization_fuel: Lock<OptimizationFuel>,\n \n     // The next two are public because the driver needs to read them.\n-    /// If -zprint-fuel=crate, Some(crate).\n+    /// If `-zprint-fuel=crate`, `Some(crate)`.\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n     pub print_fuel: AtomicU64,\n@@ -156,20 +156,20 @@ pub struct Session {\n     /// false positives about a job server in our environment.\n     pub jobserver: Client,\n \n-    /// Metadata about the allocators for the current crate being compiled\n+    /// Metadata about the allocators for the current crate being compiled.\n     pub has_global_allocator: Once<bool>,\n \n-    /// Metadata about the panic handlers for the current crate being compiled\n+    /// Metadata about the panic handlers for the current crate being compiled.\n     pub has_panic_handler: Once<bool>,\n \n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n }\n \n pub struct PerfStats {\n-    /// The accumulated time spent on computing symbol hashes\n+    /// The accumulated time spent on computing symbol hashes.\n     pub symbol_hash_time: Lock<Duration>,\n-    /// The accumulated time spent decoding def path tables from metadata\n+    /// The accumulated time spent decoding def path tables from metadata.\n     pub decode_def_path_tables_time: Lock<Duration>,\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: AtomicUsize,\n@@ -539,7 +539,7 @@ impl Session {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n \n-    /// Get the features enabled for the current compilation session.\n+    /// Gets the features enabled for the current compilation session.\n     /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n     /// dependency tracking. Use tcx.features() instead.\n     #[inline]\n@@ -989,7 +989,7 @@ impl Session {\n         self.opts.edition\n     }\n \n-    /// True if we cannot skip the PLT for shared library calls.\n+    /// Returns `true` if we cannot skip the PLT for shared library calls.\n     pub fn needs_plt(&self) -> bool {\n         // Check if the current target usually needs PLT to be enabled.\n         // The user can use the command line flag to override it.\n@@ -1178,7 +1178,7 @@ pub fn build_session_(\n         buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n-        plugin_attributes: OneThread::new(RefCell::new(Vec::new())),\n+        plugin_attributes: Lock::new(Vec::new()),\n         crate_types: Once::new(),\n         dependency_formats: Once::new(),\n         crate_disambiguator: Once::new(),"}, {"sha": "a950258cefd0cb90d82b684bac801d776eec9931", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n use std::path::{Path, PathBuf};\n-use session::{early_error, config};\n-use session::filesearch::make_target_lib_path;\n+use crate::session::{early_error, config};\n+use crate::session::filesearch::make_target_lib_path;\n \n #[derive(Clone, Debug)]\n pub struct SearchPath {"}, {"sha": "012b9e5034caee0586c0ddb4ed9529b89e7ff2e8", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,12 +6,12 @@ use super::*;\n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n \n-use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::InferCtxt;\n+use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n+use crate::infer::InferCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n-use ty::fold::TypeFolder;\n-use ty::{Region, RegionVid};\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::{Region, RegionVid};\n \n // FIXME(twk): this is obviously not nice to duplicate like that\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         AutoTraitFinder { tcx }\n     }\n \n-    /// Make a best effort to determine whether and under which conditions an auto trait is\n+    /// Makes a best effort to determine whether and under which conditions an auto trait is\n     /// implemented for a type. For example, if you have\n     ///\n     /// ```"}, {"sha": "d9eb6d8157dfbdd3590af1e35eecd1fe10eb9510", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,4 +1,4 @@\n-use traits::{\n+use crate::traits::{\n     Environment,\n     InEnvironment,\n     TraitEngine,\n@@ -8,10 +8,10 @@ use traits::{\n     FulfillmentErrorCode,\n     SelectionError,\n };\n-use traits::query::NoSolution;\n-use infer::InferCtxt;\n-use infer::canonical::{Canonical, OriginalQueryValues};\n-use ty::{self, Ty};\n+use crate::traits::query::NoSolution;\n+use crate::infer::InferCtxt;\n+use crate::infer::canonical::{Canonical, OriginalQueryValues};\n+use crate::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n \n pub type CanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;"}, {"sha": "d6b7b3b99cacd8c18bcaf974a6c39bed6b136767", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,19 +3,19 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepKind, DepTrackingMapConfig};\n+use crate::dep_graph::{DepKind, DepTrackingMapConfig};\n use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n-use infer::InferCtxt;\n+use crate::infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n+use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n-use ty::{self, Ty, TyCtxt};\n-use ty::subst::{Subst, Substs};\n-use ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::fold::TypeFoldable;\n \n-/// Attempts to resolve an obligation to a vtable.. The result is\n-/// a shallow vtable resolution -- meaning that we do not\n+/// Attempts to resolve an obligation to a vtable. The result is\n+/// a shallow vtable resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to."}, {"sha": "a57007e51d3b14900cb8f582a3740ca5a7217a02", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,20 +1,20 @@\n-//! See rustc guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n+//! See Rustc Guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n //! this works.\n //!\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use infer::CombinedSnapshot;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::infer::CombinedSnapshot;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n-use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n-use traits::IntercrateMode;\n-use traits::select::IntercrateAmbiguityCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::TypeFoldable;\n-use ty::subst::Subst;\n+use crate::traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n+use crate::traits::IntercrateMode;\n+use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::Subst;\n \n-use infer::{InferOk};\n+use crate::infer::{InferOk};\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -34,12 +34,12 @@ pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n \n-    /// True if the overlap might've been permitted before the shift\n+    /// `true` if the overlap might've been permitted before the shift\n     /// to universes.\n     pub involves_placeholder: bool,\n }\n \n-pub fn add_placeholder_note(err: &mut ::errors::DiagnosticBuilder<'_>) {\n+pub fn add_placeholder_note(err: &mut crate::errors::DiagnosticBuilder<'_>) {\n     err.note(&format!(\n         \"this behavior recently changed as a result of a bug fix; \\\n          see rust-lang/rust#56105 for details\"\n@@ -111,7 +111,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n }\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n-/// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n+/// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     a_def_id: DefId,\n@@ -242,7 +242,7 @@ pub enum OrphanCheckErr<'tcx> {\n }\n \n /// Checks the coherence orphan rules. `impl_def_id` should be the\n-/// def-id of a trait impl. To pass, either the trait must be local, or else\n+/// `DefId` of a trait impl. To pass, either the trait must be local, or else\n /// two conditions must be satisfied:\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n@@ -268,7 +268,7 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n-/// Check whether a trait-ref is potentially implementable by a crate.\n+/// Checks whether a trait-ref is potentially implementable by a crate.\n ///\n /// The current rule is that a trait-ref orphan checks in a crate C:\n ///"}, {"sha": "2f019d823ff5d2a7a5f3b6d02684d58ad502bd9b", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use infer::InferCtxt;\n-use ty::{self, Ty, TyCtxt, ToPredicate};\n-use traits::Obligation;\n-use hir::def_id::DefId;\n+use crate::infer::InferCtxt;\n+use crate::ty::{self, Ty, TyCtxt, ToPredicate};\n+use crate::traits::Obligation;\n+use crate::hir::def_id::DefId;\n \n use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};"}, {"sha": "3a47b554b2ab15503753bc98bd3ded2eae57c864", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -17,23 +17,23 @@ use super::{\n     Overflow,\n };\n \n-use errors::{Applicability, DiagnosticBuilder};\n-use hir;\n-use hir::Node;\n-use hir::def_id::DefId;\n-use infer::{self, InferCtxt};\n-use infer::type_variable::TypeVariableOrigin;\n+use crate::errors::{Applicability, DiagnosticBuilder};\n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::infer::{self, InferCtxt};\n+use crate::infer::type_variable::TypeVariableOrigin;\n use std::fmt;\n use syntax::ast;\n-use session::DiagnosticMessageId;\n-use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use ty::GenericParamDefKind;\n-use ty::error::ExpectedFound;\n-use ty::fast_reject;\n-use ty::fold::TypeFolder;\n-use ty::subst::Subst;\n-use ty::SubtypePredicate;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use crate::session::DiagnosticMessageId;\n+use crate::ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::GenericParamDefKind;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::subst::Subst;\n+use crate::ty::SubtypePredicate;\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n \n-    /// Get the parent trait chain start\n+    /// Gets the parent trait chain start\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n@@ -1035,7 +1035,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                  ).collect::<Vec<_>>())\n             }\n             Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(self.tcx.hir().span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(\n+                    self.tcx.hir().span_by_hir_id(variant_data.hir_id())),\n                  vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n@@ -1375,7 +1376,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns whether the trait predicate may apply for *some* assignment\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n     fn predicate_can_apply(&self,\n                            param_env: ty::ParamEnv<'tcx>,"}, {"sha": "587f57bb09dee7f0e4201e575563910ccbf12b41", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use infer::InferCtxt;\n-use mir::interpret::{GlobalId, ErrorHandled};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n-use ty::error::ExpectedFound;\n+use crate::infer::InferCtxt;\n+use crate::mir::interpret::{GlobalId, ErrorHandled};\n+use crate::ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n+use crate::ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_data_structures::obligation_forest::{ProcessResult};\n@@ -23,7 +23,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n }\n \n-/// The fulfillment context is used to drive trait resolution.  It\n+/// The fulfillment context is used to drive trait resolution. It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n /// errors, and which are still pending. At any point, users can call\n@@ -140,7 +140,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n-    /// `SomeTrait` or a where clause that lets us unify `$0` with\n+    /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n     fn normalize_projection_type<'a, 'gcx>(&mut self,\n@@ -509,7 +509,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     }\n }\n \n-/// Return the set of type variables contained in a trait ref\n+/// Returns the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n                                        t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {"}, {"sha": "a32838f0e4c0c356ce9c459817d2c4b13e771890", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -20,20 +20,20 @@ mod util;\n pub mod query;\n \n use chalk_engine;\n-use hir;\n-use hir::def_id::DefId;\n-use infer::{InferCtxt, SuppressRegionErrors};\n-use infer::outlives::env::OutlivesEnvironment;\n-use middle::region;\n-use mir::interpret::ErrorHandled;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, SuppressRegionErrors};\n+use crate::infer::outlives::env::OutlivesEnvironment;\n+use crate::middle::region;\n+use crate::mir::interpret::ErrorHandled;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::subst::Substs;\n-use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n-use ty::error::{ExpectedFound, TypeError};\n-use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use util::common::ErrorReported;\n+use crate::ty::subst::Substs;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n+use crate::ty::error::{ExpectedFound, TypeError};\n+use crate::ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n+use crate::util::common::ErrorReported;\n \n use std::fmt::Debug;\n use std::rc::Rc;\n@@ -73,14 +73,14 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n-// Whether to enable bug compatibility with issue #43355\n+/// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n     Issue43355,\n     Fixed\n }\n \n-// The mode that trait queries run in\n+/// The mode that trait queries run in.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n@@ -93,45 +93,45 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g., `int:Eq`) for\n-/// which the vtable must be found.  The process of finding a vtable is\n+/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n+/// which the vtable must be found. The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n-    /// Why do we have to prove this thing?\n+    /// The reason we have to prove this thing.\n     pub cause: ObligationCause<'tcx>,\n \n-    /// In which environment should we prove this thing?\n+    /// The environment in which we should prove this thing.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n-    /// What are we trying to prove?\n+    /// The thing we are trying to prove.\n     pub predicate: T,\n \n     /// If we started proving this as a result of trying to prove\n     /// something else, track the total depth to ensure termination.\n     /// If this goes over a certain threshold, we abort compilation --\n     /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem. Such a drag.\n+    /// holds for certain. Stupid halting problem; such a drag.\n     pub recursion_depth: usize,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n-/// Why did we incur this obligation? Used for error reporting.\n+/// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n-    // The id of the fn body that triggered this obligation. This is\n-    // used for region obligations to determine the precise\n-    // environment in which the region obligation should be evaluated\n-    // (in particular, closures can add new assumptions). See the\n-    // field `region_obligations` of the `FulfillmentContext` for more\n-    // information.\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n     pub body_id: ast::NodeId,\n \n     pub code: ObligationCauseCode<'tcx>\n@@ -152,20 +152,20 @@ impl<'tcx> ObligationCause<'tcx> {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from span.\n+    /// Not well classified or should be obvious from the span.\n     MiscObligation,\n \n-    /// A slice or array is WF only if `T: Sized`\n+    /// A slice or array is WF only if `T: Sized`.\n     SliceOrArrayElem,\n \n-    /// A tuple is WF only if its middle elements are Sized\n+    /// A tuple is WF only if its middle elements are `Sized`.\n     TupleElem,\n \n-    /// This is the trait reference from the given projection\n+    /// This is the trait reference from the given projection.\n     ProjectionWf(ty::ProjectionTy<'tcx>),\n \n-    /// In an impl of trait X for type Y, type Y must\n-    /// also implement all supertraits of X.\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n     ItemObligation(DefId),\n \n     /// A type like `&'a T` is WF only if `T: 'a`.\n@@ -271,7 +271,7 @@ pub struct DerivedObligationCause<'tcx> {\n     /// directly.\n     parent_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    /// The parent trait had this cause\n+    /// The parent trait had this cause.\n     parent_code: Rc<ObligationCauseCode<'tcx>>\n }\n \n@@ -280,14 +280,14 @@ pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n /// The following types:\n-/// * `WhereClause`\n-/// * `WellFormed`\n-/// * `FromEnv`\n-/// * `DomainGoal`\n-/// * `Goal`\n-/// * `Clause`\n-/// * `Environment`\n-/// * `InEnvironment`\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n@@ -399,10 +399,10 @@ pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n /// with the goal to solve and proceeds from there).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true...\n+    /// This goal will be considered true ...\n     pub goal: DomainGoal<'tcx>,\n \n-    /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n     pub hypotheses: Goals<'tcx>,\n \n     /// Useful for filtering clauses.\n@@ -485,7 +485,6 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// For example, the vtable may be tied to a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n-///\n /// ```\n /// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n /// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n@@ -517,7 +516,7 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n \n-    /// Vtable for auto trait implementations\n+    /// Vtable for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n@@ -529,18 +528,18 @@ pub enum Vtable<'tcx, N> {\n     /// any).\n     VtableParam(Vec<N>),\n \n-    /// Virtual calls through an object\n+    /// Virtual calls through an object.\n     VtableObject(VtableObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n-    /// Vtable automatically generated for a closure. The def ID is the ID\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n     /// of the closure expression. This is a `VtableImpl` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n     VtableClosure(VtableClosureData<'tcx, N>),\n \n-    /// Same as above, but for a fn pointer type with the given signature.\n+    /// Same as above, but for a function pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n \n     /// Vtable automatically generated for a generator."}, {"sha": "b31aa5998f3654ec2c29e155d06c751176189f8d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,33 +6,33 @@\n //!   - have a suitable receiver from which we can extract a vtable and coerce to a \"thin\" version\n //!     that doesn't contain the vtable;\n //!   - not reference the erased type `Self` except for in this receiver;\n-//!   - not have generic type parameters\n+//!   - not have generic type parameters.\n \n use super::elaborate_predicates;\n \n-use hir::def_id::DefId;\n-use lint;\n-use traits::{self, Obligation, ObligationCause};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n-use ty::subst::{Subst, Substs};\n+use crate::hir::def_id::DefId;\n+use crate::lint;\n+use crate::traits::{self, Obligation, ObligationCause};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n+use crate::ty::subst::{Subst, Substs};\n use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n-    /// Self : Sized declared on the trait\n+    /// `Self: Sized` declared on the trait.\n     SizedSelf,\n \n     /// Supertrait reference references `Self` an in illegal location\n-    /// (e.g., `trait Foo : Bar<Self>`)\n+    /// (e.g., `trait Foo : Bar<Self>`).\n     SupertraitSelf,\n \n-    /// Method has something illegal\n+    /// Method has something illegal.\n     Method(ast::Name, MethodViolationCode),\n \n-    /// Associated const\n+    /// Associated const.\n     AssociatedConst(ast::Name),\n }\n \n@@ -84,7 +84,7 @@ pub enum MethodViolationCode {\n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns the object safety violations that affect\n-    /// astconv - currently, Self in supertraits. This is needed\n+    /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             } else {\n                 // sanity check to make sure the receiver actually has the layout of a pointer\n \n-                use ty::layout::Abi;\n+                use crate::ty::layout::Abi;\n \n                 let param_env = self.param_env(method.def_id);\n \n@@ -399,8 +399,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         None\n     }\n \n-    /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n+    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n@@ -419,9 +419,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         result\n     }\n \n-    /// creates the object type for the current trait. For example,\n+    /// Creates the object type for the current trait. For example,\n     /// if the current trait is `Deref`, then this will be\n-    /// `dyn Deref<Target=Self::Target> + 'static`\n+    /// `dyn Deref<Target = Self::Target> + 'static`.\n     fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n         debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n \n@@ -470,25 +470,27 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         object_ty\n     }\n \n-    /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+    /// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n     /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n     /// in the following way:\n-    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n+    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n     /// - require the following bound:\n     ///\n-    ///        Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n+    ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n     ///\n-    ///    where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n     ///   (substitution notation).\n     ///\n-    /// some examples of receiver types and their required obligation\n-    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`\n-    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n+    /// Some examples of receiver types and their required obligation:\n+    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n+    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// e.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n     /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n     /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n     /// contained by the trait object, because the object that needs to be coerced is behind"}, {"sha": "f61c32614cc931847700973c160074ef25b08314", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n use fmt_macros::{Parser, Piece, Position};\n \n-use hir::def_id::DefId;\n-use ty::{self, TyCtxt, GenericParamDefKind};\n-use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, TyCtxt, GenericParamDefKind};\n+use crate::util::common::ErrorReported;\n+use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;"}, {"sha": "5a44d886e3c0a893100b755490578bf7e4983901", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -12,16 +12,16 @@ use super::SelectionError;\n use super::{VtableImplData, VtableClosureData, VtableGeneratorData, VtableFnPointerData};\n use super::util;\n \n-use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use infer::type_variable::TypeVariableOrigin;\n-use mir::interpret::{GlobalId};\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use crate::infer::type_variable::TypeVariableOrigin;\n+use crate::mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast::Ident;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use util::common::FN_OUTPUT_NAME;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::util::common::FN_OUTPUT_NAME;\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n@@ -55,7 +55,7 @@ pub enum Reveal {\n     /// Also, `impl Trait` is normalized to the concrete type,\n     /// which has to be already collected by type-checking.\n     ///\n-    /// NOTE: As `impl Trait`'s concrete type should *never*\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n     /// be observable directly by the user, `Reveal::All`\n     /// should not be used by checks which may expose\n     /// type equality or type contents to the user.\n@@ -408,7 +408,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -420,7 +420,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 promoted: None\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }\n@@ -751,9 +751,9 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n ///\n /// Concern #2. Even within the snapshot, if those original\n /// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong.  This *may* lead to some sort\n+/// that may yet turn out to be wrong. This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n-/// can occur yet.  But it seems risky at best.\n+/// can occur yet. But it seems risky at best.\n fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -786,7 +786,7 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n /// Trait>::Foo> to `[type error]` would lead to an obligation of\n-/// `<MyType<[type error]> as Trait>::Foo`.  We are supposed to report\n+/// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n@@ -844,7 +844,7 @@ impl<'tcx> Progress<'tcx> {\n     }\n }\n \n-/// Compute the result of a projection type (if we can).\n+/// Computes the result of a projection type (if we can).\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n@@ -1553,7 +1553,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n // # Cache\n \n /// The projection cache. Unlike the standard caches, this can include\n-/// infcx-dependent type variables - therefore, we have to roll the\n+/// infcx-dependent type variables, therefore we have to roll the\n /// cache back each time we roll a snapshot back, to avoid assumptions\n /// on yet-unresolved inference variables. Types with placeholder\n /// regions also have to be removed when the respective snapshot ends.\n@@ -1564,9 +1564,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// (for the lifetime of the infcx).\n ///\n /// Entries in the projection cache might contain inference variables\n-/// that will be resolved by obligations on the projection cache entry - e.g.\n+/// that will be resolved by obligations on the projection cache entry (e.g.,\n /// when a type parameter in the associated type is constrained through\n-/// an \"RFC 447\" projection on the impl.\n+/// an \"RFC 447\" projection on the impl).\n ///\n /// When working with a fulfillment context, the derived obligations of each\n /// projection cache entry will be registered on the fulfillcx, so any users\n@@ -1578,10 +1578,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// If that is done, after evaluation the obligations, it is a good idea to\n /// call `ProjectionCache::complete` to make sure the obligations won't be\n /// re-evaluated and avoid an exponential worst-case.\n-///\n-/// FIXME: we probably also want some sort of cross-infcx cache here to\n-/// reduce the amount of duplication. Let's see what we get with the Chalk\n-/// reforms.\n+//\n+// FIXME: we probably also want some sort of cross-infcx cache here to\n+// reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n #[derive(Default)]\n pub struct ProjectionCache<'tcx> {\n     map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,"}, {"sha": "e6f9c7ebe6fe4931885ec1cbf609600b9e3ae8d2", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n-use infer::at::At;\n-use infer::InferOk;\n-use infer::canonical::OriginalQueryValues;\n+use crate::infer::at::At;\n+use crate::infer::InferOk;\n+use crate::infer::canonical::OriginalQueryValues;\n use std::iter::FromIterator;\n use syntax::source_map::Span;\n-use ty::subst::Kind;\n-use ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, Ty, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -184,7 +184,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n /// outlive. This is similar but not *quite* the same as the\n /// `needs_drop` test in the compiler already -- that is, for every\n /// type T for which this function return true, needs-drop would\n-/// return false. But the reverse does not hold: in particular,\n+/// return `false`. But the reverse does not hold: in particular,\n /// `needs_drop` returns false for `PhantomData`, but it is not\n /// trivial for dropck-outlives.\n ///"}, {"sha": "d5230f15c256536bf36d8a80333fa7eee52770a0", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use infer::InferCtxt;\n-use infer::canonical::OriginalQueryValues;\n-use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n+use crate::infer::InferCtxt;\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "6b9bdfd63f4d0a9e28b62e5fcabe7ee65eb38565", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::sync::Lrc;\n-use infer::canonical::{Canonical, QueryResponse};\n-use ty::Ty;\n+use crate::infer::canonical::{Canonical, QueryResponse};\n+use crate::ty::Ty;\n \n #[derive(Debug)]\n pub struct CandidateStep<'tcx> {"}, {"sha": "112a1d0e09c944e0b4281ebd34e3b1a51a4e8cd9", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -5,9 +5,9 @@\n //! The providers for the queries defined here can be found in\n //! `librustc_traits`.\n \n-use infer::canonical::Canonical;\n-use ty::error::TypeError;\n-use ty::{self, Ty};\n+use crate::infer::canonical::Canonical;\n+use crate::ty::error::TypeError;\n+use crate::ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;"}, {"sha": "224076ce17e72c29c114233c3083d3c9b7923276", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -2,15 +2,15 @@\n //! which folds deeply, invoking the underlying\n //! `normalize_projection_ty` query when it encounters projections.\n \n-use infer::at::At;\n-use infer::canonical::OriginalQueryValues;\n-use infer::{InferCtxt, InferOk};\n-use mir::interpret::GlobalId;\n-use traits::project::Normalized;\n-use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt};\n+use crate::infer::at::At;\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::mir::interpret::GlobalId;\n+use crate::traits::project::Normalized;\n+use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n@@ -24,7 +24,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// the normalized value along with various outlives relations (in\n     /// the form of obligations that must be discharged).\n     ///\n-    /// NB. This will *eventually* be the main means of\n+    /// N.B., this will *eventually* be the main means of\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n@@ -203,7 +203,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -215,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 promoted: None,\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }"}, {"sha": "0c1252680c1dbb861058ebcbfc4d5f880136a04e", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -7,8 +7,8 @@\n //! `normalize_ty_after_erasing_regions` query for each type found\n //! within. (This underlying query is what is cached.)\n \n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     /// Erase the regions in `value` and then fully normalize all the\n@@ -45,7 +45,7 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     /// a `T` (with regions erased). This is appropriate when the\n     /// binder is being instantiated at the call site.\n     ///\n-    /// NB. Currently, higher-ranked type bounds inhibit\n+    /// N.B., currently, higher-ranked type bounds inhibit\n     /// normalization. Therefore, each time we erase them in\n     /// codegen, we need to normalize the contents.\n     pub fn normalize_erasing_late_bound_regions<T>("}, {"sha": "6fe361d5adf6d66a57f4d836702564c96bc54490", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,19 +1,19 @@\n-use infer::InferCtxt;\n-use infer::canonical::OriginalQueryValues;\n+use crate::infer::InferCtxt;\n+use crate::infer::canonical::OriginalQueryValues;\n use syntax::ast;\n use syntax::source_map::Span;\n-use traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n-use traits::query::NoSolution;\n-use ty::{self, Ty, TyCtxt};\n+use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::query::NoSolution;\n+use crate::ty::{self, Ty, TyCtxt};\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::mem;\n \n /// Outlives bounds are relationships between generic parameters,\n /// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// involved (`T: 'a`). These relationships can be extracted from the\n /// full set of predicates we understand or also from types (in which\n /// case they are called implied bounds). They are fed to the\n /// `OutlivesEnv` which in turn is supplied to the region checker and\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n-    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before\n     /// calling that fn, and hence the *callee* can assume that its\n     /// argument types are well-formed. This may imply certain relationships"}, {"sha": "d9f573eb7e291a3d4987db36c7b981c211eec989", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::Fallible;\n-use hir::def_id::DefId;\n-use ty::{ParamEnvAnd, Ty, TyCtxt};\n-use ty::subst::UserSubsts;\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::Fallible;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::subst::UserSubsts;\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct AscribeUserType<'tcx> {"}, {"sha": "7e38282cc1adcd2d1d19dd4196f76cb7fb99f3c3", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,12 +1,12 @@\n-use infer::{InferCtxt, InferOk};\n+use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n-use traits::query::Fallible;\n+use crate::traits::query::Fallible;\n \n-use infer::canonical::query_response;\n-use infer::canonical::QueryRegionConstraint;\n+use crate::infer::canonical::query_response;\n+use crate::infer::canonical::QueryRegionConstraint;\n use std::rc::Rc;\n use syntax::source_map::DUMMY_SP;\n-use traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n \n pub struct CustomTypeOp<F, G> {\n     closure: F,"}, {"sha": "5c3ccc9a995371c182437077ca8a5f080bcfe34b", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::Fallible;\n-use ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::Fallible;\n+use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct Eq<'tcx> {"}, {"sha": "c48ca33b13fbcb02624db51e624de2b28208f7e7", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::outlives_bounds::OutlivesBound;\n-use traits::query::Fallible;\n-use ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::outlives_bounds::OutlivesBound;\n+use crate::traits::query::Fallible;\n+use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct ImpliedOutlivesBounds<'tcx> {"}, {"sha": "fd13acc7796f87906c1b4ba5c46971b1a0c0a7d6", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,14 +1,14 @@\n-use infer::canonical::{\n+use crate::infer::canonical::{\n     Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n     QueryRegionConstraint, QueryResponse,\n };\n-use infer::{InferCtxt, InferOk};\n+use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n use std::rc::Rc;\n-use traits::query::Fallible;\n-use traits::ObligationCause;\n-use ty::fold::TypeFoldable;\n-use ty::{Lift, ParamEnvAnd, TyCtxt};\n+use crate::traits::query::Fallible;\n+use crate::traits::ObligationCause;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{Lift, ParamEnvAnd, TyCtxt};\n \n pub mod ascribe_user_type;\n pub mod custom;"}, {"sha": "e3d7a4d57a5643841cc0104b8347e207e7124615", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use std::fmt;\n-use traits::query::Fallible;\n-use ty::fold::TypeFoldable;\n-use ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n+use crate::traits::query::Fallible;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct Normalize<T> {\n@@ -52,7 +52,7 @@ pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx>\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n \n-    /// Convert from the `'gcx` (lifted) form of `Self` into the `tcx`\n+    /// Converts from the `'gcx` (lifted) form of `Self` into the `tcx`\n     /// form of `Self`.\n     fn shrink_to_tcx_lifetime(\n         v: &'a CanonicalizedQueryResponse<'gcx, Self>,"}, {"sha": "fc0c1c022fc80a1c01725c74d0d732c65e9f25c0", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::dropck_outlives::trivial_dropck_outlives;\n-use traits::query::dropck_outlives::DropckOutlivesResult;\n-use traits::query::Fallible;\n-use ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::dropck_outlives::trivial_dropck_outlives;\n+use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n+use crate::traits::query::Fallible;\n+use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug)]\n pub struct DropckOutlives<'tcx> {"}, {"sha": "50dedf6e87f40d59f508915860cdb1415ea1e587", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::Fallible;\n-use ty::{ParamEnvAnd, Predicate, TyCtxt};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::Fallible;\n+use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct ProvePredicate<'tcx> {"}, {"sha": "c45fb06313e1600d13e8486b2f8d45bb83a40429", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use traits::query::Fallible;\n-use ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::traits::query::Fallible;\n+use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct Subtype<'tcx> {"}, {"sha": "557784b3e3c8238ff62080e2c14a590de01333ce", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -27,25 +27,25 @@ use super::{\n     VtableGeneratorData, VtableImplData, VtableObjectData, VtableTraitAliasData,\n };\n \n-use dep_graph::{DepKind, DepNodeIndex};\n-use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, TypeFreshener};\n-use middle::lang_items;\n-use mir::interpret::GlobalId;\n-use ty::fast_reject;\n-use ty::relate::TypeRelation;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n-\n-use hir;\n+use crate::dep_graph::{DepKind, DepNodeIndex};\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n+use crate::middle::lang_items;\n+use crate::mir::interpret::GlobalId;\n+use crate::ty::fast_reject;\n+use crate::ty::relate::TypeRelation;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n use std::rc::Rc;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct SelectionContext<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -103,7 +103,7 @@ impl IntercrateAmbiguityCause {\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(\n         &self,\n-        err: &mut ::errors::DiagnosticBuilder<'_>,\n+        err: &mut crate::errors::DiagnosticBuilder<'_>,\n     ) {\n         err.note(&self.intercrate_ambiguity_hint());\n     }\n@@ -162,11 +162,11 @@ pub struct SelectionCache<'tcx> {\n }\n \n /// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation.  Sometimes\n+/// clauses, and so forth that might resolve an obligation. Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not\n /// apply to the obligation: perhaps it is defined for `usize` but the\n /// obligation is for `int`. In that case, we drop the impl out of the\n-/// list.  But the other cases are considered *candidates*.\n+/// list. But the other cases are considered *candidates*.\n ///\n /// For selection to succeed, there must be exactly one matching\n /// candidate. If the obligation is fully known, this is guaranteed\n@@ -331,7 +331,7 @@ enum BuiltinImplConditions<'tcx> {\n ///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n ///     - the \"union\" of evaluation results is equal to their maximum -\n ///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are no-ops when unioned with a definite error, and within\n+///     so they are noops when unioned with a definite error, and within\n ///     the categories it's easy to see that the unions are correct.\n pub enum EvaluationResult {\n     /// Evaluation successful\n@@ -383,31 +383,30 @@ pub enum EvaluationResult {\n     /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" - it won't\n+    /// recurses. This shows us that the impl is \"useless\" -- it won't\n     /// tell us that `T: Trait` unless it already implemented `Trait`\n     /// by some other means. However, that does not prevent `T: Trait`\n     /// does not hold, because of the bound (which can indeed be satisfied\n     /// by `SomeUnsizedType` from another crate).\n-    ///\n-    /// FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    /// ought to convert it to an `EvaluatedToErr`, because we know\n-    /// there definitely isn't a proof tree for that obligation. Not\n-    /// doing so is still sound - there isn't any proof tree, so the\n-    /// branch still can't be a part of a minimal one - but does not\n-    /// re-enable caching.\n+    //\n+    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    // ought to convert it to an `EvaluatedToErr`, because we know\n+    // there definitely isn't a proof tree for that obligation. Not\n+    // doing so is still sound -- there isn't any proof tree, so the\n+    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n     EvaluatedToRecur,\n-    /// Evaluation failed\n+    /// Evaluation failed.\n     EvaluatedToErr,\n }\n \n impl EvaluationResult {\n-    /// True if this evaluation result is known to apply, even\n+    /// Returns `true` if this evaluation result is known to apply, even\n     /// considering outlives constraints.\n     pub fn must_apply_considering_regions(self) -> bool {\n         self == EvaluatedToOk\n     }\n \n-    /// True if this evaluation result is known to apply, ignoring\n+    /// Returns `true` if this evaluation result is known to apply, ignoring\n     /// outlives constraints.\n     pub fn must_apply_modulo_regions(self) -> bool {\n         self <= EvaluatedToOkModuloRegions\n@@ -981,8 +980,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// that recursion is ok. This routine returns true if the top of the\n     /// stack (`cycle[0]`):\n     ///\n-    /// - is a defaulted trait, and\n-    /// - it also appears in the backtrace at some position `X`; and,\n+    /// - is a defaulted trait,\n+    /// - it also appears in the backtrace at some position `X`,\n     /// - all the predicates at positions `X..` between `X` an the top are\n     ///   also defaulted traits.\n     pub fn coinductive_match<I>(&mut self, cycle: I) -> bool\n@@ -1003,7 +1002,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n-    /// obligations are met. Returns true if `candidate` remains viable after this further\n+    /// obligations are met. Returns whether `candidate` remains viable after this further\n     /// scrutiny.\n     fn evaluate_candidate<'o>(\n         &mut self,\n@@ -1434,7 +1433,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if the global caches can be used.\n+    /// Returns `true` if the global caches can be used.\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n     fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n@@ -1850,7 +1849,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Check for the artificial impl that the compiler will create for an obligation like `X :\n+    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is a closure type.\n     ///\n     /// Note: the type parameters on a closure candidate are modeled as *output* type\n@@ -2231,8 +2230,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     // type variables and then we also attempt to evaluate recursive\n     // bounds to see if they are satisfied.\n \n-    /// Returns true if `victim` should be dropped in favor of\n-    /// `other`.  Generally speaking we will drop duplicate\n+    /// Returns `true` if `victim` should be dropped in favor of\n+    /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n     ///\n     /// See the comment for \"SelectionCandidate\" for more details.\n@@ -3221,7 +3220,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// we currently treat the input type parameters on the trait as\n     /// outputs. This means that when we have a match we have only\n     /// considered the self type, so we have to go back and make sure\n-    /// to relate the argument types too.  This is kind of wrong, but\n+    /// to relate the argument types too. This is kind of wrong, but\n     /// since we control the full set of impls, also not that wrong,\n     /// and it DOES yield better error messages (since we don't report\n     /// errors as if there is no applicable impl, but rather report\n@@ -3235,7 +3234,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ///     impl Fn(int) for Closure { ... }\n     ///\n     /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n-    /// we have matched the self-type `Closure`. At this point we'll\n+    /// we have matched the self type `Closure`. At this point we'll\n     /// compare the `int` to `usize` and generate an error.\n     ///\n     /// Note that this checking occurs *after* the impl has selected,\n@@ -3597,7 +3596,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Normalize `where_clause_trait_ref` and try to match it against\n-    /// `obligation`.  If successful, return any predicates that\n+    /// `obligation`. If successful, return any predicates that\n     /// result from the normalization. Normalization is necessary\n     /// because where-clauses are stored in the parameter environment\n     /// unnormalized."}, {"sha": "804f1b9d820a2c983b95d361abb5d1af8dcf56c9", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -11,16 +11,16 @@\n \n pub mod specialization_graph;\n \n-use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk};\n-use lint;\n-use traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::lint;\n+use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n-use traits::select::IntercrateAmbiguityCause;\n-use ty::{self, TyCtxt, TypeFoldable};\n-use ty::subst::{Subst, Substs};\n+use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::ty::{self, TyCtxt, TypeFoldable};\n+use crate::ty::subst::{Subst, Substs};\n \n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n@@ -58,12 +58,12 @@ pub struct OverlapError {\n /// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n /// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n ///\n-/// Where clauses add some trickiness here, because they can be used to \"define\"\n+/// where-clauses add some trickiness here, because they can be used to \"define\"\n /// an argument indirectly:\n ///\n /// ```rust\n /// impl<'a, I, T: 'a> Iterator for Cloned<I>\n-///    where I: Iterator<Item=&'a T>, T: Clone\n+///    where I: Iterator<Item = &'a T>, T: Clone\n /// ```\n ///\n /// In a case like this, the substitution for `T` is determined indirectly,\n@@ -145,10 +145,10 @@ pub fn find_associated_item<'a, 'tcx>(\n     }\n }\n \n-/// Is impl1 a specialization of impl2?\n+/// Is `impl1` a specialization of `impl2`?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;\n-/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n+/// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     (impl1_def_id, impl2_def_id): (DefId, DefId))"}, {"sha": "561859c7c3177631ddac7e8688545f39f430c82d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,16 +1,16 @@\n use super::OverlapError;\n \n-use hir::def_id::DefId;\n-use ich::{self, StableHashingContext};\n+use crate::hir::def_id::DefId;\n+use crate::ich::{self, StableHashingContext};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n-use traits;\n-use ty::{self, TyCtxt, TypeFoldable};\n-use ty::fast_reject::{self, SimplifiedType};\n+use crate::traits;\n+use crate::ty::{self, TyCtxt, TypeFoldable};\n+use crate::ty::fast_reject::{self, SimplifiedType};\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n-use util::captures::Captures;\n-use util::nodemap::{DefIdMap, FxHashMap};\n+use crate::util::captures::Captures;\n+use crate::util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> Children {\n         }\n     }\n \n-    /// Remove an impl from this set of children. Used when replacing\n+    /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n     fn remove_existing(&mut self,\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n \n-    /// The parent of a given impl, which is the def id of the trait when the\n+    /// The parent of a given impl, which is the `DefId` of the trait when the\n     /// impl is a \"specialization root\".\n     pub fn parent(&self, child: DefId) -> DefId {\n         *self.parent.get(&child).unwrap()\n@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n         trait_def_id: DefId,\n     ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n-            use ty::AssociatedKind::*;\n+            use crate::ty::AssociatedKind::*;\n             node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {\n                 | (Const, Const)\n                 | (Method, Method)"}, {"sha": "c5cc9e8b401822907b339e0bdd5fdc7d864705bb", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n use chalk_engine;\n use smallvec::SmallVec;\n-use traits;\n-use traits::project::Normalized;\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::{self, Lift, TyCtxt};\n+use crate::traits;\n+use crate::traits::project::Normalized;\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::{self, Lift, TyCtxt};\n use syntax::symbol::InternedString;\n \n use std::fmt;\n@@ -163,7 +163,7 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n \n impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WhereClause::*;\n+        use crate::traits::WhereClause::*;\n \n         // Bypass ppaux because it does not print out anonymous regions.\n         fn write_region_name<'tcx>(\n@@ -206,7 +206,7 @@ impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n \n impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WellFormed::*;\n+        use crate::traits::WellFormed::*;\n \n         match self {\n             Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n@@ -217,7 +217,7 @@ impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n \n impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::FromEnv::*;\n+        use crate::traits::FromEnv::*;\n \n         match self {\n             Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n@@ -228,7 +228,7 @@ impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n \n impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::DomainGoal::*;\n+        use crate::traits::DomainGoal::*;\n \n         match self {\n             Holds(wc) => write!(fmt, \"{}\", wc),\n@@ -246,7 +246,7 @@ impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n \n impl fmt::Display for traits::QuantifierKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::QuantifierKind::*;\n+        use crate::traits::QuantifierKind::*;\n \n         match self {\n             Universal => write!(fmt, \"forall\"),\n@@ -361,7 +361,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n \n impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::GoalKind::*;\n+        use crate::traits::GoalKind::*;\n \n         match self {\n             Implies(hypotheses, goal) => {\n@@ -420,7 +420,7 @@ impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n \n impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::Clause::*;\n+        use crate::traits::Clause::*;\n \n         match self {\n             Implies(clause) => write!(fmt, \"{}\", clause),"}, {"sha": "754cc94073b1067afdb3ae39ab20607e2948fe15", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,10 +1,10 @@\n-use hir;\n-use hir::def_id::DefId;\n-use traits::specialize::specialization_graph::NodeItem;\n-use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n-use ty::outlives::Component;\n-use ty::subst::{Kind, Subst, Substs};\n-use util::nodemap::FxHashSet;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::traits::specialize::specialization_graph::NodeItem;\n+use crate::ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n+use crate::ty::outlives::Component;\n+use crate::ty::subst::{Kind, Subst, Substs};\n+use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n@@ -525,9 +525,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n-        match self.hir().as_local_node_id(node_item_def_id) {\n-            Some(node_id) => {\n-                let item = self.hir().expect_item(node_id);\n+        match self.hir().as_local_hir_id(node_item_def_id) {\n+            Some(hir_id) => {\n+                let item = self.hir().expect_item_by_hir_id(hir_id);\n                 if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {"}, {"sha": "07fa441bb8076e3cce51f434ef33e1e98a2ce14a", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n-use ty::relate::{self, Relate, TypeRelation, RelateResult};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::ty::relate::{self, Relate, TypeRelation, RelateResult};\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is"}, {"sha": "ff4fc87542dc35862bad1656c12f8b55d292ed5f", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n-use hir;\n-use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n-use ty::subst::Substs;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::Substs;\n \n \n /// Represents coercing a value to a different type of value.\n@@ -15,7 +15,7 @@ use ty::subst::Substs;\n ///    Here the pointer will be dereferenced N times (where a dereference can\n ///    happen to raw or borrowed pointers or any smart pointer which implements\n ///    Deref, including Box<_>). The types of dereferences is given by\n-///    `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+///    `autoderefs`. It can then be auto-referenced zero or one times, indicated\n ///    by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n ///    `false`.\n ///\n@@ -38,7 +38,7 @@ use ty::subst::Substs;\n ///    stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n ///    the underlying conversions from `[i32; 4]` to `[i32]`.\n ///\n-/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case.  In\n+/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case. In\n ///    that case, we have the pointer we need coming in, so there are no\n ///    autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n ///    At some point, of course, `Box` should move out of the compiler, in which\n@@ -78,7 +78,7 @@ pub enum Adjust<'tcx> {\n     /// This will do things like convert thin pointers to fat\n     /// pointers, or convert structs containing thin pointers to\n     /// structs containing fat pointers, or convert between fat\n-    /// pointers.  We don't store the details of how the transform is\n+    /// pointers. We don't store the details of how the transform is\n     /// done (in fact, we don't know that, because it might depend on\n     /// the precise type parameters). We just store the target\n     /// type. Codegen backends and miri figure out what has to be done\n@@ -110,12 +110,12 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n }\n \n /// At least for initial deployment, we want to limit two-phase borrows to\n-/// only a few specific cases. Right now, those mostly \"things that desugar\"\n-/// into method calls\n-///     - using x.some_method() syntax, where some_method takes &mut self\n-///     - using Foo::some_method(&mut x, ...) syntax\n-///     - binary assignment operators (+=, -=, *=, etc.)\n-/// Anything else should be rejected until generalized two phase borrow support\n+/// only a few specific cases. Right now, those are mostly \"things that desugar\"\n+/// into method calls:\n+/// - using `x.some_method()` syntax, where some_method takes `&mut self`,\n+/// - using `Foo::some_method(&mut x, ...)` syntax,\n+/// - binary assignment operators (`+=`, `-=`, `*=`, etc.).\n+/// Anything else should be rejected until generalized two-phase borrow support\n /// is implemented. Right now, dataflow can't handle the general case where there\n /// is more than one use of a mutable borrow, and we don't want to accept too much\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n@@ -144,10 +144,10 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n-    /// Convert from T to &T.\n+    /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n \n-    /// Convert from T to *T.\n+    /// Converts from T to *T.\n     RawPtr(hir::Mutability),\n }\n "}, {"sha": "1290141b0a6b03314f3651a1dfd791bd12950845", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,6 +1,6 @@\n-use hir::BindingAnnotation::*;\n-use hir::BindingAnnotation;\n-use hir::Mutability;\n+use crate::hir::BindingAnnotation::*;\n+use crate::hir::BindingAnnotation;\n+use crate::hir::Mutability;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BindingMode {"}, {"sha": "0b2112f42d5955af0d6667bddada424807d6fbac", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,7 @@\n // Helpers for handling cast expressions, used in both\n // typeck and codegen.\n \n-use ty::{self, Ty};\n+use crate::ty::{self, Ty};\n \n use syntax::ast;\n "}, {"sha": "e93de32f7257b06168107c3f765d2c68d1b940af", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -6,15 +6,15 @@\n // The functionality in here is shared between persisting to crate metadata and\n // persisting to incr. comp. caches.\n \n-use hir::def_id::{DefId, CrateNum};\n-use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n+use crate::hir::def_id::{DefId, CrateNum};\n+use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n+use crate::rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n use std::intrinsics;\n-use ty::{self, Ty, TyCtxt};\n-use ty::subst::Substs;\n-use mir::interpret::Allocation;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::Substs;\n+use crate::mir::interpret::Allocation;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -252,7 +252,7 @@ pub fn decode_lazy_const<'a, 'tcx, D>(decoder: &mut D)\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n-    Ok(decoder.tcx().intern_lazy_const(Decodable::decode(decoder)?))\n+    Ok(decoder.tcx().mk_lazy_const(Decodable::decode(decoder)?))\n }\n \n #[inline]\n@@ -283,7 +283,7 @@ macro_rules! implement_ty_decoder {\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::Substs;\n             use $crate::hir::def_id::{CrateNum};\n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n+            use crate::rustc_serialize::{Decoder, SpecializedDecoder};\n             use std::borrow::Cow;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {"}, {"sha": "fff5dcf433ed9184e673e3904be9a86c069edc8d", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n-use ty::query::Providers;\n-use hir::def_id::DefId;\n-use hir;\n-use ty::TyCtxt;\n+use crate::ty::query::Providers;\n+use crate::hir::def_id::DefId;\n+use crate::hir;\n+use crate::ty::TyCtxt;\n use syntax_pos::symbol::Symbol;\n-use hir::map::blocks::FnLikeNode;\n+use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if this function must conform to `min_const_fn`\n+    /// Returns `true` if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n         // Bail out if the signature doesn't contain `const`\n         if !self.is_const_fn_raw(def_id) {"}, {"sha": "95287efd0acb0c288cb7e4f45e1d09cbe4112db2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,48 +1,48 @@\n-//! type context book-keeping\n-\n-use dep_graph::DepGraph;\n-use dep_graph::{DepNode, DepConstructor};\n-use errors::DiagnosticBuilder;\n-use session::Session;\n-use session::config::{BorrowckMode, OutputFilenames};\n-use session::config::CrateType;\n-use middle;\n-use hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n-use hir::def::{Def, Export};\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use hir::map as hir_map;\n-use hir::map::DefPathHash;\n-use lint::{self, Lint};\n-use ich::{StableHashingContext, NodeIdHashingMode};\n-use infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use infer::outlives::free_region_map::FreeRegionMap;\n-use middle::cstore::CrateStoreDyn;\n-use middle::cstore::EncodedMetadata;\n-use middle::lang_items;\n-use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n-use middle::stability;\n-use mir::{self, Mir, interpret, ProjectionKind};\n-use mir::interpret::Allocation;\n-use ty::subst::{Kind, Substs, Subst};\n-use ty::ReprOptions;\n-use traits;\n-use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n-use ty::{self, Ty, TypeAndMut};\n-use ty::{TyS, TyKind, List};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n-use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n-use ty::RegionKind;\n-use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n-use ty::TyKind::*;\n-use ty::GenericParamDefKind;\n-use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n-use ty::query;\n-use ty::steal::Steal;\n-use ty::subst::{UserSubsts, UnpackedKind};\n-use ty::{BoundVar, BindingMode};\n-use ty::CanonicalPolyFnSig;\n-use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n-use util::nodemap::{FxHashMap, FxHashSet};\n+//! Type context book-keeping.\n+\n+use crate::dep_graph::DepGraph;\n+use crate::dep_graph::{self, DepNode, DepConstructor};\n+use crate::errors::DiagnosticBuilder;\n+use crate::session::Session;\n+use crate::session::config::{BorrowckMode, OutputFilenames};\n+use crate::session::config::CrateType;\n+use crate::middle;\n+use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n+use crate::hir::def::{Def, Export};\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use crate::hir::map as hir_map;\n+use crate::hir::map::DefPathHash;\n+use crate::lint::{self, Lint};\n+use crate::ich::{StableHashingContext, NodeIdHashingMode};\n+use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n+use crate::infer::outlives::free_region_map::FreeRegionMap;\n+use crate::middle::cstore::CrateStoreDyn;\n+use crate::middle::cstore::EncodedMetadata;\n+use crate::middle::lang_items;\n+use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n+use crate::middle::stability;\n+use crate::mir::{self, Mir, interpret, ProjectionKind};\n+use crate::mir::interpret::Allocation;\n+use crate::ty::subst::{Kind, Substs, Subst};\n+use crate::ty::ReprOptions;\n+use crate::traits;\n+use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n+use crate::ty::{self, Ty, TypeAndMut};\n+use crate::ty::{TyS, TyKind, List};\n+use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n+use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n+use crate::ty::RegionKind;\n+use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n+use crate::ty::TyKind::*;\n+use crate::ty::GenericParamDefKind;\n+use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n+use crate::ty::query;\n+use crate::ty::steal::Steal;\n+use crate::ty::subst::{UserSubsts, UnpackedKind};\n+use crate::ty::{BoundVar, BindingMode};\n+use crate::ty::CanonicalPolyFnSig;\n+use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::interner::HashInterner;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n@@ -73,7 +73,7 @@ use syntax::feature_gate;\n use syntax::symbol::{Symbol, keywords, InternedString};\n use syntax_pos::Span;\n \n-use hir;\n+use crate::hir;\n \n pub struct AllArenas<'tcx> {\n     pub global: WorkerLocal<GlobalArenas<'tcx>>,\n@@ -127,6 +127,7 @@ pub struct CtxtInterners<'tcx> {\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n+    lazy_const: InternedSet<'tcx, LazyConst<'tcx>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -144,6 +145,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             goal: Default::default(),\n             goal_list: Default::default(),\n             projs: Default::default(),\n+            lazy_const: Default::default(),\n         }\n     }\n \n@@ -330,13 +332,13 @@ pub struct TypeckTables<'tcx> {\n     /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n     field_indices: ItemLocalMap<usize>,\n \n-    /// Stores the types for various nodes in the AST.  Note that this table\n-    /// is not guaranteed to be populated until after typeck.  See\n+    /// Stores the types for various nodes in the AST. Note that this table\n+    /// is not guaranteed to be populated until after typeck. See\n     /// typeck::check::fn_ctxt for details.\n     node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node.  This only applies to nodes that refer to entities\n+    /// of this node. This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n@@ -411,7 +413,7 @@ pub struct TypeckTables<'tcx> {\n     pub tainted_by_errors: bool,\n \n     /// Stores the free-region relationships that were deduced from\n-    /// its where clauses and parameter types. These are then\n+    /// its where-clauses and parameter types. These are then\n     /// read-again by borrowck.\n     pub free_region_map: FreeRegionMap<'tcx>,\n \n@@ -835,7 +837,7 @@ pub type CanonicalUserType<'gcx> = Canonical<'gcx, UserType<'gcx>>;\n \n impl CanonicalUserType<'gcx> {\n     /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n-    /// i.e. each thing is mapped to a canonical variable with the same index.\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n     pub fn is_identity(&self) -> bool {\n         match self.value {\n             UserType::Ty(_) => false,\n@@ -870,7 +872,7 @@ impl CanonicalUserType<'gcx> {\n     }\n }\n \n-/// A user-given type annotation attached to a constant.  These arise\n+/// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1051,7 +1053,7 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Get the global TyCtxt.\n+    /// Gets the global `TyCtxt`.\n     #[inline]\n     pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n         TyCtxt {\n@@ -1096,10 +1098,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n-    pub fn intern_const_alloc(\n-        self,\n-        alloc: Allocation,\n-    ) -> &'gcx Allocation {\n+    pub fn intern_const_alloc(self, alloc: Allocation) -> &'gcx Allocation {\n         self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n             self.global_arenas.const_allocs.alloc(alloc)\n         })\n@@ -1119,10 +1118,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn intern_lazy_const(self, c: ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        self.global_interners.arena.alloc(c)\n-    }\n-\n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n         self.layout_interner.borrow_mut().intern(layout, |layout| {\n             self.global_arenas.layout.alloc(layout)\n@@ -1158,12 +1153,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         value.lift_to_tcx(self.global_tcx())\n     }\n \n-    /// Returns true if self is the same as self.global_tcx().\n+    /// Returns `true` if self is the same as self.global_tcx().\n     fn is_global(self) -> bool {\n         ptr::eq(self.interners, &self.global_interners)\n     }\n \n-    /// Create a type context and call the closure with a `TyCtxt` reference\n+    /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n@@ -1358,7 +1353,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// Converts a `DefId` into its fully expanded `DefPath` (every\n     /// `DefId` is really just an interned def-path).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n@@ -1435,7 +1430,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.dep_graph.with_task(dep_node,\n                                      self,\n                                      crate_hash,\n-                                     |_, x| x // No transformation needed\n+                                     |_, x| x, // No transformation needed\n+                                     dep_graph::hash_result,\n             );\n         }\n     }\n@@ -1822,18 +1818,18 @@ pub mod tls {\n     use std::marker::PhantomData;\n     use std::ptr;\n     use syntax_pos;\n-    use ty::query;\n-    use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n+    use crate::ty::query;\n+    use crate::errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n     use rustc_data_structures::sync::{self, Lrc, Lock};\n     use rustc_data_structures::thin_vec::ThinVec;\n-    use dep_graph::TaskDeps;\n+    use crate::dep_graph::TaskDeps;\n \n     #[cfg(not(parallel_compiler))]\n     use std::cell::Cell;\n \n     #[cfg(parallel_compiler)]\n-    use rayon_core;\n+    use rustc_rayon_core as rayon_core;\n \n     /// This is the implicit state of rustc. It contains the current\n     /// TyCtxt and query. It is updated when creating a local interner or\n@@ -2114,8 +2110,8 @@ macro_rules! sty_debug_print {\n         // variable names.\n         #[allow(non_snake_case)]\n         mod inner {\n-            use ty::{self, TyCtxt};\n-            use ty::context::Interned;\n+            use crate::ty::{self, TyCtxt};\n+            use crate::ty::context::Interned;\n \n             #[derive(Copy, Clone)]\n             struct DebugStat {\n@@ -2271,6 +2267,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<GoalKind<'lcx>> for Interned<'tcx, GoalKind<'tcx>>\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<LazyConst<'lcx>> for Interned<'tcx, LazyConst<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a LazyConst<'lcx> {\n+        &self.0\n+    }\n+}\n+\n impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n     for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n@@ -2377,7 +2379,8 @@ pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n \n direct_interners!('tcx,\n     region: mk_region(|r: &RegionKind| r.keep_in_local_tcx()) -> RegionKind,\n-    goal: mk_goal(|c: &GoalKind<'_>| keep_local(c)) -> GoalKind<'tcx>\n+    goal: mk_goal(|c: &GoalKind<'_>| keep_local(c)) -> GoalKind<'tcx>,\n+    lazy_const: mk_lazy_const(|c: &LazyConst<'_>| keep_local(&c)) -> LazyConst<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -2562,7 +2565,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, self.intern_lazy_const(\n+        self.mk_ty(Array(ty, self.mk_lazy_const(\n             ty::LazyConst::Evaluated(ty::Const::from_usize(self.global_tcx(), n))\n         )))\n     }"}, {"sha": "0431afcc76c9e4250417d37cdc11b1e4fe32d5b1", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,5 +1,5 @@\n-use ty::{self, Ty, TyCtxt, TypeFlags};\n-use ty::fold::{TypeFolder, TypeFoldable};\n+use crate::ty::{self, Ty, TyCtxt, TypeFlags};\n+use crate::ty::fold::{TypeFolder, TypeFoldable};\n \n pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n     *providers = ty::query::Providers {"}, {"sha": "d0c9677ea6ecb8d3b845a042303b17c7908affbf", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,13 +1,13 @@\n-use hir::def_id::DefId;\n-use ty::{self, Region, Ty, TyCtxt};\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Region, Ty, TyCtxt};\n use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n-use errors::{Applicability, DiagnosticBuilder};\n+use crate::errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n-use hir;\n+use crate::hir;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct ExpectedFound<T> {"}, {"sha": "59ab4561f2c8778811f567b6118e6b566aeed585", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,12 +1,12 @@\n-use hir::def_id::DefId;\n-use ich::StableHashingContext;\n+use crate::hir::def_id::DefId;\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n use syntax::ast;\n-use ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt};\n \n use self::SimplifiedTypeGen::*;\n "}, {"sha": "25ec3e49cdf67361f2ccf2f56166f36a17632992", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,5 +1,5 @@\n-use ty::subst::Substs;\n-use ty::{self, Ty, TypeFlags, TypeFoldable};\n+use crate::ty::subst::Substs;\n+use crate::ty::{self, Ty, TypeFlags, TypeFoldable};\n \n #[derive(Debug)]\n pub struct FlagComputation {"}, {"sha": "aa4d1e5ea90cbf9609df79e989be33a606d481a9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 27, "deletions": 50, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,7 +4,7 @@\n //! instance of a \"folder\" (a type which implements `TypeFolder`). Then\n //! the setup is intended to be:\n //!\n-//!   T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)\n+//!     T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)\n //!\n //! This way, when you define a new folder F, you can override\n //! `fold_T()` to customize the behavior, and invoke `T.super_fold_with()`\n@@ -25,16 +25,18 @@\n //! proper thing.\n //!\n //! A `TypeFoldable` T can also be visited by a `TypeVisitor` V using similar setup:\n-//!   T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V).\n-//! These methods return true to indicate that the visitor has found what it is looking for\n-//! and does not need to visit anything else.\n+//!\n+//!     T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V).\n+//!\n+//! These methods return true to indicate that the visitor has found what it is\n+//! looking for, and does not need to visit anything else.\n \n-use hir::def_id::DefId;\n-use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::collections::BTreeMap;\n use std::fmt;\n-use util::nodemap::FxHashSet;\n+use crate::util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n@@ -52,15 +54,15 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.super_visit_with(visitor)\n     }\n \n-    /// True if `self` has any late-bound regions that are either\n+    /// Returns `true` if `self` has any late-bound regions that are either\n     /// bound by `binder` or bound by some binder outside of `binder`.\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n     /// there are any late-bound regions that appear free.\n     fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder })\n     }\n \n-    /// True if this `self` has any regions that escape `binder` (and\n+    /// Returns `true` if this `self` has any regions that escape `binder` (and\n     /// hence are not bound by it).\n     fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.has_vars_bound_at_or_above(binder.shifted_in(1))\n@@ -141,7 +143,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n }\n \n-/// The TypeFolder trait defines the actual *folding*. There is a\n+/// The `TypeFolder` trait defines the actual *folding*. There is a\n /// method defined for every foldable type. Each of these has a\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n@@ -262,7 +264,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    /// True if `callback` returns true for every region appearing free in `value`.\n+    /// Returns `true` if `callback` returns true for every region appearing free in `value`.\n     pub fn all_free_regions_meet(\n         self,\n         value: &impl TypeFoldable<'tcx>,\n@@ -271,7 +273,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         !self.any_free_region_meets(value, |r| !callback(r))\n     }\n \n-    /// True if `callback` returns true for some region appearing free in `value`.\n+    /// Returns `true` if `callback` returns true for some region appearing free in `value`.\n     pub fn any_free_region_meets(\n         self,\n         value: &impl TypeFoldable<'tcx>,\n@@ -292,8 +294,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             /// ^          ^          ^     ^\n             /// |          |          |     | here, would be shifted in 1\n             /// |          |          | here, would be shifted in 2\n-            /// |          | here, would be INNERMOST shifted in by 1\n-            /// | here, initially, binder would be INNERMOST\n+            /// |          | here, would be `INNERMOST` shifted in by 1\n+            /// | here, initially, binder would be `INNERMOST`\n             /// ```\n             ///\n             /// You see that, initially, *any* bound value is free,\n@@ -496,12 +498,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all regions bound by the given `Binder` with the\n+    /// Replaces all regions bound by the given `Binder` with the\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n     /// binder is removed in the return type. The closure is invoked\n     /// once for each unique `BoundRegion`; multiple references to the\n-    /// same `BoundRegion` will reuse the previous result.  A map is\n+    /// same `BoundRegion` will reuse the previous result. A map is\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n     ///\n@@ -520,7 +522,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n-    /// Replace all escaping bound vars. The `fld_r` closure replaces escaping\n+    /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n     /// bound regions while the `fld_t` closure replaces escaping bound types.\n     pub fn replace_escaping_bound_vars<T, F, G>(\n         self,\n@@ -554,7 +556,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Replace all types or regions bound by the given `Binder`. The `fld_r`\n+    /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n     /// closure replaces bound regions while the `fld_t` closure replaces bound\n     /// types.\n     pub fn replace_bound_vars<T, F, G>(\n@@ -570,7 +572,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n-    /// Replace any late-bound regions bound in `value` with\n+    /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     pub fn liberate_late_bound_regions<T>(\n         &self,\n@@ -586,31 +588,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }).0\n     }\n \n-    /// Flattens multiple binding levels into one. So `for<'a> for<'b> Foo`\n-    /// becomes `for<'a,'b> Foo`.\n-    pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n-                                         -> Binder<T>\n-        where T: TypeFoldable<'tcx>\n-    {\n-        let bound0_value = bound2_value.skip_binder().skip_binder();\n-        let value = self.fold_regions(bound0_value, &mut false, |region, current_depth| {\n-            match *region {\n-                ty::ReLateBound(debruijn, br) => {\n-                    // We assume no regions bound *outside* of the\n-                    // binders in `bound2_value` (nmatsakis added in\n-                    // the course of this PR; seems like a reasonable\n-                    // sanity check though).\n-                    assert!(debruijn == current_depth);\n-                    self.mk_region(ty::ReLateBound(current_depth, br))\n-                }\n-                _ => {\n-                    region\n-                }\n-            }\n-        });\n-        Binder::bind(value)\n-    }\n-\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those\n@@ -640,21 +617,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         collector.regions\n     }\n \n-    /// Replace any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n+    /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |_| self.types.re_erased).0\n     }\n \n-    /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+    /// Rewrite any late-bound regions so that they are anonymous. Region numbers are\n     /// assigned starting at 1 and increasing monotonically in the order traversed\n     /// by the fold operation.\n     ///\n     /// The chief purpose of this function is to canonicalize regions so that two\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n-    /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+    /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n     pub fn anonymize_late_bound_regions<T>(self, sig: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>,\n@@ -818,7 +795,7 @@ pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n /// scope to which it is attached, etc. An escaping var represents\n /// a bound var for which this processing has not yet been done.\n struct HasEscapingVarsVisitor {\n-    /// Anything bound by `outer_index` or \"above\" is escaping\n+    /// Anything bound by `outer_index` or \"above\" is escaping.\n     outer_index: ty::DebruijnIndex,\n }\n \n@@ -881,10 +858,10 @@ struct LateBoundRegionsCollector {\n     current_index: ty::DebruijnIndex,\n     regions: FxHashSet<ty::BoundRegion>,\n \n-    /// If true, we only want regions that are known to be\n+    /// `true` if we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n     /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n-    /// them constraints `'a == 'b`.  But if you have `<&'a u32 as\n+    /// them constraints `'a == 'b`. But if you have `<&'a u32 as\n     /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n     /// types may mean that `'a` and `'b` don't appear in the results,\n     /// so they are not considered *constrained*."}, {"sha": "3b393c3ca15bb2374250a9bf70f8bf7fa0d113e0", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n use std::mem;\n use smallvec::SmallVec;\n use syntax::ast::CRATE_NODE_ID;\n-use ty::context::TyCtxt;\n-use ty::{DefId, DefIdTree};\n+use crate::ty::context::TyCtxt;\n+use crate::ty::{DefId, DefIdTree};\n \n /// Represents a forest of DefIds closed under the ancestor relation. That is,\n /// if a DefId representing a module is contained in the forest then all\n@@ -22,22 +22,22 @@ pub struct DefIdForest {\n }\n \n impl<'a, 'gcx, 'tcx> DefIdForest {\n-    /// Create an empty forest.\n+    /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n         DefIdForest {\n             root_ids: SmallVec::new(),\n         }\n     }\n \n-    /// Create a forest consisting of a single tree representing the entire\n+    /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n \n-    /// Create a forest containing a DefId and all its descendants.\n+    /// Creates a forest containing a DefId and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);\n@@ -46,12 +46,12 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         }\n     }\n \n-    /// Test whether the forest is empty.\n+    /// Tests whether the forest is empty.\n     pub fn is_empty(&self) -> bool {\n         self.root_ids.is_empty()\n     }\n \n-    /// Test whether the forest contains a given DefId.\n+    /// Tests whether the forest contains a given DefId.\n     pub fn contains(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool"}, {"sha": "601ffe70eec18ce07a711c7bdac02e560a3f623b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,8 +1,8 @@\n-use ty::context::TyCtxt;\n-use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n-use ty::{self, DefId, Substs};\n-use ty::{AdtKind, Visibility};\n-use ty::TyKind::*;\n+use crate::ty::context::TyCtxt;\n+use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n+use crate::ty::{self, DefId, Substs};\n+use crate::ty::{AdtKind, Visibility};\n+use crate::ty::TyKind::*;\n \n pub use self::def_id_forest::DefIdForest;\n "}, {"sha": "5fc22e3c02b60cf5502d82529e6ed784c17e2c9c", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,9 +1,9 @@\n-use hir::Unsafety;\n-use hir::def_id::DefId;\n-use ty::{self, Ty, PolyFnSig, TypeFoldable, Substs, TyCtxt};\n-use traits;\n+use crate::hir::Unsafety;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, Substs, TyCtxt};\n+use crate::traits;\n use rustc_target::spec::abi::Abi;\n-use util::ppaux;\n+use crate::util::ppaux;\n \n use std::fmt;\n use std::iter;\n@@ -22,17 +22,17 @@ pub enum InstanceDef<'tcx> {\n     /// `<T as Trait>::method` where `method` receives unsizeable `self: Self`.\n     VtableShim(DefId),\n \n-    /// \\<fn() as FnTrait>::call_*\n-    /// def-id is FnTrait::call_*\n+    /// `<fn() as FnTrait>::call_*`\n+    /// `DefId` is `FnTrait::call_*`\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// <Trait as Trait>::fn\n+    /// `<Trait as Trait>::fn`\n     Virtual(DefId, usize),\n \n-    /// <[mut closure] as FnOnce>::call_once\n+    /// `<[mut closure] as FnOnce>::call_once`\n     ClosureOnceShim { call_once: DefId },\n \n-    /// drop_in_place::<T>; None for empty drop glue.\n+    /// `drop_in_place::<T>; None` for empty drop glue.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     ///`<T as Clone>::clone` shim.\n@@ -141,7 +141,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>\n     ) -> bool {\n-        use hir::map::DefPathData;\n+        use crate::hir::map::DefPathData;\n         let def_id = match *self {\n             ty::InstanceDef::Item(def_id) => def_id,\n             ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n@@ -220,7 +220,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         self.def.def_id()\n     }\n \n-    /// Resolve a (def_id, substs) pair to an (optional) instance -- most commonly,\n+    /// Resolves a `(def_id, substs)` pair to an (optional) instance -- most commonly,\n     /// this is used to find the precise code that will run for a trait method invocation,\n     /// if known.\n     ///"}, {"sha": "5dc31caf295af34beebadc38236ad403d2c11cd8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,7 +1,8 @@\n-use hir::map::DefPathData;\n-use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use ty::{self, DefIdTree, Ty, TyCtxt};\n-use middle::cstore::{ExternCrate, ExternCrateSource};\n+use crate::hir;\n+use crate::hir::map::DefPathData;\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, LocalInternedString, Symbol};\n \n@@ -42,7 +43,7 @@ pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n-/// Add the `crate::` prefix to paths where appropriate.\n+/// Adds the `crate::` prefix to paths where appropriate.\n pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n         let old = flag.get();\n@@ -54,7 +55,7 @@ pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns a string identifying this def-id. This string is\n+    /// Returns a string identifying this `DefId`. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root, unless with_forced_absolute_paths was used.\n     pub fn item_path_str(self, def_id: DefId) -> String {\n@@ -76,6 +77,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.item_path_str(self.hir().local_def_id(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_path_str(self, id: hir::HirId) -> String {\n+        self.item_path_str(self.hir().local_def_id_from_hir_id(id))\n+    }\n+\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n@@ -319,6 +325,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::Module(..) |\n             data @ DefPathData::TypeParam(..) |\n             data @ DefPathData::LifetimeParam(..) |\n+            data @ DefPathData::ConstParam(..) |\n             data @ DefPathData::EnumVariant(..) |\n             data @ DefPathData::Field(..) |\n             data @ DefPathData::AnonConst |\n@@ -455,13 +462,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n         self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-        let node_id = self.hir().as_local_node_id(impl_def_id).unwrap();\n-        let item = self.hir().expect_item(node_id);\n+        let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n+        let item = self.hir().expect_item_by_hir_id(hir_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }\n \n-    /// Returns the def-id of `def_id`'s parent in the def tree. If\n+    /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n     pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n@@ -471,9 +478,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n /// As a heuristic, when we see an impl, if we see that the\n-/// 'self-type' is a type defined in the same module as the impl,\n+/// 'self type' is a type defined in the same module as the impl,\n /// we can omit including the path to the impl itself. This\n-/// function tries to find a \"characteristic def-id\" for a\n+/// function tries to find a \"characteristic `DefId`\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n@@ -528,7 +535,7 @@ pub trait ItemPathBuffer {\n \n #[derive(Debug)]\n pub enum RootMode {\n-    /// Try to make a path relative to the local crate.  In\n+    /// Try to make a path relative to the local crate. In\n     /// particular, local paths have no prefix, and if the path comes\n     /// from an extern crate, start with the path to the `extern\n     /// crate` declaration."}, {"sha": "6c507c0015d7bcaa19e51ccc260b2bdc310a9e0e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,5 +1,5 @@\n-use session::{self, DataTypeKind};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n+use crate::session::{self, DataTypeKind};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n use syntax::ast::{self, Ident, IntTy, UintTy};\n use syntax::attr;\n@@ -12,7 +12,7 @@ use std::iter;\n use std::mem;\n use std::ops::Bound;\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -46,7 +46,7 @@ impl IntegerExt for Integer {\n         }\n     }\n \n-    /// Get the Integer type from an attr::IntType.\n+    /// Gets the Integer type from an attr::IntType.\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer {\n         let dl = cx.data_layout();\n \n@@ -62,7 +62,7 @@ impl IntegerExt for Integer {\n         }\n     }\n \n-    /// Find the appropriate Integer type and signedness for the given\n+    /// Finds the appropriate Integer type and signedness for the given\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n@@ -1686,7 +1686,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                             tcx.types.re_static,\n                             tcx.mk_array(tcx.types.usize, 3),\n                         )\n-                        /* FIXME use actual fn pointers\n+                        /* FIXME: use actual fn pointers\n                         Warning: naively computing the number of entries in the\n                         vtable by counting the methods on the trait + methods on\n                         all parent traits does not work, because some methods can\n@@ -1872,7 +1872,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::layout::Variants::*;\n+        use crate::ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n@@ -1908,7 +1908,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::layout::FieldPlacement::*;\n+        use crate::ty::layout::FieldPlacement::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n@@ -1941,7 +1941,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::layout::Abi::*;\n+        use crate::ty::layout::Abi::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n@@ -1975,29 +1975,29 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     }\n }\n \n-impl_stable_hash_for!(struct ::ty::layout::LayoutDetails {\n+impl_stable_hash_for!(struct crate::ty::layout::LayoutDetails {\n     variants,\n     fields,\n     abi,\n     size,\n     align\n });\n \n-impl_stable_hash_for!(enum ::ty::layout::Integer {\n+impl_stable_hash_for!(enum crate::ty::layout::Integer {\n     I8,\n     I16,\n     I32,\n     I64,\n     I128\n });\n \n-impl_stable_hash_for!(enum ::ty::layout::Primitive {\n+impl_stable_hash_for!(enum crate::ty::layout::Primitive {\n     Int(integer, signed),\n     Float(fty),\n     Pointer\n });\n \n-impl_stable_hash_for!(struct ::ty::layout::AbiAndPrefAlign {\n+impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n     abi,\n     pref\n });\n@@ -2023,7 +2023,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::layout::LayoutError::*;\n+        use crate::ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {"}, {"sha": "70f72acad1fb68be2cc00cf62da3aec4bb53ff3c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -4,31 +4,31 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n-use hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n-use hir::Node;\n-use hir::def::{Def, CtorKind, ExportMap};\n-use hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use hir::map::DefPathData;\n+use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n+use crate::hir::Node;\n+use crate::hir::def::{Def, CtorKind, ExportMap};\n+use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::hir::map::DefPathData;\n use rustc_data_structures::svh::Svh;\n-use ich::Fingerprint;\n-use ich::StableHashingContext;\n-use infer::canonical::Canonical;\n-use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n-use middle::resolve_lifetime::ObjectLifetimeDefault;\n-use mir::Mir;\n-use mir::interpret::{GlobalId, ErrorHandled};\n-use mir::GeneratorLayout;\n-use session::CrateDisambiguator;\n-use traits::{self, Reveal};\n-use ty;\n-use ty::layout::VariantIdx;\n-use ty::subst::{Subst, Substs};\n-use ty::util::{IntTypeExt, Discr};\n-use ty::walk::TypeWalker;\n-use util::captures::Captures;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use crate::ich::Fingerprint;\n+use crate::ich::StableHashingContext;\n+use crate::infer::canonical::Canonical;\n+use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n+use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use crate::mir::Mir;\n+use crate::mir::interpret::{GlobalId, ErrorHandled};\n+use crate::mir::GeneratorLayout;\n+use crate::session::CrateDisambiguator;\n+use crate::traits::{self, Reveal};\n+use crate::ty;\n+use crate::ty::layout::VariantIdx;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::util::{IntTypeExt, Discr};\n+use crate::ty::walk::TypeWalker;\n+use crate::util::captures::Captures;\n+use crate::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n use arena::SyncDroplessArena;\n-use session::DataTypeKind;\n+use crate::session::DataTypeKind;\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n@@ -50,7 +50,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n \n-use hir;\n+use crate::hir;\n \n pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n pub use self::sty::{FnSig, GenSig, CanonicalPolyFnSig, PolyFnSig, PolyGenSig};\n@@ -135,8 +135,8 @@ pub enum AssociatedItemContainer {\n }\n \n impl AssociatedItemContainer {\n-    /// Asserts that this is the def-id of an associated item declared\n-    /// in a trait, and returns the trait def-id.\n+    /// Asserts that this is the `DefId` of an associated item declared\n+    /// in a trait, and returns the trait `DefId`.\n     pub fn assert_trait(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -154,7 +154,7 @@ impl AssociatedItemContainer {\n \n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n-/// bounds/where clauses).\n+/// bounds / where-clauses).\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ImplHeader<'tcx> {\n     pub impl_def_id: DefId,\n@@ -328,7 +328,7 @@ pub enum Variance {\n /// item.\n pub struct CrateVariancesMap {\n     /// For each item with generics, maps to a vector of the variance\n-    /// of its generics.  If an item has no generics, it will have no\n+    /// of its generics. If an item has no generics, it will have no\n     /// entry.\n     pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n \n@@ -338,7 +338,7 @@ pub struct CrateVariancesMap {\n \n impl Variance {\n     /// `a.xform(b)` combines the variance of a context with the\n-    /// variance of a type with the following meaning.  If we are in a\n+    /// variance of a type with the following meaning. If we are in a\n     /// context with variance `a`, and we encounter a type argument in\n     /// a position with variance `b`, then `a.xform(b)` is the new\n     /// variance with which the argument appears.\n@@ -362,10 +362,10 @@ impl Variance {\n     /// The ambient variance is covariant. A `fn` type is\n     /// contravariant with respect to its parameters, so the variance\n     /// within which both pointer types appear is\n-    /// `Covariant.xform(Contravariant)`, or `Contravariant`.  `*const\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n     /// T` is covariant with respect to `T`, so the variance within\n     /// which the first `Vec<i32>` appears is\n-    /// `Contravariant.xform(Covariant)` or `Contravariant`.  The same\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n     /// is true for its `i32` argument. In the `*mut T` case, the\n     /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n     /// and hence the outermost type is `Invariant` with respect to\n@@ -489,12 +489,12 @@ pub struct TyS<'tcx> {\n     /// So, for a type without any late-bound things, like `u32`, this\n     /// will be *innermost*, because that is the innermost binder that\n     /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with debruijn index `D`, this would be `D + 1`\n+    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n     /// -- the binder itself does not capture `D`, but `D` is captured\n     /// by an inner binder.\n     ///\n     /// We call this concept an \"exclusive\" binder `D` because all\n-    /// debruijn indices within the type are contained within `0..D`\n+    /// De Bruijn indices within the type are contained within `0..D`\n     /// (exclusive).\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n@@ -720,9 +720,9 @@ pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n-/// Upvars do not get their own node-id. Instead, we use the pair of\n-/// the original var id (that is, the root variable that is referenced\n-/// by the upvar) and the id of the closure expression.\n+/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n+/// the original var ID (that is, the root variable that is referenced\n+/// by the upvar) and the ID of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n@@ -734,7 +734,7 @@ pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n \n-    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// Data must be immutable but not aliasable. This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n@@ -1096,7 +1096,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n-    /// substitution in terms of what happens with bound regions.  See\n+    /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n     pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n@@ -1235,7 +1235,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n-/// 1. `T: TraitRef<..., Item=Type>`\n+/// 1. `T: TraitRef<..., Item = Type>`\n /// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n ///\n /// In particular, form #1 is \"desugared\" to the combination of a\n@@ -1456,8 +1456,8 @@ impl<'tcx> Predicate<'tcx> {\n }\n \n /// Represents the bounds declared on a particular set of type\n-/// parameters.  Should eventually be generalized into a flag list of\n-/// where clauses.  You can obtain a `InstantiatedPredicates` list from a\n+/// parameters. Should eventually be generalized into a flag list of\n+/// where-clauses. You can obtain a `InstantiatedPredicates` list from a\n /// `GenericPredicates` by using the `instantiate` method. Note that this method\n /// reflects an important semantic invariant of `InstantiatedPredicates`: while\n /// the `GenericPredicates` are expressed in terms of the bound type\n@@ -1471,7 +1471,7 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n-/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+/// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n #[derive(Clone)]\n@@ -1537,7 +1537,7 @@ impl UniverseIndex {\n \n     /// Returns the \"next\" universe index in order -- this new index\n     /// is considered to extend all previous universes. This\n-    /// corresponds to entering a `forall` quantifier.  So, for\n+    /// corresponds to entering a `forall` quantifier. So, for\n     /// example, suppose we have this type in universe `U`:\n     ///\n     /// ```\n@@ -1619,20 +1619,20 @@ pub struct ParamEnv<'tcx> {\n \n impl<'tcx> ParamEnv<'tcx> {\n     /// Construct a trait environment suitable for contexts where\n-    /// there are no where clauses in scope. Hidden types (like `impl\n+    /// there are no where-clauses in scope. Hidden types (like `impl\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     #[inline]\n     pub fn empty() -> Self {\n         Self::new(List::empty(), Reveal::UserFacing, None)\n     }\n \n-    /// Construct a trait environment with no where clauses in scope\n+    /// Construct a trait environment with no where-clauses in scope\n     /// where the values of all `impl Trait` and other hidden types\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B., if you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     #[inline]\n     pub fn reveal_all() -> Self {\n@@ -1651,7 +1651,7 @@ impl<'tcx> ParamEnv<'tcx> {\n \n     /// Returns a new parameter environment with the same clauses, but\n     /// which \"reveals\" the true results of projections in all cases\n-    /// (even for associated types that are specializable).  This is\n+    /// (even for associated types that are specializable). This is\n     /// the desired behavior during codegen and certain other special\n     /// contexts; normally though we want to use `Reveal::UserFacing`,\n     /// which is the default.\n@@ -1736,7 +1736,7 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n \n #[derive(Copy, Clone, Debug)]\n pub struct Destructor {\n-    /// The def-id of the destructor method\n+    /// The `DefId` of the destructor method\n     pub did: DefId,\n }\n \n@@ -1781,20 +1781,21 @@ pub struct VariantDef {\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n-    /// Create a new `VariantDef`.\n+    /// Creates a new `VariantDef`.\n     ///\n-    /// - `did` is the DefId used for the variant - for tuple-structs, it is the constructor DefId,\n-    /// and for everything else, it is the variant DefId.\n+    /// - `did` is the `DefId` used for the variant.\n+    /// This is the constructor `DefId` for tuple stucts, and the variant `DefId` for everything\n+    /// else.\n     /// - `attribute_def_id` is the DefId that has the variant's attributes.\n-    /// this is the struct DefId for structs, and the variant DefId for variants.\n+    /// This is the struct `DefId` for structs, and the variant `DefId` for variants.\n     ///\n-    /// Note that we *could* use the constructor DefId, because the constructor attributes\n+    /// Note that we *could* use the constructor `DefId`, because the constructor attributes\n     /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the AdtDefs for all the structs in the universe (e.g., coherence for any\n+    /// loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n-    /// remove this hack and use the constructor DefId everywhere.\n+    /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                did: DefId,\n                ident: Ident,\n@@ -2049,13 +2050,13 @@ impl ReprOptions {\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n-    /// optimizations, such as with repr(C), repr(packed(1)), or repr(<int>).\n+    /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n             self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n+    /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n     pub fn inhibit_union_abi_opt(&self) -> bool {\n         self.c()\n     }\n@@ -2170,14 +2171,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.contains(AdtFlags::HAS_CTOR)\n     }\n \n-    /// Returns whether this type is `#[fundamental]` for the purposes\n+    /// Returns `true` if this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns `true` if this is PhantomData<T>.\n+    /// Returns `true` if this is `PhantomData<T>`.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n@@ -2199,7 +2200,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n-    /// Returns whether this type has a destructor.\n+    /// Returns `true` if this type has a destructor.\n     pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n@@ -2277,7 +2278,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     })\n                 } else {\n                     info!(\"invalid enum discriminant: {:#?}\", val);\n-                    ::mir::interpret::struct_error(\n+                    crate::mir::interpret::struct_error(\n                         tcx.at(tcx.def_span(expr_did)),\n                         \"constant evaluation of enum discriminant resulted in non-integer\",\n                     ).emit();\n@@ -2320,7 +2321,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n-    /// Compute the discriminant value used by a specific variant.\n+    /// Computes the discriminant value used by a specific variant.\n     /// Unlike `discriminants`, this is (amortized) constant-time,\n     /// only doing at most one query for evaluating an explicit\n     /// discriminant (the last one before the requested variant),\n@@ -2336,9 +2337,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         explicit_value.checked_add(tcx, offset as u128).0\n     }\n \n-    /// Yields a DefId for the discriminant and an offset to add to it\n+    /// Yields a `DefId` for the discriminant and an offset to add to it\n     /// Alternatively, if there is no explicit discriminant, returns the\n-    /// inferred discriminant directly\n+    /// inferred discriminant directly.\n     pub fn discriminant_def_for_variant(\n         &self,\n         variant_index: VariantIdx,\n@@ -2368,15 +2369,15 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns a list of types such that `Self: Sized` if and only\n-    /// if that type is Sized, or `TyErr` if this type is recursive.\n+    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n     ///\n-    /// Oddly enough, checking that the sized-constraint is Sized is\n+    /// Oddly enough, checking that the sized-constraint is `Sized` is\n     /// actually more expressive than checking all members:\n-    /// the Sized trait is inductive, so an associated type that references\n-    /// Self would prevent its containing ADT from being Sized.\n+    /// the `Sized` trait is inductive, so an associated type that references\n+    /// `Self` would prevent its containing ADT from being `Sized`.\n     ///\n     /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer, e.g., issue #31299.\n+    /// the associated type is behind a pointer (e.g., issue #31299).\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match tcx.try_adt_sized_constraint(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n@@ -2480,7 +2481,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n-/// Represents the various closure traits in the Rust language. This\n+/// Represents the various closure traits in the language. This\n /// will determine the type of the environment (`self`, in the\n /// desugaring) argument that the closure expects.\n ///\n@@ -2552,15 +2553,15 @@ impl<'tcx> TyS<'tcx> {\n         TypeWalker::new(self)\n     }\n \n-    /// Iterator that walks the immediate children of `self`.  Hence\n+    /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n     pub fn walk_shallow(&'tcx self) -> smallvec::IntoIter<walk::TypeWalkerArray<'tcx>> {\n         walk::walk_shallow(self)\n     }\n \n     /// Walks `ty` and any types appearing within `ty`, invoking the\n-    /// callback `f` on each type. If the callback returns false, then the\n+    /// callback `f` on each type. If the callback returns `false`, then the\n     /// children of the current type are ignored.\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n@@ -2670,7 +2671,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n-    /// Returns an iterator of the def-ids for all body-owners in this\n+    /// Returns an iterator of the `DefId`s for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(\n@@ -2917,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n+    /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n                         -> &'gcx Mir<'gcx>\n     {\n@@ -2937,16 +2938,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Get the attributes of a definition.\n+    /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n-        if let Some(id) = self.hir().as_local_node_id(did) {\n-            Attributes::Borrowed(self.hir().attrs(id))\n+        if let Some(id) = self.hir().as_local_hir_id(did) {\n+            Attributes::Borrowed(self.hir().attrs_by_hir_id(id))\n         } else {\n             Attributes::Owned(self.item_attrs(did))\n         }\n     }\n \n-    /// Determine whether an item is annotated with an attribute.\n+    /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n@@ -2960,14 +2961,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n     }\n \n-    /// Given the def-id of an impl, return the def_id of the trait it implements.\n-    /// If it implements no trait, return `None`.\n+    /// Given the `DefId` of an impl, returns the `DefId` of the trait it implements.\n+    /// If it implements no trait, returns `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n-    /// If the given defid describes a method belonging to an impl, return the\n-    /// def-id of the impl that the method belongs to. Otherwise, return `None`.\n+    /// If the given defid describes a method belonging to an impl, returns the\n+    /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n             if let Some(Def::Method(_)) = self.describe_def(def_id) {\n@@ -2991,16 +2992,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n-            let node_id = self.hir().as_local_node_id(impl_did).unwrap();\n-            Ok(self.hir().span(node_id))\n+            let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n+            Ok(self.hir().span_by_hir_id(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n     }\n \n-    // Hygienically compare a use-site name (`use_name`) for a field or an associated item with its\n-    // supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n-    // definition's parent/scope to perform comparison.\n+    /// Hygienically compares a use-site name (`use_name`) for a field or an associated item with\n+    /// its supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n+    /// definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n         self.adjust_ident(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.modern()\n     }\n@@ -3082,7 +3083,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n               parent_item.node)\n }\n \n-/// Calculates the Sized-constraint.\n+/// Calculates the `Sized` constraint.\n ///\n /// In fact, there are only a few options for the types in the constraint:\n ///     - an obviously-unsized type\n@@ -3110,8 +3111,8 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Lrc<Vec<DefId>> {\n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item(id);\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item_by_hir_id(id);\n     let vec: Vec<_> = match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n@@ -3135,9 +3136,9 @@ fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n-/// If the given def ID describes an item belonging to a trait,\n-/// return the ID of the trait that the trait item belongs to.\n-/// Otherwise, return `None`.\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n@@ -3232,10 +3233,9 @@ fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// If `def_id` is an issue 33140 hack impl, return its self type. Otherwise\n-/// return None.\n+/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n-/// See ImplOverlapKind::Issue33140 for more details.\n+/// See [`ImplOverlapKind::Issue33140`] for more details.\n fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> Option<Ty<'tcx>>"}, {"sha": "5b21ed5abd77b0b425045fb1e308158324be12a8", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -3,7 +3,7 @@\n // RFC for reference.\n \n use smallvec::SmallVec;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {"}, {"sha": "a3ee92f8e126361debf5c7e40cd2f5a6b77a544d", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,27 +1,27 @@\n-use dep_graph::SerializedDepNodeIndex;\n-use dep_graph::DepNode;\n-use hir::def_id::{CrateNum, DefId, DefIndex};\n-use mir::interpret::GlobalId;\n-use traits;\n-use traits::query::{\n+use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::dep_graph::DepNode;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n+use crate::mir::interpret::GlobalId;\n+use crate::traits;\n+use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n-use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use ty::subst::Substs;\n-use ty::query::queries;\n-use ty::query::Query;\n-use ty::query::QueryCache;\n-use util::profiling::ProfileCategory;\n+use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::subst::Substs;\n+use crate::ty::query::queries;\n+use crate::ty::query::Query;\n+use crate::ty::query::QueryCache;\n+use crate::util::profiling::ProfileCategory;\n \n use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::stable_hasher::HashStable;\n-use ich::StableHashingContext;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use crate::ich::StableHashingContext;\n \n // Query configuration and description traits.\n \n@@ -30,7 +30,7 @@ pub trait QueryConfig<'tcx> {\n     const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;\n+    type Value: Clone;\n }\n \n pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n@@ -44,6 +44,11 @@ pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n \n+    fn hash_result(\n+        hcx: &mut StableHashingContext<'_>,\n+        result: &Self::Value\n+    ) -> Option<Fingerprint>;\n+\n     fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value;\n }\n \n@@ -901,7 +906,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: SerializedDepNodeIndex)\n                               -> Option<Self::Value> {\n-        let mir: Option<::mir::Mir<'tcx>> = tcx.queries.on_disk_cache\n+        let mir: Option<crate::mir::Mir<'tcx>> = tcx.queries.on_disk_cache\n                                                .try_load_query_result(tcx, id);\n         mir.map(|x| tcx.alloc_mir(x))\n     }"}, {"sha": "16b4af535943bb8d3e76003609ac207a418bc7ef", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,25 +1,27 @@\n #![allow(warnings)]\n \n use std::mem;\n+use std::process;\n+use std::{fmt, ptr};\n+\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, Weak};\n use rustc_data_structures::OnDrop;\n use syntax_pos::Span;\n-use ty::tls;\n-use ty::query::Query;\n-use ty::query::plumbing::CycleError;\n+\n+use crate::ty::tls;\n+use crate::ty::query::Query;\n+use crate::ty::query::plumbing::CycleError;\n #[cfg(not(parallel_compiler))]\n-use ty::query::{\n+use crate::ty::query::{\n     plumbing::TryGetJob,\n     config::QueryDescription,\n };\n-use ty::context::TyCtxt;\n-use std::process;\n-use std::{fmt, ptr};\n+use crate::ty::context::TyCtxt;\n \n #[cfg(parallel_compiler)]\n use {\n-    rayon_core,\n+    rustc_rayon_core as rayon_core,\n     parking_lot::{Mutex, Condvar},\n     std::sync::atomic::Ordering,\n     std::thread,\n@@ -29,37 +31,38 @@ use {\n     rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher, HashStable},\n };\n \n-/// Indicates the state of a query for a given key in a query map\n+/// Indicates the state of a query for a given key in a query map.\n pub(super) enum QueryResult<'tcx> {\n-    /// An already executing query. The query job can be used to await for its completion\n+    /// An already executing query. The query job can be used to await for its completion.\n     Started(Lrc<QueryJob<'tcx>>),\n \n-    /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n+    /// The query panicked. Queries trying to wait on this will raise a fatal error or\n+    /// silently panic.\n     Poisoned,\n }\n \n-/// A span and a query key\n+/// Represents a span and a query key.\n #[derive(Clone, Debug)]\n pub struct QueryInfo<'tcx> {\n-    /// The span for a reason this query was required\n+    /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n     pub query: Query<'tcx>,\n }\n \n-/// A object representing an active query job.\n+/// Representss an object representing an active query job.\n pub struct QueryJob<'tcx> {\n     pub info: QueryInfo<'tcx>,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n \n-    /// The latch which is used to wait on this job\n+    /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n     latch: QueryLatch<'tcx>,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n-    /// Creates a new query job\n+    /// Creates a new query job.\n     pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n         QueryJob {\n             info,\n@@ -89,7 +92,7 @@ impl<'tcx> QueryJob<'tcx> {\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n     #[cfg(parallel_compiler)]\n-    pub(super) fn await<'lcx>(\n+    pub(super) fn r#await<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n@@ -101,7 +104,7 @@ impl<'tcx> QueryJob<'tcx> {\n                 cycle: Lock::new(None),\n                 condvar: Condvar::new(),\n             });\n-            self.latch.await(&waiter);\n+            self.latch.r#await(&waiter);\n             // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n             // although another thread may still have a Lrc reference so we cannot\n             // use Lrc::get_mut\n@@ -200,7 +203,7 @@ impl<'tcx> QueryLatch<'tcx> {\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn await(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n+    fn r#await(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -228,7 +231,7 @@ impl<'tcx> QueryLatch<'tcx> {\n         }\n     }\n \n-    /// Remove a single waiter from the list of waiters.\n+    /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n     fn extract_waiter(\n         &self,"}, {"sha": "f5eb7374cc19b445739a3b7f5d23bba044eeb49e", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,12 +1,12 @@\n //! Defines the set of legal keys that can be used in queries.\n \n-use infer::canonical::Canonical;\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use traits;\n-use ty::{self, Ty, TyCtxt};\n-use ty::subst::Substs;\n-use ty::fast_reject::SimplifiedType;\n-use mir;\n+use crate::infer::canonical::Canonical;\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use crate::traits;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::Substs;\n+use crate::ty::fast_reject::SimplifiedType;\n+use crate::mir;\n \n use std::fmt::Debug;\n use std::hash::Hash;"}, {"sha": "67a5c7d6c9a64b8e7ab95ee27ca88a9859953385", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,54 +1,55 @@\n-use dep_graph::{DepConstructor, DepNode};\n-use errors::DiagnosticBuilder;\n-use hir::def_id::{CrateNum, DefId, DefIndex};\n-use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n+use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::errors::DiagnosticBuilder;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n+use crate::hir::def::{Def, Export};\n+use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use rustc_data_structures::svh::Svh;\n-use infer::canonical::{self, Canonical};\n-use lint;\n-use middle::borrowck::BorrowCheckResult;\n-use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary, ForeignModule};\n-use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n-use middle::privacy::AccessLevels;\n-use middle::reachable::ReachableSet;\n-use middle::region;\n-use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n-use middle::stability::{self, DeprecationEntry};\n-use middle::lib_features::LibFeatures;\n-use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n-use mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n-use mir::mono::CodegenUnit;\n-use mir;\n-use mir::interpret::GlobalId;\n-use session::{CompileResult, CrateDisambiguator};\n-use session::config::{EntryFnType, OutputFilenames, OptLevel};\n-use traits::{self, Vtable};\n-use traits::query::{\n+use crate::infer::canonical::{self, Canonical};\n+use crate::lint;\n+use crate::middle::borrowck::BorrowCheckResult;\n+use crate::middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary, ForeignModule};\n+use crate::middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n+use crate::middle::privacy::AccessLevels;\n+use crate::middle::reachable::ReachableSet;\n+use crate::middle::region;\n+use crate::middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n+use crate::middle::stability::{self, DeprecationEntry};\n+use crate::middle::lib_features::LibFeatures;\n+use crate::middle::lang_items::{LanguageItems, LangItem};\n+use crate::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n+use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n+use crate::mir::mono::CodegenUnit;\n+use crate::mir;\n+use crate::mir::interpret::GlobalId;\n+use crate::session::{CompileResult, CrateDisambiguator};\n+use crate::session::config::{EntryFnType, OutputFilenames, OptLevel};\n+use crate::traits::{self, Vtable};\n+use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,\n     CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n     CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n-use traits::query::method_autoderef::MethodAutoderefStepsResult;\n-use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n-use traits::query::normalize::NormalizationResult;\n-use traits::query::outlives_bounds::OutlivesBound;\n-use traits::specialization_graph;\n-use traits::Clauses;\n-use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n-use ty::steal::Steal;\n-use ty::subst::Substs;\n-use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n-use util::common::{ErrorReported};\n-use util::profiling::ProfileCategory::*;\n-use session::Session;\n+use crate::traits::query::method_autoderef::MethodAutoderefStepsResult;\n+use crate::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n+use crate::traits::query::normalize::NormalizationResult;\n+use crate::traits::query::outlives_bounds::OutlivesBound;\n+use crate::traits::specialization_graph;\n+use crate::traits::Clauses;\n+use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::steal::Steal;\n+use crate::ty::subst::Substs;\n+use crate::util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n+use crate::util::common::{ErrorReported};\n+use crate::util::profiling::ProfileCategory::*;\n+use crate::session::Session;\n \n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_target::spec::PanicStrategy;\n \n use std::borrow::Cow;\n@@ -101,12 +102,12 @@ define_queries! { <'tcx>\n         /// Records the type of every item.\n         [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-        /// predicates (where clauses) that must be proven true in order\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) that must be proven true in order\n         /// to reference it. This is almost always the \"predicates query\"\n         /// that you want.\n         ///\n@@ -122,8 +123,8 @@ define_queries! { <'tcx>\n         /// user.)\n         [] fn predicates_of: PredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-        /// predicates (where clauses) directly defined on it. This is\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n         [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId)\n@@ -137,7 +138,7 @@ define_queries! { <'tcx>\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n         [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n \n-        /// Maps from the def-id of a trait to the list of\n+        /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of\n         /// predicates. We store these in a separate map because we must\n         /// evaluate them even during type conversion, often before the\n@@ -215,7 +216,7 @@ define_queries! { <'tcx>\n     },\n \n     Codegen {\n-        /// Set of all the def-ids in this crate that have MIR associated with\n+        /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n         [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n@@ -225,25 +226,25 @@ define_queries! { <'tcx>\n         /// the value isn't known except to the pass itself.\n         [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<BitSet<mir::Local>>),\n \n-        /// Fetch the MIR for a given def-id right after it's built - this includes\n+        /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n         [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-        /// Fetch the MIR for a given def-id up till the point where it is\n+        /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+        [no_hash] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-        [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+        [no_hash] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n         [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n     },\n \n     TypeChecking {\n-        /// The result of unsafety-checking this def-id.\n+        /// The result of unsafety-checking this `DefId`.\n         [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n@@ -306,23 +307,23 @@ define_queries! { <'tcx>\n     TypeChecking {\n         /// Gets a complete map from all types to their inherent impls.\n         /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for LOCAL_CRATE)\n+        /// (Defined only for `LOCAL_CRATE`.)\n         [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum)\n             -> Lrc<CrateInherentImpls>,\n \n-        /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n         /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for LOCAL_CRATE)\n+        /// (Defined only for `LOCAL_CRATE`.)\n         [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum)\n             -> (),\n     },\n \n     Other {\n         /// Evaluate a constant without running sanity checks\n         ///\n-        /// DO NOT USE THIS outside const eval. Const eval uses this to break query cycles during\n-        /// validation. Please add a comment to every use site explaining why using `const_eval`\n-        /// isn't sufficient\n+        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n+        /// during validation. Please add a comment to every use site explaining why using\n+        /// `const_eval` isn't sufficient\n         [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx>,\n \n@@ -343,7 +344,7 @@ define_queries! { <'tcx>\n     Other {\n         [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n \n-        /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n+        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n         /// in the case of closures, this will be redirected to the enclosing function.\n         [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n \n@@ -397,7 +398,7 @@ define_queries! { <'tcx>\n             -> Lrc<specialization_graph::Graph>,\n         [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n-        /// Get the ParameterEnvironment for a given item; this environment\n+        /// Gets the ParameterEnvironment for a given item; this environment\n         /// will be in \"user-facing\" mode, meaning that it is suitabe for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n@@ -484,7 +485,7 @@ define_queries! { <'tcx>\n \n         [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n \n-        /// Identifies the entry-point (e.g. the `main` function) for a given\n+        /// Identifies the entry-point (e.g., the `main` function) for a given\n         /// crate, returning `None` if there is no entry point (such as for library crates).\n         [] fn entry_fn: EntryFn(CrateNum) -> Option<(DefId, EntryFnType)>,\n         [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,"}, {"sha": "f948abc7f6fd366a74c85da9715fbef3407302b4", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,28 +1,28 @@\n-use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use errors::Diagnostic;\n-use hir;\n-use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n-use hir::map::definitions::DefPathHash;\n-use ich::{CachingSourceMapView, Fingerprint};\n-use mir::{self, interpret};\n-use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n+use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use crate::errors::Diagnostic;\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n+use crate::hir::map::definitions::DefPathHash;\n+use crate::ich::{CachingSourceMapView, Fingerprint};\n+use crate::mir::{self, interpret};\n+use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n+use crate::rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       SpecializedDecoder, SpecializedEncoder,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n-use session::{CrateDisambiguator, Session};\n+use crate::session::{CrateDisambiguator, Session};\n use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n-use ty;\n-use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n-use ty::context::TyCtxt;\n-use util::common::time;\n+use crate::ty;\n+use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n+use crate::ty::context::TyCtxt;\n+use crate::util::common::time;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -103,7 +103,7 @@ impl AbsoluteBytePos {\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    /// Create a new OnDiskCache instance from the serialized data in `data`.\n+    /// Creates a new OnDiskCache instance from the serialized data in `data`.\n     pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n@@ -202,7 +202,7 @@ impl<'sess> OnDiskCache<'sess> {\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n             time(tcx.sess, \"encode query results\", || {\n-                use ty::query::queries::*;\n+                use crate::ty::query::queries::*;\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n \n@@ -225,11 +225,11 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<specialization_graph_of<'_>, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants\n-                use ty::query::QueryAccessors;\n+                use crate::ty::query::QueryAccessors;\n                 let cache = const_eval::query_cache(tcx).borrow();\n                 assert!(cache.active.is_empty());\n                 for (key, entry) in cache.results.iter() {\n-                    use ty::query::config::QueryDescription;\n+                    use crate::ty::query::config::QueryDescription;\n                     if const_eval::cache_on_disk(tcx, key.clone()) {\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n@@ -325,7 +325,7 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    /// Load a diagnostic emitted during the previous compilation session.\n+    /// Loads a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics<'a, 'tcx>(&self,\n                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       dep_node_index: SerializedDepNodeIndex)\n@@ -339,7 +339,7 @@ impl<'sess> OnDiskCache<'sess> {\n         diagnostics.unwrap_or_default()\n     }\n \n-    /// Store a diagnostic emitted during the current compilation session.\n+    /// Stores a diagnostic emitted during the current compilation session.\n     /// Anything stored like this will be available via `load_diagnostics` in\n     /// the next compilation session.\n     #[inline(never)]\n@@ -353,7 +353,7 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Returns the cached query result if there is something in the cache for\n-    /// the given SerializedDepNodeIndex. Otherwise returns None.\n+    /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(&self,\n                                           tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                                           dep_node_index: SerializedDepNodeIndex)\n@@ -366,7 +366,7 @@ impl<'sess> OnDiskCache<'sess> {\n                           \"query result\")\n     }\n \n-    /// Store a diagnostic emitted during computation of an anonymous query.\n+    /// Stores a diagnostic emitted during computation of an anonymous query.\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`.\n@@ -777,7 +777,7 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n                                                  value: &V)\n                                                  -> Result<(), E::Error>\n     {\n-        use ty::codec::TyEncoder;\n+        use crate::ty::codec::TyEncoder;\n         let start_pos = self.position();\n \n         tag.encode(self)?;"}, {"sha": "9b2a70a6a6d20583ed52fa6fd0ecc6bcb5844f8c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 77, "deletions": 59, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871338c3aed87cb84f02ebd7fd9b447966d5b05d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=871338c3aed87cb84f02ebd7fd9b447966d5b05d", "patch": "@@ -1,20 +1,20 @@\n-//! The implementation of the query system itself. Defines the macros\n-//! that generate the actual methods on tcx which find and execute the\n-//! provider, manage the caches, and so forth.\n-\n-use dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n-use errors::DiagnosticBuilder;\n-use errors::Level;\n-use errors::Diagnostic;\n-use errors::FatalError;\n-use ty::tls;\n-use ty::{TyCtxt};\n-use ty::query::Query;\n-use ty::query::config::{QueryConfig, QueryDescription};\n-use ty::query::job::{QueryJob, QueryResult, QueryInfo};\n-use ty::item_path;\n-\n-use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n+//! The implementation of the query system itself. This defines the macros that\n+//! generate the actual methods on tcx which find and execute the provider,\n+//! manage the caches, and so forth.\n+\n+use crate::dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n+use crate::errors::DiagnosticBuilder;\n+use crate::errors::Level;\n+use crate::errors::Diagnostic;\n+use crate::errors::FatalError;\n+use crate::ty::tls;\n+use crate::ty::{TyCtxt};\n+use crate::ty::query::Query;\n+use crate::ty::query::config::{QueryConfig, QueryDescription};\n+use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n+use crate::ty::item_path;\n+\n+use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n@@ -113,7 +113,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let mut lock = cache.borrow_mut();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                tcx.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n+                tcx.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n                 let result = Ok((value.value.clone(), value.index));\n                 #[cfg(debug_assertions)]\n                 {\n@@ -160,7 +160,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             // thread\n             #[cfg(parallel_compiler)]\n             {\n-                if let Err(cycle) = job.await(tcx, span) {\n+                if let Err(cycle) = job.r#await(tcx, span) {\n                     return TryGetJob::JobCompleted(Err(cycle));\n                 }\n             }\n@@ -367,15 +367,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Fast path for when incr. comp. is off. `to_dep_node` is\n         // expensive for some DepKinds.\n         if !self.dep_graph.is_fully_enabled() {\n-            let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n+            let null_dep_node = DepNode::new_no_params(crate::dep_graph::DepKind::Null);\n             return Ok(self.force_query_with_job::<Q>(key, job, null_dep_node).0);\n         }\n \n         let dep_node = Q::to_dep_node(self, &key);\n \n         if dep_node.kind.is_anon() {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-            self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n+            self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 job.start(self, diagnostics, |tcx| {\n@@ -385,7 +385,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 })\n             });\n \n-            self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n+            self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n@@ -452,14 +452,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = if let Some(result) = result {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n+            self.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n \n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n             // recompute.\n \n-            self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n+            self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n             // The diagnostics for this query have already been\n             // promoted to the current session during\n@@ -472,7 +472,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 })\n             });\n \n-            self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n+            self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n             result\n         };\n \n@@ -499,8 +499,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         dep_node: &DepNode,\n         dep_node_index: DepNodeIndex,\n     ) {\n-        use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-        use ich::Fingerprint;\n+        use crate::ich::Fingerprint;\n \n         assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                 self.dep_graph.prev_fingerprint_of(dep_node),\n@@ -509,11 +508,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n         let mut hcx = self.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n \n-        result.hash_stable(&mut hcx, &mut hasher);\n-\n-        let new_hash: Fingerprint = hasher.finish();\n+        let new_hash = Q::hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n         debug!(\"END verify_ich({:?})\", dep_node);\n \n         let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n@@ -541,32 +537,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-        self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n+        self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             job.start(self, diagnostics, |tcx| {\n                 if dep_node.kind.is_eval_always() {\n                     tcx.dep_graph.with_eval_always_task(dep_node,\n                                                         tcx,\n                                                         key,\n-                                                        Q::compute)\n+                                                        Q::compute,\n+                                                        Q::hash_result)\n                 } else {\n                     tcx.dep_graph.with_task(dep_node,\n                                             tcx,\n                                             key,\n-                                            Q::compute)\n+                                            Q::compute,\n+                                            Q::hash_result)\n                 }\n             })\n         });\n \n-        self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n+        self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n         }\n \n-        if dep_node.kind != ::dep_graph::DepKind::Null {\n+        if dep_node.kind != crate::dep_graph::DepKind::Null {\n             if unlikely!(!diagnostics.is_empty()) {\n                 self.queries.on_disk_cache\n                     .store_diagnostics(dep_node_index, diagnostics);\n@@ -602,7 +600,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n+            self.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n         }\n     }\n \n@@ -679,6 +677,18 @@ macro_rules! handle_cycle_error {\n     };\n }\n \n+macro_rules! hash_result {\n+    ([][$hcx:expr, $result:expr]) => {{\n+        dep_graph::hash_result($hcx, &$result)\n+    }};\n+    ([no_hash$(, $modifiers:ident)*][$hcx:expr, $result:expr]) => {{\n+        None\n+    }};\n+    ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n+        hash_result!([$($modifiers),*][$($args)*])\n+    };\n+}\n+\n macro_rules! define_queries {\n     (<$tcx:tt> $($category:tt {\n         $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n@@ -698,13 +708,13 @@ macro_rules! define_queries_inner {\n         #[cfg(parallel_compiler)]\n         use ty::query::job::QueryResult;\n         use rustc_data_structures::sync::Lock;\n-        use {\n+        use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasherResult,\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n-        use util::profiling::ProfileCategory;\n+        use crate::util::profiling::ProfileCategory;\n \n         define_queries_struct! {\n             tcx: $tcx,\n@@ -729,6 +739,7 @@ macro_rules! define_queries_inner {\n                 sess.profiler(|p| {\n                     $(\n                         p.record_computed_queries(\n+                            <queries::$name<'_> as QueryConfig<'_>>::NAME,\n                             <queries::$name<'_> as QueryConfig<'_>>::CATEGORY,\n                             self.$name.lock().results.len()\n                         );\n@@ -947,7 +958,7 @@ macro_rules! define_queries_inner {\n             #[allow(unused)]\n             #[inline(always)]\n             fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n-                use dep_graph::DepConstructor::*;\n+                use crate::dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n@@ -966,6 +977,13 @@ macro_rules! define_queries_inner {\n                 })\n             }\n \n+            fn hash_result(\n+                _hcx: &mut StableHashingContext<'_>,\n+                _result: &Self::Value\n+            ) -> Option<Fingerprint> {\n+                hash_result!([$($modifiers)*][_hcx, _result])\n+            }\n+\n             fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx])\n             }\n@@ -999,16 +1017,16 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n-            /// Return a transparent wrapper for `TyCtxt` which ensures queries\n-            /// are executed instead of returing their result\n+            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+            /// are executed instead of just returing their results.\n             #[inline(always)]\n             pub fn ensure(self) -> TyCtxtEnsure<'a, $tcx, 'lcx> {\n                 TyCtxtEnsure {\n                     tcx: self,\n                 }\n             }\n \n-            /// Return a transparent wrapper for `TyCtxt` which uses\n+            /// Returns a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n             #[inline(always)]\n             pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n@@ -1049,7 +1067,7 @@ macro_rules! define_queries_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Queries<$tcx> {\n-            /// This provides access to the incr. comp. on-disk cache for query results.\n+            /// This provides access to the incrimental comilation on-disk cache for query results.\n             /// Do not access this directly. It is only meant to be used by\n             /// `DepGraph::try_mark_green()` and the query infrastructure.\n             pub(crate) on_disk_cache: OnDiskCache<'tcx>,\n@@ -1105,29 +1123,29 @@ macro_rules! define_provider_struct {\n ///\n /// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n /// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of DepNodes. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain DepNodes is a\n-/// valid DefPathHash. Since we also always build a huge table that maps every\n-/// DefPathHash in the current codebase to the corresponding DefId, we have\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n /// everything we need to re-run the query.\n ///\n /// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the DefId of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a dep-node\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the dep-node\n-/// is actually a DefPathHash, and can therefore just look up the corresponding\n-/// DefId in `tcx.def_path_hash_to_def_id`.\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n ///\n /// When you implement a new query, it will likely have a corresponding new\n-/// DepKind, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a DefId or DefIndex as sole parameter,\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n-    use hir::def_id::LOCAL_CRATE;\n+    use crate::hir::def_id::LOCAL_CRATE;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n     // DepNode::CodegenUnit:\n@@ -1167,7 +1185,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     macro_rules! force {\n         ($query:ident, $key:expr) => {\n             {\n-                tcx.force_query::<::ty::query::queries::$query<'_>>($key, DUMMY_SP, *dep_node);\n+                tcx.force_query::<crate::ty::query::queries::$query<'_>>($key, DUMMY_SP, *dep_node);\n             }\n         }\n     };\n@@ -1437,8 +1455,8 @@ macro_rules! impl_load_from_cache {\n             // Check whether the query invocation corresponding to the given\n             // DepNode is eligible for on-disk-caching.\n             pub fn cache_on_disk(&self, tcx: TyCtxt<'_, '_, '_>) -> bool {\n-                use ty::query::queries;\n-                use ty::query::QueryDescription;\n+                use crate::ty::query::queries;\n+                use crate::ty::query::QueryDescription;\n \n                 match self.kind {\n                     $(DepKind::$dep_kind => {"}]}