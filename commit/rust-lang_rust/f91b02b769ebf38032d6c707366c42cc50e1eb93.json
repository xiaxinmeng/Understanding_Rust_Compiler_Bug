{"sha": "f91b02b769ebf38032d6c707366c42cc50e1eb93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MWIwMmI3NjllYmYzODAzMmQ2YzcwNzM2NmM0MmNjNTBlMWViOTM=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-07-03T09:31:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-03T09:31:07Z"}, "message": "Rollup merge of #51979 - oli-obk:lowering_cleanups4, r=nikomatsakis\n\nGet rid of `TyImplTraitExistential`\n\ncc @eddyb\n\nr? @nikomatsakis", "tree": {"sha": "a19959065adcc2a63bf39d59dd5acd66abd4b140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a19959065adcc2a63bf39d59dd5acd66abd4b140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f91b02b769ebf38032d6c707366c42cc50e1eb93", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbO0JcCRBK7hj4Ov3rIwAAdHIIAGG8tjz1OfDHnao7tqJ2e8C/\nvW0rrFZZ5obX4rQIfWLxkHnUbkaCoikLyb41isPHtZ2anktafQlbEOrW+qYFGLjr\nvYqZJAOyoA2JJM/M9UfE6XPH+t0s4VSrDk4gaVHeKQOaHDSVcKtNF1z4IWwSrBma\n7cPl4ctcm89hfxHJw3+Qqj3istm6eQJ0izpT1qoQoNpycPGC7JVwIYLFmXU1TOJI\ngXIwzhCyYBPpTWvNtvBD37AuP9mMtYlCByeB2TGOUcvtL0V8f2ZwkPQu72Q6odQX\nReQMOA27ERRw87ym8n8Q0cvrhuN5QldCxW2MIMBrIvlUgL755fIstjlB4x5BTws=\n=UCnJ\n-----END PGP SIGNATURE-----\n", "payload": "tree a19959065adcc2a63bf39d59dd5acd66abd4b140\nparent 5195132a352a8248629824b6b73ebac49bc23dc8\nparent 75a6fde6a49b7e497163c9a415b147cec26cbc56\nauthor Pietro Albini <pietro@pietroalbini.org> 1530610267 +0200\ncommitter GitHub <noreply@github.com> 1530610267 +0200\n\nRollup merge of #51979 - oli-obk:lowering_cleanups4, r=nikomatsakis\n\nGet rid of `TyImplTraitExistential`\n\ncc @eddyb\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f91b02b769ebf38032d6c707366c42cc50e1eb93", "html_url": "https://github.com/rust-lang/rust/commit/f91b02b769ebf38032d6c707366c42cc50e1eb93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f91b02b769ebf38032d6c707366c42cc50e1eb93/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5195132a352a8248629824b6b73ebac49bc23dc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5195132a352a8248629824b6b73ebac49bc23dc8", "html_url": "https://github.com/rust-lang/rust/commit/5195132a352a8248629824b6b73ebac49bc23dc8"}, {"sha": "75a6fde6a49b7e497163c9a415b147cec26cbc56", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a6fde6a49b7e497163c9a415b147cec26cbc56", "html_url": "https://github.com/rust-lang/rust/commit/75a6fde6a49b7e497163c9a415b147cec26cbc56"}], "stats": {"total": 321, "additions": 144, "deletions": 177}, "files": [{"sha": "a7ed854d016494584fe4009e89b83af3fcc83a26", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -607,13 +607,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTraitExistential(_, def_id, ref lifetimes) => {\n-            // we are not recursing into the `existential` item, because it is already being visited\n-            // as part of the surrounding module. The `NodeId` just exists so we don't have to look\n-            // it up everywhere else in the compiler\n-            visitor.visit_def_mention(Def::Existential(def_id));\n-            walk_list!(visitor, visit_lifetime, lifetimes);\n-        }\n         TyTypeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }"}, {"sha": "5990340ae29553e222cf7cc5215ce9740e0abfe4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -1306,13 +1306,20 @@ impl<'a> LoweringContext<'a> {\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n-            hir::TyImplTraitExistential(\n-                hir::ItemId {\n-                    id: exist_ty_id.node_id\n-                },\n-                DefId::local(exist_ty_def_index),\n-                lifetimes,\n-            )\n+            let path = P(hir::Path {\n+                span: exist_ty_span,\n+                def: Def::Existential(DefId::local(exist_ty_def_index)),\n+                segments: hir_vec![hir::PathSegment {\n+                    infer_types: false,\n+                    ident: Ident::new(keywords::Invalid.name(), exist_ty_span),\n+                    args: Some(P(hir::GenericArgs {\n+                        parenthesized: false,\n+                        bindings: HirVec::new(),\n+                        args: lifetimes,\n+                    }))\n+                }],\n+            });\n+            hir::TyPath(hir::QPath::Resolved(None, path))\n         })\n     }\n \n@@ -1321,7 +1328,7 @@ impl<'a> LoweringContext<'a> {\n         exist_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n-    ) -> (HirVec<hir::Lifetime>, HirVec<hir::GenericParam>) {\n+    ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // e.g. 'a, 'b, but not 'c in `impl for<'c> SomeTrait<'a, 'b, 'c>`\n@@ -1332,7 +1339,7 @@ impl<'a> LoweringContext<'a> {\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: HashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::Lifetime>,\n+            output_lifetimes: Vec<hir::GenericArg>,\n             output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n@@ -1416,11 +1423,11 @@ impl<'a> LoweringContext<'a> {\n                     && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n-                    self.output_lifetimes.push(hir::Lifetime {\n+                    self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n                         id: self.context.next_id().node_id,\n                         span: lifetime.span,\n                         name,\n-                    });\n+                    }));\n \n                     // We need to manually create the ids here, because the\n                     // definitions will go into the explicit `existential type`"}, {"sha": "8d83dd3279c64d4b690c33608b3258128856e7b6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -1692,18 +1692,6 @@ pub enum Ty_ {\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// An existentially quantified (there exists a type satisfying) `impl\n-    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n-    ///\n-    /// The `Item` is the generated\n-    /// `existential type Foo<'a, 'b>: MyTrait<'a, 'b>;`.\n-    ///\n-    /// The `HirVec<Lifetime>` is the list of lifetimes applied as parameters\n-    /// to the `abstract type`, e.g. the `'c` and `'d` in `-> Foo<'c, 'd>`.\n-    /// This list is only a list of lifetimes and not type parameters\n-    /// because all in-scope type parameters are captured by `impl Trait`,\n-    /// so they are resolved directly through the parent `Generics`.\n-    TyImplTraitExistential(ItemId, DefId, HirVec<Lifetime>),\n     /// Unused for now\n     TyTypeof(AnonConst),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "4d0969d898e91434b7a92ad72a81fef79444f073", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -420,15 +420,6 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTraitExistential(hir_id, _def_id, ref _lifetimes) => {\n-                match self.ann.try_fetch_item(hir_id.id).map(|it| &it.node) {\n-                    None => self.word_space(\"impl {{Trait}}\")?,\n-                    Some(&hir::ItemExistential(ref exist_ty)) => {\n-                        self.print_bounds(\"impl\", &exist_ty.bounds)?;\n-                    },\n-                    other => bug!(\"impl Trait pointed to {:#?}\", other),\n-                }\n-            }\n             hir::TyArray(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;"}, {"sha": "dd19d59578fc1d0bd64a9ddfc3d55bb5d337e925", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -340,7 +340,6 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTraitExistential(existty, def_id, lifetimes),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer"}, {"sha": "369f65c214aa107cc30cf51fcfa5476419722a1e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 100, "deletions": 91, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -625,122 +625,131 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyImplTraitExistential(item_id, _, ref lifetimes) => {\n-                // Resolve the lifetimes that are applied to the existential type.\n-                // These are resolved in the current scope.\n-                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n-                //          ^                 ^this gets resolved in the current scope\n-                for lifetime in lifetimes {\n-                    self.visit_lifetime(lifetime);\n-\n-                    // Check for predicates like `impl for<'a> SomeTrait<impl OtherTrait<'a>>`\n-                    // and ban them. Type variables instantiated inside binders aren't\n-                    // well-supported at the moment, so this doesn't work.\n-                    // In the future, this should be fixed and this error should be removed.\n-                    let def = self.map.defs.get(&lifetime.id).cloned();\n-                    if let Some(Region::LateBound(_, def_id, _)) = def {\n-                        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                            // Ensure that the parent of the def is an item, not HRTB\n-                            let parent_id = self.tcx.hir.get_parent_node(node_id);\n-                            let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n-                            let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                            let krate = self.tcx.hir.forest.krate();\n-                            if !(krate.items.contains_key(&parent_id)\n-                                || krate.impl_items.contains_key(&parent_impl_id)\n-                                || krate.trait_items.contains_key(&parent_trait_id))\n-                            {\n-                                span_err!(\n-                                    self.tcx.sess,\n-                                    lifetime.span,\n-                                    E0657,\n-                                    \"`impl Trait` can only capture lifetimes \\\n-                                     bound at the fn or impl level\"\n-                                );\n-                                self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                if let Def::Existential(exist_ty_did) = path.def {\n+                    assert!(exist_ty_did.is_local());\n+                    // Resolve the lifetimes that are applied to the existential type.\n+                    // These are resolved in the current scope.\n+                    // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                    // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n+                    //          ^                 ^this gets resolved in the current scope\n+                    for lifetime in &path.segments[0].args.as_ref().unwrap().args {\n+                        if let hir::GenericArg::Lifetime(lifetime) = lifetime {\n+                            self.visit_lifetime(lifetime);\n+\n+                            // Check for predicates like `impl for<'a> Trait<impl OtherTrait<'a>>`\n+                            // and ban them. Type variables instantiated inside binders aren't\n+                            // well-supported at the moment, so this doesn't work.\n+                            // In the future, this should be fixed and this error should be removed.\n+                            let def = self.map.defs.get(&lifetime.id).cloned();\n+                            if let Some(Region::LateBound(_, def_id, _)) = def {\n+                                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                                    // Ensure that the parent of the def is an item, not HRTB\n+                                    let parent_id = self.tcx.hir.get_parent_node(node_id);\n+                                    let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n+                                    let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n+                                    let krate = self.tcx.hir.forest.krate();\n+                                    if !(krate.items.contains_key(&parent_id)\n+                                        || krate.impl_items.contains_key(&parent_impl_id)\n+                                        || krate.trait_items.contains_key(&parent_trait_id))\n+                                    {\n+                                        span_err!(\n+                                            self.tcx.sess,\n+                                            lifetime.span,\n+                                            E0657,\n+                                            \"`impl Trait` can only capture lifetimes \\\n+                                            bound at the fn or impl level\"\n+                                        );\n+                                        self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n+                                    }\n+                                }\n                             }\n                         }\n                     }\n-                }\n \n-                // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n-                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n-                //                          ^            ^ this gets resolved in the scope of\n-                //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n-                    hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n-                        generics,\n-                        bounds,\n-                    ),\n-                    ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n-                };\n+                    let id = self.tcx.hir.as_local_node_id(exist_ty_did).unwrap();\n+\n+                    // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n+                    // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                    // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n+                    //                          ^            ^ this gets resolved in the scope of\n+                    //                                         the exist_ty generics\n+                    let (generics, bounds) = match self.tcx.hir.expect_item(id).node {\n+                        hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n+                            generics,\n+                            bounds,\n+                        ),\n+                        ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n+                    };\n \n-                // We want to start our early-bound indices at the end of the parent scope,\n-                // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_abstract_type();\n-                debug!(\"visit_ty: index = {}\", index);\n+                    // We want to start our early-bound indices at the end of the parent scope,\n+                    // not including any parent `impl Trait`s.\n+                    let mut index = self.next_early_index_for_abstract_type();\n+                    debug!(\"visit_ty: index = {}\", index);\n \n-                let mut elision = None;\n-                let mut lifetimes = FxHashMap();\n-                let mut type_count = 0;\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n-                            if let hir::ParamName::Plain(param_name) = name {\n-                                if param_name.name == keywords::UnderscoreLifetime.name() {\n-                                    // Pick the elided lifetime \"definition\" if one exists\n-                                    // and use it to make an elision scope.\n-                                    elision = Some(reg);\n+                    let mut elision = None;\n+                    let mut lifetimes = FxHashMap();\n+                    let mut type_count = 0;\n+                    for param in &generics.params {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                                if let hir::ParamName::Plain(param_name) = name {\n+                                    if param_name.name == keywords::UnderscoreLifetime.name() {\n+                                        // Pick the elided lifetime \"definition\" if one exists\n+                                        // and use it to make an elision scope.\n+                                        elision = Some(reg);\n+                                    } else {\n+                                        lifetimes.insert(name, reg);\n+                                    }\n                                 } else {\n                                     lifetimes.insert(name, reg);\n                                 }\n-                            } else {\n-                                lifetimes.insert(name, reg);\n                             }\n-                        }\n-                        GenericParamKind::Type { .. } => {\n-                            type_count += 1;\n+                            GenericParamKind::Type { .. } => {\n+                                type_count += 1;\n+                            }\n                         }\n                     }\n-                }\n-                let next_early_index = index + type_count;\n+                    let next_early_index = index + type_count;\n \n-                if let Some(elision_region) = elision {\n-                    let scope = Scope::Elision {\n-                        elide: Elide::Exact(elision_region),\n-                        s: self.scope,\n-                    };\n-                    self.with(scope, |_old_scope, this| {\n+                    if let Some(elision_region) = elision {\n+                        let scope = Scope::Elision {\n+                            elide: Elide::Exact(elision_region),\n+                            s: self.scope,\n+                        };\n+                        self.with(scope, |_old_scope, this| {\n+                            let scope = Scope::Binder {\n+                                lifetimes,\n+                                next_early_index,\n+                                s: this.scope,\n+                                track_lifetime_uses: true,\n+                                abstract_type_parent: false,\n+                            };\n+                            this.with(scope, |_old_scope, this| {\n+                                this.visit_generics(generics);\n+                                for bound in bounds {\n+                                    this.visit_param_bound(bound);\n+                                }\n+                            });\n+                        });\n+                    } else {\n                         let scope = Scope::Binder {\n                             lifetimes,\n                             next_early_index,\n-                            s: this.scope,\n+                            s: self.scope,\n                             track_lifetime_uses: true,\n                             abstract_type_parent: false,\n                         };\n-                        this.with(scope, |_old_scope, this| {\n+                        self.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n                                 this.visit_param_bound(bound);\n                             }\n                         });\n-                    });\n+                    }\n                 } else {\n-                    let scope = Scope::Binder {\n-                        lifetimes,\n-                        next_early_index,\n-                        s: self.scope,\n-                        track_lifetime_uses: true,\n-                        abstract_type_parent: false,\n-                    };\n-                    self.with(scope, |_old_scope, this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n-                    });\n+                    intravisit::walk_ty(self, ty)\n                 }\n             }\n             _ => intravisit::walk_ty(self, ty),"}, {"sha": "3919ba13076f6d839426226056ca2e904b720314", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -229,8 +229,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemUse(..) => {}\n             // The interface is empty\n             hir::ItemGlobalAsm(..) => {}\n-            // Checked by visit_ty\n-            hir::ItemExistential(..) => {}\n+            hir::ItemExistential(..) => {\n+                if item_level.is_some() {\n+                    // Reach the (potentially private) type and the API being exposed\n+                    self.reach(item.id).ty().predicates();\n+                }\n+            }\n             // Visit everything\n             hir::ItemConst(..) | hir::ItemStatic(..) |\n             hir::ItemFn(..) | hir::ItemTy(..) => {\n@@ -390,17 +394,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             module_id = self.tcx.hir.get_parent_node(module_id);\n         }\n     }\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(item_id, _, _) = ty.node {\n-            if self.get(item_id.id).is_some() {\n-                // Reach the (potentially private) type and the API being exposed\n-                self.reach(item_id.id).ty().predicates();\n-            }\n-        }\n-\n-        intravisit::walk_ty(self, ty);\n-    }\n }\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n@@ -1568,8 +1561,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemUse(..) => {}\n             // No subitems\n             hir::ItemGlobalAsm(..) => {}\n-            // Checked in visit_ty\n-            hir::ItemExistential(..) => {}\n+            hir::ItemExistential(..) => {\n+                // Check the traits being exposed, as they're separate,\n+                // e.g. `impl Iterator<Item=T>` has two predicates,\n+                // `X: Iterator` and `<X as Iterator>::Item == T`,\n+                // where `X` is the `impl Iterator<Item=T>` itself,\n+                // stored in `predicates_of`, not in the `Ty` itself.\n+\n+                self.check(item.id, self.inner_visibility).predicates();\n+            }\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemTy(..) => {\n@@ -1667,20 +1667,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         // handled in `visit_item` above\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(ref exist_item, _, _) = ty.node {\n-            // Check the traits being exposed, as they're separate,\n-            // e.g. `impl Iterator<Item=T>` has two predicates,\n-            // `X: Iterator` and `<X as Iterator>::Item == T`,\n-            // where `X` is the `impl Iterator<Item=T>` itself,\n-            // stored in `predicates_of`, not in the `Ty` itself.\n-\n-            self.check(exist_item.id, self.inner_visibility).predicates();\n-        }\n-\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n     // Don't recurse into expressions in array sizes or const initializers\n     fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n     // Don't recurse into patterns in function arguments"}, {"sha": "2e467d315bedd7d7baf21a8f6b15955be39307f3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -1095,6 +1095,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     hir::TyStr => tcx.mk_str()\n                 }\n             }\n+            Def::Existential(exist_ty_did) => {\n+                assert!(exist_ty_did.is_local());\n+                let lifetimes = &path.segments[0].args.as_ref().unwrap().args;\n+                self.impl_trait_ty_to_ty(exist_ty_did, lifetimes)\n+            }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n@@ -1140,9 +1145,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTraitExistential(_, def_id, ref lifetimes) => {\n-                self.impl_trait_ty_to_ty(def_id, lifetimes)\n-            }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n@@ -1195,7 +1197,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,\n-        lifetimes: &[hir::Lifetime],\n+        lifetimes: &[hir::GenericArg],\n     ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n@@ -1208,7 +1210,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Our own parameters are the resolved lifetimes.\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        self.ast_region_to_region(&lifetimes[i], None).into()\n+                        if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n+                            self.ast_region_to_region(lifetime, None).into()\n+                        } else {\n+                            bug!()\n+                        }\n                     }\n                     _ => bug!()\n                 }"}, {"sha": "4931cbfa5acc386f274537569228089e3c3b4637", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -875,10 +875,6 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n-            bug!(\"impl Trait is desugared to existential type items\");\n-        }\n-\n         _ => &no_generics,\n     };\n "}, {"sha": "f71d62d5a04e1e3cb39a613ec7a4682df613d423", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b02b769ebf38032d6c707366c42cc50e1eb93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f91b02b769ebf38032d6c707366c42cc50e1eb93", "patch": "@@ -2987,14 +2987,6 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTraitExistential(hir_id, _, _) => {\n-                match cx.tcx.hir.expect_item(hir_id.id).node {\n-                    hir::ItemExistential(ref exist_ty) => {\n-                        ImplTrait(exist_ty.bounds.clean(cx))\n-                    },\n-                    ref other => panic!(\"impl Trait pointed to {:#?}\", other),\n-                }\n-            },\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}]}