{"sha": "da24c0d32f8a5ce74268f416bbdab2e61a34976d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMjRjMGQzMmY4YTVjZTc0MjY4ZjQxNmJiZGFiMmU2MWEzNDk3NmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T06:37:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:19Z"}, "message": "rustpkg: Remove uses of fmt!", "tree": {"sha": "36c85c9b08089f91c87aa48927215f12c73de58a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c85c9b08089f91c87aa48927215f12c73de58a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da24c0d32f8a5ce74268f416bbdab2e61a34976d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da24c0d32f8a5ce74268f416bbdab2e61a34976d", "html_url": "https://github.com/rust-lang/rust/commit/da24c0d32f8a5ce74268f416bbdab2e61a34976d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da24c0d32f8a5ce74268f416bbdab2e61a34976d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f19f36be81cfc04d013fec80598193638fe55b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f19f36be81cfc04d013fec80598193638fe55b", "html_url": "https://github.com/rust-lang/rust/commit/a7f19f36be81cfc04d013fec80598193638fe55b"}], "stats": {"total": 618, "additions": 313, "deletions": 305}, "files": [{"sha": "de673972932d3847dda29c4ff991384adb09bb26", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -52,7 +52,7 @@ fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n-    debug!(\"Workcache database file: %s\", db_file.to_str());\n+    debug2!(\"Workcache database file: {}\", db_file.to_str());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n     let cfg = Arc::new(TreeMap::new());"}, {"sha": "b7a295f00707ae15075fa244439916c7af9d71a7", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -150,7 +150,7 @@ impl Context {\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n pub fn in_target(sysroot: &Path) -> bool {\n-    debug!(\"Checking whether %s is in target\", sysroot.to_str());\n+    debug2!(\"Checking whether {} is in target\", sysroot.to_str());\n     os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n }\n \n@@ -214,8 +214,8 @@ pub fn flags_ok_for_cmd(flags: &RustcFlags,\n                         cfgs: &[~str],\n                         cmd: &str, user_supplied_opt_level: bool) -> bool {\n     let complain = |s| {\n-        io::println(fmt!(\"The %s option can only be used with the build command:\n-                         rustpkg [options..] build %s [package-ID]\", s, s));\n+        println!(\"The {} option can only be used with the build command:\n+                  rustpkg [options..] build {} [package-ID]\", s, s);\n     };\n \n     if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {"}, {"sha": "a3b807d1fc5b3c6448f793fdd18b671840d39eac", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -28,15 +28,15 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for lib in libfiles.iter() {\n             let lib = Path(*lib);\n-            debug!(\"Full name: %s\", lib.to_str());\n+            debug2!(\"Full name: {}\", lib.to_str());\n             match has_library(&lib) {\n                 Some(basename) => {\n-                    debug!(\"parent = %s, child = %s\",\n-                           p.push(\"lib\").to_str(), lib.to_str());\n+                    debug2!(\"parent = {}, child = {}\",\n+                            p.push(\"lib\").to_str(), lib.to_str());\n                     let rel_p = p.push(\"lib/\").get_relative_to(&lib);\n-                    debug!(\"Rel: %s\", rel_p.to_str());\n+                    debug2!(\"Rel: {}\", rel_p.to_str());\n                     let rel_path = rel_p.push(basename).to_str();\n-                    debug!(\"Rel name: %s\", rel_path);\n+                    debug2!(\"Rel name: {}\", rel_path);\n                     f(&PkgId::new(rel_path));\n                 }\n                 None => ()"}, {"sha": "68cfa3220f228599c034b8764532c4e31b21245e", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -66,7 +66,7 @@ impl PkgId {\n         if path.components.len() < 1 {\n             return cond.raise((path, ~\"0-length pkgid\"));\n         }\n-        let short_name = path.filestem().expect(fmt!(\"Strange path! %s\", s));\n+        let short_name = path.filestem().expect(format!(\"Strange path! {}\", s));\n \n         let version = match given_version {\n             Some(v) => v,\n@@ -87,13 +87,13 @@ impl PkgId {\n     }\n \n     pub fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.path.to_str(),\n-             hash(self.path.to_str() + self.version.to_str()),\n-             self.version.to_str())\n+        format!(\"{}-{}-{}\", self.path.to_str(),\n+                hash(self.path.to_str() + self.version.to_str()),\n+                self.version.to_str())\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n-        fmt!(\"%s%s\", self.short_name, self.version.to_str())\n+        format!(\"{}{}\", self.short_name, self.version.to_str())\n     }\n \n     /// True if the ID has multiple components\n@@ -112,7 +112,7 @@ impl PkgId {\n     // binaries for this package (as opposed to the built ones,\n     // which are per-crate).\n     pub fn install_tag(&self) -> ~str {\n-        fmt!(\"install(%s)\", self.to_str())\n+        format!(\"install({})\", self.to_str())\n     }\n }\n \n@@ -139,7 +139,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n+        format!(\"{}-{}\", self.path.to_str(), self.version.to_str())\n     }\n }\n "}, {"sha": "d7e755b89754fa9b4fb946890dd2c2164e930a4f", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -43,9 +43,9 @@ pub struct PkgSrc {\n \n impl ToStr for PkgSrc {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"Package ID %s in start dir %s [workspace = %s]\",\n-             self.id.to_str(),\n-             self.start_dir.to_str(), self.workspace.to_str())\n+        format!(\"Package ID {} in start dir {} [workspace = {}]\",\n+                self.id.to_str(),\n+                self.start_dir.to_str(), self.workspace.to_str())\n     }\n }\n condition! {\n@@ -58,21 +58,21 @@ impl PkgSrc {\n     pub fn new(workspace: Path, use_rust_path_hack: bool, id: PkgId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Checking package source for package ID %s, \\\n-               workspace = %s use_rust_path_hack = %?\",\n+        debug2!(\"Checking package source for package ID {}, \\\n+               workspace = {} use_rust_path_hack = {:?}\",\n                id.to_str(), workspace.to_str(), use_rust_path_hack);\n \n         let mut to_try = ~[];\n         if use_rust_path_hack {\n             to_try.push(workspace.clone());\n         } else {\n-            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(fmt!(\"%s-%s\",\n+            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n                                                          id.short_name, id.version.to_str()));\n             to_try.push(result);\n             to_try.push(workspace.push(\"src\").push_rel(&id.path));\n         }\n \n-        debug!(\"Checking dirs: %?\", to_try.map(|s| s.to_str()).connect(\":\"));\n+        debug2!(\"Checking dirs: {:?}\", to_try.map(|s| s.to_str()).connect(\":\"));\n \n         let path = to_try.iter().find(|&d| os::path_exists(d));\n \n@@ -84,13 +84,13 @@ impl PkgSrc {\n                 for (prefix, suffix) in id.prefixes_iter() {\n                     let package_id = PkgId::new(prefix.to_str());\n                     let path = workspace.push(\"src\").push_rel(&package_id.path);\n-                    debug!(\"in loop: checking if %s is a directory\", path.to_str());\n+                    debug2!(\"in loop: checking if {} is a directory\", path.to_str());\n                     if os::path_is_dir(&path) {\n                         let ps = PkgSrc::new(workspace.clone(),\n                                              use_rust_path_hack,\n                                              PkgId::new(prefix.to_str()));\n-                        debug!(\"pkgsrc: Returning [%s|%s|%s]\", workspace.to_str(),\n-                               ps.start_dir.push_rel(&suffix).to_str(), ps.id.to_str());\n+                        debug2!(\"pkgsrc: Returning [{}|{}|{}]\", workspace.to_str(),\n+                                ps.start_dir.push_rel(&suffix).to_str(), ps.id.to_str());\n \n                         return PkgSrc {\n                             workspace: workspace,\n@@ -108,7 +108,7 @@ impl PkgSrc {\n                 // Ok, no prefixes work, so try fetching from git\n                 let mut ok_d = None;\n                 for w in to_try.iter() {\n-                    debug!(\"Calling fetch_git on %s\", w.to_str());\n+                    debug2!(\"Calling fetch_git on {}\", w.to_str());\n                     let gf = PkgSrc::fetch_git(w, &id);\n                     for p in gf.iter() {\n                         ok_d = Some(p.clone());\n@@ -138,14 +138,14 @@ impl PkgSrc {\n                 }\n             }\n         };\n-        debug!(\"For package id %s, returning %s\", id.to_str(), dir.to_str());\n+        debug2!(\"For package id {}, returning {}\", id.to_str(), dir.to_str());\n \n         if !os::path_is_dir(&dir) {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n \n-        debug!(\"pkgsrc: Returning {%s|%s|%s}\", workspace.to_str(),\n+        debug2!(\"pkgsrc: Returning \\\\{{}|{}|{}\\\\}\", workspace.to_str(),\n                dir.to_str(), id.to_str());\n \n         PkgSrc {\n@@ -176,13 +176,13 @@ impl PkgSrc {\n             None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n         };\n \n-        debug!(\"Checking whether %s (path = %s) exists locally. Cwd = %s, does it? %?\",\n+        debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                pkgid.to_str(), pkgid.path.to_str(),\n                os::getcwd().to_str(),\n                os::path_exists(&pkgid.path));\n \n         if os::path_exists(&pkgid.path) {\n-            debug!(\"%s exists locally! Cloning it into %s\",\n+            debug2!(\"{} exists locally! Cloning it into {}\",\n                    pkgid.path.to_str(), local.to_str());\n             // Ok to use local here; we know it will succeed\n             git_clone(&pkgid.path, local, &pkgid.version);\n@@ -194,8 +194,8 @@ impl PkgSrc {\n             return None;\n         }\n \n-        let url = fmt!(\"https://%s\", pkgid.path.to_str());\n-        debug!(\"Fetching package: git clone %s %s [version=%s]\",\n+        let url = format!(\"https://{}\", pkgid.path.to_str());\n+        debug2!(\"Fetching package: git clone {} {} [version={}]\",\n                   url, clone_target.to_str(), pkgid.version.to_str());\n \n         if git_clone_general(url, &clone_target, &pkgid.version) {\n@@ -219,7 +219,7 @@ impl PkgSrc {\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n         let maybe_path = self.start_dir.push(\"pkg.rs\");\n-        debug!(\"package_script_option: checking whether %s exists\", maybe_path.to_str());\n+        debug2!(\"package_script_option: checking whether {} exists\", maybe_path.to_str());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n         }\n@@ -239,7 +239,7 @@ impl PkgSrc {\n         for c in p.components.slice(prefix, p.components.len()).iter() {\n             sub = sub.push(*c);\n         }\n-        debug!(\"Will compile crate %s\", sub.to_str());\n+        debug2!(\"Will compile crate {}\", sub.to_str());\n         cs.push(Crate::new(&sub));\n     }\n \n@@ -253,7 +253,7 @@ impl PkgSrc {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components.len();\n-        debug!(\"Matching against %s\", self.id.short_name);\n+        debug2!(\"Matching against {}\", self.id.short_name);\n         do os::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename() {\n                 Some(filename) if filter(filename) => match filename {\n@@ -282,7 +282,7 @@ impl PkgSrc {\n             cond.raise(self.id.clone());\n         }\n \n-        debug!(\"In %s, found %u libs, %u mains, %u tests, %u benchs\",\n+        debug2!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n                self.start_dir.to_str(),\n                self.libs.len(),\n                self.mains.len(),\n@@ -298,12 +298,12 @@ impl PkgSrc {\n                     what: OutputType) {\n         for crate in crates.iter() {\n             let path = self.start_dir.push_rel(&crate.file).normalize();\n-            debug!(\"build_crates: compiling %s\", path.to_str());\n+            debug2!(\"build_crates: compiling {}\", path.to_str());\n             let path_str = path.to_str();\n             let cfgs = crate.cfgs + cfgs;\n \n             do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n-                debug!(\"Building crate %s, declaring it as an input\", path.to_str());\n+                debug2!(\"Building crate {}, declaring it as an input\", path.to_str());\n                 prep.declare_input(\"file\", path.to_str(),\n                                    workcache_support::digest_file_with_date(&path));\n                 let subpath = path.clone();\n@@ -323,7 +323,7 @@ impl PkgSrc {\n                                                subcfgs,\n                                                false,\n                                                what).to_str();\n-                    debug!(\"Result of compiling %s was %s\", subpath_str, result);\n+                    debug2!(\"Result of compiling {} was {}\", subpath_str, result);\n                     result\n                 }\n             };\n@@ -335,11 +335,11 @@ impl PkgSrc {\n     pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n         let to_do = ~[self.libs.clone(), self.mains.clone(),\n                       self.tests.clone(), self.benchs.clone()];\n-        debug!(\"In declare inputs, self = %s\", self.to_str());\n+        debug2!(\"In declare inputs, self = {}\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = self.start_dir.push_rel(&c.file).normalize();\n-                debug!(\"Declaring input: %s\", path.to_str());\n+                debug2!(\"Declaring input: {}\", path.to_str());\n                 prep.declare_input(\"file\",\n                                    path.to_str(),\n                                    workcache_support::digest_file_with_date(&path.clone()));\n@@ -357,17 +357,17 @@ impl PkgSrc {\n         // Determine the destination workspace (which depends on whether\n         // we're using the rust_path_hack)\n         let destination_workspace = if is_workspace(&self.workspace) {\n-            debug!(\"%s is indeed a workspace\", self.workspace.to_str());\n+            debug2!(\"{} is indeed a workspace\", self.workspace.to_str());\n             self.workspace.clone()\n         } else {\n             // It would be nice to have only one place in the code that checks\n             // for the use_rust_path_hack flag...\n             if build_context.context.use_rust_path_hack {\n                 let rs = default_workspace();\n-                debug!(\"Using hack: %s\", rs.to_str());\n+                debug2!(\"Using hack: {}\", rs.to_str());\n                 rs\n             } else {\n-                cond.raise(fmt!(\"Package root %s is not a workspace; pass in --rust_path_hack \\\n+                cond.raise(format!(\"Package root {} is not a workspace; pass in --rust_path_hack \\\n                                         if you want to treat it as a package source\",\n                                 self.workspace.to_str()))\n             }\n@@ -377,14 +377,14 @@ impl PkgSrc {\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n-        debug!(\"Building libs in %s, destination = %s\",\n+        debug2!(\"Building libs in {}, destination = {}\",\n                destination_workspace.to_str(), destination_workspace.to_str());\n         self.build_crates(build_context, &destination_workspace, libs, cfgs, Lib);\n-        debug!(\"Building mains\");\n+        debug2!(\"Building mains\");\n         self.build_crates(build_context, &destination_workspace, mains, cfgs, Main);\n-        debug!(\"Building tests\");\n+        debug2!(\"Building tests\");\n         self.build_crates(build_context, &destination_workspace, tests, cfgs, Test);\n-        debug!(\"Building benches\");\n+        debug2!(\"Building benches\");\n         self.build_crates(build_context, &destination_workspace, benchs, cfgs, Bench);\n         destination_workspace.to_str()\n     }\n@@ -394,7 +394,7 @@ impl PkgSrc {\n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         for crate_set in crate_sets.iter() {\n             for c in crate_set.iter() {\n-                debug!(\"Built crate: %s\", c.file.to_str())\n+                debug2!(\"Built crate: {}\", c.file.to_str())\n             }\n         }\n     }"}, {"sha": "9a440cb5f8ff097627f21499f477c5397ad6fa75", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -24,7 +24,7 @@ use messages::*;\n pub fn default_workspace() -> Path {\n     let p = rust_path();\n     if p.is_empty() {\n-        fail!(\"Empty RUST_PATH\");\n+        fail2!(\"Empty RUST_PATH\");\n     }\n     let result = p[0];\n     if !os::path_is_dir(&result) {\n@@ -88,9 +88,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     };\n \n     if found.is_some() {\n-        debug!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Found {} in {}\", pkgid.to_str(), workspace.to_str());\n     } else {\n-        debug!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.to_str());\n     }\n     found\n }\n@@ -119,13 +119,13 @@ fn target_bin_dir(workspace: &Path) -> Path {\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n     result = mk_output_path(Main, Build, pkgid, result);\n-    debug!(\"built_executable_in_workspace: checking whether %s exists\",\n+    debug2!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        debug!(\"built_executable_in_workspace: %s does not exist\", result.to_str());\n+        debug2!(\"built_executable_in_workspace: {} does not exist\", result.to_str());\n         None\n     }\n }\n@@ -146,13 +146,13 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, Build, pkgid, result);\n-    debug!(\"output_in_workspace: checking whether %s exists\",\n+    debug2!(\"output_in_workspace: checking whether {} exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        error!(fmt!(\"output_in_workspace: %s does not exist\", result.to_str()));\n+        error2!(\"output_in_workspace: {} does not exist\", result.to_str());\n         None\n     }\n }\n@@ -181,14 +181,14 @@ pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Opti\n /// `short_name` is taken as the link name of the library.\n pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n-    debug!(\"library_in_workspace: checking whether a library named %s exists\",\n+    debug2!(\"library_in_workspace: checking whether a library named {} exists\",\n            short_name);\n \n     // We don't know what the hash is, so we have to search through the directory\n     // contents\n \n-    debug!(\"short_name = %s where = %? workspace = %s \\\n-            prefix = %s\", short_name, where, workspace.to_str(), prefix);\n+    debug2!(\"short_name = {} where = {:?} workspace = {} \\\n+            prefix = {}\", short_name, where, workspace.to_str(), prefix);\n \n     let dir_to_search = match where {\n         Build => target_build_dir(workspace).push_rel(path),\n@@ -204,14 +204,14 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n }\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug!(\"Listing directory %s\", dir_to_search.to_str());\n+    debug2!(\"Listing directory {}\", dir_to_search.to_str());\n     let dir_contents = os::list_dir(dir_to_search);\n-    debug!(\"dir has %? entries\", dir_contents.len());\n+    debug2!(\"dir has {:?} entries\", dir_contents.len());\n \n-    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, short_name);\n+    let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n     let lib_filetype = os::consts::DLL_SUFFIX;\n \n-    debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n+    debug2!(\"lib_prefix = {} and lib_filetype = {}\", lib_prefix, lib_filetype);\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n@@ -221,7 +221,7 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     let mut libraries = do paths.filter |p| {\n         let extension = p.filetype();\n-        debug!(\"p = %s, p's extension is %?\", p.to_str(), extension);\n+        debug2!(\"p = {}, p's extension is {:?}\", p.to_str(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n@@ -242,12 +242,12 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n             if f_name.is_empty() { break; }\n             match f_name.rfind('-') {\n                 Some(i) => {\n-                    debug!(\"Maybe %s is a version\", f_name.slice(i + 1, f_name.len()));\n+                    debug2!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n                     match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n                        Some(ref found_vers) if version == found_vers => {\n                            match f_name.slice(0, i).rfind('-') {\n                                Some(j) => {\n-                                   debug!(\"Maybe %s equals %s\", f_name.slice(0, j), lib_prefix);\n+                                   debug2!(\"Maybe {} equals {}\", f_name.slice(0, j), lib_prefix);\n                                    if f_name.slice(0, j) == lib_prefix {\n                                        result_filename = Some(p_path.clone());\n                                    }\n@@ -265,15 +265,15 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     } // for\n \n     if result_filename.is_none() {\n-        debug!(\"warning: library_in_workspace didn't find a library in %s for %s\",\n+        debug2!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n                   dir_to_search.to_str(), short_name);\n     }\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n         let absolute_path = dir_to_search.push_rel(result_filename);\n-        debug!(\"result_filename = %s\", absolute_path.to_str());\n+        debug2!(\"result_filename = {}\", absolute_path.to_str());\n         absolute_path\n     };\n \n@@ -295,8 +295,8 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n     if !os::path_is_dir(workspace) {\n         cond.raise(((*workspace).clone(),\n-                    fmt!(\"Workspace supplied to target_library_in_workspace \\\n-                          is not a directory! %s\", workspace.to_str())));\n+                    format!(\"Workspace supplied to target_library_in_workspace \\\n+                             is not a directory! {}\", workspace.to_str())));\n     }\n     target_file_in_workspace(pkgid, workspace, Lib, Install)\n }\n@@ -333,8 +333,8 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n-        cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n-            create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n+        cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n+            create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n             subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n     }\n     mk_output_path(what, where, pkgid, result)\n@@ -347,22 +347,22 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n     let mut result = target_build_dir(workspace);\n     result = result.push_rel(&pkgid.path);\n-    debug!(\"Creating build dir %s for package id %s\", result.to_str(),\n+    debug2!(\"Creating build dir {} for package id {}\", result.to_str(),\n            pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }\n     else {\n-        cond.raise((result, fmt!(\"Could not create directory for package %s\", pkgid.to_str())))\n+        cond.raise((result, format!(\"Could not create directory for package {}\", pkgid.to_str())))\n     }\n }\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n                       pkg_id: &PkgId, workspace: Path) -> Path {\n-    let short_name_with_version = fmt!(\"%s-%s\", pkg_id.short_name,\n-                                       pkg_id.version.to_str());\n+    let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n+                                          pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n@@ -371,14 +371,14 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // and if we're just building, it goes in a package-specific subdir\n         Build => workspace.push_rel(&pkg_id.path)\n     };\n-    debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n+    debug2!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n            dir.to_str());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.push(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.push(fmt!(\"%s%s%s\", pkg_id.short_name,\n+        _ => dir.push(format!(\"{}{}{}\", pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -389,7 +389,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     if !output_path.is_absolute() {\n         output_path = os::getcwd().push_rel(&output_path).normalize();\n     }\n-    debug!(\"mk_output_path: returning %s\", output_path.to_str());\n+    debug2!(\"mk_output_path: returning {}\", output_path.to_str());\n     output_path\n }\n \n@@ -407,7 +407,7 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n         did_something = true;\n     }\n     if !did_something {\n-        warn(fmt!(\"Warning: there don't seem to be any files for %s installed in %s\",\n+        warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n              pkgid.to_str(), workspace.to_str()));\n     }\n \n@@ -425,14 +425,14 @@ pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n         if dir.is_parent_of(&p.path) || dir.is_parent_of(&versionize(&p.path, &p.version)) {\n-            debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());\n+            debug2!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.to_str());\n             if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n                 || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n-                debug!(\"Did find id %s in dir %s\", p.to_str(), dir.to_str());\n+                debug2!(\"Did find id {} in dir {}\", p.to_str(), dir.to_str());\n                 return Some(dir.clone());\n             }\n         }\n-        debug!(\"Didn't find id %s in dir %s\", p.to_str(), dir.to_str())\n+        debug2!(\"Didn't find id {} in dir {}\", p.to_str(), dir.to_str())\n     }\n     None\n }\n@@ -449,7 +449,7 @@ pub fn user_set_rust_path() -> bool {\n /// Append the version string onto the end of the path's filename\n fn versionize(p: &Path, v: &Version) -> Path {\n     let q = p.file_path().to_str();\n-    p.with_filename(fmt!(\"%s-%s\", q, v.to_str()))\n+    p.with_filename(format!(\"{}-{}\", q, v.to_str()))\n }\n \n "}, {"sha": "1ece56df60a3e5a04f5e1fa7ceb03bc91eb08054", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -102,7 +102,7 @@ impl<'self> PkgScript<'self> {\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n-        debug!(\"pkgscript parse: %s\", sysroot.to_str());\n+        debug2!(\"pkgscript parse: {}\", sysroot.to_str());\n         let options = @session::options {\n             binary: binary,\n             maybe_sysroot: Some(sysroot),\n@@ -118,7 +118,7 @@ impl<'self> PkgScript<'self> {\n         let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n-        debug!(\"Returning package script with id %s\", id.to_str());\n+        debug2!(\"Returning package script with id {}\", id.to_str());\n \n         PkgScript {\n             id: id,\n@@ -138,10 +138,10 @@ impl<'self> PkgScript<'self> {\n                   sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n-        debug!(\"Working directory = %s\", self.build_dir.to_str());\n+        debug2!(\"Working directory = {}\", self.build_dir.to_str());\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate.take_unwrap());\n-        debug!(\"Building output filenames with script name %s\",\n+        debug2!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n@@ -150,7 +150,7 @@ impl<'self> PkgScript<'self> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug!(\"Running program: %s %s %s\", exe.to_str(),\n+        debug2!(\"Running program: {} {} {}\", exe.to_str(),\n                sysroot.to_str(), \"install\");\n         // Discover the output\n         exec.discover_output(\"binary\", exe.to_str(), digest_only_date(&exe));\n@@ -160,7 +160,7 @@ impl<'self> PkgScript<'self> {\n             return (~[], status);\n         }\n         else {\n-            debug!(\"Running program (configs): %s %s %s\",\n+            debug2!(\"Running program (configs): {} {} {}\",\n                    exe.to_str(), sysroot.to_str(), \"configs\");\n             let output = run::process_output(exe.to_str(), [sysroot.to_str(), ~\"configs\"]);\n             // Run the configs() function to get the configs\n@@ -223,7 +223,7 @@ impl CtxMethods for BuildContext {\n             let pkgid = PkgId::new(args[0].clone());\n             let mut dest_ws = None;\n             do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n-                debug!(\"found pkg %s in workspace %s, trying to build\",\n+                debug2!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.to_str());\n                 let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n                 dest_ws = Some(self.build(&mut pkg_src, what));\n@@ -290,7 +290,7 @@ impl CtxMethods for BuildContext {\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n-                    debug!(\"package ID = %s, found it in %? workspaces\",\n+                    debug2!(\"package ID = {}, found it in {:?} workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n@@ -349,15 +349,16 @@ impl CtxMethods for BuildContext {\n \n                 let pkgid = PkgId::new(args[0]);\n                 if !installed_packages::package_is_installed(&pkgid) {\n-                    warn(fmt!(\"Package %s doesn't seem to be installed! Doing nothing.\", args[0]));\n+                    warn(format!(\"Package {} doesn't seem to be installed! \\\n+                                  Doing nothing.\", args[0]));\n                     return;\n                 }\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n                     do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n-                        note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n+                        note(format!(\"Uninstalled package {} (was installed in {})\",\n                                   pkgid.to_str(), workspace.to_str()));\n                         true\n                     };\n@@ -370,13 +371,13 @@ impl CtxMethods for BuildContext {\n \n                 self.unprefer(args[0], None);\n             }\n-            _ => fail!(fmt!(\"I don't know the command `%s`\", cmd))\n+            _ => fail2!(\"I don't know the command `{}`\", cmd)\n         }\n     }\n \n     fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n         // stub\n-        fail!(\"`do` not yet implemented\");\n+        fail2!(\"`do` not yet implemented\");\n     }\n \n     /// Returns the destination workspace\n@@ -387,8 +388,8 @@ impl CtxMethods for BuildContext {\n         let workspace = pkg_src.workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n-        debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n-                pkgid = %s pkgsrc start_dir = %s\", workspace.to_str(),\n+        debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n+                pkgid = {} pkgsrc start_dir = {}\", workspace.to_str(),\n                in_rust_path(&workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.to_str());\n \n@@ -399,16 +400,16 @@ impl CtxMethods for BuildContext {\n             source_control::git_clone(&workspace.push_rel(&pkgid.path),\n                                       &out_dir, &pkgid.version);\n             let default_ws = default_workspace();\n-            debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n+            debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.to_str(),\n                    pkgid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws, false, pkgid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n         let mut custom = false;\n-        debug!(\"Package source directory = %s\", pkg_src.to_str());\n+        debug2!(\"Package source directory = {}\", pkg_src.to_str());\n         let opt = pkg_src.package_script_option();\n-        debug!(\"Calling pkg_script_option on %?\", opt);\n+        debug2!(\"Calling pkg_script_option on {:?}\", opt);\n         let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n                 let sysroot = self.sysroot_to_use();\n@@ -428,16 +429,16 @@ impl CtxMethods for BuildContext {\n                         pscript.run_custom(exec, &sub_sysroot)\n                     }\n                 };\n-                debug!(\"Command return code = %?\", hook_result);\n+                debug2!(\"Command return code = {:?}\", hook_result);\n                 if hook_result != 0 {\n-                    fail!(\"Error running custom build command\")\n+                    fail2!(\"Error running custom build command\")\n                 }\n                 custom = true;\n                 // otherwise, the package script succeeded\n                 cfgs\n             }\n             None => {\n-                debug!(\"No package script, continuing\");\n+                debug2!(\"No package script, continuing\");\n                 ~[]\n             }\n         } + self.context.cfgs;\n@@ -454,7 +455,7 @@ impl CtxMethods for BuildContext {\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n-                    debug!(\"JustOne: p = %s\", p.to_str());\n+                    debug2!(\"JustOne: p = {}\", p.to_str());\n                     assert!(os::path_exists(&pkg_src.start_dir.push_rel(p)));\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n@@ -465,7 +466,7 @@ impl CtxMethods for BuildContext {\n                     } else if is_bench(p) {\n                         PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n                     } else {\n-                        warn(fmt!(\"Not building any crates for dependency %s\", p.to_str()));\n+                        warn(format!(\"Not building any crates for dependency {}\", p.to_str()));\n                         return workspace.clone();\n                     }\n                 }\n@@ -486,19 +487,19 @@ impl CtxMethods for BuildContext {\n         // Do something reasonable for now\n \n         let dir = build_pkg_id_in_workspace(id, workspace);\n-        note(fmt!(\"Cleaning package %s (removing directory %s)\",\n+        note(format!(\"Cleaning package {} (removing directory {})\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n             os::remove_dir_recursive(&dir);\n-            note(fmt!(\"Removed directory %s\", dir.to_str()));\n+            note(format!(\"Removed directory {}\", dir.to_str()));\n         }\n \n-        note(fmt!(\"Cleaned package %s\", id.to_str()));\n+        note(format!(\"Cleaned package {}\", id.to_str()));\n     }\n \n     fn info(&self) {\n         // stub\n-        fail!(\"info not yet implemented\");\n+        fail2!(\"info not yet implemented\");\n     }\n \n     fn install(&self, mut pkg_src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]) {\n@@ -514,11 +515,11 @@ impl CtxMethods for BuildContext {\n \n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n-        debug!(\"In declare inputs for %s\", id.to_str());\n+        debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = pkg_src.start_dir.push_rel(&c.file).normalize();\n-                debug!(\"Recording input: %s\", path.to_str());\n+                debug2!(\"Recording input: {}\", path.to_str());\n                 installed_files.push(path);\n             }\n         }\n@@ -532,15 +533,15 @@ impl CtxMethods for BuildContext {\n             else {\n             Path(destination_workspace)\n         };\n-        debug!(\"install: destination workspace = %s, id = %s, installing to %s\",\n+        debug2!(\"install: destination workspace = {}, id = {}, installing to {}\",\n                destination_workspace, id.to_str(), actual_workspace.to_str());\n         let result = self.install_no_build(&Path(destination_workspace),\n                                            &actual_workspace,\n                                            &id).map(|s| Path(*s));\n-        debug!(\"install: id = %s, about to call discover_outputs, %?\",\n+        debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.to_str());\n         installed_files = installed_files + result;\n-        note(fmt!(\"Installed package %s to %s\", id.to_str(), actual_workspace.to_str()));\n+        note(format!(\"Installed package {} to {}\", id.to_str(), actual_workspace.to_str()));\n         (installed_files, inputs)\n     }\n \n@@ -557,8 +558,8 @@ impl CtxMethods for BuildContext {\n         let target_exec = target_executable_in_workspace(id, target_workspace);\n         let target_lib = maybe_library.map(|_p| target_library_in_workspace(id, target_workspace));\n \n-        debug!(\"target_exec = %s target_lib = %? \\\n-               maybe_executable = %? maybe_library = %?\",\n+        debug2!(\"target_exec = {} target_lib = {:?} \\\n+               maybe_executable = {:?} maybe_library = {:?}\",\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n@@ -582,7 +583,7 @@ impl CtxMethods for BuildContext {\n                 let mut outputs = ~[];\n \n                 for exec in subex.iter() {\n-                    debug!(\"Copying: %s -> %s\", exec.to_str(), sub_target_ex.to_str());\n+                    debug2!(\"Copying: {} -> {}\", exec.to_str(), sub_target_ex.to_str());\n                     if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n                          os::copy_file(exec, &sub_target_ex)) {\n                         cond.raise(((*exec).clone(), sub_target_ex.clone()));\n@@ -594,11 +595,11 @@ impl CtxMethods for BuildContext {\n                 }\n                 for lib in sublib.iter() {\n                     let target_lib = sub_target_lib\n-                        .clone().expect(fmt!(\"I built %s but apparently \\\n+                        .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.to_str()));\n                     let target_lib = target_lib\n                         .pop().push(lib.filename().expect(\"weird target lib\"));\n-                    debug!(\"Copying: %s -> %s\", lib.to_str(), sub_target_lib.to_str());\n+                    debug2!(\"Copying: {} -> {}\", lib.to_str(), sub_target_lib.to_str());\n                     if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));\n@@ -614,18 +615,18 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"prefer not yet implemented\");\n+        fail2!(\"prefer not yet implemented\");\n     }\n \n     fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n         match built_test_in_workspace(pkgid, workspace) {\n             Some(test_exec) => {\n-                debug!(\"test: test_exec = %s\", test_exec.to_str());\n+                debug2!(\"test: test_exec = {}\", test_exec.to_str());\n                 let status = run::process_status(test_exec.to_str(), [~\"--test\"]);\n                 os::set_exit_status(status);\n             }\n             None => {\n-                error(fmt!(\"Internal error: test executable for package ID %s in workspace %s \\\n+                error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n                            wasn't built! Please report this as a bug.\",\n                            pkgid.to_str(), workspace.to_str()));\n             }\n@@ -640,11 +641,11 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"uninstall not yet implemented\");\n+        fail2!(\"uninstall not yet implemented\");\n     }\n \n     fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"unprefer not yet implemented\");\n+        fail2!(\"unprefer not yet implemented\");\n     }\n }\n \n@@ -677,7 +678,7 @@ pub fn main_args(args: &[~str]) -> int {\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            error(fmt!(\"%s\", f.to_err_msg()));\n+            error(format!(\"{}\", f.to_err_msg()));\n \n             return 1;\n         }\n@@ -812,8 +813,8 @@ pub fn main_args(args: &[~str]) -> int {\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug!(\"Using sysroot: %s\", sroot.to_str());\n-    debug!(\"Will store workcache in %s\", default_workspace().to_str());\n+    debug2!(\"Using sysroot: {}\", sroot.to_str());\n+    debug2!(\"Will store workcache in {}\", default_workspace().to_str());\n \n     let rm_args = remaining_args.clone();\n     let sub_cmd = cmd.clone();"}, {"sha": "f0042e1f8e2d71991086b0aeddc1c36ec7b48688", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -17,7 +17,8 @@ use version::Version;\n /// FIXME #8711: This ignores the desired version.\n pub fn find_installed_library_in_rust_path(pkg_path: &Path, _version: &Version) -> Option<Path> {\n     let rp = rust_path();\n-    debug!(\"find_installed_library_in_rust_path: looking for path %s\", pkg_path.to_str());\n+    debug2!(\"find_installed_library_in_rust_path: looking for path {}\",\n+            pkg_path.to_str());\n     for p in rp.iter() {\n         match installed_library_in_workspace(pkg_path, p) {\n             Some(path) => return Some(path),"}, {"sha": "3d03d89bc20ab10845bcb30dcdaaec3dd725b1a8", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -19,26 +19,26 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     assert!(os::path_is_dir(source));\n     assert!(is_git_dir(source));\n     if !os::path_exists(target) {\n-        debug!(\"Running: git clone %s %s\", source.to_str(), target.to_str());\n+        debug2!(\"Running: git clone {} {}\", source.to_str(), target.to_str());\n         let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n         if outp.status != 0 {\n             io::println(str::from_utf8_owned(outp.output.clone()));\n             io::println(str::from_utf8_owned(outp.error));\n-            fail!(\"Couldn't `git clone` %s\", source.to_str());\n+            fail2!(\"Couldn't `git clone` {}\", source.to_str());\n         }\n         else {\n             match v {\n                 &ExactRevision(ref s) => {\n-                    debug!(\"`Running: git --work-tree=%s --git-dir=%s checkout %s\",\n+                    debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                            *s, target.to_str(), target.push(\".git\").to_str());\n                     let outp = run::process_output(\"git\",\n-                                   [fmt!(\"--work-tree=%s\", target.to_str()),\n-                                    fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n-                                    ~\"checkout\", fmt!(\"%s\", *s)]);\n+                                   [format!(\"--work-tree={}\", target.to_str()),\n+                                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                                    ~\"checkout\", format!(\"{}\", *s)]);\n                     if outp.status != 0 {\n                         io::println(str::from_utf8_owned(outp.output.clone()));\n                         io::println(str::from_utf8_owned(outp.error));\n-                        fail!(\"Couldn't `git checkout %s` in %s\",\n+                        fail2!(\"Couldn't `git checkout {}` in {}\",\n                               *s, target.to_str());\n                     }\n                 }\n@@ -50,11 +50,12 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n         // Check that no version was specified. There's no reason to not handle the\n         // case where a version was requested, but I haven't implemented it.\n         assert!(*v == NoVersion);\n-        debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n+        debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                target.to_str(), target.push(\".git\").to_str(), source.to_str());\n-        let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),\n-                                               fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n-                                               ~\"pull\", ~\"--no-edit\", source.to_str()]);\n+        let args = [format!(\"--work-tree={}\", target.to_str()),\n+                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                    ~\"pull\", ~\"--no-edit\", source.to_str()];\n+        let outp = run::process_output(\"git\", args);\n         assert!(outp.status == 0);\n     }\n }\n@@ -64,18 +65,18 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n     let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n     if outp.status != 0 {\n-         debug!(str::from_utf8_owned(outp.output.clone()));\n-         debug!(str::from_utf8_owned(outp.error));\n+         debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+         debug2!(\"{}\", str::from_utf8_owned(outp.error));\n          false\n     }\n     else {\n         match v {\n             &ExactRevision(ref s) | &Tagged(ref s) => {\n-                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", fmt!(\"%s\", *s)],\n+                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", format!(\"{}\", *s)],\n                                                          target);\n                     if outp.status != 0 {\n-                        debug!(str::from_utf8_owned(outp.output.clone()));\n-                        debug!(str::from_utf8_owned(outp.error));\n+                        debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+                        debug2!(\"{}\", str::from_utf8_owned(outp.error));\n                         false\n                     }\n                     else {"}, {"sha": "5b56c312226c051b25f6916a2d7a2a1f1b9b2854", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 104, "deletions": 101, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -91,24 +91,24 @@ fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> Path {\n \n fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n-    let package_dir = workspace.push_many([~\"src\", fmt!(\"%s-%s\",\n-                                                      short_name.to_str(), version.to_str())]);\n+    let package_dir = workspace.push_many([~\"src\", format!(\"{}-{}\",\n+                                                short_name.to_str(), version.to_str())]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n-                          version, \"temp_workspace\").push_many([~\"src\", fmt!(\"%s-%s\",\n+                          version, \"temp_workspace\").push_many([~\"src\", format!(\"{}-{}\",\n                                                             short_name.to_str(),\n                                                             version.to_str())]);\n \n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n-    debug!(\"mk_workspace: creating %s\", package_dir.to_str());\n+    debug2!(\"mk_workspace: creating {}\", package_dir.to_str());\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -134,7 +134,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n     });\n     let rslt = prog.finish_with_output();\n     if rslt.status != 0 {\n-        fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n+        fail2!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n            rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n     }\n }\n@@ -147,13 +147,13 @@ fn init_git_repo(p: &Path) -> Path {\n     let work_dir = tmp.push_rel(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n-    debug!(\"Running: git init in %s\", work_dir.to_str());\n+    debug2!(\"Running: git init in {}\", work_dir.to_str());\n     let ws = work_dir.to_str();\n     run_git([~\"init\"], None, &work_dir_for_opts,\n-        fmt!(\"Couldn't initialize git repository in %s\", ws));\n+        format!(\"Couldn't initialize git repository in {}\", ws));\n     // Add stuff to the dir so that git tag succeeds\n     writeFile(&work_dir.push(\"README\"), \"\");\n-    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, fmt!(\"Couldn't add in %s\", ws));\n+    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\", ws));\n     git_commit(&work_dir_for_opts, ~\"whatever\");\n     tmp\n }\n@@ -165,19 +165,19 @@ fn add_all_and_commit(repo: &Path) {\n \n fn git_commit(repo: &Path, msg: ~str) {\n     run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n-            None, repo, fmt!(\"Couldn't commit in %s\", repo.to_str()));\n+            None, repo, format!(\"Couldn't commit in {}\", repo.to_str()));\n }\n \n fn git_add_all(repo: &Path) {\n-    run_git([~\"add\", ~\"-A\"], None, repo, fmt!(\"Couldn't add all files in %s\", repo.to_str()));\n+    run_git([~\"add\", ~\"-A\"], None, repo, format!(\"Couldn't add all files in {}\", repo.to_str()));\n }\n \n fn add_git_tag(repo: &Path, tag: ~str) {\n     assert!(repo.is_absolute());\n     git_add_all(repo);\n     git_commit(repo, ~\"whatever\");\n     run_git([~\"tag\", tag.clone()], None, repo,\n-            fmt!(\"Couldn't add git tag %s in %s\", tag, repo.to_str()));\n+            format!(\"Couldn't add git tag {} in {}\", tag, repo.to_str()));\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -214,15 +214,15 @@ fn rustpkg_exec() -> Path {\n             second_try\n         }\n         else {\n-            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n+            fail2!(\"in rustpkg test, can't find an installed rustpkg\");\n         }\n     }\n }\n \n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     match command_line_test_with_env(args, cwd, None) {\n         Success(r) => r,\n-        _ => fail!(\"Command line test failed\")\n+        _ => fail2!(\"Command line test failed\")\n     }\n }\n \n@@ -242,10 +242,10 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     -> ProcessResult {\n     let cmd = rustpkg_exec().to_str();\n     let env_str = match env {\n-        Some(ref pairs) => pairs.map(|&(ref k, ref v)| { fmt!(\"%s=%s\", *k, *v) }).connect(\",\"),\n+        Some(ref pairs) => pairs.map(|&(ref k, ref v)| { format!(\"{}={}\", *k, *v) }).connect(\",\"),\n         None        => ~\"\"\n     };\n-    debug!(\"%s cd %s; %s %s\", env_str, cwd.to_str(), cmd, args.connect(\" \"));\n+    debug2!(\"{} cd {}; {} {}\", env_str, cwd.to_str(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -256,7 +256,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         err_fd: None\n     });\n     let output = prog.finish_with_output();\n-    debug!(\"Output from command %s with args %? was %s {%s}[%?]\",\n+    debug2!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n@@ -267,7 +267,7 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        debug!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n+        debug2!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n         Fail(output.status)\n@@ -279,7 +279,7 @@ to make sure the command succeeded\n \n fn create_local_package(pkgid: &PkgId) -> Path {\n     let parent_dir = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n+    debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.to_str());\n     parent_dir.pop().pop()\n }\n \n@@ -289,7 +289,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n \n     // Create main, lib, test, and bench files\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -305,7 +305,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n }\n \n fn create_local_package_with_test(pkgid: &PkgId) -> Path {\n-    debug!(\"Dry run -- would create package %s with test\");\n+    debug2!(\"Dry run -- would create package {:?} with test\", pkgid);\n     create_local_package(pkgid) // Already has tests???\n }\n \n@@ -314,7 +314,7 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n     create_local_package_in(subord_pkgid, &package_dir);\n     // Write a main.rs file into pkgid that references subord_pkgid\n     writeFile(&package_dir.push_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n-              fmt!(\"extern mod %s;\\nfn main() {}\",\n+              format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n                    subord_pkgid.short_name));\n     // Write a lib.rs file into subord_pkgid that has something in it\n     writeFile(&package_dir.push_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n@@ -324,7 +324,7 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n \n fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n                                                custom_build_hook: &str) -> Path {\n-    debug!(\"Dry run -- would create package %s with custom build hook %s\",\n+    debug2!(\"Dry run -- would create package {} with custom build hook {}\",\n            pkgid.to_str(), custom_build_hook);\n     create_local_package(pkgid)\n     // actually write the pkg.rs with the custom build hook\n@@ -336,9 +336,9 @@ fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n }\n \n fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n-    debug!(\"assert_lib_exists: repo = %s, pkg_path = %s\", repo.to_str(), pkg_path.to_str());\n+    debug2!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.to_str(), pkg_path.to_str());\n     let lib = installed_library_in_workspace(pkg_path, repo);\n-    debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n+    debug2!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         os::path_exists(libname) && is_rwx(libname)\n@@ -350,13 +350,13 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     os::path_exists(&exec) && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"test_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n         os::path_exists(exec) && is_rwx(exec)\n@@ -375,7 +375,8 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n+            repo.to_str(), short_name);\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n@@ -409,15 +410,15 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n     os::path_exists(&target_build_dir(repo).push_many([short_name.to_owned(),\n-                                     fmt!(\"%s.%s\", short_name, extension)]))\n+                                     format!(\"{}.{}\", short_name, extension)]))\n }\n \n fn assert_built_library_exists(repo: &Path, short_name: &str) {\n     assert!(built_library_exists(repo, short_name));\n }\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_library_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -439,7 +440,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     let mut result = ~[];\n     let p_output = match command_line_test_with_env(args,\n         &os::getcwd(), Some(env)) {\n-        Fail(_) => fail!(\"Command-line test failed\"),\n+        Fail(_) => fail2!(\"Command-line test failed\"),\n         Success(r) => r\n     };\n     let test_output = str::from_utf8(p_output.output);\n@@ -451,7 +452,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n \n // assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    debug!(\"lib_output_file_name: given %s and short name %s\",\n+    debug2!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.to_str(), short_name);\n     library_in_workspace(&Path(short_name),\n                          short_name,\n@@ -462,7 +463,7 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).push(short_name).push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n+    target_build_dir(workspace).push(short_name).push(format!(\"{}{}\", short_name, os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n@@ -485,20 +486,20 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     let pkg_src_dir = workspace.push_many([~\"src\", pkgid.to_str()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.push(filename);\n-    debug!(\"Trying to frob %s -- %s\", pkg_src_dir.to_str(), filename);\n+    debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.to_str(), filename);\n     if os::path_exists(&maybe_file) {\n         maybe_p = Some(maybe_file);\n     }\n-    debug!(\"Frobbed? %?\", maybe_p);\n+    debug2!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n             let w = io::file_writer(p, &[io::Append]);\n             match w {\n-                Err(s) => { let _ = cond.raise((p.clone(), fmt!(\"Bad path: %s\", s))); }\n+                Err(s) => { let _ = cond.raise((p.clone(), format!(\"Bad path: {}\", s))); }\n                 Ok(w)  => w.write_line(\"/* hi */\")\n             }\n         }\n-        None => fail!(fmt!(\"frob_source_file failed to find a source file in %s\",\n+        None => fail2!(format!(\"frob_source_file failed to find a source file in {}\",\n                            pkg_src_dir.to_str()))\n     }\n }\n@@ -509,7 +510,7 @@ fn test_make_dir_rwx() {\n     let dir = temp.push(\"quux\");\n     assert!(!os::path_exists(&dir) ||\n             os::remove_dir_recursive(&dir));\n-    debug!(\"Trying to make %s\", dir.to_str());\n+    debug2!(\"Trying to make {}\", dir.to_str());\n     assert!(make_dir_rwx(&dir));\n     assert!(os::path_is_dir(&dir));\n     assert!(is_rwx(&dir));\n@@ -521,29 +522,29 @@ fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n     let sysroot = test_sysroot();\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n+    debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = fake_pkg();\n     let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n-    debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n+    debug2!(\"temp_workspace = {}\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(), false, temp_pkg_id.clone());\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n-    debug!(\"exec = %s\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, &temp_workspace);\n-    debug!(\"lib = %?\", lib);\n+    debug2!(\"lib = {:?}\", lib);\n     assert!(lib.map_default(false, |l| os::path_exists(l)));\n     assert!(lib.map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n-    debug!(\"bench = %s\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -568,12 +569,12 @@ fn test_install_invalid() {\n #[test]\n fn test_install_git() {\n     let sysroot = test_sysroot();\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n+    debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n-    debug!(\"repo = %s\", repo.to_str());\n+    debug2!(\"repo = {}\", repo.to_str());\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    debug!(\"repo_subdir = %s\", repo_subdir.to_str());\n+    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n \n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -585,15 +586,15 @@ fn test_install_git() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    debug!(\"test_install_git: calling rustpkg install %s in %s\",\n+    debug2!(\"test_install_git: calling rustpkg install {} in {}\",\n            temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n     command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n     let ws = repo.push(\".rust\");\n     // Check that all files exist\n-    debug!(\"Checking for files in %s\", ws.to_str());\n+    debug2!(\"Checking for files in {}\", ws.to_str());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"exec = %s\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n@@ -609,9 +610,9 @@ fn test_install_git() {\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n-    debug!(\"test = %s\", test.to_str());\n+    debug2!(\"test = {}\", test.to_str());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"bench = %s\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -661,7 +662,7 @@ fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -681,7 +682,7 @@ fn test_package_version() {\n     // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n                                              &ws) {\n-        Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n+        Some(p) => p.to_str().ends_with(format!(\"0.4{}\", os::consts::DLL_SUFFIX)),\n         None    => false\n     });\n     assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n@@ -696,7 +697,7 @@ fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -710,12 +711,12 @@ fn test_package_request_version() {\n     writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-    command_line_test([~\"install\", fmt!(\"%s#0.3\", local_path)], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], &repo);\n \n     assert!(match installed_library_in_workspace(&Path(\"test_pkg_version\"), &repo.push(\".rust\")) {\n         Some(p) => {\n-            debug!(\"installed: %s\", p.to_str());\n-            p.to_str().ends_with(fmt!(\"0.3%s\", os::consts::DLL_SUFFIX))\n+            debug2!(\"installed: {}\", p.to_str());\n+            p.to_str().ends_with(format!(\"0.3{}\", os::consts::DLL_SUFFIX))\n         }\n         None    => false\n     });\n@@ -746,7 +747,7 @@ fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n     let package_dir = foo_repo.push(\"foo\");\n \n-    debug!(\"Writing files in: %s\", package_dir.to_str());\n+    debug2!(\"Writing files in: {}\", package_dir.to_str());\n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&package_dir.push(\"lib.rs\"),\n@@ -772,13 +773,13 @@ fn rustpkg_local_pkg() {\n #[ignore (reason = \"test makes bogus assumptions about build directory layout: issue #8690\")]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push_many(\n         [~\"src\", ~\"librustpkg\", ~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n-    debug!(\"package_script_with_default_build: %s\", source.to_str());\n+    debug2!(\"package_script_with_default_build: {}\", source.to_str());\n     if !os::copy_file(&source,\n                       &dir.push_many([~\"src\", ~\"fancy-lib-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n+        fail2!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n     assert_lib_exists(&dir, &Path(\"fancy-lib\"), NoVersion);\n@@ -794,7 +795,7 @@ fn rustpkg_build_no_arg() {\n \n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"build_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"build_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n }\n@@ -808,7 +809,7 @@ fn rustpkg_install_no_arg() {\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     writeFile(&package_dir.push(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"install_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"install_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"install\"], &package_dir);\n     assert_lib_exists(&tmp, &Path(\"foo\"), NoVersion);\n }\n@@ -822,7 +823,7 @@ fn rustpkg_clean_no_arg() {\n \n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"clean_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"clean_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n@@ -834,11 +835,11 @@ fn rustpkg_clean_no_arg() {\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n-    debug!(\"cwd = %s\", cwd.to_str());\n+    debug2!(\"cwd = {}\", cwd.to_str());\n                                      // use command_line_test_with_env\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n@@ -944,7 +945,7 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail!(\"package %s appears in `list` output more than once\", p.path.to_str());\n+            fail2!(\"package {} appears in `list` output more than once\", p.path.to_str());\n         }\n         else {\n             contents.push((*p).clone());\n@@ -983,8 +984,8 @@ fn no_rebuilding_dep() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], &workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n-        Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n+        Fail(status) if status == 65 => fail2!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n+        Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n     }\n \n     let bar_date_2 = datestamp(&lib_output_file_name(&workspace,\n@@ -1001,11 +1002,11 @@ fn do_rebuild_dep_dates_change() {\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_lib_name = lib_output_file_name(&workspace, \"bar\");\n     let bar_date = datestamp(&bar_lib_name);\n-    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), bar_date);\n     touch_source_file(&workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let new_bar_date = datestamp(&bar_lib_name);\n-    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), new_bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), new_bar_date);\n     assert!(new_bar_date > bar_date);\n }\n \n@@ -1074,7 +1075,7 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.path.to_str())], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path.to_str())], &repo);\n     let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n                                 \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n@@ -1119,7 +1120,7 @@ fn test_extern_mod() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail!(\"output was %s, error was %s\",\n+        fail2!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1149,7 +1150,7 @@ fn test_extern_mod_simpler() {\n     let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n     let rustc = rustpkg_exec.with_filename(\"rustc\");\n-    debug!(\"RUST_PATH=%s %s %s \\n --sysroot %s -o %s\",\n+    debug2!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n                      lib_depend_dir.to_str(),\n                      rustc.to_str(),\n                      main_file.to_str(),\n@@ -1168,7 +1169,7 @@ fn test_extern_mod_simpler() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail!(\"output was %s, error was %s\",\n+        fail2!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1182,8 +1183,8 @@ fn test_import_rustpkg() {\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n+    debug2!(\"workspace = {}\", workspace.to_str());\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1192,10 +1193,10 @@ fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n-              \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n+              \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n+    debug2!(\"workspace = {}\", workspace.to_str());\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1207,11 +1208,11 @@ fn multiple_workspaces() {\n // Make a third package that uses foo, make sure we can build/install it\n     let a_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n     let b_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n-    debug!(\"Trying to install foo in %s\", a_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", a_loc.to_str());\n     command_line_test([~\"install\", ~\"foo\"], &a_loc);\n-    debug!(\"Trying to install foo in %s\", b_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", b_loc.to_str());\n     command_line_test([~\"install\", ~\"foo\"], &b_loc);\n-    let env = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", a_loc.to_str(), b_loc.to_str()))]);\n+    let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.to_str(), b_loc.to_str()))]);\n     let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n     command_line_test_with_env([~\"install\", ~\"bar\"], &c_loc, env);\n }\n@@ -1229,7 +1230,9 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let workspace = create_local_package(&p_id);\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\",\n-       fmt!(\"%s:%s\", dest_workspace.to_str(), workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+       format!(\"{}:{}\",\n+               dest_workspace.to_str(),\n+               workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], &dest_workspace, rust_path);\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n@@ -1272,7 +1275,7 @@ fn rust_path_hack_cwd() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!lib_exists(&cwd, &Path(\"foo\"), NoVersion));\n@@ -1291,7 +1294,7 @@ fn rust_path_hack_multi_path() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug!(\"Checking that %s exists in %s\", name, dest_workspace.to_str());\n+   debug2!(\"Checking that {} exists in {}\", name, dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"quux\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, name);\n    assert!(!lib_exists(&subdir, &Path(\"quux\"), NoVersion));\n@@ -1309,7 +1312,7 @@ fn rust_path_hack_install_no_arg() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!lib_exists(&source_dir, &Path(\"foo\"), NoVersion));\n@@ -1327,7 +1330,7 @@ fn rust_path_hack_build_no_arg() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n@@ -1337,13 +1340,13 @@ fn rust_path_install_target() {\n     let dir_for_path = mkdtemp(&os::tmpdir(),\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n     let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = mkdtemp(&os::tmpdir(),\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n     let dir = dir.pop().pop();\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dir_to_install_to.to_str(),\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dir_to_install_to.to_str(),\n                                                dir.to_str()))]);\n     let cwd = os::getcwd();\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n@@ -1491,7 +1494,7 @@ fn test_cfg_fail() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       &workspace) {\n-        Success(*) => fail!(\"test_cfg_fail failed\"),\n+        Success(*) => fail2!(\"test_cfg_fail failed\"),\n         _          => ()\n     }\n }\n@@ -1627,7 +1630,7 @@ fn pkgid_pointing_to_subdir() {\n     writeFile(&foo_dir.push(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.push(\"lib.rs\"), \"pub fn g() {}\");\n \n-    debug!(\"Creating a file in %s\", workspace.to_str());\n+    debug2!(\"Creating a file in {}\", workspace.to_str());\n     let testpkg_dir = workspace.push_many([~\"src\", ~\"testpkg-0.1\"]);\n     assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n \n@@ -1654,7 +1657,7 @@ fn test_recursive_deps() {\n     writeFile(&b_workspace.push(\"src\").push(\"b-0.1\").push(\"lib.rs\"),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.to_str())]);\n-    debug!(\"RUST_PATH=%s\", b_workspace.to_str());\n+    debug2!(\"RUST_PATH={}\", b_workspace.to_str());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                &a_workspace,\n                                environment);\n@@ -1669,9 +1672,9 @@ fn test_install_to_rust_path() {\n     let second_workspace = create_local_package(&p_id);\n     let first_workspace = mk_empty_workspace(&Path(\"p\"), &NoVersion, \"dest\");\n     let rust_path = Some(~[(~\"RUST_PATH\",\n-                            fmt!(\"%s:%s\", first_workspace.to_str(),\n+                            format!(\"{}:{}\", first_workspace.to_str(),\n                                  second_workspace.to_str()))]);\n-    debug!(\"RUST_PATH=%s:%s\", first_workspace.to_str(), second_workspace.to_str());\n+    debug2!(\"RUST_PATH={}:{}\", first_workspace.to_str(), second_workspace.to_str());\n     command_line_test_with_env([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"foo\"],\n@@ -1782,7 +1785,7 @@ fn correct_package_name_with_rust_path_hack() {\n     writeFile(&dest_workspace.push_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dest_workspace.to_str(),\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.to_str(),\n                         foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n     // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n     command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n@@ -1833,9 +1836,9 @@ fn test_rebuild_when_needed() {\n     frob_source_file(&foo_workspace, &foo_id, \"test.rs\");\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n-        Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n+        Success(*) => fail2!(\"test_rebuild_when_needed didn't rebuild\"),\n         Fail(status) if status == 65 => (), // ok\n-        Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n+        Fail(_) => fail2!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n }\n \n@@ -1852,8 +1855,8 @@ fn test_no_rebuilding() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n-        Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n+        Fail(status) if status == 65 => fail2!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n+        Fail(_) => fail2!(\"test_no_rebuilding failed for some other reason\")\n     }\n }\n "}, {"sha": "17bda88339314067bc0290874a6e5974c8bcb3ec", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -174,7 +174,7 @@ pub fn compile_input(context: &BuildContext,\n                      what: OutputType) -> Option<Path> {\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n-    debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n+    debug2!(\"compile_input: {} / {:?}\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n@@ -184,9 +184,9 @@ pub fn compile_input(context: &BuildContext,\n \n     let binary = os::args()[0].to_managed();\n \n-    debug!(\"flags: %s\", flags.connect(\" \"));\n-    debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n+    debug2!(\"flags: {}\", flags.connect(\" \"));\n+    debug2!(\"cfgs: {}\", cfgs.connect(\" \"));\n+    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -203,7 +203,7 @@ pub fn compile_input(context: &BuildContext,\n                           + context.flag_strs()\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n-    debug!(\"rustc flags: %?\", matches);\n+    debug2!(\"rustc flags: {:?}\", matches);\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n@@ -213,8 +213,8 @@ pub fn compile_input(context: &BuildContext,\n     else {\n         context.sysroot().pop().pop().pop()\n     };\n-    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n-    debug!(\"sysroot_to_use = %s\", sysroot_to_use.to_str());\n+    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n+    debug2!(\"sysroot_to_use = {}\", sysroot_to_use.to_str());\n \n     let output_type = match context.compile_upto() {\n         Assemble => link::output_type_assembly,\n@@ -262,7 +262,7 @@ pub fn compile_input(context: &BuildContext,\n \n     find_and_install_dependencies(context, pkg_id, sess, exec, &crate,\n                                   |p| {\n-                                      debug!(\"a dependency: %s\", p.to_str());\n+                                      debug2!(\"a dependency: {}\", p.to_str());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n                                       if !addl_lib_search_paths.contains(&p) {\n@@ -275,23 +275,23 @@ pub fn compile_input(context: &BuildContext,\n     // Inject the link attributes so we get the right package name and version\n     if attr::find_linkage_metas(crate.attrs).is_empty() {\n         let name_to_use = match what {\n-            Test  => fmt!(\"%stest\", pkg_id.short_name).to_managed(),\n-            Bench => fmt!(\"%sbench\", pkg_id.short_name).to_managed(),\n+            Test  => format!(\"{}test\", pkg_id.short_name).to_managed(),\n+            Bench => format!(\"{}bench\", pkg_id.short_name).to_managed(),\n             _     => pkg_id.short_name.to_managed()\n         };\n-        debug!(\"Injecting link name: %s\", name_to_use);\n+        debug2!(\"Injecting link name: {}\", name_to_use);\n         let link_options =\n             ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n               attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n             ~[attr::mk_name_value_item_str(@\"package_id\",\n                                            pkg_id.path.to_str().to_managed())];\n \n-        debug!(\"link options: %?\", link_options);\n+        debug2!(\"link options: {:?}\", link_options);\n         crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n     }\n \n-    debug!(\"calling compile_crate_from_input, workspace = %s,\n-           building_library = %?\", out_dir.to_str(), sess.building_library);\n+    debug2!(\"calling compile_crate_from_input, workspace = {},\n+           building_library = {:?}\", out_dir.to_str(), sess.building_library);\n     let result = compile_crate_from_input(in_file,\n                                           exec,\n                                           context.compile_upto(),\n@@ -305,7 +305,7 @@ pub fn compile_input(context: &BuildContext,\n     else {\n         result\n     };\n-    debug!(\"About to discover output %s\", discovered_output.to_str());\n+    debug2!(\"About to discover output {}\", discovered_output.to_str());\n     for p in discovered_output.iter() {\n         if os::path_exists(p) {\n             exec.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n@@ -330,22 +330,22 @@ pub fn compile_crate_from_input(input: &Path,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n                                 crate: ast::Crate) -> Option<Path> {\n-    debug!(\"Calling build_output_filenames with %s, building library? %?\",\n+    debug2!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.to_str(), sess.building_library);\n \n     // bad copy\n-    debug!(\"out_dir = %s\", out_dir.to_str());\n+    debug2!(\"out_dir = {}\", out_dir.to_str());\n     let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n                                                  &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n-    debug!(\"Outputs are out_filename: %s and obj_filename: %s and output type = %?\",\n+    debug2!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n            outputs.out_filename.to_str(),\n            outputs.obj_filename.to_str(),\n            sess.opts.output_type);\n-    debug!(\"additional libraries:\");\n+    debug2!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n-        debug!(\"an additional library: %s\", lib.to_str());\n+        debug2!(\"an additional library: {}\", lib.to_str());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }\n@@ -362,7 +362,7 @@ pub fn compile_crate_from_input(input: &Path,\n     // Register dependency on the source file\n     exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n \n-    debug!(\"Built %s, date = %?\", outputs.out_filename.to_str(),\n+    debug2!(\"Built {}, date = {:?}\", outputs.out_filename.to_str(),\n            datestamp(&outputs.out_filename));\n \n     Some(outputs.out_filename)\n@@ -384,10 +384,10 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> Option<Path> {\n-    debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n-    debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n+    debug2!(\"compile_crate: crate={}, workspace={}\", crate.to_str(), workspace.to_str());\n+    debug2!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n-        debug!(\"+++ %s\", *fl);\n+        debug2!(\"+++ {}\", *fl);\n     }\n     compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n@@ -403,19 +403,19 @@ struct ViewItemVisitor<'self> {\n \n impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n     fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n-        debug!(\"A view item!\");\n+        debug2!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 let lib_name = match path_opt {\n                     Some(p) => p,\n                     None => self.sess.str_of(lib_ident)\n                 };\n-                debug!(\"Finding and installing... %s\", lib_name);\n+                debug2!(\"Finding and installing... {}\", lib_name);\n                 // Check standard Rust library path first\n                 match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n-                        debug!(\"It exists: %s\", installed_path.to_str());\n+                        debug2!(\"It exists: {}\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on\n                         // installed_path\n                         // For binary files, we only hash the datestamp, not the contents.\n@@ -428,15 +428,15 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        debug!(\"Trying to install library %s, rebuilding it\",\n+                        debug2!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &pkg_id);\n                         let source_workspace = if workspaces.is_empty() {\n-                            error(fmt!(\"Couldn't find package %s \\\n-                                       in any of the workspaces in the RUST_PATH (%s)\",\n+                            error(format!(\"Couldn't find package {} \\\n+                                       in any of the workspaces in the RUST_PATH ({})\",\n                                        lib_name,\n                                        rust_path().map(|s| s.to_str()).connect(\":\")));\n                             cond.raise((pkg_id.clone(), ~\"Dependency not found\"))\n@@ -452,14 +452,14 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                              pkg_id),\n                                                  &JustOne(Path(\n                                     lib_crate_filename)));\n-                        debug!(\"Installed %s, returned %? dependencies and \\\n-                               %? transitive dependencies\",\n+                        debug2!(\"Installed {}, returned {:?} dependencies and \\\n+                               {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n                         let target_workspace = outputs_disc[0].pop();\n                         for dep in outputs_disc.iter() {\n-                            debug!(\"Discovering a binary input: %s\", dep.to_str());\n+                            debug2!(\"Discovering a binary input: {}\", dep.to_str());\n                             self.exec.discover_input(\"binary\",\n                                                      dep.to_str(),\n                                                      digest_only_date(dep));\n@@ -476,11 +476,11 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                          digest_only_date(&Path(*dep)));\n                             }\n                                 else {\n-                                fail!(\"Bad kind: %s\", *what);\n+                                fail2!(\"Bad kind: {}\", *what);\n                             }\n                         }\n                         // Also, add an additional search path\n-                        debug!(\"Installed %s into %s\", lib_name, target_workspace.to_str());\n+                        debug2!(\"Installed {} into {}\", lib_name, target_workspace.to_str());\n                         (self.save)(target_workspace);\n                     }\n                 }\n@@ -501,7 +501,7 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                                      exec: &mut workcache::Exec,\n                                      c: &ast::Crate,\n                                      save: &fn(Path)) {\n-    debug!(\"In find_and_install_dependencies...\");\n+    debug2!(\"In find_and_install_dependencies...\");\n     let mut visitor = ViewItemVisitor {\n         context: context,\n         parent: parent,\n@@ -553,8 +553,8 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug!(\"Scrutinizing datestamp for %s - does it exist? %?\", p.to_str(), os::path_exists(p));\n+    debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.to_str(), os::path_exists(p));\n     let out = p.stat().map(|stat| stat.st_mtime);\n-    debug!(\"Date = %?\", out);\n+    debug2!(\"Date = {:?}\", out);\n     out.map(|t| { *t as libc::time_t })\n }"}, {"sha": "a59d2bb28870cad01b62bd98b1f28fcc11c093d5", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -79,8 +79,8 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(ref n) | Tagged(ref n) => fmt!(\"%s\", n.to_str()),\n-            SemanticVersion(ref v) => fmt!(\"%s\", v.to_str()),\n+            ExactRevision(ref n) | Tagged(ref n) => format!(\"{}\", n.to_str()),\n+            SemanticVersion(ref v) => format!(\"{}\", v.to_str()),\n             NoVersion => ~\"0.1\"\n         }\n     }\n@@ -104,9 +104,9 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n             loop;\n         }\n         let outp = run::process_output(\"git\",\n-                                   [fmt!(\"--git-dir=%s\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n+                                   [format!(\"--git-dir={}\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n \n-        debug!(\"git --git-dir=%s tag -l ~~~> %?\", git_dir.to_str(), outp.status);\n+        debug2!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.to_str(), outp.status);\n \n         if outp.status != 0 {\n             loop;\n@@ -134,25 +134,27 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n     if is_url_like(remote_path) {\n         let tmp_dir = mkdtemp(&os::tmpdir(),\n                               \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n-        debug!(\"(to get version) executing {git clone https://%s %s}\",\n+        debug2!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n                remote_path.to_str(),\n                tmp_dir.to_str());\n-        let outp  = run::process_output(\"git\", [~\"clone\", fmt!(\"https://%s\", remote_path.to_str()),\n+        let outp  = run::process_output(\"git\", [~\"clone\",\n+                                                format!(\"https://{}\",\n+                                                        remote_path.to_str()),\n                                                 tmp_dir.to_str()]);\n         if outp.status == 0 {\n-            debug!(\"Cloned it... ( %s, %s )\",\n+            debug2!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));\n             let mut output = None;\n-            debug!(\"(getting version, now getting tags) executing {git --git-dir=%s tag -l}\",\n+            debug2!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n                    tmp_dir.push(\".git\").to_str());\n             let outp = run::process_output(\"git\",\n-                                           [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n+                                           [format!(\"--git-dir={}\", tmp_dir.push(\".git\").to_str()),\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_utf8(outp.output);\n-            debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n+            debug2!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.line_iter() {\n-                debug!(\"A line of output: %s\", l);\n+                debug2!(\"A line of output: {}\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n                 }\n@@ -179,7 +181,7 @@ enum ParseState {\n \n pub fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n-    debug!(\"Attempting to parse: %s\", s);\n+    debug2!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n     for c in s.iter() {\n         if char::is_digit(c) {\n@@ -242,7 +244,7 @@ fn test_parse_version() {\n #[test]\n fn test_split_version() {\n     let s = \"a/b/c#0.1\";\n-    debug!(\"== %? ==\", split_version(s));\n+    debug2!(\"== {:?} ==\", split_version(s));\n     assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n     assert!(split_version(\"a/b/c\") == None);\n     let s = \"a#1.2\";"}, {"sha": "8af24ff4c3889064fe7750e6a81beb961e0f35fe", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -25,12 +25,12 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n             (*sha).input_str(s);\n             let st = match path.stat() {\n                 Some(st) => st,\n-                None => cond1.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+                None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n             };\n             (*sha).input_str(st.st_mtime.to_str());\n             (*sha).result_str()\n         }\n-        Err(e) => cond.raise((path.clone(), fmt!(\"Couldn't read file: %s\", e))).to_str()\n+        Err(e) => cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e))).to_str()\n     }\n }\n \n@@ -41,17 +41,17 @@ pub fn digest_only_date(path: &Path) -> ~str {\n     let mut sha = ~Sha1::new();\n     let st = match path.stat() {\n                 Some(st) => st,\n-                None => cond.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+                None => cond.raise((path.clone(), format!(\"Couldn't get file access time\")))\n     };\n     (*sha).input_str(st.st_mtime.to_str());\n     (*sha).result_str()\n }\n \n /// Adds multiple discovered outputs\n pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n-    debug!(\"Discovering %? outputs\", outputs.len());\n+    debug2!(\"Discovering {:?} outputs\", outputs.len());\n     for p in outputs.iter() {\n-        debug!(\"Discovering output! %s\", p.to_str());\n+        debug2!(\"Discovering output! {}\", p.to_str());\n         // For now, assume that all discovered outputs are binaries\n         e.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n     }"}, {"sha": "9642d004de316ecaa323e82d79a644710fd10721", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da24c0d32f8a5ce74268f416bbdab2e61a34976d/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=da24c0d32f8a5ce74268f416bbdab2e61a34976d", "patch": "@@ -25,8 +25,8 @@ pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path)\n     let workspaces = pkg_parent_workspaces(cx, pkgid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n-        fail!(\"Package %s not found in any of \\\n-                    the following workspaces: %s\",\n+        fail2!(\"Package {} not found in any of \\\n+                    the following workspaces: {}\",\n                    pkgid.path.to_str(),\n                    rust_path().to_str());\n     }"}]}