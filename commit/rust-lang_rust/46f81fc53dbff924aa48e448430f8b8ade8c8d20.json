{"sha": "46f81fc53dbff924aa48e448430f8b8ade8c8d20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjgxZmM1M2RiZmY5MjRhYTQ4ZTQ0ODQzMGY4YjhhZGU4YzhkMjA=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-07-11T17:25:37Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-07-20T03:08:39Z"}, "message": "Avoid cloning Place in report_use_of_moved_or_uninitialized and friends", "tree": {"sha": "198ee021e2dd61365602b347185267272d451e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/198ee021e2dd61365602b347185267272d451e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f81fc53dbff924aa48e448430f8b8ade8c8d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f81fc53dbff924aa48e448430f8b8ade8c8d20", "html_url": "https://github.com/rust-lang/rust/commit/46f81fc53dbff924aa48e448430f8b8ade8c8d20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f81fc53dbff924aa48e448430f8b8ade8c8d20/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec65db07ef4cf75d0944f43a1bc1f1bd18da6545", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec65db07ef4cf75d0944f43a1bc1f1bd18da6545", "html_url": "https://github.com/rust-lang/rust/commit/ec65db07ef4cf75d0944f43a1bc1f1bd18da6545"}], "stats": {"total": 484, "additions": 253, "deletions": 231}, "files": [{"sha": "b113f87fb86fddb2c92e6de18c9a7dc281a7813d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -1826,7 +1826,7 @@ newtype_index! {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n     pub base: &'a PlaceBase<'tcx>,\n     pub projection: &'a Option<Box<Projection<'tcx>>>,\n@@ -1961,6 +1961,27 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     ) -> R {\n         Place::iterate_over(self.base, self.projection, op)\n     }\n+\n+    /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// a single deref of a local.\n+    //\n+    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    pub fn local_or_deref_local(&self) -> Option<Local> {\n+        match self {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } |\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } => Some(*local),\n+            _ => None,\n+        }\n+    }\n }\n \n /// A linked list of projections running up the stack; begins with the"}, {"sha": "ce4460e8dedd2c556f77da658dfca2f89e42c98c", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n@@ -48,7 +48,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n+        (moved_place, used_place, span): (PlaceRef<'cx, 'tcx>, PlaceRef<'cx, 'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n@@ -73,25 +73,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if move_out_indices.is_empty() {\n             let root_place = self\n-                .prefixes(&used_place.base, &used_place.projection, PrefixSet::All)\n+                .prefixes(used_place, PrefixSet::All)\n                 .last()\n                 .unwrap();\n \n-            if self.uninitialized_error_reported.contains(&Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n-            }) {\n+            if self.uninitialized_error_reported.contains(&root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n                 );\n                 return;\n             }\n \n-            self.uninitialized_error_reported.insert(Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n-            });\n+            self.uninitialized_error_reported.insert(root_place);\n \n             let item_msg = match self.describe_place_with_options(used_place,\n                                                                   IncludingDowncast(true)) {\n@@ -114,8 +108,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n-                if self.prefixes(&reported_place.base, &reported_place.projection, PrefixSet::All)\n-                    .any(|p| *p.0 == used_place.base && *p.1 == used_place.projection)\n+                if self.prefixes(*reported_place, PrefixSet::All)\n+                    .any(|p| p == used_place)\n                 {\n                     debug!(\n                         \"report_use_of_moved_or_uninitialized place: error suppressed \\\n@@ -132,7 +126,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n-                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n+                self.describe_place_with_options(moved_place, IncludingDowncast(true)),\n             );\n \n             self.add_moved_or_invoked_closure_note(\n@@ -145,13 +139,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let is_partial_move = move_site_vec.iter().any(|move_site| {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n-                used_place != moved_place && used_place.is_prefix_of(moved_place)\n+                used_place != moved_place.as_place_ref()\n+                    && used_place.is_prefix_of(moved_place.as_place_ref())\n             });\n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n-                let move_spans = self.move_spans(moved_place, move_out.source);\n+                let move_spans = self.move_spans(moved_place.as_place_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n \n                 let move_msg = if move_spans.for_closure() {\n@@ -209,7 +204,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n+            let ty =\n+                Place::ty_from(used_place.base, used_place.projection, self.body, self.infcx.tcx)\n+                    .ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -225,7 +222,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let place = &self.move_data.move_paths[mpi].place;\n \n                 let ty = place.ty(self.body, self.infcx.tcx).ty;\n-                let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n+                let opt_name =\n+                    self.describe_place_with_options(place.as_place_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n@@ -259,7 +257,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let Some((_, mut old_err)) = self.move_error_reported\n-                .insert(move_out_indices, (used_place.clone(), err))\n+                .insert(move_out_indices, (used_place, err))\n             {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();\n@@ -289,7 +287,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n-        let move_spans = self.move_spans(place, location);\n+        let move_spans = self.move_spans(place.as_place_ref(), location);\n         let span = move_spans.args_or_use();\n \n         let mut err = self.cannot_move_when_borrowed(\n@@ -328,7 +326,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // Conflicting borrows are reported separately, so only check for move\n         // captures.\n-        let use_spans = self.move_spans(place, location);\n+        let use_spans = self.move_spans(place.as_place_ref(), location);\n         let span = use_spans.var_or_use();\n \n         let mut err = self.cannot_use_when_mutably_borrowed(\n@@ -698,25 +696,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let drop_span = place_span.1;\n-        let root_place = self.prefixes(&borrow.borrowed_place.base,\n-                                       &borrow.borrowed_place.projection,\n-                                       PrefixSet::All)\n+        let root_place = self.prefixes(borrow.borrowed_place.as_place_ref(), PrefixSet::All)\n             .last()\n             .unwrap();\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        assert!(root_place.1.is_none());\n-        let proper_span = match root_place.0 {\n+        assert!(root_place.projection.is_none());\n+        let proper_span = match root_place.base {\n             PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n         };\n \n         if self.access_place_error_reported\n             .contains(&(Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n+                base: root_place.base.clone(),\n+                projection: root_place.projection.clone(),\n             }, borrow_span))\n         {\n             debug!(\n@@ -728,8 +724,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         self.access_place_error_reported\n             .insert((Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n+                base: root_place.base.clone(),\n+                projection: root_place.projection.clone(),\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -739,7 +735,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n-            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n+            if !borrow.borrowed_place.as_place_ref().is_prefix_of(place_span.0.as_place_ref()) {\n                 self.report_borrow_conflicts_with_destructor(\n                     location, borrow, place_span, kind, dropped_ty,\n                 );\n@@ -753,10 +749,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n         let err = match (place_desc, explanation) {\n-            (Some(_), _) if self.is_place_thread_local(&Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n-            }) => {\n+            (Some(_), _) if self.is_place_thread_local(root_place) => {\n                 self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n             }\n             // If the outlives constraint comes from inside the closure,\n@@ -1133,12 +1126,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` is borrowed here\", place_desc),\n             )\n         } else {\n-            let root_place = self.prefixes(&borrow.borrowed_place.base,\n-                                           &borrow.borrowed_place.projection,\n+            let root_place = self.prefixes(borrow.borrowed_place.as_place_ref(),\n                                            PrefixSet::All)\n                 .last()\n                 .unwrap();\n-            let local = if let (PlaceBase::Local(local), None) = root_place {\n+            let local = if let PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } = root_place {\n                 local\n             } else {\n                 bug!(\"try_report_cannot_return_reference_to_local: not a local\")"}, {"sha": "aa772e64aa2d0de5746e4f25e03499a106da263a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -3,8 +3,8 @@ use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n-    Place, PlaceBase, ProjectionElem, Rvalue, Statement, StatementKind, Static,\n-    StaticKind, Terminator, TerminatorKind,\n+    Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n+    Static, StaticKind, Terminator, TerminatorKind,\n };\n use rustc::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n@@ -34,7 +34,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(super) fn add_moved_or_invoked_closure_note(\n         &self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n@@ -122,7 +122,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// End-user visible description of `place` if one can be found. If the\n     /// place is a temporary for instance, None will be returned.\n     pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n-        self.describe_place_with_options(place, IncludingDowncast(false))\n+        self.describe_place_with_options(place.as_place_ref(), IncludingDowncast(false))\n     }\n \n     /// End-user visible description of `place` if one can be found. If the\n@@ -131,7 +131,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n         let mut buf = String::new();\n@@ -144,19 +144,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Appends end-user visible description of `place` to `buf`.\n     fn append_place_to_string(\n         &self,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         buf: &mut String,\n         mut autoderef: bool,\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n-        match *place {\n-            Place {\n+        match place {\n+            PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: None,\n             } => {\n-                self.append_local_to_string(local, buf)?;\n+                self.append_local_to_string(*local, buf)?;\n             }\n-            Place {\n+            PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n                         kind: StaticKind::Promoted(_),\n@@ -166,17 +166,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {\n                 buf.push_str(\"promoted\");\n             }\n-            Place {\n+            PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n                         kind: StaticKind::Static(def_id),\n                         ..\n                     }),\n                 projection: None,\n             } => {\n-                buf.push_str(&self.infcx.tcx.item_name(def_id).to_string());\n+                buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n-            Place {\n+            PlaceRef {\n                 ref base,\n                 projection: Some(ref proj),\n             } => {\n@@ -196,9 +196,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if autoderef {\n                                 // FIXME turn this recursion into iteration\n                                 self.append_place_to_string(\n-                                    &Place {\n-                                        base: base.clone(),\n-                                        projection: proj.base.clone(),\n+                                    PlaceRef {\n+                                        base: &base,\n+                                        projection: &proj.base,\n                                     },\n                                     buf,\n                                     autoderef,\n@@ -209,9 +209,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     (None, PlaceBase::Local(local)) => {\n                                         if self.body.local_decls[*local].is_ref_for_guard() {\n                                             self.append_place_to_string(\n-                                                &Place {\n-                                                    base: base.clone(),\n-                                                    projection: proj.base.clone(),\n+                                                PlaceRef {\n+                                                    base: &base,\n+                                                    projection: &proj.base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -221,9 +221,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             // FIXME deduplicate this and the _ => body below\n                                             buf.push_str(&\"*\");\n                                             self.append_place_to_string(\n-                                                &Place {\n-                                                    base: base.clone(),\n-                                                    projection: proj.base.clone(),\n+                                                PlaceRef {\n+                                                    base: &base,\n+                                                    projection: &proj.base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -235,9 +235,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     _ => {\n                                         buf.push_str(&\"*\");\n                                         self.append_place_to_string(\n-                                            &Place {\n-                                                base: base.clone(),\n-                                                projection: proj.base.clone(),\n+                                            PlaceRef {\n+                                                base: &base,\n+                                                projection: &proj.base,\n                                             },\n                                             buf,\n                                             autoderef,\n@@ -250,9 +250,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                     ProjectionElem::Downcast(..) => {\n                         self.append_place_to_string(\n-                            &Place {\n-                                base: base.clone(),\n-                                projection: proj.base.clone(),\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n                             },\n                             buf,\n                             autoderef,\n@@ -273,13 +273,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&Place {\n-                                base: base.clone(),\n+                                base: (*base).clone(),\n                                 projection: proj.base.clone(),\n                             }, field);\n                             self.append_place_to_string(\n-                                &Place {\n-                                    base: base.clone(),\n-                                    projection: proj.base.clone(),\n+                                PlaceRef {\n+                                    base: &base,\n+                                    projection: &proj.base,\n                                 },\n                                 buf,\n                                 autoderef,\n@@ -292,9 +292,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         autoderef = true;\n \n                         self.append_place_to_string(\n-                            &Place {\n-                                base: base.clone(),\n-                                projection: proj.base.clone(),\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n                             },\n                             buf,\n                             autoderef,\n@@ -312,9 +312,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n                         self.append_place_to_string(\n-                            &Place {\n-                                base: base.clone(),\n-                                projection: proj.base.clone(),\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n                             },\n                             buf,\n                             autoderef,\n@@ -436,14 +436,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Checks if a place is a thread-local static.\n-    pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place {\n+    pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n+        if let PlaceRef {\n             base: PlaceBase::Static(box Static {\n                 kind: StaticKind::Static(def_id),\n                 ..\n             }),\n             projection: None,\n-        } = place {\n+        } = place_ref {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n \n@@ -487,7 +487,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Look up the provided place and work out the move path index for it,\n         // we'll use this to check whether it was originally from an overloaded\n         // operator.\n-        match self.move_data.rev_lookup.find(deref_base) {\n+        match self.move_data.rev_lookup.find(deref_base.as_place_ref()) {\n             LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n                 debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n \n@@ -775,7 +775,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n         &self,\n-        moved_place: &Place<'tcx>, // Could also be an upvar.\n+        moved_place: PlaceRef<'cx, 'tcx>, // Could also be an upvar.\n         location: Location,\n     ) -> UseSpans {\n         use self::UseSpans::*;\n@@ -854,7 +854,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id, is_generator, places\n                 );\n                 if let Some((args_span, var_span)) = self.closure_span(\n-                    *def_id, &Place::from(target), places\n+                    *def_id, Place::from(target).as_place_ref(), places\n                 ) {\n                     return ClosureUse {\n                         is_generator,\n@@ -878,7 +878,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn closure_span(\n         &self,\n         def_id: DefId,\n-        target_place: &Place<'tcx>,\n+        target_place: PlaceRef<'cx, 'tcx>,\n         places: &Vec<Operand<'tcx>>,\n     ) -> Option<(Span, Span)> {\n         debug!(\n@@ -894,7 +894,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) |\n-                    Operand::Move(place) if target_place == place => {\n+                    Operand::Move(place) if target_place == place.as_place_ref() => {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n                         return Some((*args_span, upvar.span));\n                     },"}, {"sha": "b159bf4dd04cd477c7ca167e6f4c0953535b8981", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -10,9 +10,8 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, Static,\n-\n-    StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n+    Static, StaticKind\n };\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -474,10 +473,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// `BTreeMap` is used to preserve the order of insertions when iterating. This is necessary\n     /// when errors in the map are being re-added to the error buffer so that errors with the\n     /// same primary span come out in a consistent order.\n-    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (Place<'tcx>, DiagnosticBuilder<'cx>)>,\n+    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'cx, 'tcx>, DiagnosticBuilder<'cx>)>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n-    uninitialized_error_reported: FxHashSet<Place<'tcx>>,\n+    uninitialized_error_reported: FxHashSet<PlaceRef<'cx, 'tcx>>,\n     /// Errors to be reported buffer\n     errors_buffer: Vec<Diagnostic>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n@@ -520,7 +519,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     fn visit_statement_entry(\n         &mut self,\n         location: Location,\n-        stmt: &Statement<'tcx>,\n+        stmt: &'cx Statement<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n         debug!(\n@@ -561,7 +560,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -592,7 +591,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                         self.check_if_path_or_subpath_is_moved(\n                             location,\n                             InitializationRequiringAction::Use,\n-                            (output, o.span),\n+                            (output.as_place_ref(), o.span),\n                             flow_state,\n                         );\n                     } else {\n@@ -631,7 +630,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     fn visit_terminator_entry(\n         &mut self,\n         location: Location,\n-        term: &Terminator<'tcx>,\n+        term: &'cx Terminator<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n         let loc = location;\n@@ -1144,7 +1143,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (&'cx Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1155,7 +1154,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Update,\n-                    place_span,\n+                    (place_span.0.as_place_ref(), place_span.1),\n                     flow_state,\n                 );\n             }\n@@ -1196,7 +1195,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn consume_rvalue(\n         &mut self,\n         location: Location,\n-        (rvalue, span): (&Rvalue<'tcx>, Span),\n+        (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *rvalue {\n@@ -1233,7 +1232,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     action,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1261,7 +1260,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1310,7 +1309,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n             if place.projection.is_some() {\n-                if let Some(field) = this.is_upvar_field_projection(place) {\n+                if let Some(field) = this.is_upvar_field_projection(place.as_place_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n             } else if let PlaceBase::Local(local) = place.base {\n@@ -1383,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn consume_operand(\n         &mut self,\n         location: Location,\n-        (operand, span): (&Operand<'tcx>, Span),\n+        (operand, span): (&'cx Operand<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *operand {\n@@ -1402,7 +1401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1420,7 +1419,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1438,17 +1437,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let root_place =\n-            self.prefixes(&place.base, &place.projection, PrefixSet::All).last().unwrap();\n+        let root_place = self.prefixes(place.as_place_ref(), PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.1.is_none());\n-        let (might_be_alive, will_be_dropped) = match root_place.0 {\n+        assert!(root_place.projection.is_none());\n+        let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n                 kind: StaticKind::Promoted(_),\n                 ..\n@@ -1461,10 +1459,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                (true, self.is_place_thread_local(&Place {\n-                    base: root_place.0.clone(),\n-                    projection: root_place.1.clone(),\n-                }))\n+                (true, self.is_place_thread_local(root_place))\n             }\n             PlaceBase::Local(_) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1488,10 +1483,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.body,\n             place,\n             borrow.kind,\n-            &Place {\n-                base: root_place.0.clone(),\n-                projection: root_place.1.clone(),\n-            },\n+            root_place,\n             sd,\n             places_conflict::PlaceConflictBias::Overlap,\n         ) {\n@@ -1579,7 +1571,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1626,7 +1618,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.report_use_of_moved_or_uninitialized(\n                         location,\n                         desired_action,\n-                        (&prefix, place_span.0, place_span.1),\n+                        (prefix, place_span.0, place_span.1),\n                         mpi,\n                     );\n                     return; // don't bother finding other problems.\n@@ -1647,7 +1639,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1704,22 +1696,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// static variable, as we do not track those in the MoveData.\n     fn move_path_closest_to(\n         &mut self,\n-        place: &Place<'tcx>,\n-    ) -> Result<(Place<'tcx>, MovePathIndex), NoMovePathFound> {\n-        let mut last_prefix = &place.base;\n-\n-        for prefix in self.prefixes(&place.base, &place.projection, PrefixSet::All) {\n-            if let Some(mpi) = self.move_path_for_place(&Place {\n-                base: prefix.0.clone(),\n-                projection: prefix.1.clone(),\n-            }) {\n-                return Ok((Place {\n-                    base: prefix.0.clone(),\n-                    projection: prefix.1.clone(),\n-                }, mpi));\n+        place: PlaceRef<'cx, 'tcx>,\n+    ) -> Result<(PlaceRef<'cx, 'tcx>, MovePathIndex), NoMovePathFound> {\n+        let mut last_prefix = place.base;\n+\n+        for prefix in self.prefixes(place, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_place(prefix) {\n+                return Ok((prefix, mpi));\n             }\n \n-            last_prefix = prefix.0;\n+            last_prefix = prefix.base;\n         }\n \n         match last_prefix {\n@@ -1728,7 +1714,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn move_path_for_place(&mut self, place: &Place<'tcx>) -> Option<MovePathIndex> {\n+    fn move_path_for_place(&mut self, place: PlaceRef<'cx, 'tcx>) -> Option<MovePathIndex> {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `place` (which means there is nothing\n         // that borrowck tracks for its analysis).\n@@ -1742,7 +1728,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_assigned_path_is_moved(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (&'cx Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n@@ -1766,9 +1752,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Deref => {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n-                        (&Place {\n-                            base: place.base.clone(),\n-                            projection: base.clone(),\n+                        (PlaceRef {\n+                            base: &place.base,\n+                            projection: base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n                     // recur further)\n@@ -1790,9 +1776,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n-                                (&Place {\n-                                    base: place.base.clone(),\n-                                    projection: base.clone(),\n+                                (PlaceRef {\n+                                    base: &place.base,\n+                                    projection: base,\n                                 }, span), flow_state);\n \n                             // (base initialized; no need to\n@@ -1803,9 +1789,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Once `let s; s.x = V; read(s.x);`,\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n-                            check_parent_of_field(self, location, &Place {\n-                                base: place.base.clone(),\n-                                projection: base.clone(),\n+                            check_parent_of_field(self, location, PlaceRef {\n+                                base: &place.base,\n+                                projection: base,\n                             }, span, flow_state);\n \n                             if let PlaceBase::Local(local) = place.base {\n@@ -1832,7 +1818,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         fn check_parent_of_field<'cx, 'tcx>(\n             this: &mut MirBorrowckCtxt<'cx, 'tcx>,\n             location: Location,\n-            base: &Place<'tcx>,\n+            base: PlaceRef<'cx, 'tcx>,\n             span: Span,\n             flow_state: &Flows<'cx, 'tcx>,\n         ) {\n@@ -1872,11 +1858,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // Find the shortest uninitialized prefix you can reach\n             // without going over a Deref.\n             let mut shortest_uninit_seen = None;\n-            for prefix in this.prefixes(&base.base, &base.projection, PrefixSet::Shallow) {\n-                let mpi = match this.move_path_for_place(&Place {\n-                    base: prefix.0.clone(),\n-                    projection: prefix.1.clone(),\n-                }) {\n+            for prefix in this.prefixes(base, PrefixSet::Shallow) {\n+                let mpi = match this.move_path_for_place(prefix) {\n                     Some(mpi) => mpi, None => continue,\n                 };\n \n@@ -1896,7 +1879,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) = base.ty(this.body, tcx).ty.sty {\n+                if let ty::Adt(def, _) =\n+                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.sty\n+                {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n@@ -1911,10 +1896,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 this.report_use_of_moved_or_uninitialized(\n                     location,\n                     InitializationRequiringAction::PartialAssignment,\n-                    (&Place {\n-                        base: prefix.0.clone(),\n-                        projection: prefix.1.clone(),\n-                    }, base, span),\n+                    (prefix, base, span),\n                     mpi,\n                 );\n             }\n@@ -2103,12 +2085,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {}\n             RootPlace {\n                 place_base,\n-                place_projection: Some(proj),\n+                place_projection: place_projection @ Some(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = self.is_upvar_field_projection(&Place {\n-                    base: place_base.clone(),\n-                    projection: Some(proj.clone()),\n+                if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                    base: &place_base,\n+                    projection: &place_projection,\n                 }) {\n                     self.used_mut_upvars.push(field);\n                 }\n@@ -2193,9 +2175,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(&Place {\n-                                            base: place_base.clone(),\n-                                            projection: place_projection.clone(),\n+                                        let mode = match self.is_upvar_field_projection(PlaceRef {\n+                                            base: &place_base,\n+                                            projection: &place_projection,\n                                         }) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n@@ -2239,9 +2221,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(&Place {\n-                            base: place_base.clone(),\n-                            projection: place_projection.clone(),\n+                        let upvar_field_projection = self.is_upvar_field_projection(PlaceRef {\n+                            base: &place_base,\n+                            projection: &place_projection,\n                         });\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n@@ -2306,15 +2288,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    pub fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        let mut place_projection = place.projection.clone();\n+    pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'cx, 'tcx>) -> Option<Field> {\n+        let mut place_projection = place_ref.projection;\n         let mut by_ref = false;\n \n         if let Some(box Projection {\n             base,\n             elem: ProjectionElem::Deref,\n         }) = place_projection {\n-            place_projection = base;\n+            place_projection = &base;\n             by_ref = true;\n         }\n \n@@ -2324,11 +2306,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 elem: ProjectionElem::Field(field, _ty),\n             }) => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(&place.base, &base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, &base, self.body, tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {\n-                    Some(field)\n+                    Some(*field)\n                 } else {\n                     None\n                 }"}, {"sha": "d933932309e0ca01ef4f1d578ea433dc58d2e02e", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let move_spans = self.move_spans(&original_path, location);\n+                let move_spans = self.move_spans(original_path.as_place_ref(), location);\n                 grouped_errors.push(GroupedMoveError::OtherIllegalMove {\n                     use_spans: move_spans,\n                     original_path,\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let from_simple_let = match_place.is_none();\n         let match_place = match_place.as_ref().unwrap_or(move_from);\n \n-        match self.move_data.rev_lookup.find(match_place) {\n+        match self.move_data.rev_lookup.find(match_place.as_place_ref()) {\n             // Error with the match place\n             LookupResult::Parent(_) => {\n                 for ge in &mut *grouped_errors {\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             // Error with the pattern\n             LookupResult::Exact(_) => {\n-                let mpi = match self.move_data.rev_lookup.find(move_from) {\n+                let mpi = match self.move_data.rev_lookup.find(move_from.as_place_ref()) {\n                     LookupResult::Parent(Some(mpi)) => mpi,\n                     // move_from should be a projection from match_place.\n                     _ => unreachable!(\"Probably not unreachable...\"),\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   self.is_upvar_field_projection(original_path));\n+                   self.is_upvar_field_projection(original_path.as_place_ref()));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n@@ -308,11 +308,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n         let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n-        let upvar_field = self.prefixes(&move_place.base, &move_place.projection, PrefixSet::All)\n-            .find_map(|p| self.is_upvar_field_projection(&Place {\n-                base: p.0.clone(),\n-                projection: p.1.clone(),\n-            }));\n+        let upvar_field = self.prefixes(move_place.as_place_ref(), PrefixSet::All)\n+            .find_map(|p| self.is_upvar_field_projection(p));\n \n         let deref_base = match deref_target_place.projection {\n             Some(box Projection { ref base, elem: ProjectionElem::Deref }) => Place {\n@@ -368,7 +365,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let place_name = self.describe_place(move_place).unwrap();\n \n-                let place_description = if self.is_upvar_field_projection(move_place).is_some() {\n+                let place_description = if self\n+                    .is_upvar_field_projection(move_place.as_place_ref())\n+                    .is_some()\n+                {\n                     format!(\"`{}`, a {}\", place_name, capture_description)\n                 } else {\n                     format!("}, {"sha": "adde4ac85c8fb73c5adee9bd15406f3a7e2cbc6b", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if self.is_upvar_field_projection(access_place).is_some() {\n+                if self.is_upvar_field_projection(access_place.as_place_ref()).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.upvars[upvar_index.index()].name;\n@@ -100,11 +100,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         the_place_err.ty(self.body, self.infcx.tcx).ty\n                     ));\n \n-                    reason = if self.is_upvar_field_projection(access_place).is_some() {\n-                        \", as it is a captured variable in a `Fn` closure\".to_string()\n-                    } else {\n-                        \", as `Fn` closures cannot mutate their captured variables\".to_string()\n-                    }\n+                    reason =\n+                        if self.is_upvar_field_projection(access_place.as_place_ref()).is_some() {\n+                            \", as it is a captured variable in a `Fn` closure\".to_string()\n+                        } else {\n+                            \", as `Fn` closures cannot mutate their captured variables\".to_string()\n+                        }\n                 } else if {\n                     if let (PlaceBase::Local(local), None) = (&the_place_err.base, base) {\n                         self.body.local_decls[*local].is_ref_for_guard()"}, {"sha": "6885baf8223712ee78dd712e19073238679653c6", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -252,7 +252,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = body.source_info(location).span;\n                 let spans = self\n-                    .move_spans(&Place::from(local), location)\n+                    .move_spans(Place::from(local).as_place_ref(), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 let borrow_location = location;"}, {"sha": "75065816df0506363766dbda7f46b4ce34eec211", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -50,7 +50,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n             body,\n             &borrowed.borrowed_place,\n             borrowed.kind,\n-            place,\n+            place.as_place_ref(),\n             access,\n             places_conflict::PlaceConflictBias::Overlap,\n         ) {"}, {"sha": "348214f97f25606c1c27a458016335fcec77d72c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -3,8 +3,8 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    BorrowKind, Body, Place, PlaceBase, Projection, ProjectionElem, ProjectionsIter,\n-    StaticKind\n+    Body, BorrowKind, Place, PlaceBase, PlaceRef, Projection, ProjectionElem, ProjectionsIter,\n+    StaticKind,\n };\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n@@ -36,7 +36,7 @@ crate fn places_conflict<'tcx>(\n         body,\n         borrow_place,\n         BorrowKind::Mut { allow_two_phase_borrow: true },\n-        access_place,\n+        access_place.as_place_ref(),\n         AccessDepth::Deep,\n         bias,\n     )\n@@ -51,7 +51,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_place: &Place<'tcx>,\n+    access_place: PlaceRef<'_, 'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -66,7 +66,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n         base: PlaceBase::Local(l1),\n         projection: None,\n     } = borrow_place {\n-        if let Place {\n+        if let PlaceRef {\n             base: PlaceBase::Local(l2),\n             projection: None,\n         } = access_place {"}, {"sha": "ecafd4eb1157ec3c1284d657cfb1113adb47172d", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -11,17 +11,17 @@ use super::MirBorrowckCtxt;\n \n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{Body, Place, PlaceBase, Projection, ProjectionElem};\n+use rustc::mir::{Body, Place, PlaceBase, PlaceRef, ProjectionElem};\n \n-pub trait IsPrefixOf<'tcx> {\n-    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n+pub trait IsPrefixOf<'cx, 'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool;\n }\n \n-impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n-    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n-        let mut cursor = &other.projection;\n+impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n+        let mut cursor = other.projection;\n         loop {\n-            if self.projection == *cursor {\n+            if self.projection == cursor {\n                 return self.base == other.base;\n             }\n \n@@ -37,7 +37,7 @@ pub(super) struct Prefixes<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n-    next: Option<(&'cx PlaceBase<'tcx>, &'cx Option<Box<Projection<'tcx>>>)>,\n+    next: Option<(PlaceRef<'cx, 'tcx>)>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -58,12 +58,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// terminating the iteration early based on `kind`.\n     pub(super) fn prefixes(\n         &self,\n-        place_base: &'cx PlaceBase<'tcx>,\n-        place_projection: &'cx Option<Box<Projection<'tcx>>>,\n+        place_ref: PlaceRef<'cx, 'tcx>,\n         kind: PrefixSet,\n     ) -> Prefixes<'cx, 'tcx> {\n         Prefixes {\n-            next: Some((place_base, place_projection)),\n+            next: Some(place_ref),\n             kind,\n             body: self.body,\n             tcx: self.infcx.tcx,\n@@ -72,7 +71,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n-    type Item = (&'cx PlaceBase<'tcx>, &'cx Option<Box<Projection<'tcx>>>);\n+    type Item = PlaceRef<'cx, 'tcx>;\n     fn next(&mut self) -> Option<Self::Item> {\n         let mut cursor = self.next?;\n \n@@ -82,27 +81,42 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            let proj = match cursor {\n-                (&PlaceBase::Local(_), &None)\n+            let proj = match &cursor {\n+                PlaceRef {\n+                    base: PlaceBase::Local(_),\n+                    projection: None,\n+                }\n                 | // search yielded this leaf\n-                (&PlaceBase::Static(_), &None) => {\n+                PlaceRef {\n+                    base: PlaceBase::Static(_),\n+                    projection: None,\n+                } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-                (_, &Some(ref proj))  => proj,\n+                PlaceRef {\n+                    base: _,\n+                    projection: Some(proj),\n+                } => proj,\n             };\n \n             match proj.elem {\n                 ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n                     // FIXME: add union handling\n-                    self.next = Some((cursor.0, &proj.base));\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n                 ProjectionElem::Downcast(..) |\n                 ProjectionElem::Subslice { .. } |\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Index(_) => {\n-                    cursor = (cursor.0, &proj.base);\n+                    cursor = PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    };\n                     continue 'cursor;\n                 }\n                 ProjectionElem::Deref => {\n@@ -123,7 +137,10 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                 PrefixSet::All => {\n                     // all prefixes: just blindly enqueue the base\n                     // of the projection\n-                    self.next = Some((cursor.0, &proj.base));\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n                 PrefixSet::Supporting => {\n@@ -136,7 +153,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = Place::ty_from(cursor.0, &proj.base, self.body, self.tcx).ty;\n+            let ty = Place::ty_from(cursor.base, &proj.base, self.body, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref(\n@@ -154,12 +171,18 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     _, /*ty*/\n                     hir::MutMutable,\n                     ) => {\n-                    self.next = Some((cursor.0, &proj.base));\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n \n                 ty::Adt(..) if ty.is_box() => {\n-                    self.next = Some((cursor.0, &proj.base));\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n "}, {"sha": "b6dd544d395618945126a8b1f75936fdb458fbfb", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -171,7 +171,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'tcx, F>(\n     let move_data = &ctxt.move_data;\n     for arg in body.args_iter() {\n         let place = mir::Place::from(arg);\n-        let lookup_result = move_data.rev_lookup.find(&place);\n+        let lookup_result = move_data.rev_lookup.find(place.as_place_ref());\n         on_lookup_result_bits(tcx, body, move_data,\n                               lookup_result,\n                               |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "ade732bbb75970ad08126d0a2434fb2e853e38a9", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.insert(mpi); });\n     }\n }\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.remove(mpi); });\n     }\n }\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.insert(mpi); });\n     }\n }"}, {"sha": "3bdd3e3da048e4b1c3d5d20920a4104d2e0702d9", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -314,12 +314,12 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     fn visit_statement_entry(&mut self,\n                              _loc: Location,\n-                             _stmt: &Statement<'tcx>,\n+                             _stmt: &'a Statement<'tcx>,\n                              _flow_state: &Self::FlowState) {}\n \n     fn visit_terminator_entry(&mut self,\n                               _loc: Location,\n-                              _term: &Terminator<'tcx>,\n+                              _term: &'a Terminator<'tcx>,\n                               _flow_state: &Self::FlowState) {}\n \n     // Main entry point: this drives the processing of results."}, {"sha": "93e8fd69361f8124342786c03e2f13a0f67f9723", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -454,7 +454,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             _ => place.clone()\n         };\n \n-        if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(&place) {\n+        if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(place.as_place_ref()) {\n             let init = self.builder.data.inits.push(Init {\n                 location: InitLocation::Statement(self.loc),\n                 path,"}, {"sha": "5c2255882b2c740d81d4cbd329d2d4306c8bb057", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -240,8 +240,8 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n-        place.iterate(|place_base, place_projection| {\n+    pub fn find(&self, place_ref: PlaceRef<'cx, 'tcx>) -> LookupResult {\n+        place_ref.iterate(|place_base, place_projection| {\n             let mut result = match place_base {\n                 PlaceBase::Local(local) => self.locals[*local],\n                 PlaceBase::Static(..) => return LookupResult::Parent(None),"}, {"sha": "0748321f605938ed3830697a9b7ba1b0727a0409", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -105,7 +105,7 @@ fn find_dead_unwinds<'tcx>(\n             init_data.apply_location(tcx, body, env, loc);\n         }\n \n-        let path = match env.move_data.rev_lookup.find(location) {\n+        let path = match env.move_data.rev_lookup.find(location.as_place_ref()) {\n             LookupResult::Exact(e) => e,\n             LookupResult::Parent(..) => {\n                 debug!(\"find_dead_unwinds: has parent; skipping\");\n@@ -360,7 +360,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 statement_index: data.statements.len()\n             });\n \n-            let path = self.move_data().rev_lookup.find(location);\n+            let path = self.move_data().rev_lookup.find(location.as_place_ref());\n             debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\",\n                    bb, location, path);\n \n@@ -399,7 +399,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             match terminator.kind {\n                 TerminatorKind::Drop { ref location, target, unwind } => {\n                     let init_data = self.initialization_data_at(loc);\n-                    match self.move_data().rev_lookup.find(location) {\n+                    match self.move_data().rev_lookup.find(location.as_place_ref()) {\n                         LookupResult::Exact(path) => {\n                             elaborate_drop(\n                                 &mut Elaborator {\n@@ -488,7 +488,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: false,\n         });\n \n-        match self.move_data().rev_lookup.find(location) {\n+        match self.move_data().rev_lookup.find(location.as_place_ref()) {\n             LookupResult::Exact(path) => {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 let init_data = self.initialization_data_at(loc);\n@@ -558,7 +558,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: tgt, statement_index: 0 };\n-                let path = self.move_data().rev_lookup.find(place);\n+                let path = self.move_data().rev_lookup.find(place.as_place_ref());\n                 on_lookup_result_bits(\n                     self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n@@ -632,7 +632,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n-                let path = self.move_data().rev_lookup.find(place);\n+                let path = self.move_data().rev_lookup.find(place.as_place_ref());\n                 on_lookup_result_bits(\n                     self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)"}, {"sha": "1fd865c42fcdb696b9c92ec793e4f3b0166cc1dd", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f81fc53dbff924aa48e448430f8b8ade8c8d20/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=46f81fc53dbff924aa48e448430f8b8ade8c8d20", "patch": "@@ -168,7 +168,7 @@ fn each_block<'tcx, O>(\n         if place == peek_arg_place {\n             if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = **rvalue {\n                 // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_place) {\n+                match move_data.rev_lookup.find(peeking_at_place.as_place_ref()) {\n                     LookupResult::Exact(peek_mpi) => {\n                         let bit_state = on_entry.contains(peek_mpi);\n                         debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n@@ -192,7 +192,7 @@ fn each_block<'tcx, O>(\n             }\n         }\n \n-        let lhs_mpi = move_data.rev_lookup.find(place);\n+        let lhs_mpi = move_data.rev_lookup.find(place.as_place_ref());\n \n         debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n                place, lhs_mpi, stmt);"}]}