{"sha": "9811dea2377cfe835dc22f8c129bf83a75669319", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MTFkZWEyMzc3Y2ZlODM1ZGMyMmY4YzEyOWJmODNhNzU2NjkzMTk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-29T19:23:21Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-07-01T15:12:48Z"}, "message": "Add a module to pretty-print suggestions", "tree": {"sha": "5e4091aa3cb7de78730715ddfbb719e57d5a23c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e4091aa3cb7de78730715ddfbb719e57d5a23c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9811dea2377cfe835dc22f8c129bf83a75669319", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXdohwAAoJEF5CfHlMukXoBjQQAJzZvM0Jc6/9A+9IaM4Nth7f\nsqIXmLgdH+ndosP3a8B9fwDxivdiCT2JyHSTuFefwfuVBiMQo7eMHSbqhRJ4skm0\n072aT7lgtE3HB5JhtMAuZYDGf/bYb21AoId4E2AbqfW01KL45SDYLsAF9U66IZu7\nF9KNtCEBjVTAIN5UDcw0UK/fU53ZHK+KZo1uFbIzH2UcPxtLt5cMfxliktfYLK1c\nMLkZtPzLf5DviqgIYf6DQffub6IiYzxR6eBAYTs4batxbjTbLz0TfiJ1ctqmnDvd\n6gqNe+J4G5j2ArK4vcPiJbLjZWCzG8l6B1EELHmUnUNqXPnCf5Es7Uk5TbzKgNMg\nxY2S46QDnM5tohVgQbbUNnAMBqcFj580yuPoLdKJkrcsKOEFYoVo2bCoswc2x/2i\nqsvScvb6OCBPFvTdiKG1OIVr1nkvT7nihQi30WAxAwhPL8+GpfnJtGUG4OWA5r45\nK0gA0K0HIk6f7OBoaxNZd5GbadQfqrPcob5G+NMQsxM07Tysg0BGJZTVSZIBxWm0\nOsqnpB7afbHzKl37NNyhLUHYLFUBd5vt88AMTUZImVI55YY+ufXmFPiEVOcU8DFV\nMPvmNdGZoRpw/SoVH5UOs5SLBjDVYbAleXVB01pTPry4K9ND1486cJGesPYimB/C\n5Pi/MU8Ps15AZDwfcVnw\n=SVRk\n-----END PGP SIGNATURE-----", "payload": "tree 5e4091aa3cb7de78730715ddfbb719e57d5a23c9\nparent 580ae5a879073d535c60857b1fbc5204ad2c810e\nauthor mcarton <cartonmartin+git@gmail.com> 1467228201 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1467385968 +0200\n\nAdd a module to pretty-print suggestions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9811dea2377cfe835dc22f8c129bf83a75669319", "html_url": "https://github.com/rust-lang/rust/commit/9811dea2377cfe835dc22f8c129bf83a75669319", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9811dea2377cfe835dc22f8c129bf83a75669319/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "580ae5a879073d535c60857b1fbc5204ad2c810e", "url": "https://api.github.com/repos/rust-lang/rust/commits/580ae5a879073d535c60857b1fbc5204ad2c810e", "html_url": "https://github.com/rust-lang/rust/commit/580ae5a879073d535c60857b1fbc5204ad2c810e"}], "stats": {"total": 291, "additions": 290, "deletions": 1}, "files": [{"sha": "b22531576aaec1afa60582e15aa5f5bd17c6b902", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=9811dea2377cfe835dc22f8c129bf83a75669319", "patch": "@@ -3,6 +3,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(custom_attribute)]\n+#![feature(dotdot_in_tuple_patterns)]\n #![feature(iter_arith)]\n #![feature(question_mark)]\n #![feature(rustc_private)]"}, {"sha": "5df91ee9ab4080e73a537bdf847b312fc60ed16c", "filename": "clippy_lints/src/utils/higher.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=9811dea2377cfe835dc22f8c129bf83a75669319", "patch": "@@ -0,0 +1,28 @@\n+//! This module contains functions for retrieve the original AST from lowered `hir`.\n+\n+use rustc::hir;\n+use syntax::ast;\n+\n+/// Convert a hir binary operator to the corresponding `ast` type.\n+pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n+    match op {\n+        hir::BiEq => ast::BinOpKind::Eq,\n+        hir::BiGe => ast::BinOpKind::Ge,\n+        hir::BiGt => ast::BinOpKind::Gt,\n+        hir::BiLe => ast::BinOpKind::Le,\n+        hir::BiLt => ast::BinOpKind::Lt,\n+        hir::BiNe => ast::BinOpKind::Ne,\n+        hir::BiOr => ast::BinOpKind::Or,\n+        hir::BiAdd => ast::BinOpKind::Add,\n+        hir::BiAnd => ast::BinOpKind::And,\n+        hir::BiBitAnd => ast::BinOpKind::BitAnd,\n+        hir::BiBitOr => ast::BinOpKind::BitOr,\n+        hir::BiBitXor => ast::BinOpKind::BitXor,\n+        hir::BiDiv => ast::BinOpKind::Div,\n+        hir::BiMul => ast::BinOpKind::Mul,\n+        hir::BiRem => ast::BinOpKind::Rem,\n+        hir::BiShl => ast::BinOpKind::Shl,\n+        hir::BiShr => ast::BinOpKind::Shr,\n+        hir::BiSub => ast::BinOpKind::Sub,\n+    }\n+}"}, {"sha": "6d41d5039f74d91a60594d95d2076d57fab10879", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9811dea2377cfe835dc22f8c129bf83a75669319", "patch": "@@ -18,12 +18,14 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+pub mod cargo;\n pub mod comparisons;\n pub mod conf;\n+pub mod higher;\n mod hir;\n pub mod paths;\n+pub mod sugg;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n-pub mod cargo;\n \n pub type MethodArgs = HirVec<P<Expr>>;\n "}, {"sha": "6667598b009aafeb04e20481b3453a2b718d54e9", "filename": "clippy_lints/src/utils/sugg.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9811dea2377cfe835dc22f8c129bf83a75669319/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=9811dea2377cfe835dc22f8c129bf83a75669319", "patch": "@@ -0,0 +1,258 @@\n+use rustc::hir;\n+use rustc::lint::{EarlyContext, LateContext};\n+use std::borrow::Cow;\n+use std;\n+use syntax::ast;\n+use syntax::util::parser::AssocOp;\n+use utils::{higher, snippet};\n+\n+/// A helper type to build suggestion correctly handling parenthesis.\n+pub enum Sugg<'a> {\n+    /// An expression that never needs parenthesis such as `1337` or `[0; 42]`.\n+    NonParen(Cow<'a, str>),\n+    /// An expression that does not fit in other variants.\n+    MaybeParen(Cow<'a, str>),\n+    /// A binary operator expression, including `as`-casts and explicit type coercion.\n+    BinOp(AssocOp, Cow<'a, str>),\n+}\n+\n+impl<'a> std::fmt::Display for Sugg<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+        match *self {\n+            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => {\n+                s.fmt(f)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Sugg<'a> {\n+    pub fn hir(cx: &LateContext, expr: &'a hir::Expr, default: &'a str) -> Sugg<'a> {\n+        let snippet = snippet(cx, expr.span, default);\n+\n+        match expr.node {\n+            hir::ExprAddrOf(..) |\n+            hir::ExprBox(..) |\n+            hir::ExprClosure(..) |\n+            hir::ExprIf(..) |\n+            hir::ExprUnary(..) |\n+            hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n+            hir::ExprAgain(..) |\n+            hir::ExprBlock(..) |\n+            hir::ExprBreak(..) |\n+            hir::ExprCall(..) |\n+            hir::ExprField(..) |\n+            hir::ExprIndex(..) |\n+            hir::ExprInlineAsm(..) |\n+            hir::ExprLit(..) |\n+            hir::ExprLoop(..) |\n+            hir::ExprMethodCall(..) |\n+            hir::ExprPath(..) |\n+            hir::ExprRepeat(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprStruct(..) |\n+            hir::ExprTup(..) |\n+            hir::ExprTupField(..) |\n+            hir::ExprVec(..) |\n+            hir::ExprWhile(..) => Sugg::NonParen(snippet),\n+            hir::ExprAssign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+            hir::ExprAssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+            hir::ExprBinary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+            hir::ExprCast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+            hir::ExprType(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+        }\n+    }\n+\n+    pub fn ast(cx: &EarlyContext, expr: &'a ast::Expr, default: &'a str) -> Sugg<'a> {\n+        use syntax::ast::RangeLimits;\n+\n+        let snippet = snippet(cx, expr.span, default);\n+\n+        match expr.node {\n+            ast::ExprKind::AddrOf(..) |\n+            ast::ExprKind::Box(..) |\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::If(..) |\n+            ast::ExprKind::IfLet(..) |\n+            ast::ExprKind::InPlace(..) |\n+            ast::ExprKind::Unary(..) |\n+            ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            ast::ExprKind::Again(..) |\n+            ast::ExprKind::Block(..) |\n+            ast::ExprKind::Break(..) |\n+            ast::ExprKind::Call(..) |\n+            ast::ExprKind::Field(..) |\n+            ast::ExprKind::ForLoop(..) |\n+            ast::ExprKind::Index(..) |\n+            ast::ExprKind::InlineAsm(..) |\n+            ast::ExprKind::Lit(..) |\n+            ast::ExprKind::Loop(..) |\n+            ast::ExprKind::Mac(..) |\n+            ast::ExprKind::MethodCall(..) |\n+            ast::ExprKind::Paren(..) |\n+            ast::ExprKind::Path(..) |\n+            ast::ExprKind::Repeat(..) |\n+            ast::ExprKind::Ret(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Try(..) |\n+            ast::ExprKind::Tup(..) |\n+            ast::ExprKind::TupField(..) |\n+            ast::ExprKind::Vec(..) |\n+            ast::ExprKind::While(..) |\n+            ast::ExprKind::WhileLet(..) => Sugg::NonParen(snippet),\n+            ast::ExprKind::Range(.., RangeLimits::HalfOpen) => Sugg::BinOp(AssocOp::DotDot, snippet),\n+            ast::ExprKind::Range(.., RangeLimits::Closed) => Sugg::BinOp(AssocOp::DotDotDot, snippet),\n+            ast::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+            ast::ExprKind::AssignOp(op, ..) => Sugg::BinOp(astbinop2assignop(op), snippet),\n+            ast::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node), snippet),\n+            ast::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+            ast::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+        }\n+    }\n+\n+    /// Convenience method to create the `lhs && rhs` suggestion.\n+    pub fn and(&self, rhs: &Self) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::And, self, rhs)\n+    }\n+}\n+\n+impl<'a, 'b> std::ops::Sub<&'b Sugg<'b>> for &'a Sugg<'a> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: &'b Sugg<'b>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, self, rhs)\n+    }\n+}\n+\n+struct ParenHelper<T> {\n+    paren: bool,\n+    wrapped: T,\n+}\n+\n+impl<T> ParenHelper<T> {\n+    fn new(paren: bool, wrapped: T) -> Self {\n+        ParenHelper {\n+            paren: paren,\n+            wrapped: wrapped,\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Display> std::fmt::Display for ParenHelper<T> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+        if self.paren {\n+            write!(f, \"({})\", self.wrapped)\n+        } else {\n+            self.wrapped.fmt(f)\n+        }\n+    }\n+}\n+\n+/// Build the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n+///\n+/// Precedence of shift operator relative to other arithmetic operation is often confusing so\n+/// parenthesis will always be added for a mix of these.\n+pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+    fn is_shift(op: &AssocOp) -> bool {\n+        matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n+    }\n+\n+    fn is_arith(op: &AssocOp) -> bool {\n+        matches!(*op, AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n+    }\n+\n+    fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n+        other.precedence() < op.precedence() ||\n+            (other.precedence() == op.precedence() &&\n+                ((op != other && associativity(op) != dir) ||\n+                 (op == other && associativity(op) != Associativity::Both))) ||\n+             is_shift(op) && is_arith(other) ||\n+             is_shift(other) && is_arith(op)\n+    }\n+\n+    let aop = AssocOp::from_ast_binop(op);\n+\n+    let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n+        needs_paren(&aop, lop, Associativity::Left)\n+    } else {\n+        false\n+    };\n+\n+    let rhs_paren = if let Sugg::BinOp(ref rop, _) = *rhs {\n+        needs_paren(&aop, rop, Associativity::Right)\n+    } else {\n+        false\n+    };\n+\n+    Sugg::BinOp(aop,\n+                format!(\"{} {} {}\",\n+                        ParenHelper::new(lhs_paren, lhs),\n+                        op.to_string(),\n+                        ParenHelper::new(rhs_paren, rhs)).into())\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Associativity {\n+    Both,\n+    Left,\n+    None,\n+    Right,\n+}\n+\n+/// Return the associativity/fixity of an operator. The difference with `AssocOp::fixity` is that\n+/// an operator can be both left and right associative (such as `+`:\n+/// `a + b + c == (a + b) + c == a + (b + c)`.\n+///\n+/// Chained `as` and explicit `:` type coercion never need inner parenthesis so they are considered\n+/// associative.\n+fn associativity(op: &AssocOp) -> Associativity {\n+    use syntax::util::parser::AssocOp::*;\n+\n+    match *op {\n+        Inplace | Assign | AssignOp(_) => Associativity::Right,\n+        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply |\n+        As | Colon => Associativity::Both,\n+    Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft |\n+        ShiftRight | Subtract => Associativity::Left,\n+        DotDot | DotDotDot => Associativity::None\n+    }\n+}\n+\n+/// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n+fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n+    use rustc::hir::BinOp_::*;\n+    use syntax::parse::token::BinOpToken::*;\n+\n+    AssocOp::AssignOp(match op.node {\n+        BiAdd => Plus,\n+        BiBitAnd => And,\n+        BiBitOr => Or,\n+        BiBitXor => Caret,\n+        BiDiv => Slash,\n+        BiMul => Star,\n+        BiRem => Percent,\n+        BiShl => Shl,\n+        BiShr => Shr,\n+        BiSub => Minus,\n+        BiAnd | BiEq | BiGe | BiGt | BiLe | BiLt | BiNe | BiOr => panic!(\"This operator does not exist\"),\n+    })\n+}\n+\n+/// Convert an `ast::BinOp` to the corresponding assigning binary operator.\n+fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n+    use syntax::ast::BinOpKind::*;\n+    use syntax::parse::token::BinOpToken;\n+\n+    AssocOp::AssignOp(match op.node {\n+        Add => BinOpToken::Plus,\n+        BitAnd => BinOpToken::And,\n+        BitOr => BinOpToken::Or,\n+        BitXor => BinOpToken::Caret,\n+        Div => BinOpToken::Slash,\n+        Mul => BinOpToken::Star,\n+        Rem => BinOpToken::Percent,\n+        Shl => BinOpToken::Shl,\n+        Shr => BinOpToken::Shr,\n+        Sub => BinOpToken::Minus,\n+        And | Eq | Ge | Gt | Le | Lt | Ne | Or => panic!(\"This operator does not exist\"),\n+    })\n+}"}]}