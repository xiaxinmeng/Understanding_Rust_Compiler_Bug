{"sha": "a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExODg3OTEyZThhOWRjM2MxOTA4MTRkMjdiYTAwZjVmNDg4YzZjZDM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-02T11:14:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-02T11:14:44Z"}, "message": "Rollup merge of #80629 - sexxi-goose:migrations_1, r=nikomatsakis\n\nAdd lint for 2229 migrations\n\nImplements the first for RFC 2229 where we make the decision to migrate a root variable based on if the type of the variable needs Drop and if the root variable would be moved into the closure when the feature isn't enabled.\n\nr? `@nikomatsakis`", "tree": {"sha": "b30c30a72590059bc19f1e5d159d7031958a7404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b30c30a72590059bc19f1e5d159d7031958a7404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGTQkCRBK7hj4Ov3rIwAAdHIIAJxfgoyItv7d0pVFktNDYc1B\nN1lYZw050TT5w9yE5ui+55cqAg7I8l+jFrkI6skPz2IbiKEhOr3TIOx5qRNCc92s\nBI4eBVvv2lz+OGV2RlTxKmHZB1DIQJpyKhlybqoMnT8k9uG7Nzc+O70btQKkA2rg\nKXDczEJErXXCOj87X/sdTgVI0pc2iCccE1pFY5hffWwpNo8epsbcWnIUfB0SuYSu\nOC9BqFi1Rn1dovrUy/McsuzycRYvhpg9O7d0xOKe5faEjQy2T+z+v6z+RXkWeso9\ndGaKuxKABeSSUd3wU7gx8OiQK91rMIrdvbWWCTt3kYmPh8007z+Pd51TDuNl1gk=\n=BZV5\n-----END PGP SIGNATURE-----\n", "payload": "tree b30c30a72590059bc19f1e5d159d7031958a7404\nparent d60b29d1ae8147538b8d542f7ffcc03b48e2cbda\nparent 84f0a0a1c6627e83408d1faf46e29d29d2bc13e9\nauthor Jonas Schievink <jonasschievink@gmail.com> 1612264484 +0100\ncommitter GitHub <noreply@github.com> 1612264484 +0100\n\nRollup merge of #80629 - sexxi-goose:migrations_1, r=nikomatsakis\n\nAdd lint for 2229 migrations\n\nImplements the first for RFC 2229 where we make the decision to migrate a root variable based on if the type of the variable needs Drop and if the root variable would be moved into the closure when the feature isn't enabled.\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "html_url": "https://github.com/rust-lang/rust/commit/a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "html_url": "https://github.com/rust-lang/rust/commit/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda"}, {"sha": "84f0a0a1c6627e83408d1faf46e29d29d2bc13e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f0a0a1c6627e83408d1faf46e29d29d2bc13e9", "html_url": "https://github.com/rust-lang/rust/commit/84f0a0a1c6627e83408d1faf46e29d29d2bc13e9"}], "stats": {"total": 865, "additions": 812, "deletions": 53}, "files": [{"sha": "199be00990761484b84f5b9566f29e8f7a49beb5", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -2968,6 +2968,7 @@ declare_lint_pass! {\n         UNSUPPORTED_NAKED_FUNCTIONS,\n         MISSING_ABI,\n         SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n+        DISJOINT_CAPTURE_DROP_REORDER,\n     ]\n }\n \n@@ -2994,6 +2995,51 @@ declare_lint! {\n     \"detects doc comments that aren't used by rustdoc\"\n }\n \n+declare_lint! {\n+    /// The `disjoint_capture_drop_reorder` lint detects variables that aren't completely\n+    /// captured when the feature `capture_disjoint_fields` is enabled and it affects the Drop\n+    /// order of at least one path starting at this variable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![deny(disjoint_capture_drop_reorder)]\n+    /// # #![allow(unused)]\n+    /// struct FancyInteger(i32);\n+    ///\n+    /// impl Drop for FancyInteger {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"Just dropped {}\", self.0);\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Point { x: FancyInteger, y: FancyInteger }\n+    ///\n+    /// fn main() {\n+    ///   let p = Point { x: FancyInteger(10), y: FancyInteger(20) };\n+    ///\n+    ///   let c = || {\n+    ///      let x = p.x;\n+    ///   };\n+    ///\n+    ///   c();\n+    ///\n+    ///   // ... More code ...\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the above example `p.y` will be dropped at the end of `f` instead of with `c` if\n+    /// the feature `capture_disjoint_fields` is enabled.\n+    pub DISJOINT_CAPTURE_DROP_REORDER,\n+    Allow,\n+    \"Drop reorder because of `capture_disjoint_fields`\"\n+\n+}\n+\n declare_lint_pass!(UnusedDocComment => [UNUSED_DOC_COMMENTS]);\n \n declare_lint! {"}, {"sha": "04a9e65e6647d9dda6b9346e823e5a081c40d447", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 198, "deletions": 44, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -30,6 +30,7 @@\n //! then mean that all later passes would have to check for these figments\n //! and report an error, and it just seems like more mess in the end.)\n \n+use super::writeback::Resolver;\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n@@ -40,7 +41,9 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n+use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n@@ -55,6 +58,11 @@ enum PlaceAncestryRelation {\n     Divergent,\n }\n \n+/// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n+/// during capture analysis. Information in this map feeds into the minimum capture\n+/// analysis pass.\n+type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n         InferBorrowKindVisitor { fcx: self }.visit_body(body);\n@@ -92,7 +100,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n-        body: &hir::Body<'_>,\n+        body: &'tcx hir::Body<'tcx>,\n         capture_clause: hir::CaptureBy,\n     ) {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_hir_id, body.id());\n@@ -124,28 +132,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let local_def_id = closure_def_id.expect_local();\n \n-        let mut capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>> =\n-            Default::default();\n-        if !self.tcx.features().capture_disjoint_fields {\n-            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-                for (&var_hir_id, _) in upvars.iter() {\n-                    let place = self.place_for_root_variable(local_def_id, var_hir_id);\n-\n-                    debug!(\"seed place {:?}\", place);\n-\n-                    let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo {\n-                        capture_kind_expr_id: None,\n-                        path_expr_id: None,\n-                        capture_kind,\n-                    };\n-\n-                    capture_information.insert(place, info);\n-                }\n-            }\n-        }\n-\n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n@@ -155,7 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             capture_clause,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n-            capture_information,\n+            capture_information: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -172,6 +158,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n+        self.compute_min_captures(closure_def_id, delegate.capture_information);\n+\n+        let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        if should_do_migration_analysis(self.tcx, closure_hir_id) {\n+            self.perform_2229_migration_anaysis(closure_def_id, capture_clause, span, body);\n+        }\n+\n+        // We now fake capture information for all variables that are mentioned within the closure\n+        // We do this after handling migrations so that min_captures computes before\n+        if !self.tcx.features().capture_disjoint_fields {\n+            let mut capture_information: InferredCaptureInformation<'tcx> = Default::default();\n+\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                for var_hir_id in upvars.keys() {\n+                    let place = self.place_for_root_variable(local_def_id, *var_hir_id);\n+\n+                    debug!(\"seed place {:?}\", place);\n+\n+                    let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n+                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let fake_info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n+\n+                    capture_information.insert(place, fake_info);\n+                }\n+            }\n+\n+            // This will update the min captures based on this new fake information.\n+            self.compute_min_captures(closure_def_id, capture_information);\n+        }\n+\n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n@@ -197,7 +217,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.compute_min_captures(closure_def_id, delegate);\n         self.log_closure_min_capture_info(closure_def_id, span);\n \n         self.min_captures_to_closure_captures_bridge(closure_def_id);\n@@ -344,6 +363,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n     ///\n+    ///\n+    /// Note: If this function is called multiple times for the same closure, it will update\n+    ///       the existing min_capture map that is stored in TypeckResults.\n+    ///\n     /// Eg:\n     /// ```rust,no_run\n     /// struct Point { x: i32, y: i32 }\n@@ -408,11 +431,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        inferred_info: InferBorrowKind<'_, 'tcx>,\n+        capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n-        let mut root_var_min_capture_list: ty::RootVariableMinCaptureList<'_> = Default::default();\n+        if capture_information.is_empty() {\n+            return;\n+        }\n+\n+        let mut typeck_results = self.typeck_results.borrow_mut();\n \n-        for (place, capture_info) in inferred_info.capture_information.into_iter() {\n+        let mut root_var_min_capture_list =\n+            typeck_results.closure_min_captures.remove(&closure_def_id).unwrap_or_default();\n+\n+        for (place, capture_info) in capture_information.into_iter() {\n             let var_hir_id = match place.base {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n@@ -422,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let mutability = self.determine_capture_mutability(&place);\n+                    let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                     let min_cap_list =\n                         vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n@@ -487,21 +517,129 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n-                let mutability = self.determine_capture_mutability(&place);\n+                let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place =\n                     ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n \n         debug!(\"For closure={:?}, min_captures={:#?}\", closure_def_id, root_var_min_capture_list);\n+        typeck_results.closure_min_captures.insert(closure_def_id, root_var_min_capture_list);\n+    }\n \n-        if !root_var_min_capture_list.is_empty() {\n-            self.typeck_results\n-                .borrow_mut()\n-                .closure_min_captures\n-                .insert(closure_def_id, root_var_min_capture_list);\n+    /// Perform the migration analysis for RFC 2229, and emit lint\n+    /// `disjoint_capture_drop_reorder` if needed.\n+    fn perform_2229_migration_anaysis(\n+        &self,\n+        closure_def_id: DefId,\n+        capture_clause: hir::CaptureBy,\n+        span: Span,\n+        body: &'tcx hir::Body<'tcx>,\n+    ) {\n+        let need_migrations = self.compute_2229_migrations_first_pass(\n+            closure_def_id,\n+            span,\n+            capture_clause,\n+            body,\n+            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n+        );\n+\n+        if !need_migrations.is_empty() {\n+            let need_migrations_hir_id = need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n+\n+            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+\n+            let local_def_id = closure_def_id.expect_local();\n+            let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+            self.tcx.struct_span_lint_hir(\n+                lint::builtin::DISJOINT_CAPTURE_DROP_REORDER,\n+                closure_hir_id,\n+                span,\n+                |lint| {\n+                    let mut diagnostics_builder = lint.build(\n+                        \"drop order affected for closure because of `capture_disjoint_fields`\",\n+                    );\n+                    diagnostics_builder.note(&migrations_text);\n+                    diagnostics_builder.emit();\n+                },\n+            );\n+        }\n+    }\n+\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and drop order of\n+    /// some path starting at that root variable **might** be affected.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - The type of the root variable needs Drop.\n+    fn compute_2229_migrations_first_pass(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        closure_clause: hir::CaptureBy,\n+        body: &'tcx hir::Body<'tcx>,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+        fn resolve_ty<T: TypeFoldable<'tcx>>(\n+            fcx: &FnCtxt<'_, 'tcx>,\n+            span: Span,\n+            body: &'tcx hir::Body<'tcx>,\n+            ty: T,\n+        ) -> T {\n+            let mut resolver = Resolver::new(fcx, &span, body);\n+            ty.fold_with(&mut resolver)\n+        }\n+\n+        let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+            upvars\n+        } else {\n+            return vec![];\n+        };\n+\n+        let mut need_migrations = Vec::new();\n+\n+        for (&var_hir_id, _) in upvars.iter() {\n+            let ty = resolve_ty(self, closure_span, body, self.node_ty(var_hir_id));\n+\n+            if !ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+                continue;\n+            }\n+\n+            let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n+                min_captures.and_then(|m| m.get(&var_hir_id))\n+            {\n+                root_var_min_capture_list\n+            } else {\n+                // The upvar is mentioned within the closure but no path starting from it is\n+                // used.\n+\n+                match closure_clause {\n+                    // Only migrate if closure is a move closure\n+                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+\n+                    hir::CaptureBy::Ref => {}\n+                }\n+\n+                continue;\n+            };\n+\n+            let is_moved = root_var_min_capture_list\n+                .iter()\n+                .any(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)));\n+\n+            let is_not_completely_captured =\n+                root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n+\n+            if is_moved && is_not_completely_captured {\n+                need_migrations.push((var_hir_id, ty));\n+            }\n         }\n+\n+        need_migrations\n     }\n \n     fn init_capture_kind(\n@@ -613,18 +751,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// A captured place is mutable if\n     /// 1. Projections don't include a Deref of an immut-borrow, **and**\n     /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n-    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+    fn determine_capture_mutability(\n+        &self,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        place: &Place<'tcx>,\n+    ) -> hir::Mutability {\n         let var_hir_id = match place.base {\n             PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n             _ => unreachable!(),\n         };\n \n-        let bm = *self\n-            .typeck_results\n-            .borrow()\n-            .pat_binding_modes()\n-            .get(var_hir_id)\n-            .expect(\"missing binding mode\");\n+        let bm = *typeck_results.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n \n         let mut is_mutbl = match bm {\n             ty::BindByValue(mutability) => mutability,\n@@ -698,9 +835,11 @@ struct InferBorrowKind<'a, 'tcx> {\n     ///\n     /// For closure `fix_s`, (at a high level) the map contains\n     ///\n+    /// ```\n     /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n-    capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+    /// ```\n+    capture_information: InferredCaptureInformation<'tcx>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1119,6 +1258,21 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+fn should_do_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool {\n+    let (level, _) =\n+        tcx.lint_level_at_node(lint::builtin::DISJOINT_CAPTURE_DROP_REORDER, closure_id);\n+\n+    !matches!(level, lint::Level::Allow)\n+}\n+\n+fn migration_suggestion_for_2229(tcx: TyCtxt<'_>, need_migrations: &Vec<hir::HirId>) -> String {\n+    let need_migrations_strings =\n+        need_migrations.iter().map(|v| format!(\"{}\", var_name(tcx, *v))).collect::<Vec<_>>();\n+    let migrations_list_concat = need_migrations_strings.join(\", \");\n+\n+    format!(\"drop(&({}));\", migrations_list_concat)\n+}\n+\n /// Helper function to determine if we need to escalate CaptureKind from\n /// CaptureInfo A to B and returns the escalated CaptureInfo.\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)"}, {"sha": "4d18b2cb3fc49656d2f558761ffea967ce8fdd19", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -650,7 +650,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-trait Locatable {\n+crate trait Locatable {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n \n@@ -668,7 +668,7 @@ impl Locatable for hir::HirId {\n \n /// The Resolver. This is the type folding engine that detects\n /// unresolved types and so forth.\n-struct Resolver<'cx, 'tcx> {\n+crate struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,\n@@ -679,7 +679,7 @@ struct Resolver<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n-    fn new(\n+    crate fn new(\n         fcx: &'cx FnCtxt<'cx, 'tcx>,\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,"}, {"sha": "02b373620966e239c17fbae278a91d3f2aff9101", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -0,0 +1,130 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a insignificant drop (stlib defined)\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1, t2));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        println!(\"{}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// Copy types get copied into the closure instead of move. Therefore we don't need to\n+// migrate then as their drop order isn't tied to the closure.\n+fn test4_only_non_copy_types_need_migration() {\n+    let t = (String::new(), String::new());\n+\n+    // `t1` is Copy because all of its elements are Copy\n+    let t1 = (0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn test5_only_drop_types_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (String::new(), String::new());\n+\n+    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n+    let s = S(0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _s = s.0;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test6_move_closures_non_copy_types_might_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t1, t));\n+        println!(\"{} {}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test7_drop_non_drop_aggregate_need_migration() {\n+    let t = (String::new(), String::new(), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_only_non_copy_types_need_migration();\n+    test5_only_drop_types_need_migration();\n+    test6_move_closures_non_copy_types_might_need_migration();\n+    test7_drop_non_drop_aggregate_need_migration();\n+}"}, {"sha": "656c132c12deeaf7630723734c8910c5539f90ac", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -0,0 +1,105 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:13:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/insignificant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t, t1, t2));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:31:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t, t1));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:47:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:65:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:83:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _s = s.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:98:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{} {}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t1, t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:113:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "73592ce04c28f9cfebdbb727369675d319db2939", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/no_migrations.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -0,0 +1,84 @@\n+// run-pass\n+\n+// Set of test cases that don't need migrations\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+\n+// Copy types as copied by the closure instead of being moved into the closure\n+// Therefore their drop order isn't tied to the closure and won't be requiring any\n+// migrations.\n+fn test1_only_copy_types() {\n+    let t = (0i32, 0i32);\n+\n+    let c = || {\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Same as test1 but using a move closure\n+fn test2_only_copy_types_move_closure() {\n+    let t = (0i32, 0i32);\n+\n+    let c = move || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Don't need to migrate if captured by ref\n+fn test3_only_copy_types_move_closure() {\n+    let t = (String::new(), String::new());\n+\n+    let c = || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Insignificant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test4_insignificant_drop_non_drop_aggregate() {\n+    let t = (String::new(), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test migration analysis in case of Significant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test5_significant_drop_non_drop_aggregate() {\n+    let t = (Foo(0), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_only_copy_types();\n+    test2_only_copy_types_move_closure();\n+    test3_only_copy_types_move_closure();\n+    test4_insignificant_drop_non_drop_aggregate();\n+    test5_significant_drop_non_drop_aggregate();\n+\n+}"}, {"sha": "ed5e4ea8be01182e7af538000f9dae4e34869858", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -0,0 +1,137 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a significant drop (user defined)\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ConstainsDropField(Foo, Foo);\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1, t2));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        println!(\"{:?}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// The root variable might not implement drop themselves but some path starting\n+// at the root variable might implement Drop.\n+//\n+// If this path isn't captured we need to migrate for the root variable.\n+fn test4_type_contains_drop_need_migration() {\n+    let t = ConstainsDropField(Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test5_drop_non_drop_aggregate_need_migration() {\n+    let t = (Foo(0), Foo(0), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Significant and Insignificant Drop aggregates.\n+fn test6_significant_insignificant_drop_aggregate_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (Foo(0), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test7_move_closures_non_copy_types_might_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0), Foo(0));\n+\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t1, t));\n+        println!(\"{:?} {:?}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_type_contains_drop_need_migration();\n+    test5_drop_non_drop_aggregate_need_migration();\n+    test6_significant_insignificant_drop_aggregate_need_migration();\n+    test7_move_closures_non_copy_types_might_need_migration();\n+}"}, {"sha": "6c21b27b493ba579f3bf69fa9ac31dde94dda3e2", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -0,0 +1,103 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:24:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/significant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t, t1, t2));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:42:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t, t1));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:58:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{:?}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:75:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:90:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:105:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:120:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t1, t));\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "e1b446fc61f612215a85f95d1702a450a7356d00", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -7,10 +7,10 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: test::{closure#0}::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: external requirements\n   --> $DIR/escape-upvar-nested.rs:20:27\n@@ -25,10 +25,10 @@ LL | |         };\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-nested.rs:13:1"}, {"sha": "0ea1076c32ef4dd215be4056d3e9cefef645d3b5", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1887912e8a9dc3c190814d27ba00f5f488c6cd3/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=a1887912e8a9dc3c190814d27ba00f5f488c6cd3", "patch": "@@ -7,10 +7,10 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-ref.rs:17:1"}]}