{"sha": "e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZWEzOGU0MmE3ZTM2MWUzN2IxY2QzNjIyZjNiYWYxYzgwNTU5ODY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-14T21:51:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-10-04T19:20:37Z"}, "message": "Further cleanup in resolve\n\n`try_define` is not used in build_reduced_graph anymore\nCollection of field names for error reporting is optimized\nSome comments added", "tree": {"sha": "0cd244ff5fb2d6f44d0e6bed52483210f48f4b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd244ff5fb2d6f44d0e6bed52483210f48f4b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "html_url": "https://github.com/rust-lang/rust/commit/e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19c16acfbfb718606a2b1519bbd9db43b451761", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19c16acfbfb718606a2b1519bbd9db43b451761", "html_url": "https://github.com/rust-lang/rust/commit/d19c16acfbfb718606a2b1519bbd9db43b451761"}], "stats": {"total": 130, "additions": 54, "deletions": 76}, "files": [{"sha": "8aa9d3cf9ca31bd3f9ddbe0d17b117c67a32ad51", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "patch": "@@ -699,6 +699,8 @@ impl<'a, 'tcx> CrateMetadata {\n                             }\n                         }\n                         Def::Variant(def_id) => {\n+                            // Braced variants, unlike structs, generate unusable names in\n+                            // value namespace, they are reserved for possible future use.\n                             let vkind = self.get_variant_kind(child_index).unwrap();\n                             let ctor_def = Def::VariantCtor(def_id, vkind.ctor_kind());\n                             callback(def::Export { def: ctor_def, name: name });"}, {"sha": "f689ed6a41cb68117684a3b8c1b1b12661540721", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 46, "deletions": 68, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "patch": "@@ -31,7 +31,6 @@ use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n-use syntax::parse::token;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n@@ -77,6 +76,12 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n+    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n+        if !field_names.is_empty() {\n+            self.field_names.insert(def_id, field_names);\n+        }\n+    }\n+\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n@@ -301,28 +306,26 @@ impl<'b> Resolver<'b> {\n                     self.define(parent, name, ValueNS, (ctor_def, sp, vis));\n                 }\n \n-                // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields().iter().enumerate().map(|(index, field)| {\n+                // Record field names for error reporting.\n+                let field_names = struct_def.fields().iter().filter_map(|field| {\n                     self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n-                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n-                self.structs.insert(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n \n-                // Record the def ID and fields of this union.\n-                let field_names = vdata.fields().iter().enumerate().map(|(index, field)| {\n+                // Record field names for error reporting.\n+                let field_names = vdata.fields().iter().filter_map(|field| {\n                     self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n-                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n-                self.structs.insert(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n             }\n \n             ItemKind::DefaultImpl(..) | ItemKind::Impl(..) => {}\n@@ -347,18 +350,17 @@ impl<'b> Resolver<'b> {\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n         let name = variant.node.name.name;\n-        let ctor_kind = CtorKind::from_vdata(&variant.node.data);\n-        if variant.node.data.is_struct() {\n-            // Not adding fields for variants as they are not accessed with a self receiver\n-            let variant_def_id = self.definitions.local_def_id(variant.node.data.id());\n-            self.structs.insert(variant_def_id, Vec::new());\n-        }\n+        let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n-        // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(self.definitions.local_def_id(variant.node.data.id()));\n-        let ctor_def = Def::VariantCtor(self.definitions.local_def_id(variant.node.data.id()),\n-                                        ctor_kind);\n+        // Define a name in the type namespace.\n+        let def = Def::Variant(def_id);\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n+\n+        // Define a constructor name in the value namespace.\n+        // Braced variants, unlike structs, generate unusable names in\n+        // value namespace, they are reserved for possible future use.\n+        let ctor_kind = CtorKind::from_vdata(&variant.node.data);\n+        let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n         self.define(parent, name, ValueNS, (ctor_def, variant.span, vis));\n     }\n \n@@ -407,79 +409,55 @@ impl<'b> Resolver<'b> {\n         };\n \n         match def {\n-            Def::Mod(_) | Def::Enum(..) => {\n-                debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n-                       name, vis);\n+            Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(..) => {\n-                debug!(\"(building reduced graph for external crate) building variant {}\", name);\n-                // All variants are defined in both type and value namespaces as future-proofing.\n-                let vkind = self.session.cstore.variant_kind(def_id).unwrap();\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n-                if vkind == ty::VariantKind::Struct {\n-                    // Not adding fields for variants as they are not accessed with a self receiver\n-                    self.structs.insert(def_id, Vec::new());\n-                }\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::VariantCtor(..) => {\n-                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n-                       name);\n-                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Trait(_) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\", name);\n-\n-                // If this is a trait, add all the trait item names to the trait\n-                // info.\n+            Def::Trait(..) => {\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n+                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n \n+                // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n-                for &trait_item_def in &trait_item_def_ids {\n-                    let trait_item_name =\n-                        self.session.cstore.def_key(trait_item_def)\n-                            .disambiguated_data.data.get_opt_name()\n-                            .expect(\"opt_item_name returned None for trait\");\n-\n-                    debug!(\"(building reduced graph for external crate) ... adding trait item \\\n-                            '{}'\",\n-                           trait_item_name);\n-\n+                for trait_item_def_id in trait_item_def_ids {\n+                    let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n+                                              .disambiguated_data.data.get_opt_name()\n+                                              .expect(\"opt_item_name returned None for trait\");\n                     self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n-\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(..) => {\n-                debug!(\"(building reduced graph for external crate) building type and value for {}\",\n-                       name);\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n \n-                // Record the def ID and fields of this struct.\n-                let fields = self.session.cstore.struct_field_names(def_id);\n-                self.structs.insert(def_id, fields);\n+                // Record field names for error reporting.\n+                let field_names = self.session.cstore.struct_field_names(def_id);\n+                self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Union(_) => {\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+            Def::Union(..) => {\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n \n-                // Record the def ID and fields of this union.\n-                let fields = self.session.cstore.struct_field_names(def_id);\n-                self.structs.insert(def_id, fields);\n+                // Record field names for error reporting.\n+                let field_names = self.session.cstore.struct_field_names(def_id);\n+                self.insert_field_names(def_id, field_names);\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -488,7 +466,7 @@ impl<'b> Resolver<'b> {\n             Def::Label(..) |\n             Def::SelfTy(..) |\n             Def::Err => {\n-                bug!(\"didn't expect `{:?}`\", def);\n+                bug!(\"unexpected definition: {:?}\", def);\n             }\n         }\n     }"}, {"sha": "3dbe4d915366461b184c4a063b3807534baf7a87", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ea38e42a7e361e37b1cd3622f3baf1c8055986/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e8ea38e42a7e361e37b1cd3622f3baf1c8055986", "patch": "@@ -1006,7 +1006,9 @@ pub struct Resolver<'a> {\n \n     trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n \n-    structs: FnvHashMap<DefId, Vec<Name>>,\n+    // Names of fields of an item `DefId` accessible with dot syntax.\n+    // Used for hints during error reporting.\n+    field_names: FnvHashMap<DefId, Vec<Name>>,\n \n     // All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n@@ -1218,7 +1220,7 @@ impl<'a> Resolver<'a> {\n             prelude: None,\n \n             trait_item_map: FnvHashMap(),\n-            structs: FnvHashMap(),\n+            field_names: FnvHashMap(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n@@ -2779,8 +2781,8 @@ impl<'a> Resolver<'a> {\n                 match resolution.base_def {\n                     Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n                     Def::Struct(did) | Def::Variant(did) if resolution.depth == 0 => {\n-                        if let Some(fields) = self.structs.get(&did) {\n-                            if fields.iter().any(|&field_name| name == field_name) {\n+                        if let Some(field_names) = self.field_names.get(&did) {\n+                            if field_names.iter().any(|&field_name| name == field_name) {\n                                 return Field;\n                             }\n                         }\n@@ -2852,7 +2854,6 @@ impl<'a> Resolver<'a> {\n                         _ => false,\n                     };\n                     if is_struct_variant {\n-                        let _ = self.structs.contains_key(&path_res.base_def.def_id());\n                         let path_name = path_names_to_string(path, 0);\n \n                         let mut err = resolve_struct_error(self,\n@@ -2885,9 +2886,6 @@ impl<'a> Resolver<'a> {\n                     }\n                 } else {\n                     // Be helpful if the name refers to a struct\n-                    // (The pattern matching def_tys where the id is in self.structs\n-                    // matches on regular structs while excluding tuple- and enum-like\n-                    // structs, which wouldn't result in this error.)\n                     let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS)"}]}