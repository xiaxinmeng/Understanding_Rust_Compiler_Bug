{"sha": "e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YTg4NDAwMzNiNDRhNWNlMzI1NjJkNmMxMjM4NmM0ZWU3ZjRlYzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T02:45:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T16:31:45Z"}, "message": "rollup merge of #18519 : Gankro/collect-smash", "tree": {"sha": "93b8e01ee34f409477a9c05c0f6865cc51f89795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93b8e01ee34f409477a9c05c0f6865cc51f89795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "html_url": "https://github.com/rust-lang/rust/commit/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd8c2376853e44675b4b91daf69e42d930dd813", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd8c2376853e44675b4b91daf69e42d930dd813", "html_url": "https://github.com/rust-lang/rust/commit/dcd8c2376853e44675b4b91daf69e42d930dd813"}, {"sha": "112c8a966fbdb52ff2a535dc8e6df3a8b3cb8fb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/112c8a966fbdb52ff2a535dc8e6df3a8b3cb8fb2", "html_url": "https://github.com/rust-lang/rust/commit/112c8a966fbdb52ff2a535dc8e6df3a8b3cb8fb2"}], "stats": {"total": 3503, "additions": 1797, "deletions": 1706}, "files": [{"sha": "b7c80901ef359c8f657da35445def0dea2af4986", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -944,10 +944,10 @@ An example of `use` declarations:\n ```\n use std::iter::range_step;\n use std::option::{Some, None};\n-use std::collections::hashmap::{mod, HashMap};\n+use std::collections::hash_map::{mod, HashMap};\n \n-# fn foo<T>(_: T){}\n-# fn bar(map: HashMap<String, uint>, set: hashmap::HashSet<String>){}\n+fn foo<T>(_: T){}\n+fn bar(map1: HashMap<String, uint>, map2: hash_map::HashMap<String, uint>){}\n \n fn main() {\n     // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'\n@@ -957,10 +957,10 @@ fn main() {\n     // std::option::None]);'\n     foo(vec![Some(1.0f64), None]);\n \n-    // Both `hash` and `HashMap` are in scope.\n-    let map = HashMap::new();\n-    let set = hashmap::HashSet::new();\n-    bar(map, set);\n+    // Both `hash_map` and `HashMap` are in scope.\n+    let map1 = HashMap::new();\n+    let map2 = hash_map::HashMap::new();\n+    bar(map1, map2);\n }\n ```\n \n@@ -4096,7 +4096,7 @@ cause transitions between the states. The lifecycle states of a task are:\n \n * running\n * blocked\n-* panicked \n+* panicked\n * dead\n \n A task begins its lifecycle &mdash; once it has been spawned &mdash; in the"}, {"sha": "8481111ae91a3cecdbf95801a482e23a3dccf05e", "filename": "src/libcollections/binary_heap.rs", "status": "renamed", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -19,14 +19,14 @@\n //!\n //! This is a larger example which implements [Dijkstra's algorithm][dijkstra]\n //! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n-//! It showcases how to use the `PriorityQueue` with custom types.\n+//! It showcases how to use the `BinaryHeap` with custom types.\n //!\n //! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n //! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n //! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n //!\n //! ```\n-//! use std::collections::PriorityQueue;\n+//! use std::collections::BinaryHeap;\n //! use std::uint;\n //!\n //! #[deriving(Eq, PartialEq)]\n@@ -68,7 +68,7 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = PriorityQueue::new();\n+//!     let mut pq = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n@@ -166,52 +166,52 @@ use vec::Vec;\n ///\n /// This will be a max-heap.\n #[deriving(Clone)]\n-pub struct PriorityQueue<T> {\n+pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-impl<T: Ord> Default for PriorityQueue<T> {\n+impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n-    fn default() -> PriorityQueue<T> { PriorityQueue::new() }\n+    fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n }\n \n-impl<T: Ord> PriorityQueue<T> {\n-    /// Creates an empty `PriorityQueue` as a max-heap.\n+impl<T: Ord> BinaryHeap<T> {\n+    /// Creates an empty `BinaryHeap` as a max-heap.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// use std::collections::BinaryHeap;\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n-    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n+    pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n \n-    /// Creates an empty `PriorityQueue` with a specific capacity.\n+    /// Creates an empty `BinaryHeap` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n-    /// so that the `PriorityQueue` does not have to be reallocated\n+    /// so that the `BinaryHeap` does not have to be reallocated\n     /// until it contains at least that many values.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(10u);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n-    pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n-        PriorityQueue { data: Vec::with_capacity(capacity) }\n+    pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n+        BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Creates a `PriorityQueue` from a vector. This is sometimes called\n+    /// Creates a `BinaryHeap` from a vector. This is sometimes called\n     /// `heapifying` the vector.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq = PriorityQueue::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n-    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n-        let mut q = PriorityQueue{data: xs,};\n+    pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n+        let mut q = BinaryHeap{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {\n             n -= 1;\n@@ -226,8 +226,8 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4]);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in pq.iter() {\n@@ -243,9 +243,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// assert_eq!(pq.top(), None);\n     ///\n     /// pq.push(1i);\n@@ -263,36 +263,36 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(100u);\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserves capacity for exactly `n` elements in the `PriorityQueue`.\n+    /// Reserves capacity for exactly `n` elements in the `BinaryHeap`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve_exact(100u);\n     /// assert!(pq.capacity() == 100u);\n     /// ```\n     pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n \n-    /// Reserves capacity for at least `n` elements in the `PriorityQueue`.\n+    /// Reserves capacity for at least `n` elements in the `BinaryHeap`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n@@ -306,9 +306,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::from_vec(vec![1i, 3]);\n+    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n     /// assert_eq!(pq.pop(), Some(3i));\n     /// assert_eq!(pq.pop(), Some(1i));\n@@ -332,9 +332,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// pq.push(3i);\n     /// pq.push(5i);\n     /// pq.push(1i);\n@@ -354,9 +354,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// pq.push(1i);\n     /// pq.push(5i);\n     ///\n@@ -380,9 +380,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     ///\n     /// assert_eq!(pq.replace(1i), None);\n     /// assert_eq!(pq.replace(3i), Some(1i));\n@@ -400,33 +400,33 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    /// Consumes the `PriorityQueue` and returns the underlying vector\n+    /// Consumes the `BinaryHeap` and returns the underlying vector\n     /// in arbitrary order.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// let vec = pq.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n+    pub fn into_vec(self) -> Vec<T> { let BinaryHeap{data: v} = self; v }\n \n-    /// Consumes the `PriorityQueue` and returns a vector in sorted\n+    /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n     /// pq.push(6);\n     /// pq.push(3);\n     ///\n@@ -504,7 +504,7 @@ impl<T: Ord> PriorityQueue<T> {\n     pub fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-/// `PriorityQueue` iterator.\n+/// `BinaryHeap` iterator.\n pub struct Items <'a, T:'a> {\n     iter: slice::Items<'a, T>,\n }\n@@ -517,14 +517,14 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T: Ord> FromIterator<T> for PriorityQueue<T> {\n-    fn from_iter<Iter: Iterator<T>>(mut iter: Iter) -> PriorityQueue<T> {\n+impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n+    fn from_iter<Iter: Iterator<T>>(mut iter: Iter) -> BinaryHeap<T> {\n         let vec: Vec<T> = iter.collect();\n-        PriorityQueue::from_vec(vec)\n+        BinaryHeap::from_vec(vec)\n     }\n }\n \n-impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n+impl<T: Ord> Extendable<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n@@ -541,14 +541,14 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n mod tests {\n     use std::prelude::*;\n \n-    use priority_queue::PriorityQueue;\n+    use super::BinaryHeap;\n     use vec::Vec;\n \n     #[test]\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = PriorityQueue::from_vec(data);\n+        let pq = BinaryHeap::from_vec(data);\n         let mut i = 0;\n         for el in pq.iter() {\n             assert_eq!(*el, iterout[i]);\n@@ -561,7 +561,7 @@ mod tests {\n         let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n-        let mut heap = PriorityQueue::from_vec(data);\n+        let mut heap = BinaryHeap::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n             assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n@@ -570,7 +570,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = PriorityQueue::from_vec(vec!(2i, 4, 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == 9);\n         heap.push(11);\n@@ -592,7 +592,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = PriorityQueue::from_vec(vec!(box 2i, box 4, box 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == box 9);\n         heap.push(box 11);\n@@ -614,7 +614,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -628,7 +628,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -641,7 +641,7 @@ mod tests {\n     }\n \n     fn check_to_vec(mut data: Vec<int>) {\n-        let heap = PriorityQueue::from_vec(data.clone());\n+        let heap = BinaryHeap::from_vec(data.clone());\n         let mut v = heap.clone().into_vec();\n         v.sort();\n         data.sort();\n@@ -669,27 +669,27 @@ mod tests {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n     fn test_empty_top() {\n-        let empty: PriorityQueue<int> = PriorityQueue::new();\n+        let empty: BinaryHeap<int> = BinaryHeap::new();\n         assert!(empty.top().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n         heap.replace(5).is_none();\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop().unwrap(), x);", "previous_filename": "src/libcollections/priority_queue.rs"}, {"sha": "b7085c96aed154f276abf9a1b7817b7d548c7621", "filename": "src/libcollections/bit.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for maintenance),\n+// they should be in separate files/modules, with BitvSet only using Bitv's public API.\n+\n //! Collections implemented with bit vectors.\n //!\n //! # Example\n@@ -1654,7 +1657,7 @@ mod tests {\n     use std::rand::Rng;\n     use test::Bencher;\n \n-    use bitv::{Bitv, BitvSet, from_fn, from_bytes};\n+    use super::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;\n ", "previous_filename": "src/libcollections/bitv.rs"}, {"sha": "e3dfabfa29549d53499e678f7d5aaf133ef590e1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -23,7 +23,7 @@ use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n \n-use ringbuf::RingBuf;\n+use ring_buf::RingBuf;\n \n /// A map based on a B-Tree.\n ///"}, {"sha": "282128099da0a3d2021140f43839bcbb17356fd4", "filename": "src/libcollections/btree/mod.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -8,27 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::map::BTreeMap;\n-pub use self::map::Entries;\n-pub use self::map::MutEntries;\n-pub use self::map::MoveEntries;\n-pub use self::map::Keys;\n-pub use self::map::Values;\n-pub use self::map::Entry;\n-pub use self::map::Occupied;\n-pub use self::map::Vacant;\n-pub use self::map::OccupiedEntry;\n-pub use self::map::VacantEntry;\n-\n-pub use self::set::BTreeSet;\n-pub use self::set::Items;\n-pub use self::set::MoveItems;\n-pub use self::set::DifferenceItems;\n-pub use self::set::UnionItems;\n-pub use self::set::SymDifferenceItems;\n-pub use self::set::IntersectionItems;\n-\n-\n mod node;\n-mod map;\n-mod set;\n+pub mod map;\n+pub mod set;"}, {"sha": "27752207b9797d93ce92e15498c6a93f40a128cb", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use super::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n use core::default::Default;\n use core::{iter, fmt};"}, {"sha": "bcae4fe68c9b87bd3ee514e72ed06fbbf71392b7", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -155,7 +155,7 @@ mod test {\n     use std::prelude::*;\n     use std::mem;\n \n-    use enum_set::{EnumSet, CLike};\n+    use super::{EnumSet, CLike};\n \n     #[deriving(PartialEq, Show)]\n     #[repr(uint)]"}, {"sha": "5ec8a85fb0fb771e227e5a8249859bb986aa5120", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -37,34 +37,72 @@ extern crate alloc;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-pub use bitv::{Bitv, BitvSet};\n-pub use btree::{BTreeMap, BTreeSet};\n+\n+pub use binary_heap::BinaryHeap;\n+pub use bitv::Bitv;\n+pub use bitv_set::BitvSet;\n+pub use btree_map::BTreeMap;\n+pub use btree_set::BTreeSet;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n-pub use priority_queue::PriorityQueue;\n-pub use ringbuf::RingBuf;\n-pub use smallintmap::SmallIntMap;\n+pub use ring_buf::RingBuf;\n pub use string::String;\n-pub use treemap::{TreeMap, TreeSet};\n-pub use trie::{TrieMap, TrieSet};\n+pub use tree_map::TreeMap;\n+pub use tree_set::TreeSet;\n+pub use trie_map::TrieMap;\n+pub use trie_set::TrieSet;\n pub use vec::Vec;\n+pub use vec_map::VecMap;\n \n mod macros;\n \n-pub mod bitv;\n-pub mod btree;\n+pub mod binary_heap;\n+mod bit;\n+mod btree;\n pub mod dlist;\n pub mod enum_set;\n-pub mod priority_queue;\n-pub mod ringbuf;\n-pub mod smallintmap;\n-pub mod treemap;\n-pub mod trie;\n+pub mod ring_buf;\n+mod tree;\n+mod trie;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n pub mod hash;\n+pub mod vec_map;\n+\n+pub mod bitv {\n+    pub use bit::{Bitv, Bits, from_fn, from_bytes};\n+}\n+\n+pub mod bitv_set {\n+    pub use bit::{BitvSet, BitPositions, TwoBitPositions};\n+}\n+\n+pub mod tree_map {\n+    pub use tree::map::*;\n+}\n+\n+pub mod tree_set {\n+    pub use tree::set::*;\n+}\n+\n+pub mod trie_map {\n+    pub use trie::map::*;\n+}\n+\n+pub mod trie_set {\n+    pub use trie::set::*;\n+}\n+\n+pub mod btree_map {\n+    pub use btree::map::*;\n+}\n+\n+pub mod btree_set {\n+    pub use btree::set::*;\n+}\n+\n \n #[cfg(test)] mod bench;\n "}, {"sha": "3c4c3fce61d774835fb0b482c1763ca4fe6b9699", "filename": "src/libcollections/ring_buf.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "previous_filename": "src/libcollections/ringbuf.rs"}, {"sha": "62182575c6d165ffa7c8a7fb621166dbd012f0a2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -62,7 +62,7 @@ use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n use core::prelude::{range};\n \n use hash;\n-use ringbuf::RingBuf;\n+use ring_buf::RingBuf;\n use string::String;\n use unicode;\n use vec::Vec;"}, {"sha": "9742bddb1f6594f0c971dbe22c2d1049d5778d25", "filename": "src/libcollections/tree/map.rs", "status": "renamed", "additions": 21, "deletions": 970, "changes": 991, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -8,37 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Maps are collections of unique keys with corresponding values, and sets are\n-//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n-//! `std::container` define the basic interface.\n-//!\n-//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n-//!\n-//! `TreeMap`s are ordered.\n-//!\n-//! ## Example\n-//!\n-//! ```{rust}\n-//! use std::collections::TreeSet;\n-//!\n-//! let mut tree_set = TreeSet::new();\n-//!\n-//! tree_set.insert(2i);\n-//! tree_set.insert(1i);\n-//! tree_set.insert(3i);\n-//!\n-//! for i in tree_set.iter() {\n-//!    println!(\"{}\", i) // prints 1, then 2, then 3\n-//! }\n-//! ```\n-\n use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n-use core::iter::Peekable;\n use core::iter;\n use core::mem::{replace, swap};\n use core::ptr;\n@@ -378,7 +353,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Gets a lazy iterator that consumes the treemap.\n+    /// Gets a lazy iterator that consumes the TreeMap.\n     ///\n     /// # Example\n     ///\n@@ -592,7 +567,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use collections::treemap::TreeMap;\n+    /// use std::collections::TreeMap;\n     ///\n     /// fn get_headers() -> TreeMap<String, String> {\n     ///     let mut result = TreeMap::new();\n@@ -621,7 +596,9 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut t = collections::treemap::TreeMap::new();\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut t = TreeMap::new();\n     /// t.insert(\"Content-Type\", \"application/xml\");\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n@@ -1075,616 +1052,6 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n \n }\n \n-impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-/// An implementation of the `Set` trait on top of the `TreeMap` container. The\n-/// only requirement is that the type of the elements contained ascribes to the\n-/// `Ord` trait.\n-///\n-/// ## Example\n-///\n-/// ```{rust}\n-/// use std::collections::TreeSet;\n-///\n-/// let mut set = TreeSet::new();\n-///\n-/// set.insert(2i);\n-/// set.insert(1i);\n-/// set.insert(3i);\n-///\n-/// for i in set.iter() {\n-///    println!(\"{}\", i) // prints 1, then 2, then 3\n-/// }\n-///\n-/// set.remove(&3);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"set does not contain a 3 anymore\");\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n-/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n-///\n-/// ```\n-/// use std::collections::TreeSet;\n-///\n-/// // We need `Eq` and `PartialEq`, these can be derived.\n-/// #[deriving(Eq, PartialEq)]\n-/// struct Troll<'a> {\n-///     name: &'a str,\n-///     level: uint,\n-/// }\n-///\n-/// // Implement `Ord` and sort trolls by level.\n-/// impl<'a> Ord for Troll<'a> {\n-///     fn cmp(&self, other: &Troll) -> Ordering {\n-///         // If we swap `self` and `other`, we get descending ordering.\n-///         self.level.cmp(&other.level)\n-///     }\n-/// }\n-///\n-/// // `PartialOrd` needs to be implemented as well.\n-/// impl<'a> PartialOrd for Troll<'a> {\n-///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n-///         Some(self.cmp(other))\n-///     }\n-/// }\n-///\n-/// let mut trolls = TreeSet::new();\n-///\n-/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n-/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n-/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n-/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n-///\n-/// println!(\"You are facing {} trolls!\", trolls.len());\n-///\n-/// // Print the trolls, ordered by level with smallest level first\n-/// for x in trolls.iter() {\n-///     println!(\"level {}: {}!\", x.level, x.name);\n-/// }\n-///\n-/// // Kill all trolls\n-/// trolls.clear();\n-/// assert_eq!(trolls.len(), 0);\n-/// ```\n-#[deriving(Clone)]\n-pub struct TreeSet<T> {\n-    map: TreeMap<T, ()>\n-}\n-\n-impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n-    #[inline]\n-    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-}\n-\n-impl<T: Eq + Ord> Eq for TreeSet<T> {}\n-\n-impl<T: Ord> PartialOrd for TreeSet<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n-        self.map.partial_cmp(&other.map)\n-    }\n-}\n-\n-impl<T: Ord> Ord for TreeSet<T> {\n-    #[inline]\n-    fn cmp(&self, other: &TreeSet<T>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<T: Ord + Show> Show for TreeSet<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-impl<T: Ord> Default for TreeSet<T> {\n-    #[inline]\n-    fn default() -> TreeSet<T> { TreeSet::new() }\n-}\n-\n-impl<T: Ord> TreeSet<T> {\n-    /// Creates an empty `TreeSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    /// ```\n-    #[inline]\n-    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Gets a lazy iterator over the values in the set, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in ascending order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets a lazy iterator over the values in the set, in descending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in descending order.\n-    /// for x in set.rev_iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n-        RevSetItems{iter: self.map.rev_iter()}\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out of the\n-    /// set in ascending order. The set cannot be used after calling this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Not possible with a regular `.iter()`\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n-    /// ```\n-    #[inline]\n-    pub fn into_iter(self) -> MoveSetItems<T> {\n-        self.map.into_iter().map(|(value, _)| value)\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n-    /// If all elements in the set are less than `v` empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n-    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.lower_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.lower_bound(v)}\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value greater than `v`.\n-    /// If all elements in the set are less than or equal to `v` an\n-    /// empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.upper_bound(v)}\n-    }\n-\n-    /// Visits the values representing the difference, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1 then 2\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the symmetric difference, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 4, 5 in ascending order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the intersection, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in ascending order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the union, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4, 5 in ascending order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1i);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1i);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// v.insert(1i);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, value: &T) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        self.intersection(other).next().is_none()\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n-\n-            b = y.next();\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let mut set = BTreeSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let mut set = BTreeSet::new();\n-    ///\n-    /// set.insert(2i);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-/// A lazy forward iterator over a set.\n-pub struct SetItems<'a, T:'a> {\n-    iter: Entries<'a, T, ()>\n-}\n-\n-/// A lazy backward iterator over a set.\n-pub struct RevSetItems<'a, T:'a> {\n-    iter: RevEntries<'a, T, ()>\n-}\n-\n-/// A lazy forward iterator over a set that consumes the set while iterating.\n-pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n-\n-/// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n-                        short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n \n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -1908,30 +1275,6 @@ impl<S: Writer, K: Ord + Hash<S>, V: Hash<S>> Hash<S> for TreeMap<K, V> {\n     }\n }\n \n-impl<T: Ord> FromIterator<T> for TreeSet<T> {\n-    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n-        let mut set = TreeSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl<T: Ord> Extendable<T> for TreeSet<T> {\n-    #[inline]\n-    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n-impl<S: Writer, T: Ord + Hash<S>> Hash<S> for TreeSet<T> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n \n #[cfg(test)]\n mod test_treemap {\n@@ -2448,6 +1791,22 @@ mod test_treemap {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_swap() {\n+        let mut m = TreeMap::new();\n+        assert_eq!(m.swap(1u, 2i), None);\n+        assert_eq!(m.swap(1u, 3i), Some(2));\n+        assert_eq!(m.swap(1u, 4i), Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = TreeMap::new();\n+        m.insert(1u, 2i);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n+    }\n }\n \n #[cfg(test)]\n@@ -2557,311 +1916,3 @@ mod bench {\n     }\n }\n \n-#[cfg(test)]\n-mod test_set {\n-    use std::prelude::*;\n-    use std::hash;\n-\n-    use super::{TreeMap, TreeSet};\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut s = TreeSet::new();\n-        s.clear();\n-        assert!(s.insert(5i));\n-        assert!(s.insert(12));\n-        assert!(s.insert(19));\n-        s.clear();\n-        assert!(!s.contains(&5));\n-        assert!(!s.contains(&12));\n-        assert!(!s.contains(&19));\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = TreeSet::new();\n-        let mut ys = TreeSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5i));\n-        assert!(ys.insert(11i));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = TreeSet::new();\n-        assert!(a.insert(0i));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = TreeSet::new();\n-        assert!(b.insert(0i));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 0;\n-        for x in m.iter() {\n-            assert_eq!(*x, n);\n-            n += 1\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 4;\n-        for x in m.rev_iter() {\n-            assert_eq!(*x, n);\n-            n -= 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let s: TreeSet<int> = range(0i, 5).collect();\n-\n-        let mut n = 0;\n-        for x in s.into_iter() {\n-            assert_eq!(x, n);\n-            n += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter_size_hint() {\n-        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n-\n-        let mut it = s.into_iter();\n-\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_clone_eq() {\n-      let mut m = TreeSet::new();\n-\n-      m.insert(1i);\n-      m.insert(2);\n-\n-      assert!(m.clone() == m);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = TreeSet::new();\n-      let mut y = TreeSet::new();\n-\n-      x.insert(1i);\n-      x.insert(2);\n-      x.insert(3);\n-\n-      y.insert(3i);\n-      y.insert(2);\n-      y.insert(1);\n-\n-      assert!(hash::hash(&x) == hash::hash(&y));\n-    }\n-\n-    fn check(a: &[int],\n-             b: &[int],\n-             expected: &[int],\n-             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n-        let mut set_a = TreeSet::new();\n-        let mut set_b = TreeSet::new();\n-\n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n-\n-        let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(*x, expected[i]);\n-            i += 1;\n-            true\n-        });\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n-        }\n-\n-        check_intersection([], [], []);\n-        check_intersection([1, 2, 3], [], []);\n-        check_intersection([], [1, 2, 3], []);\n-        check_intersection([2], [1, 2, 3], [2]);\n-        check_intersection([1, 2, 3], [2], [2]);\n-        check_intersection([11, 1, 3, 77, 103, 5, -5],\n-                           [2, 11, 77, -9, -42, 5, 3],\n-                           [3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n-        }\n-\n-        check_difference([], [], []);\n-        check_difference([1, 12], [], [1, 12]);\n-        check_difference([], [1, 2, 3, 9], []);\n-        check_difference([1, 3, 5, 9, 11],\n-                         [3, 9],\n-                         [1, 5, 11]);\n-        check_difference([-5, 11, 22, 33, 40, 42],\n-                         [-12, -5, 14, 23, 34, 38, 39, 50],\n-                         [11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n-        }\n-\n-        check_symmetric_difference([], [], []);\n-        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n-        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n-        check_symmetric_difference([1, 3, 5, 9, 11],\n-                                   [-2, 3, 9, 14, 22],\n-                                   [-2, 1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        fn check_union(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.union(y).all(f))\n-        }\n-\n-        check_union([], [], []);\n-        check_union([1, 2, 3], [2], [1, 2, 3]);\n-        check_union([2], [1, 2, 3], [1, 2, 3]);\n-        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n-                    [-2, 1, 5, 9, 13, 19],\n-                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_zip() {\n-        let mut x = TreeSet::new();\n-        x.insert(5u);\n-        x.insert(12u);\n-        x.insert(11u);\n-\n-        let mut y = TreeSet::new();\n-        y.insert(\"foo\");\n-        y.insert(\"bar\");\n-\n-        let x = x;\n-        let y = y;\n-        let mut z = x.iter().zip(y.iter());\n-\n-        // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert!(result.is_none());\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut m = TreeMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = TreeMap::new();\n-        m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set: TreeSet<int> = TreeSet::new();\n-        let empty: TreeSet<int> = TreeSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n-    }\n-}", "previous_filename": "src/libcollections/treemap.rs"}, {"sha": "ac8279c92feeb8f3f73cef427ff69b2eba3a17e3", "filename": "src/libcollections/tree/mod.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n+//!\n+//! `TreeMap`s are ordered.\n+//!\n+//! ## Example\n+//!\n+//! ```{rust}\n+//! use std::collections::TreeSet;\n+//!\n+//! let mut tree_set = TreeSet::new();\n+//!\n+//! tree_set.insert(2i);\n+//! tree_set.insert(1i);\n+//! tree_set.insert(3i);\n+//!\n+//! for i in tree_set.iter() {\n+//!    println!(\"{}\", i) // prints 1, then 2, then 3\n+//! }\n+//! ```\n+\n+pub mod map;\n+pub mod set;\n\\ No newline at end of file"}, {"sha": "d24a8234b20b8d3a53b76dd28237cf7e557fc418", "filename": "src/libcollections/tree/set.rs", "status": "added", "additions": 950, "deletions": 0, "changes": 950, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -0,0 +1,950 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::default::Default;\n+use core::fmt;\n+use core::fmt::Show;\n+use core::iter::Peekable;\n+use core::iter;\n+use std::hash::{Writer, Hash};\n+\n+use tree_map::{TreeMap, Entries, RevEntries, MoveEntries};\n+\n+/// An implementation of the `Set` trait on top of the `TreeMap` container. The\n+/// only requirement is that the type of the elements contained ascribes to the\n+/// `Ord` trait.\n+///\n+/// ## Example\n+///\n+/// ```{rust}\n+/// use std::collections::TreeSet;\n+///\n+/// let mut set = TreeSet::new();\n+///\n+/// set.insert(2i);\n+/// set.insert(1i);\n+/// set.insert(3i);\n+///\n+/// for i in set.iter() {\n+///    println!(\"{}\", i) // prints 1, then 2, then 3\n+/// }\n+///\n+/// set.remove(&3);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"set does not contain a 3 anymore\");\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeSet;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descending ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// let mut trolls = TreeSet::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for x in trolls.iter() {\n+///     println!(\"level {}: {}!\", x.level, x.name);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n+/// ```\n+#[deriving(Clone)]\n+pub struct TreeSet<T> {\n+    map: TreeMap<T, ()>\n+}\n+\n+impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n+    #[inline]\n+    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n+}\n+\n+impl<T: Eq + Ord> Eq for TreeSet<T> {}\n+\n+impl<T: Ord> PartialOrd for TreeSet<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n+        self.map.partial_cmp(&other.map)\n+    }\n+}\n+\n+impl<T: Ord> Ord for TreeSet<T> {\n+    #[inline]\n+    fn cmp(&self, other: &TreeSet<T>) -> Ordering {\n+        iter::order::cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+impl<T: Ord + Show> Show for TreeSet<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl<T: Ord> Default for TreeSet<T> {\n+    #[inline]\n+    fn default() -> TreeSet<T> { TreeSet::new() }\n+}\n+\n+impl<T: Ord> TreeSet<T> {\n+    /// Creates an empty `TreeSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    /// ```\n+    #[inline]\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Gets a lazy iterator over the values in the set, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in ascending order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.iter()}\n+    }\n+\n+    /// Gets a lazy iterator over the values in the set, in descending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in descending order.\n+    /// for x in set.rev_iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n+        RevSetItems{iter: self.map.rev_iter()}\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each value out of the\n+    /// set in ascending order. The set cannot be used after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+    /// ```\n+    #[inline]\n+    pub fn into_iter(self) -> MoveSetItems<T> {\n+        self.map.into_iter().map(|(value, _)| value)\n+    }\n+\n+    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n+    /// If all elements in the set are less than `v` empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n+    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.lower_bound(&10).next(), None);\n+    /// ```\n+    #[inline]\n+    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.lower_bound(v)}\n+    }\n+\n+    /// Gets a lazy iterator pointing to the first value greater than `v`.\n+    /// If all elements in the set are less than or equal to `v` an\n+    /// empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&10).next(), None);\n+    /// ```\n+    #[inline]\n+    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.upper_bound(v)}\n+    }\n+\n+    /// Visits the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> SymDifferenceItems<'a, T> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> IntersectionItems<'a, T> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1i);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// v.insert(1i);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &T) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+        self.intersection(other).next().is_none()\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+        let mut a = x.next();\n+        let mut b = y.next();\n+        while a.is_some() {\n+            if b.is_none() {\n+                return false;\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            match b1.cmp(a1) {\n+                Less => (),\n+                Greater => return false,\n+                Equal => a = x.next(),\n+            }\n+\n+            b = y.next();\n+        }\n+        true\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2i), true);\n+    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(2i);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+/// A lazy forward iterator over a set.\n+pub struct SetItems<'a, T:'a> {\n+    iter: Entries<'a, T, ()>\n+}\n+\n+/// A lazy backward iterator over a set.\n+pub struct RevSetItems<'a, T:'a> {\n+    iter: RevEntries<'a, T, ()>\n+}\n+\n+/// A lazy forward iterator over a set that consumes the set while iterating.\n+pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+\n+/// A lazy iterator producing elements in the set difference (in-order).\n+pub struct DifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set symmetric difference (in-order).\n+pub struct SymDifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set intersection (in-order).\n+pub struct IntersectionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set union (in-order).\n+pub struct UnionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n+                        short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n+}\n+\n+\n+impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next().map(|(value, _)| value)\n+    }\n+}\n+\n+impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next().map(|(value, _)| value)\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Ord> FromIterator<T> for TreeSet<T> {\n+    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n+        let mut set = TreeSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T: Ord> Extendable<T> for TreeSet<T> {\n+    #[inline]\n+    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n+        for elem in iter {\n+            self.insert(elem);\n+        }\n+    }\n+}\n+\n+impl<S: Writer, T: Ord + Hash<S>> Hash<S> for TreeSet<T> {\n+    fn hash(&self, state: &mut S) {\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use std::hash;\n+\n+    use super::TreeSet;\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut s = TreeSet::new();\n+        s.clear();\n+        assert!(s.insert(5i));\n+        assert!(s.insert(12));\n+        assert!(s.insert(19));\n+        s.clear();\n+        assert!(!s.contains(&5));\n+        assert!(!s.contains(&12));\n+        assert!(!s.contains(&19));\n+        assert!(s.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = TreeSet::new();\n+        let mut ys = TreeSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5i));\n+        assert!(ys.insert(11i));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = TreeSet::new();\n+        assert!(a.insert(0i));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = TreeSet::new();\n+        assert!(b.insert(0i));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut m = TreeSet::new();\n+\n+        assert!(m.insert(3i));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n+\n+        let mut n = 0;\n+        for x in m.iter() {\n+            assert_eq!(*x, n);\n+            n += 1\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rev_iter() {\n+        let mut m = TreeSet::new();\n+\n+        assert!(m.insert(3i));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n+\n+        let mut n = 4;\n+        for x in m.rev_iter() {\n+            assert_eq!(*x, n);\n+            n -= 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let s: TreeSet<int> = range(0i, 5).collect();\n+\n+        let mut n = 0;\n+        for x in s.into_iter() {\n+            assert_eq!(x, n);\n+            n += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter_size_hint() {\n+        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n+\n+        let mut it = s.into_iter();\n+\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert!(it.next() != None);\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert!(it.next() != None);\n+\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_clone_eq() {\n+      let mut m = TreeSet::new();\n+\n+      m.insert(1i);\n+      m.insert(2);\n+\n+      assert!(m.clone() == m);\n+    }\n+\n+    #[test]\n+    fn test_hash() {\n+      let mut x = TreeSet::new();\n+      let mut y = TreeSet::new();\n+\n+      x.insert(1i);\n+      x.insert(2);\n+      x.insert(3);\n+\n+      y.insert(3i);\n+      y.insert(2);\n+      y.insert(1);\n+\n+      assert!(hash::hash(&x) == hash::hash(&y));\n+    }\n+\n+    fn check(a: &[int],\n+             b: &[int],\n+             expected: &[int],\n+             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n+        let mut set_a = TreeSet::new();\n+        let mut set_b = TreeSet::new();\n+\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n+\n+        let mut i = 0;\n+        f(&set_a, &set_b, |x| {\n+            assert_eq!(*x, expected[i]);\n+            i += 1;\n+            true\n+        });\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+        }\n+\n+        check_intersection([], [], []);\n+        check_intersection([1, 2, 3], [], []);\n+        check_intersection([], [1, 2, 3], []);\n+        check_intersection([2], [1, 2, 3], [2]);\n+        check_intersection([1, 2, 3], [2], [2]);\n+        check_intersection([11, 1, 3, 77, 103, 5, -5],\n+                           [2, 11, 77, -9, -42, 5, 3],\n+                           [3, 5, 11, 77]);\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+        }\n+\n+        check_difference([], [], []);\n+        check_difference([1, 12], [], [1, 12]);\n+        check_difference([], [1, 2, 3, 9], []);\n+        check_difference([1, 3, 5, 9, 11],\n+                         [3, 9],\n+                         [1, 5, 11]);\n+        check_difference([-5, 11, 22, 33, 40, 42],\n+                         [-12, -5, 14, 23, 34, 38, 39, 50],\n+                         [11, 22, 33, 40, 42]);\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        fn check_symmetric_difference(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+        }\n+\n+        check_symmetric_difference([], [], []);\n+        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n+        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n+        check_symmetric_difference([1, 3, 5, 9, 11],\n+                                   [-2, 3, 9, 14, 22],\n+                                   [-2, 1, 5, 11, 14, 22]);\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        fn check_union(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.union(y).all(f))\n+        }\n+\n+        check_union([], [], []);\n+        check_union([1, 2, 3], [2], [1, 2, 3]);\n+        check_union([2], [1, 2, 3], [1, 2, 3]);\n+        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n+                    [-2, 1, 5, 9, 13, 19],\n+                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    }\n+\n+    #[test]\n+    fn test_zip() {\n+        let mut x = TreeSet::new();\n+        x.insert(5u);\n+        x.insert(12u);\n+        x.insert(11u);\n+\n+        let mut y = TreeSet::new();\n+        y.insert(\"foo\");\n+        y.insert(\"bar\");\n+\n+        let x = x;\n+        let y = y;\n+        let mut z = x.iter().zip(y.iter());\n+\n+        // FIXME: #5801: this needs a type hint to compile...\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.is_none());\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set: TreeSet<int> = TreeSet::new();\n+        let empty: TreeSet<int> = TreeSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+}"}, {"sha": "27486de6f1993e0e771329c71edb19ad93e5fe48", "filename": "src/libcollections/trie/map.rs", "status": "renamed", "additions": 2, "deletions": 441, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -654,335 +654,6 @@ impl<T> IndexMut<uint, T> for TrieMap<T> {\n     }\n }\n \n-/// A set implemented as a radix trie.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::TrieSet;\n-///\n-/// let mut set = TrieSet::new();\n-/// set.insert(6);\n-/// set.insert(28);\n-/// set.insert(6);\n-///\n-/// assert_eq!(set.len(), 2);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"3 is not in the set\");\n-/// }\n-///\n-/// // Print contents in order\n-/// for x in set.iter() {\n-///     println!(\"{}\", x);\n-/// }\n-///\n-/// set.remove(&6);\n-/// assert_eq!(set.len(), 1);\n-///\n-/// set.clear();\n-/// assert!(set.is_empty());\n-/// ```\n-#[deriving(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct TrieSet {\n-    map: TrieMap<()>\n-}\n-\n-impl Show for TrieSet {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-impl Default for TrieSet {\n-    #[inline]\n-    fn default() -> TrieSet { TrieSet::new() }\n-}\n-\n-impl TrieSet {\n-    /// Creates an empty TrieSet.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    /// let mut set = TrieSet::new();\n-    /// ```\n-    #[inline]\n-    pub fn new() -> TrieSet {\n-        TrieSet{map: TrieMap::new()}\n-    }\n-\n-    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n-    /// Returns `true` if `f` returns `true` for all elements.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n-    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n-    ///\n-    /// // Stop when we reach 3\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n-    /// assert_eq!(vec, vec![5, 4, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n-        self.map.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Gets an iterator over the values in the set, in sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    /// set.insert(3);\n-    /// set.insert(2);\n-    /// set.insert(1);\n-    /// set.insert(2);\n-    ///\n-    /// // Print 1, 2, 3\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that is not less than `val`.\n-    /// If all values in the set are less than `val` an empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n-    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n-    /// assert_eq!(set.lower_bound(10).next(), None);\n-    /// ```\n-    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.lower_bound(val)}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that key is greater than `val`.\n-    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(10).next(), None);\n-    /// ```\n-    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.upper_bound(val)}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, value: &uint) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[inline]\n-    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| !other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[inline]\n-    pub fn is_subset(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[inline]\n-    pub fn is_superset(&self, other: &TrieSet) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2), true);\n-    /// assert_eq!(set.insert(2), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ())\n-    }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value)\n-    }\n-}\n-\n-impl FromIterator<uint> for TrieSet {\n-    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet {\n-        let mut set = TrieSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl Extendable<uint> for TrieSet {\n-    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n struct TrieNode<T> {\n     count: uint,\n     children: [Child<T>, ..SIZE]\n@@ -1255,23 +926,8 @@ macro_rules! iterator_impl {\n iterator_impl! { Entries, iter = iter, mutability = }\n iterator_impl! { MutEntries, iter = iter_mut, mutability = mut }\n \n-/// A forward iterator over a set.\n-pub struct SetItems<'a> {\n-    iter: Entries<'a, ()>\n-}\n-\n-impl<'a> Iterator<uint> for SetItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        self.iter.next().map(|(key, _)| key)\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n #[cfg(test)]\n-mod test_map {\n+mod test {\n     use std::prelude::*;\n     use std::iter::range_step;\n     use std::uint;\n@@ -1687,7 +1343,7 @@ mod test_map {\n }\n \n #[cfg(test)]\n-mod bench_map {\n+mod bench {\n     use std::prelude::*;\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n@@ -1802,98 +1458,3 @@ mod bench_map {\n             })\n     }\n }\n-\n-#[cfg(test)]\n-mod test_set {\n-    use std::prelude::*;\n-    use std::uint;\n-\n-    use super::TrieSet;\n-\n-    #[test]\n-    fn test_sane_chunk() {\n-        let x = 1;\n-        let y = 1 << (uint::BITS - 1);\n-\n-        let mut trie = TrieSet::new();\n-\n-        assert!(trie.insert(x));\n-        assert!(trie.insert(y));\n-\n-        assert_eq!(trie.len(), 2);\n-\n-        let expected = [x, y];\n-\n-        for (i, x) in trie.iter().enumerate() {\n-            assert_eq!(expected[i], x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n-\n-        let set: TrieSet = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = TrieSet::new();\n-        let empty = TrieSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut a = TrieSet::new();\n-\n-        a.insert(1);\n-        a.insert(2);\n-        a.insert(3);\n-\n-        assert!(a.clone() == a);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u));\n-        assert!(a < b);\n-        assert!(a.insert(3u));\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(1));\n-        assert!(b < a);\n-        assert!(a.insert(0));\n-        assert!(a < b);\n-        assert!(a.insert(6));\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1u));\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2u));\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-}", "previous_filename": "src/libcollections/trie.rs"}, {"sha": "f0f8f00a6a0db8608717287a7a1e8b6031ffd402", "filename": "src/libcollections/trie/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines `TrieMap` and `TrieSet`, which require `uint` keys.\n+//!\n+//! `TrieMap` is ordered.\n+\n+pub mod map;\n+pub mod set;\n\\ No newline at end of file"}, {"sha": "ddddd279b0467b157fc159acacbbe5344cd40ba0", "filename": "src/libcollections/trie/set.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -0,0 +1,457 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::default::Default;\n+use core::fmt;\n+use core::fmt::Show;\n+use std::hash::Hash;\n+\n+use trie_map::{TrieMap, Entries};\n+\n+/// A set implemented as a radix trie.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TrieSet;\n+///\n+/// let mut set = TrieSet::new();\n+/// set.insert(6);\n+/// set.insert(28);\n+/// set.insert(6);\n+///\n+/// assert_eq!(set.len(), 2);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"3 is not in the set\");\n+/// }\n+///\n+/// // Print contents in order\n+/// for x in set.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// set.remove(&6);\n+/// assert_eq!(set.len(), 1);\n+///\n+/// set.clear();\n+/// assert!(set.is_empty());\n+/// ```\n+#[deriving(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct TrieSet {\n+    map: TrieMap<()>\n+}\n+\n+impl Show for TrieSet {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl Default for TrieSet {\n+    #[inline]\n+    fn default() -> TrieSet { TrieSet::new() }\n+}\n+\n+impl TrieSet {\n+    /// Creates an empty TrieSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    /// let mut set = TrieSet::new();\n+    /// ```\n+    #[inline]\n+    pub fn new() -> TrieSet {\n+        TrieSet{map: TrieMap::new()}\n+    }\n+\n+    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n+    /// Returns `true` if `f` returns `true` for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n+    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n+    ///\n+    /// // Stop when we reach 3\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n+    /// assert_eq!(vec, vec![5, 4, 3]);\n+    /// ```\n+    #[inline]\n+    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n+        self.map.each_reverse(|k, _| f(k))\n+    }\n+\n+    /// Gets an iterator over the values in the set, in sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    /// set.insert(3);\n+    /// set.insert(2);\n+    /// set.insert(1);\n+    /// set.insert(2);\n+    ///\n+    /// // Print 1, 2, 3\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n+        SetItems{iter: self.map.iter()}\n+    }\n+\n+    /// Gets an iterator pointing to the first value that is not less than `val`.\n+    /// If all values in the set are less than `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n+    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n+    /// assert_eq!(set.lower_bound(10).next(), None);\n+    /// ```\n+    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.lower_bound(val)}\n+    }\n+\n+    /// Gets an iterator pointing to the first value that key is greater than `val`.\n+    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(10).next(), None);\n+    /// ```\n+    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.upper_bound(val)}\n+    }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &uint) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| !other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_subset(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    #[inline]\n+    pub fn is_superset(&self, other: &TrieSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: uint) -> bool {\n+        self.map.insert(value, ())\n+    }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &uint) -> bool {\n+        self.map.remove(value)\n+    }\n+}\n+\n+impl FromIterator<uint> for TrieSet {\n+    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet {\n+        let mut set = TrieSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl Extendable<uint> for TrieSet {\n+    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) {\n+        for elem in iter {\n+            self.insert(elem);\n+        }\n+    }\n+}\n+\n+/// A forward iterator over a set.\n+pub struct SetItems<'a> {\n+    iter: Entries<'a, ()>\n+}\n+\n+impl<'a> Iterator<uint> for SetItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        self.iter.next().map(|(key, _)| key)\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use std::uint;\n+\n+    use super::TrieSet;\n+\n+    #[test]\n+    fn test_sane_chunk() {\n+        let x = 1;\n+        let y = 1 << (uint::BITS - 1);\n+\n+        let mut trie = TrieSet::new();\n+\n+        assert!(trie.insert(x));\n+        assert!(trie.insert(y));\n+\n+        assert_eq!(trie.len(), 2);\n+\n+        let expected = [x, y];\n+\n+        for (i, x) in trie.iter().enumerate() {\n+            assert_eq!(expected[i], x);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n+\n+        let set: TrieSet = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set = TrieSet::new();\n+        let empty = TrieSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+\n+    #[test]\n+    fn test_clone() {\n+        let mut a = TrieSet::new();\n+\n+        a.insert(1);\n+        a.insert(2);\n+        a.insert(3);\n+\n+        assert!(a.clone() == a);\n+    }\n+\n+    #[test]\n+    fn test_lt() {\n+        let mut a = TrieSet::new();\n+        let mut b = TrieSet::new();\n+\n+        assert!(!(a < b) && !(b < a));\n+        assert!(b.insert(2u));\n+        assert!(a < b);\n+        assert!(a.insert(3u));\n+        assert!(!(a < b) && b < a);\n+        assert!(b.insert(1));\n+        assert!(b < a);\n+        assert!(a.insert(0));\n+        assert!(a < b);\n+        assert!(a.insert(6));\n+        assert!(a < b && !(b < a));\n+    }\n+\n+    #[test]\n+    fn test_ord() {\n+        let mut a = TrieSet::new();\n+        let mut b = TrieSet::new();\n+\n+        assert!(a <= b && a >= b);\n+        assert!(a.insert(1u));\n+        assert!(a > b && a >= b);\n+        assert!(b < a && b <= a);\n+        assert!(b.insert(2u));\n+        assert!(b > a && b >= a);\n+        assert!(a < b && a <= b);\n+    }\n+}"}, {"sha": "c0bc785126c70aaa788802001cf14e3bb56b7b9b", "filename": "src/libcollections/vec_map.rs", "status": "renamed", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -31,9 +31,9 @@ use hash::Hash;\n /// # Example\n ///\n /// ```\n-/// use std::collections::SmallIntMap;\n+/// use std::collections::VecMap;\n ///\n-/// let mut months = SmallIntMap::new();\n+/// let mut months = VecMap::new();\n /// months.insert(1, \"Jan\");\n /// months.insert(2, \"Feb\");\n /// months.insert(3, \"Mar\");\n@@ -60,58 +60,58 @@ use hash::Hash;\n /// assert!(months.is_empty());\n /// ```\n #[deriving(PartialEq, Eq)]\n-pub struct SmallIntMap<T> {\n+pub struct VecMap<T> {\n     v: Vec<Option<T>>,\n }\n \n-impl<V> Default for SmallIntMap<V> {\n+impl<V> Default for VecMap<V> {\n     #[inline]\n-    fn default() -> SmallIntMap<V> { SmallIntMap::new() }\n+    fn default() -> VecMap<V> { VecMap::new() }\n }\n \n-impl<V:Clone> Clone for SmallIntMap<V> {\n+impl<V:Clone> Clone for VecMap<V> {\n     #[inline]\n-    fn clone(&self) -> SmallIntMap<V> {\n-        SmallIntMap { v: self.v.clone() }\n+    fn clone(&self) -> VecMap<V> {\n+        VecMap { v: self.v.clone() }\n     }\n \n     #[inline]\n-    fn clone_from(&mut self, source: &SmallIntMap<V>) {\n+    fn clone_from(&mut self, source: &VecMap<V>) {\n         self.v.reserve(source.v.len());\n         for (i, w) in self.v.iter_mut().enumerate() {\n             *w = source.v[i].clone();\n         }\n     }\n }\n \n-impl <S: hash::Writer, T: Hash<S>> Hash<S> for SmallIntMap<T> {\n+impl <S: hash::Writer, T: Hash<S>> Hash<S> for VecMap<T> {\n     fn hash(&self, state: &mut S) {\n         self.v.hash(state)\n     }\n }\n \n-impl<V> SmallIntMap<V> {\n-    /// Creates an empty `SmallIntMap`.\n+impl<V> VecMap<V> {\n+    /// Creates an empty `VecMap`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n-    /// let mut map: SmallIntMap<&str> = SmallIntMap::new();\n+    /// use std::collections::VecMap;\n+    /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n+    pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n \n-    /// Creates an empty `SmallIntMap` with space for at least `capacity`\n+    /// Creates an empty `VecMap` with space for at least `capacity`\n     /// elements before resizing.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n-    /// let mut map: SmallIntMap<&str> = SmallIntMap::with_capacity(10);\n+    /// use std::collections::VecMap;\n+    /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    pub fn with_capacity(capacity: uint) -> SmallIntMap<V> {\n-        SmallIntMap { v: Vec::with_capacity(capacity) }\n+    pub fn with_capacity(capacity: uint) -> VecMap<V> {\n+        VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order by the keys.\n@@ -132,9 +132,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n@@ -159,9 +159,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n     /// map.insert(3, \"c\");\n@@ -183,15 +183,15 @@ impl<V> SmallIntMap<V> {\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order by\n-    /// the keys, emptying (but not consuming) the original `SmallIntMap`.\n+    /// the keys, emptying (but not consuming) the original `VecMap`.\n     /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n@@ -216,9 +216,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// assert_eq!(a.len(), 0);\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n@@ -232,9 +232,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// assert!(a.is_empty());\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n@@ -248,9 +248,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n@@ -262,9 +262,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.find(&1), Some(&\"a\"));\n     /// assert_eq!(map.find(&2), None);\n@@ -285,9 +285,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n@@ -302,9 +302,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// match map.find_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n@@ -330,9 +330,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.insert(2, \"value\"), true);\n     /// assert_eq!(map.insert(2, \"value2\"), false);\n     /// assert_eq!(map[2], \"value2\");\n@@ -353,9 +353,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.remove(&1), false);\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), true);\n@@ -370,9 +370,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.swap(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n@@ -395,9 +395,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.pop(&1), Some(\"a\"));\n     /// assert_eq!(map.pop(&1), None);\n@@ -410,7 +410,7 @@ impl<V> SmallIntMap<V> {\n     }\n }\n \n-impl<V:Clone> SmallIntMap<V> {\n+impl<V:Clone> VecMap<V> {\n     /// Updates a value in the map. If the key already exists in the map,\n     /// modifies the value with `ff` taking `oldval, newval`.\n     /// Otherwise, sets the value to `newval`.\n@@ -419,9 +419,9 @@ impl<V:Clone> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update(1, vec![1i, 2], |mut old, new| { old.extend(new.into_iter()); old }));\n@@ -443,9 +443,9 @@ impl<V:Clone> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update_with_key(7, 10, |key, old, new| (old + new) % key));\n@@ -468,21 +468,21 @@ impl<V:Clone> SmallIntMap<V> {\n     }\n }\n \n-impl<V: PartialOrd> PartialOrd for SmallIntMap<V> {\n+impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n-    fn partial_cmp(&self, other: &SmallIntMap<V>) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-impl<V: Ord> Ord for SmallIntMap<V> {\n+impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n-    fn cmp(&self, other: &SmallIntMap<V>) -> Ordering {\n+    fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n+impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n \n@@ -495,30 +495,30 @@ impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n     }\n }\n \n-impl<V> FromIterator<(uint, V)> for SmallIntMap<V> {\n-    fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> SmallIntMap<V> {\n-        let mut map = SmallIntMap::new();\n+impl<V> FromIterator<(uint, V)> for VecMap<V> {\n+    fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> VecMap<V> {\n+        let mut map = VecMap::new();\n         map.extend(iter);\n         map\n     }\n }\n \n-impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n+impl<V> Extendable<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<V> Index<uint, V> for SmallIntMap<V> {\n+impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n         self.find(i).expect(\"key not present\")\n     }\n }\n \n-impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n+impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n         self.find_mut(i).expect(\"key not present\")\n@@ -612,11 +612,11 @@ mod test_map {\n     use vec::Vec;\n     use hash;\n \n-    use super::SmallIntMap;\n+    use super::VecMap;\n \n     #[test]\n     fn test_find_mut() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         assert!(m.insert(1, 12i));\n         assert!(m.insert(2, 8));\n         assert!(m.insert(5, 14));\n@@ -629,7 +629,7 @@ mod test_map {\n \n     #[test]\n     fn test_len() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n         assert!(map.insert(5, 20i));\n@@ -645,7 +645,7 @@ mod test_map {\n \n     #[test]\n     fn test_clear() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         assert!(map.insert(5, 20i));\n         assert!(map.insert(11, 12));\n         assert!(map.insert(14, 22));\n@@ -658,7 +658,7 @@ mod test_map {\n \n     #[test]\n     fn test_insert_with_key() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n \n         // given a new key, initialize it with this new count,\n         // given an existing key, add more to its count\n@@ -688,23 +688,23 @@ mod test_map {\n \n     #[test]\n     fn test_swap() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         assert_eq!(m.swap(1, 2i), None);\n         assert_eq!(m.swap(1, 3i), Some(2));\n         assert_eq!(m.swap(1, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         m.insert(1, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n \n     #[test]\n     fn test_keys() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n@@ -717,7 +717,7 @@ mod test_map {\n \n     #[test]\n     fn test_values() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n@@ -730,7 +730,7 @@ mod test_map {\n \n     #[test]\n     fn test_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -755,7 +755,7 @@ mod test_map {\n \n     #[test]\n     fn test_iterator_size_hints() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -771,7 +771,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -794,7 +794,7 @@ mod test_map {\n \n     #[test]\n     fn test_rev_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -813,7 +813,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_rev_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -836,7 +836,7 @@ mod test_map {\n \n     #[test]\n     fn test_move_iter() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         m.insert(1, box 2i);\n         let mut called = false;\n         for (k, v) in m.into_iter() {\n@@ -851,8 +851,8 @@ mod test_map {\n \n     #[test]\n     fn test_show() {\n-        let mut map = SmallIntMap::new();\n-        let empty = SmallIntMap::<int>::new();\n+        let mut map = VecMap::new();\n+        let empty = VecMap::<int>::new();\n \n         map.insert(1, 2i);\n         map.insert(3, 4i);\n@@ -865,7 +865,7 @@ mod test_map {\n \n     #[test]\n     fn test_clone() {\n-        let mut a = SmallIntMap::new();\n+        let mut a = VecMap::new();\n \n         a.insert(1, 'x');\n         a.insert(4, 'y');\n@@ -876,8 +876,8 @@ mod test_map {\n \n     #[test]\n     fn test_eq() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(a == b);\n         assert!(a.insert(0, 5i));\n@@ -894,8 +894,8 @@ mod test_map {\n \n     #[test]\n     fn test_lt() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n         assert!(b.insert(2u, 5i));\n@@ -912,8 +912,8 @@ mod test_map {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n         assert!(a.insert(1u, 1i));\n@@ -926,8 +926,8 @@ mod test_map {\n \n     #[test]\n     fn test_hash() {\n-        let mut x = SmallIntMap::new();\n-        let mut y = SmallIntMap::new();\n+        let mut x = VecMap::new();\n+        let mut y = VecMap::new();\n \n         assert!(hash::hash(&x) == hash::hash(&y));\n         x.insert(1, 'a');\n@@ -945,7 +945,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs: Vec<(uint, char)> = vec![(1u, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n \n-        let map: SmallIntMap<char> = xs.iter().map(|&x| x).collect();\n+        let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n@@ -954,7 +954,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+        let mut map: VecMap<int> = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -966,7 +966,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+        let mut map: VecMap<int> = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -980,20 +980,20 @@ mod test_map {\n mod bench {\n     extern crate test;\n     use self::test::Bencher;\n-    use super::SmallIntMap;\n+    use super::VecMap;\n     use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1002,15 +1002,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1019,15 +1019,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.find(&i); });\n@@ -1036,15 +1036,15 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.find(&i); });", "previous_filename": "src/libcollections/smallintmap.rs"}, {"sha": "10c40a32da666f922702039a600ced41e7d5526c", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -32,7 +32,7 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};"}, {"sha": "e52e1396b238fa1cc6521a9bb544ef011b38484e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -37,7 +37,7 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::slice;\n use std::{int, i8, i16, i32, i64, uint, u8, u16, u32, u64, f32, f64};\n use syntax::abi;"}, {"sha": "541d6a67b4e4bfd077aba096c4f9949aab966cdd", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -24,7 +24,7 @@ use plugin::load::PluginMetadata;\n \n use std::rc::Rc;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;"}, {"sha": "ff78491c2ad9dd4951a684c8c53293b23f726cd7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n use syntax::diagnostic::expect;\n use syntax::parse::token;\n \n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n \n pub struct MethodInfo {\n     pub name: ast::Name,"}, {"sha": "20171ecfd99f73686cb628ee038b51a22ec59755", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -34,7 +34,7 @@ use std::hash::Hash;\n use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n use std::io;\n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use std::u64;\n use rbml::reader;"}, {"sha": "7b67def405176df5a4725af7cc64e31b9b4ba2d7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -237,7 +237,7 @@ use std::slice;\n use std::string;\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use flate;\n use time;\n "}, {"sha": "ce91bd1b1538889e7eefc883689136816f5a60a6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -28,7 +28,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n-use std::collections::hashmap::Vacant;\n+use std::collections::hash_map::Vacant;\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "a2bea790c9f46ac796ad6a960b763f174c961d11", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -58,7 +58,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::cell::{Cell, RefCell};\n use std::mem::replace;\n use std::rc::{Rc, Weak};"}, {"sha": "eb58c99e559253ef14e4681fe81ec282652ca75e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -29,7 +29,7 @@ use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;"}, {"sha": "4c088e42243e190d18067c6dfab0e7b3860984f0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -43,7 +43,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use arena::TypedArena;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};"}, {"sha": "a686a5e72a0a7cafcbca071db595c5ba8ebc091c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -19,7 +19,7 @@ use middle::typeck::require_same_types;\n \n use std::cmp;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::{Span, Spanned};"}, {"sha": "c280474a076a0b28614a3a562aa87c96a2145cce", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -118,7 +118,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::abi;"}, {"sha": "acc3cf0307b9655fcc1baf0e4b810299b46459b9", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -142,7 +142,7 @@ use syntax::visit::Visitor;\n \n use std::cell::{RefCell};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Vacant, Occupied};\n+use std::collections::hash_map::{Vacant, Occupied};\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS"}, {"sha": "91e9c18853c804b0f44288721bcaf9103c2cc323", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -18,7 +18,7 @@ use middle::ty_fold::{TypeFolder, TypeFoldable};\n use syntax::ast;\n \n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types."}, {"sha": "6e5e8d72839eb0959aeef3a75ccc445279bd25e8", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -44,23 +44,23 @@ use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n-use std::collections::hashmap;\n+use std::collections::hash_map;\n \n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     skolemization_count: uint,\n-    skolemization_map: hashmap::HashMap<ty::InferTy, ty::t>,\n+    skolemization_map: hash_map::HashMap<ty::InferTy, ty::t>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n         TypeSkolemizer {\n             infcx: infcx,\n             skolemization_count: 0,\n-            skolemization_map: hashmap::HashMap::new(),\n+            skolemization_map: hash_map::HashMap::new(),\n         }\n     }\n \n@@ -76,8 +76,8 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n         }\n \n         match self.skolemization_map.entry(key) {\n-            hashmap::Occupied(entry) => *entry.get(),\n-            hashmap::Vacant(entry) => {\n+            hash_map::Occupied(entry) => *entry.get(),\n+            hash_map::Vacant(entry) => {\n                 let index = self.skolemization_count;\n                 self.skolemization_count += 1;\n                 let t = ty::mk_infer(self.infcx.tcx, skolemizer(index));"}, {"sha": "9af2b22adea455c1392769e395a9db701e347c88", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -34,7 +34,7 @@\n //! both occur before the crate is rendered.\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::fmt;\n use std::io::fs::PathExtensions;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};"}, {"sha": "bd3c618a5ed46149b2075c7ed319ddc38a24b3b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -31,7 +31,7 @@ extern crate time;\n use std::io;\n use std::io::{File, MemWriter};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n "}, {"sha": "7129f14720911f8cbaa2b0f588b305349558fa23", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -41,7 +41,7 @@ assert_eq!(*key_vector.get().unwrap(), vec![4]);\n use core::prelude::*;\n \n use alloc::heap;\n-use collections::treemap::TreeMap;\n+use collections::TreeMap;\n use core::cmp;\n use core::kinds::marker;\n use core::mem;"}, {"sha": "62b93336a34bdce65776167fba79510a3b17f806", "filename": "src/libstd/collections/hash/bench.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -18,7 +18,7 @@ use iter::{range_inclusive};\n \n #[bench]\n fn new_drop(b : &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     b.iter(|| {\n         let m : HashMap<int, int> = HashMap::new();\n@@ -28,7 +28,7 @@ fn new_drop(b : &mut Bencher) {\n \n #[bench]\n fn new_insert_drop(b : &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     b.iter(|| {\n         let mut m = HashMap::new();\n@@ -39,7 +39,7 @@ fn new_insert_drop(b : &mut Bencher) {\n \n #[bench]\n fn grow_by_insertion(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -57,7 +57,7 @@ fn grow_by_insertion(b: &mut Bencher) {\n \n #[bench]\n fn find_existing(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -74,7 +74,7 @@ fn find_existing(b: &mut Bencher) {\n \n #[bench]\n fn find_nonexisting(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -91,7 +91,7 @@ fn find_nonexisting(b: &mut Bencher) {\n \n #[bench]\n fn hashmap_as_queue(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -110,7 +110,7 @@ fn hashmap_as_queue(b: &mut Bencher) {\n \n #[bench]\n fn find_pop_insert(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n ", "previous_filename": "src/libstd/collections/hashmap/bench.rs"}, {"sha": "596e483c2f6d3b2555404ab686a9f965c98beea6", "filename": "src/libstd/collections/hash/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "previous_filename": "src/libstd/collections/hashmap/map.rs"}, {"sha": "ee3fc1e6ac3621b5bb7499e66ec8019a72007fef", "filename": "src/libstd/collections/hash/mod.rs", "status": "renamed", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -10,24 +10,7 @@\n \n //! Unordered containers, implemented as hash-tables\n \n-pub use self::map::HashMap;\n-pub use self::map::Entries;\n-pub use self::map::MutEntries;\n-pub use self::map::MoveEntries;\n-pub use self::map::Entry;\n-pub use self::map::Occupied;\n-pub use self::map::Vacant;\n-pub use self::map::OccupiedEntry;\n-pub use self::map::VacantEntry;\n-pub use self::map::Keys;\n-pub use self::map::Values;\n-pub use self::map::INITIAL_CAPACITY;\n-pub use self::set::HashSet;\n-pub use self::set::SetItems;\n-pub use self::set::SetMoveItems;\n-pub use self::set::SetAlgebraItems;\n-\n mod bench;\n-mod map;\n-mod set;\n+pub mod map;\n+pub mod set;\n mod table;", "previous_filename": "src/libstd/collections/hashmap/mod.rs"}, {"sha": "823bd49d7a6632488e8c285c2d6284248c8a4eb6", "filename": "src/libstd/collections/hash/set.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -22,7 +22,7 @@ use iter;\n use option::{Some, None};\n use result::{Ok, Err};\n \n-use super::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n+use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n \n \n // Future Optimization (FIXME!)", "previous_filename": "src/libstd/collections/hashmap/set.rs"}, {"sha": "4d73029b7b06b50e3101c238d521d35c81bb0e27", "filename": "src/libstd/collections/hash/table.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "previous_filename": "src/libstd/collections/hashmap/table.rs"}, {"sha": "13486d4b8f84d55d5e8299e341cb40174e6777df", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -24,9 +24,9 @@\n //! Rust's collections can be grouped into four major categories:\n //!\n //! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n-//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `SmallIntMap`, `LruCache`\n+//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `VecMap`, `LruCache`\n //! * Sets: `HashSet`, `BTreeSet`, `TreeSet`, `TrieSet`, `BitVSet`, `EnumSet`\n-//! * Misc: `PriorityQueue`\n+//! * Misc: `BinaryHeap`\n //!\n //! # When Should You Use Which Collection?\n //!\n@@ -74,7 +74,7 @@\n //! * You want a `HashMap`, but with many potentially large `uint` keys.\n //! * You want a `BTreeMap`, but with potentially large `uint` keys.\n //!\n-//! ### Use a `SmallIntMap` when:\n+//! ### Use a `VecMap` when:\n //! * You want a `HashMap` but with known to be small `uint` keys.\n //! * You want a `BTreeMap`, but with known to be small `uint` keys.\n //!\n@@ -88,12 +88,12 @@\n //! * You want a bitvector.\n //!\n //! ### Use a `BitVSet` when:\n-//! * You want a `SmallIntSet`.\n+//! * You want a `VecSet`.\n //!\n //! ### Use an `EnumSet` when:\n //! * You want a C-like enum, stored in a single `uint`.\n //!\n-//! ### Use a `PriorityQueue` when:\n+//! ### Use a `BinaryHeap` when:\n //! * You want to store a bunch of elements, but only ever want to process the \"biggest\"\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n@@ -266,7 +266,7 @@\n //! #### Counting the number of times each character in a string occurs\n //!\n //! ```\n-//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n //!\n //! let mut count = BTreeMap::new();\n //! let message = \"she sells sea shells by the sea shore\";\n@@ -293,7 +293,7 @@\n //! #### Tracking the inebriation of customers at a bar\n //!\n //! ```\n-//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n //!\n //! // A client of the bar. They have an id and a blood alcohol level.\n //! struct Person { id: u32, blood_alcohol: f32 };\n@@ -328,14 +328,27 @@\n \n #![experimental]\n \n-pub use core_collections::{Bitv, BitvSet, BTreeMap, BTreeSet, DList, EnumSet};\n-pub use core_collections::{PriorityQueue, RingBuf, SmallIntMap};\n-pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet};\n-pub use core_collections::{bitv, btree, dlist, enum_set};\n-pub use core_collections::{priority_queue, ringbuf, smallintmap, treemap, trie};\n+pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n+pub use core_collections::{DList, EnumSet, RingBuf};\n+pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet, VecMap};\n \n-pub use self::hashmap::{HashMap, HashSet};\n+pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set, dlist, enum_set};\n+pub use core_collections::{ring_buf, tree_map, tree_set, trie_map, trie_set, vec_map};\n+\n+pub use self::hash_map::HashMap;\n+pub use self::hash_set::HashSet;\n pub use self::lru_cache::LruCache;\n \n-pub mod hashmap;\n+mod hash;\n+\n+pub mod hash_map {\n+    //! A hashmap\n+    pub use super::hash::map::*;\n+}\n+\n+pub mod hash_set {\n+    //! A hashset\n+    pub use super::hash::set::*;\n+}\n+\n pub mod lru_cache;"}, {"sha": "bebe16286c97acdc89e8cf18ad879af8bd2d958d", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -20,7 +20,7 @@ use ast::{Ident, Mrk, Name, SyntaxContext};\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having"}, {"sha": "8c184ccbe43a89a09ccfb1a28bd91336f45e7cd9", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(missing_docs)]\n \n-use std::collections::hashmap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map;\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n@@ -440,8 +440,8 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n-    let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n+pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hash_map::HashMap<U, uint> {\n+    let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n         match map.entry(elem) {\n             Occupied(mut entry) => { *entry.get_mut() += 1; },"}, {"sha": "8151f2718e35cc1d84cad91b178a90d395d9435a", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -14,7 +14,7 @@ extern crate collections;\n extern crate rand;\n extern crate time;\n \n-use std::collections::bitv::BitvSet;\n+use std::collections::BitvSet;\n use std::collections::TreeSet;\n use std::hash::Hash;\n use std::collections::HashSet;"}, {"sha": "cdcb88d87c6446918c520ce50acf646c4f659804", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -13,17 +13,17 @@\n extern crate collections;\n extern crate time;\n \n-use std::collections::SmallIntMap;\n+use std::collections::VecMap;\n use std::os;\n use std::uint;\n \n-fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n+fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n     for i in range(min, max) {\n         map.insert(i, i + 22u);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n+fn check_sequential(min: uint, max: uint, map: &VecMap<uint>) {\n     for i in range(min, max) {\n         assert_eq!(map[i], i + 22u);\n     }\n@@ -45,7 +45,7 @@ fn main() {\n     let mut appendf = 0.0;\n \n     for _ in range(0u, rep) {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         let start = time::precise_time_s();\n         append_sequential(0u, max, &mut map);\n         let mid = time::precise_time_s();"}, {"sha": "c86f8a38f63c409f32eeb4885a17da54050f398e", "filename": "src/test/run-fail/hashmap-capacity-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:capacity overflow\n \n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::uint;\n use std::mem::size_of;\n "}, {"sha": "44006a0039abd31df57562d47f9e9e283f849a38", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -17,7 +17,7 @@ extern crate time;\n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n-use std::hashmap::{HashMap, HashSet};\n+use std::collections::{HashMap, HashSet};\n \n use rbml::reader as EBReader;\n use rbml::writer as EBWriter;"}, {"sha": "449b3099dfa4dd2e2973e25ee63062845e406218", "filename": "src/test/run-pass/while-let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a8840033b44a5ce32562d6c12386c4ee7f4ec0/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=e5a8840033b44a5ce32562d6c12386c4ee7f4ec0", "patch": "@@ -10,10 +10,10 @@\n \n #![feature(while_let)]\n \n-use std::collections::PriorityQueue;\n+use std::collections::BinaryHeap;\n \n-fn make_pq() -> PriorityQueue<int> {\n-    PriorityQueue::from_vec(vec![1i,2,3])\n+fn make_pq() -> BinaryHeap<int> {\n+    BinaryHeap::from_vec(vec![1i,2,3])\n }\n \n pub fn main() {"}]}