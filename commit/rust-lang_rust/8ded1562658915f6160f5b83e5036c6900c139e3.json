{"sha": "8ded1562658915f6160f5b83e5036c6900c139e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZWQxNTYyNjU4OTE1ZjYxNjBmNWI4M2U1MDM2YzY5MDBjMTM5ZTM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-01T05:11:38Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-01T05:11:38Z"}, "message": "Add examples + documentation for std::path", "tree": {"sha": "8e5c2b9d7e36fb525851901296d0855e67641e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e5c2b9d7e36fb525851901296d0855e67641e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ded1562658915f6160f5b83e5036c6900c139e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ded1562658915f6160f5b83e5036c6900c139e3", "html_url": "https://github.com/rust-lang/rust/commit/8ded1562658915f6160f5b83e5036c6900c139e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ded1562658915f6160f5b83e5036c6900c139e3/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d754722a04b99fdcae0fd97fa2a4395521145ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d754722a04b99fdcae0fd97fa2a4395521145ef2", "html_url": "https://github.com/rust-lang/rust/commit/d754722a04b99fdcae0fd97fa2a4395521145ef2"}], "stats": {"total": 213, "additions": 213, "deletions": 0}, "files": [{"sha": "df0b3842b7a349ccedac1cf265bf53dea571b2b0", "filename": "src/libstd/path.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/8ded1562658915f6160f5b83e5036c6900c139e3/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ded1562658915f6160f5b83e5036c6900c139e3/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8ded1562658915f6160f5b83e5036c6900c139e3", "patch": "@@ -344,6 +344,15 @@ impl<'a> Prefix<'a> {\n \n /// Determine whether the character is one of the permitted path\n /// separators for the current platform.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path;\n+///\n+/// assert!(path::is_separator('/'));\n+/// assert!(!path::is_separator('\u2764'));\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn is_separator(c: char) -> bool {\n     use ascii::*;\n@@ -540,6 +549,18 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n ///\n /// See the module documentation for an in-depth explanation of components and\n /// their role in the API.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+///\n+/// for component in path.components() {\n+///     println!(\"{:?}\", component);\n+/// }\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -610,6 +631,16 @@ impl<'a> Components<'a> {\n     }\n \n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo/bar.txt\");\n+    ///\n+    /// println!(\"{:?}\", path.components().as_path());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n@@ -1207,12 +1238,28 @@ impl Path {\n     /// Directly wrap a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// Path::new(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n         unsafe { mem::transmute(s.as_ref()) }\n     }\n \n     /// Yield the underlying `OsStr` slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let os_str = Path::new(\"foo.txt\").as_os_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &OsStr {\n         &self.inner\n@@ -1221,6 +1268,14 @@ impl Path {\n     /// Yield a `&str` slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n@@ -1229,12 +1284,28 @@ impl Path {\n     /// Convert a `Path` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_string_lossy();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n \n     /// Convert a `Path` to an owned `PathBuf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_path_buf();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n         PathBuf::from(self.inner.to_os_string())\n@@ -1248,13 +1319,29 @@ impl Path {\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n     /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert_eq!(false, Path::new(\"foo.txt\").is_absolute());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_absolute(&self) -> bool {\n         self.has_root() &&\n             (cfg!(unix) || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"foo.txt\").is_relative());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1278,6 +1365,14 @@ impl Path {\n     ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n     ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n     ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"/etc/passwd\").has_root());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn has_root(&self) -> bool {\n          self.components().has_root()\n@@ -1294,8 +1389,11 @@ impl Path {\n     ///\n     /// let path = Path::new(\"/foo/bar\");\n     /// let foo = path.parent().unwrap();\n+    ///\n     /// assert!(foo == Path::new(\"/foo\"));\n+    ///\n     /// let root = foo.parent().unwrap();\n+    ///\n     /// assert!(root == Path::new(\"/\"));\n     /// assert!(root.parent() == None);\n     /// ```\n@@ -1315,6 +1413,17 @@ impl Path {\n     ///\n     /// If the path terminates in `.`, `..`, or consists solely or a root of\n     /// prefix, `file_name` will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"hello_world.rs\");\n+    /// let filename = \"hello_world.rs\";\n+    ///\n+    /// assert_eq!(filename, path.file_name().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n@@ -1334,12 +1443,32 @@ impl Path {\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.starts_with(\"/etc\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n         iter_after(self.components(), base.as_ref().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.ends_with(\"passwd\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n         iter_after(self.components().rev(), child.as_ref().components().rev()).is_some()\n@@ -1353,6 +1482,16 @@ impl Path {\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"foo\", path.file_stem().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_stem(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n@@ -1366,6 +1505,16 @@ impl Path {\n     /// * None, if there is no embedded `.`;\n     /// * None, if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"rs\", path.extension().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn extension(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n@@ -1374,6 +1523,16 @@ impl Path {\n     /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp\");\n+    ///\n+    /// let new_path = path.join(\"foo\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1384,6 +1543,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given file name.\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_file_name(\"bar.rs\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1394,6 +1563,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given extension.\n     ///\n     /// See `PathBuf::set_extension` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_extension(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1402,6 +1581,18 @@ impl Path {\n     }\n \n     /// Produce an iterator over the components of the path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.components() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -1415,13 +1606,35 @@ impl Path {\n     }\n \n     /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.iter() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { inner: self.components() }\n     }\n \n     /// Returns an object that implements `Display` for safely printing paths\n     /// that may contain non-Unicode data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// println!(\"{}\", path.display());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn display(&self) -> Display {\n         Display { path: self }"}]}