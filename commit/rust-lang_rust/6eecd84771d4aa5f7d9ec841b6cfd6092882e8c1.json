{"sha": "6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZWNkODQ3NzFkNGFhNWY3ZDllYzg0MWI2Y2ZkNjA5Mjg4MmU4YzE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-13T22:22:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-13T22:22:08Z"}, "message": "Merge #10126\n\n10126: feat: Speculatively expand attributes in completions r=Veykril a=Veykril\n\n![j1OjBt5Nca](https://user-images.githubusercontent.com/3757771/133163858-91930072-1441-4ce4-9979-b0ad2727b47f.gif)\r\n\r\nFixes #9866\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "55e56eaa7974c776f4a9e6acbfa45d2a3cce2a40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e56eaa7974c776f4a9e6acbfa45d2a3cce2a40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhP88QCRBK7hj4Ov3rIwAArooIALBa3UWBBEyiHi4jCLp+dUZA\ngGXeCE06j7En35nHVP04hJjaH0BOw9Dx0YNowu5RfkJcBu95klu/y1Zt0WKdKnlt\nfyLYK2zXuPLYdBKKirm5VjcLZ1UKujhSiYVXyV3Xno+sKSdPTbHv/jqsBgIvP5FC\nqy+2pUKQnHMnVO90nmaXiJ1OBxdnMHnzBqVHha2GUgSxaoWtCsZBdwfe4WNejtVJ\nscy0lOOOP/lgCYAhJBSEVbvqssyswRQ0U1OcinDeJZG9VdFUxSJ3R2jenmC85J/K\nt5asiM4trJtIHiXzq3/oiy8V/20ftEiyeYyTeZqBwiOz7FlKNd7LK4xvob7S6eg=\n=lGFB\n-----END PGP SIGNATURE-----\n", "payload": "tree 55e56eaa7974c776f4a9e6acbfa45d2a3cce2a40\nparent bcf0072bb4f6eb05371d4ce920415b4b0910de9c\nparent dfb94d09d4a05653b40a7b924a38b77af428fb5f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631571728 +0000\ncommitter GitHub <noreply@github.com> 1631571728 +0000\n\nMerge #10126\n\n10126: feat: Speculatively expand attributes in completions r=Veykril a=Veykril\n\n![j1OjBt5Nca](https://user-images.githubusercontent.com/3757771/133163858-91930072-1441-4ce4-9979-b0ad2727b47f.gif)\r\n\r\nFixes #9866\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "html_url": "https://github.com/rust-lang/rust/commit/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcf0072bb4f6eb05371d4ce920415b4b0910de9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf0072bb4f6eb05371d4ce920415b4b0910de9c", "html_url": "https://github.com/rust-lang/rust/commit/bcf0072bb4f6eb05371d4ce920415b4b0910de9c"}, {"sha": "dfb94d09d4a05653b40a7b924a38b77af428fb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb94d09d4a05653b40a7b924a38b77af428fb5f", "html_url": "https://github.com/rust-lang/rust/commit/dfb94d09d4a05653b40a7b924a38b77af428fb5f"}], "stats": {"total": 448, "additions": 377, "deletions": 71}, "files": [{"sha": "3526778b68f6e273918cb95e965bcfec002d22cd", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -210,14 +210,15 @@ impl ChangeFixture {\n             let proc_lib_file = file_id;\n             file_id.0 += 1;\n \n+            let (proc_macro, source) = test_proc_macros(&proc_macros);\n             let mut fs = FileSet::default();\n             fs.insert(\n                 proc_lib_file,\n                 VfsPath::new_virtual_path(\"/sysroot/proc_macros/lib.rs\".to_string()),\n             );\n             roots.push(SourceRoot::new_library(fs));\n \n-            change.change_file(proc_lib_file, Some(Arc::new(String::new())));\n+            change.change_file(proc_lib_file, Some(Arc::new(String::from(source))));\n \n             let all_crates = crate_graph.crates_in_topological_order();\n \n@@ -228,7 +229,7 @@ impl ChangeFixture {\n                 CfgOptions::default(),\n                 CfgOptions::default(),\n                 Env::default(),\n-                test_proc_macros(&proc_macros),\n+                proc_macro,\n             );\n \n             for krate in all_crates {\n@@ -250,14 +251,33 @@ impl ChangeFixture {\n     }\n }\n \n-fn test_proc_macros(proc_macros: &[String]) -> Vec<ProcMacro> {\n-    std::array::IntoIter::new([ProcMacro {\n-        name: \"identity\".into(),\n-        kind: crate::ProcMacroKind::Attr,\n-        expander: Arc::new(IdentityProcMacroExpander),\n-    }])\n+fn test_proc_macros(proc_macros: &[String]) -> (Vec<ProcMacro>, String) {\n+    // The source here is only required so that paths to the macros exist and are resolvable.\n+    let source = r#\"\n+#[proc_macro_attribute]\n+pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+#[proc_macro_attribute]\n+pub fn input_replace(attr: TokenStream, _item: TokenStream) -> TokenStream {\n+    attr\n+}\n+\"#;\n+    let proc_macros = std::array::IntoIter::new([\n+        ProcMacro {\n+            name: \"identity\".into(),\n+            kind: crate::ProcMacroKind::Attr,\n+            expander: Arc::new(IdentityProcMacroExpander),\n+        },\n+        ProcMacro {\n+            name: \"input_replace\".into(),\n+            kind: crate::ProcMacroKind::Attr,\n+            expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n+        },\n+    ])\n     .filter(|pm| proc_macros.iter().any(|name| name == &pm.name))\n-    .collect()\n+    .collect();\n+    (proc_macros, source.into())\n }\n \n #[derive(Debug, Clone, Copy)]\n@@ -299,8 +319,9 @@ impl From<Fixture> for FileMeta {\n     }\n }\n \n+// Identity mapping\n #[derive(Debug)]\n-pub struct IdentityProcMacroExpander;\n+struct IdentityProcMacroExpander;\n impl ProcMacroExpander for IdentityProcMacroExpander {\n     fn expand(\n         &self,\n@@ -311,3 +332,19 @@ impl ProcMacroExpander for IdentityProcMacroExpander {\n         Ok(subtree.clone())\n     }\n }\n+\n+// Pastes the attribute input as its output\n+#[derive(Debug)]\n+struct AttributeInputReplaceProcMacroExpander;\n+impl ProcMacroExpander for AttributeInputReplaceProcMacroExpander {\n+    fn expand(\n+        &self,\n+        _: &Subtree,\n+        attrs: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        attrs\n+            .cloned()\n+            .ok_or_else(|| ProcMacroExpansionError::Panic(\"Expected attribute input\".into()))\n+    }\n+}"}, {"sha": "b9b94fd22a9d211d9a1275731cfea959c0988e2c", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -166,6 +166,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.speculative_expand(actual_macro_call, speculative_args, token_to_map)\n     }\n \n+    pub fn speculative_expand_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Item,\n+        speculative_args: &ast::Item,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        self.imp.speculative_expand_attr(actual_macro_call, speculative_args, token_to_map)\n+    }\n+\n     // FIXME: Rename to descend_into_macros_single\n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n         self.imp.descend_into_macros(token).pop().unwrap()\n@@ -452,7 +461,24 @@ impl<'db> SemanticsImpl<'db> {\n         hir_expand::db::expand_speculative(\n             self.db.upcast(),\n             macro_call_id,\n-            speculative_args,\n+            speculative_args.syntax(),\n+            token_to_map,\n+        )\n+    }\n+\n+    fn speculative_expand_attr(\n+        &self,\n+        actual_macro_call: &ast::Item,\n+        speculative_args: &ast::Item,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let sa = self.analyze(actual_macro_call.syntax());\n+        let macro_call = InFile::new(sa.file_id, actual_macro_call.clone());\n+        let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(macro_call))?;\n+        hir_expand::db::expand_speculative(\n+            self.db.upcast(),\n+            macro_call_id,\n+            speculative_args.syntax(),\n             token_to_map,\n         )\n     }"}, {"sha": "e1ff646b8b7bf29e75bf26b68dfb14f1c9909ec8", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -5,7 +5,7 @@ use std::sync::Arc;\n use base_db::{salsa, SourceDatabase};\n use itertools::Itertools;\n use limit::Limit;\n-use mbe::{ExpandError, ExpandResult};\n+use mbe::{syntax_node_to_token_tree, ExpandError, ExpandResult};\n use syntax::{\n     algo::diff,\n     ast::{self, AttrsOwner, NameOwner},\n@@ -141,27 +141,72 @@ pub trait AstDatabase: SourceDatabase {\n pub fn expand_speculative(\n     db: &dyn AstDatabase,\n     actual_macro_call: MacroCallId,\n-    speculative_args: &ast::TokenTree,\n+    speculative_args: &SyntaxNode,\n     token_to_map: SyntaxToken,\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n-    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(speculative_args.syntax());\n-    let range =\n-        token_to_map.text_range().checked_sub(speculative_args.syntax().text_range().start())?;\n-    let token_id = tmap_1.token_by_range(range)?;\n-\n-    let macro_def = {\n-        let loc: MacroCallLoc = db.lookup_intern_macro(actual_macro_call);\n-        db.macro_def(loc.def)?\n+    let loc = db.lookup_intern_macro(actual_macro_call);\n+    let macro_def = db.macro_def(loc.def)?;\n+    let token_range = token_to_map.text_range();\n+\n+    // Build the subtree and token mapping for the speculative args\n+    let censor = censor_for_macro_input(&loc, &speculative_args);\n+    let (mut tt, spec_args_tmap) =\n+        mbe::syntax_node_to_token_tree_censored(&speculative_args, censor);\n+\n+    let (attr_arg, token_id) = match loc.kind {\n+        MacroCallKind::Attr { invoc_attr_index, .. } => {\n+            // Attributes may have an input token tree, build the subtree and map for this as well\n+            // then try finding a token id for our token if it is inside this input subtree.\n+            let item = ast::Item::cast(speculative_args.clone())?;\n+            let attr = item.attrs().nth(invoc_attr_index as usize)?;\n+            match attr.token_tree() {\n+                Some(token_tree) => {\n+                    let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n+                    tree.delimiter = None;\n+\n+                    let shift = mbe::Shift::new(&tt);\n+                    shift.shift_all(&mut tree);\n+\n+                    let token_id = if token_tree.syntax().text_range().contains_range(token_range) {\n+                        let attr_input_start =\n+                            token_tree.left_delimiter_token()?.text_range().start();\n+                        let range = token_range.checked_sub(attr_input_start)?;\n+                        let token_id = shift.shift(map.token_by_range(range)?);\n+                        Some(token_id)\n+                    } else {\n+                        None\n+                    };\n+                    (Some(tree), token_id)\n+                }\n+                _ => (None, None),\n+            }\n+        }\n+        _ => (None, None),\n+    };\n+    let token_id = match token_id {\n+        Some(token_id) => token_id,\n+        // token wasn't inside an attribute input so it has to be in the general macro input\n+        None => {\n+            let range = token_range.checked_sub(speculative_args.text_range().start())?;\n+            let token_id = spec_args_tmap.token_by_range(range)?;\n+            macro_def.map_id_down(token_id)\n+        }\n     };\n \n-    let speculative_expansion = macro_def.expand(db, actual_macro_call, &tt);\n+    // Do the actual expansion, we need to directly expand the proc macro due to the attribute args\n+    // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n+    let speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n+        tt.delimiter = None;\n+        expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+    } else {\n+        macro_def.expand(db, actual_macro_call, &tt)\n+    };\n \n     let expand_to = macro_expand_to(db, actual_macro_call);\n+    let (node, rev_tmap) =\n+        token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n \n-    let (node, tmap_2) = token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n-\n-    let token_id = macro_def.map_id_down(token_id);\n-    let range = tmap_2.first_range_by_token(token_id, token_to_map.kind())?;\n+    let range = rev_tmap.first_range_by_token(token_id, token_to_map.kind())?;\n     let token = node.syntax_node().covering_element(range).into_token()?;\n     Some((node.syntax_node(), token))\n }\n@@ -259,7 +304,19 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n     let loc = db.lookup_intern_macro(id);\n \n     let node = SyntaxNode::new_root(arg);\n-    let censor = match loc.kind {\n+    let censor = censor_for_macro_input(&loc, &node);\n+    let (mut tt, tmap) = mbe::syntax_node_to_token_tree_censored(&node, censor);\n+\n+    if loc.def.is_proc_macro() {\n+        // proc macros expect their inputs without parentheses, MBEs expect it with them included\n+        tt.delimiter = None;\n+    }\n+\n+    Some(Arc::new((tt, tmap)))\n+}\n+\n+fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> Option<TextRange> {\n+    match loc.kind {\n         MacroCallKind::FnLike { .. } => None,\n         MacroCallKind::Derive { derive_attr_index, .. } => match ast::Item::cast(node.clone()) {\n             Some(item) => item\n@@ -275,15 +332,7 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n             }\n             None => None,\n         },\n-    };\n-    let (mut tt, tmap) = mbe::syntax_node_to_token_tree_censored(&node, censor);\n-\n-    if loc.def.is_proc_macro() {\n-        // proc macros expect their inputs without parentheses, MBEs expect it with them included\n-        tt.delimiter = None;\n     }\n-\n-    Some(Arc::new((tt, tmap)))\n }\n \n fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n@@ -367,11 +416,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n         None => return ExpandResult::str_err(\"Failed to lower macro args to token tree\".into()),\n     };\n \n-    let macro_rules = match db.macro_def(loc.def) {\n+    let expander = match db.macro_def(loc.def) {\n         Some(it) => it,\n         None => return ExpandResult::str_err(\"Failed to find macro definition\".into()),\n     };\n-    let ExpandResult { value: tt, err } = macro_rules.expand(db, id, &macro_arg.0);\n+    let ExpandResult { value: tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     // XXX: Make ExpandResult a real error and use .map_err instead?"}, {"sha": "871cccb83000e3c451d126b93b749636b7b7e797", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -370,6 +370,7 @@ impl ExpansionInfo {\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n         assert_eq!(token.file_id, self.arg.file_id);\n         let token_id = if let Some(item) = item {\n+            // check if we are mapping down in an attribute input\n             let call_id = match self.expanded.file_id.0 {\n                 HirFileIdRepr::FileId(_) => return None,\n                 HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,"}, {"sha": "1ec952d49c980dec318d574da3c3cf7461908b7a", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -175,48 +175,93 @@ impl<'a> CompletionContext<'a> {\n             incomplete_let: false,\n             no_completion_required: false,\n         };\n+        ctx.expand_and_fill(\n+            original_file.syntax().clone(),\n+            file_with_fake_ident.syntax().clone(),\n+            position.offset,\n+            fake_ident_token,\n+        );\n+        Some(ctx)\n+    }\n \n-        let mut original_file = original_file.syntax().clone();\n-        let mut speculative_file = file_with_fake_ident.syntax().clone();\n-        let mut offset = position.offset;\n-        let mut fake_ident_token = fake_ident_token;\n-\n-        // Are we inside a macro call?\n-        while let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-            find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n-            find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n-        ) {\n-            if actual_macro_call.path().as_ref().map(|s| s.syntax().text())\n-                != macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text())\n-            {\n-                break;\n+    fn expand_and_fill(\n+        &mut self,\n+        mut original_file: SyntaxNode,\n+        mut speculative_file: SyntaxNode,\n+        mut offset: TextSize,\n+        mut fake_ident_token: SyntaxToken,\n+    ) {\n+        loop {\n+            // Expand attributes\n+            if let (Some(actual_item), Some(item_with_fake_ident)) = (\n+                find_node_at_offset::<ast::Item>(&original_file, offset),\n+                find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+            ) {\n+                match (\n+                    self.sema.expand_attr_macro(&actual_item),\n+                    self.sema.speculative_expand_attr_macro(\n+                        &actual_item,\n+                        &item_with_fake_ident,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    (Some(actual_expansion), Some(speculative_expansion)) => {\n+                        let new_offset = speculative_expansion.1.text_range().start();\n+                        if new_offset > actual_expansion.text_range().end() {\n+                            break;\n+                        }\n+                        original_file = actual_expansion;\n+                        speculative_file = speculative_expansion.0;\n+                        fake_ident_token = speculative_expansion.1;\n+                        offset = new_offset;\n+                        continue;\n+                    }\n+                    (None, None) => (),\n+                    _ => break,\n+                }\n             }\n-            let speculative_args = match macro_call_with_fake_ident.token_tree() {\n-                Some(tt) => tt,\n-                None => break,\n-            };\n-            if let (Some(actual_expansion), Some(speculative_expansion)) = (\n-                ctx.sema.expand(&actual_macro_call),\n-                ctx.sema.speculative_expand(\n-                    &actual_macro_call,\n-                    &speculative_args,\n-                    fake_ident_token,\n-                ),\n+\n+            // Expand fn-like macro calls\n+            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+                find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n+                find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n             ) {\n-                let new_offset = speculative_expansion.1.text_range().start();\n-                if new_offset > actual_expansion.text_range().end() {\n+                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n+                let mac_call_path1 =\n+                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n+                if mac_call_path0 != mac_call_path1 {\n+                    break;\n+                }\n+                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n+                    Some(tt) => tt,\n+                    None => break,\n+                };\n+\n+                if let (Some(actual_expansion), Some(speculative_expansion)) = (\n+                    self.sema.expand(&actual_macro_call),\n+                    self.sema.speculative_expand(\n+                        &actual_macro_call,\n+                        &speculative_args,\n+                        fake_ident_token,\n+                    ),\n+                ) {\n+                    let new_offset = speculative_expansion.1.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        break;\n+                    }\n+                    original_file = actual_expansion;\n+                    speculative_file = speculative_expansion.0;\n+                    fake_ident_token = speculative_expansion.1;\n+                    offset = new_offset;\n+                } else {\n                     break;\n                 }\n-                original_file = actual_expansion;\n-                speculative_file = speculative_expansion.0;\n-                fake_ident_token = speculative_expansion.1;\n-                offset = new_offset;\n             } else {\n                 break;\n             }\n         }\n-        ctx.fill(&original_file, speculative_file, offset);\n-        Some(ctx)\n+\n+        self.fill(&original_file, speculative_file, offset);\n     }\n \n     /// Checks whether completions in that particular case don't make much sense."}, {"sha": "6872e3b8dc13273d572def53d0ab17c3e564c185", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -15,6 +15,7 @@ mod item_list;\n mod item;\n mod pattern;\n mod predicate;\n+mod proc_macros;\n mod record;\n mod sourcegen;\n mod type_pos;\n@@ -23,7 +24,7 @@ mod visibility;\n \n use std::mem;\n \n-use hir::{PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     helpers::{\n@@ -96,6 +97,7 @@ fn completion_list_with_config(config: CompletionConfig, ra_fixture: &str) -> St\n pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     let mut database = RootDatabase::default();\n+    database.set_enable_proc_attr_macros(true);\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n     let offset = range_or_offset.expect_offset();"}, {"sha": "73fc293526f7afc5ca8d51483799834d00b0f5c4", "filename": "crates/ide_completion/src/tests/proc_macros.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -0,0 +1,145 @@\n+//! Completion tests for expressions.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn complete_dot_in_attr() {\n+    check(\n+        r#\"\n+//- proc_macros: identity\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::identity]\n+fn main() {\n+    Foo.$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_dot_in_attr2() {\n+    check(\n+        r#\"\n+//- proc_macros: identity\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::identity]\n+fn main() {\n+    Foo.f$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_dot_in_attr_input() {\n+    check(\n+        r#\"\n+//- proc_macros: input_replace\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::input_replace(\n+    fn suprise() {\n+        Foo.$0\n+    }\n+)]\n+fn main() {}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_dot_in_attr_input2() {\n+    check(\n+        r#\"\n+//- proc_macros: input_replace\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::input_replace(\n+    fn suprise() {\n+        Foo.f$0\n+    }\n+)]\n+fn main() {}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}"}, {"sha": "9fddfbe627dfab4e3faa872efa2bbe7884f4e4f8", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=6eecd84771d4aa5f7d9ec841b6cfd6092882e8c1", "patch": "@@ -309,6 +309,7 @@ fn check_dbg(path: &Path, text: &str) {\n         \"handlers/remove_dbg.rs\",\n         // We have .dbg postfix\n         \"ide_completion/src/completions/postfix.rs\",\n+        \"ide_completion/src/tests/proc_macros.rs\",\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_completion/src/lib.rs\",\n         \"ide_db/src/helpers/generated_lints.rs\","}]}