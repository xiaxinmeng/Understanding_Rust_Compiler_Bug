{"sha": "8355437d5d0e747b7e7239cd0a2af8a3825bd912", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNTU0MzdkNWQwZTc0N2I3ZTcyMzljZDBhMmFmOGEzODI1YmQ5MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-08T21:08:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-08T21:08:52Z"}, "message": "Auto merge of #1044 - RalfJung:uprust, r=RalfJung\n\nrustup", "tree": {"sha": "17395fed48e12764d011b5e2ea049592c4261e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17395fed48e12764d011b5e2ea049592c4261e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8355437d5d0e747b7e7239cd0a2af8a3825bd912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8355437d5d0e747b7e7239cd0a2af8a3825bd912", "html_url": "https://github.com/rust-lang/rust/commit/8355437d5d0e747b7e7239cd0a2af8a3825bd912", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8355437d5d0e747b7e7239cd0a2af8a3825bd912/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9316d90315a51de12ab7c3cfbc2bd0c997b32135", "url": "https://api.github.com/repos/rust-lang/rust/commits/9316d90315a51de12ab7c3cfbc2bd0c997b32135", "html_url": "https://github.com/rust-lang/rust/commit/9316d90315a51de12ab7c3cfbc2bd0c997b32135"}, {"sha": "37b1190defc78a8d2d4139bfcb4816a1a7faf253", "url": "https://api.github.com/repos/rust-lang/rust/commits/37b1190defc78a8d2d4139bfcb4816a1a7faf253", "html_url": "https://github.com/rust-lang/rust/commit/37b1190defc78a8d2d4139bfcb4816a1a7faf253"}], "stats": {"total": 94, "additions": 48, "deletions": 46}, "files": [{"sha": "ec45e1f973071457e966dddad355fda78db34c99", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -1 +1 @@\n-c34472b77084c9f76f872871aeab121daf81fb99\n+9e346646e93cc243567e27bb0f4e8716d56ad1f1"}, {"sha": "a55c58c13add7834f7425a6eef894f22e88114cb", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -63,7 +63,7 @@ impl<'mir, 'tcx> GlobalState {\n                 // This never overflows because `int >= glb`\n                 let offset = int - glb;\n                 // If the offset exceeds the size of the allocation, this access is illegal\n-                if offset <= memory.get(alloc_id)?.size.bytes() {\n+                if offset <= memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead)?.0.bytes() {\n                     // This pointer is untagged because it was created from a cast\n                     Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged)\n                 } else {"}, {"sha": "6b2c12e6b0b0451d0ce6cf52c1a02525b2dd1f07", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -75,7 +75,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 let ptr = self.pointer_offset_inbounds(\n                     left.to_scalar()?,\n                     pointee_ty,\n-                    right.to_scalar()?.to_isize(self)?,\n+                    right.to_scalar()?.to_machine_isize(self)?,\n                 )?;\n                 (ptr, false, left.layout.ty)\n             }"}, {"sha": "ca53f5d23015a6f94bb526fbe2348fed9b45a3cb", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -40,7 +40,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match dlsym {\n             GetEntropy => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len as usize)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "44896fd9bbd563a22d33293fa7058f9a517e3e4e", "filename": "src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"getcwd\")?;\n \n         let buf = this.read_scalar(buf_op)?.not_undef()?;\n-        let size = this.read_scalar(size_op)?.to_usize(&*this.tcx)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(&*this.tcx)?;\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {"}, {"sha": "1f43a83576f62da0a215f54ad5cb53fb4bb85f53", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -144,13 +144,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ret = ret.expect(\"dest is `Some` but ret is `None`\");\n         match link_name {\n             \"malloc\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                let items = this.read_scalar(args[0])?.to_usize(this)?;\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let items = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let size = items\n                     .checked_mul(len)\n                     .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n@@ -159,8 +159,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n-                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n@@ -190,14 +190,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n+                let new_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n             \"__rust_alloc\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 if size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -212,8 +212,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 if size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -233,8 +233,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_dealloc\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_usize(this)?;\n+                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 if old_size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -253,9 +253,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_realloc\" => {\n                 let ptr = this.read_scalar(args[0])?.to_ptr()?;\n-                let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_usize(this)?;\n-                let new_size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let new_size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n                 if old_size == 0 || new_size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -277,11 +277,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let sys_getrandom = this\n                     .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n                     .expect(\"Failed to get libc::SYS_getrandom\")\n-                    .to_usize(this)?;\n+                    .to_machine_usize(this)?;\n \n                 // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                 // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n-                match this.read_scalar(args[0])?.to_usize(this)? {\n+                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id,\n                         // so skip over it.\n@@ -357,7 +357,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;\n-                let n = Size::from_bytes(this.read_scalar(args[2])?.to_usize(this)?);\n+                let n = Size::from_bytes(this.read_scalar(args[2])?.to_machine_usize(this)?);\n \n                 let result = {\n                     let left_bytes = this.memory.read_bytes(left, n)?;\n@@ -377,7 +377,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memrchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_usize(this)?;\n+                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 if let Some(idx) = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -395,7 +395,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_usize(this)?;\n+                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let idx = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -462,7 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"write\" => {\n                 let fd = this.read_scalar(args[0])?.to_i32()?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n-                let n = this.read_scalar(args[2])?.to_usize(tcx)?;\n+                let n = this.read_scalar(args[2])?.to_machine_usize(tcx)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n@@ -771,7 +771,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"SecRandomCopyBytes\" => {\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 this.gen_random(ptr, len as usize)?;\n                 this.write_null(dest)?;\n@@ -786,25 +786,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n             }\n             \"HeapAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n-                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                let size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n@@ -883,7 +883,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n             }\n             \"WriteFile\" => {\n-                let handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n                 let n = this.read_scalar(args[2])?.to_u32()?;\n                 let written_place = this.deref_operand(args[3])?;\n@@ -973,7 +973,7 @@ fn linux_getrandom<'tcx>(\n     dest: PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_scalar(args[0])?.not_undef()?;\n-    let len = this.read_scalar(args[1])?.to_usize(this)?;\n+    let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n     // neither of which have any effect on our current PRNG."}, {"sha": "764f345904fa912b41b9ac486e3e3d5f579472b7", "filename": "src/shims/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -154,7 +154,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"read\")?;\n \n-        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n         // Reading zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n@@ -166,8 +166,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.remove_handle_and(fd, |mut handle, this| {\n             // Don't use `?` to avoid returning before reinserting the handle.\n             let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n+                // FIXME: Don't use raw methods\n                 this.memory\n-                    .get_mut(buf.alloc_id)?\n+                    .get_raw_mut(buf.alloc_id)?\n                     .get_bytes_mut(&*this.tcx, buf, Size::from_bytes(count))\n                     .map(|buffer| handle.file.read(buffer))\n             });\n@@ -186,7 +187,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"write\")?;\n \n-        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n         // Writing zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n@@ -195,7 +196,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n \n         this.remove_handle_and(fd, |mut handle, this| {\n-            let bytes = this.memory.get(buf.alloc_id).and_then(|alloc| {\n+            // FIXME: Don't use raw methods\n+            let bytes = this.memory.get_raw(buf.alloc_id).and_then(|alloc| {\n                 alloc\n                     .get_bytes(&*this.tcx, buf, Size::from_bytes(count))\n                     .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))"}, {"sha": "7470090f5208fb7500ba6d21e5f5ddcac62bbac9", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -35,7 +35,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let intrinsic_name = &*tcx.item_name(instance.def_id()).as_str();\n         match intrinsic_name {\n             \"arith_offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_isize(this)?;\n+                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n \n                 let pointee_ty = substs.type_at(0);\n@@ -206,7 +206,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = this.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n-                let count = this.read_scalar(args[2])?.to_usize(this)?;\n+                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let elem_align = elem_layout.align.abi;\n \n                 let size = Size::from_bytes(count * elem_size);\n@@ -371,7 +371,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_isize(this)?;\n+                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let result_ptr = this.pointer_offset_inbounds(ptr, substs.type_at(0), offset)?;\n                 this.write_scalar(result_ptr, dest)?;\n@@ -542,7 +542,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             let ptr = mplace.ptr.to_ptr()?;\n                             // We know the return place is in-bounds\n                             this.memory\n-                                .get_mut(ptr.alloc_id)?\n+                                .get_raw_mut(ptr.alloc_id)?\n                                 .mark_definedness(ptr, dest.layout.size, false);\n                         }\n                     }\n@@ -554,7 +554,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(args[1])?.to_u8()?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let count = this.read_scalar(args[2])?.to_usize(this)?;\n+                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let byte_count = ty_layout.size * count;\n                 this.memory.write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n             }"}, {"sha": "3302143f48cbacb8aa824a7126b8ecad43f5502f", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -75,7 +75,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr_scalar = this.read_scalar(ptr_op)?.not_undef()?;\n \n         if let Ok(ptr) = this.force_ptr(ptr_scalar) {\n-            let cur_align = this.memory.get(ptr.alloc_id)?.align.bytes() as usize;\n+            let cur_align = this.memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?.1.bytes() as usize;\n             if cur_align >= req_align {\n                 // if the allocation alignment is at least the required alignment we use the\n                 // libcore implementation"}, {"sha": "94e69203437bfaa5058a98e89f95f3e8126c6aaf", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8355437d5d0e747b7e7239cd0a2af8a3825bd912/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=8355437d5d0e747b7e7239cd0a2af8a3825bd912", "patch": "@@ -540,8 +540,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n-        let alloc = this.memory.get(ptr.alloc_id)?;\n-        let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+        let extra = &this.memory.get_raw(ptr.alloc_id)?.extra;\n+        let stacked_borrows = extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!"}]}