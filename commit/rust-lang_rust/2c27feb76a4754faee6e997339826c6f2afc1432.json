{"sha": "2c27feb76a4754faee6e997339826c6f2afc1432", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjdmZWI3NmE0NzU0ZmFlZTZlOTk3MzM5ODI2YzZmMmFmYzE0MzI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T15:50:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T15:59:48Z"}, "message": "M-x indent-region on trans.rs.", "tree": {"sha": "eb282ad54d53ccd729d1d250a61f0ee738e619d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb282ad54d53ccd729d1d250a61f0ee738e619d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c27feb76a4754faee6e997339826c6f2afc1432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c27feb76a4754faee6e997339826c6f2afc1432", "html_url": "https://github.com/rust-lang/rust/commit/2c27feb76a4754faee6e997339826c6f2afc1432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c27feb76a4754faee6e997339826c6f2afc1432/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "html_url": "https://github.com/rust-lang/rust/commit/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059"}], "stats": {"total": 62, "additions": 35, "deletions": 27}, "files": [{"sha": "1b895193a56759dcbb953fa3816754fad776ade4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2c27feb76a4754faee6e997339826c6f2afc1432/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c27feb76a4754faee6e997339826c6f2afc1432/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2c27feb76a4754faee6e997339826c6f2afc1432", "patch": "@@ -482,8 +482,8 @@ fn sanitize(str s) -> str {\n                     result += \"_of_\";\n                 } else {\n                     if (c != 10u8 && c != ('}' as u8) && c != (')' as u8) &&\n-                            c != (' ' as u8) && c != ('\\t' as u8) &&\n-                            c != (';' as u8)) {\n+                        c != (' ' as u8) && c != ('\\t' as u8) &&\n+                        c != (';' as u8)) {\n                         auto v = vec(c);\n                         result += _str.from_bytes(v);\n                     }\n@@ -977,15 +977,17 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     alt (t.struct) {\n         case (ty.ty_str) {\n-            ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind trans_non_gc_free(_, v),\n-                                        \"free string\",\n-                                        T_int(), C_int(0));\n+            ret decr_refcnt_and_if_zero\n+                (cx, v, bind trans_non_gc_free(_, v),\n+                 \"free string\",\n+                 T_int(), C_int(0));\n         }\n \n         case (ty.ty_vec(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n-                auto res = iter_sequence(cx, v, t, bind drop_ty(_,_,_));\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @ty.t t) -> result {\n+                auto res = iter_sequence(cx, v, t,\n+                                         bind drop_ty(_,_,_));\n                 // FIXME: switch gc/non-gc on layer of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n@@ -996,7 +998,8 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n         }\n \n         case (ty.ty_box(?body_ty)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v, @ty.t body_ty) -> result {\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n@@ -1274,11 +1277,14 @@ fn iter_structural_ty(@block_ctxt cx,\n \n                                 auto j = 0u;\n                                 for (ty.arg a in args) {\n-                                    auto llfldp = variant_cx.build.GEP(llvarp,\n-                                        vec(C_int(0), C_int(j as int)));\n+                                    auto v = vec(C_int(0),\n+                                                 C_int(j as int));\n+                                    auto llfldp =\n+                                        variant_cx.build.GEP(llvarp, v);\n+\n                                     auto llfld =\n                                         load_scalar_or_boxed(variant_cx,\n-                                                            llfldp, a.ty);\n+                                                             llfldp, a.ty);\n \n                                     auto res = f(variant_cx, llfld, a.ty);\n                                     variant_cx = res.bcx;\n@@ -1830,7 +1836,7 @@ impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n // Returns a pointer to the union part of the LLVM representation of a tag\n // type, cast to the appropriate type.\n fn get_pat_union_ptr(@block_ctxt cx, vec[@ast.pat] subpats, ValueRef llval)\n-        -> ValueRef {\n+    -> ValueRef {\n     auto llblobptr = cx.build.GEP(llval, vec(C_int(0), C_int(1)));\n \n     // Generate the union type.\n@@ -1861,7 +1867,7 @@ impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n             for (tup(ast.def_id,arity) vinfo in tinfo.variants) {\n                 auto this_variant_id = vinfo._0;\n                 if (variant_id._0 == this_variant_id._0 &&\n-                        variant_id._1 == this_variant_id._1) {\n+                    variant_id._1 == this_variant_id._1) {\n                     variant_tag = i;\n                 }\n                 i += 1;\n@@ -1882,8 +1888,8 @@ impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                                                             vec(C_int(0),\n                                                                 C_int(i)));\n                     auto llsubval = load_scalar_or_boxed(matched_cx,\n-                                                        llsubvalptr,\n-                                                        pat_ty(subpat));\n+                                                         llsubvalptr,\n+                                                         pat_ty(subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n                                                       llsubval, next_cx);\n                     matched_cx = subpat_res.bcx;\n@@ -1923,7 +1929,7 @@ impure fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n                 auto llsubvalptr = this_cx.build.GEP(llunionptr,\n                                                      vec(C_int(0), C_int(i)));\n                 auto llsubval = load_scalar_or_boxed(this_cx, llsubvalptr,\n-                                                    pat_ty(subpat));\n+                                                     pat_ty(subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,\n                                                     llsubval);\n                 this_cx = subpat_res.bcx;\n@@ -1993,7 +1999,7 @@ fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n }\n \n fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n-        &ast.ann ann) -> lval_result {\n+              &ast.ann ann) -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n             alt (def) {\n@@ -2493,11 +2499,11 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n             auto bcx = f_res.res.bcx;\n             auto pair = faddr;\n             faddr = bcx.build.GEP(pair, vec(C_int(0),\n-                                             C_int(abi.fn_field_code)));\n+                                            C_int(abi.fn_field_code)));\n             faddr = bcx.build.Load(faddr);\n \n             llclosure = bcx.build.GEP(pair, vec(C_int(0),\n-                                                 C_int(abi.fn_field_box)));\n+                                                C_int(abi.fn_field_box)));\n             llclosure = bcx.build.Load(llclosure);\n         }\n     }\n@@ -2680,7 +2686,7 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res.is_mem);\n             auto lhs_val = load_scalar_or_boxed(lhs_res.res.bcx,\n-                                               lhs_res.res.val, t);\n+                                                lhs_res.res.val, t);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto v = trans_eager_binop(rhs_res.bcx, op, lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -3609,10 +3615,12 @@ fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n                 auto arity_info;\n                 if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n                     auto llvariantty = type_of_variant(cx, variant);\n-                    auto align = llvm.LLVMPreferredAlignmentOfType(cx.td.lltd,\n-                                                                 llvariantty);\n-                    auto size = llvm.LLVMStoreSizeOfType(cx.td.lltd,\n-                                                         llvariantty) as uint;\n+                    auto align =\n+                        llvm.LLVMPreferredAlignmentOfType(cx.td.lltd,\n+                                                          llvariantty);\n+                    auto size =\n+                        llvm.LLVMStoreSizeOfType(cx.td.lltd,\n+                                                 llvariantty) as uint;\n                     if (max_align < align) { max_align = align; }\n                     if (max_size < size) { max_size = size; }\n \n@@ -3957,8 +3965,8 @@ fn make_glues(ModuleRef llmod) -> @glue_fns {\n                                             T_fn(vec(T_taskptr()), T_void())),\n \n              upcall_glues =\n-              _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n-                                     abi.n_upcall_glues as uint),\n+             _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n+                                    abi.n_upcall_glues as uint),\n              no_op_type_glue = make_no_op_type_glue(llmod),\n              memcpy_glue = make_memcpy_glue(llmod),\n              bzero_glue = make_bzero_glue(llmod));"}]}