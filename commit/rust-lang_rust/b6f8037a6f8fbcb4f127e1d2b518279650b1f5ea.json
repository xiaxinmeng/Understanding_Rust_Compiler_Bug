{"sha": "b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZjgwMzdhNmY4ZmJjYjRmMTI3ZTFkMmI1MTgyNzk2NTBiMWY1ZWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-12T08:26:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-12T08:26:52Z"}, "message": "don't get stuck in slice patterns", "tree": {"sha": "bf4908576fa700f2cc432cd72839c8d2eed55191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf4908576fa700f2cc432cd72839c8d2eed55191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "html_url": "https://github.com/rust-lang/rust/commit/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccc75675b618f2ae59c77ee20064e613e74492bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc75675b618f2ae59c77ee20064e613e74492bb", "html_url": "https://github.com/rust-lang/rust/commit/ccc75675b618f2ae59c77ee20064e613e74492bb"}], "stats": {"total": 143, "additions": 122, "deletions": 21}, "files": [{"sha": "420bae7a77e705bd286294b832ad409f3950d5c1", "filename": "crates/libsyntax2/src/grammar/patterns.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "patch": "@@ -102,21 +102,7 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n fn tuple_pat_fields(p: &mut Parser) {\n     assert!(p.at(L_PAREN));\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_PAREN) {\n-        match p.current() {\n-            DOTDOT => p.bump(),\n-            _ => {\n-                if !p.at_ts(PATTERN_FIRST) {\n-                    p.error(\"expected a pattern\");\n-                    break;\n-                }\n-                pattern(p)\n-            }\n-        }\n-        if !p.at(R_PAREN) {\n-            p.expect(COMMA);\n-        }\n-    }\n+    pat_list(p, R_PAREN);\n     p.expect(R_PAREN);\n }\n \n@@ -194,18 +180,27 @@ fn slice_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(L_BRACK));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_BRACK) {\n+    pat_list(p, R_BRACK);\n+    p.expect(R_BRACK);\n+    m.complete(p, SLICE_PAT)\n+}\n+\n+fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n+    while !p.at(EOF) && !p.at(ket) {\n         match p.current() {\n             DOTDOT => p.bump(),\n-            _ => pattern(p),\n+            _ => {\n+                if !p.at_ts(PATTERN_FIRST) {\n+                    p.error(\"expected a pattern\");\n+                    break;\n+                }\n+                pattern(p)\n+            },\n         }\n-        if !p.at(R_BRACK) {\n+        if !p.at(ket) {\n             p.expect(COMMA);\n         }\n     }\n-    p.expect(R_BRACK);\n-\n-    m.complete(p, SLICE_PAT)\n }\n \n // test bind_pat"}, {"sha": "cf98cf7a77c30332aa7c89579a3c3ccf6d6aeb3a", "filename": "crates/libsyntax2/tests/data/parser/fuzz-failures/0001.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0001.rs?ref=b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "patch": "@@ -0,0 +1,106 @@\n+use libsyntax2::{\n+    File, TextRange, SyntaxNodeRef, TextUnit,\n+    SyntaxKind::*,\n+    algo::{find_leaf_at_offset, LeafAtOffset, find_covering_node, ancestors, Direction, siblings},\n+};\n+\n+pub fn extend_selection(file: &File, range: TextRange) -> Option<TextRange> {\n+    let syntax = file.syntax();\n+    extend(syntax.borrowed(), range)\n+}\n+\n+pub(crate) fn extend(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange> {\n+    if range.is_empty() {\n+        let offset = range.start();\n+        let mut leaves = find_leaf_at_offset(root, offset);\n+        if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n+            return Some(extend_ws(root, leaves.next()?, offset));\n+        }\n+        let leaf = match leaves {\n+            LeafAtOffset::None => return None,\n+            LeafAtOffset::Single(l) => l,\n+            LeafAtOffset::Between(l, r) => pick_best(l, r),\n+        };\n+        return Some(leaf.range());\n+    };\n+    let node = find_covering_node(root, range);\n+    if node.kind() == COMMENT && range == node.range() {\n+        if let Some(range) = extend_comments(node) {\n+            return Some(range);\n+        }\n+    }\n+\n+    match ancestors(node).skip_while(|n| n.range() == range).next() {\n+        None => None,\n+        Some(parent) => Some(parent.range()),\n+    }\n+}\n+\n+fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRange {\n+    let ws_text = ws.leaf_text().unwrap();\n+    let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n+    let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n+    let ws_suffix = &ws_text.as_str()[suffix];\n+    let ws_prefix = &ws_text.as_str()[prefix];\n+    if ws_text.contains(\"\\n\") && !ws_suffix.contains(\"\\n\") {\n+        if let Some(node) = ws.next_sibling() {\n+            let start = match ws_prefix.rfind('\\n') {\n+                Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n+                None => node.range().start()\n+            };\n+            let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n+                node.range().end() + TextUnit::of_char('\\n')\n+            } else {\n+                node.range().end()\n+            };\n+            return TextRange::from_to(start, end);\n+        }\n+    }\n+    ws.range()\n+}\n+\n+fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: Syntd[axNodeRef<'a>) -> SyntaxNodeRef<'a> {\n+    return if priority(r) > priority(l) { r } else { l };\n+    fn priority(n: SyntaxNodeRef) -> usize {\n+        match n.kind() {\n+            WHITESPACE => 0,\n+            IDENT | SELF_KW | SUPER_KW | CRATE_KW => 2,\n+            _ => 1,\n+        }\n+    }\n+}\n+\n+fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n+    let left = adj_com[ments(node, Direction::Backward);\n+    let right = adj_comments(node, Direction::Forward);\n+    if left != right {\n+        Some(TextRange::from_to(\n+            left.range().start(),\n+            right.range().end(),\n+        ))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n+    let mut res = node;\n+    for node in siblings(node, dir) {\n+        match node.kind() {\n+            COMMENT => res = node,\n+            WHITESPACE if !node.leaf_text().unwrap().as_str().contains(\"\\n\\n\") => (),\n+            _ => break\n+        }\n+    }\n+    res\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::extract_offset;\n+\n+    fn do_check(before: &str, afters: &[&str]) {\n+        let (cursor, before) = extract_offset(before);\n+        let file = File::parse(&before);\n+        let mut range = TextRange::of"}]}