{"sha": "43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZGFiZDFhZWFiZTAyYzM0MDRjNzZhOGM2MmYyOWI1NWYxZDFjN2M=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-10-02T02:50:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-02T02:50:15Z"}, "message": "Implement `core::ops` (#10)\n\n* Add vector-vector arithmetic ops\r\n* Add operators and integer conversions for masks\r\n* Add unary traits\r\n* Implement Index and IndexMut\r\n* Implement by-ref ops for masks\r\n* Document intrinsics\r\n* Implement format traits for masks\r\n* Add floating point ops tests\r\n* Add integer tests\r\n* Add mask tests", "tree": {"sha": "0878b539a4d9742d6b20f3a0ab498a71f379ab12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0878b539a4d9742d6b20f3a0ab498a71f379ab12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdpVnCRBK7hj4Ov3rIwAAdHIIAHnGkhNlwfsTSxV3nEaKXJbf\nDi2fjhEWnj+BnLGnNXybpVlHoD3whYiWSsmAN++hVBW440QfeyXF9XjYrqfD6Hhu\nSl/bj75+PivVB4Azp74X7FXWqv3Ug/zklkQo8+BTCq+Eki9Hpak2iBMKhPa6dR6J\nglOZNLDHQT59hH9ZdjF8thETZ3T4zoX5fJC31Fmoglzj5mGWm/fFCoowevraHpky\nnU38QmF3Lk74u76yizF7qVDxv7srRumWbaLKM6qRPscbbd8LnmAJ2t5g50PIt3Sj\n9Ijsu8Fd+lKGylXql6bwLlULLNTAis/YuePz0SSZfxnfubFoi/pBnOJG8G7BYX0=\n=B+n8\n-----END PGP SIGNATURE-----\n", "payload": "tree 0878b539a4d9742d6b20f3a0ab498a71f379ab12\nparent fa6bb81e44a14e9381e5de6a5b36399763a9f564\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1601607015 -0400\ncommitter GitHub <noreply@github.com> 1601607015 -0700\n\nImplement `core::ops` (#10)\n\n* Add vector-vector arithmetic ops\r\n* Add operators and integer conversions for masks\r\n* Add unary traits\r\n* Implement Index and IndexMut\r\n* Implement by-ref ops for masks\r\n* Document intrinsics\r\n* Implement format traits for masks\r\n* Add floating point ops tests\r\n* Add integer tests\r\n* Add mask tests"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "html_url": "https://github.com/rust-lang/rust/commit/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa6bb81e44a14e9381e5de6a5b36399763a9f564", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6bb81e44a14e9381e5de6a5b36399763a9f564", "html_url": "https://github.com/rust-lang/rust/commit/fa6bb81e44a14e9381e5de6a5b36399763a9f564"}], "stats": {"total": 2234, "additions": 2233, "deletions": 1}, "files": [{"sha": "c2cef778560fcfcc6526dbc75fe762f6c3b616e6", "filename": "crates/core_simd/src/intrinsics.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,39 @@\n+//! This module contains the LLVM intrinsics bindings that provide the functionality for this\n+//! crate.\n+//!\n+//! The LLVM assembly language is documented here: https://llvm.org/docs/LangRef.html\n+\n+/// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n+/// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n+/// is documented alongside each intrinsic.\n+extern \"platform-intrinsic\" {\n+    /// add/fadd\n+    pub(crate) fn simd_add<T>(x: T, y: T) -> T;\n+\n+    /// sub/fsub\n+    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;\n+\n+    /// mul/fmul\n+    pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n+\n+    /// udiv/sdiv/fdiv\n+    pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n+\n+    /// urem/srem/frem\n+    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n+\n+    /// shl\n+    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;\n+\n+    /// lshr/ashr\n+    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;\n+\n+    /// and\n+    pub(crate) fn simd_and<T>(x: T, y: T) -> T;\n+\n+    /// or\n+    pub(crate) fn simd_or<T>(x: T, y: T) -> T;\n+\n+    /// xor\n+    pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n+}"}, {"sha": "d08ef400f9bbb9dca856d7036cca38ba98399921", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -1,12 +1,14 @@\n #![no_std]\n-#![feature(repr_simd)]\n+#![feature(repr_simd, platform_intrinsics)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n \n #[macro_use]\n mod macros;\n \n mod fmt;\n+mod intrinsics;\n+mod ops;\n \n mod masks;\n pub use masks::*;"}, {"sha": "cba76b6a2a35d73e04b8d78b973a763cb237a12d", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -1,3 +1,13 @@\n+/// The error type returned when converting an integer to a mask fails.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromMaskError(());\n+\n+impl core::fmt::Display for TryFromMaskError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"mask must have all bits set or unset\")\n+    }\n+}\n+\n macro_rules! define_mask {\n     { $(#[$attr:meta])* struct $name:ident($type:ty); } => {\n         $(#[$attr])*\n@@ -34,11 +44,52 @@ macro_rules! define_mask {\n             }\n         }\n \n+        impl core::convert::TryFrom<$type> for $name {\n+            type Error = TryFromMaskError;\n+            fn try_from(value: $type) -> Result<Self, Self::Error> {\n+                if value == 0 || !value == 0 {\n+                    Ok(Self(value))\n+                } else {\n+                    Err(TryFromMaskError(()))\n+                }\n+            }\n+        }\n+\n+        impl core::convert::From<$name> for $type {\n+            fn from(value: $name) -> Self {\n+                value.0\n+            }\n+        }\n+\n         impl core::fmt::Debug for $name {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 self.test().fmt(f)\n             }\n         }\n+\n+        impl core::fmt::Binary for $name {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                <$type as core::fmt::Binary>::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl core::fmt::Octal for $name {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                <$type as core::fmt::Octal>::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl core::fmt::LowerHex for $name {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                <$type as core::fmt::LowerHex>::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl core::fmt::UpperHex for $name {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                <$type as core::fmt::UpperHex>::fmt(&self.0, f)\n+            }\n+        }\n     }\n }\n "}, {"sha": "5af10a4e1886a1ce6cbf1e699172abb9d39982a7", "filename": "crates/core_simd/src/ops.rs", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,628 @@\n+/// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n+fn invalid_shift_rhs<T>(rhs: T) -> bool\n+where\n+    T: Default + PartialOrd + core::convert::TryFrom<usize>,\n+    <T as core::convert::TryFrom<usize>>::Error: core::fmt::Debug,\n+{\n+    let bits_in_type = T::try_from(8 * core::mem::size_of::<T>()).unwrap();\n+    rhs < T::default() || rhs >= bits_in_type\n+}\n+\n+/// Automatically implements operators over references in addition to the provided operator.\n+macro_rules! impl_ref_ops {\n+    // binary op\n+    {\n+        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+            type Output = $output:ty;\n+\n+            $(#[$attrs:meta])*\n+            fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n+        }\n+    } => {\n+        impl core::ops::$trait<$rhs> for $type {\n+            type Output = $output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n+        }\n+\n+        impl core::ops::$trait<&'_ $rhs> for $type {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n+                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n+            }\n+        }\n+\n+        impl core::ops::$trait<$rhs> for &'_ $type {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: $rhs) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok, $rhs_arg)\n+            }\n+        }\n+\n+        impl core::ops::$trait<&'_ $rhs> for &'_ $type {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok, *$rhs_arg)\n+            }\n+        }\n+    };\n+\n+    // binary assignment op\n+    {\n+        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+            $(#[$attrs:meta])*\n+            fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n+        }\n+    } => {\n+        impl core::ops::$trait<$rhs> for $type {\n+            $(#[$attrs])*\n+            fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n+        }\n+\n+        impl core::ops::$trait<&'_ $rhs> for $type {\n+            $(#[$attrs])*\n+            fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n+                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n+            }\n+        }\n+    };\n+\n+    // unary op\n+    {\n+        impl core::ops::$trait:ident for $type:ty {\n+            type Output = $output:ty;\n+            fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n+        }\n+    } => {\n+        impl core::ops::$trait for $type {\n+            type Output = $output;\n+            fn $fn($self_tok) -> Self::Output $body\n+        }\n+\n+        impl core::ops::$trait for &'_ $type {\n+            type Output = <$type as core::ops::$trait>::Output;\n+            fn $fn($self_tok) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok)\n+            }\n+        }\n+    }\n+}\n+\n+/// Implements op traits for masks\n+macro_rules! impl_mask_ops {\n+    { $($mask:ty),* } => {\n+        $(\n+            impl_ref_ops! {\n+                impl core::ops::BitAnd<$mask> for $mask {\n+                    type Output = Self;\n+                    fn bitand(self, rhs: Self) -> Self::Output {\n+                        Self(self.0 & rhs.0)\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::BitAndAssign<$mask> for $mask {\n+                    fn bitand_assign(&mut self, rhs: Self) {\n+                        *self = *self & rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::BitOr<$mask> for $mask {\n+                    type Output = Self;\n+                    fn bitor(self, rhs: Self) -> Self::Output {\n+                        Self(self.0 | rhs.0)\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::BitOrAssign<$mask> for $mask {\n+                    fn bitor_assign(&mut self, rhs: Self) {\n+                        *self = *self | rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::BitXor<$mask> for $mask {\n+                    type Output = Self;\n+                    fn bitxor(self, rhs: Self) -> Self::Output {\n+                        Self(self.0 ^ rhs.0)\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::BitXorAssign<$mask> for $mask {\n+                    fn bitxor_assign(&mut self, rhs: Self) {\n+                        *self = *self ^ rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl core::ops::Not for $mask {\n+                    type Output = Self;\n+                    fn not(self) -> Self::Output {\n+                        Self(!self.0)\n+                    }\n+                }\n+            }\n+        )*\n+    }\n+}\n+impl_mask_ops! { crate::mask8, crate::mask16, crate::mask32, crate::mask64, crate::mask128, crate::masksize }\n+\n+/// Automatically implements operators over vectors and scalars for a particular vector.\n+macro_rules! impl_op {\n+    { impl Add for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Add::add, AddAssign::add_assign, simd_add }\n+    };\n+    { impl Sub for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+    };\n+    { impl Mul for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+    };\n+    { impl Div for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Div::div, DivAssign::div_assign, simd_div }\n+    };\n+    { impl Rem for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+    };\n+    { impl Shl for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+    };\n+    { impl Shr for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+    };\n+    { impl BitAnd for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+    };\n+    { impl BitOr for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+    };\n+    { impl BitXor for $type:ty, $scalar:ty } => {\n+        impl_op! { @binary $type, $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n+    };\n+\n+    { impl Not for $type:ty, $scalar:ty } => {\n+        impl_ref_ops! {\n+            impl core::ops::Not for $type {\n+                type Output = Self;\n+                fn not(self) -> Self::Output {\n+                    self ^ <$type>::splat(!<$scalar>::default())\n+                }\n+            }\n+        }\n+    };\n+\n+    { impl Neg for $type:ty, $scalar:ty } => {\n+        impl_ref_ops! {\n+            impl core::ops::Neg for $type {\n+                type Output = Self;\n+                fn neg(self) -> Self::Output {\n+                    <$type>::splat(-<$scalar>::default()) - self\n+                }\n+            }\n+        }\n+    };\n+\n+    { impl Index for $type:ty, $scalar:ty } => {\n+        impl<I> core::ops::Index<I> for $type\n+        where\n+            I: core::slice::SliceIndex<[$scalar]>,\n+        {\n+            type Output = I::Output;\n+            fn index(&self, index: I) -> &Self::Output {\n+                let slice: &[_] = self.as_ref();\n+                &slice[index]\n+            }\n+        }\n+\n+        impl<I> core::ops::IndexMut<I> for $type\n+        where\n+            I: core::slice::SliceIndex<[$scalar]>,\n+        {\n+            fn index_mut(&mut self, index: I) -> &mut Self::Output {\n+                let slice: &mut [_] = self.as_mut();\n+                &mut slice[index]\n+            }\n+        }\n+    };\n+\n+    // generic binary op with assignment when output is `Self`\n+    { @binary $type:ty, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+        impl_ref_ops! {\n+            impl core::ops::$trait<$type> for $type {\n+                type Output = $type;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: $type) -> Self::Output {\n+                    unsafe {\n+                        crate::intrinsics::$intrinsic(self, rhs)\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl core::ops::$trait<$scalar> for $type {\n+                type Output = $type;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(self, <$type>::splat(rhs))\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl core::ops::$trait<$type> for $scalar {\n+                type Output = $type;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: $type) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(<$type>::splat(self), rhs)\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl core::ops::$assign_trait<$type> for $type {\n+                #[inline]\n+                fn $assign_trait_fn(&mut self, rhs: $type) {\n+                    unsafe {\n+                        *self = crate::intrinsics::$intrinsic(*self, rhs);\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl core::ops::$assign_trait<$scalar> for $type {\n+                #[inline]\n+                fn $assign_trait_fn(&mut self, rhs: $scalar) {\n+                    core::ops::$assign_trait::$assign_trait_fn(self, <$type>::splat(rhs));\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+/// Implements floating-point operators for the provided types.\n+macro_rules! impl_float_ops {\n+    { $($scalar:ty => $($vector:ty),*;)* } => {\n+        $( // scalar\n+            $( // vector\n+                impl_op! { impl Add for $vector, $scalar }\n+                impl_op! { impl Sub for $vector, $scalar }\n+                impl_op! { impl Mul for $vector, $scalar }\n+                impl_op! { impl Div for $vector, $scalar }\n+                impl_op! { impl Rem for $vector, $scalar }\n+                impl_op! { impl Neg for $vector, $scalar }\n+                impl_op! { impl Index for $vector, $scalar }\n+            )*\n+        )*\n+    };\n+}\n+\n+/// Implements mask operators for the provided types.\n+macro_rules! impl_mask_ops {\n+    { $($scalar:ty => $($vector:ty),*;)* } => {\n+        $( // scalar\n+            $( // vector\n+                impl_op! { impl BitAnd for $vector, $scalar }\n+                impl_op! { impl BitOr  for $vector, $scalar }\n+                impl_op! { impl BitXor for $vector, $scalar }\n+                impl_op! { impl Not for $vector, $scalar }\n+                impl_op! { impl Index for $vector, $scalar }\n+            )*\n+        )*\n+    };\n+}\n+\n+/// Implements unsigned integer operators for the provided types.\n+macro_rules! impl_unsigned_int_ops {\n+    { $($scalar:ty => $($vector:ty),*;)* } => {\n+        $( // scalar\n+            $( // vector\n+                impl_op! { impl Add for $vector, $scalar }\n+                impl_op! { impl Sub for $vector, $scalar }\n+                impl_op! { impl Mul for $vector, $scalar }\n+                impl_op! { impl BitAnd for $vector, $scalar }\n+                impl_op! { impl BitOr  for $vector, $scalar }\n+                impl_op! { impl BitXor for $vector, $scalar }\n+                impl_op! { impl Not for $vector, $scalar }\n+                impl_op! { impl Index for $vector, $scalar }\n+\n+                // Integers panic on divide by 0\n+                impl_ref_ops! {\n+                    impl core::ops::Div<$vector> for $vector {\n+                        type Output = Self;\n+\n+                        #[inline]\n+                        fn div(self, rhs: $vector) -> Self::Output {\n+                            // TODO there is probably a better way of doing this\n+                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                                .iter()\n+                                .any(|x| *x == 0)\n+                            {\n+                                panic!(\"attempt to divide by zero\");\n+                            }\n+                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Div<$scalar> for $vector {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn div(self, rhs: $scalar) -> Self::Output {\n+                            if rhs == 0 {\n+                                panic!(\"attempt to divide by zero\");\n+                            }\n+                            let rhs = Self::splat(rhs);\n+                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Div<$vector> for $scalar {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn div(self, rhs: $vector) -> Self::Output {\n+                            <$vector>::splat(self) / rhs\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::DivAssign<$vector> for $vector {\n+                        #[inline]\n+                        fn div_assign(&mut self, rhs: Self) {\n+                            *self = *self / rhs;\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::DivAssign<$scalar> for $vector {\n+                        #[inline]\n+                        fn div_assign(&mut self, rhs: $scalar) {\n+                            *self = *self / rhs;\n+                        }\n+                    }\n+                }\n+\n+                // remainder panics on zero divisor\n+                impl_ref_ops! {\n+                    impl core::ops::Rem<$vector> for $vector {\n+                        type Output = Self;\n+\n+                        #[inline]\n+                        fn rem(self, rhs: $vector) -> Self::Output {\n+                            // TODO there is probably a better way of doing this\n+                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                                .iter()\n+                                .any(|x| *x == 0)\n+                            {\n+                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                            }\n+                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Rem<$scalar> for $vector {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn rem(self, rhs: $scalar) -> Self::Output {\n+                            if rhs == 0 {\n+                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                            }\n+                            let rhs = Self::splat(rhs);\n+                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Rem<$vector> for $scalar {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn rem(self, rhs: $vector) -> Self::Output {\n+                            <$vector>::splat(self) % rhs\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::RemAssign<$vector> for $vector {\n+                        #[inline]\n+                        fn rem_assign(&mut self, rhs: Self) {\n+                            *self = *self % rhs;\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::RemAssign<$scalar> for $vector {\n+                        #[inline]\n+                        fn rem_assign(&mut self, rhs: $scalar) {\n+                            *self = *self % rhs;\n+                        }\n+                    }\n+                }\n+\n+                // shifts panic on overflow\n+                impl_ref_ops! {\n+                    impl core::ops::Shl<$vector> for $vector {\n+                        type Output = Self;\n+\n+                        #[inline]\n+                        fn shl(self, rhs: $vector) -> Self::Output {\n+                            // TODO there is probably a better way of doing this\n+                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                                .iter()\n+                                .copied()\n+                                .any(invalid_shift_rhs)\n+                            {\n+                                panic!(\"attempt to shift left with overflow\");\n+                            }\n+                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Shl<$scalar> for $vector {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn shl(self, rhs: $scalar) -> Self::Output {\n+                            if invalid_shift_rhs(rhs) {\n+                                panic!(\"attempt to shift left with overflow\");\n+                            }\n+                            let rhs = Self::splat(rhs);\n+                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+\n+                impl_ref_ops! {\n+                    impl core::ops::ShlAssign<$vector> for $vector {\n+                        #[inline]\n+                        fn shl_assign(&mut self, rhs: Self) {\n+                            *self = *self << rhs;\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::ShlAssign<$scalar> for $vector {\n+                        #[inline]\n+                        fn shl_assign(&mut self, rhs: $scalar) {\n+                            *self = *self << rhs;\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Shr<$vector> for $vector {\n+                        type Output = Self;\n+\n+                        #[inline]\n+                        fn shr(self, rhs: $vector) -> Self::Output {\n+                            // TODO there is probably a better way of doing this\n+                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                                .iter()\n+                                .copied()\n+                                .any(invalid_shift_rhs)\n+                            {\n+                                panic!(\"attempt to shift with overflow\");\n+                            }\n+                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::Shr<$scalar> for $vector {\n+                        type Output = $vector;\n+\n+                        #[inline]\n+                        fn shr(self, rhs: $scalar) -> Self::Output {\n+                            if invalid_shift_rhs(rhs) {\n+                                panic!(\"attempt to shift with overflow\");\n+                            }\n+                            let rhs = Self::splat(rhs);\n+                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+                        }\n+                    }\n+                }\n+\n+\n+                impl_ref_ops! {\n+                    impl core::ops::ShrAssign<$vector> for $vector {\n+                        #[inline]\n+                        fn shr_assign(&mut self, rhs: Self) {\n+                            *self = *self >> rhs;\n+                        }\n+                    }\n+                }\n+\n+                impl_ref_ops! {\n+                    impl core::ops::ShrAssign<$scalar> for $vector {\n+                        #[inline]\n+                        fn shr_assign(&mut self, rhs: $scalar) {\n+                            *self = *self >> rhs;\n+                        }\n+                    }\n+                }\n+            )*\n+        )*\n+    };\n+}\n+\n+/// Implements unsigned integer operators for the provided types.\n+macro_rules! impl_signed_int_ops {\n+    { $($scalar:ty => $($vector:ty),*;)* } => {\n+        impl_unsigned_int_ops! { $($scalar => $($vector),*;)* }\n+        $( // scalar\n+            $( // vector\n+                impl_op! { impl Neg for $vector, $scalar }\n+            )*\n+        )*\n+    };\n+}\n+\n+impl_unsigned_int_ops! {\n+    u8    => crate::u8x8,    crate::u8x16,   crate::u8x32,   crate::u8x64;\n+    u16   => crate::u16x4,   crate::u16x8,   crate::u16x16,  crate::u16x32;\n+    u32   => crate::u32x2,   crate::u32x4,   crate::u32x8,   crate::u32x16;\n+    u64   => crate::u64x2,   crate::u64x4,   crate::u64x8;\n+    u128  => crate::u128x2,  crate::u128x4;\n+    usize => crate::usizex2, crate::usizex4, crate::usizex8;\n+}\n+\n+impl_signed_int_ops! {\n+    i8    => crate::i8x8,    crate::i8x16,   crate::i8x32,   crate::i8x64;\n+    i16   => crate::i16x4,   crate::i16x8,   crate::i16x16,  crate::i16x32;\n+    i32   => crate::i32x2,   crate::i32x4,   crate::i32x8,   crate::i32x16;\n+    i64   => crate::i64x2,   crate::i64x4,   crate::i64x8;\n+    i128  => crate::i128x2,  crate::i128x4;\n+    isize => crate::isizex2, crate::isizex4, crate::isizex8;\n+}\n+\n+impl_float_ops! {\n+    f32 => crate::f32x2, crate::f32x4, crate::f32x8, crate::f32x16;\n+    f64 => crate::f64x2, crate::f64x4, crate::f64x8;\n+}\n+\n+impl_mask_ops! {\n+    crate::mask8    => crate::mask8x8,    crate::mask8x16,   crate::mask8x32,   crate::mask8x64;\n+    crate::mask16   => crate::mask16x4,   crate::mask16x8,   crate::mask16x16,  crate::mask16x32;\n+    crate::mask32   => crate::mask32x2,   crate::mask32x4,   crate::mask32x8,   crate::mask32x16;\n+    crate::mask64   => crate::mask64x2,   crate::mask64x4,   crate::mask64x8;\n+    crate::mask128  => crate::mask128x2,  crate::mask128x4;\n+    crate::masksize => crate::masksizex2, crate::masksizex4, crate::masksizex8;\n+}"}, {"sha": "f932eba907c3479d5c4e8f0ef928bda83fc7a5b5", "filename": "crates/core_simd/tests/helpers/biteq.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,127 @@\n+pub(crate) trait BitEq {\n+    fn biteq(&self, other: &Self) -> bool;\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n+}\n+\n+macro_rules! impl_biteq {\n+    { integer impl BitEq for $($type:ty,)* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                self == other\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self)\n+            }\n+        }\n+        )*\n+    };\n+    { float impl BitEq for $($type:ty,)* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                self.to_bits() == other.to_bits()\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n+            }\n+        }\n+        )*\n+    };\n+    { vector impl BitEq for $($type:ty,)* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                let a: &[_] = self.as_ref();\n+                let b: &[_] = other.as_ref();\n+                if a.len() == b.len() {\n+                    a.iter().zip(b.iter()).fold(true, |value, (left, right)| {\n+                        value && left.biteq(right)\n+                    })\n+                } else {\n+                    false\n+                }\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                #[repr(transparent)]\n+                struct Wrapper<'a, T: BitEq>(&'a T);\n+\n+                impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n+                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                        self.0.fmt(f)\n+                    }\n+                }\n+\n+                let slice: &[_] = self.as_ref();\n+\n+                f.debug_list()\n+                    .entries(slice.iter().map(|x| Wrapper(x)))\n+                    .finish()\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_biteq! {\n+    integer impl BitEq for\n+        u8, u16, u32, u64, u128, usize,\n+        i8, i16, i32, i64, i128, isize,\n+        core_simd::mask8, core_simd::mask16, core_simd::mask32, core_simd::mask64, core_simd::mask128, core_simd::masksize,\n+}\n+\n+impl_biteq! {\n+    float impl BitEq for f32, f64,\n+}\n+\n+impl_biteq! {\n+    vector impl BitEq for\n+        core_simd::u8x8,    core_simd::u8x16,   core_simd::u8x32,   core_simd::u8x64,\n+        core_simd::i8x8,    core_simd::i8x16,   core_simd::i8x32,   core_simd::i8x64,\n+        core_simd::u16x4,   core_simd::u16x8,   core_simd::u16x16,  core_simd::u16x32,\n+        core_simd::i16x4,   core_simd::i16x8,   core_simd::i16x16,  core_simd::i16x32,\n+        core_simd::u32x2,   core_simd::u32x4,   core_simd::u32x8,   core_simd::u32x16,\n+        core_simd::i32x2,   core_simd::i32x4,   core_simd::i32x8,   core_simd::i32x16,\n+        core_simd::u64x2,   core_simd::u64x4,   core_simd::u64x8,\n+        core_simd::i64x2,   core_simd::i64x4,   core_simd::i64x8,\n+        core_simd::u128x2,  core_simd::u128x4,\n+        core_simd::i128x2,  core_simd::i128x4,\n+        core_simd::usizex2, core_simd::usizex4, core_simd::usizex8,\n+        core_simd::isizex2, core_simd::isizex4, core_simd::isizex8,\n+        core_simd::f32x2, core_simd::f32x4, core_simd::f32x8, core_simd::f32x16,\n+        core_simd::f64x2, core_simd::f64x4, core_simd::f64x8,\n+        core_simd::mask8x8,    core_simd::mask8x16,   core_simd::mask8x32,   core_simd::mask8x64,\n+        core_simd::mask16x4,   core_simd::mask16x8,   core_simd::mask16x16,  core_simd::mask16x32,\n+        core_simd::mask32x2,   core_simd::mask32x4,   core_simd::mask32x8,   core_simd::mask32x16,\n+        core_simd::mask64x2,   core_simd::mask64x4,   core_simd::mask64x8,\n+        core_simd::mask128x2,  core_simd::mask128x4,\n+        core_simd::masksizex2, core_simd::masksizex4, core_simd::masksizex8,\n+}\n+\n+pub(crate) struct BitEqWrapper<'a, T>(pub(crate) &'a T);\n+\n+impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.biteq(other.0)\n+    }\n+}\n+\n+impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+macro_rules! assert_biteq {\n+    { $a:expr, $b:expr } => {\n+        {\n+            use helpers::biteq::BitEqWrapper;\n+            let a = $a;\n+            let b = $b;\n+            assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n+        }\n+    }\n+}"}, {"sha": "6ab7803a967808f04f758c0589d1f76f0ddc151a", "filename": "crates/core_simd/tests/helpers/lanewise.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,49 @@\n+pub fn apply_unary_lanewise<T: Copy, V: AsMut<[T]> + Default>(mut x: V, f: impl Fn(T) -> T) -> V {\n+    for lane in x.as_mut() {\n+        *lane = f(*lane)\n+    }\n+    x\n+}\n+\n+pub fn apply_binary_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n+    a: V,\n+    b: V,\n+    f: impl Fn(T, T) -> T,\n+) -> V {\n+    let mut out = V::default();\n+    let out_slice = out.as_mut();\n+    let a_slice = a.as_ref();\n+    let b_slice = b.as_ref();\n+    for (o, (a, b)) in out_slice.iter_mut().zip(a_slice.iter().zip(b_slice.iter())) {\n+        *o = f(*a, *b);\n+    }\n+    out\n+}\n+\n+pub fn apply_binary_scalar_rhs_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n+    a: V,\n+    b: T,\n+    f: impl Fn(T, T) -> T,\n+) -> V {\n+    let mut out = V::default();\n+    let out_slice = out.as_mut();\n+    let a_slice = a.as_ref();\n+    for (o, a) in out_slice.iter_mut().zip(a_slice.iter()) {\n+        *o = f(*a, b);\n+    }\n+    out\n+}\n+\n+pub fn apply_binary_scalar_lhs_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n+    a: T,\n+    b: V,\n+    f: impl Fn(T, T) -> T,\n+) -> V {\n+    let mut out = V::default();\n+    let out_slice = out.as_mut();\n+    let b_slice = b.as_ref();\n+    for (o, b) in out_slice.iter_mut().zip(b_slice.iter()) {\n+        *o = f(a, *b);\n+    }\n+    out\n+}"}, {"sha": "b128f8251ca3202a6534e98569c48960caf2c75b", "filename": "crates/core_simd/tests/helpers/mod.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,4 @@\n+#[macro_use]\n+pub mod biteq;\n+\n+pub mod lanewise;"}, {"sha": "60aff06a76a65739f4848501754f543c8062672f", "filename": "crates/core_simd/tests/ops.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1 @@\n+mod ops_impl;"}, {"sha": "f87909b68cd3943d358407ffaa62e1659e936502", "filename": "crates/core_simd/tests/ops_impl/f32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+float_tests! { f32x2, f32 }\n+float_tests! { f32x4, f32 }\n+float_tests! { f32x8, f32 }\n+float_tests! { f32x16, f32 }"}, {"sha": "19ae476bd0e1cc968a962befc1cc2d5333b13d01", "filename": "crates/core_simd/tests/ops_impl/f64.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+float_tests! { f64x2, f64 }\n+float_tests! { f64x4, f64 }\n+float_tests! { f64x8, f64 }"}, {"sha": "ddf3bbbe9369eb3a961e63b19439fb0fe2cf8474", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,237 @@\n+macro_rules! float_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        #[cfg(test)]\n+        mod $vector {\n+            use super::*;\n+            use helpers::lanewise::*;\n+\n+            // TODO impl this as an associated fn on vectors\n+            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n+                let mut value = core_simd::$vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n+                value\n+            }\n+\n+            const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n+            const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n+\n+            #[test]\n+            fn add() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_lhs() {\n+                let a = 5.;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_lhs() {\n+                let a = 5.;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_lhs() {\n+                let a = 5.;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_lhs() {\n+                let a = 5.;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_lhs() {\n+                let a = 5.;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5.;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn neg() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n+                assert_biteq!(-v, expected);\n+            }\n+        }\n+    }\n+}"}, {"sha": "8a0a279b8dce2e7f538f19c58911ef891104b3b3", "filename": "crates/core_simd/tests/ops_impl/i128.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,4 @@\n+use super::helpers;\n+\n+int_tests! { i128x2, i128 }\n+int_tests! { i128x4, i128 }"}, {"sha": "445436b77a8935dadf8b2b5ec9e33deae7d245c9", "filename": "crates/core_simd/tests/ops_impl/i16.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+int_tests! { i16x4, i16 }\n+int_tests! { i16x8, i16 }\n+int_tests! { i16x16, i16 }\n+int_tests! { i16x32, i16 }"}, {"sha": "f13ab833a33591027c9b6dce5dec07e07e624d62", "filename": "crates/core_simd/tests/ops_impl/i32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+int_tests! { i32x2, i32 }\n+int_tests! { i32x4, i32 }\n+int_tests! { i32x8, i32 }\n+int_tests! { i32x16, i32 }"}, {"sha": "08479c4b994b34278a7fc85bc0989ab97daedb63", "filename": "crates/core_simd/tests/ops_impl/i64.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+int_tests! { i64x2, i64 }\n+int_tests! { i64x4, i64 }\n+int_tests! { i64x8, i64 }"}, {"sha": "2a7db7906ac1ef02f235b01cdc19fb8d997aacf6", "filename": "crates/core_simd/tests/ops_impl/i8.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+int_tests! { i8x8, i8 }\n+int_tests! { i8x16, i8 }\n+int_tests! { i8x32, i8 }\n+int_tests! { i8x64, i8 }"}, {"sha": "4175541e892dc5375e9284720035a21345ddbec7", "filename": "crates/core_simd/tests/ops_impl/int_macros.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,388 @@\n+macro_rules! int_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        #[cfg(test)]\n+        mod $vector {\n+            use super::*;\n+            use helpers::lanewise::*;\n+\n+            // TODO impl this as an associated fn on vectors\n+            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n+                let mut value = core_simd::$vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n+                value\n+            }\n+\n+            const A: [$scalar; 64] = [\n+                7, 7, 7, 7, -7, -7, -7, -7,\n+                6, 6, 6, 6, -6, -6, -6, -6,\n+                5, 5, 5, 5, -5, -5, -5, -5,\n+                4, 4, 4, 4, -4, -4, -4, -4,\n+                3, 3, 3, 3, -3, -3, -3, -3,\n+                2, 2, 2, 2, -2, -2, -2, -2,\n+                1, 1, 1, 1, -1, -1, -1, -1,\n+                0, 0, 0, 0,  0,  0,  0,  0,\n+            ];\n+            const B: [$scalar; 64] = [\n+                 1,  2,  3,  4,  5,  6,  7,  8,\n+                 1,  2,  3,  4,  5,  6,  7,  8,\n+                 1,  2,  3,  4,  5,  6,  7,  8,\n+                 1,  2,  3,  4,  5,  6,  7,  8,\n+                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n+                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n+                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n+                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n+            ];\n+\n+            #[test]\n+            fn add() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitand() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn neg() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n+                assert_biteq!(-v, expected);\n+            }\n+\n+            #[test]\n+            fn not() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n+                assert_biteq!(!v, expected);\n+            }\n+        }\n+    }\n+}"}, {"sha": "9943e9c357a458d9de84c71a5f259c4dc0480ee2", "filename": "crates/core_simd/tests/ops_impl/isize.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+int_tests! { isizex2, isize }\n+int_tests! { isizex4, isize }\n+int_tests! { isizex8, isize }"}, {"sha": "f0bcdb4d4df9744af7c04a454b67dcad83581ccc", "filename": "crates/core_simd/tests/ops_impl/mask128.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,4 @@\n+use super::helpers;\n+\n+mask_tests! { mask128x2, mask128 }\n+mask_tests! { mask128x4, mask128 }"}, {"sha": "6f3f8e0ee02e75a60b9c8a17a84d288acd99053b", "filename": "crates/core_simd/tests/ops_impl/mask16.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+mask_tests! { mask16x4, mask16 }\n+mask_tests! { mask16x8, mask16 }\n+mask_tests! { mask16x16, mask16 }\n+mask_tests! { mask16x32, mask16 }"}, {"sha": "5c35885a2f5b7965bfe451c099fe97c352810698", "filename": "crates/core_simd/tests/ops_impl/mask32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+mask_tests! { mask32x2, mask32 }\n+mask_tests! { mask32x4, mask32 }\n+mask_tests! { mask32x8, mask32 }\n+mask_tests! { mask32x16, mask32 }"}, {"sha": "88d3211465c5aac51466e5603aaed61a9a1386ab", "filename": "crates/core_simd/tests/ops_impl/mask64.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+mask_tests! { mask64x2, mask64 }\n+mask_tests! { mask64x4, mask64 }\n+mask_tests! { mask64x8, mask64 }"}, {"sha": "fa4bcf09f367fc2ad2f878305a20752e155b2c5a", "filename": "crates/core_simd/tests/ops_impl/mask8.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+mask_tests! { mask8x8, mask8 }\n+mask_tests! { mask8x16, mask8 }\n+mask_tests! { mask8x32, mask8 }\n+mask_tests! { mask8x64, mask8 }"}, {"sha": "9d6bc0cd692f2196955969ea1db61ca0cc10d65b", "filename": "crates/core_simd/tests/ops_impl/mask_macros.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,179 @@\n+macro_rules! mask_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        #[cfg(test)]\n+        mod $vector {\n+            use super::*;\n+            use helpers::lanewise::*;\n+\n+            fn from_slice(slice: &[bool]) -> core_simd::$vector {\n+                let mut value = core_simd::$vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                for (m, b) in value_slice.iter_mut().zip(slice.iter()) {\n+                    *m = (*b).into();\n+                }\n+                value\n+            }\n+\n+            const A: [bool; 64] = [\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+            ];\n+            const B: [bool; 64] = [\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+            ];\n+\n+            const SET_SCALAR: core_simd::$scalar = core_simd::$scalar::new(true);\n+            const UNSET_SCALAR: core_simd::$scalar = core_simd::$scalar::new(false);\n+            const SET_VECTOR: core_simd::$vector = core_simd::$vector::splat(SET_SCALAR);\n+            const UNSET_VECTOR: core_simd::$vector = core_simd::$vector::splat(UNSET_SCALAR);\n+\n+            #[test]\n+            fn bitand() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let expected = a;\n+                assert_biteq!(a & SET_SCALAR, expected);\n+                assert_biteq!(a & UNSET_SCALAR, UNSET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_lhs() {\n+                let a = from_slice(&A);\n+                let expected = a;\n+                assert_biteq!(SET_SCALAR & a, expected);\n+                assert_biteq!(UNSET_SCALAR & a, UNSET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitand_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected = a;\n+                a &= SET_SCALAR;\n+                assert_biteq!(a, expected);\n+                a &= UNSET_SCALAR;\n+                assert_biteq!(a, UNSET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                assert_biteq!(a | UNSET_SCALAR, a);\n+                assert_biteq!(a | SET_SCALAR, SET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_lhs() {\n+                let a = from_slice(&A);\n+                assert_biteq!(UNSET_SCALAR | a, a);\n+                assert_biteq!(SET_SCALAR | a, SET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected = a;\n+                a |= UNSET_SCALAR;\n+                assert_biteq!(a, expected);\n+                a |= SET_SCALAR;\n+                assert_biteq!(a, SET_VECTOR);\n+            }\n+\n+            #[test]\n+            fn bitxor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let expected = apply_binary_scalar_rhs_lanewise(a, SET_SCALAR, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ UNSET_SCALAR, a);\n+                assert_biteq!(a ^ SET_SCALAR, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_lhs() {\n+                let a = from_slice(&A);\n+                let expected = apply_binary_scalar_lhs_lanewise(SET_SCALAR, a, core::ops::BitXor::bitxor);\n+                assert_biteq!(UNSET_SCALAR ^ a, a);\n+                assert_biteq!(SET_SCALAR ^ a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected_unset = a;\n+                let expected_set = apply_binary_scalar_rhs_lanewise(a, SET_SCALAR, core::ops::BitXor::bitxor);\n+                a ^= UNSET_SCALAR;\n+                assert_biteq!(a, expected_unset);\n+                a ^= SET_SCALAR;\n+                assert_biteq!(a, expected_set);\n+            }\n+\n+            #[test]\n+            fn not() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n+                assert_biteq!(!v, expected);\n+            }\n+        }\n+    }\n+}"}, {"sha": "76e333f3c154b64ae7cfa4ba3d1d634b1a471216", "filename": "crates/core_simd/tests/ops_impl/masksize.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+mask_tests! { masksizex2, masksize }\n+mask_tests! { masksizex4, masksize }\n+mask_tests! { masksizex8, masksize }"}, {"sha": "814f2d04b59c315751b9f3a5c8deea391d51268a", "filename": "crates/core_simd/tests/ops_impl/mod.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,39 @@\n+#[macro_use]\n+#[path = \"../helpers/mod.rs\"]\n+mod helpers;\n+\n+#[macro_use]\n+mod float_macros;\n+\n+mod r#f32;\n+mod r#f64;\n+\n+#[macro_use]\n+mod int_macros;\n+\n+mod r#i8;\n+mod r#i16;\n+mod r#i32;\n+mod r#i64;\n+mod r#i128;\n+mod r#isize;\n+\n+#[macro_use]\n+mod uint_macros;\n+\n+mod r#u8;\n+mod r#u16;\n+mod r#u32;\n+mod r#u64;\n+mod r#u128;\n+mod r#usize;\n+\n+#[macro_use]\n+mod mask_macros;\n+\n+mod mask8;\n+mod mask16;\n+mod mask32;\n+mod mask64;\n+mod mask128;\n+mod masksize;"}, {"sha": "cfd849640ffefe2615bcd418c5808bc414663440", "filename": "crates/core_simd/tests/ops_impl/u128.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,4 @@\n+use super::helpers;\n+\n+uint_tests! { u128x2, u128 }\n+uint_tests! { u128x4, u128 }"}, {"sha": "50af4dd48b38293a429c5ef349165d56549c6a9c", "filename": "crates/core_simd/tests/ops_impl/u16.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+uint_tests! { u16x4, u16 }\n+uint_tests! { u16x8, u16 }\n+uint_tests! { u16x16, u16 }\n+uint_tests! { u16x32, u16 }"}, {"sha": "8e7faa9d740385de0848fe914eb7382ed99e9b56", "filename": "crates/core_simd/tests/ops_impl/u32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+uint_tests! { u32x2, u32 }\n+uint_tests! { u32x4, u32 }\n+uint_tests! { u32x8, u32 }\n+uint_tests! { u32x16, u32 }"}, {"sha": "1a6385d37bae5b485ca4655382b5d30b04748c67", "filename": "crates/core_simd/tests/ops_impl/u64.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+uint_tests! { u64x2, u64 }\n+uint_tests! { u64x4, u64 }\n+uint_tests! { u64x8, u64 }"}, {"sha": "31568b1eacbef01c07c18e3106a9c9a5907364f9", "filename": "crates/core_simd/tests/ops_impl/u8.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,6 @@\n+use super::helpers;\n+\n+uint_tests! { u8x8, u8 }\n+uint_tests! { u8x16, u8 }\n+uint_tests! { u8x32, u8 }\n+uint_tests! { u8x64, u8 }"}, {"sha": "eb9ac34d7efd8936298bb8b49a00733431ab2c61", "filename": "crates/core_simd/tests/ops_impl/uint_macros.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,381 @@\n+macro_rules! uint_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        #[cfg(test)]\n+        mod $vector {\n+            use super::*;\n+            use helpers::lanewise::*;\n+\n+            // TODO impl this as an associated fn on vectors\n+            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n+                let mut value = core_simd::$vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n+                value\n+            }\n+\n+            const A: [$scalar; 64] = [\n+                16, 16, 16, 16, 16, 16, 16, 16,\n+                14, 14, 14, 14, 14, 14, 14, 14,\n+                12, 12, 12, 12, 12, 12, 12, 12,\n+                10, 10, 10, 10, 10, 10, 10, 10,\n+                 8,  8,  8,  8,  8,  8,  8,  8,\n+                 6,  6,  6,  6,  6,  6,  7,  8,\n+                 4,  4,  4,  4,  5,  6,  7,  8,\n+                 1,  2,  3,  4,  5,  6,  7,  8,\n+            ];\n+            const B: [$scalar; 64] = [\n+                1, 2, 3, 4, 1, 2, 3, 4,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+                1, 2, 3, 4, 5, 6, 7, 8,\n+            ];\n+\n+            #[test]\n+            fn add() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n+                assert_biteq!(a + b, expected);\n+            }\n+\n+            #[test]\n+            fn add_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n+                a += b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 1;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_scalar_lhs() {\n+                let a = 40;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n+                assert_biteq!(a - b, expected);\n+            }\n+\n+            #[test]\n+            fn sub_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 1;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n+                a -= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n+                assert_biteq!(a * b, expected);\n+            }\n+\n+            #[test]\n+            fn mul_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n+                a *= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n+                assert_biteq!(a / b, expected);\n+            }\n+\n+            #[test]\n+            fn div_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n+                a /= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n+                assert_biteq!(a % b, expected);\n+            }\n+\n+            #[test]\n+            fn rem_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n+                a %= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitand() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_biteq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            fn bitand_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_biteq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            fn bitor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_scalar_lhs() {\n+                let a = 5;\n+                let b = from_slice(&B);\n+                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_biteq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            fn bitxor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let b = 5;\n+                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_biteq!(a, expected);\n+            }\n+\n+            #[test]\n+            fn not() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n+                assert_biteq!(!v, expected);\n+            }\n+        }\n+    }\n+}"}, {"sha": "13da57f15869b2eca9f1f2a0f56220be5e8239f6", "filename": "crates/core_simd/tests/ops_impl/usize.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs?ref=43dabd1aeabe02c3404c76a8c62f29b55f1d1c7c", "patch": "@@ -0,0 +1,5 @@\n+use super::helpers;\n+\n+uint_tests! { usizex2, usize }\n+uint_tests! { usizex4, usize }\n+uint_tests! { usizex8, usize }"}]}