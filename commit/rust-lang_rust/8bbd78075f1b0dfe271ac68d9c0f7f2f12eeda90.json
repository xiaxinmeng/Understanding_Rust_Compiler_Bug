{"sha": "8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYmQ3ODA3NWYxYjBkZmUyNzFhYzY4ZDljMGY3ZjJmMTJlZWRhOTA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-24T02:49:01Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-24T03:37:50Z"}, "message": "Handle self correctly when translating classes\n\nThis change uses the same code for handling the \"self\" reference for\nclasses as is already used for impls/ifaces. This allows removing the\nextra maybe_self_id argument (which was just for classes) to trans_closure\nthat I added before. I also rewrote the translation for class ctors so\nthat it doesn't generate new AST nodes (instead translating directly).\n\nAlso changed visit so that it visits class ctors correctly with visit_fn,\nand changed typestate to not do return-checking when visiting a class ctor.", "tree": {"sha": "5622d5946e35aa5b9d14b95ec528bea9ebf9bff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5622d5946e35aa5b9d14b95ec528bea9ebf9bff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "html_url": "https://github.com/rust-lang/rust/commit/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "713b3585c6d2ab8d07dc3f996736872af41a74fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/713b3585c6d2ab8d07dc3f996736872af41a74fe", "html_url": "https://github.com/rust-lang/rust/commit/713b3585c6d2ab8d07dc3f996736872af41a74fe"}], "stats": {"total": 204, "additions": 99, "deletions": 105}, "files": [{"sha": "c2351b3a3052855014ce95b454359aea8f95eeb6", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -201,7 +201,7 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n \n             alt fk {\n               visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps) {\n+              visit::fk_res(_, tps) | visit::fk_ctor(_, tps) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n               visit::fk_method(_, tps, m) {"}, {"sha": "bf760b5eeb2041dcfbe702a988abefd836cd1573", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -570,7 +570,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n-      visit::fk_method(_, tps, _) { scope_bare_fn(decl, id, tps) }\n+      visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps)\n+         { scope_bare_fn(decl, id, tps) }\n       visit::fk_anon(ast::proto_bare) { scope_bare_fn(decl, id, []) }\n       visit::fk_anon(_) | visit::fk_fn_block { scope_fn_expr(decl, id, []) }\n     };"}, {"sha": "593cdd228cd1fcbd146f2ed49ae80b86b858c5b9", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 79, "deletions": 88, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -1502,6 +1502,7 @@ fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n+    log_expr(*ex);\n     let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n@@ -1958,11 +1959,10 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     alt check map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) {\n         set_inline_hint_if_appr(i.attrs, lldecl);\n-        trans_fn(ccx, pt, decl, body, lldecl, no_self, psubsts, fn_id.node,\n-                 none);\n+        trans_fn(ccx, pt, decl, body, lldecl, no_self, psubsts, fn_id.node);\n       }\n       ast_map::node_item(@{node: ast::item_res(d, _, body, d_id, _), _}, _) {\n-        trans_fn(ccx, pt, d, body, lldecl, no_self, psubsts, d_id, none);\n+        trans_fn(ccx, pt, d, body, lldecl, no_self, psubsts, d_id);\n       }\n       ast_map::node_native_item(i, _, _) {\n         native::trans_intrinsic(ccx, lldecl, i, pt, option::get(psubsts),\n@@ -1981,7 +1981,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         let selfty = ty::node_id_to_type(ccx.tcx, mth.self_id);\n         let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n-                 impl_self(selfty), psubsts, fn_id.node, none);\n+                 impl_self(selfty), psubsts, fn_id.node);\n       }\n       ast_map::node_ctor(i, _) {\n         alt check i.node {\n@@ -2050,7 +2050,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                 let path = ty::item_path(ccx.tcx, impl_did) +\n                     [path_name(mth.ident)];\n                 trans_fn(ccx, path, mth.decl, mth.body,\n-                         llfn, impl_self(impl_ty), none, mth.id, none);\n+                         llfn, impl_self(impl_ty), none, mth.id);\n             }\n             local_def(mth.id)\n           }\n@@ -2137,6 +2137,11 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     }\n }\n \n+fn cast_self(cx: block, slf: val_self_pair) -> ValueRef {\n+    let rslt = PointerCast(cx, slf.v, T_ptr(type_of(cx.ccx(), slf.t)));\n+    rslt\n+}\n+\n fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     let _icx = cx.insn_ctxt(\"trans_local_var\");\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n@@ -2161,9 +2166,12 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         ret take_local(cx.fcx.lllocals, nid);\n       }\n       ast::def_self(_) {\n-        let slf = option::get(cx.fcx.llself);\n-        let ptr = PointerCast(cx, slf.v,\n-                              T_ptr(type_of(cx.ccx(), slf.t)));\n+        let slf = alt cx.fcx.llself {\n+             some(s) { s }\n+             none { cx.sess().bug(\"trans_local_var: reference to self \\\n+                                 out of context\"); }\n+        };\n+        let ptr = cast_self(cx, slf);\n         ret {val: ptr, kind: owned};\n       }\n       _ {\n@@ -2223,11 +2231,12 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n       }\n       ast::def_class_field(parent, did) {\n           // base is implicitly \"Self\"\n-          alt cx.fcx.self_id {\n+          alt cx.fcx.llself {\n             some(slf) {\n-                let {bcx, val, kind} = trans_rec_field(cx, slf,\n-                    // TODO: only supporting local objects for now\n-                                          path_to_ident(path));\n+                let base = cast_self(cx, slf);\n+                let {bcx, val, kind} = trans_rec_field_inner(cx, base,\n+                                         slf.t,\n+                                         path_to_ident(path), path.span);\n                 ret lval_no_env(bcx, val, kind);\n             }\n             _ { cx.sess().bug(\"unbound self param in class\"); }\n@@ -2245,11 +2254,16 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n+    trans_rec_field_inner(bcx, val, ty, field, base.span)\n+}\n+\n+fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n+                         field: ast::ident, sp: span) -> lval_result {\n     let fields = alt ty::get(ty).struct {\n             ty::ty_rec(fs) { fs }\n             ty::ty_class(did,_) { ty::class_items_as_fields(bcx.tcx(), did) }\n             // Constraint?\n-            _ { bcx.tcx().sess.span_bug(base.span, \"trans_rec_field:\\\n+            _ { bcx.tcx().sess.span_bug(sp, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n         };\n     let ix = option::get(ty::field_idx(field, fields));\n@@ -3406,8 +3420,9 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n         let initexpr = alt local.node.init {\n                 some({expr, _}) { expr }\n                 none { bcx.tcx().sess.span_bug(local.span,\n-                        \"init_local: Someone forgot to document why it's\\\n-                         safe to assume local.node.init isn't none!\"); }\n+                        \"init_local: late-initialized var appears to \\\n+                 be an immediate -- possibly init_local was called \\\n+                 without calling alloc_local\"); }\n             };\n         let mut {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n         if kind != temporary {\n@@ -3746,7 +3761,6 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - trans_args\n fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n-                    maybe_self_id: option<@ast::expr>,\n                     param_substs: option<param_substs>,\n                     sp: option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -3762,7 +3776,6 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           lllocals: int_hash::<local_val>(),\n           llupvars: int_hash::<ValueRef>(),\n           id: id,\n-          self_id: maybe_self_id,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n@@ -3771,7 +3784,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n \n fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n                sp: option<span>) -> fn_ctxt {\n-    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, none, sp);\n+    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -3873,14 +3886,14 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg,\n                  param_substs: option<param_substs>,\n-                 id: ast::node_id, maybe_self_id: option<@ast::expr>,\n+                 id: ast::node_id,\n                  maybe_load_env: fn(fn_ctxt)) {\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-            let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, maybe_self_id,\n-                  param_substs, some(body.span));\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n+                                  some(body.span));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -3900,7 +3913,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n \n-    if option::is_none(maybe_self_id) // hack --\n+    if !ccx.class_ctors.contains_key(id) // hack --\n        /* avoids the need for special cases to assign a type to\n           the constructor body (since it has no explicit return) */\n       &&\n@@ -3926,14 +3939,13 @@ fn trans_fn(ccx: @crate_ctxt,\n             llfndecl: ValueRef,\n             ty_self: self_arg,\n             param_substs: option<param_substs>,\n-            id: ast::node_id,\n-            maybe_self_id: option<@ast::expr>) {\n+            id: ast::node_id) {\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0u32, usec: 0u32} };\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  param_substs, id, maybe_self_id, {|fcx|\n+                  param_substs, id, {|fcx|\n         if ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_function(fcx);\n         }\n@@ -3949,8 +3961,8 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_res_ctor\");\n     // Create a function for the constructor\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n-                               none, param_substs, none);\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id, param_substs,\n+                               none);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs);\n     let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n@@ -3985,7 +3997,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                      ident: \"arg\" + uint::to_str(i, 10u),\n                      id: varg.id}];\n     }\n-    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none,\n+    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = alt param_substs {\n@@ -4150,7 +4162,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         } else if tps.len() == 0u {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     llfndecl, no_self, none, item.id, none);\n+                     llfndecl, no_self, none, item.id);\n         } else {\n             for stmt in body.node.stmts {\n                 alt stmt.node {\n@@ -4172,7 +4184,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n \n             let lldtor_decl = get_item_val(ccx, item.id);\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     lldtor_decl, no_self, none, dtor_id, none);\n+                     lldtor_decl, no_self, none, dtor_id);\n         }\n       }\n       ast::item_mod(m) {\n@@ -4205,25 +4217,14 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_class(tps, items, ctor) {\n         // FIXME factor our ctor translation, call from monomorphic_fn\n         let llctor_decl = get_item_val(ccx, ctor.node.id);\n+        // Add ctor to the ctor map\n+        ccx.class_ctors.insert(ctor.node.id, item.id);\n         // Translate the ctor\n-        // First, add a preamble that\n-        // generates a new name, obj:\n-        // let obj = { ... } (uninit record fields)\n-        let rslt_path_ = {global: false,\n-                          idents: [\"obj\"],\n-                          types: []}; // ??\n-        let rslt_path = @{node: rslt_path_,\n-                          span: ctor.node.body.span};\n-        let rslt_id : ast::node_id = ccx.sess.next_node_id();\n-        let rslt_pat : @ast::pat =\n-            @{id: ccx.sess.next_node_id(),\n-              node: ast::pat_ident(rslt_path, none),\n-              span: ctor.node.body.span};\n-        // Set up obj's type\n-        let rslt_ast_ty : @ast::ty = @{id: ccx.sess.next_node_id(),\n-                                       node: ast::ty_infer,\n-                                       span: ctor.node.body.span};\n-        // kludgy\n+\n+        // Set up the type for the result of the ctor\n+        // kludgy -- this wouldn't be necessary if the typechecker\n+        // special-cased constructors, then we could just look up\n+        // the ctor's return type.\n         let mut ty_args = [], i = 0u;\n         for tp in tps {\n             ty_args += [ty::mk_param(ccx.tcx, i,\n@@ -4233,48 +4234,37 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         let rslt_ty =  ty::mk_class(ccx.tcx,\n                                     local_def(item.id),\n                                     ty_args);\n-        // Set up a local for obj\n-        let rslt_loc_ : ast::local_ = {is_mutbl: true,\n-                                       ty: rslt_ast_ty, // ???\n-                                       pat: rslt_pat,\n-                                       init: none::<ast::initializer>,\n-                                       id: rslt_id};\n-        // Register a type for obj\n-        smallintmap::insert(*ccx.tcx.node_types,\n-                            rslt_loc_.id as uint, rslt_ty);\n-        // Create the decl statement that initializes obj\n-        let rslt_loc : @ast::local =\n-            @{node: rslt_loc_, span: ctor.node.body.span};\n-        let rslt_decl_ : ast::decl_ = ast::decl_local([rslt_loc]);\n-        let rslt_decl : @ast::decl\n-            = @{node: rslt_decl_, span: ctor.node.body.span};\n-        let prologue = @{node: ast::stmt_decl(rslt_decl,\n-                                              ccx.sess.next_node_id()),\n-                         span: ctor.node.body.span};\n-        let rslt_node_id = ccx.sess.next_node_id();\n-        ccx.tcx.def_map.insert(rslt_node_id,\n-                               ast::def_local(rslt_loc_.id, true));\n-        // And give the statement a type\n-        smallintmap::insert(*ccx.tcx.node_types,\n-                            rslt_node_id as uint, rslt_ty);\n-        // The result expression of the constructor is now a\n-        // reference to obj\n-        let rslt_expr : @ast::expr =\n-            @{id: rslt_node_id,\n-              node: ast::expr_path(rslt_path),\n-              span: ctor.node.body.span};\n-        let ctor_body_new : ast::blk_ = {stmts: [prologue]\n-                                             + ctor.node.body.node.stmts,\n-                                         expr: some(rslt_expr)\n-                                         with ctor.node.body.node};\n-        let ctor_body__ : ast::blk = {node: ctor_body_new\n-                                      with ctor.node.body};\n-        trans_fn(ccx, *path + [path_name(item.ident)], ctor.node.dec,\n-                 ctor_body__, llctor_decl, no_self,\n-                 none, ctor.node.id, some(rslt_expr));\n+\n+        // Make the fn context\n+        let fcx = new_fn_ctxt_w_id(ccx, *path, llctor_decl, ctor.node.id,\n+                                      // substs?\n+                                      none, some(ctor.span));\n+        create_llargs_for_fn_args(fcx, no_self, ctor.node.dec.inputs);\n+        let mut bcx_top = top_scope_block(fcx, some(ctor.span));\n+        let lltop = bcx_top.llbb;\n+        bcx_top = copy_args_to_allocas(fcx, bcx_top, ctor.node.dec.inputs,\n+           ty::ty_fn_args(node_id_type(bcx_top, ctor.node.id)));\n+\n+        // We *don't* want self to be passed to the ctor -- that\n+        // wouldn't make sense\n+        // So we initialize it here\n+        let {bcx, val} = alloc_ty(bcx_top, rslt_ty);\n+        let mut bcx = bcx;\n+        let selfptr = val;\n+        fcx.llself = some({v: selfptr, t: rslt_ty});\n+\n+        // Translate the body of the ctor\n+        bcx = trans_block(bcx_top, ctor.node.body, ignore);\n+        let lval_res = {bcx: bcx, val: selfptr, kind: owned};\n+        // Generate the return expression\n+        bcx = store_temp_expr(bcx, INIT, fcx.llretptr, lval_res,\n+                              rslt_ty, true);\n+        cleanup_and_leave(bcx, none, some(fcx.llreturn));\n+        Unreachable(bcx);\n+        finish_fn(fcx, lltop);\n+\n         // Translate methods\n         let (_, ms) = ast_util::split_class_items(items);\n-        // not sure how this is going to work what with \"self\" and fields\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       _ {/* fall through */ }\n@@ -4808,6 +4798,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           shape_cx: mk_ctxt(llmod),\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n+          class_ctors: int_hash::<int>(),\n           mutable do_not_commit_warning_issued: false};\n \n "}, {"sha": "09d041429cbb1792ba22880b8bc74182ef1a3c28", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -383,7 +383,7 @@ fn trans_expr_fn(bcx: block,\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n-                      bcx.fcx.param_substs, id, none, {|fcx|\n+                      bcx.fcx.param_substs, id, {|fcx|\n             load_environment(fcx, cdata_ty, cap_vars, ck);\n         });\n         llbox\n@@ -395,7 +395,7 @@ fn trans_expr_fn(bcx: block,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self, none,\n-                      id, none, {|_fcx|});\n+                      id, {|_fcx|});\n         C_null(T_opaque_box_ptr(ccx))\n       }\n     };"}, {"sha": "66aea525691289d37ac7716dd52f70b6ab2c102b", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -119,6 +119,9 @@ type crate_ctxt = {\n      shape_cx: shape::ctxt,\n      crate_map: ValueRef,\n      dbg_cx: option<debuginfo::debug_ctxt>,\n+     // Mapping from class constructors to parent class --\n+     // used in base::trans_closure\n+     class_ctors: hashmap<ast::node_id, ast::node_id>,\n      mutable do_not_commit_warning_issued: bool};\n \n // Types used for llself.\n@@ -175,10 +178,6 @@ type fn_ctxt = @{\n     // a user-defined function.\n     id: ast::node_id,\n \n-    // The expr for the \"self\" object (only if this function corresponds\n-    // to a class constructor function)\n-    self_id: option<@ast::expr>,\n-\n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n     param_substs: option<param_substs>,"}, {"sha": "2f2aaeaef1417152fd6190e43b4273c1b14b4e65", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -24,7 +24,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n             let llfn = get_item_val(ccx, m.id);\n             trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)),\n-                     none, m.id, none);\n+                     none, m.id);\n         }\n     }\n }"}, {"sha": "fb9a319971b2e2fb5bd22f2bb7c91fc67aa0e5eb", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -818,8 +818,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id,\n-                 none);\n+        trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id);\n         ret llfndecl;\n     }\n "}, {"sha": "843a8f24896481a0835b50f3fe126299780fb780", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -111,7 +111,8 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n \n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f_body);\n-    if !promises(fcx, post, fcx.enclosing.i_return) &&\n+    let is_ctor = alt fk { visit::fk_ctor(_,_) { true } _ { false } };\n+    if !is_ctor && !promises(fcx, post, fcx.enclosing.i_return) &&\n        !ty::type_is_nil(ty::ty_fn_ret(ty::node_id_to_type(\n            fcx.ccx.tcx, id))) &&\n        f_decl.cf == return_val {"}, {"sha": "cff35221a8d293cce66a84714d2d71f06c83232d", "filename": "src/rustc/syntax/visit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Frustc%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fvisit.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -18,18 +18,21 @@ enum fn_kind {\n     fk_res(ident, [ty_param]),\n     fk_anon(proto),  //< an anonymous function like fn@(...)\n     fk_fn_block,     //< a block {||...}\n+    fk_ctor(ident, [ty_param]) // class constructor\n }\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n-      fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _) { name }\n+      fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _)\n+          | fk_ctor(name, _) { name }\n       fk_anon(_) | fk_fn_block { \"anon\" }\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n-      fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps) { tps }\n+      fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps)\n+          | fk_ctor(_, tps) { tps }\n       fk_anon(_) | fk_fn_block { [] }\n     }\n }\n@@ -138,8 +141,9 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n           for m in members {\n              v.visit_class_item(m.span, m.node.privacy, m.node.decl, e, v);\n           }\n-          visit_fn_decl(ctor.node.dec, e, v);\n-          v.visit_block(ctor.node.body, e, v);\n+          // make up a fake fn so as to call visit_fn on the ctor\n+          v.visit_fn(fk_ctor(i.ident, tps), ctor.node.dec,\n+                     ctor.node.body, ctor.span, ctor.node.id, e, v);\n       }\n       item_iface(tps, methods) {\n         v.visit_ty_params(tps, e, v);"}, {"sha": "79daecfe35e97985c0f9cf07c86115d83bff03e9", "filename": "src/test/run-pass/class-methods.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=8bbd78075f1b0dfe271ac68d9c0f7f2f12eeda90", "patch": "@@ -1,4 +1,3 @@\n-// xfail-test\n class cat {\n   priv {\n     let mutable meows : uint;"}]}