{"sha": "30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYzQwNzBlM2Q1YmRmYTVkZGJiNDFlM2UyZDE1OTA1NjdjYmEzZDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-11T21:54:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-11T21:54:43Z"}, "message": "Add a boot/README file explaining rustboot's organization a bit.", "tree": {"sha": "5ccb09686c416a38ed2344c65f4b6db8c7b1a25b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ccb09686c416a38ed2344c65f4b6db8c7b1a25b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "html_url": "https://github.com/rust-lang/rust/commit/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eafd280f81a668f9b8b0a7f0eda4c3237e6b70a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eafd280f81a668f9b8b0a7f0eda4c3237e6b70a", "html_url": "https://github.com/rust-lang/rust/commit/2eafd280f81a668f9b8b0a7f0eda4c3237e6b70a"}], "stats": {"total": 408, "additions": 407, "deletions": 1}, "files": [{"sha": "67adda2d5b7712c0e8757bebf8399cbe01745d14", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "patch": "@@ -728,7 +728,7 @@ PKG_3RDPARTY := rt/valgrind.h rt/memcheck.h \\\n                 rt/uthash/uthash.h rt/uthash/utlist.h \\\n                 rt/bigint/bigint.h rt/bigint/bigint_int.cpp \\\n                 rt/bigint/bigint_ext.cpp rt/bigint/low_primes.h\n-PKG_FILES := README \\\n+PKG_FILES := README boot/README \\\n              $(wildcard etc/*.*) \\\n              $(MKFILES) $(BOOT_MLS) boot/fe/lexer.mll \\\n              $(COMPILER_INPUTS) \\"}, {"sha": "4d1b431ae8a18718ee1d421f709b804cb49e949f", "filename": "src/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME?ref=30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "patch": "@@ -3,6 +3,7 @@ This is preliminary version of the Rust compiler.\n Source layout:\n \n boot/              The bootstrap compiler\n+boot/README        - More-detailed guide to it.\n boot/fe            - Front end (lexer, parser, AST)\n boot/me            - Middle end (resolve, check, layout, trans)\n boot/be            - Back end (IL, RA, insns, asm, objfiles)"}, {"sha": "30c1f0e99a60394e7e1539856c2c5cdabca321ae", "filename": "src/boot/README", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2Fboot%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8/src%2Fboot%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2FREADME?ref=30c4070e3d5bdfa5ddbb41e3e2d1590567cba3d8", "patch": "@@ -0,0 +1,405 @@\n+An informal guide to reading and working on the rustboot compiler.\n+==================================================================\n+\n+First off, my sincerest apologies for the lightly-commented nature of the\n+compiler, as well as the general immaturity of the codebase; rustboot is\n+intended to be discarded in the near future as we transition off it, to a\n+rust-based, LLVM-backed compiler. It has taken longer than expected for \"the\n+near future\" to arrive, and here we are published and attracting contributors\n+without a good place for them to start. It will be a priority for the next\n+little while to make new contributors feel welcome and oriented within the\n+project; best I can do at this point. We were in a tremendous rush even to get\n+everything organized to this minimal point.\n+\n+If you wish to expand on this document, or have one of the\n+slightly-more-familiar authors add anything else to it, please get in touch or\n+file a bug. Your concerns are probably the same as someone else's.\n+\n+\n+\n+High-level concepts, invariants, 30,000-ft view\n+===============================================\n+\n+Rustboot has 3 main subdirectories: fe, me, and be (front, mid, back\n+end). Helper modules and ubiquitous types are found in util/.\n+\n+The entry-point for the compiler is driver/main.ml, and this file sequences\n+the various parts together.\n+\n+\n+The 4 central data structures:\n+------------------------------\n+\n+#1: fe/ast.ml defines the AST. The AST is treated as immutable after parsing\n+    despite containing some mutable types (hashtbl and such). Many -- though\n+    not all -- nodes within this data structure are wrapped in the type 'a\n+    identified. This is important. An \"identified\" AST node is one that the\n+    parser has marked with a unique node_id value. This node_id is used both\n+    to denote a source location and, more importantly, to key into a large\n+    number of tables later in the compiler. Most additional calculated\n+    properties of a program that the compiler derives are keyed to the node_id\n+    of an identified node.\n+\n+    The types 'a identified, node_id and such are in util/common.ml\n+\n+\n+#2: me/semant.ml defines the Semant.ctxt structure. This is a record of\n+    tables, almost all of which are keyed by node_id. See previous comment\n+    regrding node_id. The Semant module is open in most of the modules within\n+    the me/ directory, and they all refer liberally to the ctxt tables, either\n+    directly or via helper functions in semant. Semant also defines the\n+    mid-end pass-management logic, lookup routines, type folds, and a variety\n+    of other miscallaneous semantic-analysis helpers.\n+\n+\n+#3: be/il.ml defines the IL. This is a small, typed IL based on a type system\n+    that is relatively LLVM-ish, and a control-flow system that is *not*\n+    expression/SSA based like LLVM. It's much dumber than that. The root of\n+    the interesting types in this file is the type 'emitter', which is a\n+    growable buffer along with a few counters.  An emitter is essentially a\n+    buffer of quads. A quad, in turn, is a primitive virtual instruction\n+    ('quad' because it is in its limit a 3-address machine, plus opcode) which\n+    we then ... tend to turn directly into x86 anyways. Sorry; it wasn't clear\n+    during initial construction that we'd wind up stopping at x86, so the IL\n+    is probably superfluous, but there it is.\n+\n+    The IL types are operand = cell | immediate, and cell = reg | mem. Plus a\n+    certain quantity of special-casing and noise for constant-pointer\n+    propagation and addressing modes and whatnot.\n+\n+\n+#4: be/asm.ml defines the Asm.frag type, which is a \"chunk of binary-ish\n+    stuff\" to put in an output file. Words, bytes, lazily-resolved fixups,\n+    constant expressions, 0-terminated strings, alignment boundaries, etc. You\n+    will hopefully not need to produce a lot of this yourself; most of this is\n+    already being emitted.\n+\n+    An important type that gets resolved here is fixup, from util/common.ml.\n+    Fixups are things you can wrap around a frag using an Asm.DEF frag, which\n+    get their size and position (both in-file and in-memory) calculated at\n+    asm-time; but you can refer to them before they're resolved. So any time\n+    the compiler needs to refer to \"the place / size this thingy will be, when\n+    it finally gets boiled down to frags and emitted\" we generate a fixup and\n+    use that. Functions and static data structures, for example, tend to get\n+    fixups assigned to them early on in the middle-end of the compiler.\n+\n+\n+Control and information flow within the compiler:\n+-------------------------------------------------\n+\n+- driver/main.ml assumes control on startup. Options are parsed, platform is\n+  detected, etc.\n+\n+\n+- fe/lexer.ml does lexing in any case; fe/parser.ml holds the fundamental\n+  parser-state and parser-combinator functions. Parsing rules are split\n+  between 3 files: fe/cexp.ml, fe/pexp.ml, and fe/item.ml. This split\n+  represents the general structure of the grammar(s):\n+\n+    - The outermost grammar is called \"cexp\" (crate expression), and is an\n+      expression language that describes the crate directives found in crate\n+      files. It's evaluated inside the compiler.\n+\n+    - The next grammar is \"item\", which is a statement language that describes\n+      the directives, declarations and statements found in source files. If\n+      you compile a naked source file, you jump straight to item and then\n+      synthesize a simple crate structure around the result.\n+\n+    - The innermost grammar is \"pexp\" (parsed expression), and is an\n+      expression language used for the shared expression grammar within both\n+      cexp and item. Pexps within cexp are evaluated in the compiler\n+      (non-constant, complex cexps are errors) whereas pexps within items are\n+      desugared to statements and primitive expressions.\n+\n+    - The AST is the output from the item grammar. Pexp and cexp do not escape\n+      the front-end.\n+\n+\n+- driver/main.ml then builds a Semant.ctxt and threads it through the various\n+  middle-end passes. Each pass defines one or more visitors, which is an FRU\n+  copy of the empty_visitor in me/walk.ml. Each visitor performs a particular\n+  task, encapsulates some local state in local variables, and leaves its\n+  results in a table. If the table it's calculating is pass-local, it will be\n+  a local binding within the pass; if it's to be shared with later passes, it\n+  will be a table in Semant.ctxt. Pass order is therefore somewhat important,\n+  so I'll describe it here:\n+\n+    - me/resolve.ml looks up names and connects them to definitions. This\n+      includes expanding all types (as types can occur within names, as part\n+      of a parametric name) and performing all import/export/visibility\n+      judgments. After resolve, we should not be doing any further name-based\n+      lookups (with one exception: typestate does some more name\n+      lookup. Subtle reason, will return to it).\n+\n+      Resolve populates several of the tables near the top of Semant.ctxt:\n+\n+          ctxt_all_cast_types\n+          ctxt_all_defns\n+          ctxt_all_item_names\n+          ctxt_all_item_types\n+          ctxt_all_lvals\n+          ctxt_all_stmts\n+          ctxt_all_type_items\n+          ctxt_block_items\n+          ctxt_block_slots\n+          ctxt_frame_args\n+          ctxt_lval_to_referent\n+          ctxt_node_referenced\n+          ctxt_required_items\n+          ctxt_slot_is_arg\n+          ctxt_slot_keys\n+\n+      The most obviously critical of these are lval_to_referent and all_defns,\n+      which connect subsequent visitors from a reference node to its referent\n+      node, and catalogue all the possible things a referent may be.\n+\n+      Part of resolving that is perhaps not obvious is the task of resolving\n+      and normalizing recursive types. This is what TY_iso is for. Recursive\n+      types in rust have to pass through a tag type on their recursive edge;\n+      TY_iso is an iso-recursive group of tags that refer only to one another;\n+      within a TY_iso, the type term \"TY_idx n\" refers to \"the nth member of\n+      the current TY_iso\". Resolve is responsible for finding such groups and\n+      tying them into such closed-form knots.\n+\n+      TY_name should be completely eliminated in any of the types exiting\n+      resolve.\n+\n+\n+    - me/type.ml is a unification-based typechecker and inference engine. This\n+      is as textbook-y as we could make it. It rewrites \"auto\" slots in the\n+      ctxt_all_defns table when it completes (these are the slots with None as\n+      their Ast.slot_ty).\n+\n+      This file is organized around tyspecs and tyvars.  A tyspec is a\n+      constraint on an unknown type that is implied by its use; tyspecs are\n+      generated during the AST-walk, placed in ref cells (tyvars), and the\n+      cells are and unified with one another. If two tyvars unify, then a new\n+      constraint is created with the tighter of the two and the two previous\n+      tyvars are updated to point to the unified spec. Ideally all constraints\n+      eventually run into a source of a concrete type (or a type otherwise\n+      uniquely-determined by its tyspecs). If not, the type is underdetermined\n+      and we get a type error. Similarly if two tyvars that are supposed to\n+      unify clash in some way (integer unify-with string, say) then there is\n+      also a type error.\n+\n+\n+    - me/typestate.ml is a dataflow-based typestate checker. It is responsible\n+      for ensuring all preconditions are met, including init-before-use. It\n+      also determines slot lifecycle boundaries, and populates the context\n+      tables:\n+\n+          ctxt_constr_ids\n+          ctxt_constrs\n+          ctxt_copy_stmt_is_init\n+          ctxt_post_stmt_slot_drops\n+          ctxt_postconditions\n+          ctxt_poststates\n+          ctxt_preconditions\n+          ctxt_prestates\n+\n+      It is organized around constr_keys, a bunch of bitsets, and a CFG.\n+\n+      A constr_key is a normalized value representing a single constraint that\n+      we wish to be able to refer to within a typestate. Every constr_key gets\n+      a bit number assigned to it. A condition (and a typestate) is a\n+      bit-vector, in which the set bits indicate the constr_keys (indexed by\n+      associatd number) that hold in the condition/typestate.\n+\n+      There are 4 such bitsets generated for each node in the CFG:\n+      precondition/postcondition and prestate/poststate. The visitors here\n+      figure out all the constr_keys we'll need, then assign all the pre/post\n+      conditions, generate the CFG, calculate the typestates from the CFG, and\n+      check that every typestate satisfies its precondition.\n+\n+      (Due to the peculiarity that types are pure terms and are not 'a\n+      identified in our AST, we have to do some name-lookup in here as well\n+      when normalizing the const_keys).\n+\n+\n+    - Effect is relatively simple: it calculates the effect of each type and\n+      item, and checks that they either match their declarations or are\n+      authorized to be lying.\n+\n+\n+    - Loop is even simpler: it calculates loop-depth information for later use\n+      generating foreach loops. It populates the context tables:\n+\n+          ctxt_block_is_loop_body\n+          ctxt_slot_loop_depths\n+          ctxt_stmt_loop_depths\n+\n+\n+    - Alias checks slot-aliasing to ensure none of the rules are broken about\n+      simultaneous aliases and such. It also populates the table\n+      ctxt_slot_is_aliased.\n+\n+\n+    - Layout determines the layout of frames, arguments, objects, closures and\n+      such. This includes deciding which slot should go in a vreg and\n+      generating fixups for all frame-spill regions. It populates the context\n+      tables:\n+\n+          ctxt_block_is_loop_body\n+          ctxt_call_sizes\n+          ctxt_frame_blocks\n+          ctxt_frame_sizes\n+          ctxt_slot_is_obj_state\n+          ctxt_slot_offsets\n+          ctxt_slot_vregs\n+          ctxt_spill_fixups\n+\n+      There is a useful chunk of ASCII-art in the leading comment of layout,\n+      if you want to see how a frame goes together, I recommend reading it.\n+\n+\n+    - Trans is the big one. This is the \"translate AST to IL\" pass, and it's a\n+      bit of a dumping ground, sadly. Probably 4x the size of any other\n+      pass. Stuff that is common to the x86 and LLVM backends is factored out\n+      into transutil.ml, but it hardly helps. Suggestions welcome for\n+      splitting it further.\n+\n+      Trans works *imperatively*. It maintains a stack of emitters, one per\n+      function (or helper-function) and emits Il.quads into the top-of-stack\n+      emitter into while it walks the statements of each function. If at any\n+      point it needs to pause to emit a helper function (\"glue function\") it\n+      pushes a new emitter onto the stack and emits into that.\n+\n+      Trans populates the context tables:\n+\n+          ctxt_all_item_code\n+          ctxt_block_fixups\n+          ctxt_data\n+          ctxt_file_code\n+          ctxt_file_fixups\n+          ctxt_fn_fixups\n+          ctxt_glue_code\n+\n+      The entries in the tables ending in _code are of type Semant.code, which\n+      is an abstract type covering both function and glue-function code; each\n+      holds an executable block of quads, plus an aggregate count of vregs and\n+      a reference to the spill fixup for that code.\n+\n+\n+- Once it completes trans, driver/main.ml does the \"finishing touches\":\n+  register allocates each emitted code value (be/ra.ml), emits dwarf for the\n+  crate (me/dwarf.ml), selects instructions (be/x86.ml), then selects one of\n+  the object-file backends (be/elf.ml, be/macho.ml or be/pe.ml) and emits the\n+  selected Asm.frag to it. Hopefully little of this will require further work;\n+  the most incomplete module here is probably dwarf.ml but the remainder are\n+  mostly stable and don't tend to change much, aside from picking bugs out of\n+  them.\n+\n+\n+\n+Details and curiosities to note along the way:\n+==============================================\n+\n+- Where you might expect there to be a general recursive expression type for\n+  'expr', you'll find only a very limited non-recursive 3-way switch: binary,\n+  unary, or atom; where atom is either a literal or an lval. This is because\n+  all the \"big\" expressions (pexps) were boiled off during the desugaring\n+  phase in the frontend.\n+\n+\n+- There are multiple ways to refer to a path. Names, lvals and cargs all\n+  appear to have similar structure (and do). They're all subsets of the\n+  general path grammar, so all follow the rough shape of being either a base\n+  anchor-path or an ext (extension) path with structural recursion to the\n+  left.\n+\n+  Cargs (constraint arguments) are the sort of paths that can be passed to\n+  constraints in the typestate system, and can contain the special symbol \"*\"\n+  in the grammar, meaning \"thing I am attached to\".  This is the symbol\n+  BASE_formal in the carg_base type.\n+\n+  Names are the sort of paths that refer to types or other items. Not slots.\n+\n+  Lvals are the sort of paths that *might* refer to slots, but we don't\n+  generally know. So they can contain the dynamic-indexing component\n+  COMP_atom. For example, x.(1 + 2).y is an lval.\n+\n+\n+- Only one of these forms is 'a identified: an lval. And moreover, only the\n+  lval *base* is identified; the remainder of the path has to be projected\n+  forward through the referent after lookup. This also means that when you\n+  lookup anything else by name, you have to be using the result immediately,\n+  not storing it in a table for later.\n+\n+\n+- Types are not 'a identified. This means that you (generally) cannot refer to\n+  a *particular* occurrence of a type in the AST and associate information\n+  with it. Instead, we treat types as \"pure terms\" (not carrying identity) and\n+  calculate properties of them on the fly. For this we use a general fold\n+  defined in me/semant.ml, the family of functions held in a ty_fold\n+  structure, and passed to fold_ty.\n+\n+\n+- There is a possibly-surprising type called \"size\" in util/common. This is a\n+  type representing a \"size expression\" that may depend on runtime\n+  information, such as the type descriptors passed to a frame at runtime. This\n+  exists because our type-parameterization scheme is, at the moment,\n+  implemented by passing type descriptors around at runtime, not\n+  code-expansion a la C++ templates. So any time we have a translated indexing\n+  operation or such that depends on a type parameter, we wind up with a size\n+  expression including SIZE_param_size or SIZE_param_align, and have to do\n+  size arithmetic at runtime. Upstream of trans, we generate sizes willy-nilly\n+  and then decide in trans, x86, and dwarf whether they can be emitted\n+  statically or via runtime calculation at the point of use.\n+\n+\n+- Trans generates position-independent code (PIC). This means that it never\n+  refers to the exact position of a fixup in memory at load-time, always the\n+  distance-to-a-fixup from some other fixup, and/or current PC. On x86 this\n+  means we wind up copying the \"get next pc thunk\" trick used on linux\n+  systems, and/or storing \"crate relative\" addresses. The runtime and compiler\n+  \"know\" (unfortunately sometimes quite obscurely) that an immediate pointer\n+  should be encoded as relative-to a given displacement base, and work with\n+  those as necessary.  Similarly, they emit code to reify pointer immediates\n+  (add the displacements to displacement-bases) before handing them off to\n+  (say) C library functions that expect \"real\" pointers. This is all somewhat\n+  messy.\n+\n+\n+- There is one central static data structure, \"rust_crate\", which is emitted\n+  into the final loadable object and contains pointers to all subsequent\n+  information the runtime may be interested in. It also serves as the\n+  displacement base for a variety of PIC-ish displacements stored\n+  elsewhere. When the runtime loads a crate, it dlsym()s rust_crate, and then\n+  digs around in there. It's the entry-point for crawling the crate's\n+  structure from outside. Importantly: it also contains pointers to the dwarf.\n+\n+\n+- Currently we drive linking off dwarf. That is: when a crate needs to 'use'\n+  an item from another dwarf crate, we dlopen / LoadLibrary and find the\n+  \"rust_crate\" value, follow its pointers to dwarf tables, and scan around the\n+  dwarf DIE tree resolving the hierarchical name of the used item. This may\n+  change, we decided to recycle dwarf for this purpose early in the language\n+  evolution and may, given the number of simplifications that have occurred\n+  along the way, be able to fall back to C \"mangled name\" linkage at some\n+  point. Though that decision carries a number of serious constraints, and\n+  should not be taken lightly.\n+\n+\n+\n+Probably-bad ideas we will want to do differently in the self-hosted compiler:\n+==============================================================================\n+\n+- We desugar too early in rustboot and should preserve the pexp structure\n+  until later. Dherman is likely to argue for movement to a more\n+  expression-focused grammar. This may well happen.\n+\n+- Multiple kinds of paths enforced by numerous nearly-isomorphic ML type\n+  constructors is pointless once we're in rust; we can just make type\n+  abbreviations that carry constraints like path : is_name(*) or such.\n+\n+- Storing auxiliary information in semant tables is awkward, and we should\n+  figure out a suitably rusty idiom for decorating AST nodes in-place.\n+  Inter-pass dependencies should be managed by augmenting the AST with\n+  ever-more constraints (is_resolved(ast), is_typechecked(ast), etc.)\n+\n+- Trans should be organized as pure and value-producing code, not imperatively\n+  emitting quads into emitters. LLVM will enforce this anwyays. See what\n+  happened in lltrans.ml if you're curious what it'll look (more) like.\n+\n+- The PIC scheme will have to change, hopefully get much easier.\n+"}]}