{"sha": "40a6b8c339376b7879016d5d2a015b6ac43c4c0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYTZiOGMzMzkzNzZiNzg3OTAxNmQ1ZDJhMDE1YjZhYzQzYzRjMGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-04T17:37:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-04T17:37:55Z"}, "message": "explain our rwlock implementation (and fix a potential data race)", "tree": {"sha": "b3c9e8cd48e4ea8ace8dcbd2855452de84040554", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3c9e8cd48e4ea8ace8dcbd2855452de84040554"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40a6b8c339376b7879016d5d2a015b6ac43c4c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40a6b8c339376b7879016d5d2a015b6ac43c4c0c", "html_url": "https://github.com/rust-lang/rust/commit/40a6b8c339376b7879016d5d2a015b6ac43c4c0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40a6b8c339376b7879016d5d2a015b6ac43c4c0c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fdd3e2bee1ea0f517ff0bfe16f3816decab99a", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fdd3e2bee1ea0f517ff0bfe16f3816decab99a", "html_url": "https://github.com/rust-lang/rust/commit/61fdd3e2bee1ea0f517ff0bfe16f3816decab99a"}], "stats": {"total": 44, "additions": 24, "deletions": 20}, "files": [{"sha": "3e3a01b4ea395638cc1a194c78df51c11cf9c99c", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/40a6b8c339376b7879016d5d2a015b6ac43c4c0c/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a6b8c339376b7879016d5d2a015b6ac43c4c0c/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=40a6b8c339376b7879016d5d2a015b6ac43c4c0c", "patch": "@@ -22,27 +22,26 @@ impl RWLock {\n     pub unsafe fn read(&self) {\n         let r = libc::pthread_rwlock_rdlock(self.inner.get());\n \n-        // According to the pthread_rwlock_rdlock spec, this function **may**\n-        // fail with EDEADLK if a deadlock is detected. On the other hand\n-        // pthread mutexes will *never* return EDEADLK if they are initialized\n-        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n-        // situation may actually return from the call to pthread_rwlock_rdlock\n-        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n-        // that not all unix implementations, however, will return EDEADLK for\n-        // their rwlocks.\n+        // According to POSIX, when a thread tries to acquire this read lock\n+        // while it already holds the write lock\n+        // (or vice versa, or tries to acquire the write lock twice),\n+        // \"the call shall either deadlock or return [EDEADLK]\"\n+        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html,\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html).\n+        // So, in principle, all we have to do here is check `r == 0` to be sure we properly\n+        // got the lock.\n         //\n-        // We roughly maintain the deadlocking behavior by panicking to ensure\n-        // that this lock acquisition does not succeed.\n-        //\n-        // We also check whether this lock is already write locked. This\n-        // is only possible if it was write locked by the current thread and\n-        // the implementation allows recursive locking. The POSIX standard\n-        // doesn't require recursively locking a rwlock to deadlock, but we can't\n-        // allow that because it could lead to aliasing issues.\n+        // However, (at least) glibc before version 2.25 does not conform to this spec,\n+        // and can return `r == 0` even when this thread already holds the write lock.\n+        // We thus check for this situation ourselves and panic when detecting that a thread\n+        // got the write lock more than once, or got a read and a write lock.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n         } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_rdlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n@@ -56,6 +55,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() {\n+                // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {\n@@ -69,18 +69,21 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // See comments above for why we check for EDEADLK and write_locked. We\n-        // also need to check that num_readers is 0.\n+        // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n+        // we also need to check that there are no readers (tracked in `num_readers`).\n         if r == libc::EDEADLK\n-            || *self.write_locked.get()\n+            || (r == 0 && *self.write_locked.get())\n             || self.num_readers.load(Ordering::Relaxed) != 0\n         {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_wrlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n-            debug_assert_eq!(r, 0);\n+            assert_eq!(r, 0);\n         }\n         *self.write_locked.get() = true;\n     }\n@@ -89,6 +92,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                // `pthread_rwlock_trywrlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {"}]}