{"sha": "a8daa7115e3f5f78dba547061cd4fe6a2f716c0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZGFhNzExNWUzZjVmNzhkYmE1NDcwNjFjZDRmZTZhMmY3MTZjMGU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-27T15:27:05Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "Group by stack slot earlier", "tree": {"sha": "ec16e5ed2fb6c81940b7a5768e906ee3342e57fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec16e5ed2fb6c81940b7a5768e906ee3342e57fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e", "html_url": "https://github.com/rust-lang/rust/commit/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d77cb95e164addcf924f65b0c80465c5cebe776", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d77cb95e164addcf924f65b0c80465c5cebe776", "html_url": "https://github.com/rust-lang/rust/commit/9d77cb95e164addcf924f65b0c80465c5cebe776"}], "stats": {"total": 149, "additions": 42, "deletions": 107}, "files": [{"sha": "34f75e7da00dcb52720c302ea2713ccf2a058875", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 42, "deletions": 107, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8daa7115e3f5f78dba547061cd4fe6a2f716c0e/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=a8daa7115e3f5f78dba547061cd4fe6a2f716c0e", "patch": "@@ -1,4 +1,5 @@\n use std::collections::{BTreeMap, BTreeSet, HashSet};\n+use std::ops::Not;\n \n use cranelift_codegen::cursor::{Cursor, FuncCursor};\n use cranelift_codegen::ir::{Opcode, InstructionData, ValueDef};\n@@ -22,6 +23,13 @@ impl Ord for OrdStackSlot {\n     }\n }\n \n+#[derive(Debug, Default)]\n+struct StackSlotUsage {\n+    stack_addr: HashSet<Inst>,\n+    stack_load: HashSet<Inst>,\n+    stack_store: HashSet<Inst>,\n+}\n+\n pub(super) fn optimize_function(\n     func: &mut Function,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n@@ -31,36 +39,34 @@ pub(super) fn optimize_function(\n \n     // Record all stack_addr, stack_load and stack_store instructions. Also record all stack_addr\n     // and stack_load insts whose result is used.\n-    let mut stack_addr_load_insts_users = BTreeMap::<Inst, HashSet<Inst>>::new();\n-    let mut stack_addr_insts = BTreeSet::new();\n-    let mut stack_load_insts = BTreeSet::new();\n-    let mut stack_store_insts = BTreeSet::new();\n+    let mut stack_addr_load_insts_users = HashMap::<Inst, HashSet<Inst>>::new();\n+    let mut stack_slot_usage_map = BTreeMap::<OrdStackSlot, StackSlotUsage>::new();\n \n     let mut cursor = FuncCursor::new(func);\n     while let Some(_ebb) = cursor.next_ebb() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n                 InstructionData::StackLoad {\n                     opcode: Opcode::StackAddr,\n-                    stack_slot: _,\n+                    stack_slot,\n                     offset: _,\n                 } => {\n-                    stack_addr_insts.insert(inst);\n+                    stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_addr.insert(inst);\n                 }\n                 InstructionData::StackLoad {\n                     opcode: Opcode::StackLoad,\n-                    stack_slot: _,\n+                    stack_slot,\n                     offset: _,\n                 } => {\n-                    stack_load_insts.insert(inst);\n+                    stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_load.insert(inst);\n                 }\n                 InstructionData::StackStore {\n                     opcode: Opcode::StackStore,\n                     arg: _,\n-                    stack_slot: _,\n+                    stack_slot,\n                     offset: _,\n                 } => {\n-                    stack_store_insts.insert(inst);\n+                    stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_store.insert(inst);\n                 }\n                 _ => {}\n             }\n@@ -79,125 +85,54 @@ pub(super) fn optimize_function(\n     }\n \n     println!(\n-        \"{}:\\nstack_addr/stack_load users: {:?}\\nstack_addr: {:?}\\nstack_load: {:?}\\nstack_store: {:?}\",\n+        \"{}:\\nstack_addr/stack_load users: {:?}\\nstack slot usage: {:?}\",\n         name,\n         stack_addr_load_insts_users,\n-        stack_addr_insts,\n-        stack_load_insts,\n-        stack_store_insts,\n+        stack_slot_usage_map,\n     );\n \n     for inst in stack_addr_load_insts_users.keys() {\n-        assert!(stack_addr_insts.contains(inst) || stack_load_insts.contains(inst));\n-    }\n-\n-    // Replace all unused stack_addr instructions with nop.\n-    // FIXME remove clone\n-    for &inst in stack_addr_insts.clone().iter() {\n-        if stack_addr_load_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n-            println!(\"Removing unused stack_addr {}\", inst);\n-            func.dfg.detach_results(inst);\n-            func.dfg.replace(inst).nop();\n-            stack_addr_insts.remove(&inst);\n-        }\n-    }\n-\n-    // Replace all unused stack_load instructions with nop.\n-    // FIXME remove clone\n-    for &inst in stack_load_insts.clone().iter() {\n-        if stack_addr_load_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n-            println!(\"Removing unused stack_load {}\", inst);\n-            func.dfg.detach_results(inst);\n-            func.dfg.replace(inst).nop();\n-            stack_load_insts.remove(&inst);\n+        let mut is_recorded_stack_addr_or_stack_load = false;\n+        for stack_slot_users in stack_slot_usage_map.values() {\n+            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst) || stack_slot_users.stack_load.contains(inst);\n         }\n+        assert!(is_recorded_stack_addr_or_stack_load);\n     }\n \n-\n-    //println!(\"stack_addr (after): [{}]\", bool_secondary_map_to_string(&stack_addr_insts));\n-\n-    let mut stack_slot_usage_map: BTreeMap<OrdStackSlot, HashSet<Inst>> = BTreeMap::new();\n-    for &inst in stack_load_insts.iter() {\n-        match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackLoad,\n-                stack_slot,\n-                offset: _,\n-            } => {\n-                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n-            }\n-            ref data => unreachable!(\"{:?}\", data),\n-        }\n-    }\n-    for &inst in stack_store_insts.iter() {\n-        match func.dfg[inst] {\n-            InstructionData::StackStore {\n-                opcode: Opcode::StackStore,\n-                arg: _,\n-                stack_slot,\n-                offset: _,\n-            } => {\n-                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n+    // Replace all unused stack_addr and stack_load instructions with nop.\n+    for stack_slot_users in stack_slot_usage_map.values_mut() {\n+        // FIXME remove clone\n+        for &inst in stack_slot_users.stack_addr.clone().iter() {\n+            if stack_addr_load_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n+                println!(\"Removing unused stack_addr {}\", inst);\n+                func.dfg.detach_results(inst);\n+                func.dfg.replace(inst).nop();\n+                stack_slot_users.stack_addr.remove(&inst);\n             }\n-            ref data => unreachable!(\"{:?}\", data),\n         }\n-    }\n-    for &inst in stack_addr_insts.iter() {\n-        match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackAddr,\n-                stack_slot,\n-                offset: _,\n-            } => {\n-                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n+\n+        for &inst in stack_slot_users.stack_load.clone().iter() {\n+            if stack_addr_load_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n+                println!(\"Removing unused stack_addr {}\", inst);\n+                func.dfg.detach_results(inst);\n+                func.dfg.replace(inst).nop();\n+                stack_slot_users.stack_load.remove(&inst);\n             }\n-            ref data => unreachable!(\"{:?}\", data),\n         }\n     }\n \n-    println!(\"stack slot usage: {:?}\", stack_slot_usage_map);\n+    println!(\"stack slot usage (after): {:?}\", stack_slot_usage_map);\n \n     for (stack_slot, users) in stack_slot_usage_map.iter_mut() {\n-        let mut is_addr_leaked = false;\n-        let mut is_loaded = false;\n-        let mut is_stored = false;\n-        for &user in users.iter() {\n-            match func.dfg[user] {\n-                InstructionData::StackLoad {\n-                    opcode: Opcode::StackAddr,\n-                    stack_slot,\n-                    offset: _,\n-                } => {\n-                    is_addr_leaked = true;\n-                }\n-                InstructionData::StackLoad {\n-                    opcode: Opcode::StackLoad,\n-                    stack_slot,\n-                    offset: _,\n-                } => {\n-                    is_loaded = true;\n-                }\n-                InstructionData::StackStore {\n-                    opcode: Opcode::StackStore,\n-                    arg: _,\n-                    stack_slot,\n-                    offset: _,\n-                } => {\n-                    is_stored = true;\n-                }\n-                ref data => unreachable!(\"{:?}\", data),\n-            }\n-        }\n-\n-        if is_addr_leaked || (is_loaded && is_stored) {\n+        if users.stack_addr.is_empty().not() || (users.stack_load.is_empty().not() && users.stack_store.is_empty().not()) {\n             continue;\n         }\n \n-        if is_loaded {\n+        if users.stack_load.is_empty().not() {\n             println!(\"[{}] [BUG?] Reading uninitialized memory\", name);\n         } else {\n             // Stored value never read; just remove reads.\n-            for &user in users.iter() {\n+            for user in users.stack_store.drain() {\n                 println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot.0);\n                 func.dfg.replace(user).nop();\n             }"}]}