{"sha": "051f24da25a485f9702590f9c7f5095ebd0fbb58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MWYyNGRhMjVhNDg1Zjk3MDI1OTBmOWM3ZjUwOTVlYmQwZmJiNTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-06T03:59:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-06T04:16:28Z"}, "message": "add static region and also fix regions to be contravariant", "tree": {"sha": "6c19e8bf10758325bd92e9798ea933827fb55d64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c19e8bf10758325bd92e9798ea933827fb55d64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/051f24da25a485f9702590f9c7f5095ebd0fbb58", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/051f24da25a485f9702590f9c7f5095ebd0fbb58", "html_url": "https://github.com/rust-lang/rust/commit/051f24da25a485f9702590f9c7f5095ebd0fbb58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/051f24da25a485f9702590f9c7f5095ebd0fbb58/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1afb0b3e226164f551f3e2fc1270c6dba007281", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1afb0b3e226164f551f3e2fc1270c6dba007281", "html_url": "https://github.com/rust-lang/rust/commit/f1afb0b3e226164f551f3e2fc1270c6dba007281"}], "stats": {"total": 218, "additions": 146, "deletions": 72}, "files": [{"sha": "67988e807c160c22b1976db542d692760aa376e5", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -442,7 +442,8 @@ type region = {id: node_id, node: region_};\n enum region_ {\n     re_inferred,\n     re_named(ident),\n-    re_self\n+    re_self,\n+    re_static\n }\n \n #[auto_serialize]"}, {"sha": "759ac1a3a9597a848762c7c94ed6794dd08c599f", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -434,6 +434,8 @@ fn parse_region(p: parser) -> ast::region {\n             p.bump(); p.bump();\n             if string == \"self\" {\n                 ast::re_self\n+            } else if string == \"static\" {\n+                ast::re_static\n             } else {\n                 ast::re_named(string)\n             }"}, {"sha": "58fd96bbb2ed3f81fc845f0ee0c6499e33e900b9", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -322,6 +322,7 @@ fn print_region(s: ps, region: ast::region) {\n       ast::re_inferred { /* no-op */ }\n       ast::re_named(name) { word(s.s, name); word(s.s, \".\"); }\n       ast::re_self { word(s.s, \"self\"); word(s.s, \".\"); }\n+      ast::re_static { word(s.s, \"static\"); word(s.s, \".\"); }\n     }\n }\n "}, {"sha": "33f420ba24576fb073841615a9ba328697145888", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -140,6 +140,9 @@ fn enc_region(w: io::writer, r: ty::region) {\n         w.write_uint(id.to_uint());\n         w.write_char('|');\n       }\n+      ty::re_static {\n+        w.write_char('t');\n+      }\n     }\n }\n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {"}, {"sha": "fd8700042c64360aee212b94ebe4fee867fe9afa", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 98, "deletions": 69, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -9,6 +9,7 @@ import util::ppaux::{ty_to_str, mt_to_str};\n import result::{result, extensions, ok, err, map, map2, iter2};\n import ty::type_is_bot;\n import driver::session::session;\n+import util::common::{indent, indenter};\n \n export infer_ctxt;\n export new_infer_ctxt;\n@@ -66,25 +67,31 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n }\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\">> mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    cx.commit {||\n-        cx.tys(a, b)\n+    #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    indent {||\n+        cx.commit {||\n+            cx.tys(a, b)\n+        }\n     }\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\">> mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    cx.commit {||\n-        cx.eq_tys(a, b)\n+    #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    indent {||\n+        cx.commit {||\n+            cx.eq_tys(a, b)\n+        }\n     }\n }\n \n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n-    #debug[\">> compare_tys(%s == %s)\", a.to_str(infcx), b.to_str(infcx)];\n-    infcx.commit {||\n-        mk_subty(infcx, a, b).then {||\n-            mk_subty(infcx, b, a)\n+    #debug[\"compare_tys(%s == %s)\", a.to_str(infcx), b.to_str(infcx)];\n+    indent {||\n+        infcx.commit {||\n+            mk_subty(infcx, a, b).then {||\n+                mk_subty(infcx, b, a)\n+            }\n         }\n     }\n }\n@@ -226,24 +233,22 @@ impl unify_methods for infer_ctxt {\n         self.set(self.vb, vid, new_v);\n     }\n \n-    fn commit<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n+    fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         assert self.vb.bindings.len() == 0u;\n         assert self.rb.bindings.len() == 0u;\n \n-        let r = self.try(f);\n+        let r <- self.try(f);\n \n         // TODO---could use a vec::clear() that ran destructors but kept\n         // the vec at its currently allocated length\n         self.vb.bindings = [];\n         self.rb.bindings = [];\n \n-        #debug[\">> Commit result: %?\", r];\n-\n         ret r;\n     }\n \n-    fn try<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n+    fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         fn rollback_to<V:copy vid, T:copy>(\n             vb: vals_and_bindings<V, T>, len: uint) {\n@@ -257,7 +262,7 @@ impl unify_methods for infer_ctxt {\n         let vbl = self.vb.bindings.len();\n         let rbl = self.rb.bindings.len();\n         #debug[\"try(vbl=%u, rbl=%u)\", vbl, rbl];\n-        let r = f();\n+        let r <- f();\n         alt r {\n           result::ok(_) { #debug[\"try--ok\"]; }\n           result::err(_) {\n@@ -309,6 +314,9 @@ impl unify_methods for infer_ctxt {\n         a: bound<V>, b: bound<V>,\n         merge_op: fn(V,V) -> cres<V>) -> cres<bound<V>> {\n \n+        #debug[\"merge_bnd(%s,%s)\", a.to_str(self), b.to_str(self)];\n+        let _r = indenter();\n+\n         alt (a, b) {\n           (none, none) {\n             ok(none)\n@@ -332,6 +340,7 @@ impl unify_methods for infer_ctxt {\n         lub: fn(V,V) -> cres<V>,\n         glb: fn(V,V) -> cres<V>) -> cres<bounds<V>> {\n \n+        let _r = indenter();\n         self.merge_bnd(a.ub, b.ub, glb).chain {|ub|\n             #debug[\"glb of ubs %s and %s is %s\",\n                    a.ub.to_str(self), b.ub.to_str(self),\n@@ -383,6 +392,7 @@ impl unify_methods for infer_ctxt {\n         // them explicitly gives the type inferencer more\n         // information and helps to produce tighter bounds\n         // when necessary.\n+        indent {||\n         self.bnds(a.lb, b.ub).then {||\n         self.bnds(b.lb, a.ub).then {||\n         self.merge_bnd(a.ub, b.ub, {|x, y| x.glb(self, y)}).chain {|ub|\n@@ -395,10 +405,10 @@ impl unify_methods for infer_ctxt {\n             // the new bounds must themselves\n             // be relatable:\n             self.bnds(bnds.lb, bnds.ub).then {||\n-            self.set(vb, v_id, bounded(bnds));\n-            self.uok()\n+                self.set(vb, v_id, bounded(bnds));\n+                self.uok()\n             }\n-        }}}}\n+        }}}}}\n     }\n \n     fn vars<V:copy vid, T:copy to_str st>(\n@@ -465,46 +475,29 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> ures {\n-        alt (a, b) { // XXX\n-          (ty::re_var(a_id), ty::re_var(b_id)) {\n-            self.vars(self.rb, a_id, b_id)\n-          }\n-          (ty::re_var(a_id), _) {\n-            self.vart(self.rb, a_id, b)\n-          }\n-          (_, ty::re_var(b_id)) {\n-            self.tvar(self.rb, a, b_id)\n-          }\n-\n-          (ty::re_free(a_id, _), ty::re_scope(b_id)) |\n-          (ty::re_scope(a_id), ty::re_free(b_id, _)) |\n-          (ty::re_scope(a_id), ty::re_scope(b_id)) {\n-            let rm = self.tcx.region_map;\n-            alt region::nearest_common_ancestor(rm, a_id, b_id) {\n-              some(r_id) if r_id == a_id { self.uok() }\n-              _ { err(ty::terr_regions_differ(false, b, a)) }\n-            }\n-          }\n+        #debug[\"regions(%s <= %s)\", a.to_str(self), b.to_str(self)];\n+        indent {||\n+            alt (a, b) {\n+              (ty::re_var(a_id), ty::re_var(b_id)) {\n+                self.vars(self.rb, a_id, b_id)\n+              }\n+              (ty::re_var(a_id), _) {\n+                self.vart(self.rb, a_id, b)\n+              }\n+              (_, ty::re_var(b_id)) {\n+                self.tvar(self.rb, a, b_id)\n+              }\n \n-          // For these types, we cannot define any additional relationship:\n-          (ty::re_free(_, _), ty::re_free(_, _)) |\n-          (ty::re_bound(_), ty::re_bound(_)) |\n-          (ty::re_bound(_), ty::re_free(_, _)) |\n-          (ty::re_bound(_), ty::re_scope(_)) |\n-          (ty::re_free(_, _), ty::re_bound(_)) |\n-          (ty::re_scope(_), ty::re_bound(_)) {\n-            if a == b {\n-                self.uok()\n-            } else {\n-                err(ty::terr_regions_differ(false, b, a))\n+              _ {\n+                lub(self).c_regions(a, b).chain {|r|\n+                    if b == r {\n+                        self.uok()\n+                    } else {\n+                        err(ty::terr_regions_differ(false, b, a))\n+                    }\n+                }\n+              }\n             }\n-          }\n-\n-          (ty::re_default, _) |\n-          (_, ty::re_default) {\n-            // actually a compiler bug, I think.\n-            err(ty::terr_regions_differ(false, b, a))\n-          }\n         }\n     }\n \n@@ -657,16 +650,17 @@ impl unify_methods for infer_ctxt {\n         a: bound<T>, b: bound<T>) -> ures {\n \n         #debug(\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self));\n-\n-        alt (a, b) {\n-          (none, none) |\n-          (some(_), none) |\n-          (none, some(_)) {\n-            self.uok()\n-          }\n-          (some(t_a), some(t_b)) {\n-            t_a.st(self, t_b)\n-          }\n+        indent {||\n+            alt (a, b) {\n+              (none, none) |\n+              (some(_), none) |\n+              (none, some(_)) {\n+                self.uok()\n+              }\n+              (some(t_a), some(t_b)) {\n+                t_a.st(self, t_b)\n+              }\n+            }\n         }\n     }\n \n@@ -744,7 +738,9 @@ impl unify_methods for infer_ctxt {\n \n           (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n             self.mts(a_mt, b_mt).then {||\n-                self.regions(a_r, b_r)\n+                // Non-obvious: for &a.T to be a subtype of &b.T, &a\n+                // must exist for LONGER than &b.  That is, &b <= &a.\n+                self.regions(b_r, a_r)\n             }\n           }\n \n@@ -972,8 +968,11 @@ iface combine {\n \n     // Combining regions (along with some specific cases that are\n     // different for LUB/GLB):\n+    fn c_contraregions(\n+        a: ty::region, b: ty::region) -> cres<ty::region>;\n     fn c_regions(\n         a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn c_regions_static(r: ty::region) -> cres<ty::region>;\n     fn c_regions_scope_scope(\n         a: ty::region, a_id: ast::node_id,\n         b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n@@ -1045,11 +1044,13 @@ fn c_var_t<V:copy vid, C:combine, T:copy to_str st>(\n     alt self.bnd(a_bounds) {\n       some(a_bnd) {\n         // If a has an upper bound, return it.\n+        #debug[\"bnd=some(%s)\", a_bnd.to_str(self.infcx())];\n         ret c_ts(a_bnd, b);\n       }\n       none {\n         // If a does not have an upper bound, make b the upper bound of a\n         // and then return b.\n+        #debug[\"bnd=none\"];\n         let a_bounds = self.with_bnd(a_bounds, b);\n         self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n             self.infcx().set(vb, a_id, bounded(a_bounds));\n@@ -1162,6 +1163,7 @@ fn c_tys<C:combine>(\n     // Fast path.\n     if a == b { ret ok(a); }\n \n+    indent {||\n     alt (ty::get(a).struct, ty::get(b).struct) {\n       (ty::ty_bot, _) { self.c_bot(b) }\n       (_, ty::ty_bot) { self.c_bot(b) }\n@@ -1249,7 +1251,7 @@ fn c_tys<C:combine>(\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-        self.c_regions(a_r, b_r).chain {|r|\n+        self.c_contraregions(a_r, b_r).chain {|r|\n             self.c_mts(a_mt, b_mt).chain {|mt|\n                 ok(ty::mk_rptr(tcx, r, mt))\n             }\n@@ -1293,6 +1295,7 @@ fn c_tys<C:combine>(\n \n       _ { err(ty::terr_mismatch) }\n     }\n+    }\n }\n \n fn c_regions<C:combine>(\n@@ -1303,7 +1306,12 @@ fn c_regions<C:combine>(\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx())];\n \n+    indent {||\n     alt (a, b) {\n+      (ty::re_static, r) | (r, ty::re_static) {\n+        self.c_regions_static(r)\n+      }\n+\n       (ty::re_var(a_id), ty::re_var(b_id)) {\n         c_vars(self, self.infcx().rb,\n                a, a_id, b_id,\n@@ -1352,6 +1360,7 @@ fn c_regions<C:combine>(\n         err(ty::terr_regions_differ(false, b, a))\n       }\n     }\n+    }\n }\n \n impl of combine for lub {\n@@ -1443,6 +1452,16 @@ impl of combine for lub {\n         ret c_regions(self, a, b);\n     }\n \n+    fn c_contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        ret glb(self.infcx()).c_regions(a, b);\n+    }\n+\n+    fn c_regions_static(_r: ty::region) -> cres<ty::region> {\n+        // LUB of `r` and static is always static---what's bigger than\n+        // that?\n+        ret ok(ty::re_static);\n+    }\n+\n     fn c_regions_free_scope(\n         a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n         _b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n@@ -1573,6 +1592,16 @@ impl of combine for glb {\n         ret c_regions(self, a, b);\n     }\n \n+    fn c_contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        ret lub(self.infcx()).c_regions(a, b);\n+    }\n+\n+    fn c_regions_static(r: ty::region) -> cres<ty::region> {\n+        // GLB of `r` and static is always `r`; static is bigger than\n+        // everything\n+        ret ok(r);\n+    }\n+\n     fn c_regions_free_scope(\n         _a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n         b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {"}, {"sha": "d17f28efd6840f3f3161a66f1c97266d441d82d7", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -377,6 +377,8 @@ fn resolve_region_binding(cx: ctxt, span: span, region: ast::region) {\n         // }\n       }\n \n+      ast::re_static { /* fallthrough */ }\n+\n       ast::re_named(ident) {\n         alt cx.scope.resolve_ident(ident) {\n           some(r) {"}, {"sha": "c16b164d153201da4f223585338a1303e9b78c43", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -28,7 +28,7 @@ fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n             alt ty::get(t).struct {\n               ty::ty_rptr(region, _) {\n                 alt region {\n-                  ty::re_bound(_) | ty::re_free(_, _) {\n+                  ty::re_bound(_) | ty::re_free(_, _) | ty::re_static {\n                     /* ok */\n                   }\n                   ty::re_scope(rbi) {"}, {"sha": "70173de4f05c3ac4a094ce29a04da5b962908c3a", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -267,6 +267,7 @@ enum region {\n     re_free(node_id, bound_region),\n     re_scope(node_id),\n     re_var(region_vid),\n+    re_static, // effectively `top` in the region lattice\n     re_default\n }\n \n@@ -1473,6 +1474,7 @@ fn hash_type_structure(st: sty) -> uint {\n           re_scope(id)  { ((id as uint) << 2u) | 2u }\n           re_var(id)    { (id.to_uint() << 2u) | 3u }\n           re_default    { 4u }\n+          re_bot        { 5u }\n         }\n     }\n     alt st {"}, {"sha": "1109cc53ab6d5fd083c5ad7b7d7e33b2ed19d314", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -20,6 +20,7 @@ import std::map::{hashmap, int_hash};\n import std::serialization::{serialize_uint, deserialize_uint};\n import std::ufind;\n import syntax::print::pprust::*;\n+import util::common::indent;\n \n export check_crate;\n export method_map;\n@@ -366,6 +367,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n               ast::re_self | ast::re_named(_) {\n                 tcx.region_map.ast_type_to_region.get(region.id)\n               }\n+              ast::re_static {\n+                ty::re_static\n+              }\n             };\n             ty::mk_rptr(tcx, r, ast_mt_to_mt(tcx, mode, mt))\n           }\n@@ -2472,7 +2476,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n \n-    #debug(\"typechecking expr %d (%s)\",\n+    #debug(\">> typechecking expr %d (%s)\",\n            expr.id, syntax::print::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n@@ -3382,6 +3386,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n            ty_to_str(tcx, expected));\n \n     unify(fcx, expr.span, expected, fcx.expr_ty(expr));\n+\n+    #debug(\"<< bot=%b\", bot);\n     ret bot;\n }\n "}, {"sha": "d8b27dc56862fe9df6e601a2b3ac8de2a174ff28", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -36,6 +36,7 @@ fn region_to_str(cx: ctxt, region: region) -> str {\n       // These two should not be seen by end-users (very often, anyhow):\n       re_var(id)    { #fmt(\"&%s.\", id.to_str()) }\n       re_default    { \"&(default).\" }\n+      re_static     { \"&static.\" }\n     }\n }\n "}, {"sha": "ffc9f6ca1e0679133f3855f53d67e09c3cd96853", "filename": "src/test/compile-fail/regions-leaking-ptr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -0,0 +1,19 @@\n+// The type of `y` ends up getting inferred to the type of the block.\n+// This generates a ton of error msgs at the moment.\n+fn broken() -> int {\n+    let mut x = 3;\n+    let mut y = [&x]; //! ERROR reference escapes its block\n+    while x < 10 {\n+        let z = x;\n+        y += [&z];\n+        x += 1;\n+    }\n+    vec::foldl(0, y) {|v, p| v + *p }\n+    //!^ ERROR reference escapes its block\n+    //!^^ ERROR reference escapes its block\n+    //!^^^ ERROR reference escapes its block\n+    //!^^^^ ERROR reference escapes its block\n+    //!^^^^^ ERROR reference escapes its block\n+}\n+\n+fn main() { }\n\\ No newline at end of file"}, {"sha": "b25d7ceccbaf7a5f9c2d7ef54581e44ab55df692", "filename": "src/test/run-pass/regions-bot.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051f24da25a485f9702590f9c7f5095ebd0fbb58/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-bot.rs?ref=051f24da25a485f9702590f9c7f5095ebd0fbb58", "patch": "@@ -0,0 +1,8 @@\n+// A very limited test of the \"bottom\" region\n+\n+fn produce_static<T>() -> &static.T { fail; }\n+\n+fn foo<T>(x: &T) -> &uint { produce_static() }\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}