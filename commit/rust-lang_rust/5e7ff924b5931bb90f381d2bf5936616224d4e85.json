{"sha": "5e7ff924b5931bb90f381d2bf5936616224d4e85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlN2ZmOTI0YjU5MzFiYjkwZjM4MWQyYmY1OTM2NjE2MjI0ZDRlODU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-02T22:29:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-02T22:31:10Z"}, "message": "rustc: Don't error out early when constructing a boxed trait.\n\nThis improves error messages a bit and helps pave the way for \"@int as @Trait\"\n(as opposed to \"int as @Trait\").", "tree": {"sha": "1cc6a401cb55dfb33a8914d18543e3c7fe80317c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cc6a401cb55dfb33a8914d18543e3c7fe80317c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e7ff924b5931bb90f381d2bf5936616224d4e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7ff924b5931bb90f381d2bf5936616224d4e85", "html_url": "https://github.com/rust-lang/rust/commit/5e7ff924b5931bb90f381d2bf5936616224d4e85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e7ff924b5931bb90f381d2bf5936616224d4e85/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f78cdcb6364cf938bfeb71da0c7eca62e257d537", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78cdcb6364cf938bfeb71da0c7eca62e257d537", "html_url": "https://github.com/rust-lang/rust/commit/f78cdcb6364cf938bfeb71da0c7eca62e257d537"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "550c32d0fa10a0b6b501ce4c2fdc2c0c5ed474fc", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e7ff924b5931bb90f381d2bf5936616224d4e85/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7ff924b5931bb90f381d2bf5936616224d4e85/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5e7ff924b5931bb90f381d2bf5936616224d4e85", "patch": "@@ -51,8 +51,13 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                result.push(lookup_vtable(fcx, expr, *ty, i_ty,\n-                                          allow_unsafe, is_early));\n+                match lookup_vtable(fcx, expr, *ty, i_ty, allow_unsafe,\n+                                    is_early) {\n+                    None => {}\n+                    Some(vtable) => {\n+                        result.push(vtable);\n+                    }\n+                }\n               }\n               _ => ()\n             }\n@@ -91,7 +96,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                  trait_ty: ty::t,\n                  allow_unsafe: bool,\n                  is_early: bool)\n-    -> vtable_origin\n+    -> Option<vtable_origin>\n {\n \n     debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n@@ -113,7 +118,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n-            return vtable_param(0, 0);\n+            return Some(vtable_param(0, 0));\n         }\n     };\n \n@@ -135,7 +140,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                                            idid);\n                                     relate_trait_tys(fcx, expr,\n                                                      trait_ty, ity);\n-                                    return vtable_param(n, n_bound);\n+                                    return Some(vtable_param(n, n_bound));\n                                 }\n                             }\n                             _ => tcx.sess.impossible_case(\n@@ -170,7 +175,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                     }\n                 }\n             }\n-            return vtable_trait(did, substs.tps);\n+            return Some(vtable_trait(did, substs.tps));\n         }\n \n         _ => {\n@@ -303,7 +308,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                                 None => {\n                                     assert is_early;\n                                     // Bail out with a bogus answer\n-                                    return vtable_param(0, 0);\n+                                    return Some(vtable_param(0, 0));\n                                 }\n                             };\n \n@@ -341,23 +346,20 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n             match found.len() {\n                 0 => { /* fallthrough */ }\n-                1 => { return found[0]; }\n+                1 => { return Some(found[0]); }\n                 _ => {\n                     if !is_early {\n                         fcx.ccx.tcx.sess.span_err(\n                             expr.span,\n                             ~\"multiple applicable methods in scope\");\n                     }\n-                    return found[0];\n+                    return Some(found[0]);\n                 }\n             }\n         }\n     }\n \n-    tcx.sess.span_fatal(\n-        expr.span,\n-        fmt!(\"failed to find an implementation of trait %s for %s\",\n-             ty_to_str(tcx, trait_ty), ty_to_str(tcx, ty)));\n+    return None;\n }\n \n fn fixup_ty(fcx: @fn_ctxt,\n@@ -459,13 +461,26 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             Look up vtables for the type we're casting to,\n             passing in the source and target type\n             */\n-            let vtable = lookup_vtable(fcx, ex, fcx.expr_ty(src),\n-                                       target_ty, true, is_early);\n-            /*\n-            Map this expression to that vtable (that is: \"ex has\n-            vtable <vtable>\")\n-            */\n-            if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n+            let ty = fcx.expr_ty(src);\n+            let vtable_opt = lookup_vtable(fcx, ex, ty, target_ty, true,\n+                                           is_early);\n+            match vtable_opt {\n+                None => {\n+                    fcx.tcx().sess.span_err(\n+                        ex.span,\n+                        fmt!(\"failed to find an implementation of trait %s \\\n+                              for %s\",\n+                             ty_to_str(fcx.tcx(), target_ty),\n+                             ty_to_str(fcx.tcx(), ty)));\n+                }\n+                Some(vtable) => {\n+                    /*\n+                    Map this expression to that vtable (that is: \"ex has\n+                    vtable <vtable>\")\n+                    */\n+                    if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n+                }\n+            }\n           }\n           _ => ()\n         }"}]}