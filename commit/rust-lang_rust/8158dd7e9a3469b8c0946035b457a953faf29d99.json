{"sha": "8158dd7e9a3469b8c0946035b457a953faf29d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNThkZDdlOWEzNDY5YjhjMDk0NjAzNWI0NTdhOTUzZmFmMjlkOTk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-12T00:43:02Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-12T01:08:42Z"}, "message": "rustpkg: Use pkg IDs, remove old code for now that required packages to declare IDs explicitly\n\nThis is preliminary work on bringing rustpkg up to conformance with #5679\nand related issues.\n\nThis change makes rustpkg infer a package ID from its containing directory,\ninstead of requiring name and vers attributes in the code. Many aspects of it\nare incomplete; I've only tested one package (see README.txt) and one command,\n\"build\". So far it only works for local packages.\n\nI also removed code for several of the package commands other than \"build\",\nreplacing them with stubs that fail, since they used package IDs in ways that\ndidn't jibe well with the new scheme. I will re-implement the commands one\nat a time.", "tree": {"sha": "99661b2e610aa33f50358c871af84daf10211e81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99661b2e610aa33f50358c871af84daf10211e81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8158dd7e9a3469b8c0946035b457a953faf29d99", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8158dd7e9a3469b8c0946035b457a953faf29d99", "html_url": "https://github.com/rust-lang/rust/commit/8158dd7e9a3469b8c0946035b457a953faf29d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8158dd7e9a3469b8c0946035b457a953faf29d99/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f72e22985d0d39707f7741c0b63002889c457a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f72e22985d0d39707f7741c0b63002889c457a", "html_url": "https://github.com/rust-lang/rust/commit/e0f72e22985d0d39707f7741c0b63002889c457a"}], "stats": {"total": 1483, "additions": 519, "deletions": 964}, "files": [{"sha": "eacf07e01ea5741be5a9759aad3eb70f8dfeff62", "filename": "src/librustpkg/README.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2FREADME.txt?ref=8158dd7e9a3469b8c0946035b457a953faf29d99", "patch": "@@ -0,0 +1,4 @@\n+Right now (2013-04-11), only one package works, the branch of rust-sdl at:\n+https://github.com/catamorphism/rust-sdl/tree/new-rustpkg\n+\n+and only one command works, \"build\"."}, {"sha": "24c37d2558951297b68b76666d8a79b398aa0c5f", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 343, "deletions": 593, "changes": 936, "blob_url": "https://github.com/rust-lang/rust/blob/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=8158dd7e9a3469b8c0946035b457a953faf29d99", "patch": "@@ -27,42 +27,51 @@ extern mod rustc(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n use core::*;\n+pub use core::path::Path;\n use core::container::Map;\n use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use std::net::url;\n-use std::{json, semver, getopts};\n-use syntax::codemap::spanned;\n+use std::{getopts};\n use syntax::{ast, diagnostic};\n-use util::Package;\n+use util::{ExitCode, Pkg, PkgId};\n \n mod usage;\n mod util;\n \n-struct PackageScript {\n-    id: ~str,\n-    name: ~str,\n-    vers: semver::Version,\n-    crates: ~[~str],\n-    deps: ~[(~str, Option<~str>)],\n+/// A PkgScript represents user-supplied custom logic for\n+/// special build hooks. This only exists for packages with\n+/// an explicit package script.\n+struct PkgScript {\n+    /// Uniquely identifies this package\n+    id: PkgId,\n+    // Used to have this field:    deps: ~[(~str, Option<~str>)]\n+    // but I think it shouldn't be stored here\n+    /// The contents of the package script: either a file path,\n+    /// or a string containing the text of the input\n     input: driver::input,\n+    /// The session to use *only* for compiling the custom\n+    /// build script\n     sess: session::Session,\n+    /// The config for compiling the custom build script\n     cfg: ast::crate_cfg,\n+    /// The crate for the custom build script\n     crate: @ast::crate,\n-    custom: bool\n+    /// Directory in which to store build output\n+    build_dir: Path\n }\n \n-impl PackageScript {\n-    fn parse(parent: &Path) -> Result<PackageScript, ~str> {\n-        let script = parent.push(~\"pkg.rs\");\n-\n-        if !os::path_exists(&script) {\n-            return result::Err(~\"no pkg.rs file\");\n-        }\n-\n+impl PkgScript {\n+    /// Given the path name for a package script\n+    /// and a package ID, parse the package script into\n+    /// a PkgScript that we can then execute\n+    fn parse(script: Path, id: PkgId) -> PkgScript {\n+        // Get the executable name that was invoked\n         let binary = os::args()[0];\n+        // Build the rustc session data structures to pass\n+        // to the compiler\n         let options = @session::options {\n             binary: binary,\n             crate_type: session::bin_crate,\n@@ -73,190 +82,122 @@ impl PackageScript {\n         let cfg = driver::build_configuration(sess, binary, input);\n         let (crate, _) = driver::compile_upto(sess, cfg, input,\n                                               driver::cu_parse, None);\n-        let mut id = None;\n-        let mut vers = None;\n-        let mut crates = ~[];\n-        let mut deps = ~[];\n-\n-        fn load_pkg_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                                      Option<~str>) {\n-            let mut id = None;\n-            let mut vers = None;\n-\n-            for mis.each |a| {\n-                match a.node {\n-                    ast::meta_name_value(v, spanned {\n-                                                node: ast::lit_str(s),\n-                                                span: _}) => {\n-                        match *v {\n-                            ~\"id\" => id = Some(*s),\n-                            ~\"vers\" => vers = Some(*s),\n-                            _ => ()\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            (id, vers)\n-        }\n+        let work_dir = dest_dir(id);\n \n-        fn load_pkg_dep_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                                          Option<~str>) {\n-            let mut url = None;\n-            let mut target = None;\n-\n-            for mis.each |a| {\n-                match a.node {\n-                    ast::meta_name_value(v, spanned {\n-                                                node: ast::lit_str(s),\n-                                                span: _}) => {\n-                        match *v {\n-                            ~\"url\" => url = Some(*s),\n-                            ~\"target\" => target = Some(*s),\n-                            _ => ()\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            (url, target)\n-        }\n+        debug!(\"Returning package script with id %?\", id);\n \n-        fn load_pkg_crate_attr(mis: ~[@ast::meta_item]) -> Option<~str> {\n-            let mut file = None;\n-\n-            for mis.each |a| {\n-                match a.node {\n-                    ast::meta_name_value(v, spanned {\n-                                                node: ast::lit_str(s),\n-                                                span: _}) => {\n-                        match *v {\n-                            ~\"file\" => file = Some(*s),\n-                            _ => ()\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            file\n-        }\n-\n-        for crate.node.attrs.each |a| {\n-            match a.node.value.node {\n-                ast::meta_list(v, mis) => {\n-                    match *v {\n-                        ~\"pkg\" => {\n-                            let (i, v) = load_pkg_attr(mis);\n-\n-                            id = i;\n-                            vers = v;\n-                        }\n-                        ~\"pkg_dep\" => {\n-                            let (u, t) = load_pkg_dep_attr(mis);\n-\n-                            if u.is_none() {\n-                                fail!(~\"pkg_dep attr without a url value\");\n-                            }\n-\n-                            deps.push((u.get(), t));\n-                        }\n-                        ~\"pkg_crate\" => {\n-                            let f = load_pkg_crate_attr(mis);\n-\n-                            if f.is_none() {\n-                                fail!(~\"pkg_file attr without a file value\");\n-                            }\n-\n-                            crates.push(f.get());\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        let mut custom = false;\n-\n-        // If we hit a function, we assume they want to use\n-        // the build API.\n-        for crate.node.module.items.each |i| {\n-            match i.node {\n-                ast::item_fn(*) => {\n-                    custom = true;\n-\n-                    break;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        if id.is_none() || vers.is_none() {\n-            return result::Err(~\"pkg attr without (id, vers) values\");\n-        }\n-\n-        let id = id.get();\n-        let name = match util::parse_name(id) {\n-            result::Ok(name) => name,\n-            result::Err(err) => return result::Err(err)\n-        };\n-        let vers = match util::parse_vers(vers.get()) {\n-            result::Ok(vers) => vers,\n-            result::Err(err) => return result::Err(err)\n-        };\n-\n-        result::Ok(PackageScript {\n+        PkgScript {\n             id: id,\n-            name: name,\n-            vers: vers,\n-            crates: crates,\n-            deps: deps,\n             input: input,\n             sess: sess,\n             cfg: cfg,\n             crate: crate,\n-            custom: custom\n-        })\n+            build_dir: work_dir\n+        }\n     }\n \n-    // Build the bootstrap and run a command\n+    /// Run the contents of this package script, where <what>\n+    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n+    /// Returns a pair of an exit code and list of configs (obtained by\n+    /// calling the package script's configs() function if it exists\n     // FIXME (#4432): Use workcache to only compile the script when changed\n-    fn run(&self, cmd: ~str, test: bool) -> int {\n-        let work_dir = self.work_dir();\n-        let input = self.input;\n+    fn run_custom(&self, what: ~str) -> (~[~str], ExitCode) {\n+        debug!(\"run_custom: %s\", what);\n         let sess = self.sess;\n-        let cfg = self.cfg;\n+\n+        debug!(\"Working directory = %s\", self.build_dir.to_str());\n+        // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate);\n-        let outputs = driver::build_output_filenames(input, &Some(work_dir),\n-                                                     &None, sess);\n-        let exe = work_dir.push(~\"pkg\" + util::exe_suffix());\n-        let root = filesearch::get_rustpkg_sysroot().get().pop().pop();\n-\n-        driver::compile_rest(sess, cfg, driver::cu_parse,\n-                             Some(outputs), Some(crate));\n-        run::run_program(exe.to_str(), ~[root.to_str(), cmd, test.to_str()])\n+        debug!(\"Building output filenames with script name %s\",\n+               driver::source_name(self.input));\n+        match filesearch::get_rustpkg_sysroot() {\n+            Ok(r) => {\n+                let root = r.pop().pop().pop().pop(); // :-\\\n+                debug!(\"Root is %s, calling compile_rest\", root.to_str());\n+                util::compile_crate_from_input(self.input, Some(self.build_dir),\n+                                               sess, Some(crate), os::args()[0]);\n+                let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+                debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n+                let status = run::run_program(exe.to_str(), ~[root.to_str(), what]);\n+                if status != 0 {\n+                    return (~[], status);\n+                }\n+                else {\n+                    debug!(\"Running program (configs): %s %s %s\",\n+                           exe.to_str(), root.to_str(), ~\"configs\");\n+                    let output = run::program_output(exe.to_str(), ~[root.to_str(), ~\"configs\"]);\n+                    // Run the configs() function to get the configs\n+                    let mut cfgs = ~[];\n+                    for str::each_word(output.out) |w| {\n+                        cfgs.push(w.to_owned());\n+                    }\n+                    (cfgs, output.status)\n+                }\n+            }\n+            Err(e) => {\n+                fail!(fmt!(\"Running package script, couldn't find rustpkg sysroot (%s)\",\n+                           e))\n+            }\n+        }\n     }\n \n     fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()),\n-                         self.vers.to_str())\n+        self.id.hash()\n     }\n \n-    fn work_dir(&self) -> Path {\n-        util::root().push(~\"work\").push(self.hash())\n-    }\n }\n \n struct Ctx {\n-    cfgs: ~[~str],\n+    // I'm not sure what this is for\n     json: bool,\n-    dep_cache: @mut HashMap<~str, bool>\n+    // Cache of hashes of things already installed\n+    // though I'm not sure why the value is a bool\n+    dep_cache: @mut HashMap<~str, bool>,\n+}\n+\n+\n+/// Returns the output directory to use.\n+/// Right now is always the default, should\n+/// support changing it.\n+fn dest_dir(pkgid: PkgId) -> Path {\n+    default_dest_dir(&pkgid.path).expect(\n+        ~\"couldn't make default dir?!\")\n+        \n+}\n+\n+/// Returns the default output directory for compilation.\n+/// Creates that directory if it doesn't exist.\n+fn default_dest_dir(pkg_dir: &Path) -> Option<Path> {\n+    use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n+    // For now: assumes that pkg_dir exists and is relative\n+    // to the CWD. Change this later when we do path searching.\n+    let rslt = pkg_dir.push(\"build\");\n+    let is_dir = os::path_is_dir(&rslt);\n+    if os::path_exists(&rslt) {\n+        if is_dir {\n+            Some(rslt)\n+        }\n+        else {\n+            util::error(fmt!(\"%s is not a directory\", rslt.to_str()));\n+            None\n+        }\n+    }\n+    else {\n+        // Create it\n+        if os::make_dir(&rslt, (S_IRUSR | S_IWUSR | S_IXUSR) as i32) {\n+            Some(rslt)\n+        }\n+        else {\n+            util::error(fmt!(\"Could not create directory %s\",\n+                             rslt.to_str()));\n+            None // ??? should probably use conditions\n+        }\n+    }\n }\n \n impl Ctx {\n+\n     fn run(&self, cmd: ~str, args: ~[~str]) {\n         let root = util::root();\n \n@@ -284,20 +225,61 @@ impl Ctx {\n                 if args.len() < 1 {\n                     return usage::build();\n                 }\n+                // The package id is presumed to be the first command-line\n+                // argument\n                 let pkgid = PkgId::new(args[0]);\n-                let mut src = PkgSrc::new(&Path(\".\"), &pkgid);\n+                // Should allow the build directory to be configured.\n+                // Right now it's always the \"build\" subdirectory in\n+                // the package directory\n+                let dst_dir = dest_dir(pkgid);\n+                debug!(\"Destination dir = %s\", dst_dir.to_str());\n+                // Right now, we assume the pkgid path is a valid dir\n+                // relative to the CWD. In the future, we should search\n+                // paths\n+                let cwd = os::getcwd().normalize();\n+                debug!(\"Current working directory = %?\", cwd);\n+\n+                // Find crates inside the workspace\n+                let mut src = PkgSrc::new(&cwd, &dst_dir, &pkgid);\n+                debug!(\"Package src = %?\", src);\n                 src.find_crates();\n-                src.build(&Path(\".\"));\n+\n+                // Is there custom build logic? If so, use it\n+                let pkg_src_dir = cwd.push_rel(&pkgid.path);\n+                debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n+                let cfgs = match src.package_script_option(&pkg_src_dir) {\n+                    Some(package_script_path) => {\n+                        let pscript = PkgScript::parse(package_script_path,\n+                                                       pkgid);\n+                        // Limited right now -- we're only running the post_build\n+                        // hook and probably fail otherwise\n+                        // also post_build should be called pre_build\n+                        let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n+                        debug!(\"Command return code = %?\", hook_result);\n+                        if hook_result != 0 {\n+                            fail!(fmt!(\"Error running custom build command\"))\n+                        }\n+                        // otherwise, the package script succeeded\n+                        cfgs\n+                    }\n+                    None => {\n+                        debug!(\"No package script, continuing\");\n+                        ~[]\n+                    }\n+                };\n+                src.build(&dst_dir, cfgs);\n             }\n             ~\"clean\" => {\n                 self.clean();\n             }\n             ~\"do\" => {\n-                if args.len() < 1 {\n+                if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n-                self.do_cmd(args[0]);\n+                if !self.do_cmd(args[0], args[1]) {\n+                    fail!(~\"a command failed!\");\n+                }\n             }\n             ~\"info\" => {\n                 self.info();\n@@ -342,7 +324,7 @@ impl Ctx {\n         }\n     }\n \n-    fn do_cmd(&self, cmd: ~str) -> bool {\n+    fn do_cmd(&self, cmd: ~str, pkgname: ~str) -> bool {\n         match cmd {\n             ~\"build\" | ~\"test\" => {\n                 util::error(~\"that command cannot be manually called\");\n@@ -353,238 +335,95 @@ impl Ctx {\n         }\n \n         let cwd = &os::getcwd();\n-        let script = match PackageScript::parse(cwd) {\n-            result::Ok(script) => script,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-        let status = script.run(cmd, false);\n-\n-        if status == 42 {\n-            util::error(~\"no fns are listening for that cmd\");\n-\n-            return false;\n-        }\n-\n-        status == 0\n-    }\n-\n-    fn build(&self, dir: &Path, verbose: bool, opt: bool,\n-             test: bool) -> Option<PackageScript> {\n-        let cwd = &os::getcwd();\n-        let script = match PackageScript::parse(dir) {\n-            result::Ok(script) => script,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return None;\n-            }\n-        };\n-        let work_dir = script.work_dir();\n-        let mut success = true;\n-\n-        util::need_dir(&work_dir);\n-\n-        if script.deps.len() >= 1 {\n-            util::note(~\"installing dependencies\");\n-\n-            for script.deps.each |&dep| {\n-                let (url, target) = dep;\n-\n-                success = self.install(Some(url), target, true);\n-\n-                if !success { break; }\n-            }\n-\n-\n-            if !success {\n-                util::error(\n-                    fmt!(\"building %s v%s failed: a dep wasn't installed\",\n-                         script.name, script.vers.to_str()));\n+        let pkgid = PkgId::new(pkgname);\n+        // Always use the \"build\" subdirectory of the package dir,\n+        // but we should allow this to be configured\n+        let dst_dir = dest_dir(pkgid);\n+        \n+        let mut src = PkgSrc::new(cwd, &dst_dir, &pkgid);\n+        \n+        match src.package_script_option(cwd) {\n+            Some(script_path) => {\n+                let script = PkgScript::parse(script_path, pkgid);\n+                let (_, status) = script.run_custom(cmd); // Ignore cfgs?\n+                if status == 42 { // ???\n+                    util::error(~\"no fns are listening for that cmd\");\n+                    \n+                    return false;\n+                }\n \n-                return None;\n+                status == 0\n             }\n-\n-            util::note(~\"installed dependencies\");\n-        }\n-\n-        // Build imperative crates\n-        os::change_dir(dir);\n-\n-        if script.custom {\n-            let status = script.run(~\"build\", test);\n-\n-            if status != 0 && status != 42 {\n-                util::error(\n-                    fmt!(\"building %s v%s failed: custom logic failed (%d)\",\n-                         script.name, script.vers.to_str(), status));\n-\n-                return None;\n+            None => {\n+                util::error(fmt!(\"invoked `do`, but there is no package script in %s\", cwd.to_str()));\n+                false\n             }\n         }\n+    }\n \n-        os::change_dir(cwd);\n-\n-        for script.crates.each |&crate| {\n-            let crate = &dir.push_rel(&Path(crate)).normalize();\n-\n-            util::note(fmt!(\"compiling %s\", crate.to_str()));\n-\n-            success = self.compile(crate, &work_dir, ~[],\n-                                   ~[], opt, test);\n-\n-            if !success { break; }\n-        }\n-\n-        if !success {\n-            util::error(\n-                fmt!(\"building %s v%s failed: a crate failed to compile\",\n-                     script.name, script.vers.to_str()));\n-\n-            return None;\n-        }\n-\n-        if verbose {\n-            util::note(fmt!(\"built %s v%s\", script.name,\n-                            script.vers.to_str()));\n-        }\n-\n-        Some(script)\n+    fn build(&self, _dir: &Path, _verbose: bool, _opt: bool,\n+             _test: bool) -> Option<PkgScript> {\n+ // either not needed anymore,\n+ // or needed only when we don't have a package script. Not sure which one.\n+        fail!();\n     }\n \n-    fn compile(&self, crate: &Path, dir: &Path, flags: ~[~str],\n-               cfgs: ~[~str], opt: bool, test: bool) -> bool {\n-        util::compile_crate(None, crate, dir, flags, cfgs, opt, test)\n+    fn compile(&self, _crate: &Path, _dir: &Path, _flags: ~[~str],\n+               _cfgs: ~[~str], _opt: bool, _test: bool) -> bool {\n+        // What's the difference between build and compile?\n+        fail!(~\"compile not yet implemented\");\n     }\n \n     fn clean(&self) -> bool {\n-        let script = match PackageScript::parse(&os::getcwd()) {\n-            result::Ok(script) => script,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-        let dir = script.work_dir();\n-\n-        util::note(fmt!(\"cleaning %s v%s (%s)\", script.name,\n-                        script.vers.to_str(), script.id));\n-\n-        if os::path_exists(&dir) {\n-            util::remove_dir_r(&dir);\n-            util::note(fmt!(\"removed %s\", dir.to_str()));\n-        }\n-\n-        util::note(fmt!(\"cleaned %s v%s\", script.name,\n-                                          script.vers.to_str()));\n-\n-        true\n+        // stub\n+        fail!();\n     }\n \n     fn info(&self) {\n-        if self.json {\n-            match PackageScript::parse(&os::getcwd()) {\n-                result::Ok(script) => {\n-                    let mut map = ~HashMap::new();\n-\n-                    map.insert(~\"id\", json::String(script.id));\n-                    map.insert(~\"name\", json::String(script.name));\n-                    map.insert(~\"vers\", json::String(script.vers.to_str()));\n-                    map.insert(~\"deps\", json::List(do script.deps.map |&dep| {\n-                        let (url, target) = dep;\n-                        let mut inner = ~HashMap::new();\n-\n-                        inner.insert(~\"url\", json::String(url));\n-\n-                        if !target.is_none() {\n-                            inner.insert(~\"target\",\n-                                         json::String(target.get()));\n-                        }\n-\n-                        json::Object(inner)\n-                    }));\n-\n-                    io::println(json::to_pretty_str(&json::Object(map)));\n-                }\n-                result::Err(_) => io::println(~\"{}\")\n-            }\n-        } else {\n-            let script = match PackageScript::parse(&os::getcwd()) {\n-                result::Ok(script) => script,\n-                result::Err(err) => {\n-                    util::error(err);\n-\n-                    return;\n-                }\n-            };\n-\n-            util::note(fmt!(\"id: %s\", script.id));\n-            util::note(fmt!(\"name: %s\", script.name));\n-            util::note(fmt!(\"vers: %s\", script.vers.to_str()));\n-            util::note(fmt!(\"deps: %s\",\n-                            if script.deps.len() > 0 {\n-                                ~\"\"\n-                            } else {\n-                                ~\"none\"\n-                            }));\n-\n-            for script.deps.each |&dep| {\n-                let (url, target) = dep;\n-\n-                util::note(fmt!(\"  <%s> (%s)\", url, match target {\n-                    Some(target) => target,\n-                    None => ~\"\"\n-                }));\n-            }\n-        }\n+        // stub\n+        fail!();\n     }\n \n     fn install(&self, url: Option<~str>,\n                target: Option<~str>, cache: bool) -> bool {\n-        let mut success;\n-        let mut dir;\n-\n-        if url.is_none() {\n-            util::note(~\"installing from the cwd\");\n-\n-            dir = os::getcwd();\n-        } else {\n-            let url = url.get();\n-            let hash = util::hash(if !target.is_none() { url + target.get() }\n-                                  else { url });\n-\n-            if self.dep_cache.contains_key(&hash) {\n-                util::warn(~\"already installed dep this run\");\n-\n-                return true;\n+       let dir = match url {\n+            None => {\n+                util::note(~\"installing from the cwd\");\n+                os::getcwd()\n             }\n+            Some(url) => {\n+                let hash = util::hash(if !target.is_none() {\n+                    url + target.get()\n+                }\n+                else { url });\n \n-            self.dep_cache.insert(hash, true);\n+                if self.dep_cache.contains_key(&hash) {\n+                    util::warn(~\"already installed dep this run\");\n+                    return true;\n+                }\n \n-            dir = util::root().push(~\"tmp\").push(hash);\n+                self.dep_cache.insert(hash, true);\n \n-            if cache && os::path_exists(&dir) {\n-                return true;\n-            }\n+                let dir = util::root().push(~\"tmp\").push(hash);\n \n-            success = self.fetch(&dir, url, target);\n+                if cache && os::path_exists(&dir) {\n+                    return true;\n+                }\n \n-            if !success {\n-                return false;\n+                if !self.fetch(&dir, url, target) {\n+                    return false;\n+                }\n+                dir\n             }\n-        }\n+        };\n \n         let script = match self.build(&dir, false, true, false) {\n             Some(script) => script,\n             None => {\n                 return false;\n             }\n         };\n-        let work_dir = script.work_dir();\n+        let work_dir = script.build_dir;\n         let from_bin_dir = work_dir.push(~\"bin\");\n         let from_lib_dir = work_dir.push(~\"lib\");\n         let to_bin_dir = util::root().push(~\"bin\");\n@@ -606,15 +445,13 @@ impl Ctx {\n             libs.push(to.to_str());\n         }\n \n-        let package = Package {\n+        let package = Pkg {\n             id: script.id,\n-            vers: script.vers,\n             bins: bins,\n             libs: libs\n         };\n \n-        util::note(fmt!(\"installed %s v%s\", script.name,\n-                                            script.vers.to_str()));\n+        util::note(fmt!(\"installed %s\", script.id.to_str()));\n         util::add_pkg(&package);\n \n         true\n@@ -719,17 +556,9 @@ impl Ctx {\n                 return false;\n             }\n         };\n-        let name = match util::parse_name(package.id) {\n-            result::Ok(name) => name,\n-            result::Err(err) => {\n-                util::error(err);\n+        let name = package.id.path.to_str(); // ???\n \n-                return false;\n-            }\n-        };\n-\n-        util::note(fmt!(\"preferring %s v%s (%s)\", name, package.vers.to_str(),\n-                                                  package.id));\n+        util::note(fmt!(\"preferring %s v%s\", name, package.id.version.to_str()));\n \n         let bin_dir = util::root().push(~\"bin\");\n \n@@ -746,7 +575,7 @@ impl Ctx {\n             util::note(fmt!(\"linked %s\", out.to_str()));\n         }\n \n-        util::note(fmt!(\"preferred %s v%s\", name, package.vers.to_str()));\n+        util::note(fmt!(\"preferred %s v%s\", name, package.id.version.to_str()));\n \n         true\n     }\n@@ -758,126 +587,24 @@ impl Ctx {\n                 return false;\n             }\n         };\n-        let work_dir = script.work_dir();\n-        let test_dir = work_dir.push(~\"test\");\n-\n-        for os::walk_dir(&test_dir) |test| {\n-            util::note(fmt!(\"running %s\", test.to_str()));\n-\n-            let status = run::run_program(test.to_str(), ~[]);\n-\n-            if status != 0 {\n-                os::set_exit_status(status);\n-            }\n-        }\n-\n-        // Run custom test listener\n-        if script.custom {\n-            let status = script.run(~\"test\", false);\n-\n-            if status != 0 && status != 42 {\n-                util::error(\n-                    fmt!(\"testing %s v%s failed: custom logic failed (%d)\",\n-                         script.name, script.vers.to_str(), status));\n \n-                os::set_exit_status(status);\n-            }\n-        }\n-\n-        util::note(fmt!(\"tested %s v%s\", script.name, script.vers.to_str()));\n-\n-        true\n+        // To do\n+        util::note(fmt!(\"Would test %s, but this is a dry run\",\n+                        script.id.to_str()));\n+        false\n     }\n \n-    fn uninstall(&self, id: ~str, vers: Option<~str>) -> bool {\n-        let package = match util::get_pkg(id, vers) {\n-            result::Ok(package) => package,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-        let name = match util::parse_name(package.id) {\n-            result::Ok(name) => name,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-\n-        util::note(fmt!(\"uninstalling %s v%s (%s)\", name,\n-                        package.vers.to_str(), package.id));\n-\n-        for vec::append(package.bins, package.libs).each |&file| {\n-            let path = Path(file);\n-\n-            if os::path_exists(&path) {\n-                if os::remove_file(&path) {\n-                    util::note(fmt!(\"removed %s\", path.to_str()));\n-                } else {\n-                    util::error(fmt!(\"could not remove %s\", path.to_str()));\n-                }\n-            }\n-        }\n-\n-        util::note(fmt!(\"uninstalled %s v%s\", name, package.vers.to_str()));\n-        util::remove_pkg(&package);\n-\n-        true\n+    fn uninstall(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+        fail!(~\"uninstall not yet implemented\");\n     }\n \n-    fn unprefer(&self, id: ~str, vers: Option<~str>) -> bool {\n-        let package = match util::get_pkg(id, vers) {\n-            result::Ok(package) => package,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-        let name = match util::parse_name(package.id) {\n-            result::Ok(name) => name,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false;\n-            }\n-        };\n-\n-        util::note(fmt!(\"unpreferring %s v%s (%s)\", name,\n-                        package.vers.to_str(), package.id));\n-\n-        let bin_dir = util::root().push(~\"bin\");\n-\n-        for package.bins.each |&bin| {\n-            let path = Path(bin);\n-            let mut name = None;\n-            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n-                name = Some(s.to_owned());\n-                break;\n-            }\n-            let out = bin_dir.push(name.unwrap());\n-\n-            if os::path_exists(&out) {\n-                if os::remove_file(&out) {\n-                    util::note(fmt!(\"unlinked %s\", out.to_str()));\n-                } else {\n-                    util::error(fmt!(\"could not unlink %s\", out.to_str()));\n-                }\n-            }\n-        }\n-\n-        util::note(fmt!(\"unpreferred %s v%s\", name, package.vers.to_str()));\n-\n-        true\n+    fn unprefer(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+        fail!(~\"unprefer not yet implemented\");\n     }\n }\n \n pub fn main() {\n-    io::println(\"WARNING: The Rust package manager is experimental and may\");\n-    io::println(\"be unstable.\");\n+    io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n \n     let args = os::args();\n     let opts = ~[getopts::optflag(~\"h\"), getopts::optflag(~\"help\"),\n@@ -895,8 +622,6 @@ pub fn main() {\n                getopts::opt_present(matches, ~\"help\");\n     let json = getopts::opt_present(matches, ~\"j\") ||\n                getopts::opt_present(matches, ~\"json\");\n-    let cfgs = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n-                           getopts::opt_strs(matches, ~\"c\"));\n     let mut args = copy matches.free;\n \n     args.shift();\n@@ -925,7 +650,6 @@ pub fn main() {\n     }\n \n     Ctx {\n-        cfgs: cfgs,\n         json: json,\n         dep_cache: @mut HashMap::new()\n     }.run(cmd, args);\n@@ -966,7 +690,7 @@ pub fn run(listeners: ~[Listener]) {\n \n pub impl Crate {\n \n-    static fn new(p: &Path) -> Crate {\n+    fn new(p: &Path) -> Crate {\n         Crate {\n             file: copy *p,\n             flags: ~[],\n@@ -1022,68 +746,15 @@ pub fn src_dir() -> Path {\n     os::getcwd()\n }\n \n-/// Build a set of crates, should be called once\n-pub fn build(crates: ~[Crate]) -> bool {\n-    let args = os::args();\n-    let dir = src_dir();\n-    let work_dir = work_dir();\n-    let mut success = true;\n-    let sysroot = Path(args[1]);\n-    let test = args[3] == ~\"true\";\n-\n-    for crates.each |&crate| {\n-        let path = &dir.push_rel(&crate.file).normalize();\n-\n-        util::note(fmt!(\"compiling %s\", path.to_str()));\n-\n-        success = util::compile_crate(Some(sysroot), path, &work_dir,\n-                                      crate.flags, crate.cfgs,\n-                                      false, test);\n-\n-        if !success { break; }\n-    }\n-\n-    if !success {\n-        os::set_exit_status(101);\n-    }\n-\n-    success\n-}\n-\n-\n-// Path-fragment identifier of a package such as \n-// 'github.com/graydon/test'; must be a relative\n-// path with >=1 component.\n-struct PkgId {\n-    path: Path\n-}\n-\n condition! {\n-    bad_pkg_id: (::core::path::Path, ~str) -> ::PkgId;\n+    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n }\n \n-impl PkgId {\n-    static fn new(s: &str) -> PkgId {\n-        use bad_pkg_id::cond;\n-\n-        let p = Path(s);\n-        if p.is_absolute {\n-            return cond.raise((p, ~\"absolute pkgid\"));\n-        }\n-        if p.components.len() < 1 {\n-            return cond.raise((p, ~\"0-length pkgid\"));\n-        }\n-        PkgId {\n-            path: p\n-        }\n-    }\n-}\n-\n-\n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n pub struct PkgSrc {\n-    root: Path,\n+    root: Path, // root of where the package source code lives\n+    dst_dir: Path, // directory where we will put the compiled output\n     id: PkgId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n@@ -1092,7 +763,7 @@ pub struct PkgSrc {\n }\n \n condition! {\n-    bad_path: (::core::path::Path, ~str) -> ::core::path::Path;\n+    bad_path: (super::Path, ~str) -> super::Path;\n }\n \n condition! {\n@@ -1102,9 +773,11 @@ condition! {\n impl PkgSrc {\n \n \n-    static fn new(fs_root: &Path, id: &PkgId) -> PkgSrc {\n+    fn new(src_dir: &Path, dst_dir: &Path,\n+                  id: &PkgId) -> PkgSrc {\n         PkgSrc {\n-            root: copy *fs_root,\n+            root: copy *src_dir,\n+            dst_dir: copy *dst_dir,\n             id: copy *id,\n             libs: ~[],\n             mains: ~[],\n@@ -1117,14 +790,20 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use bad_path::cond;\n \n+        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(),\n+               self.root.to_str());\n+\n         let dir = self.root.push_rel(&self.id.path).normalize();\n \n-        if ! os::path_exists(&dir) {\n+        debug!(\"Checking dir: %s\", dir.to_str());\n+\n+        if !os::path_exists(&dir) {\n             return cond.raise((dir, ~\"missing package dir\"));\n         }\n-              \n-        if ! os::path_is_dir(&dir) {\n-            return cond.raise((dir, ~\"missing package dir\"));\n+\n+        if !os::path_is_dir(&dir) {\n+            return cond.raise((dir, ~\"supplied path for package dir is a \\\n+                                      non-directory\"));\n         }\n \n         dir\n@@ -1136,9 +815,40 @@ impl PkgSrc {\n         dir.push(\"pkg.rs\").exists()\n     }\n \n+    // If a file named \"pkg.rs\" in the current directory exists,\n+    // return the path for it. Otherwise, None\n+    fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n+        let maybe_path = cwd.push(\"pkg.rs\");\n+        if os::path_exists(&maybe_path) {\n+            Some(maybe_path)\n+        }\n+        else {\n+            None\n+        }\n+    }\n+\n+    /// True if the given path's stem is self's pkg ID's stem\n+    /// or if the pkg ID's stem is <rust-foo> and the given path's\n+    /// stem is foo\n+    fn stem_matches(&self, p: &Path) -> bool {\n+        let self_id = self.id.path.filestem();\n+        if self_id == p.filestem() {\n+            return true;\n+        }\n+        else {\n+            for self_id.each |pth| {\n+                if pth.starts_with(\"rust-\")\n+                    && match p.filestem() {\n+                           Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n+                           None => false\n+                       } { return true; }\n+            }\n+        }\n+        false\n+    }\n \n-    static fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n-        assert p.components.len() > prefix;\n+    fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n+        assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n         for vec::slice(p.components, prefix,\n                        p.components.len()).each |c| {\n@@ -1150,9 +860,15 @@ impl PkgSrc {\n \n     fn find_crates(&mut self) {\n         use PkgSrc::push_crate;\n-        assert ! self.has_pkg_file();\n+\n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n+        // This is ugly, but can go away once we get rid\n+        // of .rc files\n+        let mut saw_rs = false;\n+        let mut saw_rc = false;\n+        debug!(\"Matching against %?\",\n+               self.id.path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => push_crate(&mut self.libs,\n@@ -1163,7 +879,32 @@ impl PkgSrc {\n                                                prefix, pth),\n                 Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n                                                 prefix, pth),\n-                _ => ()\n+                _ => {\n+                    // If the file stem is the same as the\n+                    // package ID, with an .rs or .rc extension,\n+                    // consider it to be a crate\n+                    let ext = pth.filetype();\n+                    let matches = |p: &Path| {\n+                        self.stem_matches(p) && (ext == Some(~\".rc\")\n+                                                  || ext == Some(~\".rs\"))\n+                    };\n+                    debug!(\"Checking %? which %s and ext = %? %? %?\", pth.filestem(),\n+                           if matches(pth) { \"matches\" } else { \"does not match\" },\n+                           ext, saw_rs, saw_rc);\n+                    if matches(pth) &&\n+                        // Avoid pushing foo.rc *and* foo.rs\n+                         !((ext == Some(~\".rc\") && saw_rs) ||\n+                           (ext == Some(~\".rs\") && saw_rc)) {\n+                        push_crate(&mut self.libs, // ????\n+                                   prefix, pth);\n+                        if ext == Some(~\".rc\") {\n+                            saw_rc = true;\n+                        }\n+                        else if ext == Some(~\".rs\") {\n+                            saw_rs = true;\n+                        }\n+                    }\n+                }\n             }\n         }\n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n@@ -1173,31 +914,40 @@ impl PkgSrc {\n                self.benchs.len())\n     }\n \n-\n-    static fn build_crates(dst_dir: &Path,\n+    fn build_crates(dst_dir: &Path,\n                            src_dir: &Path,\n                            crates: &[Crate],\n+                           cfgs: ~[~str],\n                            test: bool) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n-            util::note(fmt!(\"compiling %s\", path.to_str()));\n-            if ! util::compile_crate(None, path,\n+            util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n+            util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n+\n+            let result = util::compile_crate(None, path,\n                                      dst_dir,\n                                      crate.flags,\n-                                     crate.cfgs,\n-                                     false, test) {\n+                                     crate.cfgs + cfgs,\n+                                     false, test); \n+            if !result  {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n             }\n+            debug!(\"Result of compiling %s was %?\",\n+                   path.to_str(), result);\n         }\n     }\n \n-    fn build(&self, dst_dir: &Path) {\n+    fn build(&self, dst_dir: &Path, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n-        PkgSrc::build_crates(dst_dir, &dir, self.libs, false);\n-        PkgSrc::build_crates(dst_dir, &dir, self.mains, false);\n-        PkgSrc::build_crates(dst_dir, &dir, self.tests, true);\n-        PkgSrc::build_crates(dst_dir, &dir, self.benchs, true);\n+        debug!(\"Building libs\");\n+        PkgSrc::build_crates(dst_dir, &dir, self.libs, cfgs, false);\n+        debug!(\"Building mains\");\n+        PkgSrc::build_crates(dst_dir, &dir, self.mains, cfgs, false);\n+        debug!(\"Building tests\");\n+        PkgSrc::build_crates(dst_dir, &dir, self.tests, cfgs, true);\n+        debug!(\"Building benches\");\n+        PkgSrc::build_crates(dst_dir, &dir, self.benchs, cfgs, true);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "819823e87447c6c3e260618b6b94fc316cfeb9b1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 172, "deletions": 371, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158dd7e9a3469b8c0946035b457a953faf29d99/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8158dd7e9a3469b8c0946035b457a953faf29d99", "patch": "@@ -9,26 +9,125 @@\n // except according to those terms.\n \n use core::*;\n+use core::cmp::Ord;\n use core::hash::Streaming;\n-use core::hashmap::HashMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n-use std::{json, term, sort, getopts};\n+use std::{json, term, getopts};\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp, spanned};\n+use syntax::codemap::{dummy_sp};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n+use rustc::back::link::output_type_exe;\n \n-pub struct Package {\n-    id: ~str,\n-    vers: semver::Version,\n+pub type ExitCode = int; // For now\n+\n+/// A version is either an exact revision,\n+/// or a semantic version\n+pub enum Version {\n+    ExactRevision(float),\n+    SemVersion(semver::Version)\n+}\n+\n+impl Ord for Version {\n+    fn lt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n+            (&SemVersion(v1), &SemVersion(v2)) => v1 < v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn le(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n+            (&SemVersion(v1), &SemVersion(v2)) => v1 <= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn ge(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n+            (&SemVersion(v1), &SemVersion(v2)) => v1 > v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn gt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n+            (&SemVersion(v1), &SemVersion(v2)) => v1 >= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+\n+}\n+\n+impl ToStr for Version {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ExactRevision(n) => n.to_str(),\n+            SemVersion(v) => v.to_str()\n+        }\n+    }\n+}\n+\n+/// Placeholder\n+fn default_version() -> Version { ExactRevision(0.1) }\n+\n+// Path-fragment identifier of a package such as\n+// 'github.com/graydon/test'; path must be a relative\n+// path with >=1 component.\n+pub struct PkgId {\n+    path: Path,\n+    version: Version\n+}\n+\n+pub impl PkgId {\n+    fn new(s: &str) -> PkgId {\n+        use bad_pkg_id::cond;\n+\n+        let p = Path(s);\n+        if p.is_absolute {\n+            return cond.raise((p, ~\"absolute pkgid\"));\n+        }\n+        if p.components.len() < 1 {\n+            return cond.raise((p, ~\"0-length pkgid\"));\n+        }\n+        PkgId {\n+            path: p,\n+            version: default_version()\n+        }\n+    }\n+\n+    fn hash(&self) -> ~str {\n+        fmt!(\"%s-%s-%s\", self.path.to_str(),\n+             hash(self.path.to_str() + self.version.to_str()),\n+             self.version.to_str())\n+    }\n+\n+}\n+\n+impl ToStr for PkgId {\n+    fn to_str(&self) -> ~str {\n+        // should probably use the filestem and not the whole path\n+        fmt!(\"%s-v%s\", self.path.to_str(), self.version.to_str())\n+    }\n+}\n+\n+pub struct Pkg {\n+    id: PkgId,\n     bins: ~[~str],\n     libs: ~[~str],\n }\n \n+impl ToStr for Pkg {\n+    fn to_str(&self) -> ~str {\n+        self.id.to_str()\n+    }\n+}\n+\n pub fn root() -> Path {\n     match filesearch::get_rustpkg_root() {\n         result::Ok(path) => path,\n@@ -309,294 +408,22 @@ pub fn wait_for_lock(path: &Path) {\n     }\n }\n \n-fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n-    for packages.each |&package| {\n-        match &package {\n-            &json::Object(ref map) => {\n-                let mut has_id = false;\n-\n-                match map.get(&~\"id\") {\n-                    &json::String(ref str) => {\n-                        if pkg.id == *str {\n-                            has_id = true;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-\n-                match map.get(&~\"vers\") {\n-                    &json::String(ref str) => {\n-                        if has_id && pkg.vers.to_str() == *str {\n-                            return copy packages;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    let mut map = ~HashMap::new();\n-\n-    map.insert(~\"id\", json::String(pkg.id));\n-    map.insert(~\"vers\", json::String(pkg.vers.to_str()));\n-    map.insert(~\"bins\", json::List(do pkg.bins.map |&bin| {\n-        json::String(bin)\n-    }));\n-    map.insert(~\"libs\", json::List(do pkg.libs.map |&lib| {\n-        json::String(lib)\n-    }));\n-\n-    vec::append(packages, ~[json::Object(map)])\n-}\n-\n-fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n-    do packages.filter_mapped |&package| {\n-        match &package {\n-            &json::Object(ref map) => {\n-                let mut has_id = false;\n-\n-                match map.get(&~\"id\") {\n-                    &json::String(str) => {\n-                        if pkg.id == str {\n-                            has_id = true;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-\n-                match map.get(&~\"vers\") {\n-                    &json::String(ref str) => {\n-                        if has_id && pkg.vers.to_str() == *str {\n-                            None\n-                        } else {\n-                            Some(copy package)\n-                        }\n-                    }\n-                    _ => { Some(copy package) }\n-                }\n-            }\n-            _ => { Some(copy package) }\n-        }\n-    }\n-}\n-\n pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n-    let root = root();\n-    let db = root.push(~\"db.json\");\n-    let db_lock = root.push(~\"db.json.lck\");\n-\n-    wait_for_lock(&db_lock);\n-    touch(&db_lock);\n-\n-    let packages = if os::path_exists(&db) {\n-        match io::read_whole_file_str(&db) {\n-            result::Ok(str) => {\n-                match json::from_str(str) {\n-                    result::Ok(json) => {\n-                        match json {\n-                            json::List(list) => list,\n-                            _ => {\n-                                os::remove_file(&db_lock);\n-\n-                                return result::Err(\n-                                    ~\"package db's json is not a list\");\n-                            }\n-                        }\n-                    }\n-                    result::Err(err) => {\n-                        os::remove_file(&db_lock);\n-\n-                        return result::Err(\n-                            fmt!(\"failed to parse package db: %s\",\n-                            err.to_str()));\n-                    }\n-                }\n-            }\n-            result::Err(err) => {\n-                os::remove_file(&db_lock);\n-\n-                return result::Err(fmt!(\"failed to read package db: %s\",\n-                                        err));\n-            }\n-        }\n-    } else { ~[] };\n-\n-    os::remove_file(&db_lock);\n-\n-    result::Ok(packages)\n-}\n-\n-pub fn get_pkg(id: ~str,\n-               vers: Option<~str>) -> result::Result<Package, ~str> {\n-    let name = match parse_name(id) {\n-        result::Ok(name) => name,\n-        result::Err(err) => return result::Err(err)\n-    };\n-    let packages = match load_pkgs() {\n-        result::Ok(packages) => packages,\n-        result::Err(err) => return result::Err(err)\n-    };\n-    let mut sel = None;\n-    let mut possibs = ~[];\n-    let mut err = None;\n-\n-    for packages.each |&package| {\n-        match package {\n-            json::Object(map) => {\n-                let pid = match map.get(&~\"id\") {\n-                    &json::String(str) => str,\n-                    _ => loop\n-                };\n-                let pname = match parse_name(pid) {\n-                    result::Ok(pname) => pname,\n-                    result::Err(perr) => {\n-                        err = Some(perr);\n-\n-                        break;\n-                    }\n-                };\n-                let pvers = match map.get(&~\"vers\") {\n-                    &json::String(str) => str,\n-                    _ => loop\n-                };\n-                if pid == id || pname == name {\n-                    let bins = match map.get(&~\"bins\") {\n-                        &json::List(ref list) => {\n-                            do list.map |&bin| {\n-                                match bin {\n-                                    json::String(str) => str,\n-                                    _ => ~\"\"\n-                                }\n-                            }\n-                        }\n-                        _ => ~[]\n-                    };\n-                    let libs = match map.get(&~\"libs\") {\n-                        &json::List(ref list) => {\n-                            do list.map |&lib| {\n-                                match lib {\n-                                    json::String(str) => str,\n-                                    _ => ~\"\"\n-                                }\n-                            }\n-                        }\n-                        _ => ~[]\n-                    };\n-                    let package = Package {\n-                        id: pid,\n-                        vers: match parse_vers(pvers) {\n-                            result::Ok(vers) => vers,\n-                            result::Err(verr) => {\n-                                err = Some(verr);\n-\n-                                break;\n-                            }\n-                        },\n-                        bins: bins,\n-                        libs: libs\n-                    };\n-\n-                    if !vers.is_none() && vers.get() == pvers {\n-                        sel = Some(package);\n-                    }\n-                    else {\n-                        possibs.push(package);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    if !err.is_none() {\n-        return result::Err(err.get());\n-    }\n-    if !sel.is_none() {\n-        return result::Ok(sel.get());\n-    }\n-    if !vers.is_none() || possibs.len() < 1 {\n-        return result::Err(~\"package not found\");\n-    }\n-\n-    let possibs = sort::merge_sort(possibs, |v1, v2| {\n-        v1.vers <= v2.vers\n-    });\n-\n-    result::Ok(copy *possibs.last())\n+    fail!(~\"load_pkg not implemented\");\n }\n \n-pub fn add_pkg(pkg: &Package) -> bool {\n-    let root = root();\n-    let db = root.push(~\"db.json\");\n-    let db_lock = root.push(~\"db.json.lck\");\n-    let packages = match load_pkgs() {\n-        result::Ok(packages) => packages,\n-        result::Err(err) => {\n-            error(err);\n-\n-            return false;\n-        }\n-    };\n-\n-    wait_for_lock(&db_lock);\n-    touch(&db_lock);\n-    os::remove_file(&db);\n-\n-    match io::mk_file_writer(&db, ~[io::Create]) {\n-        result::Ok(writer) => {\n-            writer.write_line(json::to_pretty_str(&json::List(\n-                _add_pkg(packages, pkg))));\n-        }\n-        result::Err(err) => {\n-            error(fmt!(\"failed to dump package db: %s\", err));\n-            os::remove_file(&db_lock);\n-\n-            return false;\n-        }\n-    }\n-\n-    os::remove_file(&db_lock);\n-\n-    true\n+pub fn get_pkg(_id: ~str,\n+               _vers: Option<~str>) -> result::Result<Pkg, ~str> {\n+    fail!(~\"get_pkg not implemented\");\n }\n \n-pub fn remove_pkg(pkg: &Package) -> bool {\n-    let root = root();\n-    let db = root.push(~\"db.json\");\n-    let db_lock = root.push(~\"db.json.lck\");\n-    let packages = match load_pkgs() {\n-        result::Ok(packages) => packages,\n-        result::Err(err) => {\n-            error(err);\n-\n-            return false;\n-        }\n-    };\n-\n-    wait_for_lock(&db_lock);\n-    touch(&db_lock);\n-    os::remove_file(&db);\n-\n-    match io::mk_file_writer(&db, ~[io::Create]) {\n-        result::Ok(writer) => {\n-            writer.write_line(json::to_pretty_str(&json::List(\n-                _rm_pkg(packages, pkg))));\n-        }\n-        result::Err(err) => {\n-            error(fmt!(\"failed to dump package db: %s\", err));\n-            os::remove_file(&db_lock);\n-\n-            return false;\n-        }\n-    }\n-\n-    os::remove_file(&db_lock);\n-\n-    true\n+pub fn add_pkg(pkg: &Pkg) -> bool {\n+    note(fmt!(\"Would be adding package, but add_pkg is not yet implemented %s\",\n+         pkg.to_str()));\n+    false\n }\n \n+// FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<Path>,\n                      in_file: &Path,\n                      out_dir: &Path,\n@@ -605,22 +432,41 @@ pub fn compile_input(sysroot: Option<Path>,\n                      opt: bool,\n                      test: bool) -> bool {\n \n-    assert in_file.components.len() > 1;\n+    assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n-    let short_name = in_file.pop().filename().get();\n+    debug!(\"compile_input: %s\", in_file.to_str());\n+    // tjc: by default, use the package ID name as the link name\n+    // not sure if we should support anything else\n+    let short_name = in_file.filestem().expect(\"Can't compile a directory!\");\n+    debug!(\"short_name = %s\", short_name.to_str());\n+\n+// Right now we're always assuming that we're building a library.\n+// What we should do is parse the crate and infer whether it's a library\n+// from the absence or presence of a main fn\n     let out_file = out_dir.push(os::dll_filename(short_name));\n+    let building_library = true;\n \n     debug!(\"compiling %s into %s\",\n            in_file.to_str(),\n            out_file.to_str());\n \n     let binary = os::args()[0];\n-    let matches = getopts(flags, driver::optgroups()).get();\n+\n+    debug!(\"flags: %s\", str::connect(flags, ~\" \"));\n+    debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n+// Again, we assume we're building a library\n+    let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n+                          + if building_library { ~[~\"--lib\"] } else { ~[] }\n+                          + flags\n+                          + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n+                          driver::optgroups()).get();\n     let options = @session::options {\n-        crate_type: session::unknown_crate,\n+        crate_type: if building_library { session::lib_crate }\n+                    else { session::bin_crate },\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n         maybe_sysroot: sysroot,\n+        addl_lib_search_paths: ~[copy *out_dir],\n         .. *driver::build_session_options(binary, &matches, diagnostic::emit)\n     };\n     let mut crate_cfg = options.cfg;\n@@ -631,94 +477,42 @@ pub fn compile_input(sysroot: Option<Path>,\n \n     let options = @session::options {\n         cfg: vec::append(options.cfg, crate_cfg),\n+        // output_type should be conditional\n+        output_type: output_type_exe, // Use this to get a library? That's weird\n         .. *options\n     };\n     let sess = driver::build_session(options, diagnostic::emit);\n-    let cfg = driver::build_configuration(sess, binary, input);\n-    let mut outputs = driver::build_output_filenames(input, &None, &None,\n-                                                     sess);\n-    let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n-                                          Some(outputs));\n-\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut crate_type = None;\n-\n-    fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                                   Option<~str>) {\n-        let mut name = None;\n-        let mut vers = None;\n-\n-        for mis.each |a| {\n-            match a.node {\n-                ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n-                                         span: _}) => {\n-                    match *v {\n-                        ~\"name\" => name = Some(*s),\n-                        ~\"vers\" => vers = Some(*s),\n-                        _ => { }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        (name, vers)\n-    }\n-\n-    for crate.node.attrs.each |a| {\n-        match a.node.value.node {\n-            ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n-                                     span: _}) => {\n-                match *v {\n-                    ~\"crate_type\" => crate_type = Some(*s),\n-                    _ => {}\n-                }\n-            }\n-            ast::meta_list(v, mis) => {\n-                match *v {\n-                    ~\"link\" => {\n-                        let (n, v) = load_link_attr(mis);\n-\n-                        name = n;\n-                        vers = v;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n \n-    let is_bin = match crate_type {\n-        Some(crate_type) => {\n-            match crate_type {\n-                ~\"bin\" => true,\n-                ~\"lib\" => false,\n-                _ => {\n-                    warn(~\"unknown crate_type, falling back to lib\");\n+    debug!(\"calling compile_crate_from_input, out_dir = %s,\n+           building_library = %?\", out_dir.to_str(), sess.building_library);\n+    compile_crate_from_input(input, Some(*out_dir), sess, None, binary);\n+    true\n+}\n \n-                    false\n-                }\n-            }\n+// Should use workcache to avoid recompiling when not necessary\n+// Should also rename this to something better\n+// If crate_opt is present, then finish compilation. If it's None, then\n+// call compile_upto and return the crate\n+pub fn compile_crate_from_input(input: driver::input, build_dir_opt: Option<Path>,\n+    sess: session::Session, crate_opt: Option<@ast::crate>,\n+                                binary: ~str) -> @ast::crate {\n+    debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n+    let outputs = driver::build_output_filenames(input, &build_dir_opt, &None, sess);\n+    debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n+    let cfg = driver::build_configuration(sess, binary, input);\n+    match crate_opt {\n+        Some(c) => {\n+            debug!(\"Calling compile_rest, outputs = %?\", outputs);\n+            driver::compile_rest(sess, cfg, driver::cu_everything, Some(outputs), Some(c));\n+            c\n         }\n         None => {\n-            warn(~\"missing crate_type attr, assuming lib\");\n-\n-            false\n+            debug!(\"Calling compile_upto, outputs = %?\", outputs);\n+            let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n+                                                  Some(outputs));\n+            crate\n         }\n-    };\n-\n-    outputs = driver::build_output_filenames(input,\n-                                             &Some(copy *out_dir),\n-                                             &Some(out_file),\n-                                             sess);\n-\n-    driver::compile_rest(sess, cfg, driver::cu_everything,\n-                         Some(outputs),\n-                         Some(crate));\n-\n-    true\n+    }\n }\n \n #[cfg(windows)]\n@@ -731,13 +525,20 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n \n+// Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n                      flags: ~[~str], cfgs: ~[~str], opt: bool,\n                      test: bool) -> bool {\n+    debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n+    debug!(\"compile_crate: flags =...\");\n+    for flags.each |&fl| {\n+        debug!(\"+++ %s\", fl);\n+    }\n     compile_input(sysroot, crate, dir, flags, cfgs, opt, test)\n }\n \n+\n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n     /* FIXME (#1768): Investigate how to do this on win32"}]}