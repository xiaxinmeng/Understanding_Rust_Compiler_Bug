{"sha": "285a40a90691d1f3129bebcead8c6f83363d7c83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NWE0MGE5MDY5MWQxZjMxMjliZWJjZWFkOGM2ZjgzMzYzZDdjODM=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-03-31T02:50:42Z"}, "committer": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-03-31T03:01:31Z"}, "message": "Make HashMap's RawBucket covariant", "tree": {"sha": "cd3163c0f86738f32f3b942ab02e9ede52c1ac32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd3163c0f86738f32f3b942ab02e9ede52c1ac32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/285a40a90691d1f3129bebcead8c6f83363d7c83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/285a40a90691d1f3129bebcead8c6f83363d7c83", "html_url": "https://github.com/rust-lang/rust/commit/285a40a90691d1f3129bebcead8c6f83363d7c83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/285a40a90691d1f3129bebcead8c6f83363d7c83/comments", "author": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30a3849f228833f9dc280120126d16aef3a292ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a3849f228833f9dc280120126d16aef3a292ba", "html_url": "https://github.com/rust-lang/rust/commit/30a3849f228833f9dc280120126d16aef3a292ba"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "cf64e5d333639c5f11d88b854bcfa418cc81029b", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/285a40a90691d1f3129bebcead8c6f83363d7c83/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285a40a90691d1f3129bebcead8c6f83363d7c83/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=285a40a90691d1f3129bebcead8c6f83363d7c83", "patch": "@@ -75,8 +75,10 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n     hash: *mut u64,\n-    key:  *mut K,\n-    val:  *mut V,\n+\n+    // We use *const to ensure covariance with respect to K and V\n+    key:  *const K,\n+    val:  *const V,\n     _marker: marker::PhantomData<(K,V)>,\n }\n \n@@ -354,8 +356,8 @@ impl<K, V, M> EmptyBucket<K, V, M> where M: Put<K, V> {\n                -> FullBucket<K, V, M> {\n         unsafe {\n             *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.key, key);\n-            ptr::write(self.raw.val, value);\n+            ptr::write(self.raw.key as *mut K, key);\n+            ptr::write(self.raw.val as *mut V, value);\n \n             self.table.borrow_table_mut().size += 1;\n         }\n@@ -453,8 +455,8 @@ impl<K, V, M> FullBucket<K, V, M> where M: Put<K, V> {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let old_key  = ptr::replace(self.raw.key,  k);\n-            let old_val  = ptr::replace(self.raw.val,  v);\n+            let old_key  = ptr::replace(self.raw.key as *mut K,  k);\n+            let old_val  = ptr::replace(self.raw.val as *mut V,  v);\n \n             (old_hash, old_key, old_val)\n         }\n@@ -465,8 +467,8 @@ impl<K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefM\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n         unsafe {\n-            (&mut *self.raw.key,\n-             &mut *self.raw.val)\n+            (&mut *(self.raw.key as *mut K),\n+             &mut *(self.raw.val as *mut V))\n         }\n     }\n }\n@@ -490,8 +492,8 @@ impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + De\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n         unsafe {\n-            (&mut *self.raw.key,\n-             &mut *self.raw.val)\n+            (&mut *(self.raw.key as *mut K),\n+             &mut *(self.raw.val as *mut V))\n         }\n     }\n }\n@@ -505,8 +507,8 @@ impl<K, V, M> GapThenFull<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key, 1);\n-            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key as *mut K, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val as *mut V, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -649,7 +651,7 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = *self.hashes as *mut u8;\n+        let buffer = *self.hashes as *const u8;\n         let (keys_offset, vals_offset, oflo) =\n             calculate_offsets(hashes_size,\n                               keys_size, align_of::<K>(),\n@@ -658,8 +660,8 @@ impl<K, V> RawTable<K, V> {\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n-                key:  buffer.offset(keys_offset as isize) as *mut K,\n-                val:  buffer.offset(vals_offset as isize) as *mut V,\n+                key:  buffer.offset(keys_offset as isize) as *const K,\n+                val:  buffer.offset(vals_offset as isize) as *const V,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -707,6 +709,7 @@ impl<K, V> RawTable<K, V> {\n         IterMut {\n             iter: self.raw_buckets(),\n             elems_left: self.size(),\n+            _marker: marker::PhantomData,\n         }\n     }\n \n@@ -858,6 +861,8 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n     elems_left: usize,\n+    // To ensure invariance with respect to V\n+    _marker: marker::PhantomData<&'a mut V>,\n }\n \n unsafe impl<'a, K: Sync, V: Sync> Sync for IterMut<'a, K, V> {}\n@@ -912,7 +917,7 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n             self.elems_left -= 1;\n             unsafe {\n                 (&*bucket.key,\n-                 &mut *bucket.val)\n+                 &mut *(bucket.val as *mut V))\n             }\n         })\n     }\n@@ -1003,8 +1008,8 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.key, k);\n-                            ptr::write(new_buckets.raw.val, v);\n+                            ptr::write(new_buckets.raw.key as *mut K, k);\n+                            ptr::write(new_buckets.raw.val as *mut V, v);\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;"}]}