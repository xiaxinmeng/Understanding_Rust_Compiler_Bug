{"sha": "e696188672be804889f012e19b1c799cc59adee2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OTYxODg2NzJiZTgwNDg4OWYwMTJlMTliMWM3OTljYzU5YWRlZTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T12:43:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T12:43:59Z"}, "message": "fix: don't use display-related functionality where semantics matters\n\nNavigationTarget is strictly a UI-level thing -- it describes where the\ncursor should be placed when the user presses goto definition. It\ndoesn't make any semantic guaratees about rage and focus range and, as\nsuch, is not suitable for driving renames.", "tree": {"sha": "c7eb9b10b0122c5a39a66b2c044743d8d067218c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7eb9b10b0122c5a39a66b2c044743d8d067218c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e696188672be804889f012e19b1c799cc59adee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e696188672be804889f012e19b1c799cc59adee2", "html_url": "https://github.com/rust-lang/rust/commit/e696188672be804889f012e19b1c799cc59adee2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e696188672be804889f012e19b1c799cc59adee2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a274ae384e38be5ad1b23cd2b7f2120e5a284209", "url": "https://api.github.com/repos/rust-lang/rust/commits/a274ae384e38be5ad1b23cd2b7f2120e5a284209", "html_url": "https://github.com/rust-lang/rust/commit/a274ae384e38be5ad1b23cd2b7f2120e5a284209"}], "stats": {"total": 160, "additions": 119, "deletions": 41}, "files": [{"sha": "e1ed6de3525cbf1fb2515db66749f77e3139ee09", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 119, "deletions": 41, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e696188672be804889f012e19b1c799cc59adee2/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e696188672be804889f012e19b1c799cc59adee2/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=e696188672be804889f012e19b1c799cc59adee2", "patch": "@@ -5,9 +5,9 @@\n use std::fmt::{self, Display};\n \n use either::Either;\n-use hir::{AsAssocItem, InFile, Module, ModuleDef, ModuleSource, Semantics};\n+use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId},\n+    base_db::{AnchoredPathBuf, FileId, FileRange},\n     defs::{Definition, NameClass, NameRefClass},\n     search::FileReference,\n     RootDatabase,\n@@ -20,7 +20,7 @@ use syntax::{\n \n use text_edit::TextEdit;\n \n-use crate::{display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n+use crate::{FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n \n type RenameResult<T> = Result<T, RenameError>;\n #[derive(Debug)]\n@@ -52,26 +52,9 @@ pub(crate) fn prepare_rename(\n     let syntax = source_file.syntax();\n \n     let def = find_definition(&sema, syntax, position)?;\n-    match def {\n-        Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(ModuleDef::BuiltinType(_)) => bail!(\"Cannot rename builtin type\"),\n-        Definition::ModuleDef(ModuleDef::Module(_)) => (),\n-        _ => {\n-            let nav = def\n-                .try_to_nav(sema.db)\n-                .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-            nav.focus_range.ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-        }\n-    };\n-    let name_like = sema\n-        .find_node_at_offset_with_descend(syntax, position.offset)\n+    let frange = def_name_range(&&sema, def)\n         .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-    let node = match &name_like {\n-        ast::NameLike::Name(it) => it.syntax(),\n-        ast::NameLike::NameRef(it) => it.syntax(),\n-        ast::NameLike::Lifetime(it) => it.syntax(),\n-    };\n-    Ok(RangeInfo::new(sema.original_range(node).range, ()))\n+    Ok(RangeInfo::new(frange.range, ()))\n }\n \n // Feature: Rename\n@@ -104,9 +87,11 @@ pub(crate) fn rename_with_semantics(\n \n     let def = find_definition(sema, syntax, position)?;\n     match def {\n-        Definition::ModuleDef(ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n         Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(ModuleDef::BuiltinType(_)) => bail!(\"Cannot rename builtin type\"),\n+        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            bail!(\"Cannot rename builtin type\")\n+        }\n         def => rename_reference(sema, def, new_name),\n     }\n }\n@@ -194,7 +179,7 @@ fn find_definition(\n \n fn rename_mod(\n     sema: &Semantics<RootDatabase>,\n-    module: Module,\n+    module: hir::Module,\n     new_name: &str,\n ) -> RenameResult<SourceChange> {\n     if IdentifierKind::Ident != check_identifier(new_name)? {\n@@ -227,7 +212,7 @@ fn rename_mod(\n             _ => never!(\"Module source node is missing a name\"),\n         }\n     }\n-    let def = Definition::ModuleDef(ModuleDef::Module(module));\n+    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n         (file_id, source_edit_from_references(references, def, new_name))\n@@ -293,21 +278,21 @@ fn rename_reference(\n             .and_then(|it| it.containing_trait_impl(sema.db))\n             .and_then(|it| {\n                 it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n-                    (hir::AssocItem::Function(trait_func), ModuleDef::Function(func))\n+                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n                         if trait_func.name(sema.db) == func.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(ModuleDef::Function(trait_func)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n                     }\n-                    (hir::AssocItem::Const(trait_konst), ModuleDef::Const(konst))\n+                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n                         if trait_konst.name(sema.db) == konst.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(ModuleDef::Const(trait_konst)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n                     }\n                     (\n                         hir::AssocItem::TypeAlias(trait_type_alias),\n-                        ModuleDef::TypeAlias(type_alias),\n+                        hir::ModuleDef::TypeAlias(type_alias),\n                     ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::ModuleDef(ModuleDef::TypeAlias(trait_type_alias)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n                     }\n                     _ => None,\n                 })\n@@ -557,12 +542,11 @@ fn source_edit_from_def(\n     def: Definition,\n     new_name: &str,\n ) -> RenameResult<(FileId, TextEdit)> {\n-    let nav =\n-        def.try_to_nav(sema.db).ok_or_else(|| format_err!(\"No references found at position\"))?;\n+    let frange: FileRange = def_name_range(sema, def)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n \n     let mut replacement_text = String::new();\n-    let mut repl_range =\n-        nav.focus_range.ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+    let mut repl_range = frange.range;\n     if let Definition::Local(local) = def {\n         if let Either::Left(pat) = local.source(sema.db).value {\n             if matches!(\n@@ -582,7 +566,101 @@ fn source_edit_from_def(\n         replacement_text.push_str(new_name);\n     }\n     let edit = TextEdit::replace(repl_range, replacement_text);\n-    Ok((nav.file_id, edit))\n+    Ok((frange.file_id, edit))\n+}\n+\n+fn def_name_range(sema: &Semantics<RootDatabase>, def: Definition) -> Option<FileRange> {\n+    // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n+    // and _fall back_ to the entirety of the macro call. Such fall back is\n+    // incorrect for renames. The safe behavior would be to return an error for\n+    // such cases. The correct behavior would be to return an auxiliary list of\n+    // \"can't rename these occurrences in macros\" items, and then show some kind\n+    // of a dialog to the user.\n+\n+    let res = match def {\n+        Definition::Macro(mac) => {\n+            let src = mac.source(sema.db)?;\n+            let name = match &src.value {\n+                Either::Left(it) => it.name()?,\n+                Either::Right(it) => it.name()?,\n+            };\n+            src.with_value(name.syntax()).original_file_range(sema.db)\n+        }\n+        Definition::Field(field) => {\n+            let src = field.source(sema.db)?;\n+\n+            match &src.value {\n+                FieldSource::Named(record_field) => {\n+                    let name = record_field.name()?;\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                FieldSource::Pos(_) => {\n+                    return None;\n+                }\n+            }\n+        }\n+        Definition::ModuleDef(module_def) => match module_def {\n+            hir::ModuleDef::Module(module) => {\n+                let src = module.declaration_source(sema.db)?;\n+                let name = src.value.name()?;\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            hir::ModuleDef::Function(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Adt(adt) => match adt {\n+                hir::Adt::Struct(it) => name_range(it, sema)?,\n+                hir::Adt::Union(it) => name_range(it, sema)?,\n+                hir::Adt::Enum(it) => name_range(it, sema)?,\n+            },\n+            hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Const(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Static(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n+            hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n+            hir::ModuleDef::BuiltinType(_) => return None,\n+        },\n+        Definition::SelfType(_) => return None,\n+        Definition::Local(local) => {\n+            let src = local.source(sema.db);\n+            let name = match &src.value {\n+                Either::Left(bind_pat) => bind_pat.name()?,\n+                Either::Right(_) => return None,\n+            };\n+            src.with_value(name.syntax()).original_file_range(sema.db)\n+        }\n+        Definition::GenericParam(generic_param) => match generic_param {\n+            hir::GenericParam::TypeParam(type_param) => {\n+                let src = type_param.source(sema.db)?;\n+                let name = match &src.value {\n+                    Either::Left(_) => return None,\n+                    Either::Right(type_param) => type_param.name()?,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            hir::GenericParam::LifetimeParam(lifetime_param) => {\n+                let src = lifetime_param.source(sema.db)?;\n+                let lifetime = src.value.lifetime()?;\n+                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+            }\n+            hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n+        },\n+        Definition::Label(label) => {\n+            let src = label.source(sema.db);\n+            let lifetime = src.value.lifetime()?;\n+            src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+        }\n+    };\n+    return Some(res);\n+\n+    fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n+    where\n+        D: HasSource,\n+        D::Ast: ast::NameOwner,\n+    {\n+        let src = def.source(sema.db)?;\n+        let name = src.value.name()?;\n+        let res = src.with_value(name.syntax()).original_file_range(sema.db);\n+        Some(res)\n+    }\n }\n \n #[cfg(test)]\n@@ -659,7 +737,7 @@ mod tests {\n     fn test_prepare_rename_namelikes() {\n         check_prepare(r\"fn name$0<'lifetime>() {}\", expect![[r#\"3..7: name\"#]]);\n         check_prepare(r\"fn name<'lifetime$0>() {}\", expect![[r#\"8..17: 'lifetime\"#]]);\n-        check_prepare(r\"fn name<'lifetime>() { name$0(); }\", expect![[r#\"23..27: name\"#]]);\n+        check_prepare(r\"fn name<'lifetime>() { name$0(); }\", expect![[r#\"3..7: name\"#]]);\n     }\n \n     #[test]\n@@ -691,7 +769,7 @@ fn baz() {\n     x.0$0 = 5;\n }\n \"#,\n-            expect![[r#\"No identifier available to rename\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n \n@@ -703,7 +781,7 @@ fn foo() {\n     let x: i32$0 = 0;\n }\n \"#,\n-            expect![[r#\"Cannot rename builtin type\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n \n@@ -719,7 +797,7 @@ impl Foo {\n     }\n }\n \"#,\n-            expect![[r#\"Cannot rename `Self`\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n "}]}