{"sha": "9fae1537462bb10fd17d07816efc17cfe4786806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWUxNTM3NDYyYmIxMGZkMTdkMDc4MTZlZmMxN2NmZTQ3ODY4MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T17:07:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T17:07:38Z"}, "message": "Auto merge of #49835 - da-x:literal-fragment-pr, r=petrochenkov\n\nMacros: Add a 'literal' fragment specifier\n\nSee: https://github.com/rust-lang/rust/issues/35625\n\n```rust\n\nmacro_rules! test_literal {\n    ($l:literal) => {\n        println!(\"literal: {}\", $l);\n    };\n    ($e:expr) => {\n        println!(\"expr: {}\", $e);\n    };\n}\n\nfn main() {\n    let a = 1;\n    test_literal!(a);\n    test_literal!(2);\n    test_literal!(-3);\n}\n```\n\nOutput:\n\n```\nexpr: 1\nliteral: 2\nliteral: -3\n```\n\nToDo:\n\n* [x] Feature gate\n* [x] Basic tests\n* [x] Tests for range patterns\n* [x] Tests for attributes\n* [x] Documentation\n* [x] Fix for `true`/`false`\n* [x] Fix for negative number literals", "tree": {"sha": "27b8125e37ecd34720f6cee3286e821c6a6df96d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27b8125e37ecd34720f6cee3286e821c6a6df96d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fae1537462bb10fd17d07816efc17cfe4786806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fae1537462bb10fd17d07816efc17cfe4786806", "html_url": "https://github.com/rust-lang/rust/commit/9fae1537462bb10fd17d07816efc17cfe4786806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fae1537462bb10fd17d07816efc17cfe4786806/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e955a058108fcadf0a8222de5868b0c905534d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e955a058108fcadf0a8222de5868b0c905534d5", "html_url": "https://github.com/rust-lang/rust/commit/3e955a058108fcadf0a8222de5868b0c905534d5"}, {"sha": "37ed2ab91038567bafe3fd2e545c7d1631ff2ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ed2ab91038567bafe3fd2e545c7d1631ff2ab0", "html_url": "https://github.com/rust-lang/rust/commit/37ed2ab91038567bafe3fd2e545c7d1631ff2ab0"}], "stats": {"total": 266, "additions": 251, "deletions": 15}, "files": [{"sha": "7e3638fd1cf4c1d1362320d0efcab2323491a341", "filename": "src/doc/unstable-book/src/language-features/macro-literal-matcher.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -0,0 +1,17 @@\n+# `macro_literal_matcher`\n+\n+The tracking issue for this feature is: [#35625]\n+\n+The RFC is: [rfc#1576].\n+\n+With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n+\n+* `literal`: a literal. Examples: 2, \"string\", 'c'\n+\n+A `literal` may be followed by anything, similarly to the `ident` specifier.\n+\n+[rfc#1576]: http://rust-lang.github.io/rfcs/1576-macros-literal-matcher.html\n+[#35625]: https://github.com/rust-lang/rust/issues/35625\n+[frags]: ../book/first-edition/macros.html#syntactic-requirements\n+\n+------------------------"}, {"sha": "4789e2e50ca540cc2d99f565b4bb330c07652302", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -114,7 +114,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// matches '-' lit | lit (cf. parser::Parser::parse_pat_literal_maybe_minus),\n+    /// matches '-' lit | lit (cf. parser::Parser::parse_literal_maybe_minus),\n     /// or path for ranges.\n     ///\n     /// FIXME: do we want to allow expr -> pattern conversion to create path expressions?"}, {"sha": "fcda6ce9b164deb00384bcba5b31aba3bc6332db", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -1348,7 +1348,7 @@ impl LitKind {\n             Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n             Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n             Token::Interpolated(ref nt) => match nt.0 {\n-                token::NtExpr(ref v) => match v.node {\n+                token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n                     _ => None,\n                 },"}, {"sha": "f0339b89839c1609dc853f5bf63c1eb7693f658c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -735,6 +735,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n         \"expr\" => token.can_begin_expr(),\n         \"ty\" => token.can_begin_type(),\n         \"ident\" => get_macro_ident(token).is_some(),\n+        \"literal\" => token.can_begin_literal_or_bool(),\n         \"vis\" => match *token {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n             Token::Comma | Token::Ident(..) | Token::Interpolated(_) => true,\n@@ -821,6 +822,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n+        \"literal\" => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {"}, {"sha": "1fc5aed7e7a23896c823f16b154582ec93c3f5e5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -647,7 +647,7 @@ fn check_matcher_core(sess: &ParseSess,\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n                         .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n-                              `pat`, `ty`, `path`, `meta`, `tt`, `item` and `vis`\")\n+                              `pat`, `ty`, `literal`, `path`, `meta`, `tt`, `item` and `vis`\")\n                         .emit();\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n@@ -784,6 +784,7 @@ fn frag_can_be_followed_by_any(frag: &str) -> bool {\n         \"item\"     | // always terminated by `}` or `;`\n         \"block\"    | // exactly one token tree\n         \"ident\"    | // exactly one token tree\n+        \"literal\"  | // exactly one token tree\n         \"meta\"     | // exactly one token tree\n         \"lifetime\" | // exactly one token tree\n         \"tt\" =>   // exactly one token tree\n@@ -850,6 +851,10 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 // being a single token, idents and lifetimes are harmless\n                 Ok(true)\n             },\n+            \"literal\" => {\n+                // literals may be of a single token, or two tokens (negative numbers)\n+                Ok(true)\n+            },\n             \"meta\" | \"tt\" => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n@@ -873,7 +878,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n             _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n                      \"valid fragment specifiers are `ident`, `block`, \\\n                       `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n-                      `item` and `vis`\"))\n+                      `literal`, `item` and `vis`\"))\n         }\n     }\n }\n@@ -913,6 +918,18 @@ fn is_legal_fragment_specifier(sess: &ParseSess,\n             }\n             true\n         },\n+        \"literal\" => {\n+            if !features.macro_literal_matcher &&\n+               !attr::contains_name(attrs, \"allow_internal_unstable\") {\n+                let explain = feature_gate::EXPLAIN_LITERAL_MATCHER;\n+                emit_feature_err(sess,\n+                                 \"macro_literal_matcher\",\n+                                 frag_span,\n+                                 GateIssue::Language,\n+                                 explain);\n+            }\n+            true\n+        },\n         \"vis\" => {\n             if !features.macro_vis_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {"}, {"sha": "562705462e2a4fc2fb8ef6c464ef9826c3e79e85", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -463,6 +463,9 @@ declare_features! (\n \n     // Scoped attributes\n     (active, tool_attributes, \"1.25.0\", Some(44690), None),\n+\n+    // Allows use of the :literal macro fragment specifier (RFC 1576)\n+    (active, macro_literal_matcher, \"1.27.0\", Some(35625), None),\n );\n \n declare_features! (\n@@ -1331,6 +1334,9 @@ pub const EXPLAIN_VIS_MATCHER: &'static str =\n pub const EXPLAIN_LIFETIME_MATCHER: &'static str =\n     \":lifetime fragment specifier is experimental and subject to change\";\n \n+pub const EXPLAIN_LITERAL_MATCHER: &'static str =\n+    \":literal fragment specifier is experimental and subject to change\";\n+\n pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n     \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n "}, {"sha": "d67995761f6271c2c04e79dc7dd0b64a10fad732", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -635,6 +635,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n         token::NtIdent(ident, is_raw) => token::NtIdent(fld.fold_ident(ident), is_raw),\n         token::NtLifetime(ident) => token::NtLifetime(fld.fold_ident(ident)),\n+        token::NtLiteral(expr) => token::NtLiteral(fld.fold_expr(expr)),\n         token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),"}, {"sha": "3f0df6d055b76b656ea100521220fe7cd8b09de3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -115,7 +115,7 @@ macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n         if let token::Interpolated(nt) = $p.token.clone() {\n             match nt.0 {\n-                token::NtExpr(ref e) => {\n+                token::NtExpr(ref e) | token::NtLiteral(ref e) => {\n                     $p.bump();\n                     return Ok((*e).clone());\n                 }\n@@ -1823,7 +1823,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n         let out = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n-                token::NtExpr(ref v) => match v.node {\n+                token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => { lit.node.clone() }\n                     _ => { return self.unexpected_last(&self.token); }\n                 },\n@@ -1862,7 +1862,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches '-' lit | lit (cf. ast_validation::AstValidator::check_expr_within_pat)\n-    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let minus_lo = self.span;\n@@ -2407,10 +2407,10 @@ impl<'a> Parser<'a> {\n                     hi = pth.span;\n                     ex = ExprKind::Path(None, pth);\n                 } else {\n-                    match self.parse_lit() {\n-                        Ok(lit) => {\n-                            hi = lit.span;\n-                            ex = ExprKind::Lit(P(lit));\n+                    match self.parse_literal_maybe_minus() {\n+                        Ok(expr) => {\n+                            hi = expr.span;\n+                            ex = expr.node.clone();\n                         }\n                         Err(mut err) => {\n                             self.cancel(&mut err);\n@@ -3724,7 +3724,7 @@ impl<'a> Parser<'a> {\n             let hi = self.prev_span;\n             Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n-            self.parse_pat_literal_maybe_minus()\n+            self.parse_literal_maybe_minus()\n         }\n     }\n \n@@ -3914,7 +3914,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n-                match self.parse_pat_literal_maybe_minus() {\n+                match self.parse_literal_maybe_minus() {\n                     Ok(begin) => {\n                         if self.eat(&token::DotDotDot) {\n                             let end = self.parse_pat_range_end()?;"}, {"sha": "6bcc1b0f02691d2b56494fe28683f1fc9a7cfd8d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -280,7 +280,12 @@ impl Token {\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match nt.0 {\n-                NtIdent(..) | NtExpr(..) | NtBlock(..) | NtPath(..) | NtLifetime(..) => true,\n+                NtLiteral(..) |\n+                NtIdent(..)   |\n+                NtExpr(..)    |\n+                NtBlock(..)   |\n+                NtPath(..)    |\n+                NtLifetime(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -324,6 +329,18 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token is any literal, a minus (which can follow a literal,\n+    /// for example a '-42', or one of the boolean idents).\n+    pub fn can_begin_literal_or_bool(&self) -> bool {\n+        match *self {\n+            Literal(..)  => true,\n+            BinOp(Minus) => true,\n+            Ident(ident, false) if ident.name == keywords::True.name() => true,\n+            Ident(ident, false) if ident.name == keywords::False.name() => true,\n+            _            => false,\n+        }\n+    }\n+\n     /// Returns an identifier if this token is an identifier.\n     pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n         match *self {\n@@ -672,6 +689,7 @@ pub enum Nonterminal {\n     NtTy(P<ast::Ty>),\n     NtIdent(ast::Ident, /* is_raw */ bool),\n     NtLifetime(ast::Ident),\n+    NtLiteral(P<ast::Expr>),\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n@@ -713,6 +731,7 @@ impl fmt::Debug for Nonterminal {\n             NtExpr(..) => f.pad(\"NtExpr(..)\"),\n             NtTy(..) => f.pad(\"NtTy(..)\"),\n             NtIdent(..) => f.pad(\"NtIdent(..)\"),\n+            NtLiteral(..) => f.pad(\"NtLiteral(..)\"),\n             NtMeta(..) => f.pad(\"NtMeta(..)\"),\n             NtPath(..) => f.pad(\"NtPath(..)\"),\n             NtTT(..) => f.pad(\"NtTT(..)\"),"}, {"sha": "99a6fcf170dcb9de685737e3f48bb20c47fc592a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -273,6 +273,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtIdent(e, false)    => ident_to_string(e),\n             token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n             token::NtLifetime(e)        => ident_to_string(e),\n+            token::NtLiteral(ref e)     => expr_to_string(e),\n             token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n             token::NtArm(ref e)         => arm_to_string(e),\n             token::NtImplItem(ref e)    => impl_item_to_string(e),"}, {"sha": "0bcda7bc1447aa2b112ac25ed6687136c90cc645", "filename": "src/test/run-pass/macro-literal.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Frun-pass%2Fmacro-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Frun-pass%2Fmacro-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-literal.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_literal_matcher)]\n+\n+macro_rules! mtester {\n+    ($l:literal) => {\n+        &format!(\"macro caught literal: {}\", $l)\n+    };\n+    ($e:expr) => {\n+        &format!(\"macro caught expr: {}\", $e)\n+    };\n+}\n+\n+macro_rules! two_negative_literals {\n+    ($l1:literal $l2:literal) => {\n+        &format!(\"macro caught literals: {}, {}\", $l1, $l2)\n+    };\n+}\n+\n+macro_rules! only_expr {\n+    ($e:expr) => {\n+        &format!(\"macro caught expr: {}\", $e)\n+    };\n+}\n+\n+macro_rules! mtester_dbg {\n+    ($l:literal) => {\n+        &format!(\"macro caught literal: {:?}\", $l)\n+    };\n+    ($e:expr) => {\n+        &format!(\"macro caught expr: {:?}\", $e)\n+    };\n+}\n+\n+macro_rules! catch_range {\n+    ($s:literal ... $e:literal) => {\n+        &format!(\"macro caught literal: {} ... {}\", $s, $e)\n+    };\n+    (($s:expr) ... ($e:expr)) => { // Must use ')' before '...'\n+        &format!(\"macro caught expr: {} ... {}\", $s, $e)\n+    };\n+}\n+\n+macro_rules! pat_match {\n+    ($s:literal ... $e:literal) => {\n+        match 3 {\n+            $s ... $e => \"literal, in range\",\n+            _ => \"literal, other\",\n+        }\n+    };\n+    ($s:pat) => {\n+        match 3 {\n+            $s => \"pat, single\",\n+            _ => \"pat, other\",\n+        }\n+    };\n+}\n+\n+macro_rules! match_attr {\n+    (#[$attr:meta] $e:literal) => {\n+        \"attr matched literal\"\n+    };\n+    (#[$attr:meta] $e:expr) => {\n+        \"attr matched expr\"\n+    };\n+}\n+\n+macro_rules! match_produced_attr {\n+    ($lit: literal) => {\n+        // Struct with doc comment passed via $literal\n+        #[doc = $lit]\n+        struct LiteralProduced;\n+    };\n+    ($expr: expr) => {\n+        struct ExprProduced;\n+    };\n+}\n+\n+macro_rules! test_user {\n+    ($s:literal, $e:literal) => {\n+        {\n+            let mut v = Vec::new();\n+            for i in $s .. $e {\n+                v.push(i);\n+            }\n+            \"literal\"\n+        }\n+    };\n+    ($s:expr, $e: expr) => {\n+        {\n+            let mut v = Vec::new();\n+            for i in $s .. $e {\n+                v.push(i);\n+            }\n+            \"expr\"\n+        }\n+    };\n+}\n+\n+pub fn main() {\n+    // Cases where 'literal' catches\n+    assert_eq!(mtester!(\"str\"), \"macro caught literal: str\");\n+    assert_eq!(mtester!(2), \"macro caught literal: 2\");\n+    assert_eq!(mtester!(2.2), \"macro caught literal: 2.2\");\n+    assert_eq!(mtester!(1u32), \"macro caught literal: 1\");\n+    assert_eq!(mtester!(0x32), \"macro caught literal: 50\");\n+    assert_eq!(mtester!('c'), \"macro caught literal: c\");\n+    assert_eq!(mtester!(-1.2), \"macro caught literal: -1.2\");\n+    assert_eq!(two_negative_literals!(-2 -3), \"macro caught literals: -2, -3\");\n+    assert_eq!(catch_range!(2 ... 3), \"macro caught literal: 2 ... 3\");\n+    assert_eq!(match_attr!(#[attr] 1), \"attr matched literal\");\n+    assert_eq!(test_user!(10, 20), \"literal\");\n+    assert_eq!(mtester!(false), \"macro caught literal: false\");\n+    assert_eq!(mtester!(true), \"macro caught literal: true\");\n+    match_produced_attr!(\"a\");\n+    let _a = LiteralProduced;\n+    assert_eq!(pat_match!(1 ... 3), \"literal, in range\");\n+    assert_eq!(pat_match!(4 ... 6), \"literal, other\");\n+\n+    // Cases where 'expr' catches\n+    assert_eq!(mtester!((-1.2)), \"macro caught expr: -1.2\");\n+    assert_eq!(only_expr!(-1.2), \"macro caught expr: -1.2\");\n+    assert_eq!(mtester!((1 + 3)), \"macro caught expr: 4\");\n+    assert_eq!(mtester_dbg!(()), \"macro caught expr: ()\");\n+    assert_eq!(catch_range!((1 + 1) ... (2 + 2)), \"macro caught expr: 2 ... 4\");\n+    assert_eq!(match_attr!(#[attr] (1 + 2)), \"attr matched expr\");\n+    assert_eq!(test_user!(10, (20 + 2)), \"expr\");\n+\n+    match_produced_attr!((3 + 2));\n+    let _b = ExprProduced;\n+\n+    // Cases where 'pat' matched\n+    assert_eq!(pat_match!(3), \"pat, single\");\n+    assert_eq!(pat_match!(6), \"pat, other\");\n+}"}, {"sha": "db5cca193ab4eb1dbcba2ab9dcb6434bdb3420a0", "filename": "src/test/ui/feature-gate-macro-literal-matcher.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.rs?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the :lifetime macro fragment cannot be used when macro_lifetime_matcher\n+// feature gate is not used.\n+\n+macro_rules! m { ($lt:literal) => {} }\n+//~^ ERROR :literal fragment specifier is experimental and subject to change\n+\n+fn main() {\n+    m!(\"some string literal\");\n+}"}, {"sha": "f714b916966a14f3dba755d939e408169d263a6d", "filename": "src/test/ui/feature-gate-macro-literal-matcher.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro-literal-matcher.stderr?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: :literal fragment specifier is experimental and subject to change (see issue #35625)\n+  --> $DIR/feature-gate-macro-literal-matcher.rs:14:19\n+   |\n+LL | macro_rules! m { ($lt:literal) => {} }\n+   |                   ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(macro_literal_matcher)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "765621f51d4fdbba999cb93c6f71e1171a8d065b", "filename": "src/test/ui/macro-invalid-fragment-spec.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Fmacro-invalid-fragment-spec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fae1537462bb10fd17d07816efc17cfe4786806/src%2Ftest%2Fui%2Fmacro-invalid-fragment-spec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-invalid-fragment-spec.stderr?ref=9fae1537462bb10fd17d07816efc17cfe4786806", "patch": "@@ -4,7 +4,7 @@ error: invalid fragment specifier `foo`\n LL |     ($x:foo) => ()\n    |      ^^^^^^\n    |\n-   = help: valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, `item` and `vis`\n+   = help: valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `literal`, `path`, `meta`, `tt`, `item` and `vis`\n \n error: aborting due to previous error\n "}]}