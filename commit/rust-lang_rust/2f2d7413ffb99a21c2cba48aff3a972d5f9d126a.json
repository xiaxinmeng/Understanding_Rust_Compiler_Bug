{"sha": "2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMmQ3NDEzZmZiOTlhMjFjMmNiYTQ4YWZmM2E5NzJkNWY5ZDEyNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-03T10:56:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-03T10:56:42Z"}, "message": "Auto merge of #42332 - michaelwoerister:no-more-retracing, r=nikomatsakis\n\nincr.comp.: Use DefPathHash-based DepNodes in the serialized DepGraph and remove obsolete DefIdDirectory\n\nWith this PR we don't store the dep-graph as a set of `DepNode<IndexIntoDefIdDirectory>` anymore but instead as a set of `DepNode<DefPathHash>`. Since a `DefPathHash` is a global identifier that is valid across compilation sessions, we don't need the `DefIdDirectory` anymore.\n\nSince a `DepNode<DefPathHash>` is bigger than a `DepNode<IndexIntoDefIdDirectory>` and our on-disk encoding of the dep-graph is inefficient, this PR will probably increase the amount of space the dep-graph takes up on disk. I'm in the process of gathering some performance data.\n\nThe changes in here are a step towards implementing ICH-based `DepNodes` (#42294).\n\nr? @nikomatsakis", "tree": {"sha": "2a180e5b98c838c89862669c6b9e3f1deb502c11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a180e5b98c838c89862669c6b9e3f1deb502c11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "html_url": "https://github.com/rust-lang/rust/commit/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb92767801cd289ab0c62c81db172ce104b023e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb92767801cd289ab0c62c81db172ce104b023e", "html_url": "https://github.com/rust-lang/rust/commit/fbb92767801cd289ab0c62c81db172ce104b023e"}, {"sha": "a3417bf302edb5359547109bdd95d426de4e0cb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3417bf302edb5359547109bdd95d426de4e0cb2", "html_url": "https://github.com/rust-lang/rust/commit/a3417bf302edb5359547109bdd95d426de4e0cb2"}], "stats": {"total": 639, "additions": 289, "deletions": 350}, "files": [{"sha": "ced0f351c9eed630f65f4ddc01f84ceab9ed3999", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -36,7 +36,7 @@ use util::nodemap::NodeMap;\n pub struct DefPathTable {\n     index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n-    def_path_hashes: [Vec<Fingerprint>; 2],\n+    def_path_hashes: [Vec<DefPathHash>; 2],\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -57,7 +57,7 @@ impl DefPathTable {\n \n     fn allocate(&mut self,\n                 key: DefKey,\n-                def_path_hash: Fingerprint,\n+                def_path_hash: DefPathHash,\n                 address_space: DefIndexAddressSpace)\n                 -> DefIndex {\n         let index = {\n@@ -81,7 +81,7 @@ impl DefPathTable {\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> Fingerprint {\n+    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_hashes[index.address_space().index()]\n                             [index.as_array_index()]\n     }\n@@ -126,6 +126,30 @@ impl DefPathTable {\n \n         Some(index)\n     }\n+\n+    pub fn add_def_path_hashes_to(&self,\n+                                  cnum: CrateNum,\n+                                  out: &mut FxHashMap<DefPathHash, DefId>) {\n+        for address_space in &[DefIndexAddressSpace::Low, DefIndexAddressSpace::High] {\n+            let start_index = address_space.start();\n+            out.extend(\n+                (&self.def_path_hashes[address_space.index()])\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, &hash)| {\n+                        let def_id = DefId {\n+                            krate: cnum,\n+                            index: DefIndex::new(index + start_index),\n+                        };\n+                        (hash, def_id)\n+                    })\n+            );\n+        }\n+    }\n+\n+    pub fn size(&self) -> usize {\n+        self.key_to_index.len()\n+    }\n }\n \n \n@@ -148,8 +172,8 @@ impl Decodable for DefPathTable {\n         let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n         let index_to_key_hi: Vec<DefKey> = Decodable::decode(d)?;\n \n-        let def_path_hashes_lo: Vec<Fingerprint> = Decodable::decode(d)?;\n-        let def_path_hashes_hi: Vec<Fingerprint> = Decodable::decode(d)?;\n+        let def_path_hashes_lo: Vec<DefPathHash> = Decodable::decode(d)?;\n+        let def_path_hashes_hi: Vec<DefPathHash> = Decodable::decode(d)?;\n \n         let index_to_key = [index_to_key_lo, index_to_key_hi];\n         let def_path_hashes = [def_path_hashes_lo, def_path_hashes_hi];\n@@ -216,25 +240,25 @@ pub struct DefKey {\n }\n \n impl DefKey {\n-    fn compute_stable_hash(&self, parent_hash: Fingerprint) -> Fingerprint {\n+    fn compute_stable_hash(&self, parent_hash: DefPathHash) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n \n         // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n         // and the special \"root_parent\" below.\n         0u8.hash(&mut hasher);\n         parent_hash.hash(&mut hasher);\n         self.disambiguated_data.hash(&mut hasher);\n-        hasher.finish()\n+        DefPathHash(hasher.finish())\n     }\n \n-    fn root_parent_stable_hash(crate_name: &str, crate_disambiguator: &str) -> Fingerprint {\n+    fn root_parent_stable_hash(crate_name: &str, crate_disambiguator: &str) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n         // Disambiguate this from a regular DefPath hash,\n         // see compute_stable_hash() above.\n         1u8.hash(&mut hasher);\n         crate_name.hash(&mut hasher);\n         crate_disambiguator.hash(&mut hasher);\n-        hasher.finish()\n+        DefPathHash(hasher.finish())\n     }\n }\n \n@@ -296,7 +320,9 @@ impl DefPath {\n \n         s.push_str(&tcx.original_crate_name(self.krate).as_str());\n         s.push_str(\"/\");\n-        s.push_str(&tcx.crate_disambiguator(self.krate).as_str());\n+        // Don't print the whole crate disambiguator. That's just annoying in\n+        // debug output.\n+        s.push_str(&tcx.crate_disambiguator(self.krate).as_str()[..7]);\n \n         for component in &self.data {\n             write!(s,\n@@ -372,6 +398,12 @@ pub enum DefPathData {\n     Typeof,\n }\n \n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct DefPathHash(pub Fingerprint);\n+\n+impl_stable_hash_for!(tuple_struct DefPathHash { fingerprint });\n+\n impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {\n@@ -404,7 +436,7 @@ impl Definitions {\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> Fingerprint {\n+    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.table.def_path_hash(index)\n     }\n "}, {"sha": "176760c255c00f50c742dbdf1c7cf0c5246e056d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -13,7 +13,7 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData};\n+                            DisambiguatedDefPathData, DefPathHash};\n \n use dep_graph::{DepGraph, DepNode};\n "}, {"sha": "a835548894182493fed5f506a4f53fbea9ba8e29", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -10,6 +10,7 @@\n \n use hir;\n use hir::def_id::DefId;\n+use hir::map::DefPathHash;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n@@ -115,7 +116,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&mut self, def_id: DefId) -> ich::Fingerprint {\n+    pub fn def_path_hash(&mut self, def_id: DefId) -> DefPathHash {\n         self.tcx.def_path_hash(def_id)\n     }\n "}, {"sha": "71b066c6688b583e0b26c9121e9c384cba600c4c", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -26,7 +26,8 @@ use hir::def;\n use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n+use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData,\n+                            DefPathTable};\n use hir::svh::Svh;\n use ich;\n use middle::lang_items;\n@@ -281,7 +282,8 @@ pub trait CrateStore {\n                     -> Option<DefId>;\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n-    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint;\n+    fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n+    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -412,8 +414,11 @@ impl CrateStore for DummyCrateStore {\n     fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n-    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint {\n-        bug!(\"wa\")\n+    fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash {\n+        bug!(\"def_path_hash\")\n+    }\n+    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n+        bug!(\"def_path_table\")\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }"}, {"sha": "2bbb71610ad0cc583213647a0b794c83f85acb19", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -18,7 +18,7 @@ use hir::TraitMap;\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n-use hir::map::DisambiguatedDefPathData;\n+use hir::map::{DisambiguatedDefPathData, DefPathHash};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -461,6 +461,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub hir: hir_map::Map<'tcx>,\n \n+    /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n+    /// as well as all upstream crates. Only populated in incremental mode.\n+    pub def_path_hash_to_def_id: Option<FxHashMap<DefPathHash, DefId>>,\n+\n     pub maps: maps::Maps<'tcx>,\n \n     pub mir_passes: Rc<Passes>,\n@@ -686,6 +690,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n+\n+        let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n+            let upstream_def_path_tables: Vec<(CrateNum, Rc<_>)> = s\n+                .cstore\n+                .crates()\n+                .iter()\n+                .map(|&cnum| (cnum, s.cstore.def_path_table(cnum)))\n+                .collect();\n+\n+            let def_path_tables = || {\n+                upstream_def_path_tables\n+                    .iter()\n+                    .map(|&(cnum, ref rc)| (cnum, &**rc))\n+                    .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())))\n+            };\n+\n+            // Precompute the capacity of the hashmap so we don't have to\n+            // re-allocate when populating it.\n+            let capacity = def_path_tables().map(|(_, t)| t.size()).sum::<usize>();\n+\n+            let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n+                capacity,\n+                ::std::default::Default::default()\n+            );\n+\n+            for (cnum, def_path_table) in def_path_tables() {\n+                def_path_table.add_def_path_hashes_to(cnum, &mut map);\n+            }\n+\n+            Some(map)\n+        } else {\n+            None\n+        };\n+\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n             trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n@@ -699,6 +737,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n+            def_path_hash_to_def_id: def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),\n             mir_passes,\n             freevars: RefCell::new(resolutions.freevars),"}, {"sha": "e4e1ebe18823dc5aecf16a784cd86df3c890921c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -19,7 +19,7 @@ use dep_graph::DepNode;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use ich::{self, StableHashingContext};\n+use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -2167,7 +2167,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(self, def_id: DefId) -> ich::Fingerprint {\n+    pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if def_id.is_local() {\n             self.hir.definitions().def_path_hash(def_id.index)\n         } else {"}, {"sha": "6923a6d21d63f1dec1cc499cffd9154338189b66", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -11,6 +11,7 @@\n //! This module contains TypeVariants and its major components\n \n use hir::def_id::DefId;\n+use hir::map::DefPathHash;\n \n use middle::region;\n use ty::subst::Substs;\n@@ -29,7 +30,6 @@ use util::nodemap::FxHashMap;\n use serialize;\n \n use hir;\n-use ich;\n \n use self::InferTy::*;\n use self::TypeVariants::*;\n@@ -873,7 +873,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n         self.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (ich::Fingerprint, InternedString) {\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (DefPathHash, InternedString) {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n@@ -908,7 +908,7 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n         self.skip_binder().item_name()\n     }\n \n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (ich::Fingerprint, InternedString) {\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (DefPathHash, InternedString) {\n         self.skip_binder().sort_key(tcx)\n     }\n "}, {"sha": "ef6bce8a3d9d101bf7809fc1edd51909b25878f5", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ich::Fingerprint;\n+use hir::map::DefPathHash;\n use traits::specialization_graph;\n use ty::fast_reject;\n use ty::fold::TypeFoldable;\n@@ -33,7 +33,7 @@ pub struct TraitDef {\n \n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n-    pub def_path_hash: Fingerprint,\n+    pub def_path_hash: DefPathHash,\n }\n \n // We don't store the list of impls in a flat list because each cached list of\n@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                has_default_impl: bool,\n-               def_path_hash: Fingerprint)\n+               def_path_hash: DefPathHash)\n                -> TraitDef {\n         TraitDef {\n             def_id,"}, {"sha": "be4d610a89559e5484ef35fd037590f4b04be30a", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -32,6 +32,7 @@ use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::map::DefPathHash;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n@@ -218,7 +219,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n     {\n         let tcx = self.hcx.tcx();\n \n-        let mut impls: Vec<(Fingerprint, Fingerprint)> = krate\n+        let mut impls: Vec<(DefPathHash, Fingerprint)> = krate\n             .trait_impls\n             .iter()\n             .map(|(&trait_id, impls)| {"}, {"sha": "682a7051a1e95e45883d5827cee3e27b94e1bace", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -12,22 +12,30 @@\n \n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n+use rustc::hir::map::DefPathHash;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHash;\n use std::sync::Arc;\n use rustc_data_structures::fx::FxHashMap;\n-\n-use super::directory::DefPathIndex;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n /// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n-    pub edges: Vec<SerializedEdgeSet>,\n+    /// The set of all DepNodes in the graph\n+    pub nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>>,\n+    /// For each DepNode, stores the list of edges originating from that\n+    /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n+    /// which holds the actual DepNodeIndices of the target nodes.\n+    pub edge_list_indices: Vec<(u32, u32)>,\n+    /// A flattened list of all edge targets in the graph. Edge sources are\n+    /// implicit in edge_list_indices.\n+    pub edge_list_data: Vec<DepNodeIndex>,\n \n     /// These are output nodes that have no incoming edges. We track\n     /// these separately so that when we reload all edges, we don't\n     /// lose track of these nodes.\n-    pub bootstrap_outputs: Vec<DepNode<DefPathIndex>>,\n+    pub bootstrap_outputs: Vec<DepNode<DefPathHash>>,\n \n     /// These are hashes of two things:\n     /// - the HIR nodes in this crate\n@@ -51,18 +59,36 @@ pub struct SerializedDepGraph {\n     pub hashes: Vec<SerializedHash>,\n }\n \n-/// Represents a set of \"reduced\" dependency edge. We group the\n-/// outgoing edges from a single source together.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct SerializedEdgeSet {\n-    pub source: DepNode<DefPathIndex>,\n-    pub targets: Vec<DepNode<DefPathIndex>>\n+/// The index of a DepNode in the SerializedDepGraph::nodes array.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct DepNodeIndex(pub u32);\n+\n+impl DepNodeIndex {\n+    #[inline]\n+    pub fn new(idx: usize) -> DepNodeIndex {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        DepNodeIndex(idx as u32)\n+    }\n+}\n+\n+impl Idx for DepNodeIndex {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        DepNodeIndex(idx as u32)\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n }\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {\n     /// def-id of thing being hashed\n-    pub dep_node: DepNode<DefPathIndex>,\n+    pub dep_node: DepNode<DefPathHash>,\n \n     /// the hash as of previous compilation, computed by code in\n     /// `hash` module\n@@ -115,5 +141,5 @@ pub struct SerializedMetadataHashes {\n     /// is only populated if -Z query-dep-graph is specified. It will be\n     /// empty otherwise. Importing crates are perfectly happy with just having\n     /// the DefIndex.\n-    pub index_map: FxHashMap<DefIndex, DefPathIndex>\n+    pub index_map: FxHashMap<DefIndex, DefPathHash>\n }"}, {"sha": "b9b860222968b7b232050ca1cd5d46b36b0afa25", "filename": "src/librustc_incremental/persist/directory.rs", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/fbb92767801cd289ab0c62c81db172ce104b023e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb92767801cd289ab0c62c81db172ce104b023e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=fbb92767801cd289ab0c62c81db172ce104b023e", "patch": "@@ -1,204 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Code to convert a DefId into a DefPath (when serializing) and then\n-//! back again (when deserializing). Note that the new DefId\n-//! necessarily will not be the same as the old (and of course the\n-//! item might even be removed in the meantime).\n-\n-use rustc::dep_graph::DepNode;\n-use rustc::hir::map::DefPath;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::ty::TyCtxt;\n-use rustc::util::nodemap::DefIdMap;\n-use std::fmt::{self, Debug};\n-use std::iter::once;\n-use std::collections::HashMap;\n-\n-/// Index into the DefIdDirectory\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n-         RustcEncodable, RustcDecodable)]\n-pub struct DefPathIndex {\n-    index: u32\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct DefIdDirectory {\n-    // N.B. don't use Removable here because these def-ids are loaded\n-    // directly without remapping, so loading them should not fail.\n-    paths: Vec<DefPath>,\n-\n-    // For each crate, saves the crate-name/disambiguator so that\n-    // later we can match crate-numbers up again.\n-    krates: Vec<CrateInfo>,\n-}\n-\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct CrateInfo {\n-    krate: CrateNum,\n-    name: String,\n-    disambiguator: String,\n-}\n-\n-impl DefIdDirectory {\n-    pub fn new(krates: Vec<CrateInfo>) -> DefIdDirectory {\n-        DefIdDirectory { paths: vec![], krates: krates }\n-    }\n-\n-    fn max_current_crate(&self, tcx: TyCtxt) -> CrateNum {\n-        tcx.sess.cstore.crates()\n-                       .into_iter()\n-                       .max()\n-                       .unwrap_or(LOCAL_CRATE)\n-    }\n-\n-    /// Returns a string form for `index`; useful for debugging\n-    pub fn def_path_string(&self, tcx: TyCtxt, index: DefPathIndex) -> String {\n-        let path = &self.paths[index.index as usize];\n-        if self.krate_still_valid(tcx, self.max_current_crate(tcx), path.krate) {\n-            path.to_string(tcx)\n-        } else {\n-            format!(\"<crate {} changed>\", path.krate)\n-        }\n-    }\n-\n-    pub fn krate_still_valid(&self,\n-                             tcx: TyCtxt,\n-                             max_current_crate: CrateNum,\n-                             krate: CrateNum) -> bool {\n-        // Check that the crate-number still matches. For now, if it\n-        // doesn't, just return None. We could do better, such as\n-        // finding the new number.\n-\n-        if krate > max_current_crate {\n-            false\n-        } else {\n-            let old_info = &self.krates[krate.as_usize()];\n-            assert_eq!(old_info.krate, krate);\n-            let old_name: &str = &old_info.name;\n-            let old_disambiguator: &str = &old_info.disambiguator;\n-            let new_name: &str = &tcx.crate_name(krate).as_str();\n-            let new_disambiguator: &str = &tcx.crate_disambiguator(krate).as_str();\n-            old_name == new_name && old_disambiguator == new_disambiguator\n-        }\n-    }\n-\n-    pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n-\n-        fn make_key(name: &str, disambiguator: &str) -> String {\n-            format!(\"{}/{}\", name, disambiguator)\n-        }\n-\n-        let new_krates: HashMap<_, _> =\n-            once(LOCAL_CRATE)\n-            .chain(tcx.sess.cstore.crates())\n-            .map(|krate| (make_key(&tcx.crate_name(krate).as_str(),\n-                                   &tcx.crate_disambiguator(krate).as_str()), krate))\n-            .collect();\n-\n-        let ids = self.paths.iter()\n-                            .map(|path| {\n-                                let old_krate_id = path.krate.as_usize();\n-                                assert!(old_krate_id < self.krates.len());\n-                                let old_crate_info = &self.krates[old_krate_id];\n-                                let old_crate_key = make_key(&old_crate_info.name,\n-                                                         &old_crate_info.disambiguator);\n-                                if let Some(&new_crate_key) = new_krates.get(&old_crate_key) {\n-                                    tcx.retrace_path(new_crate_key, &path.data)\n-                                } else {\n-                                    debug!(\"crate {:?} no longer exists\", old_crate_key);\n-                                    None\n-                                }\n-                            })\n-                            .collect();\n-        RetracedDefIdDirectory { ids: ids }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct RetracedDefIdDirectory {\n-    ids: Vec<Option<DefId>>\n-}\n-\n-impl RetracedDefIdDirectory {\n-    pub fn def_id(&self, index: DefPathIndex) -> Option<DefId> {\n-        self.ids[index.index as usize]\n-    }\n-\n-    pub fn map(&self, node: &DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n-        node.map_def(|&index| self.def_id(index))\n-    }\n-}\n-\n-pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hash: DefIdMap<DefPathIndex>,\n-    directory: DefIdDirectory,\n-}\n-\n-impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n-        let mut krates: Vec<_> =\n-            once(LOCAL_CRATE)\n-            .chain(tcx.sess.cstore.crates())\n-            .map(|krate| {\n-                CrateInfo {\n-                    krate: krate,\n-                    name: tcx.crate_name(krate).to_string(),\n-                    disambiguator: tcx.crate_disambiguator(krate).to_string()\n-                }\n-            })\n-            .collect();\n-\n-        // the result of crates() is not in order, so sort list of\n-        // crates so that we can just index it later\n-        krates.sort_by_key(|k| k.krate);\n-\n-        DefIdDirectoryBuilder {\n-            tcx: tcx,\n-            hash: DefIdMap(),\n-            directory: DefIdDirectory::new(krates),\n-        }\n-    }\n-\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    pub fn add(&mut self, def_id: DefId) -> DefPathIndex {\n-        debug!(\"DefIdDirectoryBuilder: def_id={:?}\", def_id);\n-        let tcx = self.tcx;\n-        let paths = &mut self.directory.paths;\n-        self.hash.entry(def_id)\n-                 .or_insert_with(|| {\n-                     let def_path = tcx.def_path(def_id);\n-                     let index = paths.len() as u32;\n-                     paths.push(def_path);\n-                     DefPathIndex { index: index }\n-                 })\n-                 .clone()\n-    }\n-\n-    pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n-        node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n-    }\n-\n-    pub fn directory(&self) -> &DefIdDirectory {\n-        &self.directory\n-    }\n-}\n-\n-impl Debug for DefIdDirectory {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        fmt.debug_list()\n-           .entries(self.paths.iter().enumerate())\n-           .finish()\n-    }\n-}"}, {"sha": "3a428bd7b8f7d273819fb2c8e3481d01a3798337", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -40,7 +40,6 @@\n //! previous revision to compare things to.\n //!\n \n-use super::directory::RetracedDefIdDirectory;\n use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n@@ -58,18 +57,23 @@ const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               dirty_inputs: &DirtyNodes,\n-                                               retraced: &RetracedDefIdDirectory) {\n+                                               dirty_inputs: &DirtyNodes) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n+    let def_path_hash_to_def_id = tcx.def_path_hash_to_def_id.as_ref().unwrap();\n     let dirty_inputs: FxHashSet<DepNode<DefId>> =\n         dirty_inputs.keys()\n-                    .filter_map(|d| retraced.map(d))\n+                    .filter_map(|dep_node| {\n+                        dep_node.map_def(|def_path_hash| {\n+                            def_path_hash_to_def_id.get(def_path_hash).cloned()\n+                        })\n+                    })\n                     .collect();\n+\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();"}, {"sha": "b30a1f4d3254fbfbd157850460895bc5f918a866", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -12,19 +12,20 @@\n \n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathHash;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n+use std::default::Default;\n use std::path::{Path};\n use std::sync::Arc;\n \n use IncrementalHashesMap;\n use super::data::*;\n-use super::directory::*;\n use super::dirty_clean;\n use super::hash::*;\n use super::fs::*;\n@@ -33,7 +34,7 @@ use super::work_product;\n \n // The key is a dirty node. The value is **some** base-input that we\n // can blame it on.\n-pub type DirtyNodes = FxHashMap<DepNode<DefPathIndex>, DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FxHashMap<DepNode<DefPathHash>, DepNode<DefPathHash>>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -118,6 +119,16 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n     None\n }\n \n+/// Try to convert a DepNode from the old dep-graph into a DepNode in the\n+/// current graph by mapping the DefPathHash to a valid DefId. This will fail\n+/// if the DefPathHash refers to something that has been removed (because\n+/// there is no DefId for that thing anymore).\n+fn retrace(tcx: TyCtxt, dep_node: &DepNode<DefPathHash>) -> Option<DepNode<DefId>> {\n+    dep_node.map_def(|def_path_hash| {\n+        tcx.def_path_hash_to_def_id.as_ref().unwrap().get(def_path_hash).cloned()\n+    })\n+}\n+\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -149,16 +160,25 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Ok(());\n     }\n \n-    let directory = DefIdDirectory::decode(&mut dep_graph_decoder)?;\n     let serialized_dep_graph = SerializedDepGraph::decode(&mut dep_graph_decoder)?;\n \n-    let edge_map: FxHashMap<_, _> = serialized_dep_graph.edges\n-                                                        .into_iter()\n-                                                        .map(|s| (s.source, s.targets))\n-                                                        .collect();\n+    let edge_map: FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>> = {\n+        let capacity = serialized_dep_graph.edge_list_data.len();\n+        let mut edge_map = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n+\n+        for (node_index, source) in serialized_dep_graph.nodes.iter().enumerate() {\n+            let (start, end) = serialized_dep_graph.edge_list_indices[node_index];\n+            let targets =\n+                (&serialized_dep_graph.edge_list_data[start as usize .. end as usize])\n+                .into_iter()\n+                .map(|&node_index| serialized_dep_graph.nodes[node_index].clone())\n+                .collect();\n+\n+            edge_map.insert(source.clone(), targets);\n+        }\n \n-    // Retrace the paths in the directory to find their current location (if any).\n-    let retraced = directory.retrace(tcx);\n+        edge_map\n+    };\n \n     // Compute the set of nodes from the old graph where some input\n     // has changed or been removed. These are \"raw\" source nodes,\n@@ -169,8 +189,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the current compilation).\n     let dirty_raw_nodes = initial_dirty_nodes(tcx,\n                                               incremental_hashes_map,\n-                                              &serialized_dep_graph.hashes,\n-                                              &retraced);\n+                                              &serialized_dep_graph.hashes);\n     let dirty_raw_nodes = transitive_dirty_nodes(&edge_map, dirty_raw_nodes);\n \n     // Recreate the edges in the graph that are still clean.\n@@ -179,15 +198,15 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut extra_edges = vec![];\n     for (source, targets) in &edge_map {\n         for target in targets {\n-            process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+            process_edges(tcx, source, target, &edge_map, &dirty_raw_nodes,\n                           &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n         }\n     }\n \n     // Recreate bootstrap outputs, which are outputs that have no incoming edges (and hence cannot\n     // be dirty).\n     for bootstrap_output in &serialized_dep_graph.bootstrap_outputs {\n-        if let Some(n) = retraced.map(bootstrap_output) {\n+        if let Some(n) = retrace(tcx, bootstrap_output) {\n             if let DepNode::WorkProduct(ref wp) = n {\n                 clean_work_products.insert(wp.clone());\n             }\n@@ -214,18 +233,17 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the edge from `Hir(X)` to `Bar` (or, if `Bar` itself cannot be\n     // recreated, to the targets of `Bar`).\n     while let Some((source, target)) = extra_edges.pop() {\n-        process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+        process_edges(tcx, source, target, &edge_map, &dirty_raw_nodes,\n                       &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n     }\n \n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n \n-    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_nodes, &retraced);\n+    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_nodes);\n \n     load_prev_metadata_hashes(tcx,\n-                              &retraced,\n                               &mut *incremental_hashes_map.prev_metadata_hashes.borrow_mut());\n     Ok(())\n }\n@@ -234,8 +252,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// a bit vector where the index is the DefPathIndex.\n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  incremental_hashes_map: &IncrementalHashesMap,\n-                                 serialized_hashes: &[SerializedHash],\n-                                 retraced: &RetracedDefIdDirectory)\n+                                 serialized_hashes: &[SerializedHash])\n                                  -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FxHashMap();\n@@ -249,7 +266,7 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     for hash in serialized_hashes {\n-        if let Some(dep_node) = retraced.map(&hash.dep_node) {\n+        if let Some(dep_node) = retrace(tcx, &hash.dep_node) {\n             if let Some(current_hash) = hcx.hash(&dep_node) {\n                 if current_hash == hash.hash {\n                     debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n@@ -282,11 +299,11 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     dirty_nodes\n }\n \n-fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n+fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>>,\n                           mut dirty_nodes: DirtyNodes)\n                           -> DirtyNodes\n {\n-    let mut stack: Vec<(DepNode<DefPathIndex>, DepNode<DefPathIndex>)> = vec![];\n+    let mut stack: Vec<(DepNode<DefPathHash>, DepNode<DefPathHash>)> = vec![];\n     stack.extend(dirty_nodes.iter().map(|(s, b)| (s.clone(), b.clone())));\n     while let Some((source, blame)) = stack.pop() {\n         // we know the source is dirty (because of the node `blame`)...\n@@ -348,7 +365,6 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n }\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n-                             retraced: &RetracedDefIdDirectory,\n                              output: &mut FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n@@ -388,9 +404,11 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     debug!(\"load_prev_metadata_hashes() - Mapping DefIds\");\n \n     assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.entry_hashes.len());\n+    let def_path_hash_to_def_id = tcx.def_path_hash_to_def_id.as_ref().unwrap();\n+\n     for serialized_hash in serialized_hashes.entry_hashes {\n-        let def_path_index = serialized_hashes.index_map[&serialized_hash.def_index];\n-        if let Some(def_id) = retraced.def_id(def_path_index) {\n+        let def_path_hash = serialized_hashes.index_map[&serialized_hash.def_index];\n+        if let Some(&def_id) = def_path_hash_to_def_id.get(&def_path_hash) {\n             let old = output.insert(def_id, serialized_hash.hash);\n             assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n         }\n@@ -402,15 +420,13 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n fn process_edges<'a, 'tcx, 'edges>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: &'edges DepNode<DefPathIndex>,\n-    target: &'edges DepNode<DefPathIndex>,\n-    edges: &'edges FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n-    directory: &DefIdDirectory,\n-    retraced: &RetracedDefIdDirectory,\n+    source: &'edges DepNode<DefPathHash>,\n+    target: &'edges DepNode<DefPathHash>,\n+    edges: &'edges FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>>,\n     dirty_raw_nodes: &DirtyNodes,\n     clean_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n     dirty_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n-    extra_edges: &mut Vec<(&'edges DepNode<DefPathIndex>, &'edges DepNode<DefPathIndex>)>)\n+    extra_edges: &mut Vec<(&'edges DepNode<DefPathHash>, &'edges DepNode<DefPathHash>)>)\n {\n     // If the target is dirty, skip the edge. If this is an edge\n     // that targets a work-product, we can print the blame\n@@ -419,14 +435,21 @@ fn process_edges<'a, 'tcx, 'edges>(\n         if let DepNode::WorkProduct(ref wp) = *target {\n             if tcx.sess.opts.debugging_opts.incremental_info {\n                 if dirty_work_products.insert(wp.clone()) {\n-                    // It'd be nice to pretty-print these paths better than just\n-                    // using the `Debug` impls, but wev.\n+                    // Try to reconstruct the human-readable version of the\n+                    // DepNode. This cannot be done for things that where\n+                    // removed.\n+                    let readable_blame = if let Some(dep_node) = retrace(tcx, blame) {\n+                        dep_node.map_def(|&def_id| Some(tcx.def_path(def_id).to_string(tcx)))\n+                                .unwrap()\n+                    } else {\n+                        blame.map_def(|def_path_hash| Some(format!(\"{:?}\", def_path_hash)))\n+                             .unwrap()\n+                    };\n+\n                     println!(\"incremental: module {:?} is dirty because {:?} \\\n                               changed or was removed\",\n                              wp,\n-                             blame.map_def(|&index| {\n-                                 Some(directory.def_path_string(tcx, index))\n-                             }).unwrap());\n+                             readable_blame);\n                 }\n             }\n         }\n@@ -439,8 +462,8 @@ fn process_edges<'a, 'tcx, 'edges>(\n     // Retrace the source -> target edges to def-ids and then create\n     // an edge in the graph. Retracing may yield none if some of the\n     // data happens to have been removed.\n-    if let Some(source_node) = retraced.map(source) {\n-        if let Some(target_node) = retraced.map(target) {\n+    if let Some(source_node) = retrace(tcx, source) {\n+        if let Some(target_node) = retrace(tcx, target) {\n             let _task = tcx.dep_graph.in_task(target_node);\n             tcx.dep_graph.read(source_node);\n             if let DepNode::WorkProduct(ref wp) = *target {"}, {"sha": "c03a0ab4ba2c181d0c19267b2f9b65948bc0d48c", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -13,7 +13,6 @@\n //! various HIR nodes.\n \n mod data;\n-mod directory;\n mod dirty_clean;\n mod fs;\n mod hash;"}, {"sha": "6d717d6f409d5706f4b3d90928d32e1061de95a1", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -11,11 +11,14 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n+use rustc::hir::map::DefPathHash;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::graph;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::io::{self, Cursor, Write};\n@@ -24,7 +27,6 @@ use std::path::PathBuf;\n \n use IncrementalHashesMap;\n use super::data::*;\n-use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n@@ -43,7 +45,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let mut builder = DefIdDirectoryBuilder::new(tcx);\n     let query = tcx.dep_graph.query();\n \n     if tcx.sess.opts.debugging_opts.incremental_info {\n@@ -65,14 +66,13 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 |e| encode_metadata_hashes(tcx,\n                                            svh,\n                                            metadata_hashes,\n-                                           &mut builder,\n                                            &mut current_metadata_hashes,\n                                            e));\n     }\n \n     save_in(sess,\n             dep_graph_path(sess),\n-            |e| encode_dep_graph(&preds, &mut builder, e));\n+            |e| encode_dep_graph(tcx, &preds, e));\n \n     let prev_metadata_hashes = incremental_hashes_map.prev_metadata_hashes.borrow();\n     dirty_clean::check_dirty_clean_metadata(tcx,\n@@ -167,81 +167,91 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n-pub fn encode_dep_graph(preds: &Predecessors,\n-                        builder: &mut DefIdDirectoryBuilder,\n+pub fn encode_dep_graph(tcx: TyCtxt,\n+                        preds: &Predecessors,\n                         encoder: &mut Encoder)\n                         -> io::Result<()> {\n     // First encode the commandline arguments hash\n-    let tcx = builder.tcx();\n     tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n \n-    // Create a flat list of (Input, WorkProduct) edges for\n-    // serialization.\n-    let mut edges = FxHashMap();\n-    for edge in preds.reduced_graph.all_edges() {\n-        let source = *preds.reduced_graph.node_data(edge.source());\n-        let target = *preds.reduced_graph.node_data(edge.target());\n-        match *target {\n-            DepNode::MetaData(ref def_id) => {\n-                // Metadata *targets* are always local metadata nodes. We have\n-                // already handled those in `encode_metadata_hashes`.\n-                assert!(def_id.is_local());\n-                continue;\n-            }\n-            _ => (),\n-        }\n-        debug!(\"serialize edge: {:?} -> {:?}\", source, target);\n-        let source = builder.map(source);\n-        let target = builder.map(target);\n-        edges.entry(source).or_insert(vec![]).push(target);\n-    }\n+    let to_hash_based_node = |dep_node: &DepNode<DefId>| {\n+        dep_node.map_def(|&def_id| Some(tcx.def_path_hash(def_id))).unwrap()\n+    };\n \n-    if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-        for (dep_node, hash) in &preds.hashes {\n-            println!(\"HIR hash for {:?} is {}\", dep_node, hash);\n+    // NB: We rely on this Vec being indexable by reduced_graph's NodeIndex.\n+    let nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>> = preds\n+        .reduced_graph\n+        .all_nodes()\n+        .iter()\n+        .map(|node| to_hash_based_node(node.data))\n+        .collect();\n+\n+    let mut edge_list_indices = Vec::with_capacity(nodes.len());\n+    let mut edge_list_data = Vec::with_capacity(preds.reduced_graph.len_edges());\n+\n+    for node_index in 0 .. nodes.len() {\n+        let start = edge_list_data.len() as u32;\n+\n+        for target in preds.reduced_graph.successor_nodes(graph::NodeIndex(node_index)) {\n+            edge_list_data.push(DepNodeIndex::new(target.node_id()));\n         }\n+\n+        let end = edge_list_data.len() as u32;\n+        debug_assert_eq!(node_index, edge_list_indices.len());\n+        edge_list_indices.push((start, end));\n     }\n \n-    // Create the serialized dep-graph.\n-    let bootstrap_outputs = preds.bootstrap_outputs.iter()\n-                                                   .map(|n| builder.map(n))\n-                                                   .collect();\n-    let edges = edges.into_iter()\n-                     .map(|(k, v)| SerializedEdgeSet { source: k, targets: v })\n-                     .collect();\n+    // Let's make we had no overflow there.\n+    assert!(edge_list_data.len() <= ::std::u32::MAX as usize);\n+    // Check that we have a consistent number of edges.\n+    assert_eq!(edge_list_data.len(), preds.reduced_graph.len_edges());\n+\n+    let bootstrap_outputs = preds\n+        .bootstrap_outputs\n+        .iter()\n+        .map(|n| to_hash_based_node(n))\n+        .collect();\n+\n+    let hashes = preds\n+        .hashes\n+        .iter()\n+        .map(|(&dep_node, &hash)| {\n+            SerializedHash {\n+                dep_node: to_hash_based_node(dep_node),\n+                hash: hash,\n+            }\n+        })\n+        .collect();\n+\n     let graph = SerializedDepGraph {\n+        nodes,\n+        edge_list_indices,\n+        edge_list_data,\n         bootstrap_outputs,\n-        edges,\n-        hashes: preds.hashes\n-            .iter()\n-            .map(|(&dep_node, &hash)| {\n-                SerializedHash {\n-                    dep_node: builder.map(dep_node),\n-                    hash: hash,\n-                }\n-            })\n-            .collect(),\n+        hashes,\n     };\n \n+    // Encode the graph data.\n+    graph.encode(encoder)?;\n+\n     if tcx.sess.opts.debugging_opts.incremental_info {\n-        println!(\"incremental: {} nodes in reduced dep-graph\", preds.reduced_graph.len_nodes());\n-        println!(\"incremental: {} edges in serialized dep-graph\", graph.edges.len());\n+        println!(\"incremental: {} nodes in reduced dep-graph\", graph.nodes.len());\n+        println!(\"incremental: {} edges in serialized dep-graph\", graph.edge_list_data.len());\n         println!(\"incremental: {} hashes in serialized dep-graph\", graph.hashes.len());\n     }\n \n-    debug!(\"graph = {:#?}\", graph);\n-\n-    // Encode the directory and then the graph data.\n-    builder.directory().encode(encoder)?;\n-    graph.encode(encoder)?;\n+    if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+        for (dep_node, hash) in &preds.hashes {\n+            println!(\"ICH for {:?} is {}\", dep_node, hash);\n+        }\n+    }\n \n     Ok(())\n }\n \n pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               metadata_hashes: &EncodedMetadataHashes,\n-                              builder: &mut DefIdDirectoryBuilder,\n                               current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n@@ -256,8 +266,8 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n             let def_id = DefId::local(serialized_hash.def_index);\n \n             // Store entry in the index_map\n-            let def_path_index = builder.add(def_id);\n-            serialized_hashes.index_map.insert(def_id.index, def_path_index);\n+            let def_path_hash = tcx.def_path_hash(def_id);\n+            serialized_hashes.index_map.insert(def_id.index, def_path_hash);\n \n             // Record hash in current_metadata_hashes\n             current_metadata_hashes.insert(def_id, serialized_hash.hash);"}, {"sha": "51f152991fdaf54974792026ea147e32c382a6fa", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -326,7 +326,7 @@ impl<'a> CrateLoader<'a> {\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n-            def_path_table: def_path_table,\n+            def_path_table: Rc::new(def_path_table),\n             exported_symbols: exported_symbols,\n             trait_impls: trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {"}, {"sha": "5066b927c11526214029b6f3667c5cedb3a67c53", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -76,7 +76,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub def_path_table: DefPathTable,\n+    pub def_path_table: Rc<DefPathTable>,\n \n     pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n "}, {"sha": "dcc55846b53d8421f334dabb3afc039d76fccfb2", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -17,15 +17,15 @@ use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n                             ExternCrate, NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def;\n-use rustc::ich;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n-use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n+use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData, DefPathHash};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n@@ -334,10 +334,14 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n-    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint {\n+    fn def_path_hash(&self, def: DefId) -> DefPathHash {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n+    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n+        self.get_crate_data(cnum).def_path_table.clone()\n+    }\n+\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));"}, {"sha": "91470f238ecb12ec00656681a53a7f3878fc22ce", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "patch": "@@ -14,9 +14,8 @@ use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n-use rustc::ich;\n \n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -1109,7 +1108,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&self, index: DefIndex) -> ich::Fingerprint {\n+    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n "}]}