{"sha": "0cacbe901d0defe79188b08e6b8d224456a34653", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYWNiZTkwMWQwZGVmZTc5MTg4YjA4ZTZiOGQyMjQ0NTZhMzQ2NTM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-23T00:46:41Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-23T00:46:52Z"}, "message": "Overhaul how we handle freevars.", "tree": {"sha": "32c356da98cdecca3794fcbb8bc5be3c9b1d941d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c356da98cdecca3794fcbb8bc5be3c9b1d941d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cacbe901d0defe79188b08e6b8d224456a34653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cacbe901d0defe79188b08e6b8d224456a34653", "html_url": "https://github.com/rust-lang/rust/commit/0cacbe901d0defe79188b08e6b8d224456a34653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cacbe901d0defe79188b08e6b8d224456a34653/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf50114eb18a434c143b51beb9b4dc3ce9400ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf50114eb18a434c143b51beb9b4dc3ce9400ea", "html_url": "https://github.com/rust-lang/rust/commit/2bf50114eb18a434c143b51beb9b4dc3ce9400ea"}], "stats": {"total": 65, "additions": 39, "deletions": 26}, "files": [{"sha": "2b733e7ba5071f9e9226ec69b4f3ab30abfd59a5", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0cacbe901d0defe79188b08e6b8d224456a34653/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cacbe901d0defe79188b08e6b8d224456a34653/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=0cacbe901d0defe79188b08e6b8d224456a34653", "patch": "@@ -16,13 +16,16 @@ import syntax::codemap::span;\n export annotate_freevars;\n export freevar_set;\n export freevar_map;\n+export get_freevar_info;\n export get_freevars;\n+export get_freevar_uses;\n export has_freevars;\n export is_freevar_of;\n export def_lookup;\n \n-type freevar_set = @ast::node_id[];\n-type freevar_map = hashmap[ast::node_id, freevar_set];\n+type freevar_set = hashset[ast::node_id];\n+type freevar_info = rec(freevar_set defs, @ast::node_id[] uses);\n+type freevar_map = hashmap[ast::node_id, freevar_info];\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n@@ -31,7 +34,7 @@ type freevar_map = hashmap[ast::node_id, freevar_set];\n // in order to start the search.\n fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n                     &fn (&walk::ast_visitor) walker,\n-                    ast::node_id[] initial_decls) -> freevar_set {\n+                    ast::node_id[] initial_decls) -> freevar_info {\n     type env =\n         @rec(mutable ast::node_id[] refs,\n              hashset[ast::node_id] decls,\n@@ -50,9 +53,9 @@ fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n                        \"internal error in collect_freevars\");\n                 }\n                 alt (e.def_map.get(expr.id)) {\n-                    case (ast::def_arg(?did)) { e.refs += ~[did._1]; }\n-                    case (ast::def_local(?did)) { e.refs += ~[did._1]; }\n-                    case (ast::def_binding(?did)) { e.refs += ~[did._1]; }\n+                    case (ast::def_arg(?did)) { e.refs += ~[expr.id]; }\n+                    case (ast::def_local(?did)) { e.refs += ~[expr.id]; }\n+                    case (ast::def_binding(?did)) { e.refs += ~[expr.id]; }\n                     case (_) { /* no-op */ }\n                 }\n             }\n@@ -87,12 +90,19 @@ fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n     walker(*visitor);\n \n     // Calculate (refs - decls). This is the set of captured upvars.\n-    auto result = ~[];\n+    // We build a vec of the node ids of the uses and a set of the\n+    // node ids of the definitions.\n+    auto uses = ~[];\n+    auto defs = new_int_hash();\n     for (ast::node_id ref_id_ in e.refs) {\n         auto ref_id = ref_id_;\n-        if (!decls.contains_key(ref_id)) { result += ~[ref_id]; }\n+        auto def_id = ast::def_id_of_def(def_map.get(ref_id))._1;\n+        if !decls.contains_key(def_id) {\n+            uses += ~[ref_id];\n+            set_add(defs, def_id);\n+        }\n     }\n-    ret @result;\n+    ret rec(defs=defs, uses=@uses);\n }\n \n // Build a map from every function and for-each body to a set of the\n@@ -136,19 +146,25 @@ fn annotate_freevars(&session::session sess, &resolve::def_map def_map,\n     ret e.freevars;\n }\n \n-fn get_freevars(&ty::ctxt tcx, ast::node_id fid) -> freevar_set {\n+fn get_freevar_info(&ty::ctxt tcx, ast::node_id fid) -> freevar_info {\n     alt (tcx.freevars.find(fid)) {\n         none {\n             fail \"get_freevars: \" + int::str(fid) + \" has no freevars\";\n         }\n         some(?d) { ret d; }\n     }\n }\n+fn get_freevars(&ty::ctxt tcx, ast::node_id fid) -> freevar_set {\n+    ret get_freevar_info(tcx, fid).defs;\n+}\n+fn get_freevar_uses(&ty::ctxt tcx, ast::node_id fid) -> @ast::node_id[] {\n+    ret get_freevar_info(tcx, fid).uses;\n+}\n fn has_freevars(&ty::ctxt tcx, ast::node_id fid) -> bool {\n-    ret ivec::len(*get_freevars(tcx, fid)) != 0u;\n+    ret get_freevars(tcx, fid).size() != 0u;\n }\n fn is_freevar_of(&ty::ctxt tcx, ast::node_id var, ast::node_id f) -> bool {\n-    ret ivec::member(var, *get_freevars(tcx, f));\n+    ret get_freevars(tcx, f).contains_key(var);\n }\n fn def_lookup(&ty::ctxt tcx, ast::node_id f, ast::node_id id) ->\n     option::t[ast::def] {"}, {"sha": "ded2a0108f6c3f32d3dbf270506d79b1d59fc2ff", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0cacbe901d0defe79188b08e6b8d224456a34653/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cacbe901d0defe79188b08e6b8d224456a34653/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0cacbe901d0defe79188b08e6b8d224456a34653", "patch": "@@ -3792,29 +3792,28 @@ fn find_variable(&@fn_ctxt fcx, ast::node_id nid) -> ValueRef {\n // Given a block context and a list of upvars, construct a closure that\n // contains pointers to all of the upvars and all of the tydescs in\n // scope. Return the ValueRef and TypeRef corresponding to the closure.\n-fn build_environment(&@block_ctxt cx, &ast::node_id[] upvars) ->\n+fn build_environment(&@block_ctxt cx, &freevar_set upvars) ->\n     rec(ValueRef ptr, TypeRef ptrty) {\n-    auto upvar_count = std::ivec::len(upvars);\n     auto has_iterbody = !option::is_none(cx.fcx.lliterbody);\n-    if (has_iterbody) { upvar_count += 1u; }\n     auto llbindingsptr;\n \n-    if (upvar_count > 0u) {\n+    if (upvars.size() > 0u || has_iterbody) {\n         // Gather up the upvars.\n         let ValueRef[] llbindings = ~[];\n         let TypeRef[] llbindingtys = ~[];\n         if (has_iterbody) {\n             llbindings += ~[option::get(cx.fcx.lliterbody)];\n             llbindingtys += ~[val_ty(llbindings.(0))];\n         }\n-        for (ast::node_id nid in upvars) {\n+        for each (ast::node_id nid in upvars.keys()) {\n             auto llbinding = find_variable(cx.fcx, nid);\n             llbindings += ~[llbinding];\n             llbindingtys += ~[val_ty(llbinding)];\n         }\n \n         // Create an array of bindings and copy in aliases to the upvars.\n         llbindingsptr = alloca(cx, T_struct(llbindingtys));\n+        auto upvar_count = std::ivec::len(llbindings);\n         auto i = 0u;\n         while (i < upvar_count) {\n             auto llbindingptr =\n@@ -3859,7 +3858,7 @@ fn build_environment(&@block_ctxt cx, &ast::node_id[] upvars) ->\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(&@block_ctxt cx, &@fn_ctxt fcx,\n-                    TypeRef llenvptrty, &ast::node_id[] upvars) {\n+                    TypeRef llenvptrty, &freevar_set upvars) {\n     auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     // Populate the upvars from the environment.\n@@ -3871,22 +3870,20 @@ fn load_environment(&@block_ctxt cx, &@fn_ctxt fcx,\n                                   C_int(abi::closure_elt_bindings)]);\n     auto llremotebindingsptr =\n         copy_args_bcx.build.Load(llremotebindingsptrptr);\n-    auto base = 0u;\n+\n     auto i = 0u;\n-    auto end = std::ivec::len(upvars);\n     if (!option::is_none(cx.fcx.lliterbody)) {\n-        base += 1u;\n+        i += 1u;\n         auto lliterbodyptr =\n             copy_args_bcx.build.GEP(llremotebindingsptr,\n                                     ~[C_int(0), C_int(0)]);\n         auto lliterbody = copy_args_bcx.build.Load(lliterbodyptr);\n         fcx.lliterbody = some(lliterbody);\n     }\n-    while (i < end) {\n-        auto upvar_id = upvars.(i);\n+    for each (ast::node_id upvar_id in upvars.keys()) {\n         auto llupvarptrptr =\n             copy_args_bcx.build.GEP(llremotebindingsptr,\n-                                    ~[C_int(0), C_int(base+i as int)]);\n+                                    ~[C_int(0), C_int(i as int)]);\n         auto llupvarptr = copy_args_bcx.build.Load(llupvarptrptr);\n         fcx.llupvars.insert(upvar_id, llupvarptr);\n         i += 1u;\n@@ -3943,7 +3940,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     auto decl_id = local.node.id;\n     auto upvars = get_freevars(lcx.ccx.tcx, body.node.id);\n \n-    auto llenv = build_environment(cx, *upvars);\n+    auto llenv = build_environment(cx, upvars);\n \n     // Step 2: Declare foreach body function.\n     let str s =\n@@ -3964,7 +3961,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n     // Generate code to load the environment out of the\n     // environment pointer.\n-    load_environment(cx, fcx, llenv.ptrty, *upvars);\n+    load_environment(cx, fcx, llenv.ptrty, upvars);\n \n     // Add an upvar for the loop variable alias.\n     fcx.llupvars.insert(decl_id, llvm::LLVMGetParam(fcx.llfn, 3u));"}]}