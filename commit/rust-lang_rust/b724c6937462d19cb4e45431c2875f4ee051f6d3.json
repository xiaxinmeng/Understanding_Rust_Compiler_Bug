{"sha": "b724c6937462d19cb4e45431c2875f4ee051f6d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjRjNjkzNzQ2MmQxOWNiNGU0NTQzMWMyODc1ZjRlZTA1MWY2ZDM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-17T09:20:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-17T09:20:43Z"}, "message": "Rollup merge of #48983 - gnzlbg:red, r=alexcrichton\n\nadd intrinsics for portable packed simd vector reductions\n\nAdds the following portable vector reduction intrinsics:\n\n* fn simd_reduce_add<T, U>(x: T) -> U;\n* fn simd_reduce_mul<T, U>(x: T) -> U;\n* fn simd_reduce_min<T, U>(x: T) -> U;\n* fn simd_reduce_max<T, U>(x: T) -> U;\n* fn simd_reduce_and<T, U>(x: T) -> U;\n* fn simd_reduce_or<T, U>(x: T) -> U;\n* fn simd_reduce_xor<T, U>(x: T) -> U;\n\nI've also added:\n\n* fn simd_reduce_all<T>(x: T) -> bool;\n* fn simd_reduce_any<T>(x: T) -> bool;\n\nThese produce better code that what we are currently producing in `stdsimd`, but the code is still not optimal due to this LLVM bug:  https://bugs.llvm.org/show_bug.cgi?id=36702\n\nr? @alexcrichton", "tree": {"sha": "9e3886ece108b6ffb1e23001f047b543811f6060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3886ece108b6ffb1e23001f047b543811f6060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b724c6937462d19cb4e45431c2875f4ee051f6d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJarN3rCRBK7hj4Ov3rIwAAdHIIAAeJqD1rhLr0MeSHQ1O94TNr\n5bbLjDAPReDJUq/F+B55hv1h1J/oPmQQSYQGEOd6lmKhVAG3jeNOpfsjU6hd9xKA\nE7mwjk68Ykj1lVD01bS81ybx6j1QAmvHm8uGyGGrBD5Dhe8ItIQPoNkkP6Ix+3Zo\nZ6/bqc7XuoncUdsL6kXwbh4zplfyS/hcyaSg1cXkkKMvcd3cMIHYw0m6KOWsogGt\nUic7KEge4+g6jzOA9bD+dNTtujefc2BsMi+7QB8VvcK48EUrGiO+0Coz+r4DvRMe\nKmnhJqDQ9g8qocPEzuHgpEOgRNFXPCbpRY3j2gGxfUSk4wec6dOAny8vs3ZWLhY=\n=SHWy\n-----END PGP SIGNATURE-----\n", "payload": "tree 9e3886ece108b6ffb1e23001f047b543811f6060\nparent c9d06a4a4e07e59c9d5099325a66242321f7c392\nparent 06148cb4b0f83ecec70148de8b589644b618e66f\nauthor kennytm <kennytm@gmail.com> 1521278443 +0800\ncommitter GitHub <noreply@github.com> 1521278443 +0800\n\nRollup merge of #48983 - gnzlbg:red, r=alexcrichton\n\nadd intrinsics for portable packed simd vector reductions\n\nAdds the following portable vector reduction intrinsics:\n\n* fn simd_reduce_add<T, U>(x: T) -> U;\n* fn simd_reduce_mul<T, U>(x: T) -> U;\n* fn simd_reduce_min<T, U>(x: T) -> U;\n* fn simd_reduce_max<T, U>(x: T) -> U;\n* fn simd_reduce_and<T, U>(x: T) -> U;\n* fn simd_reduce_or<T, U>(x: T) -> U;\n* fn simd_reduce_xor<T, U>(x: T) -> U;\n\nI've also added:\n\n* fn simd_reduce_all<T>(x: T) -> bool;\n* fn simd_reduce_any<T>(x: T) -> bool;\n\nThese produce better code that what we are currently producing in `stdsimd`, but the code is still not optimal due to this LLVM bug:  https://bugs.llvm.org/show_bug.cgi?id=36702\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b724c6937462d19cb4e45431c2875f4ee051f6d3", "html_url": "https://github.com/rust-lang/rust/commit/b724c6937462d19cb4e45431c2875f4ee051f6d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b724c6937462d19cb4e45431c2875f4ee051f6d3/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9d06a4a4e07e59c9d5099325a66242321f7c392", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d06a4a4e07e59c9d5099325a66242321f7c392", "html_url": "https://github.com/rust-lang/rust/commit/c9d06a4a4e07e59c9d5099325a66242321f7c392"}, {"sha": "06148cb4b0f83ecec70148de8b589644b618e66f", "url": "https://api.github.com/repos/rust-lang/rust/commits/06148cb4b0f83ecec70148de8b589644b618e66f", "html_url": "https://github.com/rust-lang/rust/commit/06148cb4b0f83ecec70148de8b589644b618e66f"}], "stats": {"total": 731, "additions": 728, "deletions": 3}, "files": [{"sha": "c0cdd212770623bf6ff827776db7ff55b0d84e68", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -621,6 +621,7 @@ extern \"C\" {\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n+    pub fn LLVMConstRealGetDouble (ConstantVal: ValueRef, losesInfo: *mut Bool) -> f64;\n \n \n     // Operations on composite constants\n@@ -1201,6 +1202,46 @@ extern \"C\" {\n                                 Name: *const c_char)\n                                 -> ValueRef;\n \n+    pub fn LLVMRustBuildVectorReduceFAdd(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMul(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAdd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMul(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAnd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceOr(B: BuilderRef,\n+                                       Src: ValueRef)\n+                                       -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceXor(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMin(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMax(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMin(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMax(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+\n     pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildPtrDiff(B: BuilderRef,\n@@ -1567,6 +1608,7 @@ extern \"C\" {\n     pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n \n     pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantFP(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;"}, {"sha": "3f5a9a54ff1eacfab2bd485672b2091e50d4635a", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -955,6 +955,147 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fadd_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmul_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.add\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_mul(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.mul\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_and(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.and\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_or(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.or\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_xor(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.xor\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, true);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, true);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, false);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, false);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.min\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_max(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.max\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+\n     pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);"}, {"sha": "e83e73c8ae7578d33fdc61b71a767e32aba262cc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -269,6 +269,19 @@ pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n     }\n }\n \n+pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n+    unsafe {\n+        if is_const_real(v) {\n+            let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info as *mut llvm::Bool);\n+            let loses_info = if loses_info == 1 { true } else { false };\n+            Some((r, loses_info))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub fn const_to_uint(v: ValueRef) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n@@ -281,6 +294,13 @@ pub fn is_const_integral(v: ValueRef) -> bool {\n     }\n }\n \n+pub fn is_const_real(v: ValueRef) -> bool {\n+    unsafe {\n+        !llvm::LLVMIsAConstantFP(v).is_null()\n+    }\n+}\n+\n+\n #[inline]\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)"}, {"sha": "c3de9e0ffcce226bc11ce5c1b3232bf6f931f982", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -1018,14 +1018,22 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                          name, $($fmt)*));\n         }\n     }\n-    macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n-            if !$cond {\n+    macro_rules! return_error {\n+        ($($fmt: tt)*) => {\n+            {\n                 emit_error!($($fmt)*);\n                 return Err(());\n             }\n         }\n     }\n+\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                return_error!($($fmt)*);\n+            }\n+        };\n+    }\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n             require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n@@ -1145,6 +1153,161 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n+    macro_rules! arith_red {\n+        ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$integer_reduce(args[0].immediate());\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            if name.contains(\"mul\") {\n+                                Ok(bx.mul(args[1].immediate(), r))\n+                            } else {\n+                                Ok(bx.add(args[1].immediate(), r))\n+                            }\n+                        } else {\n+                            Ok(bx.$integer_reduce(args[0].immediate()))\n+                        }\n+                    },\n+                    ty::TyFloat(f) => {\n+                        // ordered arithmetic reductions take an accumulator\n+                        let acc = if $ordered {\n+                            let acc = args[1].immediate();\n+                            // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36734\n+                            // * if the accumulator of the fadd isn't 0, incorrect\n+                            //   code is generated\n+                            // * if the accumulator of the fmul isn't 1, incorrect\n+                            //   code is generated\n+                            match const_get_real(acc) {\n+                                None => return_error!(\"accumulator of {} is not a constant\", $name),\n+                                Some((v, loses_info)) => {\n+                                    if $name.contains(\"mul\") && v != 1.0_f64 {\n+                                        return_error!(\"accumulator of {} is not 1.0\", $name);\n+                                    } else if $name.contains(\"add\") && v != 0.0_f64 {\n+                                        return_error!(\"accumulator of {} is not 0.0\", $name);\n+                                    } else if loses_info {\n+                                        return_error!(\"accumulator of {} loses information\", $name);\n+                                    }\n+                                }\n+                            }\n+                            acc\n+                        } else {\n+                            // unordered arithmetic reductions do not:\n+                            match f.bit_width() {\n+                                32 => C_undef(Type::f32(bx.cx)),\n+                                64 => C_undef(Type::f64(bx.cx)),\n+                                v => {\n+                                    return_error!(r#\"\n+unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n+                                        $name, in_ty, in_elem, v, ret_ty\n+                                    )\n+                                }\n+                            }\n+\n+                        };\n+                        Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                    }\n+                    _ => {\n+                        return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            $name, in_ty, in_elem, ret_ty\n+                        )\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n+    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd_fast, true);\n+    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul_fast, true);\n+    arith_red!(\"simd_reduce_add_unordered\": vector_reduce_add, vector_reduce_fadd_fast, false);\n+    arith_red!(\"simd_reduce_mul_unordered\": vector_reduce_mul, vector_reduce_fmul_fast, false);\n+\n+    macro_rules! minmax_red {\n+        ($name:tt: $int_red:ident, $float_red:ident) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_i) => {\n+                        Ok(bx.$int_red(args[0].immediate(), true))\n+                    },\n+                    ty::TyUint(_u) => {\n+                        Ok(bx.$int_red(args[0].immediate(), false))\n+                    },\n+                    ty::TyFloat(_f) => {\n+                        Ok(bx.$float_red(args[0].immediate()))\n+                    }\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    minmax_red!(\"simd_reduce_min\": vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(\"simd_reduce_max\": vector_reduce_max, vector_reduce_fmax);\n+\n+    minmax_red!(\"simd_reduce_min_nanless\": vector_reduce_min, vector_reduce_fmin_fast);\n+    minmax_red!(\"simd_reduce_max_nanless\": vector_reduce_max, vector_reduce_fmax_fast);\n+\n+    macro_rules! bitwise_red {\n+        ($name:tt : $red:ident, $boolean:expr) => {\n+            if name == $name {\n+                let input = if !$boolean {\n+                    require!(ret_ty == in_elem,\n+                             \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                             in_elem, in_ty, ret_ty);\n+                    args[0].immediate()\n+                } else {\n+                    match in_elem.sty {\n+                        ty::TyInt(_) | ty::TyUint(_) => {},\n+                        _ => {\n+                            return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                          $name, in_ty, in_elem, ret_ty)\n+                        }\n+                    }\n+\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = Type::i1(bx.cx);\n+                    let i1xn = Type::vector(&i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$red(input);\n+                        Ok(\n+                            if !$boolean {\n+                                r\n+                            } else {\n+                                bx.zext(r, Type::bool(bx.cx))\n+                            }\n+                        )\n+                    },\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n+    bitwise_red!(\"simd_reduce_and\": vector_reduce_and, false);\n+    bitwise_red!(\"simd_reduce_or\": vector_reduce_or, false);\n+    bitwise_red!(\"simd_reduce_xor\": vector_reduce_xor, false);\n+    bitwise_red!(\"simd_reduce_all\": vector_reduce_and, true);\n+    bitwise_red!(\"simd_reduce_any\": vector_reduce_or, true);\n+\n     if name == \"simd_cast\" {\n         require_simd!(ret_ty, \"return\");\n         let out_len = ret_ty.simd_size(tcx);"}, {"sha": "99707a4a3c0e59618e9fc36fd15e274adf16533d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -361,6 +361,14 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n+        \"simd_reduce_add_ordered\" | \"simd_reduce_mul_ordered\"\n+            => (2, vec![param(0), param(1)], param(1)),\n+        \"simd_reduce_add_unordered\" | \"simd_reduce_mul_unordered\" |\n+        \"simd_reduce_and\" | \"simd_reduce_or\"  | \"simd_reduce_xor\" |\n+        \"simd_reduce_min\" | \"simd_reduce_max\" |\n+        \"simd_reduce_min_nanless\" | \"simd_reduce_max_nanless\"\n+            => (2, vec![param(0)], param(1)),\n         name if name.starts_with(\"simd_shuffle\") => {\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {"}, {"sha": "a5644d6f9e2e1fab9edd6278eb8110ef8dae8d15", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -21,6 +21,8 @@\n \n #if LLVM_VERSION_GE(5, 0)\n #include \"llvm/ADT/Optional.h\"\n+#else\n+#include <cstdlib>\n #endif\n \n //===----------------------------------------------------------------------===\n@@ -1395,3 +1397,98 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n   auto f = unwrap(M)->functions();\n   return std::distance(std::begin(f), std::end(f));\n }\n+\n+// Vector reductions:\n+#if LLVM_VERSION_GE(5, 0)\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFAddReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMul(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFMulReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAdd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAddReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMul(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateMulReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAnd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAndReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceOr(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateOrReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceXor(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateXorReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMin(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMinReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMax(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMaxReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMin(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+   return wrap(unwrap(B)->CreateFPMinReduce(unwrap(Src), NoNaN));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMax(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+  return wrap(unwrap(B)->CreateFPMaxReduce(unwrap(Src), NoNaN));\n+}\n+\n+#else\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAdd(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMul(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAnd(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceOr(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceXor(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMin(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMax(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMin(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMax(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+#endif"}, {"sha": "57e4bb76a6ce8272678833bd3c98483e6639ef32", "filename": "src/test/compile-fail/simd-intrinsic-generic-reduction.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// min-llvm-version 5.0\n+// ignore-emscripten\n+\n+// Test that the simd_reduce_{op} intrinsics produce ok-ish error\n+// messages when misused.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n+    fn simd_reduce_and<T, U>(x: T) -> U;\n+    fn simd_reduce_or<T, U>(x: T) -> U;\n+    fn simd_reduce_xor<T, U>(x: T) -> U;\n+    fn simd_reduce_all<T>(x: T) -> bool;\n+    fn simd_reduce_any<T>(x: T) -> bool;\n+}\n+\n+fn main() {\n+    let x = u32x4(0, 0, 0, 0);\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+\n+    unsafe {\n+        simd_reduce_add_ordered(z, 0_f32);\n+        simd_reduce_mul_ordered(z, 1_f32);\n+\n+        simd_reduce_add_ordered(z, 2_f32);\n+        //~^ ERROR accumulator of simd_reduce_add_ordered is not 0.0\n+        simd_reduce_mul_ordered(z, 3_f32);\n+        //~^ ERROR accumulator of simd_reduce_mul_ordered is not 1.0\n+\n+        let _: f32 = simd_reduce_and(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+        let _: f32 = simd_reduce_or(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+        let _: f32 = simd_reduce_xor(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+\n+        let _: f32 = simd_reduce_and(z);\n+        //~^ ERROR unsupported simd_reduce_and from `f32x4` with element `f32` to `f32`\n+        let _: f32 = simd_reduce_or(z);\n+        //~^ ERROR unsupported simd_reduce_or from `f32x4` with element `f32` to `f32`\n+        let _: f32 = simd_reduce_xor(z);\n+        //~^ ERROR unsupported simd_reduce_xor from `f32x4` with element `f32` to `f32`\n+\n+        let _: bool = simd_reduce_all(z);\n+        //~^ ERROR unsupported simd_reduce_all from `f32x4` with element `f32` to `bool`\n+        let _: bool = simd_reduce_any(z);\n+        //~^ ERROR unsupported simd_reduce_any from `f32x4` with element `f32` to `bool`\n+\n+        foo(0_f32);\n+    }\n+}\n+\n+#[inline(never)]\n+unsafe fn foo(x: f32) {\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+    simd_reduce_add_ordered(z, x);\n+    //~^ ERROR accumulator of simd_reduce_add_ordered is not a constant\n+    simd_reduce_mul_ordered(z, x);\n+    //~^ ERROR accumulator of simd_reduce_mul_ordered is not a constant\n+}"}, {"sha": "9a1214d3b35e5b7ac4ac2e2b022f961a739bc34b", "filename": "src/test/run-pass/simd-intrinsic-generic-reduction.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b724c6937462d19cb4e45431c2875f4ee051f6d3/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs?ref=b724c6937462d19cb4e45431c2875f4ee051f6d3", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// min-llvm-version 5.0\n+// ignore-emscripten\n+\n+// Test that the simd_reduce_{op} intrinsics produce the correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#[allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x4(pub i8, pub i8, pub i8, pub i8);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x16(\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8\n+);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_reduce_add_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_mul_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;\n+    fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;\n+    fn simd_reduce_min<T, U>(x: T) -> U;\n+    fn simd_reduce_max<T, U>(x: T) -> U;\n+    fn simd_reduce_min_nanless<T, U>(x: T) -> U;\n+    fn simd_reduce_max_nanless<T, U>(x: T) -> U;\n+    fn simd_reduce_and<T, U>(x: T) -> U;\n+    fn simd_reduce_or<T, U>(x: T) -> U;\n+    fn simd_reduce_xor<T, U>(x: T) -> U;\n+    fn simd_reduce_all<T>(x: T) -> bool;\n+    fn simd_reduce_any<T>(x: T) -> bool;\n+}\n+\n+fn main() {\n+    unsafe {\n+        let x = i32x4(1, -2, 3, 4);\n+        let r: i32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_i32);\n+        let r: i32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_i32);\n+        let r: i32 = simd_reduce_add_ordered(x, -1);\n+        assert_eq!(r, 5_i32);\n+        let r: i32 = simd_reduce_mul_ordered(x, -1);\n+        assert_eq!(r, 24_i32);\n+\n+        let r: i32 = simd_reduce_min(x);\n+        assert_eq!(r, -2_i32);\n+        let r: i32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_i32);\n+\n+        let x = i32x4(-1, -1, -1, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert_eq!(r, 0_i32);\n+\n+        let x = i32x4(-1, -1, 0, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert_eq!(r, 0_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert_eq!(r, -1_i32);\n+    }\n+\n+    unsafe {\n+        let x = u32x4(1, 2, 3, 4);\n+        let r: u32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 10_u32);\n+        let r: u32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, 24_u32);\n+        let r: u32 = simd_reduce_add_ordered(x, 1);\n+        assert_eq!(r, 11_u32);\n+        let r: u32 = simd_reduce_mul_ordered(x, 2);\n+        assert_eq!(r, 48_u32);\n+\n+        let r: u32 = simd_reduce_min(x);\n+        assert_eq!(r, 1_u32);\n+        let r: u32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_u32);\n+\n+        let t = u32::max_value();\n+        let x = u32x4(t, t, t, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_or(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert_eq!(r, 0_u32);\n+\n+        let x = u32x4(t, t, 0, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert_eq!(r, 0_u32);\n+        let r: u32 = simd_reduce_or(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert_eq!(r, t);\n+    }\n+\n+    unsafe {\n+        let x = f32x4(1., -2., 3., 4.);\n+        let r: f32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_f32);\n+        let r: f32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_f32);\n+        // FIXME: only works correctly for accumulator, 0:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_add_ordered(x, 0.);\n+        assert_eq!(r, 6_f32);\n+        // FIXME: only works correctly for accumulator, 1:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_mul_ordered(x, 1.);\n+        assert_eq!(r, -24_f32);\n+\n+        let r: f32 = simd_reduce_min(x);\n+        assert_eq!(r, -2_f32);\n+        let r: f32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_f32);\n+        let r: f32 = simd_reduce_min_nanless(x);\n+        assert_eq!(r, -2_f32);\n+        let r: f32 = simd_reduce_max_nanless(x);\n+        assert_eq!(r, 4_f32);\n+    }\n+\n+    unsafe {\n+        let x = b8x4(!0, !0, !0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, true);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, true);\n+\n+        let x = b8x4(!0, !0, 0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, false);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, true);\n+\n+        let x = b8x4(0, 0, 0, 0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, false);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, false);\n+    }\n+}"}]}