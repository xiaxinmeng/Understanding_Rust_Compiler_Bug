{"sha": "4b1d3b703629db036ce685a852b80bf196419bb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMWQzYjcwMzYyOWRiMDM2Y2U2ODVhODUyYjgwYmYxOTY0MTliYjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:41:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:41:20Z"}, "message": "rewrite `free_region`/`region_inference` to use newly minted\n`TransitiveRelation`", "tree": {"sha": "20f4521969314e7c831a3b5e21f459b3289f6235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20f4521969314e7c831a3b5e21f459b3289f6235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b1d3b703629db036ce685a852b80bf196419bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1d3b703629db036ce685a852b80bf196419bb5", "html_url": "https://github.com/rust-lang/rust/commit/4b1d3b703629db036ce685a852b80bf196419bb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b1d3b703629db036ce685a852b80bf196419bb5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e126e498412bf0531eab499edc2fbe6bf52af2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e126e498412bf0531eab499edc2fbe6bf52af2a", "html_url": "https://github.com/rust-lang/rust/commit/5e126e498412bf0531eab499edc2fbe6bf52af2a"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "787303231b039a31e53716d43f96c3c3b16ab8b6", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4b1d3b703629db036ce685a852b80bf196419bb5/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1d3b703629db036ce685a852b80bf196419bb5/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=4b1d3b703629db036ce685a852b80bf196419bb5", "patch": "@@ -10,24 +10,18 @@\n \n //! This file defines\n \n+use middle::ty::{self, FreeRegion, Region};\n use middle::wf::ImpliedBound;\n-use middle::ty::{self, FreeRegion};\n-use util::common::can_reach;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n-    /// `map` maps from a free region `a` to a list of\n-    /// free regions `bs` such that `a <= b for all b in bs`\n-    map: FnvHashMap<FreeRegion, Vec<FreeRegion>>,\n-    /// regions that are required to outlive (and therefore be\n-    /// equal to) 'static.\n-    statics: FnvHashSet<FreeRegion>\n+    relation: TransitiveRelation<Region>\n }\n \n impl FreeRegionMap {\n     pub fn new() -> FreeRegionMap {\n-        FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n+        FreeRegionMap { relation: TransitiveRelation::new() }\n     }\n \n     pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n@@ -84,22 +78,38 @@ impl FreeRegionMap {\n     }\n \n     fn relate_to_static(&mut self, sup: FreeRegion) {\n-        self.statics.insert(sup);\n+        self.relation.add(ty::ReStatic, ty::ReFree(sup));\n     }\n \n     fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-       let mut sups = self.map.entry(sub).or_insert(Vec::new());\n-        if !sups.contains(&sup) {\n-            sups.push(sup);\n-        }\n+        self.relation.add(ty::ReFree(sub), ty::ReFree(sup))\n     }\n \n     /// Determines whether two free regions have a subregion relationship\n     /// by walking the graph encoded in `map`.  Note that\n     /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n     /// (that is, the user can give two different names to the same lifetime).\n     pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        can_reach(&self.map, sub, sup) || self.is_static(&sup)\n+        let result = sub == sup || {\n+            let sub = ty::ReFree(sub);\n+            let sup = ty::ReFree(sup);\n+            self.relation.contains(&sub, &sup) || self.relation.contains(&sup, &ty::ReStatic)\n+        };\n+        debug!(\"sub_free_region(sub={:?}, sup={:?}) = {:?}\", sub, sup, result);\n+        result\n+    }\n+\n+    pub fn lub_free_regions(&self, fr_a: FreeRegion, fr_b: FreeRegion) -> Region {\n+        let r_a = ty::ReFree(fr_a);\n+        let r_b = ty::ReFree(fr_b);\n+        let result = if fr_a == fr_b { r_a } else {\n+            match self.relation.best_upper_bound(&r_a, &r_b) {\n+                None => ty::ReStatic,\n+                Some(r) => *r,\n+            }\n+        };\n+        debug!(\"lub_free_regions(fr_a={:?}, fr_b={:?}) = {:?}\", fr_a, fr_b, result);\n+        result\n     }\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n@@ -109,10 +119,7 @@ impl FreeRegionMap {\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {\n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n-               sub_region, super_region);\n-\n-        sub_region == super_region || {\n+        let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n                 (ty::ReEmpty, _) |\n                 (_, ty::ReStatic) =>\n@@ -121,23 +128,47 @@ impl FreeRegionMap {\n                 (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()),\n+                (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n+                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()) ||\n+                    self.is_static(fr),\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n-                (ty::ReStatic, ty::ReFree(ref sup_fr)) => self.is_static(sup_fr),\n+                (ty::ReStatic, ty::ReFree(sup_fr)) =>\n+                    self.is_static(sup_fr),\n \n                 _ =>\n                     false,\n             }\n-        }\n+        };\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n+               sub_region, super_region, result);\n+        result\n     }\n \n     /// Determines whether this free-region is required to be 'static\n-    pub fn is_static(&self, super_region: &ty::FreeRegion) -> bool {\n+    pub fn is_static(&self, super_region: ty::FreeRegion) -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n-        self.statics.iter().any(|s| can_reach(&self.map, *s, *super_region))\n+        self.relation.contains(&ty::ReStatic, &ty::ReFree(super_region))\n     }\n }\n+\n+#[cfg(test)]\n+fn free_region(index: u32) -> FreeRegion {\n+    use middle::region::DestructionScopeData;\n+    FreeRegion { scope: DestructionScopeData::new(0),\n+                 bound_region: ty::BoundRegion::BrAnon(index) }\n+}\n+\n+#[test]\n+fn lub() {\n+    // a very VERY basic test, but see the tests in\n+    // TransitiveRelation, which are much more thorough.\n+    let frs: Vec<_> = (0..3).map(|i| free_region(i)).collect();\n+    let mut map = FreeRegionMap::new();\n+    map.relate_free_regions(frs[0], frs[2]);\n+    map.relate_free_regions(frs[1], frs[2]);\n+    assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n+}\n+"}, {"sha": "e04f2955ddc18a2b348e22a4ec07644b0c1f4480", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b1d3b703629db036ce685a852b80bf196419bb5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1d3b703629db036ce685a852b80bf196419bb5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=4b1d3b703629db036ce685a852b80bf196419bb5", "patch": "@@ -812,8 +812,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n           }\n \n-          (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n-             self.lub_free_regions(free_regions, a_fr, b_fr)\n+          (ReFree(a_fr), ReFree(b_fr)) => {\n+            free_regions.lub_free_regions(a_fr, b_fr)\n           }\n \n           // For these types, we cannot define any additional\n@@ -825,35 +825,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    /// Computes a region that encloses both free region arguments. Guarantee that if the same two\n-    /// regions are given as argument, in any order, a consistent result is returned.\n-    fn lub_free_regions(&self,\n-                        free_regions: &FreeRegionMap,\n-                        a: &FreeRegion,\n-                        b: &FreeRegion)\n-                        -> ty::Region\n-    {\n-        return match a.cmp(b) {\n-            Less => helper(self, free_regions, a, b),\n-            Greater => helper(self, free_regions, b, a),\n-            Equal => ty::ReFree(*a)\n-        };\n-\n-        fn helper(_this: &RegionVarBindings,\n-                  free_regions: &FreeRegionMap,\n-                  a: &FreeRegion,\n-                  b: &FreeRegion) -> ty::Region\n-        {\n-            if free_regions.sub_free_region(*a, *b) {\n-                ty::ReFree(*b)\n-            } else if free_regions.sub_free_region(*b, *a) {\n-                ty::ReFree(*a)\n-            } else {\n-                ty::ReStatic\n-            }\n-        }\n-    }\n-\n     fn glb_concrete_regions(&self,\n                             free_regions: &FreeRegionMap,\n                             a: Region,\n@@ -892,8 +863,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             b));\n             }\n \n-            (ReFree(ref fr), ReScope(s_id)) |\n-            (ReScope(s_id), ReFree(ref fr)) => {\n+            (ReFree(fr), ReScope(s_id)) |\n+            (ReScope(s_id), ReFree(fr)) => {\n                 let s = ReScope(s_id);\n                 // Free region is something \"at least as big as\n                 // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger"}]}