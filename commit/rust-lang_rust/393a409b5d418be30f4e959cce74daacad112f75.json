{"sha": "393a409b5d418be30f4e959cce74daacad112f75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5M2E0MDliNWQ0MThiZTMwZjRlOTU5Y2NlNzRkYWFjYWQxMTJmNzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-04T13:54:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-07T05:16:04Z"}, "message": "Add pop() and swap() to the Map trait", "tree": {"sha": "60f81de6d4528367aecedf3ed158ba7bc86599fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60f81de6d4528367aecedf3ed158ba7bc86599fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/393a409b5d418be30f4e959cce74daacad112f75", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/393a409b5d418be30f4e959cce74daacad112f75", "html_url": "https://github.com/rust-lang/rust/commit/393a409b5d418be30f4e959cce74daacad112f75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/393a409b5d418be30f4e959cce74daacad112f75/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b6864f2195250d34cbedf92ffaf23a400c71b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6864f2195250d34cbedf92ffaf23a400c71b9e", "html_url": "https://github.com/rust-lang/rust/commit/4b6864f2195250d34cbedf92ffaf23a400c71b9e"}], "stats": {"total": 270, "additions": 187, "deletions": 83}, "files": [{"sha": "37b904bbe632732555a95fa72c0ad49f56df25eb", "filename": "src/libcore/container.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -55,6 +55,14 @@ pub trait Map<K, V>: Mutable {\n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n     fn remove(&mut self, key: &K) -> bool;\n+\n+    /// Insert a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise None is returned.\n+    fn swap(&mut self, k: K, v: V) -> Option<V>;\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    fn pop(&mut self, k: &K) -> Option<V>;\n }\n \n pub trait Set<T>: Mutable {"}, {"sha": "33fdc98137e8dde0751c8d0b586714166b8c4a97", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -24,8 +24,8 @@ use rand::RngUtil;\n use rand;\n use uint;\n use vec;\n-use util::unreachable;\n use kinds::Copy;\n+use util::{replace, unreachable};\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -204,7 +204,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     /// Inserts the key value pair into the buckets.\n     /// Assumes that there will be a bucket.\n     /// True if there was no previous entry with that key\n-    fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n+    fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => { fail!(~\"Internal logic error\"); }\n             FoundHole(idx) => {\n@@ -213,14 +213,19 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                 self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n                                                 value: v});\n                 self.size += 1;\n-                true\n+                None\n             }\n             FoundEntry(idx) => {\n                 debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                value: v});\n-                false\n+                match self.buckets[idx] {\n+                    None => { fail!(~\"insert_internal: Internal logic error\") }\n+                    Some(ref mut b) => {\n+                        b.hash = hash;\n+                        b.key = k;\n+                        Some(replace(&mut b.value, v))\n+                    }\n+                }\n             }\n         }\n     }\n@@ -361,6 +366,20 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n     fn insert(&mut self, k: K, v: V) -> bool {\n+        self.swap(k, v).is_none()\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, k: &K) -> bool {\n+        self.pop(k).is_some()\n+    }\n+\n+    /// Insert a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise None is returned.\n+    fn swap(&mut self, k: K, v: V) -> Option<V> {\n+        // this could be faster.\n+\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -375,10 +394,11 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         self.insert_internal(hash, k, v)\n     }\n \n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    fn remove(&mut self, k: &K) -> bool {\n-        self.pop(k).is_some()\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    fn pop(&mut self, k: &K) -> Option<V> {\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        self.pop_internal(hash, k)\n     }\n }\n \n@@ -402,31 +422,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    fn pop(&mut self, k: &K) -> Option<V> {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        self.pop_internal(hash, k)\n-    }\n-\n-    fn swap(&mut self, k: K, v: V) -> Option<V> {\n-        // this could be faster.\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let old_value = self.pop_internal(hash, &k);\n-\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        self.insert_internal(hash, k, v);\n-\n-        old_value\n-    }\n-\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {"}, {"sha": "380ad11ae9245187b5a5582dad55b606b2f6e421", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -11,6 +11,7 @@\n //! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n+use util::{swap, replace};\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n@@ -110,21 +111,33 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     /// not already exist in the map.\n     #[inline(always)]\n     fn insert(&mut self, key: uint, value: T) -> bool {\n-        let ret = insert(&mut self.root.count,\n-                         &mut self.root.children[chunk(key, 0)],\n-                         key, value, 1);\n-        if ret { self.length += 1 }\n-        ret\n+        self.swap(key, value).is_none()\n     }\n \n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n     #[inline(always)]\n     fn remove(&mut self, key: &uint) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Insert a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise None is returned.\n+    fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+        let ret = insert(&mut self.root.count,\n+                         &mut self.root.children[chunk(key, 0)],\n+                         key, value, 1);\n+        if ret.is_none() { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    fn pop(&mut self, key: &uint) -> Option<T> {\n         let ret = remove(&mut self.root.count,\n                          &mut self.root.children[chunk(*key, 0)],\n                          *key, 1);\n-        if ret { self.length -= 1 }\n+        if ret.is_some() { self.length -= 1 }\n         ret\n     }\n }\n@@ -289,61 +302,65 @@ fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint)\n }\n \n fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n-             idx: uint) -> bool {\n+             idx: uint) -> Option<T> {\n     let mut tmp = Nothing;\n-    tmp <-> *child;\n-    let mut added = false;\n+    let ret;\n+    swap(&mut tmp, child);\n \n     *child = match tmp {\n       External(stored_key, stored_value) => {\n           if stored_key == key {\n+              ret = Some(stored_value);\n               External(stored_key, value)\n           } else {\n               // conflict - split the node\n               let mut new = ~TrieNode::new();\n               insert(&mut new.count,\n                      &mut new.children[chunk(stored_key, idx)],\n                      stored_key, stored_value, idx + 1);\n-              insert(&mut new.count, &mut new.children[chunk(key, idx)], key,\n-                     value, idx + 1);\n-              added = true;\n+              ret = insert(&mut new.count, &mut new.children[chunk(key, idx)],\n+                           key, value, idx + 1);\n               Internal(new)\n           }\n       }\n       Internal(x) => {\n         let mut x = x;\n-        added = insert(&mut x.count, &mut x.children[chunk(key, idx)], key,\n-                       value, idx + 1);\n+        ret = insert(&mut x.count, &mut x.children[chunk(key, idx)], key,\n+                     value, idx + 1);\n         Internal(x)\n       }\n       Nothing => {\n         *count += 1;\n-        added = true;\n+        ret = None;\n         External(key, value)\n       }\n     };\n-    added\n+    return ret;\n }\n \n fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n-             idx: uint) -> bool {\n+             idx: uint) -> Option<T> {\n     let (ret, this) = match *child {\n-      External(stored, _) => {\n-          if stored == key { (true, true) } else { (false, false) }\n+      External(stored, _) if stored == key => {\n+        match replace(child, Nothing) {\n+            External(_, value) => (Some(value), true),\n+            _ => fail!()\n+        }\n       }\n+      External(*) => (None, false),\n       Internal(ref mut x) => {\n           let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n                            key, idx + 1);\n           (ret, x.count == 0)\n       }\n-      Nothing => (false, false)\n+      Nothing => (None, false)\n     };\n \n     if this {\n         *child = Nothing;\n         *count -= 1;\n     }\n-    ret\n+    return ret;\n }\n \n #[cfg(test)]\n@@ -516,4 +533,20 @@ mod tests {\n             i += 1;\n         }\n     }\n+\n+    #[test]\n+    fn test_swap() {\n+        let mut m = TrieMap::new();\n+        assert!(m.swap(1, 2) == None);\n+        assert!(m.swap(1, 3) == Some(2));\n+        assert!(m.swap(1, 4) == Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = TrieMap::new();\n+        m.insert(1, 2);\n+        assert!(m.pop(&1) == Some(2));\n+        assert!(m.pop(&1) == None);\n+    }\n }"}, {"sha": "fc83a39cacf9a71fe909ddb21002ec7618f92d80", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -16,6 +16,7 @@\n use core::container::{Container, Mutable, Map, Set};\n use core::old_iter::{BaseIter};\n use core::option::{Some, None};\n+use core::util::replace;\n \n pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n@@ -119,12 +120,27 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n     fn remove(&mut self, key: &uint) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Insert a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise None is returned.\n+    fn swap(&mut self, key: uint, value: V) -> Option<V> {\n+        match self.find_mut(&key) {\n+            Some(loc) => { return Some(replace(loc, value)); }\n+            None => ()\n+        }\n+        self.insert(key, value);\n+        return None;\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    fn pop(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n-            return false;\n+            return None;\n         }\n-        let removed = self.v[*key].is_some();\n-        self.v[*key] = None;\n-        removed\n+        replace(&mut self.v[*key], None)\n     }\n }\n \n@@ -237,4 +253,20 @@ mod tests {\n         // sadly, no sevens were counted\n         assert!(map.find(&7).is_none());\n     }\n+\n+    #[test]\n+    fn test_swap() {\n+        let mut m = SmallIntMap::new();\n+        assert!(m.swap(1, 2) == None);\n+        assert!(m.swap(1, 3) == Some(2));\n+        assert!(m.swap(1, 4) == Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = SmallIntMap::new();\n+        m.insert(1, 2);\n+        assert!(m.pop(&1) == Some(2));\n+        assert!(m.pop(&1) == None);\n+    }\n }"}, {"sha": "c8ab48e65c06576350f68a75bbe402c64c8e7964", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -13,6 +13,7 @@\n //! `TotalOrd`.\n \n use core::iterator::*;\n+use core::util::replace;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where where red (horizontal) nodes can only be added\n@@ -150,16 +151,28 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n     fn insert(&mut self, key: K, value: V) -> bool {\n-        let ret = insert(&mut self.root, key, value);\n-        if ret { self.length += 1 }\n-        ret\n+        self.swap(key, value).is_none()\n     }\n \n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n     fn remove(&mut self, key: &K) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Insert a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise None is returned.\n+    fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        let ret = insert(&mut self.root, key, value);\n+        if ret.is_none() { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    fn pop(&mut self, key: &K) -> Option<V> {\n         let ret = remove(&mut self.root, key);\n-        if ret { self.length -= 1 }\n+        if ret.is_some() { self.length -= 1 }\n         ret\n     }\n }\n@@ -581,7 +594,8 @@ fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n     }\n }\n \n-fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K, value: V) -> bool {\n+fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+                          key: K, value: V) -> Option<V> {\n     match *node {\n       Some(ref mut save) => {\n         match key.cmp(&save.key) {\n@@ -599,20 +613,19 @@ fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K, value: V)\n           }\n           Equal => {\n             save.key = key;\n-            save.value = value;\n-            false\n+            Some(replace(&mut save.value, value))\n           }\n         }\n       }\n       None => {\n        *node = Some(~TreeNode::new(key, value));\n-        true\n+        None\n       }\n     }\n }\n \n fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n-                          key: &K) -> bool {\n+                          key: &K) -> Option<V> {\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                             child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n@@ -628,12 +641,12 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n \n     match *node {\n       None => {\n-        return false // bottom of tree\n+        return None; // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (removed, this) = match key.cmp(&save.key) {\n-          Less => (remove(&mut save.left, key), false),\n-          Greater => (remove(&mut save.right, key), false),\n+        let (ret, rebalance) = match key.cmp(&save.key) {\n+          Less => (remove(&mut save.left, key), true),\n+          Greater => (remove(&mut save.right, key), true),\n           Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n@@ -645,21 +658,24 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                         save.value <-> left.value;\n                     }\n                     save.left = Some(left);\n-                    remove(&mut save.left, key);\n+                    (remove(&mut save.left, key), true)\n                 } else {\n+                    let new = save.left.swap_unwrap();\n+                    let ~TreeNode{value, _} = replace(save, new);\n                     *save = save.left.swap_unwrap();\n+                    (Some(value), true)\n                 }\n-                (true, false)\n             } else if save.right.is_some() {\n-                *save = save.right.swap_unwrap();\n-                (true, false)\n+                let new = save.right.swap_unwrap();\n+                let ~TreeNode{value, _} = replace(save, new);\n+                (Some(value), true)\n             } else {\n-                (true, true)\n+                (None, false)\n             }\n           }\n         };\n \n-        if !this {\n+        if rebalance {\n             let left_level = save.left.map_default(0, |x| x.level);\n             let right_level = save.right.map_default(0, |x| x.level);\n \n@@ -682,13 +698,13 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                 for save.right.each_mut |x| { split(x) }\n             }\n \n-            return removed;\n+            return ret;\n         }\n       }\n     }\n-\n-    *node = None;\n-    true\n+    return match replace(node, None) {\n+        Some(~TreeNode{value, _}) => Some(value), None => fail!()\n+    };\n }\n \n #[cfg(test)]\n@@ -1217,4 +1233,20 @@ mod test_set {\n         let result: Option<(&uint, & &'static str)> = z.next();\n         assert!(result.is_none());\n     }\n+\n+    #[test]\n+    fn test_swap() {\n+        let mut m = TreeMap::new();\n+        assert!(m.swap(1, 2) == None);\n+        assert!(m.swap(1, 3) == Some(2));\n+        assert!(m.swap(1, 4) == Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = TreeMap::new();\n+        m.insert(1, 2);\n+        assert!(m.pop(&1) == Some(2));\n+        assert!(m.pop(&1) == None);\n+    }\n }"}, {"sha": "b89bf06409274566f77486f0b80819972009d409", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/393a409b5d418be30f4e959cce74daacad112f75/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393a409b5d418be30f4e959cce74daacad112f75/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=393a409b5d418be30f4e959cce74daacad112f75", "patch": "@@ -103,6 +103,10 @@ impl<T> Map<int, T> for cat<T> {\n             false\n         }\n     }\n+\n+    fn pop(&mut self, _k: &int) -> Option<T> { fail!() }\n+\n+    fn swap(&mut self, _k: int, _v: T) -> Option<T> { fail!() }\n }\n \n pub impl<T> cat<T> {"}]}