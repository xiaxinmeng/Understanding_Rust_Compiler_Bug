{"sha": "5e148200d457ef7f6740990d15b7b9c534e3aaeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTQ4MjAwZDQ1N2VmN2Y2NzQwOTkwZDE1YjdiOWM1MzRlM2FhZWI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-01T08:49:42Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-08T17:24:17Z"}, "message": "Use a submodule as safety boundary for BoxedResolver", "tree": {"sha": "fe01a047e7d5f0da253559502c015da2f2237ae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe01a047e7d5f0da253559502c015da2f2237ae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e148200d457ef7f6740990d15b7b9c534e3aaeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e148200d457ef7f6740990d15b7b9c534e3aaeb", "html_url": "https://github.com/rust-lang/rust/commit/5e148200d457ef7f6740990d15b7b9c534e3aaeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e148200d457ef7f6740990d15b7b9c534e3aaeb/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "url": "https://api.github.com/repos/rust-lang/rust/commits/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "html_url": "https://github.com/rust-lang/rust/commit/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "a6115762a82eca93b7047b8a1d5388455c6ec54d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5e148200d457ef7f6740990d15b7b9c534e3aaeb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e148200d457ef7f6740990d15b7b9c534e3aaeb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=5e148200d457ef7f6740990d15b7b9c534e3aaeb", "patch": "@@ -86,66 +86,71 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n-\n-// Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n-// then resolver_arenas and finally session.\n-// The drop order is defined to be from top to bottom in RFC1857, so there is no need for\n-// ManuallyDrop for as long as the fields are not reordered.\n-struct BoxedResolverInner {\n-    resolver: Option<Resolver<'static>>,\n-    resolver_arenas: ResolverArenas<'static>,\n-    session: Lrc<Session>,\n-    _pin: PhantomPinned,\n-}\n+pub use boxed_resolver::BoxedResolver;\n+mod boxed_resolver {\n+    use super::*;\n+\n+    pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n+\n+    // Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n+    // then resolver_arenas and finally session.\n+    // The drop order is defined to be from top to bottom in RFC1857, so there is no need for\n+    // ManuallyDrop for as long as the fields are not reordered.\n+    struct BoxedResolverInner {\n+        resolver: Option<Resolver<'static>>,\n+        resolver_arenas: ResolverArenas<'static>,\n+        session: Lrc<Session>,\n+        _pin: PhantomPinned,\n+    }\n \n-impl BoxedResolver {\n-    fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n-    where\n-        F: for<'a> FnOnce(\n-            &'a Session,\n-            &'a ResolverArenas<'a>,\n-        ) -> Result<(ast::Crate, Resolver<'a>)>,\n-    {\n-        let mut boxed_resolver = Box::new(BoxedResolverInner {\n-            session,\n-            resolver_arenas: Resolver::arenas(),\n-            resolver: None,\n-            _pin: PhantomPinned,\n-        });\n-        unsafe {\n-            let (crate_, resolver) = make_resolver(\n-                std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n-                std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n-                    &boxed_resolver.resolver_arenas,\n-                ),\n-            )?;\n-            boxed_resolver.resolver =\n-                Some(std::mem::transmute::<Resolver<'_>, Resolver<'_>>(resolver));\n-            Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+    impl BoxedResolver {\n+        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n+        where\n+            F: for<'a> FnOnce(\n+                &'a Session,\n+                &'a ResolverArenas<'a>,\n+            ) -> Result<(ast::Crate, Resolver<'a>)>,\n+        {\n+            let mut boxed_resolver = Box::new(BoxedResolverInner {\n+                session,\n+                resolver_arenas: Resolver::arenas(),\n+                resolver: None,\n+                _pin: PhantomPinned,\n+            });\n+            unsafe {\n+                let (crate_, resolver) = make_resolver(\n+                    std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n+                    std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n+                        &boxed_resolver.resolver_arenas,\n+                    ),\n+                )?;\n+                boxed_resolver.resolver =\n+                    Some(std::mem::transmute::<Resolver<'_>, Resolver<'_>>(resolver));\n+                Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+            }\n         }\n-    }\n \n-    pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n-        let mut resolver = unsafe {\n-            self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n-        };\n-        f((&mut *resolver).as_mut().unwrap())\n-    }\n+        pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n+            let mut resolver = unsafe {\n+                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+            };\n+            f((&mut *resolver).as_mut().unwrap())\n+        }\n \n-    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n-        match Rc::try_unwrap(resolver) {\n-            Ok(resolver) => {\n-                let mut resolver = resolver.into_inner();\n-                let mut resolver = unsafe {\n-                    resolver\n-                        .0\n-                        .as_mut()\n-                        .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n-                };\n-                resolver.take().unwrap().into_outputs()\n+        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n+            match Rc::try_unwrap(resolver) {\n+                Ok(resolver) => {\n+                    let mut resolver = resolver.into_inner();\n+                    let mut resolver = unsafe {\n+                        resolver\n+                            .0\n+                            .as_mut()\n+                            .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+                    };\n+                    resolver.take().unwrap().into_outputs()\n+                }\n+                Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n             }\n-            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n         }\n     }\n }"}]}