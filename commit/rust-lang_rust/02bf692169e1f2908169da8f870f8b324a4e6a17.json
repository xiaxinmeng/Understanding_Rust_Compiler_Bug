{"sha": "02bf692169e1f2908169da8f870f8b324a4e6a17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYmY2OTIxNjllMWYyOTA4MTY5ZGE4Zjg3MGY4YjMyNGE0ZTZhMTc=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-04-22T09:31:13Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-04-22T09:31:13Z"}, "message": "Merge commit '98e2b9f25b6db4b2680a3d388456d9f95cb28344' into clippyup", "tree": {"sha": "10f25d9e6e1a95384d9f2a0150fc19626d968c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10f25d9e6e1a95384d9f2a0150fc19626d968c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02bf692169e1f2908169da8f870f8b324a4e6a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02bf692169e1f2908169da8f870f8b324a4e6a17", "html_url": "https://github.com/rust-lang/rust/commit/02bf692169e1f2908169da8f870f8b324a4e6a17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02bf692169e1f2908169da8f870f8b324a4e6a17/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "419bf6bbd827f07406447419d84a154ce9294aa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/419bf6bbd827f07406447419d84a154ce9294aa8", "html_url": "https://github.com/rust-lang/rust/commit/419bf6bbd827f07406447419d84a154ce9294aa8"}], "stats": {"total": 6200, "additions": 4649, "deletions": 1551}, "files": [{"sha": "780ee9d63dfd298afbe988e78d88d0a65b26d6d2", "filename": ".github/PULL_REQUEST_TEMPLATE.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/.github%2FPULL_REQUEST_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/.github%2FPULL_REQUEST_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FPULL_REQUEST_TEMPLATE.md?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -3,7 +3,9 @@ Thank you for making Clippy better!\n We're collecting our changelog from pull request descriptions.\n If your PR only includes internal changes, you can just write\n `changelog: none`. Otherwise, please write a short comment\n-explaining your change.\n+explaining your change. Also, it's helpful for us that\n+the lint name is put into brackets `[]` and backticks `` ` ` ``,\n+e.g. ``[`lint_name`]``.\n \n If your PR fixes an issue, you can add \"fixes #issue_number\" into this\n PR description. This way the issue will be automatically closed when\n@@ -29,4 +31,5 @@ Delete this line and everything above before opening your PR.\n ---\n \n *Please write a short comment explaining your change (or \"none\" for internal only changes)*\n+\n changelog:"}, {"sha": "ae6f1aa1b30be0c3ae0c57f1e8d163eea13ef41b", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -34,15 +34,16 @@ jobs:\n       run: |\n         MESSAGE=$(git log --format=%B -n 1)\n         PR=$(echo \"$MESSAGE\" | grep -o \"#[0-9]*\" | head -1 | sed -e 's/^#//')\n-        output=$(curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -s \"https://api.github.com/repos/rust-lang/rust-clippy/pulls/$PR\" | \\\n-          python -c \"import sys, json; print(json.load(sys.stdin)['body'])\" | \\\n-          grep \"^changelog: \" | \\\n-          sed \"s/changelog: //g\")\n-        if [[ -z \"$output\" ]]; then\n+        body=$(curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -s \"https://api.github.com/repos/rust-lang/rust-clippy/pulls/$PR\" | \\\n+          python -c \"import sys, json; print(json.load(sys.stdin)['body'])\")\n+        output=$(grep \"^changelog:\\s*\\S\" <<< \"$body\" | sed \"s/changelog:\\s*//g\") || {\n           echo \"ERROR: PR body must contain 'changelog: ...'\"\n           exit 1\n-        elif [[ \"$output\" = \"none\" ]]; then\n+        }\n+        if [[ \"$output\" = \"none\" ]]; then\n           echo \"WARNING: changelog is 'none'\"\n+        else\n+          echo \"changelog: $output\"\n         fi\n       env:\n         PYTHONIOENCODING: 'utf-8'"}, {"sha": "204d56e2a9854bd137520e1a0280b64624d5066a", "filename": "CHANGELOG.md", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -179,7 +179,7 @@ Current stable, released 2021-03-25\n \n * Replace [`find_map`] with [`manual_find_map`]\n   [#6591](https://github.com/rust-lang/rust-clippy/pull/6591)\n-* [`unknown_clippy_lints`] Now integrated in the `unknown_lints` rustc lint\n+* `unknown_clippy_lints` Now integrated in the `unknown_lints` rustc lint\n   [#6653](https://github.com/rust-lang/rust-clippy/pull/6653)\n \n ### Enhancements\n@@ -280,7 +280,7 @@ Released 2021-02-11\n \n * Previously deprecated [`str_to_string`] and [`string_to_string`] have been un-deprecated\n   as `restriction` lints [#6333](https://github.com/rust-lang/rust-clippy/pull/6333)\n-* Deprecate [`panic_params`] lint. This is now available in rustc as `panic_fmt`\n+* Deprecate `panic_params` lint. This is now available in rustc as `non_fmt_panic`\n   [#6351](https://github.com/rust-lang/rust-clippy/pull/6351)\n * Move [`map_err_ignore`] to `restriction`\n   [#6416](https://github.com/rust-lang/rust-clippy/pull/6416)\n@@ -419,7 +419,7 @@ Released 2020-12-31\n   [#6037](https://github.com/rust-lang/rust-clippy/pull/6037)\n * Rename `zero_width_space` to [`invisible_characters`]\n   [#6105](https://github.com/rust-lang/rust-clippy/pull/6105)\n-* Deprecate [`drop_bounds`] (uplifted)\n+* Deprecate `drop_bounds` (uplifted)\n   [#6111](https://github.com/rust-lang/rust-clippy/pull/6111)\n * Move [`string_lit_as_bytes`] to `nursery`\n   [#6117](https://github.com/rust-lang/rust-clippy/pull/6117)\n@@ -1018,7 +1018,7 @@ Released 2020-03-12\n   [#5015](https://github.com/rust-lang/rust-clippy/pull/5015)\n * Move [`range_plus_one`] to pedantic group [#5057](https://github.com/rust-lang/rust-clippy/pull/5057)\n * Move [`debug_assert_with_mut_call`] to nursery group [#5106](https://github.com/rust-lang/rust-clippy/pull/5106)\n-* Deprecate [`unused_label`] [#4930](https://github.com/rust-lang/rust-clippy/pull/4930)\n+* Deprecate `unused_label` [#4930](https://github.com/rust-lang/rust-clippy/pull/4930)\n \n ### Enhancements\n \n@@ -1046,7 +1046,7 @@ Released 2020-03-12\n * [`wildcard_enum_match_arm`] [#4934](https://github.com/rust-lang/rust-clippy/pull/4934)\n * [`cognitive_complexity`] [#4935](https://github.com/rust-lang/rust-clippy/pull/4935)\n * [`decimal_literal_representation`] [#4956](https://github.com/rust-lang/rust-clippy/pull/4956)\n-* [`unknown_clippy_lints`] [#4963](https://github.com/rust-lang/rust-clippy/pull/4963)\n+* `unknown_clippy_lints` [#4963](https://github.com/rust-lang/rust-clippy/pull/4963)\n * [`explicit_into_iter_loop`] [#4978](https://github.com/rust-lang/rust-clippy/pull/4978)\n * [`useless_attribute`] [#5022](https://github.com/rust-lang/rust-clippy/pull/5022)\n * [`if_let_some_result`] [#5032](https://github.com/rust-lang/rust-clippy/pull/5032)\n@@ -1080,7 +1080,7 @@ Released 2020-01-30\n   [Inside Rust Blog](https://blog.rust-lang.org/inside-rust/2019/11/04/Clippy-removes-plugin-interface.html) for\n   details [#4714](https://github.com/rust-lang/rust-clippy/pull/4714)\n * Move [`use_self`] to nursery group [#4863](https://github.com/rust-lang/rust-clippy/pull/4863)\n-* Deprecate [`into_iter_on_array`] [#4788](https://github.com/rust-lang/rust-clippy/pull/4788)\n+* Deprecate `into_iter_on_array` [#4788](https://github.com/rust-lang/rust-clippy/pull/4788)\n * Expand [`string_lit_as_bytes`] to also trigger when literal has escapes\n   [#4808](https://github.com/rust-lang/rust-clippy/pull/4808)\n * Fix false positive in `comparison_chain` [#4842](https://github.com/rust-lang/rust-clippy/pull/4842)\n@@ -1282,7 +1282,7 @@ Released 2019-05-20\n \n [1fac380..37f5c1e](https://github.com/rust-lang/rust-clippy/compare/1fac380...37f5c1e)\n \n-* New lint: [`drop_bounds`] to detect `T: Drop` bounds\n+* New lint: `drop_bounds` to detect `T: Drop` bounds\n * Split [`redundant_closure`] into [`redundant_closure`] and [`redundant_closure_for_method_calls`] [#4110](https://github.com/rust-lang/rust-clippy/pull/4101)\n * Rename `cyclomatic_complexity` to [`cognitive_complexity`], start work on making lint more practical for Rust code\n * Move [`get_unwrap`] to the restriction category\n@@ -1375,7 +1375,7 @@ Released 2019-01-17\n \n * New lints: [`slow_vector_initialization`], [`mem_discriminant_non_enum`],\n   [`redundant_clone`], [`wildcard_dependencies`],\n-  [`into_iter_on_ref`], [`into_iter_on_array`], [`deprecated_cfg_attr`],\n+  [`into_iter_on_ref`], `into_iter_on_array`, [`deprecated_cfg_attr`],\n   [`mem_discriminant_non_enum`], [`cargo_common_metadata`]\n * Add support for `u128` and `i128` to integer related lints\n * Add float support to `mistyped_literal_suffixes`\n@@ -1649,7 +1649,7 @@ Released 2018-09-13\n \n ## 0.0.166\n * Rustup to *rustc 1.22.0-nightly (b7960878b 2017-10-18)*\n-* New lints: [`explicit_write`], `identity_conversion`, [`implicit_hasher`], [`invalid_ref`], [`option_map_or_none`],\n+* New lints: [`explicit_write`], `identity_conversion`, [`implicit_hasher`], `invalid_ref`, [`option_map_or_none`],\n   [`range_minus_one`], [`range_plus_one`], [`transmute_int_to_bool`], [`transmute_int_to_char`],\n   [`transmute_int_to_float`]\n \n@@ -2037,7 +2037,7 @@ Released 2018-09-13\n \n ## 0.0.64 \u2014 2016-04-26\n * Rustup to *rustc 1.10.0-nightly (645dd013a 2016-04-24)*\n-* New lints: [`temporary_cstring_as_ptr`], [`unsafe_removed_from_name`], and [`mem_forget`]\n+* New lints: `temporary_cstring_as_ptr`, [`unsafe_removed_from_name`], and [`mem_forget`]\n \n ## 0.0.63 \u2014 2016-04-08\n * Rustup to *rustc 1.9.0-nightly (7979dd608 2016-04-07)*\n@@ -2091,7 +2091,7 @@ Released 2018-09-13\n \n ## 0.0.49 \u2014 2016-03-09\n * Update to *rustc 1.9.0-nightly (eabfc160f 2016-03-08)*\n-* New lints: [`overflow_check_conditional`], [`unused_label`], [`new_without_default`]\n+* New lints: [`overflow_check_conditional`], `unused_label`, [`new_without_default`]\n \n ## 0.0.48 \u2014 2016-03-07\n * Fixed: ICE in [`needless_range_loop`] with globals\n@@ -2124,6 +2124,7 @@ Released 2018-09-13\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n [`blanket_clippy_restriction_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n+[`bool_assert_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_assert_comparison\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n@@ -2148,6 +2149,7 @@ Released 2018-09-13\n [`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n [`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n [`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr\n+[`cloned_instead_of_copied`]: https://rust-lang.github.io/rust-clippy/master/index.html#cloned_instead_of_copied\n [`cmp_nan`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_nan\n [`cmp_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_null\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n@@ -2178,7 +2180,6 @@ Released 2018-09-13\n [`double_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_must_use\n [`double_neg`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_neg\n [`double_parens`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_parens\n-[`drop_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds\n [`drop_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_copy\n [`drop_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_ref\n [`duplicate_underscore_argument`]: https://rust-lang.github.io/rust-clippy/master/index.html#duplicate_underscore_argument\n@@ -2216,6 +2217,7 @@ Released 2018-09-13\n [`filter_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_next\n [`find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#find_map\n [`flat_map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#flat_map_identity\n+[`flat_map_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#flat_map_option\n [`float_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_arithmetic\n [`float_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp\n [`float_cmp_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp_const\n@@ -2264,10 +2266,9 @@ Released 2018-09-13\n [`int_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#int_plus_one\n [`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n-[`into_iter_on_array`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_array\n [`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n [`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n-[`invalid_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_ref\n+[`invalid_null_ptr_usage`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_null_ptr_usage\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n [`invisible_characters`]: https://rust-lang.github.io/rust-clippy/master/index.html#invisible_characters\n@@ -2402,7 +2403,6 @@ Released 2018-09-13\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n [`panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic\n [`panic_in_result_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_in_result_fn\n-[`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n@@ -2488,7 +2488,6 @@ Released 2018-09-13\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n-[`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n@@ -2517,13 +2516,13 @@ Released 2018-09-13\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord\n-[`unknown_clippy_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#unknown_clippy_lints\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n [`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unnecessary_wraps`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_wraps\n@@ -2541,7 +2540,6 @@ Released 2018-09-13\n [`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n-[`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n [`unusual_byte_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unusual_byte_groupings"}, {"sha": "02d2b63c9e199c936a7c86fbbd479f85ff924afe", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -21,10 +21,10 @@ All contributors are expected to follow the [Rust Code of Conduct].\n     - [IntelliJ Rust](#intellij-rust)\n     - [Rust Analyzer](#rust-analyzer)\n   - [How Clippy works](#how-clippy-works)\n-  - [Syncing changes between Clippy and [`rust-lang/rust`]](#syncing-changes-between-clippy-and-rust-langrust)\n+  - [Syncing changes between Clippy and `rust-lang/rust`](#syncing-changes-between-clippy-and-rust-langrust)\n     - [Patching git-subtree to work with big repos](#patching-git-subtree-to-work-with-big-repos)\n-    - [Performing the sync from [`rust-lang/rust`] to Clippy](#performing-the-sync-from-rust-langrust-to-clippy)\n-    - [Performing the sync from Clippy to [`rust-lang/rust`]](#performing-the-sync-from-clippy-to-rust-langrust)\n+    - [Performing the sync from `rust-lang/rust` to Clippy](#performing-the-sync-from-rust-langrust-to-clippy)\n+    - [Performing the sync from Clippy to `rust-lang/rust`](#performing-the-sync-from-clippy-to-rust-langrust)\n     - [Defining remotes](#defining-remotes)\n   - [Issue and PR triage](#issue-and-pr-triage)\n   - [Bors and Homu](#bors-and-homu)"}, {"sha": "c565e29d07801d3a449aeabe40276f4c8315cff3", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -127,10 +127,9 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n             _ => &block.expr,\n         };\n         // function call\n-        if let Some(args) = match_panic_call(cx, begin_panic_call);\n-        if args.len() == 1;\n+        if let Some(arg) = match_panic_call(cx, begin_panic_call);\n         // bind the second argument of the `assert!` macro if it exists\n-        if let panic_message = snippet_opt(cx, args[0].span);\n+        if let panic_message = snippet_opt(cx, arg.span);\n         // second argument of begin_panic is irrelevant\n         // as is the second match arm\n         then {"}, {"sha": "bee706ed402156423b62f63fe4853ddfc685acb1", "filename": "clippy_lints/src/bool_assert_comparison.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,75 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::{ast_utils, is_direct_expn_of};\n+use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** This lint warns about boolean comparisons in assert-like macros.\n+    ///\n+    /// **Why is this bad?** It is shorter to use the equivalent.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// assert_eq!(\"a\".is_empty(), false);\n+    /// assert_ne!(\"a\".is_empty(), true);\n+    ///\n+    /// // Good\n+    /// assert!(!\"a\".is_empty());\n+    /// ```\n+    pub BOOL_ASSERT_COMPARISON,\n+    style,\n+    \"Using a boolean as comparison value in an assert_* macro when there is no need\"\n+}\n+\n+declare_lint_pass!(BoolAssertComparison => [BOOL_ASSERT_COMPARISON]);\n+\n+fn is_bool_lit(e: &Expr) -> bool {\n+    matches!(\n+        e.kind,\n+        ExprKind::Lit(Lit {\n+            kind: LitKind::Bool(_),\n+            ..\n+        })\n+    ) && !e.span.from_expansion()\n+}\n+\n+impl EarlyLintPass for BoolAssertComparison {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n+        let macros = [\"assert_eq\", \"debug_assert_eq\"];\n+        let inverted_macros = [\"assert_ne\", \"debug_assert_ne\"];\n+\n+        for mac in macros.iter().chain(inverted_macros.iter()) {\n+            if let Some(span) = is_direct_expn_of(e.span, mac) {\n+                if let Some([a, b]) = ast_utils::extract_assert_macro_args(e) {\n+                    let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+\n+                    if nb_bool_args != 1 {\n+                        // If there are two boolean arguments, we definitely don't understand\n+                        // what's going on, so better leave things as is...\n+                        //\n+                        // Or there is simply no boolean and then we can leave things as is!\n+                        return;\n+                    }\n+\n+                    let non_eq_mac = &mac[..mac.len() - 3];\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BOOL_ASSERT_COMPARISON,\n+                        span,\n+                        &format!(\"used `{}!` with a literal bool\", mac),\n+                        \"replace it with\",\n+                        format!(\"{}!(..)\", non_eq_mac),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "67f0e0c78700bc56f9bcd19373b6a27f205ad8bc", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -261,7 +261,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n             }\n             METHODS_WITH_NEGATION\n                 .iter()\n-                .cloned()\n+                .copied()\n                 .flat_map(|(a, b)| vec![(a, b), (b, a)])\n                 .find(|&(a, _)| {\n                     let path: &str = &path.ident.name.as_str();"}, {"sha": "6a2666bc6c0111026890f8ef361af6cb1fa0682d", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -323,7 +323,7 @@ fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function:\n         if let [int] = &*tp.segments;\n         then {\n             let name = &int.ident.name.as_str();\n-            candidates.iter().find(|c| name == *c).cloned()\n+            candidates.iter().find(|c| name == *c).copied()\n         } else {\n             None\n         }\n@@ -337,7 +337,7 @@ fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n         if let [ty] = &*path.segments;\n         then {\n             let name = &ty.ident.name.as_str();\n-            INTS.iter().find(|c| name == *c).cloned()\n+            INTS.iter().find(|c| name == *c).copied()\n         } else {\n             None\n         }"}, {"sha": "ab22578abd674efec12970050170789ec492d5d9", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{path_to_local, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, path_to_local, SpanlessEq};\n use if_chain::if_chain;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind, UnOp};\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{DefIdTree, TyCtxt, TypeckResults};\n+use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -52,7 +52,7 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(arm, cx.tcx)) {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n                 for arm in arms {\n                     check_arm(arm, wild_arm, cx);\n                 }\n@@ -75,7 +75,7 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // match <local> { .. }\n         if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n         // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n         let (wild_inner_arm, non_wild_inner_arm) =\n             (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n         if !pat_contains_or(non_wild_inner_arm.pat);\n@@ -126,13 +126,13 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n /// A \"wild-like\" pattern is wild (\"_\") or `None`.\n /// For this lint to apply, both the outer and inner match expressions\n /// must have \"wild-like\" branches that can be combined.\n-fn arm_is_wild_like(arm: &Arm<'_>, tcx: TyCtxt<'_>) -> bool {\n+fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     if arm.guard.is_some() {\n         return false;\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(QPath::Resolved(None, path)) if is_none_ctor(path.res, tcx) => true,\n+        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         _ => false,\n     }\n }\n@@ -164,17 +164,6 @@ fn pat_contains_or(pat: &Pat<'_>) -> bool {\n     result\n }\n \n-fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n-    if let Some(none_id) = tcx.lang_items().option_none_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = res {\n-            if let Some(variant_id) = tcx.parent(id) {\n-                return variant_id == none_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n /// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n /// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {"}, {"sha": "42e153909ce75b29f8264d6c4982ec732e2a435b", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, if_sequence, parent_node_is_if_expr, paths, SpanlessEq};\n+use clippy_utils::{get_trait_def_id, if_sequence, is_else_clause, paths, SpanlessEq};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n         }\n \n         // We only care about the top-most `if` in the chain\n-        if parent_node_is_if_expr(expr, cx) {\n+        if is_else_clause(cx.tcx, expr) {\n             return;\n         }\n "}, {"sha": "f956d171bfbe0519e9d222eebd4c581aa39c6c46", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n-    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, parent_node_is_if_expr,\n+    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, is_else_clause,\n     run_lints, search_same, ContainsName, SpanlessEq, SpanlessHash,\n };\n use if_chain::if_chain;\n@@ -188,13 +188,18 @@ fn lint_same_then_else<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     // We only lint ifs with multiple blocks\n-    if blocks.len() < 2 || parent_node_is_if_expr(expr, cx) {\n+    if blocks.len() < 2 || is_else_clause(cx.tcx, expr) {\n         return;\n     }\n \n     // Check if each block has shared code\n     let has_expr = blocks[0].expr.is_some();\n-    let (start_eq, mut end_eq, expr_eq) = scan_block_for_eq(cx, blocks);\n+\n+    let (start_eq, mut end_eq, expr_eq) = if let Some(block_eq) = scan_block_for_eq(cx, blocks) {\n+        (block_eq.start_eq, block_eq.end_eq, block_eq.expr_eq)\n+    } else {\n+        return;\n+    };\n \n     // BRANCHES_SHARING_CODE prerequisites\n     if has_conditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n@@ -290,7 +295,19 @@ fn lint_same_then_else<'tcx>(\n     }\n }\n \n-fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize, usize, bool) {\n+struct BlockEqual {\n+    /// The amount statements that are equal from the start\n+    start_eq: usize,\n+    /// The amount statements that are equal from the end\n+    end_eq: usize,\n+    ///  An indication if the block expressions are the same. This will also be true if both are\n+    /// `None`\n+    expr_eq: bool,\n+}\n+\n+/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `None` to\n+/// abort any further processing and avoid duplicate lint triggers.\n+fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<BlockEqual> {\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n@@ -332,7 +349,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n                     \"same as this\",\n                 );\n \n-                return (0, 0, false);\n+                return None;\n             }\n         }\n \n@@ -352,7 +369,11 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n         end_eq = min_block_size - start_eq;\n     }\n \n-    (start_eq, end_eq, expr_eq)\n+    Some(BlockEqual {\n+        start_eq,\n+        end_eq,\n+        expr_eq,\n+    })\n }\n \n fn check_for_warn_of_moved_symbol("}, {"sha": "4688b3d51050d63c77da6ae1d6663dd64ba20991", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -93,15 +93,6 @@ declare_deprecated_lint! {\n     \"the replacement suggested by this lint had substantially different behavior\"\n }\n \n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been superseded by the warn-by-default\n-    /// `invalid_value` rustc lint.\n-    pub INVALID_REF,\n-    \"superseded by rustc lint `invalid_value`\"\n-}\n-\n declare_deprecated_lint! {\n     /// **What it does:** Nothing. This lint has been deprecated.\n     ///\n@@ -110,24 +101,6 @@ declare_deprecated_lint! {\n     \"`collect` has been marked as #[must_use] in rustc and that covers all cases of this lint\"\n }\n \n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n-    /// `array_into_iter`.\n-    pub INTO_ITER_ON_ARRAY,\n-    \"this lint has been uplifted to rustc and is now called `array_into_iter`\"\n-}\n-\n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n-    /// `unused_labels`.\n-    pub UNUSED_LABEL,\n-    \"this lint has been uplifted to rustc and is now called `unused_labels`\"\n-}\n-\n declare_deprecated_lint! {\n     /// **What it does:** Nothing. This lint has been deprecated.\n     ///\n@@ -147,44 +120,17 @@ declare_deprecated_lint! {\n declare_deprecated_lint! {\n     /// **What it does:** Nothing. This lint has been deprecated.\n     ///\n-    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n-    /// `drop_bounds`.\n-    pub DROP_BOUNDS,\n-    \"this lint has been uplifted to rustc and is now called `drop_bounds`\"\n-}\n-\n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n-    /// `temporary_cstring_as_ptr`.\n-    pub TEMPORARY_CSTRING_AS_PTR,\n-    \"this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr`\"\n-}\n-\n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n-    /// `panic_fmt`.\n-    pub PANIC_PARAMS,\n-    \"this lint has been uplifted to rustc and is now called `panic_fmt`\"\n-}\n-\n-declare_deprecated_lint! {\n-    /// **What it does:** Nothing. This lint has been deprecated.\n-    ///\n-    /// **Deprecation reason:** This lint has been integrated into the `unknown_lints`\n-    /// rustc lint.\n-    pub UNKNOWN_CLIPPY_LINTS,\n-    \"this lint has been integrated into the `unknown_lints` rustc lint\"\n+    /// **Deprecation reason:** This lint has been replaced by `manual_find_map`, a\n+    /// more specific lint.\n+    pub FIND_MAP,\n+    \"this lint has been replaced by `manual_find_map`, a more specific lint\"\n }\n \n declare_deprecated_lint! {\n     /// **What it does:** Nothing. This lint has been deprecated.\n     ///\n-    /// **Deprecation reason:** This lint has been replaced by `manual_find_map`, a\n+    /// **Deprecation reason:** This lint has been replaced by `manual_filter_map`, a\n     /// more specific lint.\n-    pub FIND_MAP,\n-    \"this lint has been replaced by `manual_find_map`, a more specific lint\"\n+    pub FILTER_MAP,\n+    \"this lint has been replaced by `manual_filter_map`, a more specific lint\"\n }"}, {"sha": "8db5050a5ac30510ccc424c15781860db49ba2da", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 575, "deletions": 122, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,33 +1,34 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::SpanlessEq;\n-use clippy_utils::{get_item_name, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    can_move_expr_to_closure_no_visit,\n+    diagnostics::span_lint_and_sugg,\n+    is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n+    source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n+    SpanlessEq,\n+};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{\n+    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n+use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n+use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n     /// or `BTreeMap`.\n     ///\n     /// **Why is this bad?** Using `entry` is more efficient.\n     ///\n-    /// **Known problems:** Some false negatives, eg.:\n+    /// **Known problems:** The suggestion may have type inference errors in some cases. e.g.\n     /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # let mut map = HashMap::new();\n-    /// # let v = 1;\n-    /// # let k = 1;\n-    /// if !map.contains_key(&k) {\n-    ///     map.insert(k.clone(), v);\n-    /// }\n+    /// let mut map = std::collections::HashMap::new();\n+    /// let _ = if !map.contains_key(&0) {\n+    ///     map.insert(0, 0)\n+    /// } else {\n+    ///     None\n+    /// };\n     /// ```\n     ///\n     /// **Example:**\n@@ -56,132 +57,584 @@ declare_clippy_lint! {\n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n+    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::If(check, then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::Not, check) = check.kind {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n-                    // we can give a better error message\n-                    let sole_expr = {\n-                        else_block.is_none()\n-                            && if let ExprKind::Block(then_block, _) = then_block.kind {\n-                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                            } else {\n-                                true\n-                            }\n-                        // XXXManishearth we can also check for if/else blocks containing `None`.\n-                    };\n-\n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr,\n-                    };\n-\n-                    walk_expr(&mut visitor, then_block);\n+        let (cond_expr, then_expr, else_expr) = match expr.kind {\n+            ExprKind::If(c, t, e) => (c, t, e),\n+            _ => return,\n+        };\n+        let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let then_search = match find_insert_calls(cx, &contains_expr, then_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut app = Applicability::MachineApplicable;\n+        let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let sugg = if let Some(else_expr) = else_expr {\n+            let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n+                Some(search) => search,\n+                None => return,\n+            };\n+\n+            if then_search.edits.is_empty() && else_search.edits.is_empty() {\n+                // No insertions\n+                return;\n+            } else if then_search.edits.is_empty() || else_search.edits.is_empty() {\n+                // if .. { insert } else { .. } or if .. { .. } else { insert }\n+                let ((then_str, entry_kind), else_str) = match (else_search.edits.is_empty(), contains_expr.negated) {\n+                    (true, true) => (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (true, false) => (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (false, true) => (\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (false, false) => (\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {} else {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    then_str,\n+                    else_str,\n+                )\n+            } else {\n+                // if .. { insert } else { insert }\n+                let ((then_str, then_entry), (else_str, else_entry)) = if contains_expr.negated {\n+                    (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                    )\n+                } else {\n+                    (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                    )\n+                };\n+                let indent_str = snippet_indent(cx, expr.span);\n+                let indent_str = indent_str.as_deref().unwrap_or(\"\");\n+                format!(\n+                    \"match {}.entry({}) {{\\n{indent}    {entry}::{} => {}\\n\\\n+                        {indent}    {entry}::{} => {}\\n{indent}}}\",\n+                    map_str,\n+                    key_str,\n+                    then_entry,\n+                    reindent_multiline(then_str.into(), true, Some(4 + indent_str.len())),\n+                    else_entry,\n+                    reindent_multiline(else_str.into(), true, Some(4 + indent_str.len())),\n+                    entry = map_ty.entry_path(),\n+                    indent = indent_str,\n+                )\n+            }\n+        } else {\n+            if then_search.edits.is_empty() {\n+                // no insertions\n+                return;\n+            }\n+\n+            // if .. { insert }\n+            if !then_search.allow_insert_closure {\n+                let (body_str, entry_kind) = if contains_expr.negated {\n+                    then_search.snippet_vacant(cx, then_expr.span, &mut app)\n+                } else {\n+                    then_search.snippet_occupied(cx, then_expr.span, &mut app)\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    body_str,\n+                )\n+            } else if let Some(insertion) = then_search.as_single_insertion() {\n+                let value_str = snippet_with_context(cx, insertion.value.span, then_expr.span.ctxt(), \"..\", &mut app).0;\n+                if contains_expr.negated {\n+                    if insertion.value.can_have_side_effects() {\n+                        format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, value_str)\n+                    } else {\n+                        format!(\"{}.entry({}).or_insert({});\", map_str, key_str, value_str)\n+                    }\n+                } else {\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n+                    return;\n                 }\n-            } else if let Some(else_block) = *else_block {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr: false,\n-                    };\n-\n-                    walk_expr(&mut visitor, else_block);\n+            } else {\n+                let block_str = then_search.snippet_closure(cx, then_expr.span, &mut app);\n+                if contains_expr.negated {\n+                    format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, block_str)\n+                } else {\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n+                    return;\n                 }\n             }\n-        }\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_ENTRY,\n+            expr.span,\n+            &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", map_ty.name()),\n+            \"try this\",\n+            sugg,\n+            app,\n+        );\n     }\n }\n \n-fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(path, _, params, _) = check.kind;\n-        if params.len() >= 2;\n-        if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, key) = params[1].kind;\n-        then {\n-            let map = &params[0];\n-            let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n+#[derive(Clone, Copy)]\n+enum MapType {\n+    Hash,\n+    BTree,\n+}\n+impl MapType {\n+    fn name(self) -> &'static str {\n+        match self {\n+            Self::Hash => \"HashMap\",\n+            Self::BTree => \"BTreeMap\",\n+        }\n+    }\n+    fn entry_path(self) -> &'static str {\n+        match self {\n+            Self::Hash => \"std::collections::hash_map::Entry\",\n+            Self::BTree => \"std::collections::btree_map::Entry\",\n+        }\n+    }\n+}\n \n-            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n-                Some((\"BTreeMap\", map, key))\n-            }\n-            else if is_type_diagnostic_item(cx, obj_ty, sym::hashmap_type) {\n-                Some((\"HashMap\", map, key))\n-            }\n-            else {\n-                None\n+struct ContainsExpr<'tcx> {\n+    negated: bool,\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    call_ctxt: SyntaxContext,\n+}\n+fn try_parse_contains(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(MapType, ContainsExpr<'tcx>)> {\n+    let mut negated = false;\n+    let expr = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::Unary(UnOp::Not, e) => {\n+            negated = !negated;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(\n+            _,\n+            _,\n+            [map, Expr {\n+                kind: ExprKind::AddrOf(_, _, key),\n+                span: key_span,\n+                ..\n+            }],\n+            _,\n+        ) if key_span.ctxt() == expr.span.ctxt() => {\n+            let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+            let expr = ContainsExpr {\n+                negated,\n+                map,\n+                key,\n+                call_ctxt: expr.span.ctxt(),\n             };\n+            if match_def_path(cx, id, &paths::BTREEMAP_CONTAINS_KEY) {\n+                Some((MapType::BTree, expr))\n+            } else if match_def_path(cx, id, &paths::HASHMAP_CONTAINS_KEY) {\n+                Some((MapType::Hash, expr))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+struct InsertExpr<'tcx> {\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n+}\n+fn try_parse_insert(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n+    if let ExprKind::MethodCall(_, _, [map, key, value], _) = expr.kind {\n+        let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+        if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n+            Some(InsertExpr { map, key, value })\n+        } else {\n+            None\n         }\n+    } else {\n+        None\n     }\n+}\n \n-    None\n+/// An edit that will need to be made to move the expression to use the entry api\n+#[derive(Clone, Copy)]\n+enum Edit<'tcx> {\n+    /// A semicolon that needs to be removed. Used to create a closure for `insert_with`.\n+    RemoveSemi(Span),\n+    /// An insertion into the map.\n+    Insertion(Insertion<'tcx>),\n+}\n+impl Edit<'tcx> {\n+    fn as_insertion(self) -> Option<Insertion<'tcx>> {\n+        if let Self::Insertion(i) = self { Some(i) } else { None }\n+    }\n+}\n+#[derive(Clone, Copy)]\n+struct Insertion<'tcx> {\n+    call: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n }\n \n-struct InsertVisitor<'a, 'tcx, 'b> {\n-    cx: &'a LateContext<'tcx>,\n-    span: Span,\n-    ty: &'static str,\n-    map: &'b Expr<'b>,\n-    key: &'b Expr<'b>,\n-    sole_expr: bool,\n+/// This visitor needs to do a multiple things:\n+/// * Find all usages of the map. An insertion can only be made before any other usages of the map.\n+/// * Determine if there's an insertion using the same key. There's no need for the entry api\n+///   otherwise.\n+/// * Determine if the final statement executed is an insertion. This is needed to use\n+///   `or_insert_with`.\n+/// * Determine if there's any sub-expression that can't be placed in a closure.\n+/// * Determine if there's only a single insert statement. `or_insert` can be used in this case.\n+#[allow(clippy::struct_excessive_bools)]\n+struct InsertSearcher<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    /// The map expression used in the contains call.\n+    map: &'tcx Expr<'tcx>,\n+    /// The key expression used in the contains call.\n+    key: &'tcx Expr<'tcx>,\n+    /// The context of the top level block. All insert calls must be in the same context.\n+    ctxt: SyntaxContext,\n+    /// Whether this expression can be safely moved into a closure.\n+    allow_insert_closure: bool,\n+    /// Whether this expression can use the entry api.\n+    can_use_entry: bool,\n+    /// Whether this expression is the final expression in this code path. This may be a statement.\n+    in_tail_pos: bool,\n+    // Is this expression a single insert. A slightly better suggestion can be made in this case.\n+    is_single_insert: bool,\n+    /// If the visitor has seen the map being used.\n+    is_map_used: bool,\n+    /// The locations where changes need to be made for the suggestion.\n+    edits: Vec<Edit<'tcx>>,\n+    /// A stack of loops the visitor is currently in.\n+    loops: Vec<HirId>,\n }\n+impl<'tcx> InsertSearcher<'_, 'tcx> {\n+    /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n+    /// only if they are on separate code paths. This will return whether the map was used in the\n+    /// given expression.\n+    fn visit_cond_arm(&mut self, e: &'tcx Expr<'_>) -> bool {\n+        let is_map_used = self.is_map_used;\n+        let in_tail_pos = self.in_tail_pos;\n+        self.visit_expr(e);\n+        let res = self.is_map_used;\n+        self.is_map_used = is_map_used;\n+        self.in_tail_pos = in_tail_pos;\n+        res\n+    }\n \n-impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n-    type Map = Map<'tcx>;\n+    /// Visits an expression which is not itself in a tail position, but other sibling expressions\n+    /// may be. e.g. if conditions\n+    fn visit_non_tail_expr(&mut self, e: &'tcx Expr<'_>) {\n+        let in_tail_pos = self.in_tail_pos;\n+        self.in_tail_pos = false;\n+        self.visit_expr(e);\n+        self.in_tail_pos = in_tail_pos;\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n+    type Map = ErasedMap<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Semi(e) => {\n+                self.visit_expr(e);\n+\n+                if self.in_tail_pos && self.allow_insert_closure {\n+                    // The spans are used to slice the top level expression into multiple parts. This requires that\n+                    // they all come from the same part of the source code.\n+                    if stmt.span.ctxt() == self.ctxt && e.span.ctxt() == self.ctxt {\n+                        self.edits\n+                            .push(Edit::RemoveSemi(stmt.span.trim_start(e.span).unwrap_or(DUMMY_SP)));\n+                    } else {\n+                        self.allow_insert_closure = false;\n+                    }\n+                }\n+            },\n+            StmtKind::Expr(e) => self.visit_expr(e),\n+            StmtKind::Local(Local { init: Some(e), .. }) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                self.is_single_insert = false;\n+                self.visit_expr(e);\n+            },\n+            _ => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+                self.is_single_insert = false;\n+            },\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx Block<'_>) {\n+        // If the block is in a tail position, then the last expression (possibly a statement) is in the\n+        // tail position. The rest, however, are not.\n+        match (block.stmts, block.expr) {\n+            ([], None) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+            },\n+            ([], Some(expr)) => self.visit_expr(expr),\n+            (stmts, Some(expr)) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_expr(expr);\n+            },\n+            ([stmts @ .., stmt], None) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_stmt(stmt);\n+            },\n+        }\n+    }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, _, params, _) = expr.kind;\n-            if params.len() == 3;\n-            if path.ident.name == sym!(insert);\n-            if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n-            if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n-            if snippet_opt(self.cx, self.map.span) == snippet_opt(self.cx, params[0].span);\n-            then {\n-                span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n-                                   &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |diag| {\n-                    if self.sole_expr {\n-                        let mut app = Applicability::MachineApplicable;\n-                        let help = format!(\"{}.entry({}).or_insert({});\",\n-                                           snippet_with_applicability(self.cx, self.map.span, \"map\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[1].span, \"..\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[2].span, \"..\", &mut app));\n-\n-                        diag.span_suggestion(\n-                            self.span,\n-                            \"consider using\",\n-                            help,\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n+        if !self.can_use_entry {\n+            return;\n+        }\n+\n+        match try_parse_insert(self.cx, expr) {\n+            Some(insert_expr) if SpanlessEq::new(self.cx).eq_expr(self.map, insert_expr.map) => {\n+                // Multiple inserts, inserts with a different key, and inserts from a macro can't use the entry api.\n+                if self.is_map_used\n+                    || !SpanlessEq::new(self.cx).eq_expr(self.key, insert_expr.key)\n+                    || expr.span.ctxt() != self.ctxt\n+                {\n+                    self.can_use_entry = false;\n+                    return;\n+                }\n+\n+                self.edits.push(Edit::Insertion(Insertion {\n+                    call: expr,\n+                    value: insert_expr.value,\n+                }));\n+                self.is_map_used = true;\n+                self.allow_insert_closure &= self.in_tail_pos;\n+\n+                // The value doesn't affect whether there is only a single insert expression.\n+                let is_single_insert = self.is_single_insert;\n+                self.visit_non_tail_expr(insert_expr.value);\n+                self.is_single_insert = is_single_insert;\n+            },\n+            _ if SpanlessEq::new(self.cx).eq_expr(self.map, expr) => {\n+                self.is_map_used = true;\n+            },\n+            _ => match expr.kind {\n+                ExprKind::If(cond_expr, then_expr, Some(else_expr)) => {\n+                    self.is_single_insert = false;\n+                    self.visit_non_tail_expr(cond_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.visit_cond_arm(then_expr);\n+                    is_map_used |= self.visit_cond_arm(else_expr);\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Match(scrutinee_expr, arms, _) => {\n+                    self.is_single_insert = false;\n+                    self.visit_non_tail_expr(scrutinee_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.is_map_used;\n+                    for arm in arms {\n+                        if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n+                            self.visit_non_tail_expr(guard)\n+                        }\n+                        is_map_used |= self.visit_cond_arm(arm.body);\n                     }\n-                    else {\n-                        let help = format!(\"consider using `{}.entry({})`\",\n-                                           snippet(self.cx, self.map.span, \"map\"),\n-                                           snippet(self.cx, params[1].span, \"..\"));\n-\n-                        diag.span_label(\n-                            self.span,\n-                            &help,\n-                        );\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Loop(block, ..) => {\n+                    self.loops.push(expr.hir_id);\n+                    self.is_single_insert = false;\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    // Don't allow insertions inside of a loop.\n+                    let edit_len = self.edits.len();\n+                    self.visit_block(block);\n+                    if self.edits.len() != edit_len {\n+                        self.can_use_entry = false;\n                     }\n-                });\n-            }\n+                    self.loops.pop();\n+                },\n+                ExprKind::Block(block, _) => self.visit_block(block),\n+                ExprKind::InlineAsm(_) | ExprKind::LlvmInlineAsm(_) => {\n+                    self.can_use_entry = false;\n+                },\n+                _ => {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    // Sub expressions are no longer in the tail position.\n+                    self.is_single_insert = false;\n+                    self.in_tail_pos = false;\n+                    walk_expr(self, expr);\n+                },\n+            },\n         }\n+    }\n+}\n+\n+struct InsertSearchResults<'tcx> {\n+    edits: Vec<Edit<'tcx>>,\n+    allow_insert_closure: bool,\n+    is_single_insert: bool,\n+}\n+impl InsertSearchResults<'tcx> {\n+    fn as_single_insertion(&self) -> Option<Insertion<'tcx>> {\n+        self.is_single_insert.then(|| self.edits[0].as_insertion().unwrap())\n+    }\n \n-        if !self.sole_expr {\n-            walk_expr(self, expr);\n+    fn snippet(\n+        &self,\n+        cx: &LateContext<'_>,\n+        mut span: Span,\n+        app: &mut Applicability,\n+        write_wrapped: impl Fn(&mut String, Insertion<'_>, SyntaxContext, &mut Applicability),\n+    ) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n+            res.push_str(&snippet_with_applicability(\n+                cx,\n+                span.until(insertion.call.span),\n+                \"..\",\n+                app,\n+            ));\n+            if is_expr_used_or_unified(cx.tcx, insertion.call) {\n+                write_wrapped(&mut res, insertion, ctxt, app);\n+            } else {\n+                let _ = write!(\n+                    res,\n+                    \"e.insert({})\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n+            }\n+            span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n         }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n     }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+\n+    fn snippet_occupied(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `Some(&mut value)`, but the entry returns `&mut value`\n+                let _ = write!(\n+                    res,\n+                    \"Some(e.insert({}))\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n+            }),\n+            \"Occupied(mut e)\",\n+        )\n     }\n+\n+    fn snippet_vacant(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `None`, but the entry returns a mutable reference.\n+                let _ = if is_expr_final_block_expr(cx.tcx, insertion.call) {\n+                    write!(\n+                        res,\n+                        \"e.insert({});\\n{}None\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                        snippet_indent(cx, insertion.call.span).as_deref().unwrap_or(\"\"),\n+                    )\n+                } else {\n+                    write!(\n+                        res,\n+                        \"{{ e.insert({}); None }}\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                    )\n+                };\n+            }),\n+            \"Vacant(e)\",\n+        )\n+    }\n+\n+    fn snippet_closure(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for edit in &self.edits {\n+            match *edit {\n+                Edit::Insertion(insertion) => {\n+                    // Cut out the value from `map.insert(key, value)`\n+                    res.push_str(&snippet_with_applicability(\n+                        cx,\n+                        span.until(insertion.call.span),\n+                        \"..\",\n+                        app,\n+                    ));\n+                    res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n+                    span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n+                },\n+                Edit::RemoveSemi(semi_span) => {\n+                    // Cut out the semicolon. This allows the value to be returned from the closure.\n+                    res.push_str(&snippet_with_applicability(cx, span.until(semi_span), \"..\", app));\n+                    span = span.trim_start(semi_span).unwrap_or(DUMMY_SP);\n+                },\n+            }\n+        }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n+    }\n+}\n+\n+fn find_insert_calls(\n+    cx: &LateContext<'tcx>,\n+    contains_expr: &ContainsExpr<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<InsertSearchResults<'tcx>> {\n+    let mut s = InsertSearcher {\n+        cx,\n+        map: contains_expr.map,\n+        key: contains_expr.key,\n+        ctxt: expr.span.ctxt(),\n+        edits: Vec::new(),\n+        is_map_used: false,\n+        allow_insert_closure: true,\n+        can_use_entry: true,\n+        in_tail_pos: true,\n+        is_single_insert: true,\n+        loops: Vec::new(),\n+    };\n+    s.visit_expr(expr);\n+    let allow_insert_closure = s.allow_insert_closure;\n+    let is_single_insert = s.is_single_insert;\n+    let edits = s.edits;\n+    s.can_use_entry.then(|| InsertSearchResults {\n+        edits,\n+        allow_insert_closure,\n+        is_single_insert,\n+    })\n }"}, {"sha": "4e2dbf005d51c7cd9f2f5ffb9fde6563d73c9def", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{in_macro, match_path_ast};\n+use clippy_utils::in_macro;\n use rustc_ast::ast::{AssocItemKind, Extern, FnKind, FnSig, ImplKind, Item, ItemKind, TraitKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -126,7 +126,9 @@ impl_lint_pass!(ExcessiveBools => [STRUCT_EXCESSIVE_BOOLS, FN_PARAMS_EXCESSIVE_B\n \n fn is_bool_ty(ty: &Ty) -> bool {\n     if let TyKind::Path(None, path) = &ty.kind {\n-        return match_path_ast(path, &[\"bool\"]);\n+        if let [name] = path.segments.as_slice() {\n+            return name.ident.name == sym::bool;\n+        }\n     }\n     false\n }"}, {"sha": "c2b055ed6488e4e9bdeb0d34e1980a16c8e09fdc", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::paths;\n use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{is_expn_of, last_path_segment, match_def_path, match_function_call};\n use if_chain::if_chain;\n@@ -100,15 +101,15 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n                     return Some(format!(\"{:?}.to_string()\", s.as_str()));\n                 }\n             } else {\n-                let snip = snippet(cx, format_args.span, \"<arg>\");\n+                let sugg = Sugg::hir(cx, format_args, \"<arg>\");\n                 if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n                     if path.ident.name == sym!(to_string) {\n-                        return Some(format!(\"{}\", snip));\n+                        return Some(format!(\"{}\", sugg));\n                     }\n                 } else if let ExprKind::Binary(..) = format_args.kind {\n-                    return Some(format!(\"{}\", snip));\n+                    return Some(format!(\"{}\", sugg));\n                 }\n-                return Some(format!(\"{}.to_string()\", snip));\n+                return Some(format!(\"{}.to_string()\", sugg.maybe_par()));\n             }\n         }\n     }\n@@ -136,7 +137,7 @@ fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Strin\n                 if let Some(s_src) = snippet_opt(cx, lit.span) {\n                     // Simulate macro expansion, converting {{ and }} to { and }.\n                     let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                    return Some(format!(\"{}.to_string()\", s_expand))\n+                    return Some(format!(\"{}.to_string()\", s_expand));\n                 }\n             } else if s.as_str().is_empty() {\n                 return on_argumentv1_new(cx, &tup[0], arms);"}, {"sha": "3bd6a09d3653aeb0a60887d8df220196f910d16b", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -215,9 +215,22 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n         // the snippet should look like \" else \\n    \" with maybe comments anywhere\n         // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n         if let Some(else_snippet) = snippet_opt(cx, else_span);\n-        if let Some(else_pos) = else_snippet.find(\"else\");\n-        if else_snippet[else_pos..].contains('\\n');\n+        if let Some((pre_else, post_else)) = else_snippet.split_once(\"else\");\n+        if let Some((_, post_else_post_eol)) = post_else.split_once('\\n');\n+\n         then {\n+            // Allow allman style braces `} \\n else \\n {`\n+            if_chain! {\n+                if is_block(else_);\n+                if let Some((_, pre_else_post_eol)) = pre_else.split_once('\\n');\n+                // Exactly one eol before and after the else\n+                if !pre_else_post_eol.contains('\\n');\n+                if !post_else_post_eol.contains('\\n');\n+                then {\n+                    return;\n+                }\n+            }\n+\n             let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n             span_lint_and_note(\n                 cx,"}, {"sha": "5e2baba8943498d5e321f94ae8c424c66a0d3e35", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass<'_> for FromOverInto {\n                     cx.tcx.sess.source_map().guess_head_span(item.span),\n                     \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n                     None,\n-                    \"consider to implement `From` instead\",\n+                    &format!(\"consider to implement `From<{}>` instead\", impl_trait_ref.self_ty()),\n                 );\n             }\n         }"}, {"sha": "85c95f1151f84b53db10ffdacc68cc98cdd92783", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,7 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{match_qpath, meets_msrv, parent_node_is_if_expr};\n+use clippy_utils::{is_else_clause, is_lang_ctor, meets_msrv};\n use if_chain::if_chain;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -67,7 +68,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         // We only care about the top-most `if` in the chain\n-        if parent_node_is_if_expr(expr, cx) {\n+        if is_else_clause(cx.tcx, expr) {\n             return;\n         }\n \n@@ -77,12 +78,12 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let Some(then_expr) = then_block.expr;\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n-            if match_qpath(then_call_qpath, &clippy_utils::paths::OPTION_SOME);\n+            if is_lang_ctor(cx, then_call_qpath, OptionSome);\n             if let ExprKind::Block(els_block, _) = els.kind;\n             if els_block.stmts.is_empty();\n             if let Some(els_expr) = els_block.expr;\n-            if let ExprKind::Path(ref els_call_qpath) = els_expr.kind;\n-            if match_qpath(els_call_qpath, &clippy_utils::paths::OPTION_NONE);\n+            if let ExprKind::Path(ref qpath) = els_expr.kind;\n+            if is_lang_ctor(cx, qpath, OptionNone);\n             then {\n                 let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n                 let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {"}, {"sha": "03fe0d16d480f792f8138a3480812604ab183cb4", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -22,7 +22,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, match_path};\n+use clippy_utils::{differing_macro_contexts, match_def_path};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for public `impl` or `fn` missing generalization\n@@ -333,12 +333,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Call(fun, args) = e.kind;\n             if let ExprKind::Path(QPath::TypeRelative(ty, method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n+            if let Some(ty_did) = ty_path.res.opt_def_id();\n             then {\n                 if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n                     return;\n                 }\n \n-                if match_path(ty_path, &paths::HASHMAP) {\n+                if match_def_path(self.cx, ty_did, &paths::HASHMAP) {\n                     if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n@@ -351,7 +352,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                             ),\n                         );\n                     }\n-                } else if match_path(ty_path, &paths::HASHSET) {\n+                } else if match_def_path(self.cx, ty_did, &paths::HASHSET) {\n                     if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());"}, {"sha": "4069a685ea0a44e9eff0d141fa0c67feba6b769c", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{in_macro, match_qpath, SpanlessEq};\n+use clippy_utils::{in_macro, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -87,7 +87,13 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n-                const INT_TYPES: [&str; 5] = [\"i8\", \"i16\", \"i32\", \"i64\", \"i128\"];\n+                const INT_TYPES: [LangItem; 5] = [\n+                    LangItem::I8,\n+                    LangItem::I16,\n+                    LangItem::I32,\n+                    LangItem::I64,\n+                    LangItem::Isize\n+                ];\n \n                 match cond_num_val.kind {\n                     ExprKind::Lit(ref cond_lit) => {\n@@ -99,17 +105,30 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             };\n                         }\n                     },\n-                    ExprKind::Path(ref cond_num_path) => {\n-                        if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"MIN\"])) {\n-                            print_lint_and_sugg(cx, &var_name, expr);\n-                        };\n+                    ExprKind::Path(QPath::TypeRelative(_, name)) => {\n+                        if_chain! {\n+                            if name.ident.as_str() == \"MIN\";\n+                            if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n+                            if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n+                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n+                            if int_ids.any(|int_id| int_id == impl_id);\n+                            then {\n+                                print_lint_and_sugg(cx, &var_name, expr)\n+                            }\n+                        }\n                     },\n-                    ExprKind::Call(func, _) => {\n-                        if let ExprKind::Path(ref cond_num_path) = func.kind {\n-                            if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n-                                print_lint_and_sugg(cx, &var_name, expr);\n+                    ExprKind::Call(func, []) => {\n+                        if_chain! {\n+                            if let ExprKind::Path(QPath::TypeRelative(_, name)) = func.kind;\n+                            if name.ident.as_str() == \"min_value\";\n+                            if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n+                            if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n+                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n+                            if int_ids.any(|int_id| int_id == impl_id);\n+                            then {\n+                                print_lint_and_sugg(cx, &var_name, expr)\n                             }\n-                        };\n+                        }\n                     },\n                     _ => (),\n                 }"}, {"sha": "d138c3a8acfefc0ff50b822ce6bb0d926b2f0116", "filename": "clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::in_macro;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n@@ -66,6 +67,7 @@ declare_lint_pass!(InconsistentStructConstructor => [INCONSISTENT_STRUCT_CONSTRU\n impl LateLintPass<'_> for InconsistentStructConstructor {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n+            if !in_macro(expr.span);\n             if let ExprKind::Struct(qpath, fields, base) = expr.kind;\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let Some(adt_def) = ty.ty_adt_def();"}, {"sha": "afee20ce43e48088b46e2cf3d9cb4c39a272057e", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, match_type};\n-use clippy_utils::{get_trait_def_id, higher, match_qpath, paths};\n+use clippy_utils::{get_trait_def_id, higher, is_qpath_def_path, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -163,7 +163,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n         ExprKind::Call(path, _) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n-                match_qpath(qpath, &paths::REPEAT).into()\n+                is_qpath_def_path(cx, qpath, path.hir_id, &paths::ITER_REPEAT).into()\n             } else {\n                 Finite\n             }"}, {"sha": "d6134e178ca179bfe2528a7f6957ce9ff8141ed7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -179,6 +179,7 @@ mod await_holding_invalid;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n+mod bool_assert_comparison;\n mod booleans;\n mod bytecount;\n mod cargo_common_metadata;\n@@ -357,6 +358,7 @@ mod unicode;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n+mod unnecessary_self_imports;\n mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n@@ -391,6 +393,7 @@ pub use crate::utils::conf::Conf;\n ///\n /// Used in `./src/driver.rs`.\n pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n+    // NOTE: Do not add any more pre-expansion passes. These should be removed eventually.\n     store.register_pre_expansion_pass(|| box write::Write::default());\n     store.register_pre_expansion_pass(|| box attrs::EarlyAttributes);\n     store.register_pre_expansion_pass(|| box dbg_macro::DbgMacro);\n@@ -494,22 +497,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         \"clippy::unsafe_vector_initialization\",\n         \"the replacement suggested by this lint had substantially different behavior\",\n     );\n-    store.register_removed(\n-        \"clippy::invalid_ref\",\n-        \"superseded by rustc lint `invalid_value`\",\n-    );\n     store.register_removed(\n         \"clippy::unused_collect\",\n         \"`collect` has been marked as #[must_use] in rustc and that covers all cases of this lint\",\n     );\n-    store.register_removed(\n-        \"clippy::into_iter_on_array\",\n-        \"this lint has been uplifted to rustc and is now called `array_into_iter`\",\n-    );\n-    store.register_removed(\n-        \"clippy::unused_label\",\n-        \"this lint has been uplifted to rustc and is now called `unused_labels`\",\n-    );\n     store.register_removed(\n         \"clippy::replace_consts\",\n         \"associated-constants `MIN`/`MAX` of integers are preferred to `{min,max}_value()` and module constants\",\n@@ -518,26 +509,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         \"clippy::regex_macro\",\n         \"the regex! macro has been removed from the regex crate in 2018\",\n     );\n-    store.register_removed(\n-        \"clippy::drop_bounds\",\n-        \"this lint has been uplifted to rustc and is now called `drop_bounds`\",\n-    );\n-    store.register_removed(\n-        \"clippy::temporary_cstring_as_ptr\",\n-        \"this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr`\",\n-    );\n-    store.register_removed(\n-        \"clippy::panic_params\",\n-        \"this lint has been uplifted to rustc and is now called `panic_fmt`\",\n-    );\n-    store.register_removed(\n-        \"clippy::unknown_clippy_lints\",\n-        \"this lint has been integrated into the `unknown_lints` rustc lint\",\n-    );\n     store.register_removed(\n         \"clippy::find_map\",\n         \"this lint has been replaced by `manual_find_map`, a more specific lint\",\n     );\n+    store.register_removed(\n+        \"clippy::filter_map\",\n+        \"this lint has been replaced by `manual_filter_map`, a more specific lint\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     // begin register lints, do not remove this comment, it\u2019s used in `update_lints`\n@@ -592,6 +571,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         bit_mask::VERBOSE_BIT_MASK,\n         blacklisted_name::BLACKLISTED_NAME,\n         blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n+        bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n         booleans::LOGIC_BUG,\n         booleans::NONMINIMAL_BOOL,\n         bytecount::NAIVE_BYTECOUNT,\n@@ -783,17 +763,18 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::BYTES_NTH,\n         methods::CHARS_LAST_CMP,\n         methods::CHARS_NEXT_CMP,\n+        methods::CLONED_INSTEAD_OF_COPIED,\n         methods::CLONE_DOUBLE_REF,\n         methods::CLONE_ON_COPY,\n         methods::CLONE_ON_REF_PTR,\n         methods::EXPECT_FUN_CALL,\n         methods::EXPECT_USED,\n         methods::FILETYPE_IS_FILE,\n-        methods::FILTER_MAP,\n         methods::FILTER_MAP_IDENTITY,\n         methods::FILTER_MAP_NEXT,\n         methods::FILTER_NEXT,\n         methods::FLAT_MAP_IDENTITY,\n+        methods::FLAT_MAP_OPTION,\n         methods::FROM_ITER_INSTEAD_OF_COLLECT,\n         methods::GET_UNWRAP,\n         methods::IMPLICIT_CLONE,\n@@ -904,6 +885,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         precedence::PRECEDENCE,\n         ptr::CMP_NULL,\n+        ptr::INVALID_NULL_PTR_USAGE,\n         ptr::MUT_FROM_REF,\n         ptr::PTR_ARG,\n         ptr_eq::PTR_EQ,\n@@ -988,6 +970,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         unit_types::UNIT_CMP,\n         unnamed_address::FN_ADDRESS_COMPARISONS,\n         unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n+        unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n         unnecessary_sort_by::UNNECESSARY_SORT_BY,\n         unnecessary_wraps::UNNECESSARY_WRAPS,\n         unnested_or_patterns::UNNESTED_OR_PATTERNS,\n@@ -1073,6 +1056,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n     store.register_late_pass(|| box inconsistent_struct_constructor::InconsistentStructConstructor);\n     store.register_late_pass(|| box non_octal_unix_permissions::NonOctalUnixPermissions);\n+    store.register_early_pass(|| box unnecessary_self_imports::UnnecessarySelfImports);\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n@@ -1295,6 +1279,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n     store.register_late_pass(|| box manual_map::ManualMap);\n     store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n+    store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(arithmetic::FLOAT_ARITHMETIC),\n@@ -1345,6 +1330,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(strings::STRING_TO_STRING),\n         LintId::of(strings::STR_TO_STRING),\n         LintId::of(types::RC_BUFFER),\n+        LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n         LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n         LintId::of(write::PRINT_STDERR),\n@@ -1404,8 +1390,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n         LintId::of(matches::MATCH_WILD_ERR_ARM),\n         LintId::of(matches::SINGLE_MATCH_ELSE),\n-        LintId::of(methods::FILTER_MAP),\n+        LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n         LintId::of(methods::FILTER_MAP_NEXT),\n+        LintId::of(methods::FLAT_MAP_OPTION),\n         LintId::of(methods::IMPLICIT_CLONE),\n         LintId::of(methods::INEFFICIENT_TO_STRING),\n         LintId::of(methods::MAP_FLATTEN),\n@@ -1428,6 +1415,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(strings::STRING_ADD_ASSIGN),\n         LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n+        LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n         LintId::of(types::LINKEDLIST),\n         LintId::of(types::OPTION_OPTION),\n         LintId::of(unicode::NON_ASCII_LITERAL),\n@@ -1474,6 +1462,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n         LintId::of(booleans::LOGIC_BUG),\n         LintId::of(booleans::NONMINIMAL_BOOL),\n         LintId::of(casts::CAST_REF_TO_MUT),\n@@ -1673,6 +1662,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n         LintId::of(precedence::PRECEDENCE),\n         LintId::of(ptr::CMP_NULL),\n+        LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n         LintId::of(ptr::MUT_FROM_REF),\n         LintId::of(ptr::PTR_ARG),\n         LintId::of(ptr_eq::PTR_EQ),\n@@ -1715,7 +1705,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n         LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n         LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n-        LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n         LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n         LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n         LintId::of(transmute::WRONG_TRANSMUTE),\n@@ -1759,6 +1748,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n         LintId::of(casts::FN_TO_NUMERIC_CAST),\n         LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n@@ -1949,7 +1939,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n         LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n         LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n-        LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n         LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n         LintId::of(types::BORROWED_BOX),\n         LintId::of(types::TYPE_COMPLEXITY),\n@@ -2012,6 +2001,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n+        LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n         LintId::of(ptr::MUT_FROM_REF),\n         LintId::of(ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(regex::INVALID_REGEX),\n@@ -2153,6 +2143,15 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::identity_conversion\", \"clippy::useless_conversion\");\n     ls.register_renamed(\"clippy::zero_width_space\", \"clippy::invisible_characters\");\n     ls.register_renamed(\"clippy::single_char_push_str\", \"clippy::single_char_add_str\");\n+\n+    // uplifted lints\n+    ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");\n+    ls.register_renamed(\"clippy::into_iter_on_array\", \"array_into_iter\");\n+    ls.register_renamed(\"clippy::unused_label\", \"unused_labels\");\n+    ls.register_renamed(\"clippy::drop_bounds\", \"drop_bounds\");\n+    ls.register_renamed(\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\");\n+    ls.register_renamed(\"clippy::panic_params\", \"non_fmt_panic\");\n+    ls.register_renamed(\"clippy::unknown_clippy_lints\", \"unknown_lints\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "c7a28f42ea19b65e24a0019be672549c4cb7a655", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,24 +1,25 @@\n use super::EXPLICIT_INTO_ITER_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_trait_method, paths};\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n \n-pub(super) fn check(cx: &LateContext<'_>, args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n-    let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n-    let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-    if !TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+pub(super) fn check(cx: &LateContext<'_>, self_arg: &'hir Expr<'hir>, call_expr: &Expr<'_>) {\n+    let self_ty = cx.typeck_results().expr_ty(self_arg);\n+    let self_ty_adjusted = cx.typeck_results().expr_ty_adjusted(self_arg);\n+    if !(TyS::same_type(self_ty, self_ty_adjusted) && match_trait_method(cx, call_expr, &paths::INTO_ITERATOR)) {\n         return;\n     }\n \n     let mut applicability = Applicability::MachineApplicable;\n-    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let object = snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability);\n     span_lint_and_sugg(\n         cx,\n         EXPLICIT_INTO_ITER_LOOP,\n-        arg.span,\n+        call_expr.span,\n         \"it is more concise to loop over containers instead of using explicit \\\n             iteration methods\",\n         \"to write this more concisely, try\","}, {"sha": "ce02ad013bef64df5463e0ed324905de543f87e5", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -9,12 +9,12 @@ use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_span::sym;\n \n-pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, arg: &Expr<'_>, method_name: &str) {\n     let should_lint = match method_name {\n-        \"iter\" | \"iter_mut\" => is_ref_iterable_type(cx, &args[0]),\n+        \"iter\" | \"iter_mut\" => is_ref_iterable_type(cx, self_arg),\n         \"into_iter\" if match_trait_method(cx, arg, &paths::INTO_ITERATOR) => {\n-            let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n-            let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+            let receiver_ty = cx.typeck_results().expr_ty(self_arg);\n+            let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(self_arg);\n             let ref_receiver_ty = cx.tcx.mk_ref(\n                 cx.tcx.lifetimes.re_erased,\n                 ty::TypeAndMut {\n@@ -32,7 +32,7 @@ pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, met\n     }\n \n     let mut applicability = Applicability::MachineApplicable;\n-    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let object = snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n     span_lint_and_sugg(\n         cx,"}, {"sha": "64ff7574f86b7669d4efbf498e09527aa100abe4", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,10 +1,11 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{is_ok_ctor, is_some_ctor, path_to_local_id};\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, StmtKind};\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -42,9 +43,9 @@ pub(super) fn check<'tcx>(\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n             if path_to_local_id(match_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n-            let some_ctor = is_some_ctor(cx, path.res);\n-            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if let PatKind::TupleStruct(ref qpath, _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n+            let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };"}, {"sha": "a4bc3e6bd100cd4c47c9b31febd8144209b183a2", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -602,22 +602,19 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(method, _, args, _) = arg.kind {\n-        // just the receiver, no arguments\n-        if args.len() == 1 {\n-            let method_name = &*method.ident.as_str();\n-            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-            match method_name {\n-                \"iter\" | \"iter_mut\" => explicit_iter_loop::check(cx, args, arg, method_name),\n-                \"into_iter\" => {\n-                    explicit_iter_loop::check(cx, args, arg, method_name);\n-                    explicit_into_iter_loop::check(cx, args, arg);\n-                },\n-                \"next\" => {\n-                    next_loop_linted = iter_next_loop::check(cx, arg, expr);\n-                },\n-                _ => {},\n-            }\n+    if let ExprKind::MethodCall(method, _, [self_arg], _) = arg.kind {\n+        let method_name = &*method.ident.as_str();\n+        // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+        match method_name {\n+            \"iter\" | \"iter_mut\" => explicit_iter_loop::check(cx, self_arg, arg, method_name),\n+            \"into_iter\" => {\n+                explicit_iter_loop::check(cx, self_arg, arg, method_name);\n+                explicit_into_iter_loop::check(cx, self_arg, arg);\n+            },\n+            \"next\" => {\n+                next_loop_linted = iter_next_loop::check(cx, arg, expr);\n+            },\n+            _ => {},\n         }\n     }\n "}, {"sha": "e97b7c9417033d9a9929f7a994fafb5f08f4b0e5", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -100,7 +100,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         ExprKind::Binary(_, e1, e2)\n         | ExprKind::Assign(e1, e2, _)\n         | ExprKind::AssignOp(_, e1, e2)\n-        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().cloned(), main_loop_id),\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), main_loop_id),\n         ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))"}, {"sha": "ec03daff87b075c2fd470a798a79ccc092bec5f5", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -112,6 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if let Some(mac_attr) = attrs.iter().find(|attr| attr.has_name(sym::macro_use));\n             if let Res::Def(DefKind::Mod, id) = path.res;\n+            if !id.is_local();\n             then {\n                 for kid in cx.tcx.item_children(id).iter() {\n                     if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {"}, {"sha": "0b873534f2c8d4be30d6fc29ed6191edebd49f69", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 18, "deletions": 78, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,15 +1,14 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{can_partially_move_ty, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{in_constant, is_allowed, is_else_clause, match_def_path, match_var, paths, peel_hir_expr_refs};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n-use rustc_hir::{\n-    def::Res,\n-    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n-};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -103,12 +102,18 @@ impl LateLintPass<'_> for ManualMap {\n                 None => return,\n             };\n \n+            // These two lints will go back and forth with each other.\n             if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n                 && !is_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n             {\n                 return;\n             }\n \n+            // `map` won't perform any adjustments.\n+            if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+                return;\n+            }\n+\n             if !can_move_expr_to_closure(cx, some_expr) {\n                 return;\n             }\n@@ -192,51 +197,6 @@ impl LateLintPass<'_> for ManualMap {\n     }\n }\n \n-// Checks if the expression can be moved into a closure as is.\n-fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    struct V<'cx, 'tcx> {\n-        cx: &'cx LateContext<'tcx>,\n-        make_closure: bool,\n-    }\n-    impl Visitor<'tcx> for V<'_, 'tcx> {\n-        type Map = ErasedMap<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            match e.kind {\n-                ExprKind::Break(..)\n-                | ExprKind::Continue(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Yield(..)\n-                | ExprKind::InlineAsm(_)\n-                | ExprKind::LlvmInlineAsm(_) => {\n-                    self.make_closure = false;\n-                },\n-                // Accessing a field of a local value can only be done if the type isn't\n-                // partially moved.\n-                ExprKind::Field(base_expr, _)\n-                    if matches!(\n-                        base_expr.kind,\n-                        ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-                    ) && can_partially_move_ty(self.cx, self.cx.typeck_results().expr_ty(base_expr)) =>\n-                {\n-                    // TODO: check if the local has been partially moved. Assume it has for now.\n-                    self.make_closure = false;\n-                    return;\n-                }\n-                _ => (),\n-            };\n-            walk_expr(self, e);\n-        }\n-    }\n-\n-    let mut v = V { cx, make_closure: true };\n-    v.visit_expr(expr);\n-    v.make_closure\n-}\n-\n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n@@ -269,20 +229,9 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(QPath::Resolved(None, path))\n-                if path\n-                    .res\n-                    .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)) =>\n-            {\n-                Some(OptionPat::None)\n-            },\n-            PatKind::TupleStruct(QPath::Resolved(None, path), [pattern], _)\n-                if path\n-                    .res\n-                    .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME))\n-                    && pat.span.ctxt() == ctxt =>\n+            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -298,17 +247,11 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n     match expr.kind {\n         ExprKind::Call(\n             Expr {\n-                kind: ExprKind::Path(QPath::Resolved(None, path)),\n+                kind: ExprKind::Path(ref qpath),\n                 ..\n             },\n             [arg],\n-        ) if ctxt == expr.span.ctxt() => {\n-            if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n-                Some(arg)\n-            } else {\n-                None\n-            }\n-        },\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(arg),\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -324,10 +267,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Path(QPath::Resolved(None, path)) => path\n-            .res\n-            .opt_def_id()\n-            .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)),\n+        ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         ExprKind::Block(\n             Block {\n                 stmts: [],"}, {"sha": "847c8c648b00acb21dfd4f4d9b6b8e61ebc2968a", "filename": "clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -54,7 +55,7 @@ impl LateLintPass<'_> for ManualOkOr {\n             let or_expr = &args[1];\n             if is_ok_wrapping(cx, &args[2]);\n             if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;\n-            if match_qpath(err_path, &paths::RESULT_ERR);\n+            if is_lang_ctor(cx, err_path, ResultErr);\n             if let Some(method_receiver_snippet) = snippet_opt(cx, method_receiver.span);\n             if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n             if let Some(indent) = indent_of(cx, scrutinee.span);\n@@ -81,7 +82,7 @@ impl LateLintPass<'_> for ManualOkOr {\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n     if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if match_qpath(qpath, &paths::RESULT_OK) {\n+        if is_lang_ctor(cx, qpath, ResultOk) {\n             return true;\n         }\n     }\n@@ -90,7 +91,7 @@ fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n         let body = cx.tcx.hir().body(body_id);\n         if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n         if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if match_qpath(ok_path, &paths::RESULT_OK);\n+        if is_lang_ctor(cx, ok_path, ResultOk);\n         then { path_to_local_id(ok_arg, param_id) } else { false }\n     }\n }"}, {"sha": "65baa2552ccc6b7758b9ce9c7570beb914539368", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{in_constant, match_qpath, path_to_local_id, paths, sugg};\n+use clippy_utils::{in_constant, is_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -68,23 +69,21 @@ impl Case {\n }\n \n fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+    fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n                 match arm.pat.kind {\n-                    PatKind::Path(ref some_qpath) =>\n-                        match_qpath(some_qpath, &paths::OPTION_NONE),\n-                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n-                        match_qpath(err_qpath, &paths::RESULT_ERR),\n+                    PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                    PatKind::TupleStruct(ref qpath, &[pat], _) =>\n+                        matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n                     _ => false,\n                 }\n-            );\n+            });\n             let unwrap_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n-            if match_qpath(unwrap_qpath, &paths::OPTION_SOME)\n-                || match_qpath(unwrap_qpath, &paths::RESULT_OK);\n+            if let PatKind::TupleStruct(ref qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n             if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n             if path_to_local_id(unwrap_arm.body, binding_hir_id);\n             if !contains_return_break_continue_macro(or_arm.body);\n@@ -106,7 +105,7 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         } else {\n             None\n         };\n-        if let Some(or_arm) = applicable_or_arm(match_arms);\n+        if let Some(or_arm) = applicable_or_arm(cx, match_arms);\n         if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = indent_of(cx, expr.span);\n         if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();"}, {"sha": "41cda23510ea2f9e19e694e534ebf0f98d5e8834", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_adjusted, is_trait_method, match_path, match_var, paths, remove_blocks};\n+use clippy_utils::{is_adjusted, is_qpath_def_path, is_trait_method, match_var, paths, remove_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n@@ -80,7 +80,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(QPath::Resolved(_, path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n         _ => false,\n     }\n }"}, {"sha": "44b4eb2903531db3381b9ddb133dc9b08430e754", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 249, "deletions": 51, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -7,14 +7,15 @@ use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::LocalUsedVisitor;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, meets_msrv, path_to_local,\n+    get_parent_expr, in_macro, is_allowed, is_expn_of, is_lang_ctor, is_refutable, is_wild, meets_msrv, path_to_local,\n     path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks, strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n     self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n     Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n@@ -422,7 +423,12 @@ declare_clippy_lint! {\n     /// **Why is this bad?** It's more concise and clear to just use the proper\n     /// utility function\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** This will change the drop order for the matched type. Both `if let` and\n+    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n+    /// value before entering the block. For most types this change will not matter, but for a few\n+    /// types this will not be an acceptable change (e.g. locks). See the\n+    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n+    /// drop order.\n     ///\n     /// **Example:**\n     ///\n@@ -737,8 +743,11 @@ fn report_single_match_single_pattern(\n     let (msg, sugg) = if_chain! {\n         if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n         let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n-        if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n-        if ty.is_integral() || ty.is_char() || ty.is_str() || implements_trait(cx, ty, trait_id, &[]);\n+        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str()\n+            || (implements_trait(cx, ty, spe_trait_id, &[])\n+                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n         then {\n             // scrutinee derives PartialEq and the pattern is a constant.\n             let pat_ref_count = match pat.kind {\n@@ -1120,7 +1129,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n             Applicability::MaybeIncorrect,\n         ),\n         variants => {\n-            let mut suggestions: Vec<_> = variants.iter().cloned().map(format_suggestion).collect();\n+            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n             let message = if adt_def.is_variant_list_non_exhaustive() {\n                 suggestions.push(\"_\".into());\n                 \"wildcard matches known variants and will also match future added variants\"\n@@ -1189,10 +1198,10 @@ fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n \n fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n-            is_ref_some_arm(&arms[1])\n-        } else if is_none_arm(&arms[1]) {\n-            is_ref_some_arm(&arms[0])\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n         } else {\n             None\n         };\n@@ -1500,7 +1509,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n /// Gets all arms that are unbounded `PatRange`s.\n fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n-        .flat_map(|arm| {\n+        .filter_map(|arm| {\n             if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n@@ -1575,20 +1584,20 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n }\n \n // Checks if arm has the form `None => None`\n-fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, pats, _) = arm.pat.kind;\n-        if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref qpath, pats, _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n         if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n-        if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n+        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n@@ -1699,54 +1708,206 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::source::snippet;\n-    use clippy_utils::{is_trait_method, match_qpath, paths};\n+    use clippy_utils::source::{snippet, snippet_with_applicability};\n+    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+    use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_errors::Applicability;\n-    use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n+    use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n+    use rustc_hir::{\n+        intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, PatKind, QPath,\n+    };\n     use rustc_lint::LateContext;\n+    use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                MatchSource::IfLetDesugar { contains_else_clause } => {\n+                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause)\n+                },\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n                 _ => {},\n             }\n         }\n     }\n \n+    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n+    /// deallocate memory. For these types, and composites containing them, changing the drop order\n+    /// won't result in any observable side effects.\n+    fn type_needs_ordered_drop(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if !ty.needs_drop(cx.tcx, cx.param_env) {\n+            false\n+        } else if !cx\n+            .tcx\n+            .lang_items()\n+            .drop_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n+            // This type doesn't implement drop, so no side effects here.\n+            // Check if any component type has any.\n+            match ty.kind() {\n+                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop(cx, ty)),\n+                ty::Array(ty, _) => type_needs_ordered_drop(cx, ty),\n+                ty::Adt(adt, subs) => adt\n+                    .all_fields()\n+                    .map(|f| f.ty(cx.tcx, subs))\n+                    .any(|ty| type_needs_ordered_drop(cx, ty)),\n+                _ => true,\n+            }\n+        }\n+        // Check for std types which implement drop, but only for memory allocation.\n+        else if is_type_diagnostic_item(cx, ty, sym::vec_type)\n+            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+            || is_type_diagnostic_item(cx, ty, sym::Rc)\n+            || is_type_diagnostic_item(cx, ty, sym::Arc)\n+            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n+            || match_type(cx, ty, &paths::BTREEMAP)\n+            || match_type(cx, ty, &paths::LINKED_LIST)\n+            || match_type(cx, ty, &paths::WEAK_RC)\n+            || match_type(cx, ty, &paths::WEAK_ARC)\n+        {\n+            // Check all of the generic arguments.\n+            if let ty::Adt(_, subs) = ty.kind() {\n+                subs.types().any(|ty| type_needs_ordered_drop(cx, ty))\n+            } else {\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    // Extract the generic arguments out of a type\n+    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+        if_chain! {\n+            if let ty::Adt(_, subs) = ty.kind();\n+            if let Some(sub) = subs.get(index);\n+            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+            then {\n+                Some(sub_ty)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    // Checks if there are any temporaries created in the given expression for which drop order\n+    // matters.\n+    fn temporaries_need_ordered_drop(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+        struct V<'a, 'tcx> {\n+            cx: &'a LateContext<'tcx>,\n+            res: bool,\n+        }\n+        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+            type Map = ErasedMap<'tcx>;\n+            fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+                match expr.kind {\n+                    // Taking the reference of a value leaves a temporary\n+                    // e.g. In `&String::new()` the string is a temporary value.\n+                    // Remaining fields are temporary values\n+                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                        if !matches!(expr.kind, ExprKind::Path(_)) {\n+                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(expr);\n+                            }\n+                        }\n+                    },\n+                    // the base type is alway taken by reference.\n+                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                    ExprKind::Index(base, index) => {\n+                        if !matches!(base.kind, ExprKind::Path(_)) {\n+                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(base);\n+                            }\n+                        }\n+                        self.visit_expr(index);\n+                    },\n+                    // Method calls can take self by reference.\n+                    // e.g. In `String::new().len()` the string is a temporary value.\n+                    ExprKind::MethodCall(_, _, [self_arg, args @ ..], _) => {\n+                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                            let self_by_ref = self\n+                                .cx\n+                                .typeck_results()\n+                                .type_dependent_def_id(expr.hir_id)\n+                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                            if self_by_ref\n+                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n+                            {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(self_arg)\n+                            }\n+                        }\n+                        args.iter().for_each(|arg| self.visit_expr(arg));\n+                    },\n+                    // Either explicitly drops values, or changes control flow.\n+                    ExprKind::DropTemps(_)\n+                    | ExprKind::Ret(_)\n+                    | ExprKind::Break(..)\n+                    | ExprKind::Yield(..)\n+                    | ExprKind::Block(Block { expr: None, .. }, _)\n+                    | ExprKind::Loop(..) => (),\n+\n+                    // Only consider the final expression.\n+                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                    _ => walk_expr(self, expr),\n+                }\n+            }\n+        }\n+\n+        let mut v = V { cx, res: false };\n+        v.visit_expr(expr);\n+        v.res\n+    }\n+\n     fn find_sugg_for_if_let<'tcx>(\n         cx: &LateContext<'tcx>,\n         expr: &'tcx Expr<'_>,\n-        op: &Expr<'_>,\n-        arms: &[Arm<'_>],\n+        op: &'tcx Expr<'tcx>,\n+        arm: &Arm<'_>,\n         keyword: &'static str,\n+        has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &arms[0].pat.kind;\n+        let mut kind = &arm.pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n         if let PatKind::Ref(inner, _mutability) = kind {\n             kind = &inner.kind;\n         }\n-        let good_method = match kind {\n-            PatKind::TupleStruct(ref path, patterns, _) if patterns.len() == 1 => {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    if match_qpath(path, &paths::RESULT_OK) {\n-                        \"is_ok()\"\n-                    } else if match_qpath(path, &paths::RESULT_ERR) {\n-                        \"is_err()\"\n-                    } else if match_qpath(path, &paths::OPTION_SOME) {\n-                        \"is_some()\"\n-                    } else if match_qpath(path, &paths::POLL_READY) {\n-                        \"is_ready()\"\n-                    } else if match_qpath(path, &paths::IPADDR_V4) {\n-                        \"is_ipv4()\"\n-                    } else if match_qpath(path, &paths::IPADDR_V6) {\n-                        \"is_ipv6()\"\n+        let op_ty = cx.typeck_results().expr_ty(op);\n+        // Determine which function should be used, and the type contained by the corresponding\n+        // variant.\n+        let (good_method, inner_ty) = match kind {\n+            PatKind::TupleStruct(ref path, [sub_pat], _) => {\n+                if let PatKind::Wild = sub_pat.kind {\n+                    if is_lang_ctor(cx, path, ResultOk) {\n+                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n+                    } else if is_lang_ctor(cx, path, ResultErr) {\n+                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n+                    } else if is_lang_ctor(cx, path, OptionSome) {\n+                        (\"is_some()\", op_ty)\n+                    } else if is_lang_ctor(cx, path, PollReady) {\n+                        (\"is_ready()\", op_ty)\n+                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n+                        (\"is_ipv4()\", op_ty)\n+                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n+                        (\"is_ipv6()\", op_ty)\n                     } else {\n                         return;\n                     }\n@@ -1755,17 +1916,36 @@ mod redundant_pattern_match {\n                 }\n             },\n             PatKind::Path(ref path) => {\n-                if match_qpath(path, &paths::OPTION_NONE) {\n+                let method = if is_lang_ctor(cx, path, OptionNone) {\n                     \"is_none()\"\n-                } else if match_qpath(path, &paths::POLL_PENDING) {\n+                } else if is_lang_ctor(cx, path, PollPending) {\n                     \"is_pending()\"\n                 } else {\n                     return;\n-                }\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             },\n             _ => return,\n         };\n \n+        // If this is the last expression in a block or there is an else clause then the whole\n+        // type needs to be considered, not just the inner type of the branch being matched on.\n+        // Note the last expression in a block is dropped after all local bindings.\n+        let check_ty = if has_else\n+            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+        {\n+            op_ty\n+        } else {\n+            inner_ty\n+        };\n+\n+        // All temporaries created in the scrutinee expression are dropped at the same time as the\n+        // scrutinee would be, so they have to be considered as well.\n+        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+        // for the duration if body.\n+        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, op);\n+\n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n@@ -1784,7 +1964,7 @@ mod redundant_pattern_match {\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n-            arms[0].pat.span,\n+            arm.pat.span,\n             &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n             |diag| {\n                 // while let ... = ... { ... }\n@@ -1798,12 +1978,20 @@ mod redundant_pattern_match {\n                 // while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n-                diag.span_suggestion(\n-                    span,\n-                    \"try this\",\n-                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                    Applicability::MachineApplicable, // snippet\n-                );\n+\n+                let mut app = if needs_drop {\n+                    Applicability::MaybeIncorrect\n+                } else {\n+                    Applicability::MachineApplicable\n+                };\n+                let sugg = snippet_with_applicability(cx, op_span, \"_\", &mut app);\n+\n+                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+                if needs_drop {\n+                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+                }\n             },\n         );\n     }\n@@ -1819,6 +2007,7 @@ mod redundant_pattern_match {\n                 ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n                     if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n                         find_good_method_for_match(\n+                            cx,\n                             arms,\n                             path_left,\n                             path_right,\n@@ -1829,6 +2018,7 @@ mod redundant_pattern_match {\n                         )\n                         .or_else(|| {\n                             find_good_method_for_match(\n+                                cx,\n                                 arms,\n                                 path_left,\n                                 path_right,\n@@ -1848,6 +2038,7 @@ mod redundant_pattern_match {\n                 {\n                     if let PatKind::Wild = patterns[0].kind {\n                         find_good_method_for_match(\n+                            cx,\n                             arms,\n                             path_left,\n                             path_right,\n@@ -1858,6 +2049,7 @@ mod redundant_pattern_match {\n                         )\n                         .or_else(|| {\n                             find_good_method_for_match(\n+                                cx,\n                                 arms,\n                                 path_left,\n                                 path_right,\n@@ -1898,7 +2090,9 @@ mod redundant_pattern_match {\n         }\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n     fn find_good_method_for_match<'a>(\n+        cx: &LateContext<'_>,\n         arms: &[Arm<'_>],\n         path_left: &QPath<'_>,\n         path_right: &QPath<'_>,\n@@ -1907,9 +2101,13 @@ mod redundant_pattern_match {\n         should_be_left: &'a str,\n         should_be_right: &'a str,\n     ) -> Option<&'a str> {\n-        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+        let body_node_pair = if is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_left)\n+            && is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_right)\n+        {\n             (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+        } else if is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_left)\n+            && is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_right)\n+        {\n             (&(*arms[1].body).kind, &(*arms[0].body).kind)\n         } else {\n             return None;"}, {"sha": "ec60bffe95555fe0e256c47383519aa76b91f32f", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::is_diagnostic_assoc_item;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, match_def_path, match_qpath, meets_msrv, paths};\n+use clippy_utils::{in_macro, is_diag_trait_item, is_lang_ctor, match_def_path, meets_msrv, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -102,7 +102,7 @@ impl_lint_pass!(MemReplace =>\n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if let ExprKind::Path(ref replacement_qpath) = src.kind {\n         // Check that second argument is `Option::None`\n-        if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n+        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n             // Since this is a late pass (already type-checked),\n             // and we already know that the second argument is an\n             // `Option`, we do not need to check the first\n@@ -210,17 +210,17 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n         sym::BinaryHeap,\n     ];\n \n-    if std_types_symbols\n-        .iter()\n-        .any(|symbol| is_diagnostic_assoc_item(cx, def_id, *symbol))\n-    {\n-        if let QPath::TypeRelative(_, method) = path {\n-            if method.ident.name == sym::new {\n-                return true;\n+    if let QPath::TypeRelative(_, method) = path {\n+        if method.ident.name == sym::new {\n+            if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n+                if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n+                    return std_types_symbols\n+                        .iter()\n+                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n+                }\n             }\n         }\n     }\n-\n     false\n }\n \n@@ -230,7 +230,7 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n         if !in_external_macro(cx.tcx.sess, expr_span);\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n         if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n-        if is_diagnostic_assoc_item(cx, repl_def_id, sym::Default)\n+        if is_diag_trait_item(cx, repl_def_id, sym::Default)\n             || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n \n         then {"}, {"sha": "ba97ab3900ca4b0f1a6960076c699641726e0054", "filename": "clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,38 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::ty::{get_iterator_item_ty, is_copy};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::{sym, Span};\n+\n+use super::CLONED_INSTEAD_OF_COPIED;\n+\n+pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span) {\n+    let recv_ty = cx.typeck_results().expr_ty_adjusted(recv);\n+    let inner_ty = match recv_ty.kind() {\n+        // `Option<T>` -> `T`\n+        ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::option_type, adt.did) => subst.type_at(0),\n+        _ if is_trait_method(cx, expr, sym::Iterator) => match get_iterator_item_ty(cx, recv_ty) {\n+            // <T as Iterator>::Item\n+            Some(ty) => ty,\n+            _ => return,\n+        },\n+        _ => return,\n+    };\n+    match inner_ty.kind() {\n+        // &T where T: Copy\n+        ty::Ref(_, ty, _) if is_copy(cx, ty) => {},\n+        _ => return,\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        CLONED_INSTEAD_OF_COPIED,\n+        span,\n+        \"used `cloned` where `copied` could be used instead\",\n+        \"try\",\n+        \"copied\".into(),\n+        Applicability::MachineApplicable,\n+    )\n+}"}, {"sha": "1588eec88824bfdfc97ebee00565fe846a81f179", "filename": "clippy_lints/src/methods/filter_flat_map.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,18 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_trait_method;\n-use rustc_hir as hir;\n-use rustc_lint::LateContext;\n-use rustc_span::sym;\n-\n-use super::FILTER_MAP;\n-\n-/// lint use of `filter().flat_map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-    // lint if caller of `.filter().flat_map()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";\n-        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n-                    and filtering by returning `iter::empty()`\";\n-        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n-    }\n-}"}, {"sha": "741b1e7e361255c09560bbdadd26ca46e32963b7", "filename": "clippy_lints/src/methods/filter_map_flat_map.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,18 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_trait_method;\n-use rustc_hir as hir;\n-use rustc_lint::LateContext;\n-use rustc_span::sym;\n-\n-use super::FILTER_MAP;\n-\n-/// lint use of `filter_map().flat_map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-    // lint if caller of `.filter_map().flat_map()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";\n-        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n-                    and filtering by returning `iter::empty()`\";\n-        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n-    }\n-}"}, {"sha": "403fe8d35468468db91a9c46a13dd2755b5c9fd7", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_expr_path_def_path, is_trait_method, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -33,14 +33,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg:\n             }\n         }\n \n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = filter_map_arg.kind;\n-\n-            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n-\n-            then {\n-                apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n-            }\n+        if is_expr_path_def_path(cx, filter_map_arg, &paths::CONVERT_IDENTITY) {\n+            apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n         }\n     }\n }"}, {"sha": "713bbf258370d9ac08b1cf67d288e173abe4dd14", "filename": "clippy_lints/src/methods/filter_map_map.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,17 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_trait_method;\n-use rustc_hir as hir;\n-use rustc_lint::LateContext;\n-use rustc_span::sym;\n-\n-use super::FILTER_MAP;\n-\n-/// lint use of `filter_map().map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-    // lint if caller of `.filter_map().map()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";\n-        let hint = \"this is more succinctly expressed by only calling `.filter_map(..)` instead\";\n-        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n-    }\n-}"}, {"sha": "25f8434cb94428f458f36fd442fcf8260e542828", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_trait_method, match_qpath, paths};\n+use clippy_utils::{is_expr_path_def_path, is_trait_method, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -16,8 +16,6 @@ pub(super) fn check<'tcx>(\n     flat_map_span: Span,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &flat_map_arg.kind;\n-\n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n                 cx,\n@@ -31,8 +29,8 @@ pub(super) fn check<'tcx>(\n         };\n \n         if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n-            let body = cx.tcx.hir().body(*body_id);\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = flat_map_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n \n             if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n             if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n@@ -45,14 +43,8 @@ pub(super) fn check<'tcx>(\n             }\n         }\n \n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = arg_node;\n-\n-            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n-\n-            then {\n-                apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n-            }\n+        if is_expr_path_def_path(cx, flat_map_arg, &paths::CONVERT_IDENTITY) {\n+            apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n         }\n     }\n }"}, {"sha": "12d560653edf3cd70a1b3486cfc49a9de9c3e63a", "filename": "clippy_lints/src/methods/flat_map_option.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::{source_map::Span, sym};\n+\n+use super::FLAT_MAP_OPTION;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>, span: Span) {\n+    if !is_trait_method(cx, expr, sym::Iterator) {\n+        return;\n+    }\n+    let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n+    let sig = match arg_ty.kind() {\n+        ty::Closure(_, substs) => substs.as_closure().sig(),\n+        _ if arg_ty.is_fn() => arg_ty.fn_sig(cx.tcx),\n+        _ => return,\n+    };\n+    if !is_type_diagnostic_item(cx, sig.output().skip_binder(), sym::option_type) {\n+        return;\n+    }\n+    span_lint_and_sugg(\n+        cx,\n+        FLAT_MAP_OPTION,\n+        span,\n+        \"used `flat_map` where `filter_map` could be used instead\",\n+        \"try\",\n+        \"filter_map\".into(),\n+        Applicability::MachineApplicable,\n+    )\n+}"}, {"sha": "28d0e8cd4ae9e33039c01e7b0c21c34d55166bb4", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,26 +1,23 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, match_qpath, paths, sugg};\n+use clippy_utils::{is_expr_path_def_path, paths, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::ExprKind;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty::Ty;\n use rustc_span::sym;\n \n use super::FROM_ITER_INSTEAD_OF_COLLECT;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>], func_kind: &ExprKind<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>], func: &hir::Expr<'_>) {\n     if_chain! {\n-        if let hir::ExprKind::Path(path) = func_kind;\n-        if match_qpath(path, &[\"from_iter\"]);\n+        if is_expr_path_def_path(cx, func, &paths::FROM_ITERATOR_METHOD);\n         let ty = cx.typeck_results().expr_ty(expr);\n         let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n-        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n         if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n \n-        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        if implements_trait(cx, arg_ty, iter_id, &[]);\n         then {\n             // `expr` implements `FromIterator` trait\n             let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();"}, {"sha": "81c42de145f6c704f7333c6a6618e8c73427e3c6", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,28 +1,36 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::{is_diag_item_method, is_diag_trait_item};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::ExprKind;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Span};\n \n use super::IMPLICIT_CLONE;\n-use clippy_utils::is_diagnostic_assoc_item;\n \n-pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, trait_diagnostic: Symbol) {\n+pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, span: Span) {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_path, _, [arg], _) = &expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if match method_name {\n+            \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n+            \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n+            \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n+            \"to_vec\" => cx.tcx.impl_of_method(method_def_id)\n+                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n+                == Some(true),\n+            _ => false,\n+        };\n         let return_type = cx.typeck_results().expr_ty(expr);\n-        let input_type = cx.typeck_results().expr_ty(arg).peel_refs();\n-        if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        let input_type = cx.typeck_results().expr_ty(recv).peel_refs();\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n         if TyS::same_type(return_type, input_type);\n-        if is_diagnostic_assoc_item(cx, expr_def_id, trait_diagnostic);\n         then {\n             span_lint_and_sugg(\n-                cx,IMPLICIT_CLONE,method_path.ident.span,\n-                &format!(\"implicitly cloning a `{}` by calling `{}` on its dereferenced type\", ty_name, method_path.ident.name),\n+                cx,\n+                IMPLICIT_CLONE,\n+                span,\n+                &format!(\"implicitly cloning a `{}` by calling `{}` on its dereferenced type\", ty_name, method_name),\n                 \"consider using\",\n                 \"clone\".to_string(),\n                 Applicability::MachineApplicable"}, {"sha": "2fddea7068d961f45d14a81bb3961c1377cce7f0", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::match_qpath;\n+use clippy_utils::is_qpath_def_path;\n use clippy_utils::source::snippet_with_applicability;\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -94,11 +94,11 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n \n     // `std::T::MAX` `std::T::MIN` constants\n     if let hir::ExprKind::Path(path) = &expr.kind {\n-        if match_qpath(path, &[\"core\", &ty_str, \"MAX\"][..]) {\n+        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MAX\"][..]) {\n             return Some(MinMax::Max);\n         }\n \n-        if match_qpath(path, &[\"core\", &ty_str, \"MIN\"][..]) {\n+        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MIN\"][..]) {\n             return Some(MinMax::Min);\n         }\n     }"}, {"sha": "c2cd3011d14933fc4db6caf29eb2c20a191a5200", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -8,17 +8,16 @@ mod chars_next_cmp;\n mod chars_next_cmp_with_unwrap;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n+mod cloned_instead_of_copied;\n mod expect_fun_call;\n mod expect_used;\n mod filetype_is_file;\n-mod filter_flat_map;\n mod filter_map;\n-mod filter_map_flat_map;\n mod filter_map_identity;\n-mod filter_map_map;\n mod filter_map_next;\n mod filter_next;\n mod flat_map_identity;\n+mod flat_map_option;\n mod from_iter_instead_of_collect;\n mod get_unwrap;\n mod implicit_clone;\n@@ -76,6 +75,52 @@ use rustc_span::symbol::SymbolStr;\n use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `cloned()` on an `Iterator` or `Option` where\n+    /// `copied()` could be used instead.\n+    ///\n+    /// **Why is this bad?** `copied()` is better because it guarantees that the type being cloned\n+    /// implements `Copy`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// [1, 2, 3].iter().cloned();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// [1, 2, 3].iter().copied();\n+    /// ```\n+    pub CLONED_INSTEAD_OF_COPIED,\n+    pedantic,\n+    \"used `cloned` where `copied` could be used instead\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `Iterator::flat_map()` where `filter_map()` could be\n+    /// used instead.\n+    ///\n+    /// **Why is this bad?** When applicable, `filter_map()` is more clear since it shows that\n+    /// `Option` is used to produce 0 or 1 items.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n+    /// ```\n+    pub FLAT_MAP_OPTION,\n+    pedantic,\n+    \"used `flat_map` where `filter_map` could be used instead\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for `.unwrap()` calls on `Option`s and on `Result`s.\n     ///\n@@ -472,35 +517,6 @@ declare_clippy_lint! {\n     \"using combinations of `flatten` and `map` which can usually be written as a single method call\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n-    /// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n-    ///\n-    /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `_.filter_map(_)`.\n-    ///\n-    /// **Known problems:** Often requires a condition + Option/Iterator creation\n-    /// inside the closure.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let vec = vec![1];\n-    ///\n-    /// // Bad\n-    /// vec.iter().filter(|x| **x == 0).map(|x| *x * 2);\n-    ///\n-    /// // Good\n-    /// vec.iter().filter_map(|x| if *x == 0 {\n-    ///     Some(*x * 2)\n-    /// } else {\n-    ///     None\n-    /// });\n-    /// ```\n-    pub FILTER_MAP,\n-    pedantic,\n-    \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `_.filter(_).map(_)` that can be written more simply\n     /// as `filter_map(_)`.\n@@ -1670,14 +1686,15 @@ impl_lint_pass!(Methods => [\n     CLONE_ON_COPY,\n     CLONE_ON_REF_PTR,\n     CLONE_DOUBLE_REF,\n+    CLONED_INSTEAD_OF_COPIED,\n+    FLAT_MAP_OPTION,\n     INEFFICIENT_TO_STRING,\n     NEW_RET_NO_SELF,\n     SINGLE_CHAR_PATTERN,\n     SINGLE_CHAR_ADD_STR,\n     SEARCH_IS_SOME,\n     FILTER_NEXT,\n     SKIP_WHILE_NEXT,\n-    FILTER_MAP,\n     FILTER_MAP_IDENTITY,\n     MANUAL_FILTER_MAP,\n     MANUAL_FIND_MAP,\n@@ -1741,7 +1758,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n         match expr.kind {\n             hir::ExprKind::Call(func, args) => {\n-                from_iter_instead_of_collect::check(cx, expr, args, &func.kind);\n+                from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n             hir::ExprKind::MethodCall(method_call, ref method_span, args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n@@ -1942,6 +1959,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n             (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n             (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n+            (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span),\n             (\"collect\", []) => match method_call!(recv) {\n                 Some((\"cloned\", [recv2], _)) => iter_cloned_collect::check(cx, expr, recv2),\n                 Some((\"map\", [m_recv, m_arg], _)) => {\n@@ -1965,10 +1983,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 unnecessary_filter_map::check(cx, expr, arg);\n                 filter_map_identity::check(cx, expr, arg, span);\n             },\n-            (\"flat_map\", [flm_arg]) => match method_call!(recv) {\n-                Some((\"filter\", [_, _], _)) => filter_flat_map::check(cx, expr),\n-                Some((\"filter_map\", [_, _], _)) => filter_map_flat_map::check(cx, expr),\n-                _ => flat_map_identity::check(cx, expr, flm_arg, span),\n+            (\"flat_map\", [arg]) => {\n+                flat_map_identity::check(cx, expr, arg, span);\n+                flat_map_option::check(cx, expr, arg, span);\n             },\n             (\"flatten\", []) => {\n                 if let Some((\"map\", [recv, map_arg], _)) = method_call!(recv) {\n@@ -1993,7 +2010,6 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                         (\"filter\", [f_arg]) => {\n                             filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false)\n                         },\n-                        (\"filter_map\", [_]) => filter_map_map::check(cx, expr),\n                         (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n                         _ => {},\n                     }\n@@ -2025,10 +2041,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 }\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n-            (\"to_os_string\", []) => implicit_clone::check(cx, expr, sym::OsStr),\n-            (\"to_owned\", []) => implicit_clone::check(cx, expr, sym::ToOwned),\n-            (\"to_path_buf\", []) => implicit_clone::check(cx, expr, sym::Path),\n-            (\"to_vec\", []) => implicit_clone::check(cx, expr, sym::slice),\n+            (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n+                implicit_clone::check(cx, name, expr, recv, span);\n+            },\n             (\"unwrap\", []) => match method_call!(recv) {\n                 Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n                 Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),"}, {"sha": "36a1c13d5be1e1918cab85e6cea28e34920a102c", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_qpath, paths};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -32,7 +33,7 @@ pub(super) fn check<'tcx>(\n \n     let (lint_name, msg, instead, hint) = {\n         let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-            match_qpath(qpath, &paths::OPTION_NONE)\n+            is_lang_ctor(cx, qpath, OptionNone)\n         } else {\n             return;\n         };\n@@ -43,7 +44,7 @@ pub(super) fn check<'tcx>(\n         }\n \n         let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-            match_qpath(qpath, &paths::OPTION_SOME)\n+            is_lang_ctor(cx, qpath, OptionSome)\n         } else {\n             false\n         };"}, {"sha": "1a5894e48d14c5ac1c935dae2231e086f248c78c", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_def_path, match_qpath, paths};\n+use clippy_utils::{is_expr_path_def_path, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -12,8 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n     if_chain! {\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(ref path) = callee.kind;\n-        if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n+        if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n         if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint("}, {"sha": "b61c4ffe9b3aebb5abd0a4d39ec94abf1d75e830", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::sym;\n@@ -54,14 +55,12 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n     match &expr.kind {\n         hir::ExprKind::Call(func, args) => {\n             if let hir::ExprKind::Path(ref path) = func.kind {\n-                if match_qpath(path, &paths::OPTION_SOME) {\n+                if is_lang_ctor(cx, path, OptionSome) {\n                     if path_to_local_id(&args[0], arg_id) {\n                         return (false, false);\n                     }\n                     return (true, false);\n                 }\n-                // We don't know. It might do anything.\n-                return (true, true);\n             }\n             (true, true)\n         },\n@@ -85,7 +84,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n+        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n         _ => (true, true),\n     }\n }"}, {"sha": "6e2bcb113c2c1baf6ba899e59a135db8482c7fa3", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -102,6 +102,14 @@ pub(super) fn check<'tcx>(\n             .iter()\n             .all(|conv| conv.check(cx, self_ty, item_name, implements_trait, is_trait_item))\n     }) {\n+        // don't lint if it implements a trait but not willing to check `Copy` types conventions (see #7032)\n+        if implements_trait\n+            && !conventions\n+                .iter()\n+                .any(|conv| matches!(conv, Convention::IsSelfTypeCopy(_)))\n+        {\n+            return;\n+        }\n         if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n             let suggestion = {\n                 if conventions.len() > 1 {"}, {"sha": "0b0cd9be46cf41f02614a99d6a4839aac9c235e3", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use crate::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    get_item_name, get_parent_expr, higher, in_constant, is_diagnostic_assoc_item, is_integer_const, iter_input_pats,\n-    last_path_segment, match_qpath, unsext, SpanlessEq,\n+    expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n+    iter_input_pats, last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -555,22 +555,22 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n         ExprKind::MethodCall(.., args, _) if args.len() == 1 => {\n             if_chain!(\n                 if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-                if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString)\n-                    || is_diagnostic_assoc_item(cx, expr_def_id, sym::ToOwned);\n+                if is_diag_trait_item(cx, expr_def_id, sym::ToString)\n+                    || is_diag_trait_item(cx, expr_def_id, sym::ToOwned);\n                 then {\n                     (cx.typeck_results().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n             )\n         },\n-        ExprKind::Call(path, v) if v.len() == 1 => {\n-            if let ExprKind::Path(ref path) = path.kind {\n-                if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n-                } else {\n-                    return;\n-                }\n+        ExprKind::Call(path, [arg]) => {\n+            if expr_path_res(cx, path)\n+                .opt_def_id()\n+                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n+                .is_some()\n+            {\n+                (cx.typeck_results().expr_ty(arg), snippet(cx, arg.span, \"..\"))\n             } else {\n                 return;\n             }"}, {"sha": "93b7a897405aee42b368639e58ee6cca2a4bba11", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         let mir = cx.tcx.optimized_mir(def_id);\n \n-        if let Err((span, err)) = is_min_const_fn(cx.tcx, mir) {\n+        if let Err((span, err)) = is_min_const_fn(cx.tcx, mir, self.msrv.as_ref()) {\n             if rustc_mir::const_eval::is_min_const_fn(cx.tcx, def_id.to_def_id()) {\n                 cx.tcx.sess.span_err(span, &err);\n             }"}, {"sha": "64e9dc85466eb6e5a969b8d5d56a559e6bfe9a52", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::sext;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n "}, {"sha": "dd4581986377f54b02e6034a3a1bf23e487af971", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -5,7 +5,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{is_expn_of, parent_node_is_if_expr};\n+use clippy_utils::{is_else_clause, is_expn_of};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     snip = snip.make_return();\n                 }\n \n-                if parent_node_is_if_expr(e, cx) {\n+                if is_else_clause(cx.tcx, e) {\n                     snip = snip.blockify()\n                 }\n "}, {"sha": "e33a33e238633aeaf5b68930e536070d80b73cb5", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -279,7 +279,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             spans.extend(\n                                 deref_span\n                                     .iter()\n-                                    .cloned()\n+                                    .copied()\n                                     .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))),\n                             );\n                             spans.sort_by_key(|&(span, _)| span);"}, {"sha": "cfe7ae6630e0472257e9284dcf0b3139aad5c980", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, is_ok_ctor, is_some_ctor, meets_msrv};\n+use clippy_utils::{differing_macro_contexts, meets_msrv};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_semver::RustcVersion;\n@@ -159,8 +161,8 @@ fn is_some_or_ok_call<'a>(\n     if_chain! {\n         // Check outer expression matches CALL_IDENT(ARGUMENT) format\n         if let ExprKind::Call(path, args) = &expr.kind;\n-        if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n-        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+        if let ExprKind::Path(ref qpath) = &path.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n \n         // Extract inner expression from ARGUMENT\n         if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;"}, {"sha": "e527adbb8929def838d0e8dc9ef6ffbfe6b3ad52", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::paths;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, get_enclosing_block, in_macro, match_qpath};\n+use clippy_utils::{eager_or_lazy, get_enclosing_block, in_macro, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::OptionSome;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -164,7 +164,7 @@ fn detect_option_if_let_else<'tcx>(\n         if arms.len() == 2;\n         if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n-        if match_qpath(struct_qpath, &paths::OPTION_SOME);\n+        if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n         if !contains_return_break_continue_macro(arms[0].body);\n         if !contains_return_break_continue_macro(arms[1].body);"}, {"sha": "cef74d87e7c016a8348dc5081fd6fddde0d01521", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{find_macro_calls, return_ty};\n+use clippy_utils::{find_macro_calls, is_expn_of, return_ty};\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n }\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n-    let panics = find_macro_calls(\n+    let mut panics = find_macro_calls(\n         &[\n             \"unimplemented\",\n             \"unreachable\",\n@@ -61,12 +61,10 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir\n             \"assert\",\n             \"assert_eq\",\n             \"assert_ne\",\n-            \"debug_assert\",\n-            \"debug_assert_eq\",\n-            \"debug_assert_ne\",\n         ],\n         body,\n     );\n+    panics.retain(|span| is_expn_of(*span, \"debug_assert\").is_none());\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "1a680e7607e0b21e0116df6e0fa4363af52081b9", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -74,7 +74,7 @@ declare_lint_pass!(PanicUnimplemented => [UNIMPLEMENTED, UNREACHABLE, TODO, PANI\n \n impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if match_panic_call(cx, expr).is_some() {\n+        if match_panic_call(cx, expr).is_some() && is_expn_of(expr.span, \"debug_assert\").is_none() {\n             let span = get_outer_span(expr);\n             if is_expn_of(expr.span, \"unimplemented\").is_some() {\n                 span_lint("}, {"sha": "6b64846c24d101026756f0d222d318b935bb6724", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -42,6 +42,14 @@ declare_clippy_lint! {\n     /// false positives in cases involving multiple lifetimes that are bounded by\n     /// each other.\n     ///\n+    /// Also, it does not take account of other similar cases where getting memory addresses\n+    /// matters; namely, returning the pointer to the argument in question,\n+    /// and passing the argument, as both references and pointers,\n+    /// to a function that needs the memory address. For further details, refer to\n+    /// [this issue](https://github.com/rust-lang/rust-clippy/issues/5953)\n+    /// that explains a real case in which this false positive\n+    /// led to an **undefined behaviour** introduced with unsafe code.\n+    ///\n     /// **Example:**\n     ///\n     /// ```rust"}, {"sha": "b0674f90678362d0248ac4def6f5fa738e50a83d", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 82, "deletions": 12, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_the\n use clippy_utils::ptr::get_spans;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{is_type_diagnostic_item, match_type, walk_ptrs_hir_ty};\n-use clippy_utils::{is_allowed, match_qpath, paths};\n+use clippy_utils::{expr_path_res, is_allowed, match_any_def_paths, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -15,6 +15,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n use rustc_span::{sym, MultiSpan};\n use std::borrow::Cow;\n \n@@ -94,7 +95,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CMP_NULL,\n     style,\n-    \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n+    \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead\"\n }\n \n declare_clippy_lint! {\n@@ -119,7 +120,28 @@ declare_clippy_lint! {\n     \"fns that create mutable refs from immutable ref args\"\n }\n \n-declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n+declare_clippy_lint! {\n+    /// **What it does:** This lint checks for invalid usages of `ptr::null`.\n+    ///\n+    /// **Why is this bad?** This causes undefined behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // Bad. Undefined behavior\n+    /// unsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n+    /// ```\n+    ///\n+    /// // Good\n+    /// unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n+    /// ```\n+    pub INVALID_NULL_PTR_USAGE,\n+    correctness,\n+    \"invalid usage of a null pointer, suggesting `NonNull::dangling()` instead\"\n+}\n+\n+declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF, INVALID_NULL_PTR_USAGE]);\n \n impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -153,14 +175,63 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref op, l, r) = expr.kind {\n-            if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n+            if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(cx, l) || is_null_path(cx, r)) {\n                 span_lint(\n                     cx,\n                     CMP_NULL,\n                     expr.span,\n                     \"comparing with null is better expressed by the `.is_null()` method\",\n                 );\n             }\n+        } else {\n+            check_invalid_ptr_usage(cx, expr);\n+        }\n+    }\n+}\n+\n+fn check_invalid_ptr_usage<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    // (fn_path, arg_indices) - `arg_indices` are the `arg` positions where null would cause U.B.\n+    const INVALID_NULL_PTR_USAGE_TABLE: [(&[&str], &[usize]); 16] = [\n+        (&paths::SLICE_FROM_RAW_PARTS, &[0]),\n+        (&paths::SLICE_FROM_RAW_PARTS_MUT, &[0]),\n+        (&paths::PTR_COPY, &[0, 1]),\n+        (&paths::PTR_COPY_NONOVERLAPPING, &[0, 1]),\n+        (&paths::PTR_READ, &[0]),\n+        (&paths::PTR_READ_UNALIGNED, &[0]),\n+        (&paths::PTR_READ_VOLATILE, &[0]),\n+        (&paths::PTR_REPLACE, &[0]),\n+        (&paths::PTR_SLICE_FROM_RAW_PARTS, &[0]),\n+        (&paths::PTR_SLICE_FROM_RAW_PARTS_MUT, &[0]),\n+        (&paths::PTR_SWAP, &[0, 1]),\n+        (&paths::PTR_SWAP_NONOVERLAPPING, &[0, 1]),\n+        (&paths::PTR_WRITE, &[0]),\n+        (&paths::PTR_WRITE_UNALIGNED, &[0]),\n+        (&paths::PTR_WRITE_VOLATILE, &[0]),\n+        (&paths::PTR_WRITE_BYTES, &[0]),\n+    ];\n+\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        let fun_def_path = cx.get_def_path(fun_def_id).into_iter().map(Symbol::to_ident_string).collect::<Vec<_>>();\n+        if let Some(&(_, arg_indices)) = INVALID_NULL_PTR_USAGE_TABLE\n+            .iter()\n+            .find(|&&(fn_path, _)| fn_path == fun_def_path);\n+        then {\n+            for &arg_idx in arg_indices {\n+                if let Some(arg) = args.get(arg_idx).filter(|arg| is_null_path(cx, arg)) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        INVALID_NULL_PTR_USAGE,\n+                        arg.span,\n+                        \"pointer must be non-null\",\n+                        \"change this to\",\n+                        \"core::ptr::NonNull::dangling().as_ptr()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n     }\n }\n@@ -345,13 +416,12 @@ fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability,\n     }\n }\n \n-fn is_null_path(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(pathexp, args) = expr.kind {\n-        if args.is_empty() {\n-            if let ExprKind::Path(ref path) = pathexp.kind {\n-                return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n-            }\n-        }\n+fn is_null_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Call(pathexp, []) = expr.kind {\n+        expr_path_res(cx, pathexp).opt_def_id().map_or(false, |id| {\n+            match_any_def_paths(cx, id, &[&paths::PTR_NULL, &paths::PTR_NULL_MUT]).is_some()\n+        })\n+    } else {\n+        false\n     }\n-    false\n }"}, {"sha": "30bee21390068eadf73ac702b08a9565beafcb36", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, match_def_path, match_qpath, paths};\n+use clippy_utils::{eq_expr_value, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -100,15 +101,14 @@ impl QuestionMark {\n             if Self::is_option(cx, subject);\n \n             if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n-            if match_qpath(path1, &[\"Some\"]);\n-            if let PatKind::Binding(annot, _, bind, _) = &fields[0].kind;\n+            if is_lang_ctor(cx, path1, OptionSome);\n+            if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n             if let ExprKind::Block(block, None) = &arms[0].body.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n-            if let ExprKind::Path(path) = &trailing_expr.kind;\n-            if match_qpath(path, &[&bind.as_str()]);\n+            if path_to_local_id(trailing_expr, bind_id);\n \n             if let PatKind::Wild = arms[1].pat.kind;\n             if Self::expression_returns_none(cx, arms[1].body);\n@@ -156,15 +156,7 @@ impl QuestionMark {\n                 false\n             },\n             ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n-            ExprKind::Path(ref qp) => {\n-                if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n-                    cx.qpath_res(qp, expression.hir_id)\n-                {\n-                    return match_def_path(cx, def_id, &paths::OPTION_NONE);\n-                }\n-\n-                false\n-            },\n+            ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n             _ => false,\n         }\n     }"}, {"sha": "b565c77aaecff808131af09b3c81dd23ca69197c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{fn_def_id, in_macro, match_qpath};\n+use clippy_utils::{fn_def_id, in_macro, path_to_local_id};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n@@ -84,9 +84,8 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n             if local.ty.is_none();\n             if cx.tcx.hir().attrs(local.hir_id).is_empty();\n             if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if let PatKind::Binding(_, local_id, _, _) = local.pat.kind;\n+            if path_to_local_id(retexpr, local_id);\n             if !last_statement_borrows(cx, initexpr);\n             if !in_external_macro(cx.sess(), initexpr.span);\n             if !in_external_macro(cx.sess(), retexpr.span);\n@@ -223,6 +222,7 @@ fn check_final_expr<'tcx>(\n             },\n             _ => (),\n         },\n+        ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),\n         _ => (),\n     }\n }"}, {"sha": "6104103580e989fe56530b3bd767b56ac2b2af7a", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 109, "deletions": 16, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,11 +1,10 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::in_macro;\n-use if_chain::if_chain;\n-use rustc_ast::{Item, ItemKind, UseTreeKind};\n+use rustc_ast::{ptr::P, Crate, Item, ItemKind, ModKind, UseTreeKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::edition::Edition;\n+use rustc_span::{edition::Edition, symbol::kw, Span, Symbol};\n \n declare_clippy_lint! {\n     /// **What it does:** Checking for imports with single component use path.\n@@ -38,26 +37,120 @@ declare_clippy_lint! {\n declare_lint_pass!(SingleComponentPathImports => [SINGLE_COMPONENT_PATH_IMPORTS]);\n \n impl EarlyLintPass for SingleComponentPathImports {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if_chain! {\n-            if !in_macro(item.span);\n-            if cx.sess.opts.edition >= Edition::Edition2018;\n-            if !item.vis.kind.is_pub();\n-            if let ItemKind::Use(use_tree) = &item.kind;\n-            if let segments = &use_tree.prefix.segments;\n-            if segments.len() == 1;\n-            if let UseTreeKind::Simple(None, _, _) = use_tree.kind;\n-            then {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n+        if cx.sess.opts.edition < Edition::Edition2018 {\n+            return;\n+        }\n+        check_mod(cx, &krate.items);\n+    }\n+}\n+\n+fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n+    // keep track of imports reused with `self` keyword,\n+    // such as `self::crypto_hash` in the example below\n+    // ```rust,ignore\n+    // use self::crypto_hash::{Algorithm, Hasher};\n+    // ```\n+    let mut imports_reused_with_self = Vec::new();\n+\n+    // keep track of single use statements\n+    // such as `crypto_hash` in the example below\n+    // ```rust,ignore\n+    // use crypto_hash;\n+    // ```\n+    let mut single_use_usages = Vec::new();\n+\n+    for item in items {\n+        track_uses(cx, &item, &mut imports_reused_with_self, &mut single_use_usages);\n+    }\n+\n+    for single_use in &single_use_usages {\n+        if !imports_reused_with_self.contains(&single_use.0) {\n+            let can_suggest = single_use.2;\n+            if can_suggest {\n                 span_lint_and_sugg(\n                     cx,\n                     SINGLE_COMPONENT_PATH_IMPORTS,\n-                    item.span,\n+                    single_use.1,\n                     \"this import is redundant\",\n                     \"remove it entirely\",\n                     String::new(),\n-                    Applicability::MachineApplicable\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                span_lint_and_help(\n+                    cx,\n+                    SINGLE_COMPONENT_PATH_IMPORTS,\n+                    single_use.1,\n+                    \"this import is redundant\",\n+                    None,\n+                    \"remove this import\",\n                 );\n             }\n         }\n     }\n }\n+\n+fn track_uses(\n+    cx: &EarlyContext<'_>,\n+    item: &Item,\n+    imports_reused_with_self: &mut Vec<Symbol>,\n+    single_use_usages: &mut Vec<(Symbol, Span, bool)>,\n+) {\n+    if in_macro(item.span) || item.vis.kind.is_pub() {\n+        return;\n+    }\n+\n+    match &item.kind {\n+        ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n+            check_mod(cx, &items);\n+        },\n+        ItemKind::Use(use_tree) => {\n+            let segments = &use_tree.prefix.segments;\n+\n+            // keep track of `use some_module;` usages\n+            if segments.len() == 1 {\n+                if let UseTreeKind::Simple(None, _, _) = use_tree.kind {\n+                    let ident = &segments[0].ident;\n+                    single_use_usages.push((ident.name, item.span, true));\n+                }\n+                return;\n+            }\n+\n+            if segments.is_empty() {\n+                // keep track of `use {some_module, some_other_module};` usages\n+                if let UseTreeKind::Nested(trees) = &use_tree.kind {\n+                    for tree in trees {\n+                        let segments = &tree.0.prefix.segments;\n+                        if segments.len() == 1 {\n+                            if let UseTreeKind::Simple(None, _, _) = tree.0.kind {\n+                                let ident = &segments[0].ident;\n+                                single_use_usages.push((ident.name, tree.0.span, false));\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                // keep track of `use self::some_module` usages\n+                if segments[0].ident.name == kw::SelfLower {\n+                    // simple case such as `use self::module::SomeStruct`\n+                    if segments.len() > 1 {\n+                        imports_reused_with_self.push(segments[1].ident.name);\n+                        return;\n+                    }\n+\n+                    // nested case such as `use self::{module1::Struct1, module2::Struct2}`\n+                    if let UseTreeKind::Nested(trees) = &use_tree.kind {\n+                        for tree in trees {\n+                            let segments = &tree.0.prefix.segments;\n+                            if !segments.is_empty() {\n+                                imports_reused_with_self.push(segments[0].ident.name);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "cd2bdec1707b31d2f75647a0e0e4cd35f098d105", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -65,8 +65,8 @@ fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, inverted: bool)\n \n fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n     const FUNCTIONS: [&[&str]; 8] = [\n-        &paths::COPY_NONOVERLAPPING,\n-        &paths::COPY,\n+        &paths::PTR_COPY_NONOVERLAPPING,\n+        &paths::PTR_COPY,\n         &paths::WRITE_BYTES,\n         &paths::PTR_SWAP_NONOVERLAPPING,\n         &paths::PTR_SLICE_FROM_RAW_PARTS,"}, {"sha": "191781be000cf8177919236a38389dafac24c3df", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_enclosing_block, match_qpath, SpanlessEq};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_enclosing_block, is_expr_path_def_path, path_to_local, path_to_local_id, paths, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -9,7 +10,7 @@ use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath,\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks slow zero-filled vector initialization\n@@ -46,8 +47,8 @@ declare_lint_pass!(SlowVectorInit => [SLOW_VECTOR_INITIALIZATION]);\n /// assigned to a variable. For example, `let mut vec = Vec::with_capacity(0)` or\n /// `vec = Vec::with_capacity(0)`\n struct VecAllocation<'tcx> {\n-    /// Symbol of the local variable name\n-    variable_name: Symbol,\n+    /// HirId of the variable\n+    local_id: HirId,\n \n     /// Reference to the expression which allocates the vector\n     allocation_expr: &'tcx Expr<'tcx>,\n@@ -72,16 +73,15 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         if_chain! {\n             if let ExprKind::Assign(left, right, _) = expr.kind;\n \n-            // Extract variable name\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n-            if let Some(variable_name) = path.segments.get(0);\n+            // Extract variable\n+            if let Some(local_id) = path_to_local(left);\n \n             // Extract len argument\n-            if let Some(len_arg) = Self::is_vec_with_capacity(right);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(cx, right);\n \n             then {\n                 let vi = VecAllocation {\n-                    variable_name: variable_name.ident.name,\n+                    local_id,\n                     allocation_expr: right,\n                     len_expr: len_arg,\n                 };\n@@ -95,13 +95,13 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, local_id, _, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if let Some(len_arg) = Self::is_vec_with_capacity(init);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(cx, init);\n \n             then {\n                 let vi = VecAllocation {\n-                    variable_name: variable_name.name,\n+                    local_id,\n                     allocation_expr: init,\n                     len_expr: len_arg,\n                 };\n@@ -115,19 +115,18 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n impl SlowVectorInit {\n     /// Checks if the given expression is `Vec::with_capacity(..)`. It will return the expression\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n-    fn is_vec_with_capacity<'tcx>(expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_vec_with_capacity<'tcx>(cx: &LateContext<'_>, expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         if_chain! {\n-            if let ExprKind::Call(func, args) = expr.kind;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n-            if args.len() == 1;\n-\n+            if let ExprKind::Call(func, [arg]) = expr.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, name)) = func.kind;\n+            if name.ident.as_str() == \"with_capacity\";\n+            if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::vec_type);\n             then {\n-                return Some(&args[0]);\n+                Some(arg)\n+            } else {\n+                None\n             }\n         }\n-\n-        None\n     }\n \n     /// Search initialization for the given vector\n@@ -208,11 +207,9 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if let ExprKind::MethodCall(path, _, [self_arg, extend_arg], _) = expr.kind;\n+            if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n-            if let Some(extend_arg) = args.get(1);\n             if self.is_repeat_take(extend_arg);\n \n             then {\n@@ -225,11 +222,9 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if let ExprKind::MethodCall(path, _, [self_arg, len_arg, fill_arg], _) = expr.kind;\n+            if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(resize);\n-            if let (Some(len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n             if let ExprKind::Lit(ref lit) = fill_arg.kind;\n@@ -252,7 +247,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n \n             // Check that take is applied to `repeat(0)`\n             if let Some(repeat_expr) = take_args.get(0);\n-            if Self::is_repeat_zero(repeat_expr);\n+            if self.is_repeat_zero(repeat_expr);\n \n             // Check that len expression is equals to `with_capacity` expression\n             if let Some(len_arg) = take_args.get(1);\n@@ -267,21 +262,19 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Returns `true` if given expression is `repeat(0)`\n-    fn is_repeat_zero(expr: &Expr<'_>) -> bool {\n+    fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::Call(fn_expr, repeat_args) = expr.kind;\n-            if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n-            if match_qpath(qpath_repeat, &[\"repeat\"]);\n-            if let Some(repeat_arg) = repeat_args.get(0);\n+            if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n+            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n             if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n             then {\n-                return true\n+                true\n+            } else {\n+                false\n             }\n         }\n-\n-        false\n     }\n }\n "}, {"sha": "4272935bc310e93bfd13bf2dec59c6e6d5ef6559", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -195,7 +195,7 @@ fn attempt_to_emit_no_difference_lint(\n     i: usize,\n     expected_loc: IdentLocation,\n ) {\n-    if let Some(binop) = binops.get(i).cloned() {\n+    if let Some(binop) = binops.get(i).copied() {\n         // We need to try and figure out which identifier we should\n         // suggest using instead. Since there could be multiple\n         // replacement candidates in a given expression, and we're"}, {"sha": "e2c144709f5b78b5420eca8a8828186d8fa57b2a", "filename": "clippy_lints/src/tabs_in_doc_comments.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -104,30 +104,32 @@ fn get_chunks_of_tabs(the_str: &str) -> Vec<(u32, u32)> {\n     // tracker to decide if the last group of tabs is not closed by a non-tab character\n     let mut is_active = false;\n \n-    let chars_array: Vec<_> = the_str.chars().collect();\n+    // Note that we specifically need the char _byte_ indices here, not the positional indexes\n+    // within the char array to deal with multi-byte characters properly. `char_indices` does\n+    // exactly that. It provides an iterator over tuples of the form `(byte position, char)`.\n+    let char_indices: Vec<_> = the_str.char_indices().collect();\n \n-    if chars_array == vec!['\\t'] {\n+    if let [(_, '\\t')] = char_indices.as_slice() {\n         return vec![(0, 1)];\n     }\n \n-    for (index, arr) in chars_array.windows(2).enumerate() {\n-        let index = u32::try_from(index).expect(line_length_way_to_long);\n-        match arr {\n-            ['\\t', '\\t'] => {\n+    for entry in char_indices.windows(2) {\n+        match entry {\n+            [(_, '\\t'), (_, '\\t')] => {\n                 // either string starts with double tab, then we have to set it active,\n                 // otherwise is_active is true anyway\n                 is_active = true;\n             },\n-            [_, '\\t'] => {\n+            [(_, _), (index_b, '\\t')] => {\n                 // as ['\\t', '\\t'] is excluded, this has to be a start of a tab group,\n                 // set indices accordingly\n                 is_active = true;\n-                current_start = index + 1;\n+                current_start = u32::try_from(*index_b).unwrap();\n             },\n-            ['\\t', _] => {\n+            [(_, '\\t'), (index_b, _)] => {\n                 // this now has to be an end of the group, hence we have to push a new tuple\n                 is_active = false;\n-                spans.push((current_start, index + 1));\n+                spans.push((current_start, u32::try_from(*index_b).unwrap()));\n             },\n             _ => {},\n         }\n@@ -137,7 +139,7 @@ fn get_chunks_of_tabs(the_str: &str) -> Vec<(u32, u32)> {\n     if is_active {\n         spans.push((\n             current_start,\n-            u32::try_from(the_str.chars().count()).expect(line_length_way_to_long),\n+            u32::try_from(char_indices.last().unwrap().0 + 1).expect(line_length_way_to_long),\n         ));\n     }\n \n@@ -148,6 +150,13 @@ fn get_chunks_of_tabs(the_str: &str) -> Vec<(u32, u32)> {\n mod tests_for_get_chunks_of_tabs {\n     use super::get_chunks_of_tabs;\n \n+    #[test]\n+    fn test_unicode_han_string() {\n+        let res = get_chunks_of_tabs(\" \\u{4f4d}\\t\");\n+\n+        assert_eq!(res, vec![(4, 5)]);\n+    }\n+\n     #[test]\n     fn test_empty_string() {\n         let res = get_chunks_of_tabs(\"\");"}, {"sha": "4fb297ac6c6990771cc9ef935f76b2225901ed60", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_diagnostic_assoc_item, match_def_path, path_to_local_id, paths};\n+use clippy_utils::{is_diag_trait_item, match_def_path, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -95,7 +95,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n             if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString);\n+            if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n             if path_to_local_id(&args[0], self_hir_id);\n             then {\n                 span_lint("}, {"sha": "569113910c98226cb75acfda62fdd78c83c2c6a2", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -274,7 +274,7 @@ declare_clippy_lint! {\n     /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n     /// ```\n     pub TRANSMUTE_PTR_TO_PTR,\n-    complexity,\n+    pedantic,\n     \"transmutes from a pointer to a pointer / a reference to a reference\"\n }\n "}, {"sha": "888ecab10461ac936317191e6fa41927e655c504", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use crate::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_qpath, paths};\n+use clippy_utils::{is_expr_path_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n@@ -37,18 +37,15 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(func, args) = expr.kind;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if match_qpath(path, &paths::STD_MEM_TRANSMUTE);\n-            if args.len() == 1;\n+            if let ExprKind::Call(func, [arg]) = expr.kind;\n+            if is_expr_path_def_path(cx, func, &paths::TRANSMUTE);\n \n             then {\n-\n                 // Catching transmute over constants that resolve to `null`.\n                 let mut const_eval_context = constant_context(cx, cx.typeck_results());\n                 if_chain! {\n-                    if let ExprKind::Path(ref _qpath) = args[0].kind;\n-                    let x = const_eval_context.expr(&args[0]);\n+                    if let ExprKind::Path(ref _qpath) = arg.kind;\n+                    let x = const_eval_context.expr(arg);\n                     if let Some(Constant::RawPtr(0)) = x;\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n@@ -58,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(0 as *const i32)`\n                 if_chain! {\n-                    if let ExprKind::Cast(inner_expr, _cast_ty) = args[0].kind;\n+                    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n                     if let ExprKind::Lit(ref lit) = inner_expr.kind;\n                     if let LitKind::Int(0, _) = lit.node;\n                     then {\n@@ -69,10 +66,8 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(std::ptr::null::<i32>())`\n                 if_chain! {\n-                    if let ExprKind::Call(func1, args1) = args[0].kind;\n-                    if let ExprKind::Path(ref path1) = func1.kind;\n-                    if match_qpath(path1, &paths::STD_PTR_NULL);\n-                    if args1.is_empty();\n+                    if let ExprKind::Call(func1, []) = arg.kind;\n+                    if is_expr_path_def_path(cx, func1, &paths::PTR_NULL);\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n                     }"}, {"sha": "ebb39ea4877dee0268807ccca366b5ae5e9c974d", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, in_macro, match_def_path, match_qpath, paths};\n+use clippy_utils::{differing_macro_contexts, get_parent_expr, in_macro, is_lang_ctor, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::ResultErr;\n use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n             if let Some(err_arg) = err_args.get(0);\n             if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-            if match_qpath(err_fun_path, &paths::RESULT_ERR);\n+            if is_lang_ctor(cx, err_fun_path, ResultErr);\n             if let Some(return_ty) = find_return_type(cx, &expr.kind);\n             then {\n                 let prefix;\n@@ -101,10 +102,15 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n                 } else {\n                     snippet(cx, err_arg.span, \"_\")\n                 };\n+                let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n+                    \"\" // already returns\n+                } else {\n+                    \"return \"\n+                };\n                 let suggestion = if err_ty == expr_err_ty {\n-                    format!(\"return {}{}{}\", prefix, origin_snippet, suffix)\n+                    format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n                 } else {\n-                    format!(\"return {}{}.into(){}\", prefix, origin_snippet, suffix)\n+                    format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n                 };\n \n                 span_lint_and_sugg("}, {"sha": "bdeff035e5ec99ab30dd2e68a90c06a2eb4033a7", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{match_path, paths};\n+use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n                     _ => None,\n                 });\n                 then {\n-                    if is_any_trait(inner) {\n+                    if is_any_trait(cx, inner) {\n                         // Ignore `Box<Any>` types; see issue #1884 for details.\n                         return false;\n                     }\n@@ -84,13 +84,14 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n }\n \n // Returns true if given type is `Any` trait.\n-fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n+fn is_any_trait(cx: &LateContext<'_>, t: &hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let TyKind::TraitObject(traits, ..) = t.kind;\n         if !traits.is_empty();\n+        if let Some(trait_did) = traits[0].trait_ref.trait_def_id();\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_path(traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        if match_def_path(cx, trait_did, &paths::ANY_TRAIT);\n         then {\n             return true;\n         }"}, {"sha": "48c54d79cf11347c7b06bafb5cf5e1269c0347d8", "filename": "clippy_lints/src/unnecessary_self_imports.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_self_imports.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,67 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use if_chain::if_chain;\n+use rustc_ast::{Item, ItemKind, UseTreeKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for imports ending in `::{self}`.\n+    ///\n+    /// **Why is this bad?** In most cases, this can be written much more cleanly by omitting `::{self}`.\n+    ///\n+    /// **Known problems:** Removing `::{self}` will cause any non-module items at the same path to also be imported.\n+    /// This might cause a naming conflict (https://github.com/rust-lang/rustfmt/issues/3568). This lint makes no attempt\n+    /// to detect this scenario and that is why it is a restriction lint.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::io::{self};\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::io;\n+    /// ```\n+    pub UNNECESSARY_SELF_IMPORTS,\n+    restriction,\n+    \"imports ending in `::{self}`, which can be omitted\"\n+}\n+\n+declare_lint_pass!(UnnecessarySelfImports => [UNNECESSARY_SELF_IMPORTS]);\n+\n+impl EarlyLintPass for UnnecessarySelfImports {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if_chain! {\n+            if let ItemKind::Use(use_tree) = &item.kind;\n+            if let UseTreeKind::Nested(nodes) = &use_tree.kind;\n+            if let [(self_tree, _)] = &**nodes;\n+            if let [self_seg] = &*self_tree.prefix.segments;\n+            if self_seg.ident.name == kw::SelfLower;\n+            if let Some(last_segment) = use_tree.prefix.segments.last();\n+\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    UNNECESSARY_SELF_IMPORTS,\n+                    item.span,\n+                    \"import ending with `::{self}`\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            last_segment.span().with_hi(item.span.hi()),\n+                            \"consider omitting `::{self}`\",\n+                            format!(\n+                                \"{}{};\",\n+                                last_segment.ident,\n+                                if let UseTreeKind::Simple(Some(alias), ..) = self_tree.kind { format!(\" as {}\", alias) } else { String::new() },\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.note(\"this will slightly change semantics; any non-module items at the same path will also be imported\");\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "f2f1410aed7421343bd812172c02f40d25167ca4", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, in_macro, match_qpath, paths, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, in_macro, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -85,11 +86,11 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         }\n \n         // Get the wrapper and inner types, if can't, abort.\n-        let (return_type_label, path, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n+        let (return_type_label, lang_item, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n             if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did) {\n-                (\"Option\", &paths::OPTION_SOME, subst.type_at(0))\n+                (\"Option\", OptionSome, subst.type_at(0))\n             } else if cx.tcx.is_diagnostic_item(sym::result_type, adt_def.did) {\n-                (\"Result\", &paths::RESULT_OK, subst.type_at(0))\n+                (\"Result\", ResultOk, subst.type_at(0))\n             } else {\n                 return;\n             }\n@@ -103,22 +104,20 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 // Check if a function call.\n-                if let ExprKind::Call(func, args) = ret_expr.kind;\n-                // Get the Path of the function call.\n-                if let ExprKind::Path(ref qpath) = func.kind;\n+                if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if match_qpath(qpath, path);\n-                if args.len() == 1;\n+                if let ExprKind::Path(qpath) = &func.kind;\n+                if is_lang_ctor(cx, qpath, lang_item);\n                 // Make sure the function argument does not contain a return expression.\n-                if !contains_return(&args[0]);\n+                if !contains_return(arg);\n                 then {\n                     suggs.push(\n                         (\n                             ret_expr.span,\n                             if inner_type.is_unit() {\n                                 \"\".to_string()\n                             } else {\n-                                snippet(cx, args[0].span.source_callsite(), \"..\").to_string()\n+                                snippet(cx, arg.span.source_callsite(), \"..\").to_string()\n                             }\n                         )\n                     );"}, {"sha": "5e8e530f480fb439871a99399e7ef4123657311d", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n         };\n \n         match expr.kind {\n-            hir::ExprKind::Match(res, _, _) if is_try(expr).is_some() => {\n+            hir::ExprKind::Match(res, _, _) if is_try(cx, expr).is_some() => {\n                 if let hir::ExprKind::Call(func, args) = res.kind {\n                     if matches!(\n                         func.kind,"}, {"sha": "3d3d0e19d26224190bdd8e0546ae7e31599fb9bf", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -3,7 +3,8 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sug\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq,\n+    is_else_clause, is_expn_of, is_expr_path_def_path, match_def_path, method_calls, path_to_res, paths, run_lints,\n+    SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n@@ -578,8 +579,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n \n         if_chain! {\n             if let ExprKind::Call(func, and_then_args) = expr.kind;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if match_qpath(path, &[\"span_lint_and_then\"]);\n+            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n@@ -761,8 +761,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n         if_chain! {\n             // Check if this is a call to utils::match_type()\n             if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n-            if match_qpath(fn_qpath, &[\"utils\", \"match_type\"]);\n+            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n@@ -771,16 +770,17 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n             if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n             then {\n+                // TODO: check paths constants from external crates.\n                 let cx_snippet = snippet(cx, context.span, \"_\");\n                 let ty_snippet = snippet(cx, ty.span, \"_\");\n \n                 span_lint_and_sugg(\n                     cx,\n                     MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n                     expr.span,\n-                    \"usage of `utils::match_type()` on a type diagnostic item\",\n+                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n                     \"try\",\n-                    format!(\"utils::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n+                    format!(\"clippy_utils::ty::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "7e962472c07f5b4c994027c5303262dbb7c4470b", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -573,7 +573,7 @@ impl Write {\n                         diag.multipart_suggestion(\n                             \"try this\",\n                             iter::once((comma_span.to(token_expr.span), String::new()))\n-                                .chain(fmt_spans.iter().cloned().zip(iter::repeat(replacement)))\n+                                .chain(fmt_spans.iter().copied().zip(iter::repeat(replacement)))\n                                 .collect(),\n                             Applicability::MachineApplicable,\n                         );"}, {"sha": "93e10c836cc7ffbb785f963694246c26f24313fe", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -5,6 +5,7 @@\n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n use crate::{both, over};\n+use if_chain::if_chain;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n@@ -571,3 +572,34 @@ pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n         _ => false,\n     }\n }\n+\n+/// Extract args from an assert-like macro.\n+///\n+/// Currently working with:\n+/// - `assert_eq!` and `assert_ne!`\n+/// - `debug_assert_eq!` and `debug_assert_ne!`\n+///\n+/// For example:\n+///\n+/// `debug_assert_eq!(a, b)` will return Some([a, b])\n+pub fn extract_assert_macro_args(mut expr: &Expr) -> Option<[&Expr; 2]> {\n+    if_chain! {\n+        if let ExprKind::If(_, ref block, _) = expr.kind;\n+        if let StmtKind::Semi(ref e) = block.stmts.get(0)?.kind;\n+        then {\n+            expr = e;\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::Block(ref block, _) = expr.kind;\n+        if let StmtKind::Expr(ref expr) = block.stmts.get(0)?.kind;\n+        if let ExprKind::Match(ref match_expr, _) = expr.kind;\n+        if let ExprKind::Tup(ref tup) = match_expr.kind;\n+        if let [a, b, ..] = tup.as_slice();\n+        if let (&ExprKind::AddrOf(_, _, ref a), &ExprKind::AddrOf(_, _, ref b)) = (&a.kind, &b.kind);\n+        then {\n+            return Some([&*a, &*b]);\n+        }\n+    }\n+    None\n+}"}, {"sha": "c0584e1e2269410bd0387197965995ed5f4cd754", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -151,10 +151,9 @@ pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n \n /// Return true if the attributes contain `#[doc(hidden)]`\n pub fn is_doc_hidden(attrs: &[ast::Attribute]) -> bool {\n-    #[allow(clippy::filter_map)]\n     attrs\n         .iter()\n         .filter(|attr| attr.has_name(sym::doc))\n-        .flat_map(ast::Attribute::meta_item_list)\n+        .filter_map(ast::Attribute::meta_item_list)\n         .any(|l| attr::list_contains_name(&l, sym::hidden))\n }"}, {"sha": "07ae6e924e28b7daee63fe73710532859c40b5e5", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -96,6 +96,16 @@ impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n+                // This additional check ensures that the type of the locals are equivalent even if the init\n+                // expression or type have some inferred parts.\n+                if let Some(typeck) = self.inner.maybe_typeck_results {\n+                    let l_ty = typeck.pat_ty(&l.pat);\n+                    let r_ty = typeck.pat_ty(&r.pat);\n+                    if !rustc_middle::ty::TyS::same_type(l_ty, r_ty) {\n+                        return false;\n+                    }\n+                }\n+\n                 // eq_pat adds the HirIds to the locals map. We therefor call it last to make sure that\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n@@ -424,7 +434,7 @@ fn reduce_exprkind<'hir>(cx: &LateContext<'_>, kind: &'hir ExprKind<'hir>) -> &'\n                                 TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n                             )\n                         })\n-                        .ne([TokenKind::OpenBrace, TokenKind::CloseBrace].iter().cloned()) =>\n+                        .ne([TokenKind::OpenBrace, TokenKind::CloseBrace].iter().copied()) =>\n                 {\n                     kind\n                 },"}, {"sha": "9564432ee48e1e523a5a2754cd71e02bdfacac89", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 245, "deletions": 113, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -10,6 +10,7 @@\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n+extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n@@ -57,13 +58,14 @@ use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n-    TraitItem, TraitItemKind, TraitRef, TyKind,\n+    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n+    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment,\n+    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -80,7 +82,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::is_recursively_primitive_type;\n+use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -222,6 +224,19 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     }\n }\n \n+/// Checks if a `QPath` resolves to a constructor of a `LangItem`.\n+/// For example, use this to check whether a function call or a pattern is `Some(..)`.\n+pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem) -> bool {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n+            if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n+                return cx.tcx.parent(ctor_id) == Some(item_id);\n+            }\n+        }\n+    }\n+    false\n+}\n+\n /// Returns `true` if this `span` was expanded by any macro.\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n@@ -279,27 +294,29 @@ pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str])\n     trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n \n-/// Checks if the method call given in `def_id` belongs to a trait or other container with a given\n-/// diagnostic item\n-pub fn is_diagnostic_assoc_item(cx: &LateContext<'_>, def_id: DefId, diag_item: Symbol) -> bool {\n-    cx.tcx\n-        .opt_associated_item(def_id)\n-        .and_then(|associated_item| match associated_item.container {\n-            rustc_ty::TraitContainer(assoc_def_id) => Some(assoc_def_id),\n-            rustc_ty::ImplContainer(assoc_def_id) => match cx.tcx.type_of(assoc_def_id).kind() {\n-                rustc_ty::Adt(adt, _) => Some(adt.did),\n-                rustc_ty::Slice(_) => cx.tcx.get_diagnostic_item(sym::slice), // this isn't perfect but it works\n-                _ => None,\n-            },\n-        })\n-        .map_or(false, |assoc_def_id| cx.tcx.is_diagnostic_item(diag_item, assoc_def_id))\n+/// Checks if a method is defined in an impl of a diagnostic item\n+pub fn is_diag_item_method(cx: &LateContext<'_>, def_id: DefId, diag_item: Symbol) -> bool {\n+    if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n+        if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n+            return cx.tcx.is_diagnostic_item(diag_item, adt.did);\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks if a method is in a diagnostic item trait\n+pub fn is_diag_trait_item(cx: &LateContext<'_>, def_id: DefId, diag_item: Symbol) -> bool {\n+    if let Some(trait_did) = cx.tcx.trait_of_item(def_id) {\n+        return cx.tcx.is_diagnostic_item(diag_item, trait_did);\n+    }\n+    false\n }\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n     cx.typeck_results()\n         .type_dependent_def_id(expr.hir_id)\n-        .map_or(false, |did| is_diagnostic_assoc_item(cx, did, diag_item))\n+        .map_or(false, |did| is_diag_trait_item(cx, did, diag_item))\n }\n \n /// Checks if an expression references a variable of the given name.\n@@ -380,6 +397,29 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     }\n }\n \n+/// If the expression is a path, resolve it. Otherwise, return `Res::Err`.\n+pub fn expr_path_res(cx: &LateContext<'_>, expr: &Expr<'_>) -> Res {\n+    if let ExprKind::Path(p) = &expr.kind {\n+        cx.qpath_res(p, expr.hir_id)\n+    } else {\n+        Res::Err\n+    }\n+}\n+\n+/// Resolves the path to a `DefId` and checks if it matches the given path.\n+pub fn is_qpath_def_path(cx: &LateContext<'_>, path: &QPath<'_>, hir_id: HirId, segments: &[&str]) -> bool {\n+    cx.qpath_res(path, hir_id)\n+        .opt_def_id()\n+        .map_or(false, |id| match_def_path(cx, id, segments))\n+}\n+\n+/// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n+pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n+    expr_path_res(cx, expr)\n+        .opt_def_id()\n+        .map_or(false, |id| match_def_path(cx, id, segments))\n+}\n+\n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n /// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n /// `QPath::Resolved.1.res.opt_def_id()`.\n@@ -408,20 +448,6 @@ pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name.as_str() == *b)\n }\n \n-/// Matches a `Path` against a slice of segment string literals, e.g.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n /// If the expression is a path to a local, returns the canonical `HirId` of the local.\n pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n@@ -522,6 +548,73 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// Checks if the top level expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n+        | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n+            if jump_targets.contains(&id) =>\n+        {\n+            true\n+        },\n+        ExprKind::Break(..)\n+        | ExprKind::Continue(_)\n+        | ExprKind::Ret(_)\n+        | ExprKind::Yield(..)\n+        | ExprKind::InlineAsm(_)\n+        | ExprKind::LlvmInlineAsm(_) => false,\n+        // Accessing a field of a local value can only be done if the type isn't\n+        // partially moved.\n+        ExprKind::Field(base_expr, _)\n+            if matches!(\n+                base_expr.kind,\n+                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n+            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n+        {\n+            // TODO: check if the local has been partially moved. Assume it has for now.\n+            false\n+        }\n+        _ => true,\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        loops: Vec<HirId>,\n+        allow_closure: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if !self.allow_closure {\n+                return;\n+            }\n+            if let ExprKind::Loop(b, ..) = e.kind {\n+                self.loops.push(e.hir_id);\n+                self.visit_block(b);\n+                self.loops.pop();\n+            } else {\n+                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        cx,\n+        allow_closure: true,\n+        loops: Vec::new(),\n+    };\n+    v.visit_expr(expr);\n+    v.allow_closure\n+}\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls<'tcx>(\n@@ -960,7 +1053,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// the function once on the given pattern.\n pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>, mut f: F) {\n     if let PatKind::Or(pats) = pat.kind {\n-        pats.iter().cloned().for_each(f)\n+        pats.iter().copied().for_each(f)\n     } else {\n         f(pat)\n     }\n@@ -1011,11 +1104,11 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl It\n \n /// Checks if a given expression is a match expression expanded from the `?`\n /// operator or the `try` macro.\n-pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    fn is_ok(arm: &Arm<'_>) -> bool {\n+pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_ok(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n-            if match_qpath(path, &paths::RESULT_OK[1..]);\n+            if is_lang_ctor(cx, path, ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n             then {\n@@ -1025,9 +1118,9 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         false\n     }\n \n-    fn is_err(arm: &Arm<'_>) -> bool {\n+    fn is_err(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            match_qpath(path, &paths::RESULT_ERR[1..])\n+            is_lang_ctor(cx, path, ResultErr)\n         } else {\n             false\n         }\n@@ -1043,8 +1136,8 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n             if arms.len() == 2;\n             if arms[0].guard.is_none();\n             if arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            if (is_ok(cx, &arms[0]) && is_err(cx, &arms[1])) ||\n+                (is_ok(cx, &arms[1]) && is_err(cx, &arms[0]));\n             then {\n                 return Some(expr);\n             }\n@@ -1131,29 +1224,47 @@ pub fn match_function_call<'tcx>(\n     None\n }\n \n+/// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n+/// any.\n+pub fn match_any_def_paths(cx: &LateContext<'_>, did: DefId, paths: &[&[&str]]) -> Option<usize> {\n+    let search_path = cx.get_def_path(did);\n+    paths\n+        .iter()\n+        .position(|p| p.iter().map(|x| Symbol::intern(x)).eq(search_path.iter().copied()))\n+}\n+\n+/// Checks if the given `DefId` matches the path.\n pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n-    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n-    // accepts only that. We should probably move to Symbols in Clippy as well.\n-    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n-    cx.match_def_path(did, &syms)\n+    // We should probably move to Symbols in Clippy as well rather than interning every time.\n+    let path = cx.get_def_path(did);\n+    syms.iter().map(|x| Symbol::intern(x)).eq(path.iter().copied())\n }\n \n-pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n-    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n-        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n+pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Call(func, [arg]) = expr.kind {\n+        expr_path_res(cx, func)\n+            .opt_def_id()\n+            .map_or(false, |id| match_panic_def_id(cx, id))\n+            .then(|| arg)\n+    } else {\n+        None\n+    }\n }\n \n pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_def_path(cx, did, &paths::BEGIN_PANIC)\n-        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANIC_ANY)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n+    match_any_def_paths(\n+        cx,\n+        did,\n+        &[\n+            &paths::BEGIN_PANIC,\n+            &paths::BEGIN_PANIC_FMT,\n+            &paths::PANIC_ANY,\n+            &paths::PANICKING_PANIC,\n+            &paths::PANICKING_PANIC_FMT,\n+            &paths::PANICKING_PANIC_STR,\n+        ],\n+    )\n+    .is_some()\n }\n \n /// Returns the list of condition expressions and the list of blocks in a\n@@ -1189,21 +1300,6 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     (conds, blocks)\n }\n \n-/// This function returns true if the given expression is the `else` or `if else` part of an if\n-/// statement\n-pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    let parent_id = map.get_parent_node(expr.hir_id);\n-    let parent_node = map.get(parent_id);\n-    matches!(\n-        parent_node,\n-        Node::Expr(Expr {\n-            kind: ExprKind::If(_, _, _),\n-            ..\n-        })\n-    )\n-}\n-\n // Finds the `#[must_use]` attribute, if any\n pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n     attrs.iter().find(|a| a.has_name(sym::must_use))\n@@ -1228,6 +1324,51 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n+/// Gets the node where an expression is either used, or it's type is unified with another branch.\n+pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+    let map = tcx.hir();\n+    let mut child_id = expr.hir_id;\n+    let mut iter = map.parent_iter(child_id);\n+    loop {\n+        match iter.next() {\n+            None => break None,\n+            Some((id, Node::Block(_))) => child_id = id,\n+            Some((id, Node::Arm(arm))) if arm.body.hir_id == child_id => child_id = id,\n+            Some((_, Node::Expr(expr))) => match expr.kind {\n+                ExprKind::Match(_, [arm], _) if arm.hir_id == child_id => child_id = expr.hir_id,\n+                ExprKind::Block(..) | ExprKind::DropTemps(_) => child_id = expr.hir_id,\n+                ExprKind::If(_, then_expr, None) if then_expr.hir_id == child_id => break None,\n+                _ => break Some(Node::Expr(expr)),\n+            },\n+            Some((_, node)) => break Some(node),\n+        }\n+    }\n+}\n+\n+/// Checks if the result of an expression is used, or it's type is unified with another branch.\n+pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    !matches!(\n+        get_expr_use_or_unification_node(tcx, expr),\n+        None | Some(Node::Stmt(Stmt {\n+            kind: StmtKind::Expr(_)\n+                | StmtKind::Semi(_)\n+                | StmtKind::Local(Local {\n+                    pat: Pat {\n+                        kind: PatKind::Wild,\n+                        ..\n+                    },\n+                    ..\n+                }),\n+            ..\n+        }))\n+    )\n+}\n+\n+/// Checks if the expression is the final expression returned from a block.\n+pub fn is_expr_final_block_expr(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(get_parent_node(tcx, expr.hir_id), Some(Node::Block(..)))\n+}\n+\n pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n     cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n@@ -1397,28 +1538,43 @@ pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n     peel(pat, 0)\n }\n \n+/// Peels of expressions while the given closure returns `Some`.\n+pub fn peel_hir_expr_while<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(&'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>>,\n+) -> &'tcx Expr<'tcx> {\n+    while let Some(e) = f(expr) {\n+        expr = e;\n+    }\n+    expr\n+}\n+\n /// Peels off up to the given number of references on the expression. Returns the underlying\n /// expression and the number of references removed.\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0, count)\n+    let mut remaining = count;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+            remaining -= 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count - remaining)\n }\n \n /// Peels off all references on the expression. Returns the underlying expression and the number of\n /// references removed.\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0)\n+    let mut count = 0;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+            count += 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count)\n }\n \n #[macro_export]\n@@ -1450,27 +1606,3 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n         }\n     }\n }\n-\n-/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n-pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-/// Check if the resolution of a given path is a `Some` variant of `Option`.\n-pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}"}, {"sha": "5e6733a300f2ca49cae21a62b5deeddc472685a2", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -4,7 +4,7 @@\n //! Whenever possible, please consider diagnostic items over hardcoded paths.\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n-pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n+pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n@@ -13,13 +13,13 @@ pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n+pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n-pub const COPY: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy_nonoverlapping\"];\n-pub const COPY_NONOVERLAPPING: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n@@ -44,10 +44,14 @@ pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n+pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n+pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n #[cfg(feature = \"internal-lints\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n@@ -60,8 +64,9 @@ pub const INTO: [&str; 3] = [\"core\", \"convert\", \"Into\"];\n pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n-pub const IPADDR_V4: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V4\"];\n-pub const IPADDR_V6: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V6\"];\n+pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n+pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n+pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n@@ -100,12 +105,23 @@ pub const PERMISSIONS_FROM_MODE: [&str; 7] = [\"std\", \"sys\", \"unix\", \"ext\", \"fs\",\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n+pub const PTR_COPY: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy\"];\n+pub const PTR_COPY_NONOVERLAPPING: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 3] = [\"core\", \"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 3] = [\"core\", \"ptr\", \"null_mut\"];\n pub const PTR_SLICE_FROM_RAW_PARTS: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts\"];\n pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts_mut\"];\n pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n+pub const PTR_READ: [&str; 3] = [\"core\", \"ptr\", \"read\"];\n+pub const PTR_READ_UNALIGNED: [&str; 3] = [\"core\", \"ptr\", \"read_unaligned\"];\n+pub const PTR_READ_VOLATILE: [&str; 3] = [\"core\", \"ptr\", \"read_volatile\"];\n+pub const PTR_REPLACE: [&str; 3] = [\"core\", \"ptr\", \"replace\"];\n+pub const PTR_SWAP: [&str; 3] = [\"core\", \"ptr\", \"swap\"];\n+pub const PTR_WRITE: [&str; 3] = [\"core\", \"ptr\", \"write\"];\n+pub const PTR_WRITE_BYTES: [&str; 3] = [\"core\", \"intrinsics\", \"write_bytes\"];\n+pub const PTR_WRITE_UNALIGNED: [&str; 3] = [\"core\", \"ptr\", \"write_unaligned\"];\n+pub const PTR_WRITE_VOLATILE: [&str; 3] = [\"core\", \"ptr\", \"write_volatile\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n@@ -117,7 +133,6 @@ pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n-pub const REPEAT: [&str; 3] = [\"core\", \"iter\", \"repeat\"];\n pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n@@ -131,10 +146,8 @@ pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n-pub const STD_CONVERT_IDENTITY: [&str; 3] = [\"std\", \"convert\", \"identity\"];\n+pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n-pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n-pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];"}, {"sha": "b2ce58b597b3d901a160645b34d04342459f11f3", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,3 +1,8 @@\n+// This code used to be a part of `rustc` but moved to Clippy as a result of\n+// https://github.com/rust-lang/rust/issues/76618. Because of that, it contains unused code and some\n+// of terminologies might not be relevant in the context of Clippy. Note that its behavior might\n+// differ from the time of `rustc` even if the name stays the same.\n+\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n@@ -6,14 +11,15 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n+use rustc_semver::RustcVersion;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>) -> McfResult {\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&RustcVersion>) -> McfResult {\n     let def_id = body.source.def_id();\n     let mut current = def_id;\n     loop {\n@@ -70,7 +76,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>) -> McfResult {\n     )?;\n \n     for bb in body.basic_blocks() {\n-        check_terminator(tcx, body, bb.terminator())?;\n+        check_terminator(tcx, body, bb.terminator(), msrv)?;\n         for stmt in &bb.statements {\n             check_statement(tcx, body, def_id, stmt)?;\n         }\n@@ -268,7 +274,12 @@ fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'t\n     Ok(())\n }\n \n-fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Terminator<'tcx>) -> McfResult {\n+fn check_terminator(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+    terminator: &Terminator<'tcx>,\n+    msrv: Option<&RustcVersion>,\n+) -> McfResult {\n     let span = terminator.source_info.span;\n     match &terminator.kind {\n         TerminatorKind::FalseEdge { .. }\n@@ -305,7 +316,7 @@ fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Termin\n         } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n-                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id) {\n+                if !is_const_fn(tcx, fn_def_id, msrv) {\n                     return Err((\n                         span,\n                         format!(\n@@ -350,3 +361,24 @@ fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Termin\n         TerminatorKind::InlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n     }\n }\n+\n+fn is_const_fn(tcx: TyCtxt<'_>, def_id: DefId, msrv: Option<&RustcVersion>) -> bool {\n+    rustc_mir::const_eval::is_const_fn(tcx, def_id)\n+        && if let Some(const_stab) = tcx.lookup_const_stability(def_id) {\n+            if let rustc_attr::StabilityLevel::Stable { since } = const_stab.level {\n+                // Checking MSRV is manually necessary because `rustc` has no such concept. This entire\n+                // function could be removed if `rustc` provided a MSRV-aware version of `is_const_fn`.\n+                // as a part of an unimplemented MSRV check https://github.com/rust-lang/rust/issues/65262.\n+                crate::meets_msrv(\n+                    msrv,\n+                    &RustcVersion::parse(&since.as_str())\n+                        .expect(\"`rustc_attr::StabilityLevel::Stable::since` is ill-formatted\"),\n+                )\n+            } else {\n+                // `rustc_mir::const_eval::is_const_fn` should return false for unstably const functions.\n+                unreachable!();\n+            }\n+        } else {\n+            true\n+        }\n+}"}, {"sha": "53180d1f9f54f699014b50c35f0d1e1eff33b9cc", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -66,6 +66,15 @@ pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n     snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n+/// Gets a snippet of the indentation of the line of a span\n+pub fn snippet_indent<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+    snippet_opt(cx, line_span(cx, span)).map(|mut s| {\n+        let len = s.len() - s.trim_start().len();\n+        s.truncate(len);\n+        s\n+    })\n+}\n+\n // If the snippet is empty, it's an attribute that was inserted during macro\n // expansion and we want to ignore those, because they could come from external\n // sources that the user has no control over."}, {"sha": "64a80f2554fa4c0e413cd2c51be74fe3f20f6cb6", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -13,7 +13,7 @@ use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n use rustc_span::sym;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n \n@@ -52,6 +52,25 @@ pub fn contains_adt_constructor(ty: Ty<'_>, adt: &AdtDef) -> bool {\n     })\n }\n \n+/// Resolves `<T as Iterator>::Item` for `T`\n+/// Do not invoke without first verifying that the type implements `Iterator`\n+pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    cx.tcx\n+        .get_diagnostic_item(sym::Iterator)\n+        .and_then(|iter_did| {\n+            cx.tcx.associated_items(iter_did).find_by_name_and_kind(\n+                cx.tcx,\n+                Ident::from_str(\"Item\"),\n+                ty::AssocKind::Type,\n+                iter_did,\n+            )\n+        })\n+        .map(|assoc| {\n+            let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n+            cx.tcx.normalize_erasing_regions(cx.param_env, proj)\n+        })\n+}\n+\n /// Returns true if ty has `iter` or `iter_mut` methods\n pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`"}, {"sha": "50f0d724016ff1b33039de9ae471d68b04fc0ced", "filename": "doc/adding_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -625,7 +625,7 @@ in the following steps:\n Here are some pointers to things you are likely going to need for every lint:\n \n * [Clippy utils][utils] - Various helper functions. Maybe the function you need\n-  is already in here (`implements_trait`, `match_path`, `snippet`, etc)\n+  is already in here (`implements_trait`, `match_def_path`, `snippet`, etc)\n * [Clippy diagnostics][diagnostics]\n * [The `if_chain` macro][if_chain]\n * [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]"}, {"sha": "bfb0c3b3f74ec9b4baef4c517018f77b4d277ecf", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -5,7 +5,7 @@\n // When a new lint is introduced, we can search the results for new warnings and check for false\n // positives.\n \n-#![allow(clippy::filter_map, clippy::collapsible_else_if)]\n+#![allow(clippy::collapsible_else_if)]\n \n use std::ffi::OsStr;\n use std::process::Command;"}, {"sha": "cd398451783d6bc53b03596e5b7a55956c9a19d3", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-04-08\"\n+channel = \"nightly-2021-04-22\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "7764cc8da786115eb69d7de82ea2216decd6a1d1", "filename": "tests/ui-internal/collapsible_span_lint_calls.fixed", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,58 +2,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_ast;\n extern crate rustc_errors;\n extern crate rustc_lint;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use rustc_ast::ast::Expr;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-#[allow(unused_variables)]\n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n-{\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_help<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    option_span: Option<Span>,\n-    help: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_note<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    note_span: Option<Span>,\n-    note: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_sugg<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    help: &str,\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-}\n \n declare_tool_lint! {\n     pub clippy::TEST_LINT,"}, {"sha": "bdd296db8320bac83ebab1971a9c0363c194dac5", "filename": "tests/ui-internal/collapsible_span_lint_calls.rs", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,58 +2,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_ast;\n extern crate rustc_errors;\n extern crate rustc_lint;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use rustc_ast::ast::Expr;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-#[allow(unused_variables)]\n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n-{\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_help<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    option_span: Option<Span>,\n-    help: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_note<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    note_span: Option<Span>,\n-    note: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_sugg<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    help: &str,\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-}\n \n declare_tool_lint! {\n     pub clippy::TEST_LINT,"}, {"sha": "0632b038577375f3a1c2ada471554bd5cb7303b8", "filename": "tests/ui-internal/collapsible_span_lint_calls.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:75:9\n+  --> $DIR/collapsible_span_lint_calls.rs:35:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_suggestion(expr.span, help_msg, sugg.to_string(), Applicability::MachineApplicable);\n@@ -14,31 +14,31 @@ LL | #![deny(clippy::internal)]\n    = note: `#[deny(clippy::collapsible_span_lint_calls)]` implied by `#[deny(clippy::internal)]`\n \n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:78:9\n+  --> $DIR/collapsible_span_lint_calls.rs:38:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_help(expr.span, help_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg)`\n \n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:81:9\n+  --> $DIR/collapsible_span_lint_calls.rs:41:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.help(help_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg)`\n \n error: this call is collspible\n-  --> $DIR/collapsible_span_lint_calls.rs:84:9\n+  --> $DIR/collapsible_span_lint_calls.rs:44:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_note(expr.span, note_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg)`\n \n error: this call is collspible\n-  --> $DIR/collapsible_span_lint_calls.rs:87:9\n+  --> $DIR/collapsible_span_lint_calls.rs:47:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.note(note_msg);"}, {"sha": "063f0c6460c5ee92053ba824d69e06b67d62bc23", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,29 +1,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_hir;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+\n #[macro_use]\n extern crate rustc_session;\n+use clippy_utils::{paths, ty::match_type};\n use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Ty;\n \n-mod paths {\n-    pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n-}\n-\n-mod utils {\n-    use super::*;\n-\n-    pub fn match_type(_cx: &LateContext<'_>, _ty: Ty<'_>, _path: &[&str]) -> bool {\n-        false\n-    }\n-}\n-\n-use utils::match_type;\n-\n declare_lint! {\n     pub TEST_LINT,\n     Warn,\n@@ -38,12 +27,12 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n         let ty = cx.typeck_results().expr_ty(expr);\n \n-        let _ = match_type(cx, ty, &paths::VEC);\n+        let _ = match_type(cx, ty, &paths::VEC); // FIXME: Doesn't lint external paths\n         let _ = match_type(cx, ty, &OPTION);\n         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n \n         let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n-        let _ = utils::match_type(cx, ty, rc_path);\n+        let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n     }\n }\n "}, {"sha": "714729605658cca3aa0110c9ee311b7beb637861", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,8 +1,8 @@\n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:41:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:31:17\n    |\n-LL |         let _ = match_type(cx, ty, &paths::VEC);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::vec_type)`\n+LL |         let _ = match_type(cx, ty, &OPTION);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::option_type)`\n    |\n note: the lint level is defined here\n   --> $DIR/match_type_on_diag_item.rs:1:9\n@@ -11,23 +11,17 @@ LL | #![deny(clippy::internal)]\n    |         ^^^^^^^^^^^^^^^^\n    = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n \n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:42:17\n-   |\n-LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::option_type)`\n-\n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:43:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:32:17\n    |\n LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::result_type)`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::result_type)`\n \n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:46:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:35:17\n    |\n-LL |         let _ = utils::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::Rc)`\n+LL |         let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Rc)`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "4a62f6f2909f3b01af9663bbc3cb96c47a901821", "filename": "tests/ui/asm_syntax.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fasm_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fasm_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm_syntax.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,7 @@\n-#![feature(asm)]\n // only-x86_64\n+// ignore-aarch64\n+\n+#![feature(asm)]\n \n #[warn(clippy::inline_asm_x86_intel_syntax)]\n mod warn_intel {\n@@ -23,6 +25,7 @@ mod warn_att {\n     }\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n fn main() {\n     unsafe {\n         warn_att::use_asm();"}, {"sha": "e3abbe086586ea18c4af09fa93efe389e2cb1e75", "filename": "tests/ui/asm_syntax.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fasm_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fasm_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm_syntax.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n error: Intel x86 assembly syntax used\n-  --> $DIR/asm_syntax.rs:7:9\n+  --> $DIR/asm_syntax.rs:9:9\n    |\n LL |         asm!(\"\");\n    |         ^^^^^^^^^\n@@ -8,23 +8,23 @@ LL |         asm!(\"\");\n    = help: use AT&T x86 assembly syntax\n \n error: Intel x86 assembly syntax used\n-  --> $DIR/asm_syntax.rs:8:9\n+  --> $DIR/asm_syntax.rs:10:9\n    |\n LL |         asm!(\"\", options());\n    |         ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use AT&T x86 assembly syntax\n \n error: Intel x86 assembly syntax used\n-  --> $DIR/asm_syntax.rs:9:9\n+  --> $DIR/asm_syntax.rs:11:9\n    |\n LL |         asm!(\"\", options(nostack));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use AT&T x86 assembly syntax\n \n error: AT&T x86 assembly syntax used\n-  --> $DIR/asm_syntax.rs:21:9\n+  --> $DIR/asm_syntax.rs:23:9\n    |\n LL |         asm!(\"\", options(att_syntax));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -33,7 +33,7 @@ LL |         asm!(\"\", options(att_syntax));\n    = help: use Intel x86 assembly syntax\n \n error: AT&T x86 assembly syntax used\n-  --> $DIR/asm_syntax.rs:22:9\n+  --> $DIR/asm_syntax.rs:24:9\n    |\n LL |         asm!(\"\", options(nostack, att_syntax));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "2de402fae8c7de0d05f04a50f65ce5e3976bca61", "filename": "tests/ui/bool_assert_comparison.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,59 @@\n+#![warn(clippy::bool_assert_comparison)]\n+\n+macro_rules! a {\n+    () => {\n+        true\n+    };\n+}\n+macro_rules! b {\n+    () => {\n+        true\n+    };\n+}\n+\n+fn main() {\n+    assert_eq!(\"a\".len(), 1);\n+    assert_eq!(\"a\".is_empty(), false);\n+    assert_eq!(\"\".is_empty(), true);\n+    assert_eq!(true, \"\".is_empty());\n+    assert_eq!(a!(), b!());\n+    assert_eq!(a!(), \"\".is_empty());\n+    assert_eq!(\"\".is_empty(), b!());\n+\n+    assert_ne!(\"a\".len(), 1);\n+    assert_ne!(\"a\".is_empty(), false);\n+    assert_ne!(\"\".is_empty(), true);\n+    assert_ne!(true, \"\".is_empty());\n+    assert_ne!(a!(), b!());\n+    assert_ne!(a!(), \"\".is_empty());\n+    assert_ne!(\"\".is_empty(), b!());\n+\n+    debug_assert_eq!(\"a\".len(), 1);\n+    debug_assert_eq!(\"a\".is_empty(), false);\n+    debug_assert_eq!(\"\".is_empty(), true);\n+    debug_assert_eq!(true, \"\".is_empty());\n+    debug_assert_eq!(a!(), b!());\n+    debug_assert_eq!(a!(), \"\".is_empty());\n+    debug_assert_eq!(\"\".is_empty(), b!());\n+\n+    debug_assert_ne!(\"a\".len(), 1);\n+    debug_assert_ne!(\"a\".is_empty(), false);\n+    debug_assert_ne!(\"\".is_empty(), true);\n+    debug_assert_ne!(true, \"\".is_empty());\n+    debug_assert_ne!(a!(), b!());\n+    debug_assert_ne!(a!(), \"\".is_empty());\n+    debug_assert_ne!(\"\".is_empty(), b!());\n+\n+    // assert with error messages\n+    assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n+    assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n+    assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n+    assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n+    assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+\n+    debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n+    debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n+    debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n+    debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n+    debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+}"}, {"sha": "f57acf520d5f12e111ce76b150fd4ad98768f1c4", "filename": "tests/ui/bool_assert_comparison.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbool_assert_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbool_assert_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,112 @@\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:16:5\n+   |\n+LL |     assert_eq!(\"a\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+   |\n+   = note: `-D clippy::bool-assert-comparison` implied by `-D warnings`\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:17:5\n+   |\n+LL |     assert_eq!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:18:5\n+   |\n+LL |     assert_eq!(true, \"\".is_empty());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:24:5\n+   |\n+LL |     assert_ne!(\"a\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:25:5\n+   |\n+LL |     assert_ne!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:26:5\n+   |\n+LL |     assert_ne!(true, \"\".is_empty());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:32:5\n+   |\n+LL |     debug_assert_eq!(\"a\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:33:5\n+   |\n+LL |     debug_assert_eq!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:34:5\n+   |\n+LL |     debug_assert_eq!(true, \"\".is_empty());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:40:5\n+   |\n+LL |     debug_assert_ne!(\"a\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:41:5\n+   |\n+LL |     debug_assert_ne!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:42:5\n+   |\n+LL |     debug_assert_ne!(true, \"\".is_empty());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:50:5\n+   |\n+LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:51:5\n+   |\n+LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:52:5\n+   |\n+LL |     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:56:5\n+   |\n+LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:57:5\n+   |\n+LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:58:5\n+   |\n+LL |     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "ce2040bdeb82d934e2bbe8c7fbd7bbb63d959835", "filename": "tests/ui/branches_sharing_code/shared_at_bottom.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -206,4 +206,18 @@ fn fp_test() {\n     }\n }\n \n+fn fp_if_let_issue7054() {\n+    // This shouldn't trigger the lint\n+    let string;\n+    let _x = if let true = true {\n+        \"\"\n+    } else if true {\n+        string = \"x\".to_owned();\n+        &string\n+    } else {\n+        string = \"y\".to_owned();\n+        &string\n+    };\n+}\n+\n fn main() {}"}, {"sha": "51a46481399b4e6a5b6af13ec2384fbe46eb263e", "filename": "tests/ui/branches_sharing_code/shared_at_top.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -100,4 +100,15 @@ fn check_if_same_than_else_mask() {\n     }\n }\n \n+#[allow(clippy::vec_init_then_push)]\n+fn pf_local_with_inferred_type_issue7053() {\n+    if true {\n+        let mut v = Vec::new();\n+        v.push(0);\n+    } else {\n+        let mut v = Vec::new();\n+        v.push(\"\");\n+    };\n+}\n+\n fn main() {}"}, {"sha": "4eb999e18e64e35c33e43fd1ecf9aff0aa0c6a55", "filename": "tests/ui/cloned_instead_of_copied.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcloned_instead_of_copied.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::cloned_instead_of_copied)]\n+\n+fn main() {\n+    // yay\n+    let _ = [1].iter().copied();\n+    let _ = vec![\"hi\"].iter().copied();\n+    let _ = Some(&1).copied();\n+    let _ = Box::new([1].iter()).copied();\n+    let _ = Box::new(Some(&1)).copied();\n+\n+    // nay\n+    let _ = [String::new()].iter().cloned();\n+    let _ = Some(&String::new()).cloned();\n+}"}, {"sha": "894496c0ebbb5de0831cafe122d3f9debbee39aa", "filename": "tests/ui/cloned_instead_of_copied.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcloned_instead_of_copied.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![warn(clippy::cloned_instead_of_copied)]\n+\n+fn main() {\n+    // yay\n+    let _ = [1].iter().cloned();\n+    let _ = vec![\"hi\"].iter().cloned();\n+    let _ = Some(&1).cloned();\n+    let _ = Box::new([1].iter()).cloned();\n+    let _ = Box::new(Some(&1)).cloned();\n+\n+    // nay\n+    let _ = [String::new()].iter().cloned();\n+    let _ = Some(&String::new()).cloned();\n+}"}, {"sha": "e0707d32146891a50f6caca35169c453870459f4", "filename": "tests/ui/cloned_instead_of_copied.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcloned_instead_of_copied.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcloned_instead_of_copied.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,34 @@\n+error: used `cloned` where `copied` could be used instead\n+  --> $DIR/cloned_instead_of_copied.rs:6:24\n+   |\n+LL |     let _ = [1].iter().cloned();\n+   |                        ^^^^^^ help: try: `copied`\n+   |\n+   = note: `-D clippy::cloned-instead-of-copied` implied by `-D warnings`\n+\n+error: used `cloned` where `copied` could be used instead\n+  --> $DIR/cloned_instead_of_copied.rs:7:31\n+   |\n+LL |     let _ = vec![\"hi\"].iter().cloned();\n+   |                               ^^^^^^ help: try: `copied`\n+\n+error: used `cloned` where `copied` could be used instead\n+  --> $DIR/cloned_instead_of_copied.rs:8:22\n+   |\n+LL |     let _ = Some(&1).cloned();\n+   |                      ^^^^^^ help: try: `copied`\n+\n+error: used `cloned` where `copied` could be used instead\n+  --> $DIR/cloned_instead_of_copied.rs:9:34\n+   |\n+LL |     let _ = Box::new([1].iter()).cloned();\n+   |                                  ^^^^^^ help: try: `copied`\n+\n+error: used `cloned` where `copied` could be used instead\n+  --> $DIR/cloned_instead_of_copied.rs:10:32\n+   |\n+LL |     let _ = Box::new(Some(&1)).cloned();\n+   |                                ^^^^^^ help: try: `copied`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "5e99cb432b6e2f2232fa20462aa0fd93dbcb65b6", "filename": "tests/ui/crashes/ice-5835.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcrashes%2Fice-5835.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcrashes%2Fice-5835.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5835.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,9 @@\n+#[rustfmt::skip]\n+pub struct Foo {\n+    /// \u4f4d\t\n+    ///   ^ Do not remove this tab character.\n+    ///   It was required to trigger the ICE.\n+    pub bar: u8,\n+}\n+\n+fn main() {}"}, {"sha": "c972bcb60a0cdba58c021f22479930ed7ba4f786", "filename": "tests/ui/crashes/ice-5835.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcrashes%2Fice-5835.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fcrashes%2Fice-5835.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5835.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,10 @@\n+error: using tabs in doc comments is not recommended\n+  --> $DIR/ice-5835.rs:3:10\n+   |\n+LL |     /// \u4f4d    \n+   |           ^^^^ help: consider using four spaces per tab\n+   |\n+   = note: `-D clippy::tabs-in-doc-comments` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "dbf0b03af769ccc5ec9b36c18a27bf5e174573cb", "filename": "tests/ui/deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -11,5 +11,6 @@\n #[warn(clippy::panic_params)]\n #[warn(clippy::unknown_clippy_lints)]\n #[warn(clippy::find_map)]\n+#[warn(clippy::filter_map)]\n \n fn main() {}"}, {"sha": "3e125c1dab568a7f137b12a7521cb41cc27b9ce0", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -24,65 +24,71 @@ error: lint `clippy::unused_collect` has been removed: `collect` has been marked\n LL | #[warn(clippy::unused_collect)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: lint `clippy::invalid_ref` has been removed: superseded by rustc lint `invalid_value`\n+error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n   --> $DIR/deprecated.rs:5:8\n    |\n LL | #[warn(clippy::invalid_ref)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n-error: lint `clippy::into_iter_on_array` has been removed: this lint has been uplifted to rustc and is now called `array_into_iter`\n+error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n   --> $DIR/deprecated.rs:6:8\n    |\n LL | #[warn(clippy::into_iter_on_array)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n-error: lint `clippy::unused_label` has been removed: this lint has been uplifted to rustc and is now called `unused_labels`\n+error: lint `clippy::unused_label` has been renamed to `unused_labels`\n   --> $DIR/deprecated.rs:7:8\n    |\n LL | #[warn(clippy::unused_label)]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n error: lint `clippy::regex_macro` has been removed: the regex! macro has been removed from the regex crate in 2018\n   --> $DIR/deprecated.rs:8:8\n    |\n LL | #[warn(clippy::regex_macro)]\n    |        ^^^^^^^^^^^^^^^^^^^\n \n-error: lint `clippy::drop_bounds` has been removed: this lint has been uplifted to rustc and is now called `drop_bounds`\n+error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n   --> $DIR/deprecated.rs:9:8\n    |\n LL | #[warn(clippy::drop_bounds)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n-error: lint `clippy::temporary_cstring_as_ptr` has been removed: this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr`\n+error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n   --> $DIR/deprecated.rs:10:8\n    |\n LL | #[warn(clippy::temporary_cstring_as_ptr)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n-error: lint `clippy::panic_params` has been removed: this lint has been uplifted to rustc and is now called `panic_fmt`\n+error: lint `clippy::panic_params` has been renamed to `non_fmt_panic`\n   --> $DIR/deprecated.rs:11:8\n    |\n LL | #[warn(clippy::panic_params)]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panic`\n \n-error: lint `clippy::unknown_clippy_lints` has been removed: this lint has been integrated into the `unknown_lints` rustc lint\n+error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n   --> $DIR/deprecated.rs:12:8\n    |\n LL | #[warn(clippy::unknown_clippy_lints)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::find_map` has been removed: this lint has been replaced by `manual_find_map`, a more specific lint\n   --> $DIR/deprecated.rs:13:8\n    |\n LL | #[warn(clippy::find_map)]\n    |        ^^^^^^^^^^^^^^^^\n \n+error: lint `clippy::filter_map` has been removed: this lint has been replaced by `manual_filter_map`, a more specific lint\n+  --> $DIR/deprecated.rs:14:8\n+   |\n+LL | #[warn(clippy::filter_map)]\n+   |        ^^^^^^^^^^^^^^^^^^\n+\n error: lint `clippy::unstable_as_slice` has been removed: `Vec::as_slice` has been stabilized in 1.7\n   --> $DIR/deprecated.rs:1:8\n    |\n LL | #[warn(clippy::unstable_as_slice)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "cfad3090ba38d2bc7a0a5482c0c97084757f4fee", "filename": "tests/ui/entry.fixed", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,155 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+#![feature(asm)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n+    m.entry(k).or_insert(v);\n+\n+    // semicolon on insert, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        if true {\n+            v\n+        } else {\n+            v2\n+        }\n+    });\n+\n+    // semicolon on if, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        if true {\n+            v\n+        } else {\n+            v2\n+        }\n+    });\n+\n+    // early return, use if let\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        if true {\n+            e.insert(v);\n+        } else {\n+            e.insert(v2);\n+            return;\n+        }\n+    }\n+\n+    // use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        foo();\n+        v\n+    });\n+\n+    // semicolon on insert and match, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        match 0 {\n+            1 if true => {\n+                v\n+            },\n+            _ => {\n+                v2\n+            },\n+        }\n+    });\n+\n+    // one branch doesn't insert, use if let\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        match 0 {\n+            0 => foo(),\n+            _ => {\n+                e.insert(v2);\n+            },\n+        };\n+    }\n+\n+    // use or_insert_with\n+    m.entry(k).or_insert_with(|| {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                v\n+            },\n+            1 => {\n+                foo();\n+                v\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    v\n+                } else {\n+                    v2\n+                }\n+            },\n+            _ => {\n+                v2\n+            },\n+        }\n+    });\n+\n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n+    m.entry(m!(k)).or_insert_with(|| m!(v));\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fa9280b58de11cd513d6ced8c6ef0a8fe81b5cdf", "filename": "tests/ui/entry.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,159 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+#![feature(asm)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    }\n+\n+    // semicolon on insert, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+        }\n+    }\n+\n+    // semicolon on if, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v)\n+        } else {\n+            m.insert(k, v2)\n+        };\n+    }\n+\n+    // early return, use if let\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+            return;\n+        }\n+    }\n+\n+    // use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v);\n+    }\n+\n+    // semicolon on insert and match, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            1 if true => {\n+                m.insert(k, v);\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    // one branch doesn't insert, use if let\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            0 => foo(),\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    // use or_insert_with\n+    if !m.contains_key(&k) {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                m.insert(k, v);\n+            },\n+            1 => {\n+                foo();\n+                m.insert(k, v);\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    m.insert(k, v);\n+                } else {\n+                    m.insert(k, v2);\n+                };\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        }\n+    }\n+\n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n+    if !m.contains_key(&m!(k)) {\n+        m.insert(m!(k), m!(v));\n+    }\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2f075a97010a63d77365ce0ac6f03eeef8e3ab50", "filename": "tests/ui/entry.stderr", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,186 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:24:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^ help: try this: `m.entry(k).or_insert(v);`\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:29:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+LL | |             m.insert(k, v2);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         if true {\n+LL |             v\n+LL |         } else {\n+LL |             v2\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:38:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v)\n+LL | |         } else {\n+LL | |             m.insert(k, v2)\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         if true {\n+LL |             v\n+LL |         } else {\n+LL |             v2\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:47:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         if true {\n+LL |             e.insert(v);\n+LL |         } else {\n+LL |             e.insert(v2);\n+LL |             return;\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:57:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         foo();\n+LL |         v\n+LL |     });\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:63:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             1 if true => {\n+LL | |                 m.insert(k, v);\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         match 0 {\n+LL |             1 if true => {\n+LL |                 v\n+LL |             },\n+LL |             _ => {\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:75:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             0 => foo(),\n+LL | |             _ => {\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         match 0 {\n+LL |             0 => foo(),\n+LL |             _ => {\n+LL |                 e.insert(v2);\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:85:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         match 0 {\n+LL | |             0 if false => {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         foo();\n+LL |         match 0 {\n+LL |             0 if false => {\n+LL |                 v\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:119:5\n+   |\n+LL | /     if !m.contains_key(&m!(k)) {\n+LL | |         m.insert(m!(k), m!(v));\n+LL | |     }\n+   | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n+\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry.rs:153:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "dcdaae7e72430494a3224bb9f0312ab07e90f274", "filename": "tests/ui/entry_fixable.fixed", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.fixed?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    m.entry(k).or_insert(v);\n-}\n-\n-fn main() {}"}, {"sha": "55d5b21568d0e03223089aad2e5990a3a104d9eb", "filename": "tests/ui/entry_fixable.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,17 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "87403200ced5008788562ebe66b8c6c2ea918129", "filename": "tests/ui/entry_fixable.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.stderr?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,12 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_fixable.rs:12:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v);\n-LL | |     }\n-   | |_____^ help: consider using: `m.entry(k).or_insert(v);`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "f530fc023cfbf920f46b98cacb2847966234c6c8", "filename": "tests/ui/entry_unfixable.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,73 +0,0 @@\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        m.insert(k, v)\n-    };\n-}\n-\n-fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        foo();\n-        m.insert(k, v)\n-    };\n-}\n-\n-fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-// should not trigger\n-fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(o, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map<K: Eq + Hash, V>(m: HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e58c8d22dc45e2bc6303f3afeb8dd813ded7c42f", "filename": "tests/ui/entry_unfixable.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fentry_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.stderr?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,57 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:10:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:18:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:26:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:35:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry_unfixable.rs:44:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "2332fa6313ff3958dea096892b3ac236cfc16c14", "filename": "tests/ui/entry_with_else.fixed", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,73 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+            None\n+        }\n+    };\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        foo();\n+        Some(e.insert(v))\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "2ff0c038efe27fb3333dc4aea39e2e1da1e16e4f", "filename": "tests/ui/entry_with_else.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,60 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        foo();\n+    }\n+\n+    if !m.contains_key(&k) {\n+        foo();\n+    } else {\n+        m.insert(k, v);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        if true { m.insert(k, v) } else { m.insert(k, v2) }\n+    } else {\n+        m.insert(k, v)\n+    };\n+\n+    if m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v)\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "6f62ff8d37457609f72a14510f69e3d661ff9cfe", "filename": "tests/ui/entry_with_else.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fentry_with_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,142 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:16:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:22:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:28:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:34:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |     } else {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:40:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:46:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         if true { m.insert(k, v) } else { m.insert(k, v2) }\n+LL | |     } else {\n+LL | |         m.insert(k, v)\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:52:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         foo();\n+LL |         Some(e.insert(v))\n+LL |     } else {\n+LL |         None\n+LL |     };\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "96121b114ce6c8cfb5f77b18cfaadbf55cf3c991", "filename": "tests/ui/filter_methods.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Ffilter_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Ffilter_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_methods.rs?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,25 +0,0 @@\n-#![warn(clippy::all, clippy::pedantic)]\n-#![allow(clippy::let_underscore_drop)]\n-#![allow(clippy::missing_docs_in_private_items)]\n-\n-fn main() {\n-    let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x * 2).collect();\n-\n-    let _: Vec<_> = vec![5_i8; 6]\n-        .into_iter()\n-        .filter(|&x| x == 0)\n-        .flat_map(|x| x.checked_mul(2))\n-        .collect();\n-\n-    let _: Vec<_> = vec![5_i8; 6]\n-        .into_iter()\n-        .filter_map(|x| x.checked_mul(2))\n-        .flat_map(|x| x.checked_mul(2))\n-        .collect();\n-\n-    let _: Vec<_> = vec![5_i8; 6]\n-        .into_iter()\n-        .filter_map(|x| x.checked_mul(2))\n-        .map(|x| x.checked_mul(2))\n-        .collect();\n-}"}, {"sha": "c7b4f28be3a4454f5a01293c6bf0ba8d7b5a02ba", "filename": "tests/ui/filter_methods.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Ffilter_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Ffilter_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_methods.stderr?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,39 +0,0 @@\n-error: called `filter(..).flat_map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:8:21\n-   |\n-LL |       let _: Vec<_> = vec![5_i8; 6]\n-   |  _____________________^\n-LL | |         .into_iter()\n-LL | |         .filter(|&x| x == 0)\n-LL | |         .flat_map(|x| x.checked_mul(2))\n-   | |_______________________________________^\n-   |\n-   = note: `-D clippy::filter-map` implied by `-D warnings`\n-   = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n-\n-error: called `filter_map(..).flat_map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:14:21\n-   |\n-LL |       let _: Vec<_> = vec![5_i8; 6]\n-   |  _____________________^\n-LL | |         .into_iter()\n-LL | |         .filter_map(|x| x.checked_mul(2))\n-LL | |         .flat_map(|x| x.checked_mul(2))\n-   | |_______________________________________^\n-   |\n-   = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n-\n-error: called `filter_map(..).map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:20:21\n-   |\n-LL |       let _: Vec<_> = vec![5_i8; 6]\n-   |  _____________________^\n-LL | |         .into_iter()\n-LL | |         .filter_map(|x| x.checked_mul(2))\n-LL | |         .map(|x| x.checked_mul(2))\n-   | |__________________________________^\n-   |\n-   = help: this is more succinctly expressed by only calling `.filter_map(..)` instead\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "6a34f008995cdfb301e94086129e09adc703571d", "filename": "tests/ui/flat_map_option.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_option.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::flat_map_option)]\n+#![allow(clippy::redundant_closure, clippy::unnecessary_filter_map)]\n+\n+fn main() {\n+    // yay\n+    let c = |x| Some(x);\n+    let _ = [1].iter().filter_map(c);\n+    let _ = [1].iter().filter_map(Some);\n+\n+    // nay\n+    let _ = [1].iter().flat_map(|_| &Some(1));\n+}"}, {"sha": "2479abddbf04e49c167c908bc19c1bf8ca05be44", "filename": "tests/ui/flat_map_option.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_option.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::flat_map_option)]\n+#![allow(clippy::redundant_closure, clippy::unnecessary_filter_map)]\n+\n+fn main() {\n+    // yay\n+    let c = |x| Some(x);\n+    let _ = [1].iter().flat_map(c);\n+    let _ = [1].iter().flat_map(Some);\n+\n+    // nay\n+    let _ = [1].iter().flat_map(|_| &Some(1));\n+}"}, {"sha": "a9d8056dee978cb6511ea72c1cd967ed660e44de", "filename": "tests/ui/flat_map_option.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fflat_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_option.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,16 @@\n+error: used `flat_map` where `filter_map` could be used instead\n+  --> $DIR/flat_map_option.rs:8:24\n+   |\n+LL |     let _ = [1].iter().flat_map(c);\n+   |                        ^^^^^^^^ help: try: `filter_map`\n+   |\n+   = note: `-D clippy::flat-map-option` implied by `-D warnings`\n+\n+error: used `flat_map` where `filter_map` could be used instead\n+  --> $DIR/flat_map_option.rs:9:24\n+   |\n+LL |     let _ = [1].iter().flat_map(Some);\n+   |                        ^^^^^^^^ help: try: `filter_map`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f44928d4083868968a448727c64cce4ba20ecb8a", "filename": "tests/ui/for_loop_fixable.fixed", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -281,3 +281,29 @@ mod issue_4958 {\n         for _ in rr.into_iter() {}\n     }\n }\n+\n+// explicit_into_iter_loop\n+#[warn(clippy::explicit_into_iter_loop)]\n+mod issue_6900 {\n+    struct S;\n+    impl S {\n+        #[allow(clippy::should_implement_trait)]\n+        pub fn into_iter<T>(self) -> I<T> {\n+            unimplemented!()\n+        }\n+    }\n+\n+    struct I<T>(T);\n+    impl<T> Iterator for I<T> {\n+        type Item = T;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            unimplemented!()\n+        }\n+    }\n+\n+    fn f() {\n+        for _ in S.into_iter::<u32>() {\n+            unimplemented!()\n+        }\n+    }\n+}"}, {"sha": "5b1eb3ee4dcd2421440fe4332b17c8a00af23c0f", "filename": "tests/ui/for_loop_fixable.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -281,3 +281,29 @@ mod issue_4958 {\n         for _ in rr.into_iter() {}\n     }\n }\n+\n+// explicit_into_iter_loop\n+#[warn(clippy::explicit_into_iter_loop)]\n+mod issue_6900 {\n+    struct S;\n+    impl S {\n+        #[allow(clippy::should_implement_trait)]\n+        pub fn into_iter<T>(self) -> I<T> {\n+            unimplemented!()\n+        }\n+    }\n+\n+    struct I<T>(T);\n+    impl<T> Iterator for I<T> {\n+        type Item = T;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            unimplemented!()\n+        }\n+    }\n+\n+    fn f() {\n+        for _ in S.into_iter::<u32>() {\n+            unimplemented!()\n+        }\n+    }\n+}"}, {"sha": "e4cfb005fd1d0d8e8a0ac4bd42392dddb56df35c", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -65,4 +65,8 @@ fn main() {\n     // False positive\n     let a = \"foo\".to_string();\n     let _ = Some(a + \"bar\");\n+\n+    // Wrap it with braces\n+    let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n+    let _s: String = (&*v.join(\"\\n\")).to_string();\n }"}, {"sha": "683957f0ff0f79cb452811b66b0db83d90f55c8b", "filename": "tests/ui/format.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -67,4 +67,8 @@ fn main() {\n     // False positive\n     let a = \"foo\".to_string();\n     let _ = Some(format!(\"{}\", a + \"bar\"));\n+\n+    // Wrap it with braces\n+    let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n+    let _s: String = format!(\"{}\", &*v.join(\"\\n\"));\n }"}, {"sha": "2017eb2b3838fc46208b13ec268f6248bdb21d54", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -87,5 +87,11 @@ error: useless use of `format!`\n LL |     let _ = Some(format!(\"{}\", a + \"bar\"));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `a + \"bar\"`\n \n-error: aborting due to 13 previous errors\n+error: useless use of `format!`\n+  --> $DIR/format.rs:73:22\n+   |\n+LL |     let _s: String = format!(\"{}\", &*v.join(\"/n\"));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `(&*v.join(\"/n\")).to_string()`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "2951e6bdac430bde13ea1a58bdfad95fb14a0a2f", "filename": "tests/ui/from_over_into.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -5,7 +5,7 @@ LL | impl Into<StringWrapper> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n-   = help: consider to implement `From` instead\n+   = help: consider to implement `From<std::string::String>` instead\n \n error: aborting due to previous error\n "}, {"sha": "d1025743790a9747bfb95c6bb746d0b1e15b917c", "filename": "tests/ui/inconsistent_struct_constructor.fixed", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_struct_constructor.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -13,6 +13,15 @@ struct Foo {\n     z: i32,\n }\n \n+macro_rules! new_foo {\n+    () => {\n+        let x = 1;\n+        let y = 1;\n+        let z = 1;\n+        Foo { y, x, z }\n+    };\n+}\n+\n mod without_base {\n     use super::Foo;\n \n@@ -24,6 +33,10 @@ mod without_base {\n         // Should lint.\n         Foo { x, y, z };\n \n+        // Should NOT lint.\n+        // issue #7069.\n+        new_foo!();\n+\n         // Shoule NOT lint because the order is the same as in the definition.\n         Foo { x, y, z };\n "}, {"sha": "b095aa64a2174371e94d9f2c240ed910c9c893ca", "filename": "tests/ui/inconsistent_struct_constructor.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_struct_constructor.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -13,6 +13,15 @@ struct Foo {\n     z: i32,\n }\n \n+macro_rules! new_foo {\n+    () => {\n+        let x = 1;\n+        let y = 1;\n+        let z = 1;\n+        Foo { y, x, z }\n+    };\n+}\n+\n mod without_base {\n     use super::Foo;\n \n@@ -24,6 +33,10 @@ mod without_base {\n         // Should lint.\n         Foo { y, x, z };\n \n+        // Should NOT lint.\n+        // issue #7069.\n+        new_foo!();\n+\n         // Shoule NOT lint because the order is the same as in the definition.\n         Foo { x, y, z };\n "}, {"sha": "ef308dedb1661c331703d68d9ab973477f473d51", "filename": "tests/ui/inconsistent_struct_constructor.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finconsistent_struct_constructor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_struct_constructor.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,13 +1,13 @@\n error: struct constructor field order is inconsistent with struct definition field order\n-  --> $DIR/inconsistent_struct_constructor.rs:25:9\n+  --> $DIR/inconsistent_struct_constructor.rs:34:9\n    |\n LL |         Foo { y, x, z };\n    |         ^^^^^^^^^^^^^^^ help: try: `Foo { x, y, z }`\n    |\n    = note: `-D clippy::inconsistent-struct-constructor` implied by `-D warnings`\n \n error: struct constructor field order is inconsistent with struct definition field order\n-  --> $DIR/inconsistent_struct_constructor.rs:43:9\n+  --> $DIR/inconsistent_struct_constructor.rs:56:9\n    |\n LL | /         Foo {\n LL | |             z,"}, {"sha": "4f5322ebf202f819063de4ef709541741a952703", "filename": "tests/ui/invalid_null_ptr_usage.fixed", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_null_ptr_usage.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,49 @@\n+// run-rustfix\n+\n+fn main() {\n+    unsafe {\n+        let _slice: &[usize] = std::slice::from_raw_parts(core::ptr::NonNull::dangling().as_ptr(), 0);\n+        let _slice: &[usize] = std::slice::from_raw_parts(core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        let _slice: &[usize] = std::slice::from_raw_parts_mut(core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        std::ptr::copy::<usize>(core::ptr::NonNull::dangling().as_ptr(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+        std::ptr::copy::<usize>(std::ptr::NonNull::dangling().as_ptr(), core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        std::ptr::copy_nonoverlapping::<usize>(core::ptr::NonNull::dangling().as_ptr(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+        std::ptr::copy_nonoverlapping::<usize>(std::ptr::NonNull::dangling().as_ptr(), core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        struct A; // zero sized struct\n+        assert_eq!(std::mem::size_of::<A>(), 0);\n+\n+        let _a: A = std::ptr::read(core::ptr::NonNull::dangling().as_ptr());\n+        let _a: A = std::ptr::read(core::ptr::NonNull::dangling().as_ptr());\n+\n+        let _a: A = std::ptr::read_unaligned(core::ptr::NonNull::dangling().as_ptr());\n+        let _a: A = std::ptr::read_unaligned(core::ptr::NonNull::dangling().as_ptr());\n+\n+        let _a: A = std::ptr::read_volatile(core::ptr::NonNull::dangling().as_ptr());\n+        let _a: A = std::ptr::read_volatile(core::ptr::NonNull::dangling().as_ptr());\n+\n+        let _a: A = std::ptr::replace(core::ptr::NonNull::dangling().as_ptr(), A);\n+\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts(core::ptr::NonNull::dangling().as_ptr(), 0);\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts(core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts_mut(core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        std::ptr::swap::<A>(core::ptr::NonNull::dangling().as_ptr(), &mut A);\n+        std::ptr::swap::<A>(&mut A, core::ptr::NonNull::dangling().as_ptr());\n+\n+        std::ptr::swap_nonoverlapping::<A>(core::ptr::NonNull::dangling().as_ptr(), &mut A, 0);\n+        std::ptr::swap_nonoverlapping::<A>(&mut A, core::ptr::NonNull::dangling().as_ptr(), 0);\n+\n+        std::ptr::write(core::ptr::NonNull::dangling().as_ptr(), A);\n+\n+        std::ptr::write_unaligned(core::ptr::NonNull::dangling().as_ptr(), A);\n+\n+        std::ptr::write_volatile(core::ptr::NonNull::dangling().as_ptr(), A);\n+\n+        std::ptr::write_bytes::<usize>(core::ptr::NonNull::dangling().as_ptr(), 42, 0);\n+    }\n+}"}, {"sha": "ae51c52d8af0ce2f33759bad1f8fe8d059b97064", "filename": "tests/ui/invalid_null_ptr_usage.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_null_ptr_usage.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,49 @@\n+// run-rustfix\n+\n+fn main() {\n+    unsafe {\n+        let _slice: &[usize] = std::slice::from_raw_parts(std::ptr::null(), 0);\n+        let _slice: &[usize] = std::slice::from_raw_parts(std::ptr::null_mut(), 0);\n+\n+        let _slice: &[usize] = std::slice::from_raw_parts_mut(std::ptr::null_mut(), 0);\n+\n+        std::ptr::copy::<usize>(std::ptr::null(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+        std::ptr::copy::<usize>(std::ptr::NonNull::dangling().as_ptr(), std::ptr::null_mut(), 0);\n+\n+        std::ptr::copy_nonoverlapping::<usize>(std::ptr::null(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+        std::ptr::copy_nonoverlapping::<usize>(std::ptr::NonNull::dangling().as_ptr(), std::ptr::null_mut(), 0);\n+\n+        struct A; // zero sized struct\n+        assert_eq!(std::mem::size_of::<A>(), 0);\n+\n+        let _a: A = std::ptr::read(std::ptr::null());\n+        let _a: A = std::ptr::read(std::ptr::null_mut());\n+\n+        let _a: A = std::ptr::read_unaligned(std::ptr::null());\n+        let _a: A = std::ptr::read_unaligned(std::ptr::null_mut());\n+\n+        let _a: A = std::ptr::read_volatile(std::ptr::null());\n+        let _a: A = std::ptr::read_volatile(std::ptr::null_mut());\n+\n+        let _a: A = std::ptr::replace(std::ptr::null_mut(), A);\n+\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts(std::ptr::null(), 0);\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts(std::ptr::null_mut(), 0);\n+\n+        let _slice: *const [usize] = std::ptr::slice_from_raw_parts_mut(std::ptr::null_mut(), 0);\n+\n+        std::ptr::swap::<A>(std::ptr::null_mut(), &mut A);\n+        std::ptr::swap::<A>(&mut A, std::ptr::null_mut());\n+\n+        std::ptr::swap_nonoverlapping::<A>(std::ptr::null_mut(), &mut A, 0);\n+        std::ptr::swap_nonoverlapping::<A>(&mut A, std::ptr::null_mut(), 0);\n+\n+        std::ptr::write(std::ptr::null_mut(), A);\n+\n+        std::ptr::write_unaligned(std::ptr::null_mut(), A);\n+\n+        std::ptr::write_volatile(std::ptr::null_mut(), A);\n+\n+        std::ptr::write_bytes::<usize>(std::ptr::null_mut(), 42, 0);\n+    }\n+}"}, {"sha": "532c36abe51961fc6b31d9bebba0a03e034f92ce", "filename": "tests/ui/invalid_null_ptr_usage.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Finvalid_null_ptr_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_null_ptr_usage.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,154 @@\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:5:59\n+   |\n+LL |         let _slice: &[usize] = std::slice::from_raw_parts(std::ptr::null(), 0);\n+   |                                                           ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+   |\n+   = note: `#[deny(clippy::invalid_null_ptr_usage)]` on by default\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:6:59\n+   |\n+LL |         let _slice: &[usize] = std::slice::from_raw_parts(std::ptr::null_mut(), 0);\n+   |                                                           ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:8:63\n+   |\n+LL |         let _slice: &[usize] = std::slice::from_raw_parts_mut(std::ptr::null_mut(), 0);\n+   |                                                               ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:10:33\n+   |\n+LL |         std::ptr::copy::<usize>(std::ptr::null(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+   |                                 ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:11:73\n+   |\n+LL |         std::ptr::copy::<usize>(std::ptr::NonNull::dangling().as_ptr(), std::ptr::null_mut(), 0);\n+   |                                                                         ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:13:48\n+   |\n+LL |         std::ptr::copy_nonoverlapping::<usize>(std::ptr::null(), std::ptr::NonNull::dangling().as_ptr(), 0);\n+   |                                                ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:14:88\n+   |\n+LL |         std::ptr::copy_nonoverlapping::<usize>(std::ptr::NonNull::dangling().as_ptr(), std::ptr::null_mut(), 0);\n+   |                                                                                        ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:19:36\n+   |\n+LL |         let _a: A = std::ptr::read(std::ptr::null());\n+   |                                    ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:20:36\n+   |\n+LL |         let _a: A = std::ptr::read(std::ptr::null_mut());\n+   |                                    ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:22:46\n+   |\n+LL |         let _a: A = std::ptr::read_unaligned(std::ptr::null());\n+   |                                              ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:23:46\n+   |\n+LL |         let _a: A = std::ptr::read_unaligned(std::ptr::null_mut());\n+   |                                              ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:25:45\n+   |\n+LL |         let _a: A = std::ptr::read_volatile(std::ptr::null());\n+   |                                             ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:26:45\n+   |\n+LL |         let _a: A = std::ptr::read_volatile(std::ptr::null_mut());\n+   |                                             ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:28:39\n+   |\n+LL |         let _a: A = std::ptr::replace(std::ptr::null_mut(), A);\n+   |                                       ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:30:69\n+   |\n+LL |         let _slice: *const [usize] = std::ptr::slice_from_raw_parts(std::ptr::null(), 0);\n+   |                                                                     ^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:31:69\n+   |\n+LL |         let _slice: *const [usize] = std::ptr::slice_from_raw_parts(std::ptr::null_mut(), 0);\n+   |                                                                     ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:33:73\n+   |\n+LL |         let _slice: *const [usize] = std::ptr::slice_from_raw_parts_mut(std::ptr::null_mut(), 0);\n+   |                                                                         ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:35:29\n+   |\n+LL |         std::ptr::swap::<A>(std::ptr::null_mut(), &mut A);\n+   |                             ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:36:37\n+   |\n+LL |         std::ptr::swap::<A>(&mut A, std::ptr::null_mut());\n+   |                                     ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:38:44\n+   |\n+LL |         std::ptr::swap_nonoverlapping::<A>(std::ptr::null_mut(), &mut A, 0);\n+   |                                            ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:39:52\n+   |\n+LL |         std::ptr::swap_nonoverlapping::<A>(&mut A, std::ptr::null_mut(), 0);\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:41:25\n+   |\n+LL |         std::ptr::write(std::ptr::null_mut(), A);\n+   |                         ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:43:35\n+   |\n+LL |         std::ptr::write_unaligned(std::ptr::null_mut(), A);\n+   |                                   ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:45:34\n+   |\n+LL |         std::ptr::write_volatile(std::ptr::null_mut(), A);\n+   |                                  ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: pointer must be non-null\n+  --> $DIR/invalid_null_ptr_usage.rs:47:40\n+   |\n+LL |         std::ptr::write_bytes::<usize>(std::ptr::null_mut(), 42, 0);\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ help: change this to: `core::ptr::NonNull::dangling().as_ptr()`\n+\n+error: aborting due to 25 previous errors\n+"}, {"sha": "51c66a46368dba6010f92775aecfca6ac22e556e", "filename": "tests/ui/macro_use_imports.fixed", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -4,7 +4,7 @@\n // run-rustfix\n // ignore-32bit\n \n-#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code, unused_attributes)]\n #![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]\n \n@@ -40,4 +40,8 @@ mod a {\n     }\n }\n \n+// issue #7015, ICE due to calling `item_children` with local `DefId`\n+#[macro_use]\n+use a as b;\n+\n fn main() {}"}, {"sha": "2011129bc944d86a997e2d83df19fc3de344f5db", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -4,7 +4,7 @@\n // run-rustfix\n // ignore-32bit\n \n-#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code, unused_attributes)]\n #![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]\n \n@@ -40,4 +40,8 @@ mod a {\n     }\n }\n \n+// issue #7015, ICE due to calling `item_children` with local `DefId`\n+#[macro_use]\n+use a as b;\n+\n fn main() {}"}, {"sha": "40d01df6379a696496028454027d8acaba84f1c8", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -146,4 +146,11 @@ fn main() {\n             None => None,\n         };\n     }\n+\n+    // #7077\n+    let s = &String::new();\n+    let _: Option<&str> = match Some(s) {\n+        Some(s) => Some(s),\n+        None => None,\n+    };\n }"}, {"sha": "cfef0c5cc4ec66207834005b7b151d666737c0fa", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -212,4 +212,11 @@ fn main() {\n             None => None,\n         };\n     }\n+\n+    // #7077\n+    let s = &String::new();\n+    let _: Option<&str> = match Some(s) {\n+        Some(s) => Some(s),\n+        None => None,\n+    };\n }"}, {"sha": "7b9dc76b8f1d48d7b055bf5b6c48442fd5f6bebb", "filename": "tests/ui/missing_const_for_fn/auxiliary/helper.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fauxiliary%2Fhelper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fauxiliary%2Fhelper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fauxiliary%2Fhelper.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,8 @@\n+// This file provides a const function that is unstably const forever.\n+\n+#![feature(staged_api)]\n+#![stable(feature = \"1\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"foo\", issue = \"none\")]\n+pub const fn unstably_const_fn() {}"}, {"sha": "7cda1aaa3c22894def353f9e6223546a930ab2f5", "filename": "tests/ui/missing_const_for_fn/cant_be_const.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,9 +2,14 @@\n //! compilation error.\n //! The .stderr output of this test should be empty. Otherwise it's a bug somewhere.\n \n+// aux-build:helper.rs\n+\n #![warn(clippy::missing_const_for_fn)]\n #![allow(incomplete_features)]\n #![feature(start, const_generics)]\n+#![feature(custom_inner_attributes)]\n+\n+extern crate helper;\n \n struct Game;\n \n@@ -101,3 +106,17 @@ fn const_generic_return<T, const N: usize>(t: &[T]) -> &[T; N] {\n \n     unsafe { &*p }\n }\n+\n+// Do not lint this because it calls a function whose constness is unstable.\n+fn unstably_const_fn() {\n+    helper::unstably_const_fn()\n+}\n+\n+mod const_fn_stabilized_after_msrv {\n+    #![clippy::msrv = \"1.46.0\"]\n+\n+    // Do not lint this because `u8::is_ascii_digit` is stabilized as a const function in 1.47.0.\n+    fn const_fn_stabilized_after_msrv(byte: u8) {\n+        byte.is_ascii_digit();\n+    }\n+}"}, {"sha": "0accb516f5f6b4a145e161c708cc726a72b221a8", "filename": "tests/ui/missing_const_for_fn/could_be_const.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,7 @@\n #![warn(clippy::missing_const_for_fn)]\n #![allow(incomplete_features, clippy::let_and_return)]\n #![feature(const_generics)]\n+#![feature(custom_inner_attributes)]\n \n use std::mem::transmute;\n \n@@ -70,5 +71,14 @@ mod with_drop {\n     }\n }\n \n+mod const_fn_stabilized_before_msrv {\n+    #![clippy::msrv = \"1.47.0\"]\n+\n+    // This could be const because `u8::is_ascii_digit` is a stable const function in 1.47.\n+    fn const_fn_stabilized_before_msrv(byte: u8) {\n+        byte.is_ascii_digit();\n+    }\n+}\n+\n // Should not be const\n fn main() {}"}, {"sha": "63c211f39fa1e3530a1be0d041f69d6bae65ee63", "filename": "tests/ui/missing_const_for_fn/could_be_const.stderr", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:13:5\n+  --> $DIR/could_be_const.rs:14:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self { guess: 42 }\n@@ -9,23 +9,23 @@ LL | |     }\n    = note: `-D clippy::missing-const-for-fn` implied by `-D warnings`\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:17:5\n+  --> $DIR/could_be_const.rs:18:5\n    |\n LL | /     fn const_generic_params<'a, T, const N: usize>(&self, b: &'a [T; N]) -> &'a [T; N] {\n LL | |         b\n LL | |     }\n    | |_____^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:23:1\n+  --> $DIR/could_be_const.rs:24:1\n    |\n LL | / fn one() -> i32 {\n LL | |     1\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:28:1\n+  --> $DIR/could_be_const.rs:29:1\n    |\n LL | / fn two() -> i32 {\n LL | |     let abc = 2;\n@@ -34,36 +34,44 @@ LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:34:1\n+  --> $DIR/could_be_const.rs:35:1\n    |\n LL | / fn string() -> String {\n LL | |     String::new()\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:39:1\n+  --> $DIR/could_be_const.rs:40:1\n    |\n LL | / unsafe fn four() -> i32 {\n LL | |     4\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:44:1\n+  --> $DIR/could_be_const.rs:45:1\n    |\n LL | / fn generic<T>(t: T) -> T {\n LL | |     t\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:67:9\n+  --> $DIR/could_be_const.rs:68:9\n    |\n LL | /         pub fn b(self, a: &A) -> B {\n LL | |             B\n LL | |         }\n    | |_________^\n \n-error: aborting due to 8 previous errors\n+error: this could be a `const fn`\n+  --> $DIR/could_be_const.rs:78:5\n+   |\n+LL | /     fn const_fn_stabilized_before_msrv(byte: u8) {\n+LL | |         byte.is_ascii_digit();\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "5c4fd466c04187df5abf52be6a504374c59c919b", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+// edition:2018\n \n #![allow(unused)]\n #![allow(\n@@ -125,10 +126,85 @@ mod issue6501 {\n     }\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_no_semicolon();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    test_closure();\n+async fn async_test_end_of_fn() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+    true\n+}\n+\n+async fn async_test_no_semicolon() -> bool {\n+    true\n+}\n+\n+async fn async_test_if_block() -> bool {\n+    if true {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+async fn async_test_match(x: bool) -> bool {\n+    match x {\n+        true => false,\n+        false => {\n+            true\n+        },\n+    }\n+}\n+\n+async fn async_test_closure() {\n+    let _ = || {\n+        true\n+    };\n+    let _ = || true;\n+}\n+\n+async fn async_test_macro_call() -> i32 {\n+    return the_answer!();\n+}\n+\n+async fn async_test_void_fun() {\n+    \n+}\n+\n+async fn async_test_void_if_fun(b: bool) {\n+    if b {\n+        \n+    } else {\n+        \n+    }\n+}\n+\n+async fn async_test_void_match(x: u32) {\n+    match x {\n+        0 => (),\n+        _ => {},\n+    }\n+}\n+\n+async fn async_read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n }\n+\n+async fn async_borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        String::from(\"test\")\n+    } else {\n+        String::new()\n+    }\n+}\n+\n+async fn async_test_return_in_macro() {\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n+fn main() {}"}, {"sha": "34811db7413a3ac5d90254dd7591c02b53b6556b", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+// edition:2018\n \n #![allow(unused)]\n #![allow(\n@@ -125,10 +126,85 @@ mod issue6501 {\n     }\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_no_semicolon();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    test_closure();\n+async fn async_test_end_of_fn() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+    return true;\n+}\n+\n+async fn async_test_no_semicolon() -> bool {\n+    return true;\n+}\n+\n+async fn async_test_if_block() -> bool {\n+    if true {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+async fn async_test_match(x: bool) -> bool {\n+    match x {\n+        true => return false,\n+        false => {\n+            return true;\n+        },\n+    }\n+}\n+\n+async fn async_test_closure() {\n+    let _ = || {\n+        return true;\n+    };\n+    let _ = || return true;\n+}\n+\n+async fn async_test_macro_call() -> i32 {\n+    return the_answer!();\n+}\n+\n+async fn async_test_void_fun() {\n+    return;\n+}\n+\n+async fn async_test_void_if_fun(b: bool) {\n+    if b {\n+        return;\n+    } else {\n+        return;\n+    }\n+}\n+\n+async fn async_test_void_match(x: u32) {\n+    match x {\n+        0 => (),\n+        _ => return,\n+    }\n+}\n+\n+async fn async_read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n }\n+\n+async fn async_borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        return String::from(\"test\");\n+    } else {\n+        return String::new();\n+    }\n+}\n+\n+async fn async_test_return_in_macro() {\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n+fn main() {}"}, {"sha": "74dda971fdabb632633f4a125ba15d6e2d5ad1a3", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 103, "deletions": 19, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,112 +1,196 @@\n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:23:5\n+  --> $DIR/needless_return.rs:24:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n    |\n    = note: `-D clippy::needless-return` implied by `-D warnings`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:27:5\n+  --> $DIR/needless_return.rs:28:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:32:9\n+  --> $DIR/needless_return.rs:33:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:34:9\n+  --> $DIR/needless_return.rs:35:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:40:17\n+  --> $DIR/needless_return.rs:41:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:42:13\n+  --> $DIR/needless_return.rs:43:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:49:9\n+  --> $DIR/needless_return.rs:50:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:51:16\n+  --> $DIR/needless_return.rs:52:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:59:5\n+  --> $DIR/needless_return.rs:60:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:64:9\n+  --> $DIR/needless_return.rs:65:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:66:9\n+  --> $DIR/needless_return.rs:67:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:73:14\n+  --> $DIR/needless_return.rs:74:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:88:9\n+  --> $DIR/needless_return.rs:89:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:90:9\n+  --> $DIR/needless_return.rs:91:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:111:32\n+  --> $DIR/needless_return.rs:112:32\n    |\n LL |         bar.unwrap_or_else(|_| return)\n    |                                ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:116:13\n+  --> $DIR/needless_return.rs:117:13\n    |\n LL |             return;\n    |             ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:118:20\n+  --> $DIR/needless_return.rs:119:20\n    |\n LL |         let _ = || return;\n    |                    ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:124:32\n+  --> $DIR/needless_return.rs:125:32\n    |\n LL |         res.unwrap_or_else(|_| return Foo)\n    |                                ^^^^^^^^^^ help: remove `return`: `Foo`\n \n-error: aborting due to 18 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:134:5\n+   |\n+LL |     return true;\n+   |     ^^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:138:5\n+   |\n+LL |     return true;\n+   |     ^^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:143:9\n+   |\n+LL |         return true;\n+   |         ^^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:145:9\n+   |\n+LL |         return false;\n+   |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:151:17\n+   |\n+LL |         true => return false,\n+   |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:153:13\n+   |\n+LL |             return true;\n+   |             ^^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:160:9\n+   |\n+LL |         return true;\n+   |         ^^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:162:16\n+   |\n+LL |     let _ = || return true;\n+   |                ^^^^^^^^^^^ help: remove `return`: `true`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:170:5\n+   |\n+LL |     return;\n+   |     ^^^^^^^ help: remove `return`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:175:9\n+   |\n+LL |         return;\n+   |         ^^^^^^^ help: remove `return`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:177:9\n+   |\n+LL |         return;\n+   |         ^^^^^^^ help: remove `return`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:184:14\n+   |\n+LL |         _ => return,\n+   |              ^^^^^^ help: replace `return` with an empty block: `{}`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:199:9\n+   |\n+LL |         return String::from(\"test\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:201:9\n+   |\n+LL |         return String::new();\n+   |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n+\n+error: aborting due to 32 previous errors\n "}, {"sha": "c4fcd7e70944c5ebc974916f88b81877a6c83102", "filename": "tests/ui/panic_in_result_fn_debug_assertions.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,44 +1,39 @@\n #![warn(clippy::panic_in_result_fn)]\n #![allow(clippy::unnecessary_wraps)]\n \n+// debug_assert should never trigger the `panic_in_result_fn` lint\n+\n struct A;\n \n impl A {\n-    fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n-    {\n+    fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> {\n         debug_assert!(x == 5, \"wrong argument\");\n         Ok(true)\n     }\n \n-    fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n-    {\n+    fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> {\n         debug_assert_eq!(x, 5);\n         Ok(true)\n     }\n \n-    fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n-    {\n+    fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> {\n         debug_assert_ne!(x, 1);\n         Ok(true)\n     }\n \n-    fn other_with_debug_assert_with_message(x: i32) // should not emit lint\n-    {\n+    fn other_with_debug_assert_with_message(x: i32) {\n         debug_assert!(x == 5, \"wrong argument\");\n     }\n \n-    fn other_with_debug_assert_eq(x: i32) // should not emit lint\n-    {\n+    fn other_with_debug_assert_eq(x: i32) {\n         debug_assert_eq!(x, 5);\n     }\n \n-    fn other_with_debug_assert_ne(x: i32) // should not emit lint\n-    {\n+    fn other_with_debug_assert_ne(x: i32) {\n         debug_assert_ne!(x, 1);\n     }\n \n-    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n-    {\n+    fn result_without_banned_functions() -> Result<bool, String> {\n         let debug_assert = \"debug_assert!\";\n         println!(\"No {}\", debug_assert);\n         Ok(true)"}, {"sha": "ec18e89698c56d6d2cc59a158adcdb3a0053e166", "filename": "tests/ui/panic_in_result_fn_debug_assertions.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/419bf6bbd827f07406447419d84a154ce9294aa8/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr?ref=419bf6bbd827f07406447419d84a154ce9294aa8", "patch": "@@ -1,57 +0,0 @@\n-error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:7:5\n-   |\n-LL | /     fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n-LL | |     {\n-LL | |         debug_assert!(x == 5, \"wrong argument\");\n-LL | |         Ok(true)\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n-note: return Err() instead of panicking\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:9:9\n-   |\n-LL |         debug_assert!(x == 5, \"wrong argument\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:13:5\n-   |\n-LL | /     fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n-LL | |     {\n-LL | |         debug_assert_eq!(x, 5);\n-LL | |         Ok(true)\n-LL | |     }\n-   | |_____^\n-   |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n-note: return Err() instead of panicking\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:15:9\n-   |\n-LL |         debug_assert_eq!(x, 5);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:19:5\n-   |\n-LL | /     fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n-LL | |     {\n-LL | |         debug_assert_ne!(x, 1);\n-LL | |         Ok(true)\n-LL | |     }\n-   | |_____^\n-   |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n-note: return Err() instead of panicking\n-  --> $DIR/panic_in_result_fn_debug_assertions.rs:21:9\n-   |\n-LL |         debug_assert_ne!(x, 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "93b236f7473d5f2d3d823ae63ce8edcd37d00515", "filename": "tests/ui/panicking_macros.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fpanicking_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fpanicking_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanicking_macros.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::unimplemented, clippy::unreachable, clippy::todo, clippy::panic)]\n-#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::assertions_on_constants, clippy::eq_op)]\n \n extern crate core;\n \n@@ -43,6 +43,18 @@ fn core_versions() {\n     unreachable!();\n }\n \n+fn debug_assert() {\n+    debug_assert!(true);\n+    debug_assert_eq!(true, true);\n+    debug_assert_ne!(true, false);\n+}\n+\n+fn debug_assert_msg() {\n+    debug_assert!(true, \"test\");\n+    debug_assert_eq!(true, true, \"test\");\n+    debug_assert_ne!(true, false, \"test\");\n+}\n+\n fn main() {\n     panic();\n     todo();"}, {"sha": "794ed542435d149910e44c4ecf712185b7df2355", "filename": "tests/ui/redundant_pattern_matching_drop_order.fixed", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+\n+// Issue #5746\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n+use std::task::Poll::{Pending, Ready};\n+\n+fn main() {\n+    let m = std::sync::Mutex::new((0, 0));\n+\n+    // Result\n+    if m.lock().is_ok() {}\n+    if Err::<(), _>(m.lock().unwrap().0).is_err() {}\n+\n+    {\n+        if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {}\n+    }\n+    if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {\n+    } else {\n+    }\n+    if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {}\n+    if Err::<std::sync::MutexGuard<()>, _>(()).is_err() {}\n+\n+    if Ok::<_, ()>(String::new()).is_ok() {}\n+    if Err::<(), _>((String::new(), ())).is_err() {}\n+\n+    // Option\n+    if Some(m.lock()).is_some() {}\n+    if Some(m.lock().unwrap().0).is_some() {}\n+\n+    {\n+        if None::<std::sync::MutexGuard<()>>.is_none() {}\n+    }\n+    if None::<std::sync::MutexGuard<()>>.is_none() {\n+    } else {\n+    }\n+\n+    if None::<std::sync::MutexGuard<()>>.is_none() {}\n+\n+    if Some(String::new()).is_some() {}\n+    if Some((String::new(), ())).is_some() {}\n+\n+    // Poll\n+    if Ready(m.lock()).is_ready() {}\n+    if Ready(m.lock().unwrap().0).is_ready() {}\n+\n+    {\n+        if Pending::<std::sync::MutexGuard<()>>.is_pending() {}\n+    }\n+    if Pending::<std::sync::MutexGuard<()>>.is_pending() {\n+    } else {\n+    }\n+\n+    if Pending::<std::sync::MutexGuard<()>>.is_pending() {}\n+\n+    if Ready(String::new()).is_ready() {}\n+    if Ready((String::new(), ())).is_ready() {}\n+}"}, {"sha": "b9c82d86f618b4041f6bb568d52e2d652e4934be", "filename": "tests/ui/redundant_pattern_matching_drop_order.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+\n+// Issue #5746\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n+use std::task::Poll::{Pending, Ready};\n+\n+fn main() {\n+    let m = std::sync::Mutex::new((0, 0));\n+\n+    // Result\n+    if let Ok(_) = m.lock() {}\n+    if let Err(_) = Err::<(), _>(m.lock().unwrap().0) {}\n+\n+    {\n+        if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+    }\n+    if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {\n+    } else {\n+    }\n+    if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+    if let Err(_) = Err::<std::sync::MutexGuard<()>, _>(()) {}\n+\n+    if let Ok(_) = Ok::<_, ()>(String::new()) {}\n+    if let Err(_) = Err::<(), _>((String::new(), ())) {}\n+\n+    // Option\n+    if let Some(_) = Some(m.lock()) {}\n+    if let Some(_) = Some(m.lock().unwrap().0) {}\n+\n+    {\n+        if let None = None::<std::sync::MutexGuard<()>> {}\n+    }\n+    if let None = None::<std::sync::MutexGuard<()>> {\n+    } else {\n+    }\n+\n+    if let None = None::<std::sync::MutexGuard<()>> {}\n+\n+    if let Some(_) = Some(String::new()) {}\n+    if let Some(_) = Some((String::new(), ())) {}\n+\n+    // Poll\n+    if let Ready(_) = Ready(m.lock()) {}\n+    if let Ready(_) = Ready(m.lock().unwrap().0) {}\n+\n+    {\n+        if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+    }\n+    if let Pending = Pending::<std::sync::MutexGuard<()>> {\n+    } else {\n+    }\n+\n+    if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+\n+    if let Ready(_) = Ready(String::new()) {}\n+    if let Ready(_) = Ready((String::new(), ())) {}\n+}"}, {"sha": "eb7aa70ee27385ba7da308fdb1c6bae86afb97ff", "filename": "tests/ui/redundant_pattern_matching_drop_order.stderr", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,171 @@\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:12:12\n+   |\n+LL |     if let Ok(_) = m.lock() {}\n+   |     -------^^^^^----------- help: try this: `if m.lock().is_ok()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:13:12\n+   |\n+LL |     if let Err(_) = Err::<(), _>(m.lock().unwrap().0) {}\n+   |     -------^^^^^^------------------------------------ help: try this: `if Err::<(), _>(m.lock().unwrap().0).is_err()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:16:16\n+   |\n+LL |         if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+   |         -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:18:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {\n+   |     -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:21:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+   |     -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:22:12\n+   |\n+LL |     if let Err(_) = Err::<std::sync::MutexGuard<()>, _>(()) {}\n+   |     -------^^^^^^------------------------------------------ help: try this: `if Err::<std::sync::MutexGuard<()>, _>(()).is_err()`\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:24:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, ()>(String::new()) {}\n+   |     -------^^^^^----------------------------- help: try this: `if Ok::<_, ()>(String::new()).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:25:12\n+   |\n+LL |     if let Err(_) = Err::<(), _>((String::new(), ())) {}\n+   |     -------^^^^^^------------------------------------ help: try this: `if Err::<(), _>((String::new(), ())).is_err()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:28:12\n+   |\n+LL |     if let Some(_) = Some(m.lock()) {}\n+   |     -------^^^^^^^----------------- help: try this: `if Some(m.lock()).is_some()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:29:12\n+   |\n+LL |     if let Some(_) = Some(m.lock().unwrap().0) {}\n+   |     -------^^^^^^^---------------------------- help: try this: `if Some(m.lock().unwrap().0).is_some()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:32:16\n+   |\n+LL |         if let None = None::<std::sync::MutexGuard<()>> {}\n+   |         -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:34:12\n+   |\n+LL |     if let None = None::<std::sync::MutexGuard<()>> {\n+   |     -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:38:12\n+   |\n+LL |     if let None = None::<std::sync::MutexGuard<()>> {}\n+   |     -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:40:12\n+   |\n+LL |     if let Some(_) = Some(String::new()) {}\n+   |     -------^^^^^^^---------------------- help: try this: `if Some(String::new()).is_some()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:41:12\n+   |\n+LL |     if let Some(_) = Some((String::new(), ())) {}\n+   |     -------^^^^^^^---------------------------- help: try this: `if Some((String::new(), ())).is_some()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:44:12\n+   |\n+LL |     if let Ready(_) = Ready(m.lock()) {}\n+   |     -------^^^^^^^^------------------ help: try this: `if Ready(m.lock()).is_ready()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:45:12\n+   |\n+LL |     if let Ready(_) = Ready(m.lock().unwrap().0) {}\n+   |     -------^^^^^^^^----------------------------- help: try this: `if Ready(m.lock().unwrap().0).is_ready()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:48:16\n+   |\n+LL |         if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+   |         -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:50:12\n+   |\n+LL |     if let Pending = Pending::<std::sync::MutexGuard<()>> {\n+   |     -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:54:12\n+   |\n+LL |     if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+   |     -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:56:12\n+   |\n+LL |     if let Ready(_) = Ready(String::new()) {}\n+   |     -------^^^^^^^^----------------------- help: try this: `if Ready(String::new()).is_ready()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:57:12\n+   |\n+LL |     if let Ready(_) = Ready((String::new(), ())) {}\n+   |     -------^^^^^^^^----------------------------- help: try this: `if Ready((String::new(), ())).is_ready()`\n+\n+error: aborting due to 22 previous errors\n+"}, {"sha": "997144772669be4fdabd45a0834deebf1c8c3388", "filename": "tests/ui/redundant_pattern_matching_option.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n fn main() {\n     if None::<()>.is_none() {}"}, {"sha": "8309847e18162796d787c4bb771bb5ffd7f58600", "filename": "tests/ui/redundant_pattern_matching_option.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n fn main() {\n     if let None = None::<()> {}"}, {"sha": "613a30d4a48453bbede0d3c9f4386a7b304938a3", "filename": "tests/ui/redundant_pattern_matching_option.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,49 +1,49 @@\n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:8:12\n+  --> $DIR/redundant_pattern_matching_option.rs:13:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:10:12\n+  --> $DIR/redundant_pattern_matching_option.rs:15:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:12:12\n+  --> $DIR/redundant_pattern_matching_option.rs:17:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:18:15\n+  --> $DIR/redundant_pattern_matching_option.rs:23:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:20:15\n+  --> $DIR/redundant_pattern_matching_option.rs:25:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:22:15\n+  --> $DIR/redundant_pattern_matching_option.rs:27:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:25:15\n+  --> $DIR/redundant_pattern_matching_option.rs:30:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:33:5\n+  --> $DIR/redundant_pattern_matching_option.rs:38:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -52,7 +52,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:38:5\n+  --> $DIR/redundant_pattern_matching_option.rs:43:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -61,7 +61,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:43:13\n+  --> $DIR/redundant_pattern_matching_option.rs:48:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -71,49 +71,49 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:49:20\n+  --> $DIR/redundant_pattern_matching_option.rs:54:20\n    |\n LL |     let _ = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:53:20\n+  --> $DIR/redundant_pattern_matching_option.rs:58:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:55:19\n+  --> $DIR/redundant_pattern_matching_option.rs:60:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:74:12\n+  --> $DIR/redundant_pattern_matching_option.rs:79:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:76:12\n+  --> $DIR/redundant_pattern_matching_option.rs:81:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:78:15\n+  --> $DIR/redundant_pattern_matching_option.rs:83:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:80:15\n+  --> $DIR/redundant_pattern_matching_option.rs:85:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:82:5\n+  --> $DIR/redundant_pattern_matching_option.rs:87:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -122,7 +122,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:87:5\n+  --> $DIR/redundant_pattern_matching_option.rs:92:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,"}, {"sha": "c297745380404030beee5b4487083387349af196", "filename": "tests/ui/redundant_pattern_matching_poll.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n use std::task::Poll::{self, Pending, Ready};\n "}, {"sha": "665c8c417504dbb1b54b4c48e1ef39216c6d6a83", "filename": "tests/ui/redundant_pattern_matching_poll.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n use std::task::Poll::{self, Pending, Ready};\n "}, {"sha": "5ecf024a733a31a376e589f87898357995aceb97", "filename": "tests/ui/redundant_pattern_matching_poll.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,43 +1,43 @@\n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:10:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:15:12\n    |\n LL |     if let Pending = Pending::<()> {}\n    |     -------^^^^^^^---------------- help: try this: `if Pending::<()>.is_pending()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:12:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:17:12\n    |\n LL |     if let Ready(_) = Ready(42) {}\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:14:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:19:12\n    |\n LL |     if let Ready(_) = Ready(42) {\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:20:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:25:15\n    |\n LL |     while let Ready(_) = Ready(42) {}\n    |     ----------^^^^^^^^------------ help: try this: `while Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:22:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:27:15\n    |\n LL |     while let Pending = Ready(42) {}\n    |     ----------^^^^^^^------------ help: try this: `while Ready(42).is_pending()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:24:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:29:15\n    |\n LL |     while let Pending = Pending::<()> {}\n    |     ----------^^^^^^^---------------- help: try this: `while Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:30:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:35:5\n    |\n LL | /     match Ready(42) {\n LL | |         Ready(_) => true,\n@@ -46,7 +46,7 @@ LL | |     };\n    | |_____^ help: try this: `Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:35:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:40:5\n    |\n LL | /     match Pending::<()> {\n LL | |         Ready(_) => false,\n@@ -55,7 +55,7 @@ LL | |     };\n    | |_____^ help: try this: `Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:40:13\n+  --> $DIR/redundant_pattern_matching_poll.rs:45:13\n    |\n LL |       let _ = match Pending::<()> {\n    |  _____________^\n@@ -65,49 +65,49 @@ LL | |     };\n    | |_____^ help: try this: `Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:46:20\n+  --> $DIR/redundant_pattern_matching_poll.rs:51:20\n    |\n LL |     let _ = if let Ready(_) = poll { true } else { false };\n    |             -------^^^^^^^^------- help: try this: `if poll.is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:50:20\n+  --> $DIR/redundant_pattern_matching_poll.rs:55:20\n    |\n LL |     let _ = if let Ready(_) = gen_poll() {\n    |             -------^^^^^^^^------------- help: try this: `if gen_poll().is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:52:19\n+  --> $DIR/redundant_pattern_matching_poll.rs:57:19\n    |\n LL |     } else if let Pending = gen_poll() {\n    |            -------^^^^^^^------------- help: try this: `if gen_poll().is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:68:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:73:12\n    |\n LL |     if let Ready(_) = Ready(42) {}\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:70:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:75:12\n    |\n LL |     if let Pending = Pending::<()> {}\n    |     -------^^^^^^^---------------- help: try this: `if Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:72:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:77:15\n    |\n LL |     while let Ready(_) = Ready(42) {}\n    |     ----------^^^^^^^^------------ help: try this: `while Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:74:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:79:15\n    |\n LL |     while let Pending = Pending::<()> {}\n    |     ----------^^^^^^^---------------- help: try this: `while Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:76:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:81:5\n    |\n LL | /     match Ready(42) {\n LL | |         Ready(_) => true,\n@@ -116,7 +116,7 @@ LL | |     };\n    | |_____^ help: try this: `Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:81:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:86:5\n    |\n LL | /     match Pending::<()> {\n LL | |         Ready(_) => false,"}, {"sha": "d7af5d762ae4a9f8485feba9e4ae915c95f76100", "filename": "tests/ui/redundant_pattern_matching_result.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_bool,\n     clippy::match_like_matches_macro,\n     clippy::unnecessary_wraps,\n-    deprecated\n+    deprecated,\n+    clippy::if_same_then_else\n )]\n \n fn main() {"}, {"sha": "e06d4485ae4f295e98ff223ebb04a48084c07ffe", "filename": "tests/ui/redundant_pattern_matching_result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_bool,\n     clippy::match_like_matches_macro,\n     clippy::unnecessary_wraps,\n-    deprecated\n+    deprecated,\n+    clippy::if_same_then_else\n )]\n \n fn main() {"}, {"sha": "e06f095da20c6a723f19ef019ca64de33684072b", "filename": "tests/ui/redundant_pattern_matching_result.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,37 +1,37 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:15:12\n+  --> $DIR/redundant_pattern_matching_result.rs:16:12\n    |\n LL |     if let Ok(_) = &result {}\n    |     -------^^^^^---------- help: try this: `if result.is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:17:12\n+  --> $DIR/redundant_pattern_matching_result.rs:18:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:19:12\n+  --> $DIR/redundant_pattern_matching_result.rs:20:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:21:15\n+  --> $DIR/redundant_pattern_matching_result.rs:22:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:23:15\n+  --> $DIR/redundant_pattern_matching_result.rs:24:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:33:5\n+  --> $DIR/redundant_pattern_matching_result.rs:34:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -40,7 +40,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:38:5\n+  --> $DIR/redundant_pattern_matching_result.rs:39:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -49,7 +49,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:43:5\n+  --> $DIR/redundant_pattern_matching_result.rs:44:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -58,7 +58,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:48:5\n+  --> $DIR/redundant_pattern_matching_result.rs:49:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -67,73 +67,73 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:53:20\n+  --> $DIR/redundant_pattern_matching_result.rs:54:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:59:20\n+  --> $DIR/redundant_pattern_matching_result.rs:60:20\n    |\n LL |     let _ = if let Ok(_) = gen_res() {\n    |             -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:61:19\n+  --> $DIR/redundant_pattern_matching_result.rs:62:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:84:19\n+  --> $DIR/redundant_pattern_matching_result.rs:85:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:85:16\n+  --> $DIR/redundant_pattern_matching_result.rs:86:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:91:12\n+  --> $DIR/redundant_pattern_matching_result.rs:92:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:92:15\n+  --> $DIR/redundant_pattern_matching_result.rs:93:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:110:12\n+  --> $DIR/redundant_pattern_matching_result.rs:111:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:112:12\n+  --> $DIR/redundant_pattern_matching_result.rs:113:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:114:15\n+  --> $DIR/redundant_pattern_matching_result.rs:115:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:116:15\n+  --> $DIR/redundant_pattern_matching_result.rs:117:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:118:5\n+  --> $DIR/redundant_pattern_matching_result.rs:119:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -142,7 +142,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:123:5\n+  --> $DIR/redundant_pattern_matching_result.rs:124:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,"}, {"sha": "6c7e2b854dc14b3379cc8b6448662861d4a88d02", "filename": "tests/ui/repl_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Frepl_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Frepl_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,5 +1,5 @@\n-#![allow(deprecated, invalid_value)]\n-#![warn(clippy::all)]\n+#![allow(deprecated, invalid_value, clippy::uninit_assumed_init)]\n+#![warn(clippy::mem_replace_with_uninit)]\n \n use std::mem;\n "}, {"sha": "f66b445b7b6a35249600338185df6d6bb7774bb6", "filename": "tests/ui/single_component_path_imports.fixed", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -19,3 +19,16 @@ fn main() {\n     // False positive #5154, shouldn't trigger lint.\n     m!();\n }\n+\n+mod hello_mod {\n+    \n+    #[allow(dead_code)]\n+    fn hello_mod() {}\n+}\n+\n+mod hi_mod {\n+    use self::regex::{Regex, RegexSet};\n+    use regex;\n+    #[allow(dead_code)]\n+    fn hi_mod() {}\n+}"}, {"sha": "09d4865859584ed792063e9e6bb510a1b679c012", "filename": "tests/ui/single_component_path_imports.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -19,3 +19,16 @@ fn main() {\n     // False positive #5154, shouldn't trigger lint.\n     m!();\n }\n+\n+mod hello_mod {\n+    use regex;\n+    #[allow(dead_code)]\n+    fn hello_mod() {}\n+}\n+\n+mod hi_mod {\n+    use self::regex::{Regex, RegexSet};\n+    use regex;\n+    #[allow(dead_code)]\n+    fn hi_mod() {}\n+}"}, {"sha": "7005fa8f125d36255c12bf6c8b93cf6644f64eba", "filename": "tests/ui/single_component_path_imports.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,10 +1,16 @@\n+error: this import is redundant\n+  --> $DIR/single_component_path_imports.rs:24:5\n+   |\n+LL |     use regex;\n+   |     ^^^^^^^^^^ help: remove it entirely\n+   |\n+   = note: `-D clippy::single-component-path-imports` implied by `-D warnings`\n+\n error: this import is redundant\n   --> $DIR/single_component_path_imports.rs:6:1\n    |\n LL | use regex;\n    | ^^^^^^^^^^ help: remove it entirely\n-   |\n-   = note: `-D clippy::single-component-path-imports` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "94117061b270da718a68172b91b920c1c18c434b", "filename": "tests/ui/single_component_path_imports_nested_first.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_nested_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_nested_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports_nested_first.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+#![warn(clippy::single_component_path_imports)]\n+#![allow(unused_imports)]\n+\n+use regex;\n+use serde as edres;\n+pub use serde;\n+\n+fn main() {\n+    regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n+}\n+\n+mod root_nested_use_mod {\n+    use {regex, serde};\n+    #[allow(dead_code)]\n+    fn root_nested_use_mod() {}\n+}"}, {"sha": "0c3256c1ce43a71ea37159b4a65991603e493a59", "filename": "tests/ui/single_component_path_imports_nested_first.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_nested_first.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_nested_first.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports_nested_first.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,25 @@\n+error: this import is redundant\n+  --> $DIR/single_component_path_imports_nested_first.rs:14:10\n+   |\n+LL |     use {regex, serde};\n+   |          ^^^^^\n+   |\n+   = note: `-D clippy::single-component-path-imports` implied by `-D warnings`\n+   = help: remove this import\n+\n+error: this import is redundant\n+  --> $DIR/single_component_path_imports_nested_first.rs:14:17\n+   |\n+LL |     use {regex, serde};\n+   |                 ^^^^^\n+   |\n+   = help: remove this import\n+\n+error: this import is redundant\n+  --> $DIR/single_component_path_imports_nested_first.rs:5:1\n+   |\n+LL | use regex;\n+   | ^^^^^^^^^^ help: remove it entirely\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "94319ade0ac4b9672ad2064bab6844db2e634887", "filename": "tests/ui/single_component_path_imports_self_after.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_self_after.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_self_after.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports_self_after.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+#![warn(clippy::single_component_path_imports)]\n+#![allow(unused_imports)]\n+\n+use self::regex::{Regex as xeger, RegexSet as tesxeger};\n+pub use self::{\n+    regex::{Regex, RegexSet},\n+    some_mod::SomeType,\n+};\n+use regex;\n+\n+mod some_mod {\n+    pub struct SomeType;\n+}\n+\n+fn main() {}"}, {"sha": "c7437b234566a95f08dd4794f7cecc2af1430adf", "filename": "tests/ui/single_component_path_imports_self_before.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_self_before.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_component_path_imports_self_before.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports_self_before.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+#![warn(clippy::single_component_path_imports)]\n+#![allow(unused_imports)]\n+\n+use regex;\n+\n+use self::regex::{Regex as xeger, RegexSet as tesxeger};\n+pub use self::{\n+    regex::{Regex, RegexSet},\n+    some_mod::SomeType,\n+};\n+\n+mod some_mod {\n+    pub struct SomeType;\n+}\n+\n+fn main() {}"}, {"sha": "b1819e08d53bf5dc9054e41cde25c580077082c5", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -135,6 +135,14 @@ fn if_suggestion() {\n         Bar::A => println!(),\n         _ => (),\n     }\n+\n+    // issue #7038\n+    struct X;\n+    let x = Some(X);\n+    match x {\n+        None => println!(),\n+        _ => (),\n+    };\n }\n \n macro_rules! single_match {"}, {"sha": "9ef2a8668a6faffdcb9e92757bc742b597e0db1a", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -119,5 +119,14 @@ LL | |         _ => (),\n LL | |     }\n    | |_____^ help: try this: `if let Bar::A = x { println!() }`\n \n-error: aborting due to 12 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:142:5\n+   |\n+LL | /     match x {\n+LL | |         None => println!(),\n+LL | |         _ => (),\n+LL | |     };\n+   | |_____^ help: try this: `if let None = x { println!() }`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "df2256e4f97de98afe0285e587ac9924c000fb3a", "filename": "tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_bytes!(\"entry_unfixable.rs\");\n+    let includestr = include_bytes!(\"string_lit_as_bytes.rs\");\n \n     let _ = b\"string with newline\\t\\n\";\n }"}, {"sha": "c6bf8f732ed9f615d1ea2d660d6ed7602513270b", "filename": "tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n+    let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n \n     let _ = \"string with newline\\t\\n\".as_bytes();\n }"}, {"sha": "f47d6161c6cf2c8869b90783eebd684581ee9a91", "filename": "tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -27,8 +27,8 @@ LL |     let bs = \"lit to owned\".to_owned().into_bytes();\n error: calling `as_bytes()` on `include_str!(..)`\n   --> $DIR/string_lit_as_bytes.rs:25:22\n    |\n-LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n+LL |     let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"string_lit_as_bytes.rs\")`\n \n error: calling `as_bytes()` on a string literal\n   --> $DIR/string_lit_as_bytes.rs:27:13"}, {"sha": "547615b10d9fb11741e2d9e59a1dbc2cc26f53cd", "filename": "tests/ui/suspicious_else_formatting.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsuspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsuspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -40,6 +40,7 @@ fn main() {\n     {\n     }\n \n+    // This is fine, though weird. Allman style braces on the else.\n     if foo() {\n     }\n     else\n@@ -76,4 +77,29 @@ fn main() {\n     }\n     if foo() {\n     }\n+\n+    // Almost Allman style braces. Lint these.\n+    if foo() {\n+    }\n+\n+    else\n+    {\n+\n+    }\n+\n+    if foo() {\n+    }\n+    else\n+\n+    {\n+\n+    }\n+\n+    // #3864 - Allman style braces\n+    if foo()\n+    {\n+    }\n+    else\n+    {\n+    }\n }"}, {"sha": "d8d67b4138ab3b95c9f107c4265ead6548416846", "filename": "tests/ui/suspicious_else_formatting.stderr", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsuspicious_else_formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fsuspicious_else_formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -41,37 +41,50 @@ LL | |     {\n    |\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n \n-error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:44:6\n+error: this is an `else if` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:51:6\n    |\n-LL |       }\n+LL |       } else\n    |  ______^\n-LL | |     else\n-LL | |     {\n+LL | |     if foo() { // the span of the above error should continue here\n    | |____^\n    |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n \n error: this is an `else if` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:50:6\n+  --> $DIR/suspicious_else_formatting.rs:56:6\n    |\n-LL |       } else\n+LL |       }\n    |  ______^\n+LL | |     else\n LL | |     if foo() { // the span of the above error should continue here\n    | |____^\n    |\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n \n-error: this is an `else if` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:55:6\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:83:6\n    |\n LL |       }\n    |  ______^\n+LL | |\n LL | |     else\n-LL | |     if foo() { // the span of the above error should continue here\n+LL | |     {\n    | |____^\n    |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:91:6\n+   |\n+LL |       }\n+   |  ______^\n+LL | |     else\n+LL | |\n+LL | |     {\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "264194419c7396680250c34fefb7ed935e0dc639", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -160,3 +160,11 @@ pub fn poll_next(ready: bool) -> Poll<Option<io::Result<()>>> {\n \n     Poll::Ready(None)\n }\n+\n+// Tests that `return` is not duplicated\n+pub fn try_return(x: bool) -> Result<i32, i32> {\n+    if x {\n+        return Err(42);\n+    }\n+    Ok(0)\n+}"}, {"sha": "bc6979bf457199e79271e9bd3bc0a12580d242ea", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -160,3 +160,11 @@ pub fn poll_next(ready: bool) -> Poll<Option<io::Result<()>>> {\n \n     Poll::Ready(None)\n }\n+\n+// Tests that `return` is not duplicated\n+pub fn try_return(x: bool) -> Result<i32, i32> {\n+    if x {\n+        return Err(42)?;\n+    }\n+    Ok(0)\n+}"}, {"sha": "8f332a9b6492caf32c24c28edf46fec5c03eaa1d", "filename": "tests/ui/try_err.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Ftry_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -74,5 +74,11 @@ error: returning an `Err(_)` with the `?` operator\n LL |         Err(io::ErrorKind::NotFound)?\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Some(Err(io::ErrorKind::NotFound.into())))`\n \n-error: aborting due to 10 previous errors\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:167:16\n+   |\n+LL |         return Err(42)?;\n+   |                ^^^^^^^^ help: try this: `Err(42)`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "1ed3883c1f06059285c858c40323eec9b069de77", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -1,6 +1,6 @@\n #![feature(stmt_expr_attributes)]\n \n-use std::mem::MaybeUninit;\n+use std::mem::{self, MaybeUninit};\n \n fn main() {\n     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n@@ -19,4 +19,7 @@ fn main() {\n \n     // This is OK, because all constitutent types are uninit-compatible.\n     let _: (MaybeUninit<usize>, [MaybeUninit<bool>; 2]) = unsafe { MaybeUninit::uninit().assume_init() };\n+\n+    // Was a false negative.\n+    let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n }"}, {"sha": "85b64a8419ab021bd36585ebde6e9431e84301e6", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -12,5 +12,11 @@ error: this call for this type may be undefined behavior\n LL |     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: this call for this type may be undefined behavior\n+  --> $DIR/uninit.rs:24:29\n+   |\n+LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "1185eaa1d552fecda9aef32d1f3ed574384332e6", "filename": "tests/ui/unnecessary_self_imports.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_self_imports.fixed?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_self_imports)]\n+#![allow(unused_imports, dead_code)]\n+\n+use std::collections::hash_map::{self, *};\n+use std::fs as alias;\n+use std::io::{self, Read};\n+use std::rc;\n+\n+fn main() {}"}, {"sha": "56bfbc09402adcd40cb1b27e2efad035ace7a459", "filename": "tests/ui/unnecessary_self_imports.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_self_imports.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_self_imports)]\n+#![allow(unused_imports, dead_code)]\n+\n+use std::collections::hash_map::{self, *};\n+use std::fs::{self as alias};\n+use std::io::{self, Read};\n+use std::rc::{self};\n+\n+fn main() {}"}, {"sha": "83a5618c983d313dc0ab895da9cd9346b0661a92", "filename": "tests/ui/unnecessary_self_imports.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Funnecessary_self_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_self_imports.stderr?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -0,0 +1,23 @@\n+error: import ending with `::{self}`\n+  --> $DIR/unnecessary_self_imports.rs:6:1\n+   |\n+LL | use std::fs::{self as alias};\n+   | ^^^^^^^^^--------------------\n+   |          |\n+   |          help: consider omitting `::{self}`: `fs as alias;`\n+   |\n+   = note: `-D clippy::unnecessary-self-imports` implied by `-D warnings`\n+   = note: this will slightly change semantics; any non-module items at the same path will also be imported\n+\n+error: import ending with `::{self}`\n+  --> $DIR/unnecessary_self_imports.rs:8:1\n+   |\n+LL | use std::rc::{self};\n+   | ^^^^^^^^^-----------\n+   |          |\n+   |          help: consider omitting `::{self}`: `rc;`\n+   |\n+   = note: this will slightly change semantics; any non-module items at the same path will also be imported\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ae3a740d405d6fc103c8b2f33f8381cb6d6584cf", "filename": "tests/ui/wrong_self_convention2.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fwrong_self_convention2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/tests%2Fui%2Fwrong_self_convention2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.rs?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -30,3 +30,15 @@ mod issue6983 {\n         }\n     }\n }\n+\n+mod issue7032 {\n+    trait Foo {\n+        fn from_usize(x: usize) -> Self;\n+    }\n+    // don't trigger\n+    impl Foo for usize {\n+        fn from_usize(x: usize) -> Self {\n+            x\n+        }\n+    }\n+}"}, {"sha": "27ecb532dd00e97bbaa2672049c03e64af9e5ef3", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02bf692169e1f2908169da8f870f8b324a4e6a17/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/02bf692169e1f2908169da8f870f8b324a4e6a17/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=02bf692169e1f2908169da8f870f8b324a4e6a17", "patch": "@@ -133,7 +133,7 @@\n             opacity: 30%;\n         }\n \n-        p > code {\n+        :not(pre) > code {\n             color: var(--inline-code-color);\n             background-color: var(--inline-code-bg);\n         }"}]}