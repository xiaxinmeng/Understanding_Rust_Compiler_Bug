{"sha": "c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZWRiOWY5NzgyNjFhYTBjMzEzZjNiOTEzMWJkZDBkMDlhY2JkNmI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T07:14:20Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T07:14:20Z"}, "message": "More work for multiple int sizes.", "tree": {"sha": "9c9f3c601b69f296a18778b2ec5daefa7aeedc6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c9f3c601b69f296a18778b2ec5daefa7aeedc6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "html_url": "https://github.com/rust-lang/rust/commit/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397dbd909ab1a91bc2136ba32ebd9521977a42a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/397dbd909ab1a91bc2136ba32ebd9521977a42a1", "html_url": "https://github.com/rust-lang/rust/commit/397dbd909ab1a91bc2136ba32ebd9521977a42a1"}], "stats": {"total": 187, "additions": 122, "deletions": 65}, "files": [{"sha": "887a69f2587962345e3128ccd1f4a325f9407dc8", "filename": "src/interpreter.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "patch": "@@ -36,16 +36,6 @@ impl fmt::Display for EvalError {\n     }\n }\n \n-// #[derive(Clone, Debug, PartialEq)]\n-// enum Value {\n-//     Uninit,\n-//     Bool(bool),\n-//     Int(i64), // FIXME(tsion): Should be bit-width aware.\n-//     Pointer(Pointer),\n-//     Adt { variant: usize, data_ptr: Pointer },\n-//     Func(def_id::DefId),\n-// }\n-\n /// A stack frame.\n struct Frame<'a, 'tcx: 'a> {\n     /// The MIR for the fucntion called on this frame.\n@@ -87,6 +77,15 @@ struct Interpreter<'a, 'tcx: 'a> {\n     stack: Vec<Frame<'a, 'tcx>>,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum PrimVal {\n+    Bool(bool),\n+    I8(i8),\n+    I16(i16),\n+    I32(i32),\n+    I64(i64),\n+}\n+\n impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n@@ -109,7 +108,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n             let repr = self.ty_to_repr(arg_decl.ty);\n             let dest = self.memory.allocate(repr.size());\n-            let src = try!(self.operand_to_ptr(arg_operand));\n+            let (src, _) = try!(self.eval_operand(arg_operand));\n             try!(self.memory.copy(src, dest, repr.size()));\n             locals.push(dest);\n         }\n@@ -161,22 +160,22 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 Goto { target } => current_block = target,\n \n                 If { ref cond, targets: (then_target, else_target) } => {\n-                    let cond_ptr = try!(self.operand_to_ptr(cond));\n+                    let (cond_ptr, _) = try!(self.eval_operand(cond));\n                     let cond_val = try!(self.memory.read_bool(cond_ptr));\n                     current_block = if cond_val { then_target } else { else_target };\n                 }\n \n                 SwitchInt { ref discr, ref values, ref targets, .. } => {\n                     // FIXME(tsion): Handle non-integer switch types.\n-                    let discr_ptr = try!(self.lvalue_to_ptr(discr));\n-                    let discr_val = try!(self.memory.read_int(discr_ptr));\n+                    let (discr_ptr, discr_repr) = try!(self.eval_lvalue(discr));\n+                    let discr_val = try!(self.memory.read_i64(discr_ptr));\n \n                     // Branch to the `otherwise` case by default, if no match is found.\n                     current_block = targets[targets.len() - 1];\n \n                     for (index, val_const) in values.iter().enumerate() {\n                         let ptr = try!(self.const_to_ptr(val_const));\n-                        let val = try!(self.memory.read_int(ptr));\n+                        let val = try!(self.memory.read_i64(ptr));\n                         if discr_val == val {\n                             current_block = targets[index];\n                             break;\n@@ -241,40 +240,43 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                       right_operand: &mir::Operand<'tcx>, dest: Pointer) -> EvalResult<()>\n     {\n         // FIXME(tsion): Check for non-integer binary operations.\n-        let left = try!(self.operand_to_ptr(left_operand));\n-        let right = try!(self.operand_to_ptr(right_operand));\n-        let l = try!(self.memory.read_int(left));\n-        let r = try!(self.memory.read_int(right));\n+        let (left, left_repr) = try!(self.eval_operand(left_operand));\n+        let (right, right_repr) = try!(self.eval_operand(right_operand));\n+\n+        let left_val = try!(self.memory.read_primval(left, &left_repr));\n+        let right_val = try!(self.memory.read_primval(right, &right_repr));\n \n         use rustc::mir::repr::BinOp::*;\n-        let n = match bin_op {\n-            Add    => l + r,\n-            Sub    => l - r,\n-            Mul    => l * r,\n-            Div    => l / r,\n-            Rem    => l % r,\n-            BitXor => l ^ r,\n-            BitAnd => l & r,\n-            BitOr  => l | r,\n-            Shl    => l << r,\n-            Shr    => l >> r,\n-            _      => unimplemented!(),\n-            // Eq     => Value::Bool(l == r),\n-            // Lt     => Value::Bool(l < r),\n-            // Le     => Value::Bool(l <= r),\n-            // Ne     => Value::Bool(l != r),\n-            // Ge     => Value::Bool(l >= r),\n-            // Gt     => Value::Bool(l > r),\n+        use self::PrimVal::*;\n+        let result_val = match (bin_op, left_val, right_val) {\n+            (Add,    I64(l), I64(r)) => I64(l + r),\n+            (Sub,    I64(l), I64(r)) => I64(l - r),\n+            (Mul,    I64(l), I64(r)) => I64(l * r),\n+            (Div,    I64(l), I64(r)) => I64(l / r),\n+            (Rem,    I64(l), I64(r)) => I64(l % r),\n+            (BitXor, I64(l), I64(r)) => I64(l ^ r),\n+            (BitAnd, I64(l), I64(r)) => I64(l & r),\n+            (BitOr,  I64(l), I64(r)) => I64(l | r),\n+            (Shl,    I64(l), I64(r)) => I64(l << r),\n+            (Shr,    I64(l), I64(r)) => I64(l >> r),\n+            (Eq,     I64(l), I64(r)) => Bool(l == r),\n+            (Lt,     I64(l), I64(r)) => Bool(l < r),\n+            (Le,     I64(l), I64(r)) => Bool(l <= r),\n+            (Ne,     I64(l), I64(r)) => Bool(l != r),\n+            (Ge,     I64(l), I64(r)) => Bool(l >= r),\n+            (Gt,     I64(l), I64(r)) => Bool(l > r),\n+            _ => unimplemented!(),\n         };\n-        self.memory.write_int(dest, n)\n+\n+        self.memory.write_primval(dest, result_val)\n     }\n \n     fn assign_to_product(&mut self, dest: Pointer, dest_repr: &Repr,\n                          operands: &[mir::Operand<'tcx>]) -> EvalResult<()> {\n         match *dest_repr {\n             Repr::Product { ref fields, .. } => {\n                 for (field, operand) in fields.iter().zip(operands) {\n-                    let src = try!(self.operand_to_ptr(operand));\n+                    let (src, _) = try!(self.eval_operand(operand));\n                     try!(self.memory.copy(src, dest.offset(field.offset), field.repr.size()));\n                 }\n             }\n@@ -286,30 +288,32 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n         -> EvalResult<()>\n     {\n-        let dest = try!(self.lvalue_to_ptr(lvalue));\n-        let dest_ty = self.current_frame().mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n-        let dest_repr = self.ty_to_repr(dest_ty);\n+        let (dest, dest_repr) = try!(self.eval_lvalue(lvalue));\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let src = try!(self.operand_to_ptr(operand));\n+                let (src, _) = try!(self.eval_operand(operand));\n                 self.memory.copy(src, dest, dest_repr.size())\n             }\n \n             BinaryOp(bin_op, ref left, ref right) =>\n                 self.eval_binary_op(bin_op, left, right, dest),\n \n             UnaryOp(un_op, ref operand) => {\n-                // FIXME(tsion): Check for non-integer operations.\n-                let ptr = try!(self.operand_to_ptr(operand));\n-                let m = try!(self.memory.read_int(ptr));\n+                let (src, src_repr) = try!(self.eval_operand(operand));\n+                let src_val = try!(self.memory.read_primval(src, &src_repr));\n+\n                 use rustc::mir::repr::UnOp::*;\n-                let n = match un_op {\n-                    Not => !m,\n-                    Neg => -m,\n+                use self::PrimVal::*;\n+                let result_val = match (un_op, src_val) {\n+                    (Not, Bool(b)) => Bool(!b),\n+                    (Not, I64(n)) => I64(!n),\n+                    (Neg, I64(n)) => I64(-n),\n+                    _ => unimplemented!(),\n                 };\n-                self.memory.write_int(dest, n)\n+\n+                self.memory.write_primval(dest, result_val)\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -346,22 +350,25 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n+    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<(Pointer, Repr)> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n+            Consume(ref lvalue) => self.eval_lvalue(lvalue),\n \n-            Constant(ref constant) => {\n+            Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n-                match constant.literal {\n-                    Value { ref value } => self.const_to_ptr(value),\n+                match *literal {\n+                    Value { ref value } => Ok((\n+                        try!(self.const_to_ptr(value)),\n+                        self.ty_to_repr(ty),\n+                    )),\n                     ref l => panic!(\"can't handle item literal: {:?}\", l),\n                 }\n             }\n         }\n     }\n \n-    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Pointer> {\n+    fn eval_lvalue(&self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<(Pointer, Repr)> {\n         let frame = self.current_frame();\n \n         use rustc::mir::repr::Lvalue::*;\n@@ -374,7 +381,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             ref l => panic!(\"can't handle lvalue: {:?}\", l),\n         };\n \n-        Ok(ptr)\n+        let ty = self.current_frame().mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+        Ok((ptr, self.ty_to_repr(ty)))\n \n         //     mir::Lvalue::Projection(ref proj) => {\n         //         let base_ptr = self.lvalue_to_ptr(&proj.base);\n@@ -419,7 +427,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             Int(n) => {\n                 // TODO(tsion): Check int constant type.\n                 let ptr = self.memory.allocate(8);\n-                try!(self.memory.write_int(ptr, n));\n+                try!(self.memory.write_i64(ptr, n));\n                 Ok(ptr)\n             }\n             Uint(_u)          => unimplemented!(),"}, {"sha": "af3911083bf6532bdb1a4f04166763386757506c", "filename": "src/memory.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1edb9f978261aa0c313f3b9131bdd0d09acbd6b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c1edb9f978261aa0c313f3b9131bdd0d09acbd6b", "patch": "@@ -2,7 +2,7 @@ use byteorder::{self, ByteOrder};\n use std::collections::HashMap;\n use std::ptr;\n \n-use interpreter::{EvalError, EvalResult};\n+use interpreter::{EvalError, EvalResult, PrimVal};\n \n pub struct Memory {\n     next_id: u64,\n@@ -119,14 +119,25 @@ impl Memory {\n         Ok(())\n     }\n \n-    pub fn read_int(&self, ptr: Pointer) -> EvalResult<i64> {\n-        self.get_bytes(ptr, 8).map(byteorder::NativeEndian::read_i64)\n+    pub fn read_primval(&self, ptr: Pointer, repr: &Repr) -> EvalResult<PrimVal> {\n+        match *repr {\n+            Repr::Bool => self.read_bool(ptr).map(PrimVal::Bool),\n+            Repr::Int(IntRepr::I8) => self.read_i8(ptr).map(PrimVal::I8),\n+            Repr::Int(IntRepr::I16) => self.read_i16(ptr).map(PrimVal::I16),\n+            Repr::Int(IntRepr::I32) => self.read_i32(ptr).map(PrimVal::I32),\n+            Repr::Int(IntRepr::I64) => self.read_i64(ptr).map(PrimVal::I64),\n+            _ => panic!(\"primitive read of non-primitive: {:?}\", repr),\n+        }\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i64) -> EvalResult<()> {\n-        let bytes = try!(self.get_bytes_mut(ptr, 8));\n-        byteorder::NativeEndian::write_i64(bytes, n);\n-        Ok(())\n+    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<()> {\n+        match val {\n+            PrimVal::Bool(b) => self.write_bool(ptr, b),\n+            PrimVal::I8(n) => self.write_i8(ptr, n),\n+            PrimVal::I16(n) => self.write_i16(ptr, n),\n+            PrimVal::I32(n) => self.write_i32(ptr, n),\n+            PrimVal::I64(n) => self.write_i64(ptr, n),\n+        }\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<bool> {\n@@ -143,6 +154,44 @@ impl Memory {\n         bytes[0] = b as u8;\n         Ok(())\n     }\n+\n+    pub fn read_i8(&self, ptr: Pointer) -> EvalResult<i8> {\n+        self.get_bytes(ptr, 1).map(|b| b[0] as i8)\n+    }\n+\n+    pub fn write_i8(&mut self, ptr: Pointer, n: i8) -> EvalResult<()> {\n+        self.get_bytes_mut(ptr, 1).map(|b| b[0] = n as u8)\n+    }\n+\n+    pub fn read_i16(&self, ptr: Pointer) -> EvalResult<i16> {\n+        self.get_bytes(ptr, 2).map(byteorder::NativeEndian::read_i16)\n+    }\n+\n+    pub fn write_i16(&mut self, ptr: Pointer, n: i16) -> EvalResult<()> {\n+        let bytes = try!(self.get_bytes_mut(ptr, 2));\n+        byteorder::NativeEndian::write_i16(bytes, n);\n+        Ok(())\n+    }\n+\n+    pub fn read_i32(&self, ptr: Pointer) -> EvalResult<i32> {\n+        self.get_bytes(ptr, 4).map(byteorder::NativeEndian::read_i32)\n+    }\n+\n+    pub fn write_i32(&mut self, ptr: Pointer, n: i32) -> EvalResult<()> {\n+        let bytes = try!(self.get_bytes_mut(ptr, 4));\n+        byteorder::NativeEndian::write_i32(bytes, n);\n+        Ok(())\n+    }\n+\n+    pub fn read_i64(&self, ptr: Pointer) -> EvalResult<i64> {\n+        self.get_bytes(ptr, 8).map(byteorder::NativeEndian::read_i64)\n+    }\n+\n+    pub fn write_i64(&mut self, ptr: Pointer, n: i64) -> EvalResult<()> {\n+        let bytes = try!(self.get_bytes_mut(ptr, 8));\n+        byteorder::NativeEndian::write_i64(bytes, n);\n+        Ok(())\n+    }\n }\n \n impl Allocation {"}]}