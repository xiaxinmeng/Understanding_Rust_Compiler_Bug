{"sha": "591eeff22af299043637e75bb5735c3c65e0c7fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MWVlZmYyMmFmMjk5MDQzNjM3ZTc1YmI1NzM1YzNjNjVlMGM3ZmU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-21T18:27:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-25T18:01:02Z"}, "message": "Change ManuallyDrop from an union to a struct and make it a lang item.", "tree": {"sha": "8825672f6042850602420a5268e46f5b3ffa52d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8825672f6042850602420a5268e46f5b3ffa52d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/591eeff22af299043637e75bb5735c3c65e0c7fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/591eeff22af299043637e75bb5735c3c65e0c7fe", "html_url": "https://github.com/rust-lang/rust/commit/591eeff22af299043637e75bb5735c3c65e0c7fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/591eeff22af299043637e75bb5735c3c65e0c7fe/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fefe81605d6111faa8dbb3635ab2c51d59de740a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fefe81605d6111faa8dbb3635ab2c51d59de740a", "html_url": "https://github.com/rust-lang/rust/commit/fefe81605d6111faa8dbb3635ab2c51d59de740a"}], "stats": {"total": 320, "additions": 225, "deletions": 95}, "files": [{"sha": "8643219cb61153307944351cb5ff60edb097564c", "filename": "src/libcore/manually_drop_stage0.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibcore%2Fmanually_drop_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibcore%2Fmanually_drop_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanually_drop_stage0.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n+///\n+/// This wrapper is 0-cost.\n+///\n+/// # Examples\n+///\n+/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n+/// the type:\n+///\n+/// ```rust\n+/// use std::mem::ManuallyDrop;\n+/// struct Peach;\n+/// struct Banana;\n+/// struct Melon;\n+/// struct FruitBox {\n+///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n+///     peach: ManuallyDrop<Peach>,\n+///     melon: Melon, // Field that\u2019s independent of the other two.\n+///     banana: ManuallyDrop<Banana>,\n+/// }\n+///\n+/// impl Drop for FruitBox {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // Explicit ordering in which field destructors are run specified in the intuitive\n+///             // location \u2013 the destructor of the structure containing the fields.\n+///             // Moreover, one can now reorder fields within the struct however much they want.\n+///             ManuallyDrop::drop(&mut self.peach);\n+///             ManuallyDrop::drop(&mut self.banana);\n+///         }\n+///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n+///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+#[allow(unions_with_drop_fields)]\n+#[derive(Copy)]\n+pub union ManuallyDrop<T>{ value: T }\n+\n+impl<T> ManuallyDrop<T> {\n+    /// Wrap a value to be manually dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// ManuallyDrop::new(Box::new(()));\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[rustc_const_unstable(feature = \"const_manually_drop_new\")]\n+    #[inline]\n+    pub const fn new(value: T) -> ManuallyDrop<T> {\n+        ManuallyDrop { value: value }\n+    }\n+\n+    /// Extract the value from the ManuallyDrop container.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// let x = ManuallyDrop::new(Box::new(()));\n+    /// let _: Box<()> = ManuallyDrop::into_inner(x);\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n+        unsafe {\n+            slot.value\n+        }\n+    }\n+\n+    /// Manually drops the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function runs the destructor of the contained value and thus the wrapped value\n+    /// now represents uninitialized data. It is up to the user of this method to ensure the\n+    /// uninitialized data is not actually used.\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n+        ptr::drop_in_place(&mut slot.value)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T> Deref for ManuallyDrop<T> {\n+    type Target = T;\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            &self.value\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T> DerefMut for ManuallyDrop<T> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe {\n+            &mut self.value\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n+    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        unsafe {\n+            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: Clone> Clone for ManuallyDrop<T> {\n+    fn clone(&self) -> Self {\n+        ManuallyDrop::new(self.deref().clone())\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        self.deref_mut().clone_from(source);\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: Default> Default for ManuallyDrop<T> {\n+    fn default() -> Self {\n+        ManuallyDrop::new(Default::default())\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: PartialEq> PartialEq for ManuallyDrop<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.deref().eq(other)\n+    }\n+\n+    fn ne(&self, other: &Self) -> bool {\n+        self.deref().ne(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: Eq> Eq for ManuallyDrop<T> {}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: PartialOrd> PartialOrd for ManuallyDrop<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<::cmp::Ordering> {\n+        self.deref().partial_cmp(other)\n+    }\n+\n+    fn lt(&self, other: &Self) -> bool {\n+        self.deref().lt(other)\n+    }\n+\n+    fn le(&self, other: &Self) -> bool {\n+        self.deref().le(other)\n+    }\n+\n+    fn gt(&self, other: &Self) -> bool {\n+        self.deref().gt(other)\n+    }\n+\n+    fn ge(&self, other: &Self) -> bool {\n+        self.deref().ge(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: Ord> Ord for ManuallyDrop<T> {\n+    fn cmp(&self, other: &Self) -> ::cmp::Ordering {\n+        self.deref().cmp(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n+impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n+    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+        self.deref().hash(state);\n+    }\n+}"}, {"sha": "1a54f03bb00673ed2c2a431e7e76ef2a3ffd333f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 16, "deletions": 92, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -918,7 +918,6 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n-\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///\n /// This wrapper is 0-cost.\n@@ -954,11 +953,18 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n ///     }\n /// }\n /// ```\n+#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[allow(unions_with_drop_fields)]\n-#[derive(Copy)]\n-pub union ManuallyDrop<T>{ value: T }\n+#[lang = \"manually_drop\"]\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ManuallyDrop<T> {\n+    value: T,\n+}\n+\n+#[cfg(stage0)]\n+include!(\"manually_drop_stage0.rs\");\n \n+#[cfg(not(stage0))]\n impl<T> ManuallyDrop<T> {\n     /// Wrap a value to be manually dropped.\n     ///\n@@ -972,7 +978,7 @@ impl<T> ManuallyDrop<T> {\n     #[rustc_const_unstable(feature = \"const_manually_drop_new\")]\n     #[inline]\n     pub const fn new(value: T) -> ManuallyDrop<T> {\n-        ManuallyDrop { value: value }\n+        ManuallyDrop { value }\n     }\n \n     /// Extract the value from the ManuallyDrop container.\n@@ -987,9 +993,7 @@ impl<T> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n-        unsafe {\n-            slot.value\n-        }\n+        slot.value\n     }\n \n     /// Manually drops the contained value.\n@@ -1006,102 +1010,22 @@ impl<T> ManuallyDrop<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n impl<T> Deref for ManuallyDrop<T> {\n     type Target = T;\n     #[inline]\n     fn deref(&self) -> &Self::Target {\n-        unsafe {\n-            &self.value\n-        }\n+        &self.value\n     }\n }\n \n+#[cfg(not(stage0))]\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n impl<T> DerefMut for ManuallyDrop<T> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe {\n-            &mut self.value\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n-    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n-        unsafe {\n-            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Clone> Clone for ManuallyDrop<T> {\n-    fn clone(&self) -> Self {\n-        ManuallyDrop::new(self.deref().clone())\n-    }\n-\n-    fn clone_from(&mut self, source: &Self) {\n-        self.deref_mut().clone_from(source);\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Default> Default for ManuallyDrop<T> {\n-    fn default() -> Self {\n-        ManuallyDrop::new(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: PartialEq> PartialEq for ManuallyDrop<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other)\n-    }\n-\n-    fn ne(&self, other: &Self) -> bool {\n-        self.deref().ne(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Eq> Eq for ManuallyDrop<T> {}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: PartialOrd> PartialOrd for ManuallyDrop<T> {\n-    fn partial_cmp(&self, other: &Self) -> Option<::cmp::Ordering> {\n-        self.deref().partial_cmp(other)\n-    }\n-\n-    fn lt(&self, other: &Self) -> bool {\n-        self.deref().lt(other)\n-    }\n-\n-    fn le(&self, other: &Self) -> bool {\n-        self.deref().le(other)\n-    }\n-\n-    fn gt(&self, other: &Self) -> bool {\n-        self.deref().gt(other)\n-    }\n-\n-    fn ge(&self, other: &Self) -> bool {\n-        self.deref().ge(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: Ord> Ord for ManuallyDrop<T> {\n-    fn cmp(&self, other: &Self) -> ::cmp::Ordering {\n-        self.deref().cmp(other)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\n-impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n-    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n+        &mut self.value\n     }\n }\n "}, {"sha": "cf94a0fb4b4ba618b59c3cabc2400c1fcd39a59f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -324,6 +324,8 @@ language_item_table! {\n \n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n+    ManuallyDropItem,                \"manually_drop\",           manually_drop;\n+\n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n \n     // A lang item for each of the 128-bit operators we can optionally lower."}, {"sha": "a48d24bb97a9c58777179b519f298de74690f93e", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -243,7 +243,10 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n \n         ty::TyAdt(def, _) => {\n             if def.is_union() {\n-                // Unions never run have a dtor.\n+                // Unions never have a dtor.\n+                true\n+            } else if Some(def.did) == tcx.lang_items().manually_drop() {\n+                // `ManuallyDrop` never has a dtor.\n                 true\n             } else {\n                 // Other types might. Moreover, PhantomData doesn't"}, {"sha": "95caa0c185be1d74890309611b60773b3d3e9f18", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -932,6 +932,9 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Foreign types can never have destructors\n         ty::TyForeign(..) => false,\n \n+        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n+        ty::TyAdt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n+\n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n         // know whether the type implements Copy (and thus needs no\n@@ -967,7 +970,8 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::TyTuple(ref tys) => tys.iter().cloned().any(needs_drop),\n \n-        // unions don't have destructors regardless of the child types\n+        // unions don't have destructors because of the child types,\n+        // only if they manually implement `Drop` (handled above).\n         ty::TyAdt(def, _) if def.is_union() => false,\n \n         ty::TyAdt(def, substs) =>"}, {"sha": "bbffeec631abd3c72dab7bf96765798d712aa461", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591eeff22af299043637e75bb5735c3c65e0c7fe/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=591eeff22af299043637e75bb5735c3c65e0c7fe", "patch": "@@ -369,7 +369,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             });\n         }\n \n-        let contents_drop = if adt.is_union() {\n+        let skip_contents =\n+            adt.is_union() || Some(adt.did) == self.tcx().lang_items().manually_drop();\n+        let contents_drop = if skip_contents {\n             (self.succ, self.unwind)\n         } else {\n             self.open_drop_for_adt_contents(adt, substs)"}]}