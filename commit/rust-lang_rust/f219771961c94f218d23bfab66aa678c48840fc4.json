{"sha": "f219771961c94f218d23bfab66aa678c48840fc4", "node_id": "C_kwDOAAsO6NoAKGYyMTk3NzE5NjFjOTRmMjE4ZDIzYmZhYjY2YWE2NzhjNDg4NDBmYzQ", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2023-01-19T16:37:59Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2023-01-19T16:37:59Z"}, "message": "Clean up and document unord collections a bit.", "tree": {"sha": "289be23c8b19ce4bd428118031d1d1dcf5390a6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/289be23c8b19ce4bd428118031d1d1dcf5390a6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f219771961c94f218d23bfab66aa678c48840fc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f219771961c94f218d23bfab66aa678c48840fc4", "html_url": "https://github.com/rust-lang/rust/commit/f219771961c94f218d23bfab66aa678c48840fc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f219771961c94f218d23bfab66aa678c48840fc4/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ee14ce3960ca02ba4f4a19b84bf9c27ec6de9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ee14ce3960ca02ba4f4a19b84bf9c27ec6de9d", "html_url": "https://github.com/rust-lang/rust/commit/72ee14ce3960ca02ba4f4a19b84bf9c27ec6de9d"}], "stats": {"total": 104, "additions": 66, "deletions": 38}, "files": [{"sha": "f35f18e51cb4e5339dfd8a4b88b9c291ce773256", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f219771961c94f218d23bfab66aa678c48840fc4/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f219771961c94f218d23bfab66aa678c48840fc4/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=f219771961c94f218d23bfab66aa678c48840fc4", "patch": "@@ -208,21 +208,24 @@ impl<V: Eq + Hash> UnordSet<V> {\n         UnordItems(self.inner.into_iter())\n     }\n \n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n     #[inline]\n     pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<&V>\n     where\n         V: ToStableHashKey<HCX>,\n     {\n-        let mut items: Vec<&V> = self.inner.iter().collect();\n-        if cache_sort_key {\n-            items.sort_by_cached_key(|k| k.to_stable_hash_key(hcx));\n-        } else {\n-            items.sort_unstable_by_key(|k| k.to_stable_hash_key(hcx));\n-        }\n-\n-        items\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&x| x)\n     }\n \n+    /// Returns the items of this set in stable sort order (as defined by\n+    /// `StableOrd`). This method is much more efficient than\n+    /// `into_sorted` because it does not need to transform keys to their\n+    /// `ToStableHashKey` equivalent.\n     #[inline]\n     pub fn to_sorted_stable_ord(&self) -> Vec<V>\n     where\n@@ -233,19 +236,18 @@ impl<V: Eq + Hash> UnordSet<V> {\n         items\n     }\n \n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n     #[inline]\n     pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<V>\n     where\n         V: ToStableHashKey<HCX>,\n     {\n-        let mut items: Vec<V> = self.inner.into_iter().collect();\n-        if cache_sort_key {\n-            items.sort_by_cached_key(|k| k.to_stable_hash_key(hcx));\n-        } else {\n-            items.sort_unstable_by_key(|k| k.to_stable_hash_key(hcx));\n-        }\n-\n-        items\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |x| x)\n     }\n \n     // We can safely extend this UnordSet from a set of unordered values because that\n@@ -398,21 +400,23 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n         self.inner.extend(items.0)\n     }\n \n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n     #[inline]\n     pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<(&K, &V)>\n     where\n         K: ToStableHashKey<HCX>,\n     {\n-        let mut items: Vec<(&K, &V)> = self.inner.iter().collect();\n-        if cache_sort_key {\n-            items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        } else {\n-            items.sort_unstable_by_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        }\n-\n-        items\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n     }\n \n+    /// Returns the entries of this map in stable sort order (as defined by `StableOrd`).\n+    /// This method can be much more efficient than `into_sorted` because it does not need\n+    /// to transform keys to their `ToStableHashKey` equivalent.\n     #[inline]\n     pub fn to_sorted_stable_ord(&self) -> Vec<(K, &V)>\n     where\n@@ -423,32 +427,35 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n         items\n     }\n \n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n     #[inline]\n     pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<(K, V)>\n     where\n         K: ToStableHashKey<HCX>,\n     {\n-        let mut items: Vec<(K, V)> = self.inner.into_iter().collect();\n-        if cache_sort_key {\n-            items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        } else {\n-            items.sort_unstable_by_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        }\n-        items\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |(k, _)| k)\n     }\n \n+    /// Returns the values of this map in stable sort order (as defined by K's\n+    /// `ToStableHashKey` implementation).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n     #[inline]\n     pub fn values_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> impl Iterator<Item = &V>\n     where\n         K: ToStableHashKey<HCX>,\n     {\n-        let mut items: Vec<(&K, &V)> = self.inner.iter().collect();\n-        if cache_sort_key {\n-            items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        } else {\n-            items.sort_unstable_by_key(|(k, _)| k.to_stable_hash_key(hcx));\n-        }\n-        items.into_iter().map(|(_, v)| v)\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n+            .into_iter()\n+            .map(|(_, v)| v)\n     }\n }\n \n@@ -540,6 +547,27 @@ impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n     }\n }\n \n+#[inline]\n+fn to_sorted_vec<HCX, T, K, I>(\n+    hcx: &HCX,\n+    iter: I,\n+    cache_sort_key: bool,\n+    extract_key: fn(&T) -> &K,\n+) -> Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+    K: ToStableHashKey<HCX>,\n+{\n+    let mut items: Vec<T> = iter.collect();\n+    if cache_sort_key {\n+        items.sort_by_cached_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    } else {\n+        items.sort_unstable_by_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    }\n+\n+    items\n+}\n+\n fn hash_iter_order_independent<\n     HCX,\n     T: HashStable<HCX>,"}]}