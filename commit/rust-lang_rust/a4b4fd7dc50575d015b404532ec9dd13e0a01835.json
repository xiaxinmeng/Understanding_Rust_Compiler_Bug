{"sha": "a4b4fd7dc50575d015b404532ec9dd13e0a01835", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YjRmZDdkYzUwNTc1ZDAxNWI0MDQ1MzJlYzlkZDEzZTBhMDE4MzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T13:29:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T13:29:08Z"}, "message": "move symbols to ra_analysis", "tree": {"sha": "4ba01eb7201bccdb3f4c018a607b55599743c685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ba01eb7201bccdb3f4c018a607b55599743c685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4b4fd7dc50575d015b404532ec9dd13e0a01835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b4fd7dc50575d015b404532ec9dd13e0a01835", "html_url": "https://github.com/rust-lang/rust/commit/a4b4fd7dc50575d015b404532ec9dd13e0a01835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4b4fd7dc50575d015b404532ec9dd13e0a01835/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4ffd7b31780b1f2ac6dcb731566b583bf562647", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ffd7b31780b1f2ac6dcb731566b583bf562647", "html_url": "https://github.com/rust-lang/rust/commit/e4ffd7b31780b1f2ac6dcb731566b583bf562647"}], "stats": {"total": 511, "additions": 255, "deletions": 256}, "files": [{"sha": "f3b513de1a7e3a303b7342328f2a9620bb29bd84", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=a4b4fd7dc50575d015b404532ec9dd13e0a01835", "patch": "@@ -10,7 +10,7 @@ use hir::{\n     self, FnSignatureInfo, Problem, source_binder,\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n-use ra_editor::{self, FileSymbol, find_node_at_offset, LineIndex, LocalEdit, Severity};\n+use ra_editor::{self, find_node_at_offset, LineIndex, LocalEdit, Severity};\n use ra_syntax::{\n     algo::find_covering_node,\n     ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n@@ -25,7 +25,7 @@ use crate::{\n     completion::{CompletionItem, completions},\n     CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n     Query, ReferenceResolution, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{LibrarySymbolsQuery, SymbolIndex, SymbolsDatabase},\n+    symbol_index::{LibrarySymbolsQuery, SymbolIndex, SymbolsDatabase, FileSymbol},\n };\n \n #[derive(Debug, Default)]"}, {"sha": "ff28271abf2f6898731f98013c3045e3014b10ac", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=a4b4fd7dc50575d015b404532ec9dd13e0a01835", "patch": "@@ -36,10 +36,11 @@ use crate::{\n \n pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n-    runnables::{Runnable, RunnableKind}\n+    runnables::{Runnable, RunnableKind},\n+    symbol_index::FileSymbol,\n };\n pub use ra_editor::{\n-    FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, StructureNode, Severity\n+    Fold, FoldKind, HighlightedRange, LineIndex, StructureNode, Severity\n };\n pub use hir::FnSignatureInfo;\n "}, {"sha": "edb2268fbd263ed85bf951e6188972a568be2867", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=a4b4fd7dc50575d015b404532ec9dd13e0a01835", "patch": "@@ -4,10 +4,11 @@ use std::{\n };\n \n use fst::{self, Streamer};\n-use ra_editor::{self, FileSymbol};\n use ra_syntax::{\n-    SourceFileNode,\n+    AstNode, SyntaxNodeRef, SourceFileNode, SmolStr, TextRange,\n+    algo::visit::{visitor, Visitor},\n     SyntaxKind::{self, *},\n+    ast::{self, NameOwner, DocCommentsOwner},\n };\n use ra_db::{SyntaxDatabase, SourceRootId};\n use rayon::prelude::*;\n@@ -65,8 +66,9 @@ impl SymbolIndex {\n     ) -> SymbolIndex {\n         let mut symbols = files\n             .flat_map(|(file_id, file)| {\n-                ra_editor::file_symbols(&file)\n-                    .into_iter()\n+                file.syntax()\n+                    .descendants()\n+                    .filter_map(to_symbol)\n                     .map(move |symbol| (symbol.name.as_str().to_lowercase(), (file_id, symbol)))\n                     .collect::<Vec<_>>()\n             })\n@@ -121,3 +123,116 @@ fn is_type(kind: SyntaxKind) -> bool {\n         _ => false,\n     }\n }\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FileSymbol {\n+    pub name: SmolStr,\n+    pub node_range: TextRange,\n+    pub kind: SyntaxKind,\n+}\n+\n+impl FileSymbol {\n+    pub fn docs(&self, file: &SourceFileNode) -> Option<String> {\n+        file.syntax()\n+            .descendants()\n+            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n+            .filter_map(|node: SyntaxNodeRef| {\n+                fn doc_comments<'a, N: DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+                    let comments = node.doc_comment_text();\n+                    if comments.is_empty() {\n+                        None\n+                    } else {\n+                        Some(comments)\n+                    }\n+                }\n+\n+                visitor()\n+                    .visit(doc_comments::<ast::FnDef>)\n+                    .visit(doc_comments::<ast::StructDef>)\n+                    .visit(doc_comments::<ast::EnumDef>)\n+                    .visit(doc_comments::<ast::TraitDef>)\n+                    .visit(doc_comments::<ast::Module>)\n+                    .visit(doc_comments::<ast::TypeDef>)\n+                    .visit(doc_comments::<ast::ConstDef>)\n+                    .visit(doc_comments::<ast::StaticDef>)\n+                    .accept(node)?\n+            })\n+            .nth(0)\n+    }\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    pub fn description(&self, file: &SourceFileNode) -> Option<String> {\n+        // TODO: After type inference is done, add type information to improve the output\n+        file.syntax()\n+            .descendants()\n+            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n+            .filter_map(|node: SyntaxNodeRef| {\n+                // TODO: Refactor to be have less repetition\n+                visitor()\n+                    .visit(|node: ast::FnDef| {\n+                        let mut string = \"fn \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::StructDef| {\n+                        let mut string = \"struct \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::EnumDef| {\n+                        let mut string = \"enum \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::TraitDef| {\n+                        let mut string = \"trait \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::Module| {\n+                        let mut string = \"mod \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::TypeDef| {\n+                        let mut string = \"type \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::ConstDef| {\n+                        let mut string = \"const \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::StaticDef| {\n+                        let mut string = \"static \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .accept(node)?\n+            })\n+            .nth(0)\n+    }\n+}\n+\n+fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n+        let name = node.name()?;\n+        Some(FileSymbol {\n+            name: name.text(),\n+            node_range: node.syntax().range(),\n+            kind: node.syntax().kind(),\n+        })\n+    }\n+    visitor()\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n+        .accept(node)?\n+}"}, {"sha": "bfc745e58c355f4c630b546c14a95eaa0b39606d", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=a4b4fd7dc50575d015b404532ec9dd13e0a01835", "patch": "@@ -3,7 +3,7 @@ mod extend_selection;\n mod folding_ranges;\n mod line_index;\n mod line_index_utils;\n-mod symbols;\n+mod structure;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n@@ -15,7 +15,7 @@ pub use self::{\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n-    symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n+    structure::{file_structure, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n     diagnostics::diagnostics\n };"}, {"sha": "2292b1ddf0f6699bf5e21a1febe5dac6c4ef3389", "filename": "crates/ra_editor/src/structure.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b4fd7dc50575d015b404532ec9dd13e0a01835/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fstructure.rs?ref=a4b4fd7dc50575d015b404532ec9dd13e0a01835", "patch": "@@ -0,0 +1,129 @@\n+use crate::TextRange;\n+\n+use ra_syntax::{\n+    algo::visit::{visitor, Visitor},\n+    ast::{self, NameOwner},\n+    AstNode, SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent,\n+};\n+\n+#[derive(Debug, Clone)]\n+pub struct StructureNode {\n+    pub parent: Option<usize>,\n+    pub label: String,\n+    pub navigation_range: TextRange,\n+    pub node_range: TextRange,\n+    pub kind: SyntaxKind,\n+}\n+\n+pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n+    let mut res = Vec::new();\n+    let mut stack = Vec::new();\n+\n+    for event in file.syntax().preorder() {\n+        match event {\n+            WalkEvent::Enter(node) => {\n+                if let Some(mut symbol) = structure_node(node) {\n+                    symbol.parent = stack.last().map(|&n| n);\n+                    stack.push(res.len());\n+                    res.push(symbol);\n+                }\n+            }\n+            WalkEvent::Leave(node) => {\n+                if structure_node(node).is_some() {\n+                    stack.pop().unwrap();\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n+        let name = node.name()?;\n+        Some(StructureNode {\n+            parent: None,\n+            label: name.text().to_string(),\n+            navigation_range: name.syntax().range(),\n+            node_range: node.syntax().range(),\n+            kind: node.syntax().kind(),\n+        })\n+    }\n+\n+    visitor()\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::NamedFieldDef>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n+        .visit(|im: ast::ImplItem| {\n+            let target_type = im.target_type()?;\n+            let target_trait = im.target_trait();\n+            let label = match target_trait {\n+                None => format!(\"impl {}\", target_type.syntax().text()),\n+                Some(t) => format!(\n+                    \"impl {} for {}\",\n+                    t.syntax().text(),\n+                    target_type.syntax().text(),\n+                ),\n+            };\n+\n+            let node = StructureNode {\n+                parent: None,\n+                label,\n+                navigation_range: target_type.syntax().range(),\n+                node_range: im.syntax().range(),\n+                kind: im.syntax().kind(),\n+            };\n+            Some(node)\n+        })\n+        .accept(node)?\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::assert_eq_dbg;\n+\n+    #[test]\n+    fn test_file_structure() {\n+        let file = SourceFileNode::parse(\n+            r#\"\n+struct Foo {\n+    x: i32\n+}\n+\n+mod m {\n+    fn bar() {}\n+}\n+\n+enum E { X, Y(i32) }\n+type T = ();\n+static S: i32 = 92;\n+const C: i32 = 92;\n+\n+impl E {}\n+\n+impl fmt::Debug for E {}\n+\"#,\n+        );\n+        let structure = file_structure(&file);\n+        assert_eq_dbg(\n+            r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n+                StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n+                StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n+                StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n+                StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n+                StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n+                StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n+                StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n+                StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n+                StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n+            &structure,\n+        )\n+    }\n+}"}, {"sha": "9e25decfbc311c6544c55c99aedcaeaba32b08cb", "filename": "crates/ra_editor/src/symbols.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/e4ffd7b31780b1f2ac6dcb731566b583bf562647/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4ffd7b31780b1f2ac6dcb731566b583bf562647/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fsymbols.rs?ref=e4ffd7b31780b1f2ac6dcb731566b583bf562647", "patch": "@@ -1,246 +0,0 @@\n-use crate::TextRange;\n-\n-use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n-    ast::{self, DocCommentsOwner, NameOwner},\n-    AstNode, SourceFileNode, SmolStr, SyntaxKind, SyntaxNodeRef, WalkEvent,\n-};\n-\n-#[derive(Debug, Clone)]\n-pub struct StructureNode {\n-    pub parent: Option<usize>,\n-    pub label: String,\n-    pub navigation_range: TextRange,\n-    pub node_range: TextRange,\n-    pub kind: SyntaxKind,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FileSymbol {\n-    pub name: SmolStr,\n-    pub node_range: TextRange,\n-    pub kind: SyntaxKind,\n-}\n-\n-impl FileSymbol {\n-    pub fn docs(&self, file: &SourceFileNode) -> Option<String> {\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                fn doc_comments<'a, N: DocCommentsOwner<'a>>(node: N) -> Option<String> {\n-                    let comments = node.doc_comment_text();\n-                    if comments.is_empty() {\n-                        None\n-                    } else {\n-                        Some(comments)\n-                    }\n-                }\n-\n-                visitor()\n-                    .visit(doc_comments::<ast::FnDef>)\n-                    .visit(doc_comments::<ast::StructDef>)\n-                    .visit(doc_comments::<ast::EnumDef>)\n-                    .visit(doc_comments::<ast::TraitDef>)\n-                    .visit(doc_comments::<ast::Module>)\n-                    .visit(doc_comments::<ast::TypeDef>)\n-                    .visit(doc_comments::<ast::ConstDef>)\n-                    .visit(doc_comments::<ast::StaticDef>)\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    pub fn description(&self, file: &SourceFileNode) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                // TODO: Refactor to be have less repetition\n-                visitor()\n-                    .visit(|node: ast::FnDef| {\n-                        let mut string = \"fn \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StructDef| {\n-                        let mut string = \"struct \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::EnumDef| {\n-                        let mut string = \"enum \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TraitDef| {\n-                        let mut string = \"trait \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::Module| {\n-                        let mut string = \"mod \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TypeDef| {\n-                        let mut string = \"type \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::ConstDef| {\n-                        let mut string = \"const \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StaticDef| {\n-                        let mut string = \"static \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n-}\n-\n-pub fn file_symbols(file: &SourceFileNode) -> Vec<FileSymbol> {\n-    file.syntax().descendants().filter_map(to_symbol).collect()\n-}\n-\n-fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n-        let name = node.name()?;\n-        Some(FileSymbol {\n-            name: name.text(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n-        })\n-    }\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .accept(node)?\n-}\n-\n-pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n-    let mut res = Vec::new();\n-    let mut stack = Vec::new();\n-\n-    for event in file.syntax().preorder() {\n-        match event {\n-            WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = structure_node(node) {\n-                    symbol.parent = stack.last().map(|&n| n);\n-                    stack.push(res.len());\n-                    res.push(symbol);\n-                }\n-            }\n-            WalkEvent::Leave(node) => {\n-                if structure_node(node).is_some() {\n-                    stack.pop().unwrap();\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n-        let name = node.name()?;\n-        Some(StructureNode {\n-            parent: None,\n-            label: name.text().to_string(),\n-            navigation_range: name.syntax().range(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n-        })\n-    }\n-\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::NamedFieldDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .visit(|im: ast::ImplItem| {\n-            let target_type = im.target_type()?;\n-            let target_trait = im.target_trait();\n-            let label = match target_trait {\n-                None => format!(\"impl {}\", target_type.syntax().text()),\n-                Some(t) => format!(\n-                    \"impl {} for {}\",\n-                    t.syntax().text(),\n-                    target_type.syntax().text(),\n-                ),\n-            };\n-\n-            let node = StructureNode {\n-                parent: None,\n-                label,\n-                navigation_range: target_type.syntax().range(),\n-                node_range: im.syntax().range(),\n-                kind: im.syntax().kind(),\n-            };\n-            Some(node)\n-        })\n-        .accept(node)?\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::assert_eq_dbg;\n-\n-    #[test]\n-    fn test_file_structure() {\n-        let file = SourceFileNode::parse(\n-            r#\"\n-struct Foo {\n-    x: i32\n-}\n-\n-mod m {\n-    fn bar() {}\n-}\n-\n-enum E { X, Y(i32) }\n-type T = ();\n-static S: i32 = 92;\n-const C: i32 = 92;\n-\n-impl E {}\n-\n-impl fmt::Debug for E {}\n-\"#,\n-        );\n-        let symbols = file_structure(&file);\n-        assert_eq_dbg(\n-            r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n-                StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n-                StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n-                StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n-                StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n-                StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n-                StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n-                StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n-                StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n-                StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n-            &symbols,\n-        )\n-    }\n-}"}]}