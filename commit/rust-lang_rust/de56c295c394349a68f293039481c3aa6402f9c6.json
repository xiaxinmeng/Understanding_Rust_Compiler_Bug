{"sha": "de56c295c394349a68f293039481c3aa6402f9c6", "node_id": "C_kwDOAAsO6NoAKGRlNTZjMjk1YzM5NDM0OWE2OGYyOTMwMzk0ODFjM2FhNjQwMmY5YzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T16:12:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T16:12:48Z"}, "message": "Auto merge of #95867 - cjgillot:fixed-size, r=oli-obk\n\nSkip `Lazy` for some metadata tables\n\nSome metadata tables encode their entries indirectly, through the Lazy construct. This is useful when dealing with variable length encoding, but incurs the extra cost of one u32.\n\nMeanwhile, some fields can be encoded in a single u8, or can use a short fixed-length encoding. This PR proposes to do so, and avoid the overhead.", "tree": {"sha": "baf0f6ce25e66fb0175ef72ff467e14395caa99d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baf0f6ce25e66fb0175ef72ff467e14395caa99d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de56c295c394349a68f293039481c3aa6402f9c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de56c295c394349a68f293039481c3aa6402f9c6", "html_url": "https://github.com/rust-lang/rust/commit/de56c295c394349a68f293039481c3aa6402f9c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de56c295c394349a68f293039481c3aa6402f9c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "327caac4d01aef74d6577b87c295270608be09fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/327caac4d01aef74d6577b87c295270608be09fa", "html_url": "https://github.com/rust-lang/rust/commit/327caac4d01aef74d6577b87c295270608be09fa"}, {"sha": "b4cf2cdf870512373a656393f393bce84eb78d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4cf2cdf870512373a656393f393bce84eb78d80", "html_url": "https://github.com/rust-lang/rust/commit/b4cf2cdf870512373a656393f393bce84eb78d80"}], "stats": {"total": 464, "additions": 322, "deletions": 142}, "files": [{"sha": "aebd293f6c211976ada0edc86622a1fed6239cee", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=de56c295c394349a68f293039481c3aa6402f9c6", "patch": "@@ -5,7 +5,9 @@\n #![feature(nll)]\n #![feature(once_cell)]\n #![feature(proc_macro_internals)]\n+#![feature(macro_metavar_expr)]\n #![feature(min_specialization)]\n+#![feature(slice_as_chunks)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]"}, {"sha": "3933a0d19a4ad2052088823f1b76e5f2a4be0d36", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=de56c295c394349a68f293039481c3aa6402f9c6", "patch": "@@ -292,6 +292,18 @@ trait LazyQueryDecodable<'a, 'tcx, T> {\n     ) -> T;\n }\n \n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for T {\n+    fn decode_query(self, _: CrateMetadataRef<'a>, _: TyCtxt<'tcx>, _: impl FnOnce() -> !) -> T {\n+        self\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<T> {\n+    fn decode_query(self, _: CrateMetadataRef<'a>, _: TyCtxt<'tcx>, err: impl FnOnce() -> !) -> T {\n+        if let Some(l) = self { l } else { err() }\n+    }\n+}\n+\n impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<Lazy<T>>\n where\n     T: Decodable<DecodeContext<'a, 'tcx>>,\n@@ -376,6 +388,17 @@ impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DeprecationEntry>>\n     }\n }\n \n+impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DefId>> for Option<RawDefId> {\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        _: TyCtxt<'tcx>,\n+        _: impl FnOnce() -> !,\n+    ) -> Option<DefId> {\n+        self.map(|raw_def_id| raw_def_id.decode(cdata))\n+    }\n+}\n+\n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -394,8 +417,9 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.unwrap()\n     }\n \n+    #[inline]\n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n-        if cnum == LOCAL_CRATE { self.cdata().cnum } else { self.cdata().cnum_map[cnum] }\n+        self.cdata().map_encoded_cnum_to_current(cnum)\n     }\n \n     fn read_lazy_with_meta<T: ?Sized + LazyMeta>(&mut self, meta: T::Meta) -> Lazy<T> {\n@@ -706,8 +730,7 @@ impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n-    for Lazy<Table<I, T>>\n+impl<'a, 'tcx, I: Idx, T> Decodable<DecodeContext<'a, 'tcx>> for Lazy<Table<I, T>>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -844,6 +867,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n+    #[inline]\n+    pub(super) fn map_encoded_cnum_to_current(self, cnum: CrateNum) -> CrateNum {\n+        if cnum == LOCAL_CRATE { self.cnum } else { self.cnum_map[cnum] }\n+    }\n+\n     fn kind(self, item_id: DefIndex) -> EntryKind {\n         self.maybe_kind(item_id).unwrap_or_else(|| {\n             bug!(\n@@ -856,16 +884,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn def_kind(self, item_id: DefIndex) -> DefKind {\n-        self.root.tables.opt_def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(\n-            || {\n-                bug!(\n-                    \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n-                    item_id,\n-                    self.root.name,\n-                    self.cnum,\n-                )\n-            },\n-        )\n+        self.root.tables.opt_def_kind.get(self, item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn get_span(self, index: DefIndex, sess: &Session) -> Span {\n@@ -1449,9 +1475,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         index: DefIndex,\n         def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n     ) -> DefPathHash {\n-        *def_path_hashes.entry(index).or_insert_with(|| {\n-            self.root.tables.def_path_hashes.get(self, index).unwrap().decode(self)\n-        })\n+        *def_path_hashes\n+            .entry(index)\n+            .or_insert_with(|| self.root.tables.def_path_hashes.get(self, index).unwrap())\n     }\n \n     #[inline]"}, {"sha": "e967750aebb522c15473b75bd4b035d024b76ab6", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=de56c295c394349a68f293039481c3aa6402f9c6", "patch": "@@ -147,8 +147,7 @@ impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n-    for Lazy<Table<I, T>>\n+impl<'a, 'tcx, I: Idx, T> Encodable<EncodeContext<'a, 'tcx>> for Lazy<Table<I, T>>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -461,16 +460,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n             {\n                 let def_key = self.lazy(table.def_key(def_index));\n-                let def_path_hash = self.lazy(table.def_path_hash(def_index));\n+                let def_path_hash = table.def_path_hash(def_index);\n                 self.tables.def_keys.set(def_index, def_key);\n                 self.tables.def_path_hashes.set(def_index, def_path_hash);\n             }\n         } else {\n             for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n                 let def_key = self.lazy(def_key);\n-                let def_path_hash = self.lazy(def_path_hash);\n                 self.tables.def_keys.set(def_index, def_key);\n-                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+                self.tables.def_path_hashes.set(def_index, *def_path_hash);\n             }\n         }\n     }\n@@ -988,7 +986,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            record!(self.tables.opt_def_kind[def_id] <- def_kind);\n+            self.tables.opt_def_kind.set(def_id.index, def_kind);\n             record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n             record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n@@ -1048,7 +1046,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n+        self.tables.impl_constness.set(def_id.index, hir::Constness::Const);\n         record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n@@ -1078,7 +1076,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n+        self.tables.impl_constness.set(def_id.index, hir::Constness::Const);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1157,7 +1155,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n+        self.tables.impl_constness.set(def_id.index, hir::Constness::Const);\n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data)));\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n@@ -1207,8 +1205,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n                     }\n                 };\n-                record!(self.tables.asyncness[def_id] <- m_sig.header.asyncness);\n-                record!(self.tables.impl_constness[def_id] <- hir::Constness::NotConst);\n+                self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n+                self.tables.impl_constness.set(def_id.index, hir::Constness::NotConst);\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     container,\n                     has_self: trait_item.fn_has_self_parameter,\n@@ -1265,15 +1263,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n-                record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n+                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                record!(self.tables.impl_constness[def_id] <- constness);\n+                self.tables.impl_constness.set(def_id.index, constness);\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     container,\n                     has_self: impl_item.fn_has_self_parameter,\n@@ -1286,7 +1284,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_ident_span(def_id, impl_item.ident(self.tcx));\n         self.encode_item_type(def_id);\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n-            record!(self.tables.trait_item_def_id[def_id] <- trait_item_def_id);\n+            self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n         }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1394,9 +1392,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Const\n             }\n             hir::ItemKind::Fn(ref sig, .., body) => {\n-                record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n+                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                record!(self.tables.impl_constness[def_id] <- sig.header.constness);\n+                self.tables.impl_constness.set(def_id.index, sig.header.constness);\n                 EntryKind::Fn\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n@@ -1420,7 +1418,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n+                self.tables.impl_constness.set(def_id.index, hir::Constness::Const);\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n@@ -1450,15 +1448,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }))\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n-                record!(self.tables.impl_defaultness[def_id] <- defaultness);\n-                record!(self.tables.impl_constness[def_id] <- constness);\n+                self.tables.impl_defaultness.set(def_id.index, defaultness);\n+                self.tables.impl_constness.set(def_id.index, constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Some(mut an) = trait_def.ancestors(self.tcx, def_id).ok() {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n-                            record!(self.tables.impl_parent[def_id] <- parent);\n+                            self.tables.impl_parent.set(def_id.index, parent.into());\n                         }\n                     }\n \n@@ -1472,7 +1470,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n-                record!(self.tables.impl_polarity[def_id] <- polarity);\n+                self.tables.impl_polarity.set(def_id.index, polarity);\n \n                 EntryKind::Impl\n             }\n@@ -1644,7 +1642,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.proc_macro_quoted_spans.set(i, span);\n             }\n \n-            record!(self.tables.opt_def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n+            self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.attributes[LOCAL_CRATE.as_def_id()] <- tcx.get_attrs(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n@@ -1685,7 +1683,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                record!(self.tables.opt_def_kind[def_id] <- DefKind::Macro(macro_kind));\n+                self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n@@ -1886,14 +1884,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n-                record!(self.tables.asyncness[def_id] <- hir::IsAsync::NotAsync);\n+                self.tables.asyncness.set(def_id.index, hir::IsAsync::NotAsync);\n                 record!(self.tables.fn_arg_names[def_id] <- *names);\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                record!(self.tables.impl_constness[def_id] <- constness);\n+                self.tables.impl_constness.set(def_id.index, constness);\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignFn);\n             }\n             hir::ForeignItemKind::Static(..) => {"}, {"sha": "43ccfc64e0563978adf8f7c7b6dfd7a083ff3c2a", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=de56c295c394349a68f293039481c3aa6402f9c6", "patch": "@@ -1,3 +1,4 @@\n+use crate::creader::CrateMetadataRef;\n use decoder::Metadata;\n use def_path_hash_map::DefPathHashMapRef;\n use table::{Table, TableBuilder};\n@@ -8,7 +9,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n-use rustc_hir::def_id::{DefId, DefIndex, DefPathHash, StableCrateId};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n@@ -237,6 +238,29 @@ crate struct CrateRoot<'tcx> {\n     symbol_mangling_version: SymbolManglingVersion,\n }\n \n+/// On-disk representation of `DefId`.\n+/// This creates a type-safe way to enforce that we remap the CrateNum between the on-disk\n+/// representation and the compilation session.\n+#[derive(Copy, Clone)]\n+crate struct RawDefId {\n+    krate: u32,\n+    index: u32,\n+}\n+\n+impl Into<RawDefId> for DefId {\n+    fn into(self) -> RawDefId {\n+        RawDefId { krate: self.krate.as_u32(), index: self.index.as_u32() }\n+    }\n+}\n+\n+impl RawDefId {\n+    fn decode(self, cdata: CrateMetadataRef<'_>) -> DefId {\n+        let krate = CrateNum::from_u32(self.krate);\n+        let krate = cdata.map_encoded_cnum_to_current(krate);\n+        DefId { krate, index: DefIndex::from_u32(self.index) }\n+    }\n+}\n+\n #[derive(Encodable, Decodable)]\n crate struct CrateDep {\n     pub name: Symbol,\n@@ -286,7 +310,7 @@ define_tables! {\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n \n-    opt_def_kind: Table<DefIndex, Lazy<DefKind>>,\n+    opt_def_kind: Table<DefIndex, DefKind>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     def_span: Table<DefIndex, Lazy<Span>>,\n     def_ident_span: Table<DefIndex, Lazy<Span>>,\n@@ -309,20 +333,20 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n     thir_abstract_const: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n-    impl_parent: Table<DefIndex, Lazy!(DefId)>,\n-    impl_polarity: Table<DefIndex, Lazy!(ty::ImplPolarity)>,\n-    impl_constness: Table<DefIndex, Lazy!(hir::Constness)>,\n-    impl_defaultness: Table<DefIndex, Lazy!(hir::Defaultness)>,\n+    impl_parent: Table<DefIndex, RawDefId>,\n+    impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n+    impl_constness: Table<DefIndex, hir::Constness>,\n+    impl_defaultness: Table<DefIndex, hir::Defaultness>,\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     coerce_unsized_info: Table<DefIndex, Lazy!(ty::adjustment::CoerceUnsizedInfo)>,\n     mir_const_qualif: Table<DefIndex, Lazy!(mir::ConstQualifs)>,\n     rendered_const: Table<DefIndex, Lazy!(String)>,\n-    asyncness: Table<DefIndex, Lazy!(hir::IsAsync)>,\n+    asyncness: Table<DefIndex, hir::IsAsync>,\n     fn_arg_names: Table<DefIndex, Lazy!([Ident])>,\n     generator_kind: Table<DefIndex, Lazy!(hir::GeneratorKind)>,\n     trait_def: Table<DefIndex, Lazy!(ty::TraitDef)>,\n \n-    trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n+    trait_item_def_id: Table<DefIndex, RawDefId>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n@@ -332,7 +356,7 @@ define_tables! {\n     // `DefPathTable` up front, since we may only ever use a few\n     // definitions from any given crate.\n     def_keys: Table<DefIndex, Lazy<DefKey>>,\n-    def_path_hashes: Table<DefIndex, Lazy<DefPathHash>>,\n+    def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, Lazy<Span>>,\n }\n "}, {"sha": "7a23cba536a0a18bfdfbc69b4fb3cda5333aacad", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 222, "deletions": 92, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56c295c394349a68f293039481c3aa6402f9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=de56c295c394349a68f293039481c3aa6402f9c6", "patch": "@@ -1,8 +1,11 @@\n use crate::rmeta::*;\n \n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n use rustc_serialize::opaque::Encoder;\n use rustc_serialize::Encoder as _;\n+use rustc_span::hygiene::MacroKind;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n@@ -13,111 +16,225 @@ use tracing::debug;\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n pub(super) trait FixedSizeEncoding: Default {\n-    const BYTE_LEN: usize;\n-\n-    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n-    // once that starts being allowed by the compiler (i.e. lazy normalization).\n-    fn from_bytes(b: &[u8]) -> Self;\n-    fn write_to_bytes(self, b: &mut [u8]);\n-\n-    // FIXME(eddyb) make these generic functions, or at least defaults here.\n-    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n-    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n-\n-    /// Read a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n-    /// from `&b[i * Self::BYTE_LEN..]`, returning `None` if `i`\n-    /// is not in bounds, or `Some(Self::from_bytes(...))` otherwise.\n-    fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self>;\n-    /// Write a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n-    /// at `&mut b[i * Self::BYTE_LEN..]`, using `Self::write_to_bytes`.\n-    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n-}\n-\n-// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n-macro_rules! fixed_size_encoding_byte_len_and_defaults {\n-    ($byte_len:expr) => {\n-        const BYTE_LEN: usize = $byte_len;\n-        fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self> {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n-            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n-            let b = unsafe {\n-                std::slice::from_raw_parts(b.as_ptr() as *const [u8; BYTE_LEN], b.len() / BYTE_LEN)\n-            };\n-            b.get(i).map(|b| FixedSizeEncoding::from_bytes(b))\n-        }\n-        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // see similar comment in `read_from_bytes_at` for why it can't yet.\n-            let b = unsafe {\n-                std::slice::from_raw_parts_mut(\n-                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n-                    b.len() / BYTE_LEN,\n-                )\n-            };\n-            self.write_to_bytes(&mut b[i]);\n-        }\n-    };\n+    /// This should be `[u8; BYTE_LEN]`;\n+    type ByteArray;\n+\n+    fn from_bytes(b: &Self::ByteArray) -> Self;\n+    fn write_to_bytes(self, b: &mut Self::ByteArray);\n }\n \n impl FixedSizeEncoding for u32 {\n-    fixed_size_encoding_byte_len_and_defaults!(4);\n+    type ByteArray = [u8; 4];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 4]) -> Self {\n+        Self::from_le_bytes(*b)\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 4]) {\n+        *b = self.to_le_bytes();\n+    }\n+}\n+\n+macro_rules! fixed_size_enum {\n+    ($ty:ty { $(($($pat:tt)*))* }) => {\n+        impl FixedSizeEncoding for Option<$ty> {\n+            type ByteArray = [u8;1];\n+\n+            #[inline]\n+            fn from_bytes(b: &[u8;1]) -> Self {\n+                use $ty::*;\n+                if b[0] == 0 {\n+                    return None;\n+                }\n+                match b[0] - 1 {\n+                    $(${index()} => Some($($pat)*),)*\n+                    _ => panic!(\"Unexpected ImplPolarity code: {:?}\", b[0]),\n+                }\n+            }\n+\n+            #[inline]\n+            fn write_to_bytes(self, b: &mut [u8;1]) {\n+                use $ty::*;\n+                b[0] = match self {\n+                    None => 0,\n+                    $(Some($($pat)*) => 1 + ${index()},)*\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fixed_size_enum! {\n+    DefKind {\n+        ( Mod                                      )\n+        ( Struct                                   )\n+        ( Union                                    )\n+        ( Enum                                     )\n+        ( Variant                                  )\n+        ( Trait                                    )\n+        ( TyAlias                                  )\n+        ( ForeignTy                                )\n+        ( TraitAlias                               )\n+        ( AssocTy                                  )\n+        ( TyParam                                  )\n+        ( Fn                                       )\n+        ( Const                                    )\n+        ( ConstParam                               )\n+        ( AssocFn                                  )\n+        ( AssocConst                               )\n+        ( ExternCrate                              )\n+        ( Use                                      )\n+        ( ForeignMod                               )\n+        ( AnonConst                                )\n+        ( InlineConst                              )\n+        ( OpaqueTy                                 )\n+        ( Field                                    )\n+        ( LifetimeParam                            )\n+        ( GlobalAsm                                )\n+        ( Impl                                     )\n+        ( Closure                                  )\n+        ( Generator                                )\n+        ( Static(ast::Mutability::Not)             )\n+        ( Static(ast::Mutability::Mut)             )\n+        ( Ctor(CtorOf::Struct, CtorKind::Fn)       )\n+        ( Ctor(CtorOf::Struct, CtorKind::Const)    )\n+        ( Ctor(CtorOf::Struct, CtorKind::Fictive)  )\n+        ( Ctor(CtorOf::Variant, CtorKind::Fn)      )\n+        ( Ctor(CtorOf::Variant, CtorKind::Const)   )\n+        ( Ctor(CtorOf::Variant, CtorKind::Fictive) )\n+        ( Macro(MacroKind::Bang)                   )\n+        ( Macro(MacroKind::Attr)                   )\n+        ( Macro(MacroKind::Derive)                 )\n+    }\n+}\n+\n+fixed_size_enum! {\n+    ty::ImplPolarity {\n+        ( Positive    )\n+        ( Negative    )\n+        ( Reservation )\n+    }\n+}\n+\n+fixed_size_enum! {\n+    hir::Constness {\n+        ( NotConst )\n+        ( Const    )\n+    }\n+}\n \n-    fn from_bytes(b: &[u8]) -> Self {\n-        let mut bytes = [0; Self::BYTE_LEN];\n-        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n-        Self::from_le_bytes(bytes)\n+fixed_size_enum! {\n+    hir::Defaultness {\n+        ( Final                        )\n+        ( Default { has_value: false } )\n+        ( Default { has_value: true }  )\n     }\n+}\n \n-    fn write_to_bytes(self, b: &mut [u8]) {\n-        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n+fixed_size_enum! {\n+    hir::IsAsync {\n+        ( NotAsync )\n+        ( Async    )\n+    }\n+}\n+\n+// We directly encode `DefPathHash` because a `Lazy` would encur a 25% cost.\n+impl FixedSizeEncoding for Option<DefPathHash> {\n+    type ByteArray = [u8; 16];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 16]) -> Self {\n+        Some(DefPathHash(Fingerprint::from_le_bytes(*b)))\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 16]) {\n+        let Some(DefPathHash(fingerprint)) = self else {\n+            panic!(\"Trying to encode absent DefPathHash.\")\n+        };\n+        *b = fingerprint.to_le_bytes();\n+    }\n+}\n+\n+// We directly encode RawDefId because using a `Lazy` would incur a 50% overhead in the worst case.\n+impl FixedSizeEncoding for Option<RawDefId> {\n+    type ByteArray = [u8; 8];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 8]) -> Self {\n+        let krate = u32::from_le_bytes(b[0..4].try_into().unwrap());\n+        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n+        if krate == 0 {\n+            return None;\n+        }\n+        Some(RawDefId { krate: krate - 1, index })\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 8]) {\n+        match self {\n+            None => *b = [0; 8],\n+            Some(RawDefId { krate, index }) => {\n+                // CrateNum is less than `CrateNum::MAX_AS_U32`.\n+                debug_assert!(krate < u32::MAX);\n+                b[0..4].copy_from_slice(&(1 + krate).to_le_bytes());\n+                b[4..8].copy_from_slice(&index.to_le_bytes());\n+            }\n+        }\n     }\n }\n \n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `Lazy<T>` impl, but in the general case we might not need / want to\n // fit every `usize` in `u32`.\n impl<T> FixedSizeEncoding for Option<Lazy<T>> {\n-    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN);\n+    type ByteArray = [u8; 4];\n \n-    fn from_bytes(b: &[u8]) -> Self {\n-        Some(Lazy::from_position(NonZeroUsize::new(u32::from_bytes(b) as usize)?))\n+    #[inline]\n+    fn from_bytes(b: &[u8; 4]) -> Self {\n+        let position = NonZeroUsize::new(u32::from_bytes(b) as usize)?;\n+        Some(Lazy::from_position(position))\n     }\n \n-    fn write_to_bytes(self, b: &mut [u8]) {\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 4]) {\n         let position = self.map_or(0, |lazy| lazy.position.get());\n         let position: u32 = position.try_into().unwrap();\n-\n         position.write_to_bytes(b)\n     }\n }\n \n impl<T> FixedSizeEncoding for Option<Lazy<[T]>> {\n-    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN * 2);\n+    type ByteArray = [u8; 8];\n \n-    fn from_bytes(b: &[u8]) -> Self {\n-        Some(Lazy::from_position_and_meta(\n-            <Option<Lazy<T>>>::from_bytes(b)?.position,\n-            u32::from_bytes(&b[u32::BYTE_LEN..]) as usize,\n-        ))\n+    #[inline]\n+    fn from_bytes(b: &[u8; 8]) -> Self {\n+        let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n+        let len = u32::from_bytes(meta_bytes) as usize;\n+        Some(Lazy::from_position_and_meta(position, len))\n     }\n \n-    fn write_to_bytes(self, b: &mut [u8]) {\n-        self.map(|lazy| Lazy::<T>::from_position(lazy.position)).write_to_bytes(b);\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 8]) {\n+        let ([ref mut position_bytes, ref mut meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+\n+        let position = self.map_or(0, |lazy| lazy.position.get());\n+        let position: u32 = position.try_into().unwrap();\n+        position.write_to_bytes(position_bytes);\n \n         let len = self.map_or(0, |lazy| lazy.meta);\n         let len: u32 = len.try_into().unwrap();\n-\n-        len.write_to_bytes(&mut b[u32::BYTE_LEN..]);\n+        len.write_to_bytes(meta_bytes);\n     }\n }\n \n /// Random-access table (i.e. offering constant-time `get`/`set`), similar to\n /// `Vec<Option<T>>`, but without requiring encoding or decoding all the values\n /// eagerly and in-order.\n-/// A total of `(max_idx + 1) * <Option<T> as FixedSizeEncoding>::BYTE_LEN` bytes\n+/// A total of `(max_idx + 1)` times `Option<T> as FixedSizeEncoding>::ByteArray`\n /// are used for a table, where `max_idx` is the largest index passed to\n /// `TableBuilder::set`.\n pub(super) struct Table<I: Idx, T>\n@@ -135,53 +252,54 @@ pub(super) struct TableBuilder<I: Idx, T>\n where\n     Option<T>: FixedSizeEncoding,\n {\n-    // FIXME(eddyb) use `IndexVec<I, [u8; <Option<T>>::BYTE_LEN]>` instead of\n-    // `Vec<u8>`, once that starts working (i.e. lazy normalization).\n-    // Then again, that has the downside of not allowing `TableBuilder::encode` to\n-    // obtain a `&[u8]` entirely in safe code, for writing the bytes out.\n-    bytes: Vec<u8>,\n-    _marker: PhantomData<(fn(&I), T)>,\n+    blocks: IndexVec<I, <Option<T> as FixedSizeEncoding>::ByteArray>,\n+    _marker: PhantomData<T>,\n }\n \n impl<I: Idx, T> Default for TableBuilder<I, T>\n where\n     Option<T>: FixedSizeEncoding,\n {\n     fn default() -> Self {\n-        TableBuilder { bytes: vec![], _marker: PhantomData }\n+        TableBuilder { blocks: Default::default(), _marker: PhantomData }\n     }\n }\n \n impl<I: Idx, T> TableBuilder<I, T>\n where\n     Option<T>: FixedSizeEncoding,\n {\n-    pub(crate) fn set(&mut self, i: I, value: T) {\n+    pub(crate) fn set<const N: usize>(&mut self, i: I, value: T)\n+    where\n+        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n+    {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n-        let i = i.index();\n-        let needed = (i + 1) * <Option<T>>::BYTE_LEN;\n-        if self.bytes.len() < needed {\n-            self.bytes.resize(needed, 0);\n-        }\n-\n-        Some(value).write_to_bytes_at(&mut self.bytes, i);\n+        self.blocks.ensure_contains_elem(i, || [0; N]);\n+        Some(value).write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode(&self, buf: &mut Encoder) -> Lazy<Table<I, T>> {\n+    pub(crate) fn encode<const N: usize>(&self, buf: &mut Encoder) -> Lazy<Table<I, T>>\n+    where\n+        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n+    {\n         let pos = buf.position();\n-        buf.emit_raw_bytes(&self.bytes).unwrap();\n-        Lazy::from_position_and_meta(NonZeroUsize::new(pos as usize).unwrap(), self.bytes.len())\n+        for block in &self.blocks {\n+            buf.emit_raw_bytes(block).unwrap();\n+        }\n+        let num_bytes = self.blocks.len() * N;\n+        Lazy::from_position_and_meta(NonZeroUsize::new(pos as usize).unwrap(), num_bytes)\n     }\n }\n \n impl<I: Idx, T> LazyMeta for Table<I, T>\n where\n     Option<T>: FixedSizeEncoding,\n {\n+    /// Number of bytes in the data stream.\n     type Meta = usize;\n }\n \n@@ -191,16 +309,28 @@ where\n {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> Option<T> {\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>, const N: usize>(\n+        &self,\n+        metadata: M,\n+        i: I,\n+    ) -> Option<T>\n+    where\n+        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n+    {\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.meta];\n-        <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n+        let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n+        let bytes = bytes.get(i.index())?;\n+        FixedSizeEncoding::from_bytes(bytes)\n     }\n \n     /// Size of the table in entries, including possible gaps.\n-    pub(super) fn size(&self) -> usize {\n-        self.meta / <Option<T>>::BYTE_LEN\n+    pub(super) fn size<const N: usize>(&self) -> usize\n+    where\n+        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n+    {\n+        self.meta / N\n     }\n }"}]}