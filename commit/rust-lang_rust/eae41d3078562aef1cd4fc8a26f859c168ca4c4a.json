{"sha": "eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZTQxZDMwNzg1NjJhZWYxY2Q0ZmM4YTI2Zjg1OWMxNjhjYTRjNGE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-02T13:44:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-02T13:44:26Z"}, "message": "unify the 2 impl indexes", "tree": {"sha": "0ce57d4bd8a8d35c84904bf73e1c65713fef66f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ce57d4bd8a8d35c84904bf73e1c65713fef66f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "html_url": "https://github.com/rust-lang/rust/commit/eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/comments", "author": null, "committer": null, "parents": [{"sha": "55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "html_url": "https://github.com/rust-lang/rust/commit/55d35f12ae7a73fcef1c59b5b2cc0142a557934c"}], "stats": {"total": 115, "additions": 39, "deletions": 76}, "files": [{"sha": "a4fee5b7aa805f063835a603459fed7b8dd9b3fe", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "patch": "@@ -133,8 +133,7 @@ enum_from_u32! {\n         tag_table_method_map = 0x5f,\n         // GAP 0x60\n         tag_table_adjustments = 0x61,\n-        // GAP 0x62, 0x63\n-            // GAP 0x64, 0x65\n+        // GAP 0x62, 0x63, 0x64, 0x65\n         tag_table_upvar_capture_map = 0x66,\n         // GAP 0x67, 0x68\n         tag_table_const_qualif = 0x69,\n@@ -163,22 +162,17 @@ pub const tag_lang_items_missing: usize = 0x76;\n \n pub const tag_item_unnamed_field: usize = 0x77;\n pub const tag_items_data_item_visibility: usize = 0x78;\n-\n-// GAP 0x79, 0x7a\n-\n+pub const tag_items_data_item_inherent_impl: usize = 0x79;\n+// GAP 0x7a\n pub const tag_mod_child: usize = 0x7b;\n pub const tag_misc_info: usize = 0x108; // top-level only\n pub const tag_misc_info_crate_items: usize = 0x7c;\n \n-// GAP 0x7d\n-// GAP 0x7e\n-\n pub const tag_impls: usize = 0x109; // top-level only\n-pub const tag_impls_impl: usize = 0x7f;\n-pub const tag_impls_impl_trait_def_id: usize = 0x8d;\n+pub const tag_impls_trait: usize = 0x7d;\n+pub const tag_impls_trait_impl: usize = 0x7e;\n \n-pub const tag_items_data_item_inherent_impl: usize = 0x80;\n-pub const tag_items_data_item_extension_impl: usize = 0x81;\n+// GAP 0x7f, 0x80, 0x81\n \n pub const tag_native_libraries: usize = 0x10a; // top-level only\n pub const tag_native_libraries_lib: usize = 0x82;\n@@ -208,7 +202,7 @@ pub const tag_struct_field: usize = 0x8a;\n \n pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n-\n+// GAP 0x8d\n pub const tag_items_data_region: usize = 0x8e;\n \n pub const tag_region_param_def: usize = 0x8f;"}, {"sha": "8eea5b3553adf1c8df5205a244f96475ac55534e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "patch": "@@ -1284,24 +1284,19 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n                                         mut callback: F) where\n     F: FnMut(DefId),\n {\n-    if cdata.cnum == def_id.krate {\n-        let item_doc = cdata.lookup_item(def_id.index);\n-        for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n-            callback(item_def_id(impl_doc, cdata));\n-        }\n-        return;\n-    }\n-\n     // Do a reverse lookup beforehand to avoid touching the crate_num\n     // hash map in the loop below.\n     if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n         let def_id_u64 = def_to_u64(crate_local_did);\n \n         let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-        for impl_doc in reader::tagged_docs(impls_doc, tag_impls_impl) {\n-            let impl_trait = reader::get_doc(impl_doc, tag_impls_impl_trait_def_id);\n-            if reader::doc_as_u64(impl_trait) == def_id_u64 {\n-                callback(item_def_id(impl_doc, cdata));\n+        for trait_doc in reader::tagged_docs(impls_doc, tag_impls_trait) {\n+            let trait_def_id = reader::get_doc(trait_doc, tag_def_id);\n+            if reader::doc_as_u64(trait_def_id) != def_id_u64 {\n+                continue;\n+            }\n+            for impl_doc in reader::tagged_docs(trait_doc, tag_impls_trait_impl) {\n+                callback(translated_def_id(cdata, impl_doc));\n             }\n         }\n     }"}, {"sha": "9d2b1548f29d87c3a4e1dcfec371ae6f05465d70", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "patch": "@@ -865,20 +865,6 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     }\n }\n \n-// Encodes the implementations of a trait defined in this crate.\n-fn encode_extension_implementations(ecx: &EncodeContext,\n-                                    rbml_w: &mut Encoder,\n-                                    trait_def_id: DefId) {\n-    assert!(trait_def_id.is_local());\n-    let def = ecx.tcx.lookup_trait_def(trait_def_id);\n-\n-    def.for_each_impl(ecx.tcx, |impl_def_id| {\n-        rbml_w.start_tag(tag_items_data_item_extension_impl);\n-        encode_def_id(rbml_w, impl_def_id);\n-        rbml_w.end_tag();\n-    });\n-}\n-\n fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n         rbml_w.start_tag(tag_items_data_item_stability);\n@@ -1256,9 +1242,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_path(rbml_w, path.clone());\n \n-        // Encode the implementations of this trait.\n-        encode_extension_implementations(ecx, rbml_w, def_id);\n-\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n@@ -1763,53 +1746,44 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n \n \n \n-struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n-    ecx: &'a EncodeContext<'b, 'tcx>,\n-    rbml_w: &'a mut Encoder<'c>,\n+struct ImplVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    impls: FnvHashMap<DefId, Vec<DefId>>\n }\n \n-impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n-\n-            // Load eagerly if this is an implementation of the Drop trait\n-            // or if the trait is not defined in this crate.\n-            if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                    def_id.krate != LOCAL_CRATE {\n-                self.rbml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.rbml_w, self.ecx.tcx.map.local_def_id(item.id));\n-                self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n-                self.rbml_w.end_tag();\n+        if let hir::ItemImpl(..) = item.node {\n+            let impl_id = self.tcx.map.local_def_id(item.id);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n+                self.impls.entry(trait_ref.def_id)\n+                    .or_insert(vec![])\n+                    .push(impl_id);\n             }\n         }\n         visit::walk_item(self, item);\n     }\n }\n \n-/// Encodes implementations that are eagerly loaded.\n-///\n-/// None of this is necessary in theory; we can load all implementations\n-/// lazily. However, in two cases the optimizations to lazily load\n-/// implementations are not yet implemented. These two cases, which require us\n-/// to load implementations eagerly, are:\n-///\n-/// * Destructors (implementations of the Drop trait).\n-///\n-/// * Implementations of traits not defined in this crate.\n+/// Encodes an index, mapping each trait to its (local) implementations.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n                     krate: &hir::Crate,\n                     rbml_w: &'a mut Encoder) {\n-    rbml_w.start_tag(tag_impls);\n+    let mut visitor = ImplVisitor {\n+        tcx: ecx.tcx,\n+        impls: FnvHashMap()\n+    };\n+    visit::walk_crate(&mut visitor, krate);\n \n-    {\n-        let mut visitor = ImplVisitor {\n-            ecx: ecx,\n-            rbml_w: rbml_w,\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n+    rbml_w.start_tag(tag_impls);\n+    for (trait_, trait_impls) in visitor.impls {\n+        rbml_w.start_tag(tag_impls_trait);\n+        encode_def_id(rbml_w, trait_);\n+        for impl_ in trait_impls {\n+            rbml_w.wr_tagged_u64(tag_impls_trait_impl, def_to_u64(impl_));\n+        }\n+        rbml_w.end_tag();\n     }\n-\n     rbml_w.end_tag();\n }\n "}, {"sha": "6c23307c67776570279eecaf7d967e81a161f34b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eae41d3078562aef1cd4fc8a26f859c168ca4c4a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "patch": "@@ -1319,7 +1319,7 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n                 if let Some(ctor_id) = def.ctor_id {\n                     let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n                         .struct_variant().ctor_id;\n-                    println!(\"copying ctor {:?}\", ctor_did);\n+                    debug!(\"copying ctor {:?}\", ctor_did);\n                     copy_item_type(dcx, ctor_id, ctor_did);\n                 }\n             }"}]}