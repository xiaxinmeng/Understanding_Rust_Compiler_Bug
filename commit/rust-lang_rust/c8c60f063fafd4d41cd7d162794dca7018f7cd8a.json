{"sha": "c8c60f063fafd4d41cd7d162794dca7018f7cd8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YzYwZjA2M2ZhZmQ0ZDQxY2Q3ZDE2Mjc5NGRjYTcwMThmN2NkOGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-29T01:34:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-29T01:34:51Z"}, "message": "auto merge of #6740 : Aatch/rust/atomic-types, r=brson\n\nThis is a follow up to #6732. Makes everything a little more sound.\r\n\r\nr? @brson", "tree": {"sha": "0c4a41d66f69333628a8b401f651401331716613", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c4a41d66f69333628a8b401f651401331716613"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8c60f063fafd4d41cd7d162794dca7018f7cd8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c60f063fafd4d41cd7d162794dca7018f7cd8a", "html_url": "https://github.com/rust-lang/rust/commit/c8c60f063fafd4d41cd7d162794dca7018f7cd8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8c60f063fafd4d41cd7d162794dca7018f7cd8a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3d0c1eb0e86e04c2a6d5abe526516351cfaef3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d0c1eb0e86e04c2a6d5abe526516351cfaef3f", "html_url": "https://github.com/rust-lang/rust/commit/e3d0c1eb0e86e04c2a6d5abe526516351cfaef3f"}, {"sha": "df1814ba089e8b86bd7e191afa99c7bd10e05d4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1814ba089e8b86bd7e191afa99c7bd10e05d4f", "html_url": "https://github.com/rust-lang/rust/commit/df1814ba089e8b86bd7e191afa99c7bd10e05d4f"}], "stats": {"total": 186, "additions": 118, "deletions": 68}, "files": [{"sha": "ab2b5d8ea2b3b4b77154eb3a5bf92a8d4f1a9bf2", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 118, "deletions": 68, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/c8c60f063fafd4d41cd7d162794dca7018f7cd8a/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c60f063fafd4d41cd7d162794dca7018f7cd8a/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=c8c60f063fafd4d41cd7d162794dca7018f7cd8a", "patch": "@@ -10,30 +10,60 @@\n \n /*!\n  * Atomic types\n+ *\n+ * Basic atomic types supporting atomic operations. Each method takes an `Ordering` which\n+ * represents the strength of the memory barrier for that operation. These orderings are the same\n+ * as C++11 atomic orderings [http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync]\n+ *\n+ * All atomic types are a single word in size.\n  */\n \n use unstable::intrinsics;\n use cast;\n use option::{Option,Some,None};\n+use libc::c_void;\n+use ops::Drop;\n \n+/**\n+ * A simple atomic flag, that can be set and cleared. The most basic atomic type.\n+ */\n pub struct AtomicFlag {\n-    priv v:int\n+    priv v: int\n }\n \n+/**\n+ * An atomic boolean type.\n+ */\n pub struct AtomicBool {\n-    priv v:uint\n+    priv v: uint\n }\n \n+/**\n+ * A signed atomic integer type, supporting basic atomic aritmetic operations\n+ */\n pub struct AtomicInt {\n-    priv v:int\n+    priv v: int\n }\n \n+/**\n+ * An unsigned atomic integer type, supporting basic atomic aritmetic operations\n+ */\n pub struct AtomicUint {\n-    priv v:uint\n+    priv v: uint\n }\n \n+/**\n+ * An unsafe atomic pointer. Only supports basic atomic operations\n+ */\n pub struct AtomicPtr<T> {\n-    priv p:~T\n+    priv p: *mut T\n+}\n+\n+/**\n+ * An owned atomic pointer. Ensures that only a single reference to the data is held at any time.\n+ */\n+pub struct AtomicOption<T> {\n+    priv p: *mut c_void\n }\n \n pub enum Ordering {\n@@ -53,46 +83,46 @@ impl AtomicFlag {\n      * Clears the atomic flag\n      */\n     #[inline(always)]\n-    fn clear(&mut self, order:Ordering) {\n+    fn clear(&mut self, order: Ordering) {\n         unsafe {atomic_store(&mut self.v, 0, order)}\n     }\n \n-    #[inline(always)]\n     /**\n      * Sets the flag if it was previously unset, returns the previous value of the\n      * flag.\n      */\n-    fn test_and_set(&mut self, order:Ordering) -> bool {\n+    #[inline(always)]\n+    fn test_and_set(&mut self, order: Ordering) -> bool {\n         unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n     }\n }\n \n impl AtomicBool {\n-    fn new(v:bool) -> AtomicBool {\n+    fn new(v: bool) -> AtomicBool {\n         AtomicBool { v: if v { 1 } else { 0 } }\n     }\n \n     #[inline(always)]\n-    fn load(&self, order:Ordering) -> bool {\n+    fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(&self.v, order) > 0 }\n     }\n \n     #[inline(always)]\n-    fn store(&mut self, val:bool, order:Ordering) {\n+    fn store(&mut self, val: bool, order: Ordering) {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n     #[inline(always)]\n-    fn swap(&mut self, val:bool, order:Ordering) -> bool {\n+    fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_swap(&mut self.v, val, order) > 0}\n     }\n \n     #[inline(always)]\n-    fn compare_and_swap(&mut self, old: bool, new: bool, order:Ordering) -> bool {\n+    fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { 1 } else { 0 };\n         let new = if new { 1 } else { 0 };\n \n@@ -101,131 +131,152 @@ impl AtomicBool {\n }\n \n impl AtomicInt {\n-    fn new(v:int) -> AtomicInt {\n+    fn new(v: int) -> AtomicInt {\n         AtomicInt { v:v }\n     }\n \n     #[inline(always)]\n-    fn load(&self, order:Ordering) -> int {\n+    fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n     #[inline(always)]\n-    fn store(&mut self, val:int, order:Ordering) {\n+    fn store(&mut self, val: int, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n     #[inline(always)]\n-    fn swap(&mut self, val:int, order:Ordering) -> int {\n+    fn swap(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n     #[inline(always)]\n-    fn compare_and_swap(&mut self, old: int, new: int, order:Ordering) -> int {\n+    fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     #[inline(always)]\n-    fn fetch_add(&mut self, val:int, order:Ordering) -> int {\n+    fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     #[inline(always)]\n-    fn fetch_sub(&mut self, val:int, order:Ordering) -> int {\n+    fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n }\n \n impl AtomicUint {\n-    fn new(v:uint) -> AtomicUint {\n+    fn new(v: uint) -> AtomicUint {\n         AtomicUint { v:v }\n     }\n \n     #[inline(always)]\n-    fn load(&self, order:Ordering) -> uint {\n+    fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n     #[inline(always)]\n-    fn store(&mut self, val:uint, order:Ordering) {\n+    fn store(&mut self, val: uint, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n     #[inline(always)]\n-    fn swap(&mut self, val:uint, order:Ordering) -> uint {\n+    fn swap(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n     #[inline(always)]\n-    fn compare_and_swap(&mut self, old: uint, new: uint, order:Ordering) -> uint {\n+    fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     #[inline(always)]\n-    fn fetch_add(&mut self, val:uint, order:Ordering) -> uint {\n+    fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     #[inline(always)]\n-    fn fetch_sub(&mut self, val:uint, order:Ordering) -> uint {\n+    fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n }\n \n impl<T> AtomicPtr<T> {\n-    fn new(p:~T) -> AtomicPtr<T> {\n+    fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p:p }\n     }\n \n-    /**\n-     * Atomically swaps the stored pointer with the one given.\n-     *\n-     * Returns None if the pointer stored has been taken\n-     */\n     #[inline(always)]\n-    fn swap(&mut self, ptr:~T, order:Ordering) -> Option<~T> {\n+    fn load(&self, order: Ordering) -> *mut T {\n+        unsafe { atomic_load(&self.p, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn store(&mut self, ptr: *mut T, order: Ordering) {\n+        unsafe { atomic_store(&mut self.p, ptr, order); }\n+    }\n+\n+    #[inline(always)]\n+    fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n+        unsafe { atomic_swap(&mut self.p, ptr, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        unsafe { atomic_compare_and_swap(&mut self.p, old, new, order) }\n+    }\n+}\n+\n+impl<T> AtomicOption<T> {\n+    fn new(p: ~T) -> AtomicOption<T> {\n         unsafe {\n-            let p = atomic_swap(&mut self.p, ptr, order);\n+            AtomicOption {\n+                p: cast::transmute(p)\n+            }\n+        }\n+    }\n+\n+    fn empty() -> AtomicOption<T> {\n+        unsafe {\n+            AtomicOption {\n+                p: cast::transmute(0)\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n+        unsafe {\n+            let val = cast::transmute(val);\n+\n+            let p = atomic_swap(&mut self.p, val, order);\n             let pv : &uint = cast::transmute(&p);\n \n             if *pv == 0 {\n                 None\n             } else {\n-                Some(p)\n+                Some(cast::transmute(p))\n             }\n         }\n     }\n \n-    /**\n-     * Atomically takes the stored pointer out.\n-     *\n-     * Returns None if it was already taken.\n-     */\n     #[inline(always)]\n-    fn take(&mut self, order:Ordering) -> Option<~T> {\n-        unsafe { self.swap(cast::transmute(0), order) }\n-    }\n-\n-    /**\n-     * Atomically stores the given pointer, this will overwrite\n-     * and previous value stored.\n-     */\n-    #[inline(always)]\n-    fn give(&mut self, ptr:~T, order:Ordering) {\n-        let _ = self.swap(ptr, order);\n+    fn take(&mut self, order: Ordering) -> Option<~T> {\n+        unsafe {\n+            self.swap(cast::transmute(0), order)\n+        }\n     }\n+}\n \n-    /**\n-     * Checks to see if the stored pointer has been taken.\n-     */\n-    fn taken(&self, order:Ordering) -> bool {\n+#[unsafe_destructor]\n+impl<T> Drop for AtomicOption<T> {\n+    fn finalize(&self) {\n+        // This will ensure that the contained data is\n+        // destroyed, unless it's null.\n         unsafe {\n-            let p : ~T = atomic_load(&self.p, order);\n-\n-            let pv : &uint = cast::transmute(&p);\n-\n-            cast::forget(p);\n-            *pv == 0\n+            let this : &mut AtomicOption<T> = cast::transmute(self);\n+            let _ = this.take(SeqCst);\n         }\n     }\n }\n@@ -316,8 +367,8 @@ mod test {\n     }\n \n     #[test]\n-    fn pointer_swap() {\n-        let mut p = AtomicPtr::new(~1);\n+    fn option_swap() {\n+        let mut p = AtomicOption::new(~1);\n         let a = ~2;\n \n         let b = p.swap(a, SeqCst);\n@@ -327,15 +378,14 @@ mod test {\n     }\n \n     #[test]\n-    fn pointer_take() {\n-        let mut p = AtomicPtr::new(~1);\n+    fn option_take() {\n+        let mut p = AtomicOption::new(~1);\n \n         assert_eq!(p.take(SeqCst), Some(~1));\n         assert_eq!(p.take(SeqCst), None);\n-        assert!(p.taken(SeqCst));\n \n         let p2 = ~2;\n-        p.give(p2, SeqCst);\n+        p.swap(p2, SeqCst);\n \n         assert_eq!(p.take(SeqCst), Some(~2));\n     }"}]}