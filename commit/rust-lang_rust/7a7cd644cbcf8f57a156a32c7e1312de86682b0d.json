{"sha": "7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhN2NkNjQ0Y2JjZjhmNTdhMTU2YTMyYzdlMTMxMmRlODY2ODJiMGQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-03T01:14:59Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-16T22:30:39Z"}, "message": "rustdoc: refactoring and tidying up\n\npulled out of #35020", "tree": {"sha": "b8b87f63bf5c39f27657a97ea10728c5e5d0427c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8b87f63bf5c39f27657a97ea10728c5e5d0427c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "html_url": "https://github.com/rust-lang/rust/commit/7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "197be89f367d1240d5f9cd9c4efd77812775354e", "url": "https://api.github.com/repos/rust-lang/rust/commits/197be89f367d1240d5f9cd9c4efd77812775354e", "html_url": "https://github.com/rust-lang/rust/commit/197be89f367d1240d5f9cd9c4efd77812775354e"}], "stats": {"total": 226, "additions": 114, "deletions": 112}, "files": [{"sha": "8802bc6dc42e039e2875fabb84b6a5a5ca66449b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "patch": "@@ -326,7 +326,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.to_static_str());\n+            url.push_str(shortty.css_class());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");"}, {"sha": "c3d38637ab70ccfc7f0f3db07c625a690c792f81", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "patch": "@@ -90,7 +90,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn to_static_str(&self) -> &'static str {\n+    pub fn css_class(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -117,6 +117,6 @@ impl ItemType {\n \n impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_static_str().fmt(f)\n+        self.css_class().fmt(f)\n     }\n }"}, {"sha": "151e138efefbf0a3a09595d0c4fa13f9441fb6a8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "patch": "@@ -24,7 +24,7 @@ pub struct Layout {\n \n pub struct Page<'a> {\n     pub title: &'a str,\n-    pub ty: &'a str,\n+    pub css_class: &'a str,\n     pub root_path: &'a str,\n     pub description: &'a str,\n     pub keywords: &'a str,\n@@ -80,7 +80,7 @@ r##\"<!DOCTYPE html>\n         </form>\n     </nav>\n \n-    <section id='main' class=\"content {ty}\">{content}</section>\n+    <section id='main' class=\"content {css_class}\">{content}</section>\n     <section id='search' class=\"content hidden\"></section>\n \n     <section class=\"footer\"></section>\n@@ -152,7 +152,7 @@ r##\"<!DOCTYPE html>\n     },\n     content   = *t,\n     root_path = page.root_path,\n-    ty        = page.ty,\n+    css_class = page.css_class,\n     logo      = if layout.logo.is_empty() {\n         \"\".to_string()\n     } else {"}, {"sha": "963ea48d634200bf50d9540df77ce11ad6fea61e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 108, "deletions": 106, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a7cd644cbcf8f57a156a32c7e1312de86682b0d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7a7cd644cbcf8f57a156a32c7e1312de86682b0d", "patch": "@@ -587,7 +587,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_methods {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n             search_index.push(IndexItem {\n-                ty: shortty(item),\n+                ty: item_type(item),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -714,10 +714,10 @@ fn write_shared(cx: &Context,\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if !line.starts_with(key) {\n-                    continue\n+                    continue;\n                 }\n                 if line.starts_with(&format!(r#\"{}[\"{}\"]\"#, key, krate)) {\n-                    continue\n+                    continue;\n                 }\n                 ret.push(line.to_string());\n             }\n@@ -761,7 +761,7 @@ fn write_shared(cx: &Context,\n             try_err!(mkdir(&mydst), &mydst);\n         }\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.to_static_str(),\n+                            remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n         let all_implementors = try_err!(collect(&mydst, &krate.name,\n                                                 \"implementors\"),\n@@ -832,7 +832,7 @@ fn mkdir(path: &Path) -> io::Result<()> {\n }\n \n /// Returns a documentation-level item type from the item.\n-fn shortty(item: &clean::Item) -> ItemType {\n+fn item_type(item: &clean::Item) -> ItemType {\n     ItemType::from_item(item)\n }\n \n@@ -952,7 +952,7 @@ impl<'a> SourceCollector<'a> {\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n-        cur.push(&fname[..]);\n+        cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n         let mut w = BufWriter::new(File::create(&cur)?);\n@@ -961,7 +961,7 @@ impl<'a> SourceCollector<'a> {\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {\n             title: &title,\n-            ty: \"source\",\n+            css_class: \"source\",\n             root_path: &root_path,\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n@@ -1080,7 +1080,7 @@ impl DocFolder for Cache {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n-                            ty: shortty(&item),\n+                            ty: item_type(&item),\n                             name: s.to_string(),\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -1126,7 +1126,7 @@ impl DocFolder for Cache {\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), shortty(&item)));\n+                                      (self.stack.clone(), item_type(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -1139,7 +1139,7 @@ impl DocFolder for Cache {\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n                 self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                shortty(&item)));\n+                                                item_type(&item)));\n             }\n \n             _ => {}\n@@ -1283,74 +1283,77 @@ impl Context {\n         Ok(())\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        fn render(writer: &mut io::Write, cx: &Context, it: &clean::Item,\n-                  pushname: bool) -> io::Result<()> {\n-            // A little unfortunate that this is done like this, but it sure\n-            // does make formatting *a lot* nicer.\n-            CURRENT_LOCATION_KEY.with(|slot| {\n-                *slot.borrow_mut() = cx.current.clone();\n-            });\n+    fn render_item(&self,\n+                   writer: &mut io::Write,\n+                   it: &clean::Item,\n+                   pushname: bool)\n+                   -> io::Result<()> {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_LOCATION_KEY.with(|slot| {\n+            *slot.borrow_mut() = self.current.clone();\n+        });\n \n-            let mut title = if it.is_primitive() {\n-                // No need to include the namespace for primitive types\n-                String::new()\n-            } else {\n-                cx.current.join(\"::\")\n-            };\n-            if pushname {\n-                if !title.is_empty() {\n-                    title.push_str(\"::\");\n-                }\n-                title.push_str(it.name.as_ref().unwrap());\n+        let mut title = if it.is_primitive() {\n+            // No need to include the namespace for primitive types\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n             }\n-            title.push_str(\" - Rust\");\n-            let tyname = shortty(it).to_static_str();\n-            let desc = if it.is_crate() {\n-                format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.shared.layout.krate)\n-            } else {\n-                format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n-            };\n-            let keywords = make_item_keywords(it);\n-            let page = layout::Page {\n-                ty: tyname,\n-                root_path: &cx.root_path,\n-                title: &title,\n-                description: &desc,\n-                keywords: &keywords,\n-            };\n+            title.push_str(it.name.as_ref().unwrap());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = item_type(it).css_class();\n+        let desc = if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\",\n+                    self.shared.layout.krate)\n+        } else {\n+            format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                    it.name.as_ref().unwrap(), tyname, self.shared.layout.krate)\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname,\n+            root_path: &self.root_path,\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+        };\n \n-            reset_ids(true);\n+        reset_ids(true);\n \n-            if !cx.render_redirect_pages {\n-                layout::render(writer, &cx.shared.layout, &page,\n-                               &Sidebar{ cx: cx, item: it },\n-                               &Item{ cx: cx, item: it },\n-                               cx.shared.css_file_extension.is_some())?;\n-            } else {\n-                let mut url = repeat(\"../\").take(cx.current.len())\n-                                           .collect::<String>();\n-                if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n-                    for name in &names[..names.len() - 1] {\n-                        url.push_str(name);\n-                        url.push_str(\"/\");\n-                    }\n-                    url.push_str(&item_path(ty, names.last().unwrap()));\n-                    layout::redirect(writer, &url)?;\n+        if !self.render_redirect_pages {\n+            layout::render(writer, &self.shared.layout, &page,\n+                           &Sidebar{ cx: self, item: it },\n+                           &Item{ cx: self, item: it },\n+                           self.shared.css_file_extension.is_some())?;\n+        } else {\n+            let mut url = repeat(\"../\").take(self.current.len())\n+                                       .collect::<String>();\n+            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+                for name in &names[..names.len() - 1] {\n+                    url.push_str(name);\n+                    url.push_str(\"/\");\n                 }\n+                url.push_str(&item_path(ty, names.last().unwrap()));\n+                layout::redirect(writer, &url)?;\n             }\n-            Ok(())\n         }\n+        Ok(())\n+    }\n \n+    /// Non-parallelized version of rendering an item. This will take the input\n+    /// item, render its contents, and then invoke the specified closure with\n+    /// all sub-items which need to be rendered.\n+    ///\n+    /// The rendering driver uses this closure to queue up more work.\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n+        F: FnMut(&mut Context, clean::Item),\n+    {\n         // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n@@ -1371,7 +1374,7 @@ impl Context {\n                 let item = item.take().unwrap();\n \n                 let mut buf = Vec::new();\n-                render(&mut buf, this, &item, false).unwrap();\n+                this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n                     let joint_dst = this.dst.join(\"index.html\");\n@@ -1386,7 +1389,7 @@ impl Context {\n                     _ => unreachable!()\n                 };\n \n-                // render sidebar-items.js used throughout this module\n+                // Render sidebar-items.js used throughout this module.\n                 if !this.render_redirect_pages {\n                     let items = this.build_sidebar_items(&m);\n                     let js_dst = this.dst.join(\"sidebar-items.js\");\n@@ -1398,23 +1401,22 @@ impl Context {\n                 for item in m.items {\n                     f(this,item);\n                 }\n+\n                 Ok(())\n-            })\n+            })?;\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n-            render(&mut buf, self, &item, true).unwrap();\n+            self.render_item(&mut buf, &item, true).unwrap();\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n-                let joint_dst = self.dst.join(&item_path(shortty(&item),\n+                let joint_dst = self.dst.join(&item_path(item_type(&item),\n                                                          item.name.as_ref().unwrap()));\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n                 let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                 try_err!(dst.write_all(&buf), &joint_dst);\n             }\n-            Ok(())\n-        } else {\n-            Ok(())\n         }\n+        Ok(())\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n@@ -1423,7 +1425,7 @@ impl Context {\n         for item in &m.items {\n             if self.maybe_ignore_item(item) { continue }\n \n-            let short = shortty(item).to_static_str();\n+            let short = item_type(item).css_class();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -1531,7 +1533,7 @@ impl<'a> Item<'a> {\n             }\n             Some(format!(\"{path}{file}?gotosrc={goto}\",\n                          path = path,\n-                         file = item_path(shortty(self.item), external_path.last().unwrap()),\n+                         file = item_path(item_type(self.item), external_path.last().unwrap()),\n                          goto = self.item.def_id.index.as_usize()))\n         }\n     }\n@@ -1566,7 +1568,7 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-               shortty(self.item), self.item.name.as_ref().unwrap())?;\n+               item_type(self.item), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n@@ -1622,7 +1624,7 @@ impl<'a> fmt::Display for Item<'a> {\n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n         ItemType::Module => format!(\"{}/index.html\", name),\n-        _ => format!(\"{}.{}.html\", ty.to_static_str(), name),\n+        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n     }\n }\n \n@@ -1714,8 +1716,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     }\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n-        let ty1 = shortty(i1);\n-        let ty2 = shortty(i2);\n+        let ty1 = item_type(i1);\n+        let ty2 = item_type(i2);\n         if ty1 != ty2 {\n             return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n         }\n@@ -1739,7 +1741,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             continue;\n         }\n \n-        let myty = Some(shortty(myitem));\n+        let myty = Some(item_type(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n             // Put `extern crate` and `use` re-exports in the same section.\n             curty = myty;\n@@ -1825,9 +1827,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                       class = shortty(myitem),\n+                       class = item_type(myitem),\n                        stab = myitem.stability_class(),\n-                       href = item_path(shortty(myitem), myitem.name.as_ref().unwrap()),\n+                       href = item_path(item_type(myitem), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n         }\n@@ -2022,7 +2024,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n-        let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n+        let id = derive_id(format!(\"{}.{}\", item_type(m), name));\n         write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n                id = id,\n                stab = m.stability_class())?;\n@@ -2104,7 +2106,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = shortty(it).to_static_str(),\n+           ty = item_type(it).css_class(),\n            name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n@@ -2113,7 +2115,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     use html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n-    let ty = match shortty(it) {\n+    let ty = match item_type(it) {\n         Typedef | AssociatedType => AssociatedType,\n         s@_ => s,\n     };\n@@ -2191,7 +2193,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               link: AssocItemLink)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", shortty(meth), name);\n+        let anchor = format!(\"#{}.{}\", item_type(meth), name);\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n             AssocItemLink::Anchor(None) => anchor,\n@@ -2268,9 +2270,9 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         if fields.peek().is_some() {\n             write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n-                write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n+                write!(w, \"<span id='{item_type}.{name}' class='{item_type}'><code>{name}: {ty}</code>\n                            </span><span class='stab {stab}'></span>\",\n-                       shortty = ItemType::StructField,\n+                       item_type = ItemType::StructField,\n                        stab = field.stability_class(),\n                        name = field.name.as_ref().unwrap(),\n                        ty = ty)?;\n@@ -2339,8 +2341,8 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<span id='{shortty}.{name}' class='variant'><code>{name}\",\n-                   shortty = ItemType::Variant,\n+            write!(w, \"<span id='{item_type}.{name}' class='variant'><code>{name}\",\n+                   item_type = ItemType::Variant,\n                    name = variant.name.as_ref().unwrap())?;\n             if let clean::VariantItem(ref var) = variant.inner {\n                 if let clean::TupleVariant(ref tys) = var.kind {\n@@ -2588,7 +2590,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     link: AssocItemLink, render_static: bool,\n                     is_default_item: bool, outer_version: Option<&str>,\n                     trait_: Option<&clean::Trait>) -> fmt::Result {\n-        let shortty = shortty(item);\n+        let item_type = item_type(item);\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n@@ -2601,8 +2603,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static || render_static {\n-                    let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty)?;\n+                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id))?;\n                     write!(w, \"</code>\")?;\n@@ -2612,25 +2614,25 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, item_type)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n@@ -2749,7 +2751,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                    relpath: '{path}'\\\n                 }};</script>\",\n                name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = shortty(it).to_static_str(),\n+               ty = item_type(it).css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path"}]}