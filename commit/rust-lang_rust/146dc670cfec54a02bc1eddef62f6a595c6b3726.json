{"sha": "146dc670cfec54a02bc1eddef62f6a595c6b3726", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NmRjNjcwY2ZlYzU0YTAyYmMxZWRkZWY2MmY2YTU5NWM2YjM3MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-03T03:24:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-03T03:24:35Z"}, "message": "Auto merge of #41717 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #41217, #41625, #41640, #41653, #41656, #41657, #41705\n- Failed merges:", "tree": {"sha": "763b7680341f8413be81b4facaf9f84eb75229e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763b7680341f8413be81b4facaf9f84eb75229e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/146dc670cfec54a02bc1eddef62f6a595c6b3726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/146dc670cfec54a02bc1eddef62f6a595c6b3726", "html_url": "https://github.com/rust-lang/rust/commit/146dc670cfec54a02bc1eddef62f6a595c6b3726", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/146dc670cfec54a02bc1eddef62f6a595c6b3726/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0634f0a30f94116ee13c16fb1a35c4c92253ab13", "url": "https://api.github.com/repos/rust-lang/rust/commits/0634f0a30f94116ee13c16fb1a35c4c92253ab13", "html_url": "https://github.com/rust-lang/rust/commit/0634f0a30f94116ee13c16fb1a35c4c92253ab13"}, {"sha": "2b51384a2d6973b307ca126551fbe838cf7384d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b51384a2d6973b307ca126551fbe838cf7384d0", "html_url": "https://github.com/rust-lang/rust/commit/2b51384a2d6973b307ca126551fbe838cf7384d0"}], "stats": {"total": 6878, "additions": 1355, "deletions": 5523}, "files": [{"sha": "e77db28967e336b9474caad94b3276cd4508d970", "filename": "src/grammar/.gitignore", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,4 +0,0 @@\n-verify\n-*.class\n-*.java\n-*.tokens"}, {"sha": "83808108ff8325900f506e66c67677f8aeea960f", "filename": "src/grammar/README.md", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FREADME.md?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,33 +0,0 @@\n-# Reference grammar.\n-\n-Uses [antlr4](http://www.antlr.org/) and a custom Rust tool to compare\n-ASTs/token streams generated. You can use the `make check-lexer` target to\n-run all of the available tests.\n-\n-The build of the rust part is included with `make tidy` and can be run with `make check-build-lexer-verifier`.\n-\n-# Manual build\n-\n-To use manually, assuming antlr4 is installed at `/usr/share/java/antlr-complete.jar`:\n-\n-```\n-antlr4 RustLexer.g4\n-javac -classpath /usr/share/java/antlr-complete.jar *.java\n-rustc -O verify.rs\n-for file in ../*/**.rs; do\n-    echo $file;\n-    grun RustLexer tokens -tokens < \"$file\" | ./verify \"$file\" RustLexer.tokens || break\n-done\n-```\n-\n-Note that the `../*/**.rs` glob will match every `*.rs` file in the above\n-directory and all of its recursive children. This is a Zsh extension.\n-\n-\n-## Cleanup\n-\n-To cleanup you can use a command like this:\n-\n-```bash\n-rm -f verify *.class *.java *.tokens\n-```"}, {"sha": "a63fc59e50b07145a92b4a0ef9aac1d511dd8478", "filename": "src/grammar/RustLexer.g4", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,197 +0,0 @@\n-lexer grammar RustLexer;\n-\n-@lexer::members {\n-  public boolean is_at(int pos) {\n-    return _input.index() == pos;\n-  }\n-}\n-\n-\n-tokens {\n-    EQ, LT, LE, EQEQ, NE, GE, GT, ANDAND, OROR, NOT, TILDE, PLUS,\n-    MINUS, STAR, SLASH, PERCENT, CARET, AND, OR, SHL, SHR, BINOP,\n-    BINOPEQ, LARROW, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n-    MOD_SEP, RARROW, FAT_ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET,\n-    LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR, LIT_BYTE,\n-    LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BYTE_STR,\n-    LIT_BYTE_STR_RAW, QUESTION, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n-    COMMENT, SHEBANG, UTF8_BOM\n-}\n-\n-import xidstart , xidcontinue;\n-\n-\n-/* Expression-operator symbols */\n-\n-EQ      : '=' ;\n-LT      : '<' ;\n-LE      : '<=' ;\n-EQEQ    : '==' ;\n-NE      : '!=' ;\n-GE      : '>=' ;\n-GT      : '>' ;\n-ANDAND  : '&&' ;\n-OROR    : '||' ;\n-NOT     : '!' ;\n-TILDE   : '~' ;\n-PLUS    : '+' ;\n-MINUS   : '-' ;\n-STAR    : '*' ;\n-SLASH   : '/' ;\n-PERCENT : '%' ;\n-CARET   : '^' ;\n-AND     : '&' ;\n-OR      : '|' ;\n-SHL     : '<<' ;\n-SHR     : '>>' ;\n-LARROW  : '<-' ;\n-\n-BINOP\n-    : PLUS\n-    | SLASH\n-    | MINUS\n-    | STAR\n-    | PERCENT\n-    | CARET\n-    | AND\n-    | OR\n-    | SHL\n-    | SHR\n-    | LARROW\n-    ;\n-\n-BINOPEQ : BINOP EQ ;\n-\n-/* \"Structural symbols\" */\n-\n-AT         : '@' ;\n-DOT        : '.' ;\n-DOTDOT     : '..' ;\n-DOTDOTDOT  : '...' ;\n-COMMA      : ',' ;\n-SEMI       : ';' ;\n-COLON      : ':' ;\n-MOD_SEP    : '::' ;\n-RARROW     : '->' ;\n-FAT_ARROW  : '=>' ;\n-LPAREN     : '(' ;\n-RPAREN     : ')' ;\n-LBRACKET   : '[' ;\n-RBRACKET   : ']' ;\n-LBRACE     : '{' ;\n-RBRACE     : '}' ;\n-POUND      : '#';\n-DOLLAR     : '$' ;\n-UNDERSCORE : '_' ;\n-\n-// Literals\n-\n-fragment HEXIT\n-  : [0-9a-fA-F]\n-  ;\n-\n-fragment CHAR_ESCAPE\n-  : [nrt\\\\'\"0]\n-  | [xX] HEXIT HEXIT\n-  | 'u' HEXIT HEXIT HEXIT HEXIT\n-  | 'U' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT\n-  | 'u{' HEXIT '}'\n-  | 'u{' HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT '}'\n-  ;\n-\n-fragment SUFFIX\n-  : IDENT\n-  ;\n-\n-fragment INTEGER_SUFFIX\n-  : { _input.LA(1) != 'e' && _input.LA(1) != 'E' }? SUFFIX\n-  ;\n-\n-LIT_CHAR\n-  : '\\'' ( '\\\\' CHAR_ESCAPE\n-         | ~[\\\\'\\n\\t\\r]\n-         | '\\ud800' .. '\\udbff' '\\udc00' .. '\\udfff'\n-         )\n-    '\\'' SUFFIX?\n-  ;\n-\n-LIT_BYTE\n-  : 'b\\'' ( '\\\\' ( [xX] HEXIT HEXIT\n-                 | [nrt\\\\'\"0] )\n-          | ~[\\\\'\\n\\t\\r] '\\udc00'..'\\udfff'?\n-          )\n-    '\\'' SUFFIX?\n-  ;\n-\n-LIT_INTEGER\n-\n-  : [0-9][0-9_]* INTEGER_SUFFIX?\n-  | '0b' [01_]+ INTEGER_SUFFIX?\n-  | '0o' [0-7_]+ INTEGER_SUFFIX?\n-  | '0x' [0-9a-fA-F_]+ INTEGER_SUFFIX?\n-  ;\n-\n-LIT_FLOAT\n-  : [0-9][0-9_]* ('.' {\n-        /* dot followed by another dot is a range, not a float */\n-        _input.LA(1) != '.' &&\n-        /* dot followed by an identifier is an integer with a function call, not a float */\n-        _input.LA(1) != '_' &&\n-        !(_input.LA(1) >= 'a' && _input.LA(1) <= 'z') &&\n-        !(_input.LA(1) >= 'A' && _input.LA(1) <= 'Z')\n-  }? | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n-  ;\n-\n-LIT_STR\n-  : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"' SUFFIX?\n-  ;\n-\n-LIT_BYTE_STR : 'b' LIT_STR ;\n-LIT_BYTE_STR_RAW : 'b' LIT_STR_RAW ;\n-\n-/* this is a bit messy */\n-\n-fragment LIT_STR_RAW_INNER\n-  : '\"' .*? '\"'\n-  | LIT_STR_RAW_INNER2\n-  ;\n-\n-fragment LIT_STR_RAW_INNER2\n-  : POUND LIT_STR_RAW_INNER POUND\n-  ;\n-\n-LIT_STR_RAW\n-  : 'r' LIT_STR_RAW_INNER SUFFIX?\n-  ;\n-\n-\n-QUESTION : '?';\n-\n-IDENT : XID_Start XID_Continue* ;\n-\n-fragment QUESTION_IDENTIFIER : QUESTION? IDENT;\n-\n-LIFETIME : '\\'' IDENT ;\n-\n-WHITESPACE : [ \\r\\n\\t]+ ;\n-\n-UNDOC_COMMENT     : '////' ~[\\n]* -> type(COMMENT) ;\n-YESDOC_COMMENT    : '///' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n-OUTER_DOC_COMMENT : '//!' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n-LINE_COMMENT      : '//' ( ~[/\\n] ~[\\n]* )? -> type(COMMENT) ;\n-\n-DOC_BLOCK_COMMENT\n-  : ('/**' ~[*] | '/*!') (DOC_BLOCK_COMMENT | .)*? '*/' -> type(DOC_COMMENT)\n-  ;\n-\n-BLOCK_COMMENT : '/*' (BLOCK_COMMENT | .)*? '*/' -> type(COMMENT) ;\n-\n-/* these appear at the beginning of a file */\n-\n-SHEBANG : '#!' { is_at(2) && _input.LA(1) != '[' }? ~[\\r\\n]* -> type(SHEBANG) ;\n-\n-UTF8_BOM : '\\ufeff' { is_at(1) }? -> skip ;"}, {"sha": "70a8f6fca2e5c68c8fe6e043a2f76e4658e19b93", "filename": "src/grammar/check.sh", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,52 +0,0 @@\n-#!/bin/sh\n-\n-# ignore-license\n-\n-# Run the reference lexer against libsyntax and compare the tokens and spans.\n-# If \"// ignore-lexer-test\" is present in the file, it will be ignored.\n-\n-\n-# Argument $1 is the file to check, $2 is the classpath to use, $3 is the path\n-# to the grun binary, $4 is the path to the verify binary, $5 is the path to\n-# RustLexer.tokens\n-if [ \"${VERBOSE}\" == \"1\" ]; then\n-    set -x\n-fi\n-\n-passed=0\n-failed=0\n-skipped=0\n-\n-check() {\n-    grep --silent \"// ignore-lexer-test\" \"$1\";\n-\n-    # if it is *not* found...\n-    if [ $? -eq 1 ]; then\n-        cd $2 # This `cd` is so java will pick up RustLexer.class. I could not\n-        # figure out how to wrangle the CLASSPATH, just adding build/grammar\n-        # did not seem to have any effect.\n-        if $3 RustLexer tokens -tokens < $1 | $4 $1 $5; then\n-            echo \"pass: $1\"\n-            passed=`expr $passed + 1`\n-        else\n-            echo \"fail: $1\"\n-            failed=`expr $failed + 1`\n-        fi\n-    else\n-        echo \"skip: $1\"\n-        skipped=`expr $skipped + 1`\n-    fi\n-}\n-\n-for file in $(find $1 -iname '*.rs' ! -path '*/test/compile-fail*'); do\n-    check \"$file\" $2 $3 $4 $5\n-done\n-\n-printf \"\\ntest result: \"\n-\n-if [ $failed -eq 0 ]; then\n-    printf \"ok. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n-else\n-    printf \"failed. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n-    exit 1\n-fi"}, {"sha": "77737c99496f34757127d29e0040da0ff7f4fa56", "filename": "src/grammar/lexer.l", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,343 +0,0 @@\n-%{\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <ctype.h>\n-\n-static int num_hashes;\n-static int end_hashes;\n-static int saw_non_hash;\n-\n-%}\n-\n-%option stack\n-%option yylineno\n-\n-%x str\n-%x rawstr\n-%x rawstr_esc_begin\n-%x rawstr_esc_body\n-%x rawstr_esc_end\n-%x byte\n-%x bytestr\n-%x rawbytestr\n-%x rawbytestr_nohash\n-%x pound\n-%x shebang_or_attr\n-%x ltorchar\n-%x linecomment\n-%x doc_line\n-%x blockcomment\n-%x doc_block\n-%x suffix\n-\n-ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n-\n-%%\n-\n-<suffix>{ident}            { BEGIN(INITIAL); }\n-<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n-\n-[ \\n\\t\\r]             { }\n-\n-\\xef\\xbb\\xbf {\n-  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n-  if (yyget_lineno() != 1) {\n-    return -1;\n-  }\n-}\n-\n-\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n-<doc_line>\\n          { BEGIN(INITIAL);\n-                        yyleng--;\n-                        yytext[yyleng] = 0;\n-                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-                      }\n-<doc_line>[^\\n]*      { yymore(); }\n-\n-\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n-<linecomment>\\n       { BEGIN(INITIAL); }\n-<linecomment>[^\\n]*   { }\n-\n-\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n-<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n-<doc_block>\\*\\/       {\n-    yy_pop_state();\n-    if (yy_top_state() == doc_block) {\n-        yymore();\n-    } else {\n-        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-    }\n-}\n-<doc_block>(.|\\n)     { yymore(); }\n-\n-\\/\\*                  { yy_push_state(blockcomment); }\n-<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n-<blockcomment>\\*\\/    { yy_pop_state(); }\n-<blockcomment>(.|\\n)   { }\n-\n-_        { return UNDERSCORE; }\n-as       { return AS; }\n-box      { return BOX; }\n-break    { return BREAK; }\n-const    { return CONST; }\n-continue { return CONTINUE; }\n-crate    { return CRATE; }\n-else     { return ELSE; }\n-enum     { return ENUM; }\n-extern   { return EXTERN; }\n-false    { return FALSE; }\n-fn       { return FN; }\n-for      { return FOR; }\n-if       { return IF; }\n-impl     { return IMPL; }\n-in       { return IN; }\n-let      { return LET; }\n-loop     { return LOOP; }\n-match    { return MATCH; }\n-mod      { return MOD; }\n-move     { return MOVE; }\n-mut      { return MUT; }\n-priv     { return PRIV; }\n-proc     { return PROC; }\n-pub      { return PUB; }\n-ref      { return REF; }\n-return   { return RETURN; }\n-self     { return SELF; }\n-static   { return STATIC; }\n-struct   { return STRUCT; }\n-trait    { return TRAIT; }\n-true     { return TRUE; }\n-type     { return TYPE; }\n-typeof   { return TYPEOF; }\n-unsafe   { return UNSAFE; }\n-use      { return USE; }\n-where    { return WHERE; }\n-while    { return WHILE; }\n-\n-{ident}  { return IDENT; }\n-\n-0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n-0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n-\n-[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n-[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n-\n-;      { return ';'; }\n-,      { return ','; }\n-\\.\\.\\. { return DOTDOTDOT; }\n-\\.\\.   { return DOTDOT; }\n-\\.     { return '.'; }\n-\\(     { return '('; }\n-\\)     { return ')'; }\n-\\{     { return '{'; }\n-\\}     { return '}'; }\n-\\[     { return '['; }\n-\\]     { return ']'; }\n-@      { return '@'; }\n-#      { BEGIN(pound); yymore(); }\n-<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n-<shebang_or_attr>\\[ {\n-  BEGIN(INITIAL);\n-  yyless(2);\n-  return SHEBANG;\n-}\n-<shebang_or_attr>[^\\[\\n]*\\n {\n-  // Since the \\n was eaten as part of the token, yylineno will have\n-  // been incremented to the value 2 if the shebang was on the first\n-  // line. This yyless undoes that, setting yylineno back to 1.\n-  yyless(yyleng - 1);\n-  if (yyget_lineno() == 1) {\n-    BEGIN(INITIAL);\n-    return SHEBANG_LINE;\n-  } else {\n-    BEGIN(INITIAL);\n-    yyless(2);\n-    return SHEBANG;\n-  }\n-}\n-<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n-\n-\\~     { return '~'; }\n-::     { return MOD_SEP; }\n-:      { return ':'; }\n-\\$     { return '$'; }\n-\\?     { return '?'; }\n-\n-==    { return EQEQ; }\n-=>    { return FAT_ARROW; }\n-=     { return '='; }\n-\\!=   { return NE; }\n-\\!    { return '!'; }\n-\\<=   { return LE; }\n-\\<\\<  { return SHL; }\n-\\<\\<= { return SHLEQ; }\n-\\<    { return '<'; }\n-\\>=   { return GE; }\n-\\>\\>  { return SHR; }\n-\\>\\>= { return SHREQ; }\n-\\>    { return '>'; }\n-\n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n-\n-b\\x22              { BEGIN(bytestr); yymore(); }\n-<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n-\n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n-\n-br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n-<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n-<rawbytestr_nohash>(.|\\n)   { yymore(); }\n-<rawbytestr_nohash><<EOF>>  { return -1; }\n-\n-br/# {\n-    BEGIN(rawbytestr);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-<rawbytestr># {\n-    if (!saw_non_hash) {\n-        num_hashes++;\n-    } else if (end_hashes != 0) {\n-        end_hashes++;\n-        if (end_hashes == num_hashes) {\n-            BEGIN(INITIAL);\n-            return LIT_BYTE_STR_RAW;\n-        }\n-    }\n-    yymore();\n-}\n-<rawbytestr>\\x22# {\n-    end_hashes = 1;\n-    if (end_hashes == num_hashes) {\n-        BEGIN(INITIAL);\n-        return LIT_BYTE_STR_RAW;\n-    }\n-    yymore();\n-}\n-<rawbytestr>(.|\\n) {\n-    if (!saw_non_hash) {\n-        saw_non_hash = 1;\n-    }\n-    if (end_hashes != 0) {\n-        end_hashes = 0;\n-    }\n-    yymore();\n-}\n-<rawbytestr><<EOF>> { return -1; }\n-\n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n-\n-r\\x22           { BEGIN(rawstr); yymore(); }\n-<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n-<rawstr>(.|\\n)  { yymore(); }\n-<rawstr><<EOF>> { return -1; }\n-\n-r/#             {\n-    BEGIN(rawstr_esc_begin);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-\n-<rawstr_esc_begin># {\n-    num_hashes++;\n-    yymore();\n-}\n-<rawstr_esc_begin>\\x22 {\n-    BEGIN(rawstr_esc_body);\n-    yymore();\n-}\n-<rawstr_esc_begin>(.|\\n) { return -1; }\n-\n-<rawstr_esc_body>\\x22/# {\n-  BEGIN(rawstr_esc_end);\n-  yymore();\n- }\n-<rawstr_esc_body>(.|\\n) {\n-  yymore();\n- }\n-\n-<rawstr_esc_end># {\n-  end_hashes++;\n-  if (end_hashes == num_hashes) {\n-    BEGIN(INITIAL);\n-    return LIT_STR_RAW;\n-  }\n-  yymore();\n- }\n-<rawstr_esc_end>[^#] {\n-  end_hashes = 0;\n-  BEGIN(rawstr_esc_body);\n-  yymore();\n- }\n-\n-<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n-\n-\\x22                     { BEGIN(str); yymore(); }\n-<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n-\n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n-\n-\\<-  { return LARROW; }\n--\\>  { return RARROW; }\n--    { return '-'; }\n--=   { return MINUSEQ; }\n-&&   { return ANDAND; }\n-&    { return '&'; }\n-&=   { return ANDEQ; }\n-\\|\\| { return OROR; }\n-\\|   { return '|'; }\n-\\|=  { return OREQ; }\n-\\+   { return '+'; }\n-\\+=  { return PLUSEQ; }\n-\\*   { return '*'; }\n-\\*=  { return STAREQ; }\n-\\/   { return '/'; }\n-\\/=  { return SLASHEQ; }\n-\\^   { return '^'; }\n-\\^=  { return CARETEQ; }\n-%    { return '%'; }\n-%=   { return PERCENTEQ; }\n-\n-<<EOF>> { return 0; }\n-\n-%%"}, {"sha": "db88a1f2999aa56a8fdac9d26472e20c3b9c824f", "filename": "src/grammar/parser-lalr-main.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,203 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern int yylex();\n-extern int rsparse();\n-\n-#define PUSHBACK_LEN 4\n-\n-static char pushback[PUSHBACK_LEN];\n-static int verbose;\n-\n-void print(const char* format, ...) {\n-  va_list args;\n-  va_start(args, format);\n-  if (verbose) {\n-    vprintf(format, args);\n-  }\n-  va_end(args);\n-}\n-\n-// If there is a non-null char at the head of the pushback queue,\n-// dequeue it and shift the rest of the queue forwards. Otherwise,\n-// return the token from calling yylex.\n-int rslex() {\n-  if (pushback[0] == '\\0') {\n-    return yylex();\n-  } else {\n-    char c = pushback[0];\n-    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n-    pushback[PUSHBACK_LEN - 1] = '\\0';\n-    return c;\n-  }\n-}\n-\n-// Note: this does nothing if the pushback queue is full. As long as\n-// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n-// in an action, this shouldn't be a problem.\n-void push_back(char c) {\n-  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n-    if (pushback[i] == '\\0') {\n-      pushback[i] = c;\n-      break;\n-    }\n-  }\n-}\n-\n-extern int rsdebug;\n-\n-struct node {\n-  struct node *next;\n-  struct node *prev;\n-  int own_string;\n-  char const *name;\n-  int n_elems;\n-  struct node *elems[];\n-};\n-\n-struct node *nodes = NULL;\n-int n_nodes;\n-\n-struct node *mk_node(char const *name, int n, ...) {\n-  va_list ap;\n-  int i = 0;\n-  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n-  struct node *nn, *nd = (struct node *)malloc(sz);\n-\n-  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n-\n-  nd->own_string = 0;\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  if (nodes) {\n-    nodes->prev = nd;\n-  }\n-  nodes = nd;\n-\n-  nd->name = name;\n-  nd->n_elems = n;\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[i++] = nn;\n-  }\n-  va_end(ap);\n-  n_nodes++;\n-  return nd;\n-}\n-\n-struct node *mk_atom(char *name) {\n-  struct node *nd = mk_node((char const *)strdup(name), 0);\n-  nd->own_string = 1;\n-  return nd;\n-}\n-\n-struct node *mk_none() {\n-  return mk_atom(\"<none>\");\n-}\n-\n-struct node *ext_node(struct node *nd, int n, ...) {\n-  va_list ap;\n-  int i = 0, c = nd->n_elems + n;\n-  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n-  struct node *nn;\n-\n-  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n-        nd->n_elems, c, nd->name, nd);\n-\n-  if (nd->next) {\n-    nd->next->prev = nd->prev;\n-  }\n-  if (nd->prev) {\n-    nd->prev->next = nd->next;\n-  }\n-  nd = realloc(nd, sz);\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  nodes->prev = nd;\n-  nodes = nd;\n-\n-  print(\" ==> %p\\n\", nd);\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[nd->n_elems++] = nn;\n-    ++i;\n-  }\n-  va_end(ap);\n-  return nd;\n-}\n-\n-int const indent_step = 4;\n-\n-void print_indent(int depth) {\n-  while (depth) {\n-    if (depth-- % indent_step == 0) {\n-      print(\"|\");\n-    } else {\n-      print(\" \");\n-    }\n-  }\n-}\n-\n-void print_node(struct node *n, int depth) {\n-  int i = 0;\n-  print_indent(depth);\n-  if (n->n_elems == 0) {\n-    print(\"%s\\n\", n->name);\n-  } else {\n-    print(\"(%s\\n\", n->name);\n-    for (i = 0; i < n->n_elems; ++i) {\n-      print_node(n->elems[i], depth + indent_step);\n-    }\n-    print_indent(depth);\n-    print(\")\\n\");\n-  }\n-}\n-\n-int main(int argc, char **argv) {\n-  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n-    verbose = 1;\n-  } else {\n-    verbose = 0;\n-  }\n-  int ret = 0;\n-  struct node *tmp;\n-  memset(pushback, '\\0', PUSHBACK_LEN);\n-  ret = rsparse();\n-  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n-  if (nodes) {\n-    print_node(nodes, 0);\n-  }\n-  while (nodes) {\n-    tmp = nodes;\n-    nodes = tmp->next;\n-    if (tmp->own_string) {\n-      free((void*)tmp->name);\n-    }\n-    free(tmp);\n-  }\n-  return ret;\n-}\n-\n-void rserror(char const *s) {\n-  fprintf(stderr, \"%s\\n\", s);\n-}"}, {"sha": "c9fcdf7647b9cfa79e42164ca858d728a7685dd7", "filename": "src/grammar/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1945, "changes": 1945, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,1945 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-%{\n-#define YYERROR_VERBOSE\n-#define YYSTYPE struct node *\n-struct node;\n-extern int yylex();\n-extern void yyerror(char const *s);\n-extern struct node *mk_node(char const *name, int n, ...);\n-extern struct node *mk_atom(char *text);\n-extern struct node *mk_none();\n-extern struct node *ext_node(struct node *nd, int n, ...);\n-extern void push_back(char c);\n-extern char *yytext;\n-%}\n-%debug\n-\n-%token SHL\n-%token SHR\n-%token LE\n-%token EQEQ\n-%token NE\n-%token GE\n-%token ANDAND\n-%token OROR\n-%token SHLEQ\n-%token SHREQ\n-%token MINUSEQ\n-%token ANDEQ\n-%token OREQ\n-%token PLUSEQ\n-%token STAREQ\n-%token SLASHEQ\n-%token CARETEQ\n-%token PERCENTEQ\n-%token DOTDOT\n-%token DOTDOTDOT\n-%token MOD_SEP\n-%token RARROW\n-%token LARROW\n-%token FAT_ARROW\n-%token LIT_BYTE\n-%token LIT_CHAR\n-%token LIT_INTEGER\n-%token LIT_FLOAT\n-%token LIT_STR\n-%token LIT_STR_RAW\n-%token LIT_BYTE_STR\n-%token LIT_BYTE_STR_RAW\n-%token IDENT\n-%token UNDERSCORE\n-%token LIFETIME\n-\n-// keywords\n-%token SELF\n-%token STATIC\n-%token AS\n-%token BREAK\n-%token CRATE\n-%token ELSE\n-%token ENUM\n-%token EXTERN\n-%token FALSE\n-%token FN\n-%token FOR\n-%token IF\n-%token IMPL\n-%token IN\n-%token LET\n-%token LOOP\n-%token MATCH\n-%token MOD\n-%token MOVE\n-%token MUT\n-%token PRIV\n-%token PUB\n-%token REF\n-%token RETURN\n-%token STRUCT\n-%token TRUE\n-%token TRAIT\n-%token TYPE\n-%token UNSAFE\n-%token DEFAULT\n-%token USE\n-%token WHILE\n-%token CONTINUE\n-%token PROC\n-%token BOX\n-%token CONST\n-%token WHERE\n-%token TYPEOF\n-%token INNER_DOC_COMMENT\n-%token OUTER_DOC_COMMENT\n-\n-%token SHEBANG\n-%token SHEBANG_LINE\n-%token STATIC_LIFETIME\n-\n- /*\n-   Quoting from the Bison manual:\n-\n-   \"Finally, the resolution of conflicts works by comparing the precedence\n-   of the rule being considered with that of the lookahead token. If the\n-   token's precedence is higher, the choice is to shift. If the rule's\n-   precedence is higher, the choice is to reduce. If they have equal\n-   precedence, the choice is made based on the associativity of that\n-   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n-   Bison) says how each conflict was resolved\"\n- */\n-\n-// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n-// all potential ambiguities are scrutinized and eliminated manually.\n-%expect 0\n-\n-// fake-precedence symbol to cause '|' bars in lambda context to parse\n-// at low precedence, permit things like |x| foo = bar, where '=' is\n-// otherwise lower-precedence than '|'. Also used for proc() to cause\n-// things like proc() a + b to parse as proc() { a + b }.\n-%precedence LAMBDA\n-\n-%precedence SELF\n-\n-// MUT should be lower precedence than IDENT so that in the pat rule,\n-// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n-%precedence MUT\n-\n-// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n-// trying to decide if we've got a struct-construction expr (esp. in\n-// contexts like 'if foo { .')\n-//\n-// IDENT also needs to be lower precedence than '<' so that '<' in\n-// 'foo:bar . <' is shifted (in a trait reference occurring in a\n-// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n-%precedence IDENT\n-\n-// A couple fake-precedence symbols to use in rules associated with +\n-// and < in trailing type contexts. These come up when you have a type\n-// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n-// has to be shifted so the parser keeps trying to parse a type, even\n-// though it might well consider reducing the type \"bar\" and then\n-// going on to \"<\" as a subsequent binop. The \"+\" case is with\n-// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n-%precedence SHIFTPLUS\n-\n-%precedence MOD_SEP\n-%precedence RARROW ':'\n-\n-// In where clauses, \"for\" should have greater precedence when used as\n-// a higher ranked constraint than when used as the beginning of a\n-// for_in_type (which is a ty)\n-%precedence FORTYPE\n-%precedence FOR\n-\n-// Binops & unops, and their precedences\n-%precedence BOX\n-%precedence BOXPLACE\n-%nonassoc DOTDOT\n-\n-// RETURN needs to be lower-precedence than tokens that start\n-// prefix_exprs\n-%precedence RETURN\n-\n-%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n-%right LARROW\n-%left OROR\n-%left ANDAND\n-%left EQEQ NE\n-%left '<' '>' LE GE\n-%left '|'\n-%left '^'\n-%left '&'\n-%left SHL SHR\n-%left '+' '-'\n-%precedence AS\n-%left '*' '/' '%'\n-%precedence '!'\n-\n-%precedence '{' '[' '(' '.'\n-\n-%precedence RANGE\n-\n-%start crate\n-\n-%%\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 1: Items and attributes\n-////////////////////////////////////////////////////////////////////////\n-\n-crate\n-: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n-| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n-;\n-\n-maybe_shebang\n-: SHEBANG_LINE\n-| %empty\n-;\n-\n-maybe_inner_attrs\n-: inner_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-inner_attrs\n-: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n-| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-inner_attr\n-: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n-| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n-;\n-\n-maybe_outer_attrs\n-: outer_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-outer_attrs\n-: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n-| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-outer_attr\n-: '#' '[' meta_item ']'    { $$ = $3; }\n-| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n-;\n-\n-meta_item\n-: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n-| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n-| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-;\n-\n-meta_seq\n-: %empty                   { $$ = mk_none(); }\n-| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n-| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_mod_items\n-: mod_items\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-mod_items\n-: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n-| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-attrs_and_vis\n-: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n-;\n-\n-mod_item\n-: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n-;\n-\n-// items that can appear outside of a fn block\n-item\n-: stmt_item\n-| item_macro\n-;\n-\n-// items that can appear in \"stmts\"\n-stmt_item\n-: item_static\n-| item_const\n-| item_type\n-| block_item\n-| view_item\n-;\n-\n-item_static\n-: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n-| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n-;\n-\n-item_const\n-: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n-;\n-\n-item_macro\n-: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-;\n-\n-view_item\n-: use_item\n-| extern_fn_item\n-| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n-| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n-;\n-\n-extern_fn_item\n-: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n-;\n-\n-use_item\n-: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n-;\n-\n-view_path\n-: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n-| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n-|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n-|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n-|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n-;\n-\n-block_item\n-: item_fn\n-| item_unsafe_fn\n-| item_mod\n-| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n-| item_struct\n-| item_enum\n-| item_trait\n-| item_impl\n-;\n-\n-maybe_ty_ascription\n-: ':' ty_sum { $$ = $2; }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_init_expr\n-: '=' expr { $$ = $2; }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-// structs\n-item_struct\n-: STRUCT ident generic_params maybe_where_clause struct_decl_args\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n-}\n-;\n-\n-struct_decl_args\n-: '{' struct_decl_fields '}'                  { $$ = $2; }\n-| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n-;\n-\n-struct_tuple_args\n-: '(' struct_tuple_fields ')'                 { $$ = $2; }\n-| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n-;\n-\n-struct_decl_fields\n-: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_decl_field\n-: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n-;\n-\n-struct_tuple_fields\n-: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-struct_tuple_field\n-: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n-;\n-\n-// enums\n-item_enum\n-: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n-| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n-;\n-\n-enum_defs\n-: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n-| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n-| %empty                 { $$ = mk_none(); }\n-;\n-\n-enum_def\n-: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n-;\n-\n-enum_args\n-: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| %empty                         { $$ = mk_none(); }\n-;\n-\n-item_mod\n-: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n-| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n-| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n-;\n-\n-item_foreign_mod\n-: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n-| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n-;\n-\n-maybe_abi\n-: str\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_foreign_items\n-: foreign_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-foreign_items\n-: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n-| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n-;\n-\n-foreign_item\n-: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n-| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-;\n-\n-item_foreign_static\n-: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n-;\n-\n-item_foreign_fn\n-: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n-;\n-\n-fn_decl_allow_variadic\n-: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params_allow_variadic\n-: '(' ')'                      { $$ = mk_none(); }\n-| '(' params ')'               { $$ = $2; }\n-| '(' params ',' ')'           { $$ = $2; }\n-| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n-;\n-\n-visibility\n-: PUB      { $$ = mk_atom(\"Public\"); }\n-| %empty   { $$ = mk_atom(\"Inherited\"); }\n-;\n-\n-idents_or_self\n-: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n-| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ident_or_self\n-: ident\n-| SELF  { $$ = mk_atom(yytext); }\n-;\n-\n-item_type\n-: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n-;\n-\n-for_sized\n-: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n-| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n-| %empty        { $$ = mk_none(); }\n-;\n-\n-item_trait\n-: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n-{\n-  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n-}\n-;\n-\n-maybe_trait_items\n-: trait_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-trait_items\n-: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n-| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-trait_item\n-: trait_const\n-| trait_type\n-| trait_method\n-;\n-\n-trait_const\n-: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_const_default\n-: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-trait_type\n-: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n-;\n-\n-maybe_unsafe\n-: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_default_maybe_unsafe\n-: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n-| DEFAULT        { $$ = mk_atom(\"Default\"); }\n-|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-\n-trait_method\n-: type_method { $$ = mk_node(\"Required\", 1, $1); }\n-| method      { $$ = mk_node(\"Provided\", 1, $1); }\n-;\n-\n-type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n-}\n-;\n-\n-method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-// There are two forms of impl:\n-//\n-// impl (<...>)? TY { ... }\n-// impl (<...>)? TRAIT for TY { ... }\n-//\n-// Unfortunately since TY can begin with '<' itself -- as part of a\n-// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n-// should we reduce one of the early rules of TY (such as maybe_once)\n-// or shall we continue shifting into the generic_params list for the\n-// impl?\n-//\n-// The production parser disambiguates a different case here by\n-// permitting / requiring the user to provide parens around types when\n-// they are ambiguous with traits. We do the same here, regrettably,\n-// by splitting ty into ty and ty_prim.\n-item_impl\n-: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n-}\n-;\n-\n-maybe_impl_items\n-: impl_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_items\n-: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n-| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n-;\n-\n-impl_item\n-: impl_method\n-| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n-| impl_const\n-| impl_type\n-;\n-\n-impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n-;\n-\n-impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n-;\n-\n-item_fn\n-: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n-}\n-;\n-\n-item_unsafe_fn\n-: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n-}\n-| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n-}\n-;\n-\n-fn_decl\n-: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self\n-: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self_allow_anon_params\n-: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params\n-: '(' maybe_params ')'  { $$ = $2; }\n-;\n-\n-fn_anon_params\n-: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n-| '(' ')'                                            { $$ = mk_none(); }\n-;\n-\n-fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-maybe_params\n-: params\n-| params ','\n-| %empty  { $$ = mk_none(); }\n-;\n-\n-params\n-: param                { $$ = mk_node(\"Args\", 1, $1); }\n-| params ',' param     { $$ = ext_node($1, 1, $3); }\n-;\n-\n-param\n-: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-;\n-\n-inferrable_params\n-: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n-| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-inferrable_param\n-: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n-;\n-\n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n-maybe_comma_params\n-: ','            { $$ = mk_none(); }\n-| ',' params     { $$ = $2; }\n-| ',' params ',' { $$ = $2; }\n-| %empty         { $$ = mk_none(); }\n-;\n-\n-maybe_comma_anon_params\n-: ','                 { $$ = mk_none(); }\n-| ',' anon_params     { $$ = $2; }\n-| ',' anon_params ',' { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-maybe_anon_params\n-: anon_params\n-| anon_params ','\n-| %empty      { $$ = mk_none(); }\n-;\n-\n-anon_params\n-: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n-| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// anon means it's allowed to be anonymous (type-only), but it can\n-// still have a name\n-anon_param\n-: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-| ty\n-;\n-\n-anon_params_allow_variadic_tail\n-: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n-| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n-| %empty                                         { $$ = mk_none(); }\n-;\n-\n-named_arg\n-: ident\n-| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n-| '&' ident         { $$ = $2; }\n-| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n-| ANDAND ident      { $$ = $2; }\n-| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n-| MUT ident         { $$ = $2; }\n-;\n-\n-ret_ty\n-: RARROW '!'         { $$ = mk_none(); }\n-| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n-| %prec IDENT %empty { $$ = mk_none(); }\n-;\n-\n-generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| %empty                              { $$ = mk_none(); }\n-;\n-\n-maybe_where_clause\n-: %empty                              { $$ = mk_none(); }\n-| where_clause\n-;\n-\n-where_clause\n-: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n-| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n-;\n-\n-where_predicates\n-: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n-| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n-;\n-\n-where_predicate\n-: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-;\n-\n-maybe_for_lifetimes\n-: FOR '<' lifetimes '>' { $$ = mk_none(); }\n-| %prec FORTYPE %empty  { $$ = mk_none(); }\n-\n-ty_params\n-: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n-| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with no type parameters; e.g. `foo::bar::Baz`\n-//\n-// These show up in 'use' view-items, because these are processed\n-// without respect to types.\n-path_no_types_allowed\n-: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n-| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n-| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters, with no double colons\n-// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-//\n-// These show up in \"trait references\", the components of\n-// type-parameter bounds lists, as well as in the prefix of the\n-// path_generic_args_and_bounds rule, which is the full form of a\n-// named typed expression.\n-//\n-// They do not have (nor need) an extra '::' before '<' because\n-// unlike in expr context, there are no \"less-than\" type exprs to\n-// be ambiguous with.\n-path_generic_args_without_colons\n-: %prec IDENT\n-  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n-| %prec IDENT\n-  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n-| %prec IDENT\n-  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n-;\n-\n-generic_args\n-: '<' generic_values '>'   { $$ = $2; }\n-| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n-| '<' generic_values GE    { push_back('='); $$ = $2; }\n-| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-// If generic_args starts with \"<<\", the first arg must be a\n-// TyQualifiedPath because that's the only type that can start with a\n-// '<'. This rule parses that as the first ty_sum and then continues\n-// with the rest of generic_values.\n-| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-;\n-\n-generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n-;\n-\n-maybe_ty_sums_and_or_bindings\n-: ty_sums\n-| ty_sums ','\n-| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n-| bindings\n-| bindings ','\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_bindings\n-: ',' bindings { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 2: Patterns\n-////////////////////////////////////////////////////////////////////////\n-\n-pat\n-: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n-| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n-| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n-| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n-| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n-| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n-| lit_or_path\n-| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n-| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n-| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n-| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n-| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n-|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n-| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n-| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-;\n-\n-pats_or\n-: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n-| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding_mode\n-: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n-| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n-| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n-;\n-\n-lit_or_path\n-: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n-| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n-| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n-;\n-\n-pat_field\n-:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n-|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n-| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n-| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n-|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n-| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n-;\n-\n-pat_fields\n-: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n-| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_struct\n-: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n-| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n-;\n-\n-pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_vec\n-: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_vec_elts\n-: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n-| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 3: Types\n-////////////////////////////////////////////////////////////////////////\n-\n-ty\n-: ty_prim\n-| ty_closure\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n-| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n-;\n-\n-ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n-| ty_bare_fn\n-| ty_proc\n-| for_in_type\n-;\n-\n-ty_bare_fn\n-:                         FN ty_fn_decl { $$ = $2; }\n-| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n-|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n-| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n-;\n-\n-ty_fn_decl\n-: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n-;\n-\n-ty_closure\n-: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n-|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n-| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n-|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n-;\n-\n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n-for_in_type\n-: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n-;\n-\n-for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n-| trait_ref\n-| ty_closure\n-;\n-\n-maybe_mut\n-: MUT              { $$ = mk_atom(\"MutMutable\"); }\n-| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-maybe_mut_or_const\n-: MUT    { $$ = mk_atom(\"MutMutable\"); }\n-| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n-| %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-ty_qualified_path_and_generic_values\n-: ty_qualified_path maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n-}\n-| ty_qualified_path ',' ty_sums maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n-}\n-;\n-\n-ty_qualified_path\n-: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-;\n-\n-maybe_ty_sums\n-: ty_sums\n-| ty_sums ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-ty_sums\n-: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n-| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n-;\n-\n-ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n-;\n-\n-maybe_ty_param_bounds\n-: ':' ty_param_bounds { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-ty_param_bounds\n-: boundseq\n-| %empty { $$ = mk_none(); }\n-;\n-\n-boundseq\n-: polybound\n-| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-polybound\n-: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n-| bound\n-| '?' bound { $$ = $2; }\n-;\n-\n-bindings\n-: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n-| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding\n-: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n-;\n-\n-ty_param\n-: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n-| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_bounds\n-: %prec SHIFTPLUS\n-  ':' bounds             { $$ = $2; }\n-| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n-;\n-\n-bounds\n-: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n-| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-bound\n-: lifetime\n-| trait_ref\n-;\n-\n-maybe_ltbounds\n-: %prec SHIFTPLUS\n-  ':' ltbounds       { $$ = $2; }\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-ltbounds\n-: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n-| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_ty_default\n-: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n-| %empty     { $$ = mk_none(); }\n-;\n-\n-maybe_lifetimes\n-: lifetimes\n-| lifetimes ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-lifetimes\n-: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n-| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n-;\n-\n-lifetime_and_bounds\n-: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n-| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-lifetime\n-: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n-| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-trait_ref\n-: %prec IDENT path_generic_args_without_colons\n-| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 4: Blocks, statements, and expressions\n-////////////////////////////////////////////////////////////////////////\n-\n-inner_attrs_and_block\n-: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n-;\n-\n-block\n-: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n-;\n-\n-maybe_stmts\n-: stmts\n-| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n-| nonblock_expr\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-// There are two sub-grammars within a \"stmts: exprs\" derivation\n-// depending on whether each stmt-expr is a block-expr form; this is to\n-// handle the \"semicolon rule\" for stmt sequencing that permits\n-// writing\n-//\n-//     if foo { bar } 10\n-//\n-// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n-// stmt). Unfortunately by permitting juxtaposition of exprs in\n-// sequence like that, the non-block expr grammar has to have a\n-// second limited sub-grammar that excludes the prefix exprs that\n-// are ambiguous with binops. That is to say:\n-//\n-//     {10} - 1\n-//\n-// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n-// is to say, two statements rather than one, at least according to\n-// the mainline rust parser.\n-//\n-// So we wind up with a 3-way split in exprs that occur in stmt lists:\n-// block, nonblock-prefix, and nonblock-nonprefix.\n-//\n-// In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n-\n-stmts\n-: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n-| stmts stmt     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-stmt\n-: let\n-|                 stmt_item\n-|             PUB stmt_item { $$ = $2; }\n-| outer_attrs     stmt_item { $$ = $2; }\n-| outer_attrs PUB stmt_item { $$ = $3; }\n-| full_block_expr\n-| block\n-| nonblock_expr ';'\n-| ';'                   { $$ = mk_none(); }\n-;\n-\n-maybe_exprs\n-: exprs\n-| exprs ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_expr\n-: expr\n-| %empty { $$ = mk_none(); }\n-;\n-\n-exprs\n-: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n-| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n-;\n-\n-path_expr\n-: path_generic_args_with_colons\n-| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n-| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters with double colons before\n-// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-//\n-// These show up in expr context, in order to disambiguate from \"less-than\"\n-// expressions.\n-path_generic_args_with_colons\n-: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n-| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n-| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// the braces-delimited macro is a block_expr so it doesn't appear here\n-macro_expr\n-: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-;\n-\n-nonblock_expr\n-: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| nonblock_prefix_expr\n-;\n-\n-expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-expr_nostruct\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr_nostruct\n-;\n-\n-nonblock_prefix_expr_nostruct\n-: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr_nostruct\n-| MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n-;\n-\n-nonblock_prefix_expr\n-: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr\n-| MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n-;\n-\n-expr_qualified_path\n-: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n-}\n-\n-maybe_qpath_params\n-: MOD_SEP generic_args { $$ = $2; }\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_as_trait_ref\n-: AS trait_ref { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-lambda_expr\n-: %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n-| %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n-;\n-\n-lambda_expr_nostruct\n-: %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n-| %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n-;\n-\n-proc_expr\n-: %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n-;\n-\n-proc_expr_nostruct\n-: %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n-;\n-\n-vec_expr\n-: maybe_exprs\n-| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n-;\n-\n-struct_expr_fields\n-: field_inits\n-| field_inits ','\n-| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n-;\n-\n-maybe_field_inits\n-: field_inits\n-| field_inits ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-field_inits\n-: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n-| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n-;\n-\n-field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n-;\n-\n-default_field_init\n-: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n-;\n-\n-block_expr\n-: expr_match\n-| expr_if\n-| expr_if_let\n-| expr_while\n-| expr_while_let\n-| expr_loop\n-| expr_for\n-| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n-;\n-\n-full_block_expr\n-: block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-;\n-\n-expr_match\n-: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n-| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n-| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n-| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n-;\n-\n-match_clauses\n-: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n-| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n-;\n-\n-match_clause\n-: nonblock_match_clause ','\n-| block_match_clause\n-| block_match_clause ','\n-;\n-\n-nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-;\n-\n-block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-;\n-\n-maybe_guard\n-: IF expr_nostruct           { $$ = $2; }\n-| %empty                     { $$ = mk_none(); }\n-;\n-\n-expr_if\n-: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n-| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n-;\n-\n-expr_if_let\n-: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n-| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n-;\n-\n-block_or_if\n-: block\n-| expr_if\n-| expr_if_let\n-;\n-\n-expr_while\n-: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n-;\n-\n-expr_while_let\n-: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n-;\n-\n-expr_loop\n-: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n-;\n-\n-expr_for\n-: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n-;\n-\n-maybe_label\n-: lifetime ':'\n-| %empty { $$ = mk_none(); }\n-;\n-\n-let\n-: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 5: Macros and misc. rules\n-////////////////////////////////////////////////////////////////////////\n-\n-lit\n-: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n-| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n-| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n-| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n-| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| str\n-;\n-\n-str\n-: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n-| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n-| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n-| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n-;\n-\n-maybe_ident\n-: %empty { $$ = mk_none(); }\n-| ident\n-;\n-\n-ident\n-: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-;\n-\n-unpaired_token\n-: SHL                        { $$ = mk_atom(yytext); }\n-| SHR                        { $$ = mk_atom(yytext); }\n-| LE                         { $$ = mk_atom(yytext); }\n-| EQEQ                       { $$ = mk_atom(yytext); }\n-| NE                         { $$ = mk_atom(yytext); }\n-| GE                         { $$ = mk_atom(yytext); }\n-| ANDAND                     { $$ = mk_atom(yytext); }\n-| OROR                       { $$ = mk_atom(yytext); }\n-| LARROW                     { $$ = mk_atom(yytext); }\n-| SHLEQ                      { $$ = mk_atom(yytext); }\n-| SHREQ                      { $$ = mk_atom(yytext); }\n-| MINUSEQ                    { $$ = mk_atom(yytext); }\n-| ANDEQ                      { $$ = mk_atom(yytext); }\n-| OREQ                       { $$ = mk_atom(yytext); }\n-| PLUSEQ                     { $$ = mk_atom(yytext); }\n-| STAREQ                     { $$ = mk_atom(yytext); }\n-| SLASHEQ                    { $$ = mk_atom(yytext); }\n-| CARETEQ                    { $$ = mk_atom(yytext); }\n-| PERCENTEQ                  { $$ = mk_atom(yytext); }\n-| DOTDOT                     { $$ = mk_atom(yytext); }\n-| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n-| MOD_SEP                    { $$ = mk_atom(yytext); }\n-| RARROW                     { $$ = mk_atom(yytext); }\n-| FAT_ARROW                  { $$ = mk_atom(yytext); }\n-| LIT_BYTE                   { $$ = mk_atom(yytext); }\n-| LIT_CHAR                   { $$ = mk_atom(yytext); }\n-| LIT_INTEGER                { $$ = mk_atom(yytext); }\n-| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n-| LIT_STR                    { $$ = mk_atom(yytext); }\n-| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n-| IDENT                      { $$ = mk_atom(yytext); }\n-| UNDERSCORE                 { $$ = mk_atom(yytext); }\n-| LIFETIME                   { $$ = mk_atom(yytext); }\n-| SELF                       { $$ = mk_atom(yytext); }\n-| STATIC                     { $$ = mk_atom(yytext); }\n-| AS                         { $$ = mk_atom(yytext); }\n-| BREAK                      { $$ = mk_atom(yytext); }\n-| CRATE                      { $$ = mk_atom(yytext); }\n-| ELSE                       { $$ = mk_atom(yytext); }\n-| ENUM                       { $$ = mk_atom(yytext); }\n-| EXTERN                     { $$ = mk_atom(yytext); }\n-| FALSE                      { $$ = mk_atom(yytext); }\n-| FN                         { $$ = mk_atom(yytext); }\n-| FOR                        { $$ = mk_atom(yytext); }\n-| IF                         { $$ = mk_atom(yytext); }\n-| IMPL                       { $$ = mk_atom(yytext); }\n-| IN                         { $$ = mk_atom(yytext); }\n-| LET                        { $$ = mk_atom(yytext); }\n-| LOOP                       { $$ = mk_atom(yytext); }\n-| MATCH                      { $$ = mk_atom(yytext); }\n-| MOD                        { $$ = mk_atom(yytext); }\n-| MOVE                       { $$ = mk_atom(yytext); }\n-| MUT                        { $$ = mk_atom(yytext); }\n-| PRIV                       { $$ = mk_atom(yytext); }\n-| PUB                        { $$ = mk_atom(yytext); }\n-| REF                        { $$ = mk_atom(yytext); }\n-| RETURN                     { $$ = mk_atom(yytext); }\n-| STRUCT                     { $$ = mk_atom(yytext); }\n-| TRUE                       { $$ = mk_atom(yytext); }\n-| TRAIT                      { $$ = mk_atom(yytext); }\n-| TYPE                       { $$ = mk_atom(yytext); }\n-| UNSAFE                     { $$ = mk_atom(yytext); }\n-| USE                        { $$ = mk_atom(yytext); }\n-| WHILE                      { $$ = mk_atom(yytext); }\n-| CONTINUE                   { $$ = mk_atom(yytext); }\n-| PROC                       { $$ = mk_atom(yytext); }\n-| BOX                        { $$ = mk_atom(yytext); }\n-| CONST                      { $$ = mk_atom(yytext); }\n-| WHERE                      { $$ = mk_atom(yytext); }\n-| TYPEOF                     { $$ = mk_atom(yytext); }\n-| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| SHEBANG                    { $$ = mk_atom(yytext); }\n-| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n-| ';'                        { $$ = mk_atom(yytext); }\n-| ','                        { $$ = mk_atom(yytext); }\n-| '.'                        { $$ = mk_atom(yytext); }\n-| '@'                        { $$ = mk_atom(yytext); }\n-| '#'                        { $$ = mk_atom(yytext); }\n-| '~'                        { $$ = mk_atom(yytext); }\n-| ':'                        { $$ = mk_atom(yytext); }\n-| '$'                        { $$ = mk_atom(yytext); }\n-| '='                        { $$ = mk_atom(yytext); }\n-| '?'                        { $$ = mk_atom(yytext); }\n-| '!'                        { $$ = mk_atom(yytext); }\n-| '<'                        { $$ = mk_atom(yytext); }\n-| '>'                        { $$ = mk_atom(yytext); }\n-| '-'                        { $$ = mk_atom(yytext); }\n-| '&'                        { $$ = mk_atom(yytext); }\n-| '|'                        { $$ = mk_atom(yytext); }\n-| '+'                        { $$ = mk_atom(yytext); }\n-| '*'                        { $$ = mk_atom(yytext); }\n-| '/'                        { $$ = mk_atom(yytext); }\n-| '^'                        { $$ = mk_atom(yytext); }\n-| '%'                        { $$ = mk_atom(yytext); }\n-;\n-\n-token_trees\n-: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n-| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-token_tree\n-: delimited_token_trees\n-| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n-;\n-\n-delimited_token_trees\n-: parens_delimited_token_trees\n-| braces_delimited_token_trees\n-| brackets_delimited_token_trees\n-;\n-\n-parens_delimited_token_trees\n-: '(' token_trees ')'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n-}\n-;\n-\n-braces_delimited_token_trees\n-: '{' token_trees '}'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n-}\n-;\n-\n-brackets_delimited_token_trees\n-: '[' token_trees ']'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n-}\n-;\n\\ No newline at end of file"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,64 +0,0 @@\n-Rust's lexical grammar is not context-free. Raw string literals are the source\n-of the problem. Informally, a raw string literal is an `r`, followed by `N`\n-hashes (where N can be zero), a quote, any characters, then a quote followed\n-by `N` hashes. Critically, once inside the first pair of quotes,\n-another quote cannot be followed by `N` consecutive hashes. e.g.\n-`r###\"\"###\"###` is invalid.\n-\n-This grammar describes this as best possible:\n-\n-    R -> 'r' S\n-    S -> '\"' B '\"'\n-    S -> '#' S '#'\n-    B -> . B\n-    B -> \u03b5\n-\n-Where `.` represents any character, and `\u03b5` the empty string. Consider the\n-string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n-accepted as one by the above grammar, using the derivation:\n-\n-    R : #\"\"#\"#\n-    S : \"\"#\"\n-    S : \"#\n-    B : #\n-    B : \u03b5\n-\n-(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n-string.) The difficulty arises from the fact that it is fundamentally\n-context-sensitive. In particular, the context needed is the number of hashes.\n-\n-To prove that Rust's string literals are not context-free, we will use\n-the fact that context-free languages are closed under intersection with\n-regular languages, and the\n-[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n-\n-Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n-context-free, then their intersection with `R`, `R'`, should also be context-free.\n-Therefore, to prove that raw string literals are not context-free,\n-it is sufficient to prove that `R'` is not context-free.\n-\n-The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n-\n-Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n-the pumping lemma applies. Consider the following string `s` in `R'`:\n-\n-`r#^p\"\"#^{p-1}\"#^p`\n-\n-e.g. for `p = 2`: `s = r##\"\"#\"##`\n-\n-Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n-`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n-\n-Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n-in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n-Consequently, of the three sequences of hashes, `v` and `x` combined\n-can only pump two of them.\n-If we ever choose the central sequence of hashes, then one of the outer sequences\n-will not grow when we pump, leading to an imbalance between the outer sequences.\n-Therefore, we must pump both outer sequences of hashes. However,\n-there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n-be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n-context-free.\n-\n-Since `R'` is not context-free, it follows that the Rust's raw string literals\n-must not be context-free."}, {"sha": "37be41b935f84b4e1434ba9f76d8aa8b25ed4c98", "filename": "src/grammar/testparser.py", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,76 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# ignore-tidy-linelength\n-\n-import sys\n-\n-import os\n-import subprocess\n-import argparse\n-\n-# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n-\n-# Parsers should read from stdin and return exit status 0 for a\n-# successful parse, and nonzero for an unsuccessful parse\n-\n-parser = argparse.ArgumentParser()\n-parser.add_argument('-p', '--parser', nargs='+')\n-parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n-args = parser.parse_args(sys.argv[1:])\n-\n-total = 0\n-ok = {}\n-bad = {}\n-for parser in args.parser:\n-    ok[parser] = 0\n-    bad[parser] = []\n-devnull = open(os.devnull, 'w')\n-print(\"\\n\")\n-\n-for base, dirs, files in os.walk(args.source_dir[0]):\n-    for f in filter(lambda p: p.endswith('.rs'), files):\n-        p = os.path.join(base, f)\n-        parse_fail = 'parse-fail' in p\n-        if sys.version_info.major == 3:\n-            lines = open(p, encoding='utf-8').readlines()\n-        else:\n-            lines = open(p).readlines()\n-        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n-            continue\n-        total += 1\n-        for parser in args.parser:\n-            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n-                if parse_fail:\n-                    bad[parser].append(p)\n-                else:\n-                    ok[parser] += 1\n-            else:\n-                if parse_fail:\n-                    ok[parser] += 1\n-                else:\n-                    bad[parser].append(p)\n-        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n-        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n-                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n-\n-devnull.close()\n-\n-print(\"\\n\")\n-\n-for parser in args.parser:\n-    filename = os.path.basename(parser) + '.bad'\n-    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n-    with open(filename, \"w\") as f:\n-        for p in bad[parser]:\n-            f.write(p)\n-            f.write(\"\\n\")"}, {"sha": "081bd05025967e76940f075c1c490c6ccdf2bfa7", "filename": "src/grammar/tokens.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Token {\n-  SHL = 257, // Parser generators reserve 0-256 for char literals\n-  SHR,\n-  LE,\n-  EQEQ,\n-  NE,\n-  GE,\n-  ANDAND,\n-  OROR,\n-  SHLEQ,\n-  SHREQ,\n-  MINUSEQ,\n-  ANDEQ,\n-  OREQ,\n-  PLUSEQ,\n-  STAREQ,\n-  SLASHEQ,\n-  CARETEQ,\n-  PERCENTEQ,\n-  DOTDOT,\n-  DOTDOTDOT,\n-  MOD_SEP,\n-  RARROW,\n-  FAT_ARROW,\n-  LIT_BYTE,\n-  LIT_CHAR,\n-  LIT_INTEGER,\n-  LIT_FLOAT,\n-  LIT_STR,\n-  LIT_STR_RAW,\n-  LIT_BYTE_STR,\n-  LIT_BYTE_STR_RAW,\n-  IDENT,\n-  UNDERSCORE,\n-  LIFETIME,\n-\n-  // keywords\n-  SELF,\n-  STATIC,\n-  AS,\n-  BREAK,\n-  CRATE,\n-  ELSE,\n-  ENUM,\n-  EXTERN,\n-  FALSE,\n-  FN,\n-  FOR,\n-  IF,\n-  IMPL,\n-  IN,\n-  LET,\n-  LOOP,\n-  MATCH,\n-  MOD,\n-  MOVE,\n-  MUT,\n-  PRIV,\n-  PUB,\n-  REF,\n-  RETURN,\n-  STRUCT,\n-  TRUE,\n-  TRAIT,\n-  TYPE,\n-  UNSAFE,\n-  USE,\n-  WHILE,\n-  CONTINUE,\n-  PROC,\n-  BOX,\n-  CONST,\n-  WHERE,\n-  TYPEOF,\n-  INNER_DOC_COMMENT,\n-  OUTER_DOC_COMMENT,\n-\n-  SHEBANG,\n-  SHEBANG_LINE,\n-  STATIC_LIFETIME\n-};"}, {"sha": "3ac043f7aa9bc13568c73c482ce5484a3a09f745", "filename": "src/grammar/verify.rs", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,361 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(plugin, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-\n-#[macro_use]\n-extern crate log;\n-\n-use std::collections::HashMap;\n-use std::env;\n-use std::fs::File;\n-use std::io::{BufRead, Read};\n-use std::path::Path;\n-\n-use syntax::parse::lexer;\n-use rustc::dep_graph::DepGraph;\n-use rustc::session::{self, config};\n-use rustc::middle::cstore::DummyCrateStore;\n-\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax::codemap;\n-use syntax::parse::token::{self, BinOpToken, DelimToken, Lit, Token};\n-use syntax::parse::lexer::TokenAndSpan;\n-use syntax_pos::Pos;\n-\n-use syntax::symbol::{Symbol, keywords};\n-\n-fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n-    fn id() -> token::Token {\n-        Token::Ident(ast::Ident::with_empty_ctxt(keywords::Invalid.name()))\n-    }\n-\n-    let mut res = HashMap::new();\n-\n-    res.insert(\"-1\".to_string(), Token::Eof);\n-\n-    for line in file.split('\\n') {\n-        let eq = match line.trim().rfind('=') {\n-            Some(val) => val,\n-            None => continue\n-        };\n-\n-        let val = &line[..eq];\n-        let num = &line[eq + 1..];\n-\n-        let tok = match val {\n-            \"SHR\"               => Token::BinOp(BinOpToken::Shr),\n-            \"DOLLAR\"            => Token::Dollar,\n-            \"LT\"                => Token::Lt,\n-            \"STAR\"              => Token::BinOp(BinOpToken::Star),\n-            \"FLOAT_SUFFIX\"      => id(),\n-            \"INT_SUFFIX\"        => id(),\n-            \"SHL\"               => Token::BinOp(BinOpToken::Shl),\n-            \"LBRACE\"            => Token::OpenDelim(DelimToken::Brace),\n-            \"RARROW\"            => Token::RArrow,\n-            \"LIT_STR\"           => Token::Literal(Lit::Str_(keywords::Invalid.name()), None),\n-            \"DOTDOT\"            => Token::DotDot,\n-            \"MOD_SEP\"           => Token::ModSep,\n-            \"DOTDOTDOT\"         => Token::DotDotDot,\n-            \"NOT\"               => Token::Not,\n-            \"AND\"               => Token::BinOp(BinOpToken::And),\n-            \"LPAREN\"            => Token::OpenDelim(DelimToken::Paren),\n-            \"ANDAND\"            => Token::AndAnd,\n-            \"AT\"                => Token::At,\n-            \"LBRACKET\"          => Token::OpenDelim(DelimToken::Bracket),\n-            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(keywords::Invalid.name(), 0), None),\n-            \"RPAREN\"            => Token::CloseDelim(DelimToken::Paren),\n-            \"SLASH\"             => Token::BinOp(BinOpToken::Slash),\n-            \"COMMA\"             => Token::Comma,\n-            \"LIFETIME\"          => Token::Lifetime(\n-                                            ast::Ident::with_empty_ctxt(keywords::Invalid.name())),\n-            \"CARET\"             => Token::BinOp(BinOpToken::Caret),\n-            \"TILDE\"             => Token::Tilde,\n-            \"IDENT\"             => id(),\n-            \"PLUS\"              => Token::BinOp(BinOpToken::Plus),\n-            \"LIT_CHAR\"          => Token::Literal(Lit::Char(keywords::Invalid.name()), None),\n-            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(keywords::Invalid.name()), None),\n-            \"EQ\"                => Token::Eq,\n-            \"RBRACKET\"          => Token::CloseDelim(DelimToken::Bracket),\n-            \"COMMENT\"           => Token::Comment,\n-            \"DOC_COMMENT\"       => Token::DocComment(keywords::Invalid.name()),\n-            \"DOT\"               => Token::Dot,\n-            \"EQEQ\"              => Token::EqEq,\n-            \"NE\"                => Token::Ne,\n-            \"GE\"                => Token::Ge,\n-            \"PERCENT\"           => Token::BinOp(BinOpToken::Percent),\n-            \"RBRACE\"            => Token::CloseDelim(DelimToken::Brace),\n-            \"BINOP\"             => Token::BinOp(BinOpToken::Plus),\n-            \"POUND\"             => Token::Pound,\n-            \"OROR\"              => Token::OrOr,\n-            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(keywords::Invalid.name()), None),\n-            \"BINOPEQ\"           => Token::BinOpEq(BinOpToken::Plus),\n-            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(keywords::Invalid.name()), None),\n-            \"WHITESPACE\"        => Token::Whitespace,\n-            \"UNDERSCORE\"        => Token::Underscore,\n-            \"MINUS\"             => Token::BinOp(BinOpToken::Minus),\n-            \"SEMI\"              => Token::Semi,\n-            \"COLON\"             => Token::Colon,\n-            \"FAT_ARROW\"         => Token::FatArrow,\n-            \"OR\"                => Token::BinOp(BinOpToken::Or),\n-            \"GT\"                => Token::Gt,\n-            \"LE\"                => Token::Le,\n-            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(keywords::Invalid.name()), None),\n-            \"LIT_BINARY_RAW\"    => Token::Literal(\n-                                            Lit::ByteStrRaw(keywords::Invalid.name(), 0), None),\n-            \"QUESTION\"          => Token::Question,\n-            \"SHEBANG\"           => Token::Shebang(keywords::Invalid.name()),\n-            _                   => continue,\n-        };\n-\n-        res.insert(num.to_string(), tok);\n-    }\n-\n-    debug!(\"Token map: {:?}\", res);\n-    res\n-}\n-\n-fn str_to_binop(s: &str) -> token::BinOpToken {\n-    match s {\n-        \"+\"     => BinOpToken::Plus,\n-        \"/\"     => BinOpToken::Slash,\n-        \"-\"     => BinOpToken::Minus,\n-        \"*\"     => BinOpToken::Star,\n-        \"%\"     => BinOpToken::Percent,\n-        \"^\"     => BinOpToken::Caret,\n-        \"&\"     => BinOpToken::And,\n-        \"|\"     => BinOpToken::Or,\n-        \"<<\"    => BinOpToken::Shl,\n-        \">>\"    => BinOpToken::Shr,\n-        _       => panic!(\"Bad binop str `{}`\", s),\n-    }\n-}\n-\n-/// Assuming a string/byte string literal, strip out the leading/trailing\n-/// hashes and surrounding quotes/raw/byte prefix.\n-fn fix(mut lit: &str) -> ast::Name {\n-    let prefix: Vec<char> = lit.chars().take(2).collect();\n-    if prefix[0] == 'r' {\n-        if prefix[1] == 'b' {\n-            lit = &lit[2..]\n-        } else {\n-            lit = &lit[1..];\n-        }\n-    } else if prefix[0] == 'b' {\n-        lit = &lit[1..];\n-    }\n-\n-    let leading_hashes = count(lit);\n-\n-    // +1/-1 to adjust for single quotes\n-    Symbol::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n-}\n-\n-/// Assuming a char/byte literal, strip the 'b' prefix and the single quotes.\n-fn fixchar(mut lit: &str) -> ast::Name {\n-    let prefix = lit.chars().next().unwrap();\n-    if prefix == 'b' {\n-        lit = &lit[1..];\n-    }\n-\n-    Symbol::intern(&lit[1..lit.len() - 1])\n-}\n-\n-fn count(lit: &str) -> usize {\n-    lit.chars().take_while(|c| *c == '#').count()\n-}\n-\n-fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_pairs_pos: &[usize],\n-                     has_bom: bool)\n-                     -> TokenAndSpan {\n-    // old regex:\n-    // \\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\n-    let start = s.find(\"[@\").unwrap();\n-    let comma = start + s[start..].find(\",\").unwrap();\n-    let colon = comma + s[comma..].find(\":\").unwrap();\n-    let content_start = colon + s[colon..].find(\"='\").unwrap();\n-    // Use rfind instead of find, because we don't want to stop at the content\n-    let content_end = content_start + s[content_start..].rfind(\"',<\").unwrap();\n-    let toknum_end = content_end + s[content_end..].find(\">,\").unwrap();\n-\n-    let start = &s[comma + 1 .. colon];\n-    let end = &s[colon + 1 .. content_start];\n-    let content = &s[content_start + 2 .. content_end];\n-    let toknum = &s[content_end + 3 .. toknum_end];\n-\n-    let not_found = format!(\"didn't find token {:?} in the map\", toknum);\n-    let proto_tok = tokens.get(toknum).expect(&not_found);\n-\n-    let nm = Symbol::intern(content);\n-\n-    debug!(\"What we got: content (`{}`), proto: {:?}\", content, proto_tok);\n-\n-    let real_tok = match *proto_tok {\n-        Token::BinOp(..)           => Token::BinOp(str_to_binop(content)),\n-        Token::BinOpEq(..)         => Token::BinOpEq(str_to_binop(&content[..content.len() - 1])),\n-        Token::Literal(Lit::Str_(..), n)      => Token::Literal(Lit::Str_(fix(content)), n),\n-        Token::Literal(Lit::StrRaw(..), n)    => Token::Literal(Lit::StrRaw(fix(content),\n-                                                                             count(content)), n),\n-        Token::Literal(Lit::Char(..), n)      => Token::Literal(Lit::Char(fixchar(content)), n),\n-        Token::Literal(Lit::Byte(..), n)      => Token::Literal(Lit::Byte(fixchar(content)), n),\n-        Token::DocComment(..)      => Token::DocComment(nm),\n-        Token::Literal(Lit::Integer(..), n)   => Token::Literal(Lit::Integer(nm), n),\n-        Token::Literal(Lit::Float(..), n)     => Token::Literal(Lit::Float(nm), n),\n-        Token::Literal(Lit::ByteStr(..), n)    => Token::Literal(Lit::ByteStr(nm), n),\n-        Token::Literal(Lit::ByteStrRaw(..), n) => Token::Literal(Lit::ByteStrRaw(fix(content),\n-                                                                                count(content)), n),\n-        Token::Ident(..)           => Token::Ident(ast::Ident::with_empty_ctxt(nm)),\n-        Token::Lifetime(..)        => Token::Lifetime(ast::Ident::with_empty_ctxt(nm)),\n-        ref t => t.clone()\n-    };\n-\n-    let start_offset = if real_tok == Token::Eof {\n-        1\n-    } else {\n-        0\n-    };\n-\n-    let offset = if has_bom { 1 } else { 0 };\n-\n-    let mut lo = start.parse::<u32>().unwrap() - start_offset - offset;\n-    let mut hi = end.parse::<u32>().unwrap() + 1 - offset;\n-\n-    // Adjust the span: For each surrogate pair already encountered, subtract one position.\n-    lo -= surrogate_pairs_pos.binary_search(&(lo as usize)).unwrap_or_else(|x| x) as u32;\n-    hi -= surrogate_pairs_pos.binary_search(&(hi as usize)).unwrap_or_else(|x| x) as u32;\n-\n-    let sp = syntax_pos::Span {\n-        lo: syntax_pos::BytePos(lo),\n-        hi: syntax_pos::BytePos(hi),\n-        expn_id: syntax_pos::NO_EXPANSION\n-    };\n-\n-    TokenAndSpan {\n-        tok: real_tok,\n-        sp: sp\n-    }\n-}\n-\n-fn tok_cmp(a: &token::Token, b: &token::Token) -> bool {\n-    match a {\n-        &Token::Ident(id) => match b {\n-                &Token::Ident(id2) => id == id2,\n-                _ => false\n-        },\n-        _ => a == b\n-    }\n-}\n-\n-fn span_cmp(antlr_sp: codemap::Span, rust_sp: codemap::Span, cm: &codemap::CodeMap) -> bool {\n-    antlr_sp.expn_id == rust_sp.expn_id &&\n-        antlr_sp.lo.to_usize() == cm.bytepos_to_file_charpos(rust_sp.lo).to_usize() &&\n-        antlr_sp.hi.to_usize() == cm.bytepos_to_file_charpos(rust_sp.hi).to_usize()\n-}\n-\n-fn main() {\n-    fn next(r: &mut lexer::StringReader) -> TokenAndSpan {\n-        use syntax::parse::lexer::Reader;\n-        r.next_token()\n-    }\n-\n-    let mut args = env::args().skip(1);\n-    let filename = args.next().unwrap();\n-    if filename.find(\"parse-fail\").is_some() {\n-        return;\n-    }\n-\n-    // Rust's lexer\n-    let mut code = String::new();\n-    File::open(&Path::new(&filename)).unwrap().read_to_string(&mut code).unwrap();\n-\n-    let surrogate_pairs_pos: Vec<usize> = code.chars().enumerate()\n-                                                     .filter(|&(_, c)| c as usize > 0xFFFF)\n-                                                     .map(|(n, _)| n)\n-                                                     .enumerate()\n-                                                     .map(|(x, n)| x + n)\n-                                                     .collect();\n-\n-    let has_bom = code.starts_with(\"\\u{feff}\");\n-\n-    debug!(\"Pairs: {:?}\", surrogate_pairs_pos);\n-\n-    let options = config::basic_options();\n-    let session = session::build_session(options, &DepGraph::new(false), None,\n-                                         syntax::errors::registry::Registry::new(&[]),\n-                                         Rc::new(DummyCrateStore));\n-    let filemap = session.parse_sess.codemap()\n-                         .new_filemap(\"<n/a>\".to_string(), code);\n-    let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n-    let cm = session.codemap();\n-\n-    // ANTLR\n-    let mut token_file = File::open(&Path::new(&args.next().unwrap())).unwrap();\n-    let mut token_list = String::new();\n-    token_file.read_to_string(&mut token_list).unwrap();\n-    let token_map = parse_token_list(&token_list);\n-\n-    let stdin = std::io::stdin();\n-    let lock = stdin.lock();\n-    let lines = lock.lines();\n-    let antlr_tokens = lines.map(|l| parse_antlr_token(l.unwrap().trim(),\n-                                                       &token_map,\n-                                                       &surrogate_pairs_pos,\n-                                                       has_bom));\n-\n-    for antlr_tok in antlr_tokens {\n-        let rustc_tok = next(&mut lexer);\n-        if rustc_tok.tok == Token::Eof && antlr_tok.tok == Token::Eof {\n-            continue\n-        }\n-\n-        assert!(span_cmp(antlr_tok.sp, rustc_tok.sp, cm), \"{:?} and {:?} have different spans\",\n-                rustc_tok,\n-                antlr_tok);\n-\n-        macro_rules! matches {\n-            ( $($x:pat),+ ) => (\n-                match rustc_tok.tok {\n-                    $($x => match antlr_tok.tok {\n-                        $x => {\n-                            if !tok_cmp(&rustc_tok.tok, &antlr_tok.tok) {\n-                                // FIXME #15677: needs more robust escaping in\n-                                // antlr\n-                                warn!(\"Different names for {:?} and {:?}\", rustc_tok, antlr_tok);\n-                            }\n-                        }\n-                        _ => panic!(\"{:?} is not {:?}\", antlr_tok, rustc_tok)\n-                    },)*\n-                    ref c => assert!(c == &antlr_tok.tok, \"{:?} is not {:?}\", antlr_tok, rustc_tok)\n-                }\n-            )\n-        }\n-\n-        matches!(\n-            Token::Literal(Lit::Byte(..), _),\n-            Token::Literal(Lit::Char(..), _),\n-            Token::Literal(Lit::Integer(..), _),\n-            Token::Literal(Lit::Float(..), _),\n-            Token::Literal(Lit::Str_(..), _),\n-            Token::Literal(Lit::StrRaw(..), _),\n-            Token::Literal(Lit::ByteStr(..), _),\n-            Token::Literal(Lit::ByteStrRaw(..), _),\n-            Token::Ident(..),\n-            Token::Lifetime(..),\n-            Token::Interpolated(..),\n-            Token::DocComment(..),\n-            Token::Shebang(..)\n-        );\n-    }\n-}"}, {"sha": "f3a1a3b40f99a382f17d8246b0f03c96eb7f49c3", "filename": "src/grammar/xidcontinue.g4", "status": "removed", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fxidcontinue.g4", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fxidcontinue.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fxidcontinue.g4?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,473 +0,0 @@\n-lexer grammar Xidcontinue;\n-\n-fragment XID_Continue:\n-      '\\u0030' .. '\\u0039'\n-    | '\\u0041' .. '\\u005a'\n-    | '\\u005f'\n-    | '\\u0061' .. '\\u007a'\n-    | '\\u00aa'\n-    | '\\u00b5'\n-    | '\\u00b7'\n-    | '\\u00ba'\n-    | '\\u00c0' .. '\\u00d6'\n-    | '\\u00d8' .. '\\u00f6'\n-    | '\\u00f8' .. '\\u0236'\n-    | '\\u0250' .. '\\u02c1'\n-    | '\\u02c6' .. '\\u02d1'\n-    | '\\u02e0' .. '\\u02e4'\n-    | '\\u02ee'\n-    | '\\u0300' .. '\\u0357'\n-    | '\\u035d' .. '\\u036f'\n-    | '\\u0386'\n-    | '\\u0388' .. '\\u038a'\n-    | '\\u038c'\n-    | '\\u038e' .. '\\u03a1'\n-    | '\\u03a3' .. '\\u03ce'\n-    | '\\u03d0' .. '\\u03f5'\n-    | '\\u03f7' .. '\\u03fb'\n-    | '\\u0400' .. '\\u0481'\n-    | '\\u0483' .. '\\u0486'\n-    | '\\u048a' .. '\\u04ce'\n-    | '\\u04d0' .. '\\u04f5'\n-    | '\\u04f8' .. '\\u04f9'\n-    | '\\u0500' .. '\\u050f'\n-    | '\\u0531' .. '\\u0556'\n-    | '\\u0559'\n-    | '\\u0561' .. '\\u0587'\n-    | '\\u0591' .. '\\u05a1'\n-    | '\\u05a3' .. '\\u05b9'\n-    | '\\u05bb' .. '\\u05bd'\n-    | '\\u05bf'\n-    | '\\u05c1' .. '\\u05c2'\n-    | '\\u05c4'\n-    | '\\u05d0' .. '\\u05ea'\n-    | '\\u05f0' .. '\\u05f2'\n-    | '\\u0610' .. '\\u0615'\n-    | '\\u0621' .. '\\u063a'\n-    | '\\u0640' .. '\\u0658'\n-    | '\\u0660' .. '\\u0669'\n-    | '\\u066e' .. '\\u06d3'\n-    | '\\u06d5' .. '\\u06dc'\n-    | '\\u06df' .. '\\u06e8'\n-    | '\\u06ea' .. '\\u06fc'\n-    | '\\u06ff'\n-    | '\\u0710' .. '\\u074a'\n-    | '\\u074d' .. '\\u074f'\n-    | '\\u0780' .. '\\u07b1'\n-    | '\\u0901' .. '\\u0939'\n-    | '\\u093c' .. '\\u094d'\n-    | '\\u0950' .. '\\u0954'\n-    | '\\u0958' .. '\\u0963'\n-    | '\\u0966' .. '\\u096f'\n-    | '\\u0981' .. '\\u0983'\n-    | '\\u0985' .. '\\u098c'\n-    | '\\u098f' .. '\\u0990'\n-    | '\\u0993' .. '\\u09a8'\n-    | '\\u09aa' .. '\\u09b0'\n-    | '\\u09b2'\n-    | '\\u09b6' .. '\\u09b9'\n-    | '\\u09bc' .. '\\u09c4'\n-    | '\\u09c7' .. '\\u09c8'\n-    | '\\u09cb' .. '\\u09cd'\n-    | '\\u09d7'\n-    | '\\u09dc' .. '\\u09dd'\n-    | '\\u09df' .. '\\u09e3'\n-    | '\\u09e6' .. '\\u09f1'\n-    | '\\u0a01' .. '\\u0a03'\n-    | '\\u0a05' .. '\\u0a0a'\n-    | '\\u0a0f' .. '\\u0a10'\n-    | '\\u0a13' .. '\\u0a28'\n-    | '\\u0a2a' .. '\\u0a30'\n-    | '\\u0a32' .. '\\u0a33'\n-    | '\\u0a35' .. '\\u0a36'\n-    | '\\u0a38' .. '\\u0a39'\n-    | '\\u0a3c'\n-    | '\\u0a3e' .. '\\u0a42'\n-    | '\\u0a47' .. '\\u0a48'\n-    | '\\u0a4b' .. '\\u0a4d'\n-    | '\\u0a59' .. '\\u0a5c'\n-    | '\\u0a5e'\n-    | '\\u0a66' .. '\\u0a74'\n-    | '\\u0a81' .. '\\u0a83'\n-    | '\\u0a85' .. '\\u0a8d'\n-    | '\\u0a8f' .. '\\u0a91'\n-    | '\\u0a93' .. '\\u0aa8'\n-    | '\\u0aaa' .. '\\u0ab0'\n-    | '\\u0ab2' .. '\\u0ab3'\n-    | '\\u0ab5' .. '\\u0ab9'\n-    | '\\u0abc' .. '\\u0ac5'\n-    | '\\u0ac7' .. '\\u0ac9'\n-    | '\\u0acb' .. '\\u0acd'\n-    | '\\u0ad0'\n-    | '\\u0ae0' .. '\\u0ae3'\n-    | '\\u0ae6' .. '\\u0aef'\n-    | '\\u0b01' .. '\\u0b03'\n-    | '\\u0b05' .. '\\u0b0c'\n-    | '\\u0b0f' .. '\\u0b10'\n-    | '\\u0b13' .. '\\u0b28'\n-    | '\\u0b2a' .. '\\u0b30'\n-    | '\\u0b32' .. '\\u0b33'\n-    | '\\u0b35' .. '\\u0b39'\n-    | '\\u0b3c' .. '\\u0b43'\n-    | '\\u0b47' .. '\\u0b48'\n-    | '\\u0b4b' .. '\\u0b4d'\n-    | '\\u0b56' .. '\\u0b57'\n-    | '\\u0b5c' .. '\\u0b5d'\n-    | '\\u0b5f' .. '\\u0b61'\n-    | '\\u0b66' .. '\\u0b6f'\n-    | '\\u0b71'\n-    | '\\u0b82' .. '\\u0b83'\n-    | '\\u0b85' .. '\\u0b8a'\n-    | '\\u0b8e' .. '\\u0b90'\n-    | '\\u0b92' .. '\\u0b95'\n-    | '\\u0b99' .. '\\u0b9a'\n-    | '\\u0b9c'\n-    | '\\u0b9e' .. '\\u0b9f'\n-    | '\\u0ba3' .. '\\u0ba4'\n-    | '\\u0ba8' .. '\\u0baa'\n-    | '\\u0bae' .. '\\u0bb5'\n-    | '\\u0bb7' .. '\\u0bb9'\n-    | '\\u0bbe' .. '\\u0bc2'\n-    | '\\u0bc6' .. '\\u0bc8'\n-    | '\\u0bca' .. '\\u0bcd'\n-    | '\\u0bd7'\n-    | '\\u0be7' .. '\\u0bef'\n-    | '\\u0c01' .. '\\u0c03'\n-    | '\\u0c05' .. '\\u0c0c'\n-    | '\\u0c0e' .. '\\u0c10'\n-    | '\\u0c12' .. '\\u0c28'\n-    | '\\u0c2a' .. '\\u0c33'\n-    | '\\u0c35' .. '\\u0c39'\n-    | '\\u0c3e' .. '\\u0c44'\n-    | '\\u0c46' .. '\\u0c48'\n-    | '\\u0c4a' .. '\\u0c4d'\n-    | '\\u0c55' .. '\\u0c56'\n-    | '\\u0c60' .. '\\u0c61'\n-    | '\\u0c66' .. '\\u0c6f'\n-    | '\\u0c82' .. '\\u0c83'\n-    | '\\u0c85' .. '\\u0c8c'\n-    | '\\u0c8e' .. '\\u0c90'\n-    | '\\u0c92' .. '\\u0ca8'\n-    | '\\u0caa' .. '\\u0cb3'\n-    | '\\u0cb5' .. '\\u0cb9'\n-    | '\\u0cbc' .. '\\u0cc4'\n-    | '\\u0cc6' .. '\\u0cc8'\n-    | '\\u0cca' .. '\\u0ccd'\n-    | '\\u0cd5' .. '\\u0cd6'\n-    | '\\u0cde'\n-    | '\\u0ce0' .. '\\u0ce1'\n-    | '\\u0ce6' .. '\\u0cef'\n-    | '\\u0d02' .. '\\u0d03'\n-    | '\\u0d05' .. '\\u0d0c'\n-    | '\\u0d0e' .. '\\u0d10'\n-    | '\\u0d12' .. '\\u0d28'\n-    | '\\u0d2a' .. '\\u0d39'\n-    | '\\u0d3e' .. '\\u0d43'\n-    | '\\u0d46' .. '\\u0d48'\n-    | '\\u0d4a' .. '\\u0d4d'\n-    | '\\u0d57'\n-    | '\\u0d60' .. '\\u0d61'\n-    | '\\u0d66' .. '\\u0d6f'\n-    | '\\u0d82' .. '\\u0d83'\n-    | '\\u0d85' .. '\\u0d96'\n-    | '\\u0d9a' .. '\\u0db1'\n-    | '\\u0db3' .. '\\u0dbb'\n-    | '\\u0dbd'\n-    | '\\u0dc0' .. '\\u0dc6'\n-    | '\\u0dca'\n-    | '\\u0dcf' .. '\\u0dd4'\n-    | '\\u0dd6'\n-    | '\\u0dd8' .. '\\u0ddf'\n-    | '\\u0df2' .. '\\u0df3'\n-    | '\\u0e01' .. '\\u0e3a'\n-    | '\\u0e40' .. '\\u0e4e'\n-    | '\\u0e50' .. '\\u0e59'\n-    | '\\u0e81' .. '\\u0e82'\n-    | '\\u0e84'\n-    | '\\u0e87' .. '\\u0e88'\n-    | '\\u0e8a'\n-    | '\\u0e8d'\n-    | '\\u0e94' .. '\\u0e97'\n-    | '\\u0e99' .. '\\u0e9f'\n-    | '\\u0ea1' .. '\\u0ea3'\n-    | '\\u0ea5'\n-    | '\\u0ea7'\n-    | '\\u0eaa' .. '\\u0eab'\n-    | '\\u0ead' .. '\\u0eb9'\n-    | '\\u0ebb' .. '\\u0ebd'\n-    | '\\u0ec0' .. '\\u0ec4'\n-    | '\\u0ec6'\n-    | '\\u0ec8' .. '\\u0ecd'\n-    | '\\u0ed0' .. '\\u0ed9'\n-    | '\\u0edc' .. '\\u0edd'\n-    | '\\u0f00'\n-    | '\\u0f18' .. '\\u0f19'\n-    | '\\u0f20' .. '\\u0f29'\n-    | '\\u0f35'\n-    | '\\u0f37'\n-    | '\\u0f39'\n-    | '\\u0f3e' .. '\\u0f47'\n-    | '\\u0f49' .. '\\u0f6a'\n-    | '\\u0f71' .. '\\u0f84'\n-    | '\\u0f86' .. '\\u0f8b'\n-    | '\\u0f90' .. '\\u0f97'\n-    | '\\u0f99' .. '\\u0fbc'\n-    | '\\u0fc6'\n-    | '\\u1000' .. '\\u1021'\n-    | '\\u1023' .. '\\u1027'\n-    | '\\u1029' .. '\\u102a'\n-    | '\\u102c' .. '\\u1032'\n-    | '\\u1036' .. '\\u1039'\n-    | '\\u1040' .. '\\u1049'\n-    | '\\u1050' .. '\\u1059'\n-    | '\\u10a0' .. '\\u10c5'\n-    | '\\u10d0' .. '\\u10f8'\n-    | '\\u1100' .. '\\u1159'\n-    | '\\u115f' .. '\\u11a2'\n-    | '\\u11a8' .. '\\u11f9'\n-    | '\\u1200' .. '\\u1206'\n-    | '\\u1208' .. '\\u1246'\n-    | '\\u1248'\n-    | '\\u124a' .. '\\u124d'\n-    | '\\u1250' .. '\\u1256'\n-    | '\\u1258'\n-    | '\\u125a' .. '\\u125d'\n-    | '\\u1260' .. '\\u1286'\n-    | '\\u1288'\n-    | '\\u128a' .. '\\u128d'\n-    | '\\u1290' .. '\\u12ae'\n-    | '\\u12b0'\n-    | '\\u12b2' .. '\\u12b5'\n-    | '\\u12b8' .. '\\u12be'\n-    | '\\u12c0'\n-    | '\\u12c2' .. '\\u12c5'\n-    | '\\u12c8' .. '\\u12ce'\n-    | '\\u12d0' .. '\\u12d6'\n-    | '\\u12d8' .. '\\u12ee'\n-    | '\\u12f0' .. '\\u130e'\n-    | '\\u1310'\n-    | '\\u1312' .. '\\u1315'\n-    | '\\u1318' .. '\\u131e'\n-    | '\\u1320' .. '\\u1346'\n-    | '\\u1348' .. '\\u135a'\n-    | '\\u1369' .. '\\u1371'\n-    | '\\u13a0' .. '\\u13f4'\n-    | '\\u1401' .. '\\u166c'\n-    | '\\u166f' .. '\\u1676'\n-    | '\\u1681' .. '\\u169a'\n-    | '\\u16a0' .. '\\u16ea'\n-    | '\\u16ee' .. '\\u16f0'\n-    | '\\u1700' .. '\\u170c'\n-    | '\\u170e' .. '\\u1714'\n-    | '\\u1720' .. '\\u1734'\n-    | '\\u1740' .. '\\u1753'\n-    | '\\u1760' .. '\\u176c'\n-    | '\\u176e' .. '\\u1770'\n-    | '\\u1772' .. '\\u1773'\n-    | '\\u1780' .. '\\u17b3'\n-    | '\\u17b6' .. '\\u17d3'\n-    | '\\u17d7'\n-    | '\\u17dc' .. '\\u17dd'\n-    | '\\u17e0' .. '\\u17e9'\n-    | '\\u180b' .. '\\u180d'\n-    | '\\u1810' .. '\\u1819'\n-    | '\\u1820' .. '\\u1877'\n-    | '\\u1880' .. '\\u18a9'\n-    | '\\u1900' .. '\\u191c'\n-    | '\\u1920' .. '\\u192b'\n-    | '\\u1930' .. '\\u193b'\n-    | '\\u1946' .. '\\u196d'\n-    | '\\u1970' .. '\\u1974'\n-    | '\\u1d00' .. '\\u1d6b'\n-    | '\\u1e00' .. '\\u1e9b'\n-    | '\\u1ea0' .. '\\u1ef9'\n-    | '\\u1f00' .. '\\u1f15'\n-    | '\\u1f18' .. '\\u1f1d'\n-    | '\\u1f20' .. '\\u1f45'\n-    | '\\u1f48' .. '\\u1f4d'\n-    | '\\u1f50' .. '\\u1f57'\n-    | '\\u1f59'\n-    | '\\u1f5b'\n-    | '\\u1f5d'\n-    | '\\u1f5f' .. '\\u1f7d'\n-    | '\\u1f80' .. '\\u1fb4'\n-    | '\\u1fb6' .. '\\u1fbc'\n-    | '\\u1fbe'\n-    | '\\u1fc2' .. '\\u1fc4'\n-    | '\\u1fc6' .. '\\u1fcc'\n-    | '\\u1fd0' .. '\\u1fd3'\n-    | '\\u1fd6' .. '\\u1fdb'\n-    | '\\u1fe0' .. '\\u1fec'\n-    | '\\u1ff2' .. '\\u1ff4'\n-    | '\\u1ff6' .. '\\u1ffc'\n-    | '\\u203f' .. '\\u2040'\n-    | '\\u2054'\n-    | '\\u2071'\n-    | '\\u207f'\n-    | '\\u20d0' .. '\\u20dc'\n-    | '\\u20e1'\n-    | '\\u20e5' .. '\\u20ea'\n-    | '\\u2102'\n-    | '\\u2107'\n-    | '\\u210a' .. '\\u2113'\n-    | '\\u2115'\n-    | '\\u2118' .. '\\u211d'\n-    | '\\u2124'\n-    | '\\u2126'\n-    | '\\u2128'\n-    | '\\u212a' .. '\\u2131'\n-    | '\\u2133' .. '\\u2139'\n-    | '\\u213d' .. '\\u213f'\n-    | '\\u2145' .. '\\u2149'\n-    | '\\u2160' .. '\\u2183'\n-    | '\\u3005' .. '\\u3007'\n-    | '\\u3021' .. '\\u302f'\n-    | '\\u3031' .. '\\u3035'\n-    | '\\u3038' .. '\\u303c'\n-    | '\\u3041' .. '\\u3096'\n-    | '\\u3099' .. '\\u309a'\n-    | '\\u309d' .. '\\u309f'\n-    | '\\u30a1' .. '\\u30ff'\n-    | '\\u3105' .. '\\u312c'\n-    | '\\u3131' .. '\\u318e'\n-    | '\\u31a0' .. '\\u31b7'\n-    | '\\u31f0' .. '\\u31ff'\n-    | '\\u3400' .. '\\u4db5'\n-    | '\\u4e00' .. '\\u9fa5'\n-    | '\\ua000' .. '\\ua48c'\n-    | '\\uac00' .. '\\ud7a3'\n-    | '\\uf900' .. '\\ufa2d'\n-    | '\\ufa30' .. '\\ufa6a'\n-    | '\\ufb00' .. '\\ufb06'\n-    | '\\ufb13' .. '\\ufb17'\n-    | '\\ufb1d' .. '\\ufb28'\n-    | '\\ufb2a' .. '\\ufb36'\n-    | '\\ufb38' .. '\\ufb3c'\n-    | '\\ufb3e'\n-    | '\\ufb40' .. '\\ufb41'\n-    | '\\ufb43' .. '\\ufb44'\n-    | '\\ufb46' .. '\\ufbb1'\n-    | '\\ufbd3' .. '\\ufc5d'\n-    | '\\ufc64' .. '\\ufd3d'\n-    | '\\ufd50' .. '\\ufd8f'\n-    | '\\ufd92' .. '\\ufdc7'\n-    | '\\ufdf0' .. '\\ufdf9'\n-    | '\\ufe00' .. '\\ufe0f'\n-    | '\\ufe20' .. '\\ufe23'\n-    | '\\ufe33' .. '\\ufe34'\n-    | '\\ufe4d' .. '\\ufe4f'\n-    | '\\ufe71'\n-    | '\\ufe73'\n-    | '\\ufe77'\n-    | '\\ufe79'\n-    | '\\ufe7b'\n-    | '\\ufe7d'\n-    | '\\ufe7f' .. '\\ufefc'\n-    | '\\uff10' .. '\\uff19'\n-    | '\\uff21' .. '\\uff3a'\n-    | '\\uff3f'\n-    | '\\uff41' .. '\\uff5a'\n-    | '\\uff65' .. '\\uffbe'\n-    | '\\uffc2' .. '\\uffc7'\n-    | '\\uffca' .. '\\uffcf'\n-    | '\\uffd2' .. '\\uffd7'\n-    | '\\uffda' .. '\\uffdc'\n-    | '\\ud800' '\\udc00' .. '\\udc0a'\n-    | '\\ud800' '\\udc0d' .. '\\udc25'\n-    | '\\ud800' '\\udc28' .. '\\udc39'\n-    | '\\ud800' '\\udc3c' .. '\\udc3c'\n-    | '\\ud800' '\\udc3f' .. '\\udc4c'\n-    | '\\ud800' '\\udc50' .. '\\udc5c'\n-    | '\\ud800' '\\udc80' .. '\\udcf9'\n-    | '\\ud800' '\\udf00' .. '\\udf1d'\n-    | '\\ud800' '\\udf30' .. '\\udf49'\n-    | '\\ud800' '\\udf80' .. '\\udf9c'\n-    | '\\ud801' '\\ue000' .. '\\ue09c'\n-    | '\\ud801' '\\ue0a0' .. '\\ue0a8'\n-    | '\\ud802' '\\ue400' .. '\\ue404'\n-    | '\\ud802' '\\u0808'\n-    | '\\ud802' '\\ue40a' .. '\\ue434'\n-    | '\\ud802' '\\ue437' .. '\\ue437'\n-    | '\\ud802' '\\u083c'\n-    | '\\ud802' '\\u083f'\n-    | '\\ud834' '\\uad65' .. '\\uad68'\n-    | '\\ud834' '\\uad6d' .. '\\uad71'\n-    | '\\ud834' '\\uad7b' .. '\\uad81'\n-    | '\\ud834' '\\uad85' .. '\\uad8a'\n-    | '\\ud834' '\\uadaa' .. '\\uadac'\n-    | '\\ud835' '\\ub000' .. '\\ub053'\n-    | '\\ud835' '\\ub056' .. '\\ub09b'\n-    | '\\ud835' '\\ub09e' .. '\\ub09e'\n-    | '\\ud835' '\\ud4a2'\n-    | '\\ud835' '\\ub0a5' .. '\\ub0a5'\n-    | '\\ud835' '\\ub0a9' .. '\\ub0ab'\n-    | '\\ud835' '\\ub0ae' .. '\\ub0b8'\n-    | '\\ud835' '\\ud4bb'\n-    | '\\ud835' '\\ub0bd' .. '\\ub0c2'\n-    | '\\ud835' '\\ub0c5' .. '\\ub104'\n-    | '\\ud835' '\\ub107' .. '\\ub109'\n-    | '\\ud835' '\\ub10d' .. '\\ub113'\n-    | '\\ud835' '\\ub116' .. '\\ub11b'\n-    | '\\ud835' '\\ub11e' .. '\\ub138'\n-    | '\\ud835' '\\ub13b' .. '\\ub13d'\n-    | '\\ud835' '\\ub140' .. '\\ub143'\n-    | '\\ud835' '\\ud546'\n-    | '\\ud835' '\\ub14a' .. '\\ub14f'\n-    | '\\ud835' '\\ub152' .. '\\ub2a2'\n-    | '\\ud835' '\\ub2a8' .. '\\ub2bf'\n-    | '\\ud835' '\\ub2c2' .. '\\ub2d9'\n-    | '\\ud835' '\\ub2dc' .. '\\ub2f9'\n-    | '\\ud835' '\\ub2fc' .. '\\ub313'\n-    | '\\ud835' '\\ub316' .. '\\ub333'\n-    | '\\ud835' '\\ub336' .. '\\ub34d'\n-    | '\\ud835' '\\ub350' .. '\\ub36d'\n-    | '\\ud835' '\\ub370' .. '\\ub387'\n-    | '\\ud835' '\\ub38a' .. '\\ub3a7'\n-    | '\\ud835' '\\ub3aa' .. '\\ub3c1'\n-    | '\\ud835' '\\ub3c4' .. '\\ub3c8'\n-    | '\\ud835' '\\ub3ce' .. '\\ub3fe'\n-    | '\\ud840' '\\udc00' .. '\\udffe'\n-    | '\\ud841' '\\ue000' .. '\\ue3fe'\n-    | '\\ud842' '\\ue400' .. '\\ue7fe'\n-    | '\\ud843' '\\ue800' .. '\\uebfe'\n-    | '\\ud844' '\\uec00' .. '\\ueffe'\n-    | '\\ud845' '\\uf000' .. '\\uf3fe'\n-    | '\\ud846' '\\uf400' .. '\\uf7fe'\n-    | '\\ud847' '\\uf800' .. '\\ufbfe'\n-    | '\\ud848' '\\ufc00' .. '\\ufffe'\n-    | '\\ud849' '\\u0000' .. '\\u03fe'\n-    | '\\ud84a' '\\u0400' .. '\\u07fe'\n-    | '\\ud84b' '\\u0800' .. '\\u0bfe'\n-    | '\\ud84c' '\\u0c00' .. '\\u0ffe'\n-    | '\\ud84d' '\\u1000' .. '\\u13fe'\n-    | '\\ud84e' '\\u1400' .. '\\u17fe'\n-    | '\\ud84f' '\\u1800' .. '\\u1bfe'\n-    | '\\ud850' '\\u1c00' .. '\\u1ffe'\n-    | '\\ud851' '\\u2000' .. '\\u23fe'\n-    | '\\ud852' '\\u2400' .. '\\u27fe'\n-    | '\\ud853' '\\u2800' .. '\\u2bfe'\n-    | '\\ud854' '\\u2c00' .. '\\u2ffe'\n-    | '\\ud855' '\\u3000' .. '\\u33fe'\n-    | '\\ud856' '\\u3400' .. '\\u37fe'\n-    | '\\ud857' '\\u3800' .. '\\u3bfe'\n-    | '\\ud858' '\\u3c00' .. '\\u3ffe'\n-    | '\\ud859' '\\u4000' .. '\\u43fe'\n-    | '\\ud85a' '\\u4400' .. '\\u47fe'\n-    | '\\ud85b' '\\u4800' .. '\\u4bfe'\n-    | '\\ud85c' '\\u4c00' .. '\\u4ffe'\n-    | '\\ud85d' '\\u5000' .. '\\u53fe'\n-    | '\\ud85e' '\\u5400' .. '\\u57fe'\n-    | '\\ud85f' '\\u5800' .. '\\u5bfe'\n-    | '\\ud860' '\\u5c00' .. '\\u5ffe'\n-    | '\\ud861' '\\u6000' .. '\\u63fe'\n-    | '\\ud862' '\\u6400' .. '\\u67fe'\n-    | '\\ud863' '\\u6800' .. '\\u6bfe'\n-    | '\\ud864' '\\u6c00' .. '\\u6ffe'\n-    | '\\ud865' '\\u7000' .. '\\u73fe'\n-    | '\\ud866' '\\u7400' .. '\\u77fe'\n-    | '\\ud867' '\\u7800' .. '\\u7bfe'\n-    | '\\ud868' '\\u7c00' .. '\\u7ffe'\n-    | '\\ud869' '\\u8000' .. '\\u82d5'\n-    | '\\ud87e' '\\ud400' .. '\\ud61c'\n-    | '\\udb40' '\\udd00' .. '\\uddee'\n-    ;"}, {"sha": "53fb50f4584d2d65eee0b77d8f9f090cc47abeed", "filename": "src/grammar/xidstart.g4", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fxidstart.g4", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Fgrammar%2Fxidstart.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fxidstart.g4?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,379 +0,0 @@\n-lexer grammar Xidstart;\n-\n-fragment XID_Start :\n-      '\\u0041' .. '\\u005a'\n-    | '_'\n-    | '\\u0061' .. '\\u007a'\n-    | '\\u00aa'\n-    | '\\u00b5'\n-    | '\\u00ba'\n-    | '\\u00c0' .. '\\u00d6'\n-    | '\\u00d8' .. '\\u00f6'\n-    | '\\u00f8' .. '\\u0236'\n-    | '\\u0250' .. '\\u02c1'\n-    | '\\u02c6' .. '\\u02d1'\n-    | '\\u02e0' .. '\\u02e4'\n-    | '\\u02ee'\n-    | '\\u0386'\n-    | '\\u0388' .. '\\u038a'\n-    | '\\u038c'\n-    | '\\u038e' .. '\\u03a1'\n-    | '\\u03a3' .. '\\u03ce'\n-    | '\\u03d0' .. '\\u03f5'\n-    | '\\u03f7' .. '\\u03fb'\n-    | '\\u0400' .. '\\u0481'\n-    | '\\u048a' .. '\\u04ce'\n-    | '\\u04d0' .. '\\u04f5'\n-    | '\\u04f8' .. '\\u04f9'\n-    | '\\u0500' .. '\\u050f'\n-    | '\\u0531' .. '\\u0556'\n-    | '\\u0559'\n-    | '\\u0561' .. '\\u0587'\n-    | '\\u05d0' .. '\\u05ea'\n-    | '\\u05f0' .. '\\u05f2'\n-    | '\\u0621' .. '\\u063a'\n-    | '\\u0640' .. '\\u064a'\n-    | '\\u066e' .. '\\u066f'\n-    | '\\u0671' .. '\\u06d3'\n-    | '\\u06d5'\n-    | '\\u06e5' .. '\\u06e6'\n-    | '\\u06ee' .. '\\u06ef'\n-    | '\\u06fa' .. '\\u06fc'\n-    | '\\u06ff'\n-    | '\\u0710'\n-    | '\\u0712' .. '\\u072f'\n-    | '\\u074d' .. '\\u074f'\n-    | '\\u0780' .. '\\u07a5'\n-    | '\\u07b1'\n-    | '\\u0904' .. '\\u0939'\n-    | '\\u093d'\n-    | '\\u0950'\n-    | '\\u0958' .. '\\u0961'\n-    | '\\u0985' .. '\\u098c'\n-    | '\\u098f' .. '\\u0990'\n-    | '\\u0993' .. '\\u09a8'\n-    | '\\u09aa' .. '\\u09b0'\n-    | '\\u09b2'\n-    | '\\u09b6' .. '\\u09b9'\n-    | '\\u09bd'\n-    | '\\u09dc' .. '\\u09dd'\n-    | '\\u09df' .. '\\u09e1'\n-    | '\\u09f0' .. '\\u09f1'\n-    | '\\u0a05' .. '\\u0a0a'\n-    | '\\u0a0f' .. '\\u0a10'\n-    | '\\u0a13' .. '\\u0a28'\n-    | '\\u0a2a' .. '\\u0a30'\n-    | '\\u0a32' .. '\\u0a33'\n-    | '\\u0a35' .. '\\u0a36'\n-    | '\\u0a38' .. '\\u0a39'\n-    | '\\u0a59' .. '\\u0a5c'\n-    | '\\u0a5e'\n-    | '\\u0a72' .. '\\u0a74'\n-    | '\\u0a85' .. '\\u0a8d'\n-    | '\\u0a8f' .. '\\u0a91'\n-    | '\\u0a93' .. '\\u0aa8'\n-    | '\\u0aaa' .. '\\u0ab0'\n-    | '\\u0ab2' .. '\\u0ab3'\n-    | '\\u0ab5' .. '\\u0ab9'\n-    | '\\u0abd'\n-    | '\\u0ad0'\n-    | '\\u0ae0' .. '\\u0ae1'\n-    | '\\u0b05' .. '\\u0b0c'\n-    | '\\u0b0f' .. '\\u0b10'\n-    | '\\u0b13' .. '\\u0b28'\n-    | '\\u0b2a' .. '\\u0b30'\n-    | '\\u0b32' .. '\\u0b33'\n-    | '\\u0b35' .. '\\u0b39'\n-    | '\\u0b3d'\n-    | '\\u0b5c' .. '\\u0b5d'\n-    | '\\u0b5f' .. '\\u0b61'\n-    | '\\u0b71'\n-    | '\\u0b83'\n-    | '\\u0b85' .. '\\u0b8a'\n-    | '\\u0b8e' .. '\\u0b90'\n-    | '\\u0b92' .. '\\u0b95'\n-    | '\\u0b99' .. '\\u0b9a'\n-    | '\\u0b9c'\n-    | '\\u0b9e' .. '\\u0b9f'\n-    | '\\u0ba3' .. '\\u0ba4'\n-    | '\\u0ba8' .. '\\u0baa'\n-    | '\\u0bae' .. '\\u0bb5'\n-    | '\\u0bb7' .. '\\u0bb9'\n-    | '\\u0c05' .. '\\u0c0c'\n-    | '\\u0c0e' .. '\\u0c10'\n-    | '\\u0c12' .. '\\u0c28'\n-    | '\\u0c2a' .. '\\u0c33'\n-    | '\\u0c35' .. '\\u0c39'\n-    | '\\u0c60' .. '\\u0c61'\n-    | '\\u0c85' .. '\\u0c8c'\n-    | '\\u0c8e' .. '\\u0c90'\n-    | '\\u0c92' .. '\\u0ca8'\n-    | '\\u0caa' .. '\\u0cb3'\n-    | '\\u0cb5' .. '\\u0cb9'\n-    | '\\u0cbd'\n-    | '\\u0cde'\n-    | '\\u0ce0' .. '\\u0ce1'\n-    | '\\u0d05' .. '\\u0d0c'\n-    | '\\u0d0e' .. '\\u0d10'\n-    | '\\u0d12' .. '\\u0d28'\n-    | '\\u0d2a' .. '\\u0d39'\n-    | '\\u0d60' .. '\\u0d61'\n-    | '\\u0d85' .. '\\u0d96'\n-    | '\\u0d9a' .. '\\u0db1'\n-    | '\\u0db3' .. '\\u0dbb'\n-    | '\\u0dbd'\n-    | '\\u0dc0' .. '\\u0dc6'\n-    | '\\u0e01' .. '\\u0e30'\n-    | '\\u0e32'\n-    | '\\u0e40' .. '\\u0e46'\n-    | '\\u0e81' .. '\\u0e82'\n-    | '\\u0e84'\n-    | '\\u0e87' .. '\\u0e88'\n-    | '\\u0e8a'\n-    | '\\u0e8d'\n-    | '\\u0e94' .. '\\u0e97'\n-    | '\\u0e99' .. '\\u0e9f'\n-    | '\\u0ea1' .. '\\u0ea3'\n-    | '\\u0ea5'\n-    | '\\u0ea7'\n-    | '\\u0eaa' .. '\\u0eab'\n-    | '\\u0ead' .. '\\u0eb0'\n-    | '\\u0eb2'\n-    | '\\u0ebd'\n-    | '\\u0ec0' .. '\\u0ec4'\n-    | '\\u0ec6'\n-    | '\\u0edc' .. '\\u0edd'\n-    | '\\u0f00'\n-    | '\\u0f40' .. '\\u0f47'\n-    | '\\u0f49' .. '\\u0f6a'\n-    | '\\u0f88' .. '\\u0f8b'\n-    | '\\u1000' .. '\\u1021'\n-    | '\\u1023' .. '\\u1027'\n-    | '\\u1029' .. '\\u102a'\n-    | '\\u1050' .. '\\u1055'\n-    | '\\u10a0' .. '\\u10c5'\n-    | '\\u10d0' .. '\\u10f8'\n-    | '\\u1100' .. '\\u1159'\n-    | '\\u115f' .. '\\u11a2'\n-    | '\\u11a8' .. '\\u11f9'\n-    | '\\u1200' .. '\\u1206'\n-    | '\\u1208' .. '\\u1246'\n-    | '\\u1248'\n-    | '\\u124a' .. '\\u124d'\n-    | '\\u1250' .. '\\u1256'\n-    | '\\u1258'\n-    | '\\u125a' .. '\\u125d'\n-    | '\\u1260' .. '\\u1286'\n-    | '\\u1288'\n-    | '\\u128a' .. '\\u128d'\n-    | '\\u1290' .. '\\u12ae'\n-    | '\\u12b0'\n-    | '\\u12b2' .. '\\u12b5'\n-    | '\\u12b8' .. '\\u12be'\n-    | '\\u12c0'\n-    | '\\u12c2' .. '\\u12c5'\n-    | '\\u12c8' .. '\\u12ce'\n-    | '\\u12d0' .. '\\u12d6'\n-    | '\\u12d8' .. '\\u12ee'\n-    | '\\u12f0' .. '\\u130e'\n-    | '\\u1310'\n-    | '\\u1312' .. '\\u1315'\n-    | '\\u1318' .. '\\u131e'\n-    | '\\u1320' .. '\\u1346'\n-    | '\\u1348' .. '\\u135a'\n-    | '\\u13a0' .. '\\u13f4'\n-    | '\\u1401' .. '\\u166c'\n-    | '\\u166f' .. '\\u1676'\n-    | '\\u1681' .. '\\u169a'\n-    | '\\u16a0' .. '\\u16ea'\n-    | '\\u16ee' .. '\\u16f0'\n-    | '\\u1700' .. '\\u170c'\n-    | '\\u170e' .. '\\u1711'\n-    | '\\u1720' .. '\\u1731'\n-    | '\\u1740' .. '\\u1751'\n-    | '\\u1760' .. '\\u176c'\n-    | '\\u176e' .. '\\u1770'\n-    | '\\u1780' .. '\\u17b3'\n-    | '\\u17d7'\n-    | '\\u17dc'\n-    | '\\u1820' .. '\\u1877'\n-    | '\\u1880' .. '\\u18a8'\n-    | '\\u1900' .. '\\u191c'\n-    | '\\u1950' .. '\\u196d'\n-    | '\\u1970' .. '\\u1974'\n-    | '\\u1d00' .. '\\u1d6b'\n-    | '\\u1e00' .. '\\u1e9b'\n-    | '\\u1ea0' .. '\\u1ef9'\n-    | '\\u1f00' .. '\\u1f15'\n-    | '\\u1f18' .. '\\u1f1d'\n-    | '\\u1f20' .. '\\u1f45'\n-    | '\\u1f48' .. '\\u1f4d'\n-    | '\\u1f50' .. '\\u1f57'\n-    | '\\u1f59'\n-    | '\\u1f5b'\n-    | '\\u1f5d'\n-    | '\\u1f5f' .. '\\u1f7d'\n-    | '\\u1f80' .. '\\u1fb4'\n-    | '\\u1fb6' .. '\\u1fbc'\n-    | '\\u1fbe'\n-    | '\\u1fc2' .. '\\u1fc4'\n-    | '\\u1fc6' .. '\\u1fcc'\n-    | '\\u1fd0' .. '\\u1fd3'\n-    | '\\u1fd6' .. '\\u1fdb'\n-    | '\\u1fe0' .. '\\u1fec'\n-    | '\\u1ff2' .. '\\u1ff4'\n-    | '\\u1ff6' .. '\\u1ffc'\n-    | '\\u2071'\n-    | '\\u207f'\n-    | '\\u2102'\n-    | '\\u2107'\n-    | '\\u210a' .. '\\u2113'\n-    | '\\u2115'\n-    | '\\u2118' .. '\\u211d'\n-    | '\\u2124'\n-    | '\\u2126'\n-    | '\\u2128'\n-    | '\\u212a' .. '\\u2131'\n-    | '\\u2133' .. '\\u2139'\n-    | '\\u213d' .. '\\u213f'\n-    | '\\u2145' .. '\\u2149'\n-    | '\\u2160' .. '\\u2183'\n-    | '\\u3005' .. '\\u3007'\n-    | '\\u3021' .. '\\u3029'\n-    | '\\u3031' .. '\\u3035'\n-    | '\\u3038' .. '\\u303c'\n-    | '\\u3041' .. '\\u3096'\n-    | '\\u309d' .. '\\u309f'\n-    | '\\u30a1' .. '\\u30fa'\n-    | '\\u30fc' .. '\\u30ff'\n-    | '\\u3105' .. '\\u312c'\n-    | '\\u3131' .. '\\u318e'\n-    | '\\u31a0' .. '\\u31b7'\n-    | '\\u31f0' .. '\\u31ff'\n-    | '\\u3400' .. '\\u4db5'\n-    | '\\u4e00' .. '\\u9fa5'\n-    | '\\ua000' .. '\\ua48c'\n-    | '\\uac00' .. '\\ud7a3'\n-    | '\\uf900' .. '\\ufa2d'\n-    | '\\ufa30' .. '\\ufa6a'\n-    | '\\ufb00' .. '\\ufb06'\n-    | '\\ufb13' .. '\\ufb17'\n-    | '\\ufb1d'\n-    | '\\ufb1f' .. '\\ufb28'\n-    | '\\ufb2a' .. '\\ufb36'\n-    | '\\ufb38' .. '\\ufb3c'\n-    | '\\ufb3e'\n-    | '\\ufb40' .. '\\ufb41'\n-    | '\\ufb43' .. '\\ufb44'\n-    | '\\ufb46' .. '\\ufbb1'\n-    | '\\ufbd3' .. '\\ufc5d'\n-    | '\\ufc64' .. '\\ufd3d'\n-    | '\\ufd50' .. '\\ufd8f'\n-    | '\\ufd92' .. '\\ufdc7'\n-    | '\\ufdf0' .. '\\ufdf9'\n-    | '\\ufe71'\n-    | '\\ufe73'\n-    | '\\ufe77'\n-    | '\\ufe79'\n-    | '\\ufe7b'\n-    | '\\ufe7d'\n-    | '\\ufe7f' .. '\\ufefc'\n-    | '\\uff21' .. '\\uff3a'\n-    | '\\uff41' .. '\\uff5a'\n-    | '\\uff66' .. '\\uff9d'\n-    | '\\uffa0' .. '\\uffbe'\n-    | '\\uffc2' .. '\\uffc7'\n-    | '\\uffca' .. '\\uffcf'\n-    | '\\uffd2' .. '\\uffd7'\n-    | '\\uffda' .. '\\uffdc'\n-    | '\\ud800' '\\udc00' .. '\\udc0a'\n-    | '\\ud800' '\\udc0d' .. '\\udc25'\n-    | '\\ud800' '\\udc28' .. '\\udc39'\n-    | '\\ud800' '\\udc3c' .. '\\udc3c'\n-    | '\\ud800' '\\udc3f' .. '\\udc4c'\n-    | '\\ud800' '\\udc50' .. '\\udc5c'\n-    | '\\ud800' '\\udc80' .. '\\udcf9'\n-    | '\\ud800' '\\udf00' .. '\\udf1d'\n-    | '\\ud800' '\\udf30' .. '\\udf49'\n-    | '\\ud800' '\\udf80' .. '\\udf9c'\n-    | '\\ud801' '\\ue000' .. '\\ue09c'\n-    | '\\ud802' '\\ue400' .. '\\ue404'\n-    | '\\ud802' '\\u0808'\n-    | '\\ud802' '\\ue40a' .. '\\ue434'\n-    | '\\ud802' '\\ue437' .. '\\ue437'\n-    | '\\ud802' '\\u083c'\n-    | '\\ud802' '\\u083f'\n-    | '\\ud835' '\\ub000' .. '\\ub053'\n-    | '\\ud835' '\\ub056' .. '\\ub09b'\n-    | '\\ud835' '\\ub09e' .. '\\ub09e'\n-    | '\\ud835' '\\ud4a2'\n-    | '\\ud835' '\\ub0a5' .. '\\ub0a5'\n-    | '\\ud835' '\\ub0a9' .. '\\ub0ab'\n-    | '\\ud835' '\\ub0ae' .. '\\ub0b8'\n-    | '\\ud835' '\\ud4bb'\n-    | '\\ud835' '\\ub0bd' .. '\\ub0c2'\n-    | '\\ud835' '\\ub0c5' .. '\\ub104'\n-    | '\\ud835' '\\ub107' .. '\\ub109'\n-    | '\\ud835' '\\ub10d' .. '\\ub113'\n-    | '\\ud835' '\\ub116' .. '\\ub11b'\n-    | '\\ud835' '\\ub11e' .. '\\ub138'\n-    | '\\ud835' '\\ub13b' .. '\\ub13d'\n-    | '\\ud835' '\\ub140' .. '\\ub143'\n-    | '\\ud835' '\\ud546'\n-    | '\\ud835' '\\ub14a' .. '\\ub14f'\n-    | '\\ud835' '\\ub152' .. '\\ub2a2'\n-    | '\\ud835' '\\ub2a8' .. '\\ub2bf'\n-    | '\\ud835' '\\ub2c2' .. '\\ub2d9'\n-    | '\\ud835' '\\ub2dc' .. '\\ub2f9'\n-    | '\\ud835' '\\ub2fc' .. '\\ub313'\n-    | '\\ud835' '\\ub316' .. '\\ub333'\n-    | '\\ud835' '\\ub336' .. '\\ub34d'\n-    | '\\ud835' '\\ub350' .. '\\ub36d'\n-    | '\\ud835' '\\ub370' .. '\\ub387'\n-    | '\\ud835' '\\ub38a' .. '\\ub3a7'\n-    | '\\ud835' '\\ub3aa' .. '\\ub3c1'\n-    | '\\ud835' '\\ub3c4' .. '\\ub3c8'\n-    | '\\ud840' '\\udc00' .. '\\udffe'\n-    | '\\ud841' '\\ue000' .. '\\ue3fe'\n-    | '\\ud842' '\\ue400' .. '\\ue7fe'\n-    | '\\ud843' '\\ue800' .. '\\uebfe'\n-    | '\\ud844' '\\uec00' .. '\\ueffe'\n-    | '\\ud845' '\\uf000' .. '\\uf3fe'\n-    | '\\ud846' '\\uf400' .. '\\uf7fe'\n-    | '\\ud847' '\\uf800' .. '\\ufbfe'\n-    | '\\ud848' '\\ufc00' .. '\\ufffe'\n-    | '\\ud849' '\\u0000' .. '\\u03fe'\n-    | '\\ud84a' '\\u0400' .. '\\u07fe'\n-    | '\\ud84b' '\\u0800' .. '\\u0bfe'\n-    | '\\ud84c' '\\u0c00' .. '\\u0ffe'\n-    | '\\ud84d' '\\u1000' .. '\\u13fe'\n-    | '\\ud84e' '\\u1400' .. '\\u17fe'\n-    | '\\ud84f' '\\u1800' .. '\\u1bfe'\n-    | '\\ud850' '\\u1c00' .. '\\u1ffe'\n-    | '\\ud851' '\\u2000' .. '\\u23fe'\n-    | '\\ud852' '\\u2400' .. '\\u27fe'\n-    | '\\ud853' '\\u2800' .. '\\u2bfe'\n-    | '\\ud854' '\\u2c00' .. '\\u2ffe'\n-    | '\\ud855' '\\u3000' .. '\\u33fe'\n-    | '\\ud856' '\\u3400' .. '\\u37fe'\n-    | '\\ud857' '\\u3800' .. '\\u3bfe'\n-    | '\\ud858' '\\u3c00' .. '\\u3ffe'\n-    | '\\ud859' '\\u4000' .. '\\u43fe'\n-    | '\\ud85a' '\\u4400' .. '\\u47fe'\n-    | '\\ud85b' '\\u4800' .. '\\u4bfe'\n-    | '\\ud85c' '\\u4c00' .. '\\u4ffe'\n-    | '\\ud85d' '\\u5000' .. '\\u53fe'\n-    | '\\ud85e' '\\u5400' .. '\\u57fe'\n-    | '\\ud85f' '\\u5800' .. '\\u5bfe'\n-    | '\\ud860' '\\u5c00' .. '\\u5ffe'\n-    | '\\ud861' '\\u6000' .. '\\u63fe'\n-    | '\\ud862' '\\u6400' .. '\\u67fe'\n-    | '\\ud863' '\\u6800' .. '\\u6bfe'\n-    | '\\ud864' '\\u6c00' .. '\\u6ffe'\n-    | '\\ud865' '\\u7000' .. '\\u73fe'\n-    | '\\ud866' '\\u7400' .. '\\u77fe'\n-    | '\\ud867' '\\u7800' .. '\\u7bfe'\n-    | '\\ud868' '\\u7c00' .. '\\u7ffe'\n-    | '\\ud869' '\\u8000' .. '\\u82d5'\n-    | '\\ud87e' '\\ud400' .. '\\ud61c'\n-    ;"}, {"sha": "c13fd5583543e6f7b43928eda2cd23df67984485", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -1573,12 +1573,30 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// An atomic fence.\n ///\n-/// A fence 'A' which has [`Release`] ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) [`Acquire`] semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// Depending on the specified order, a fence prevents the compiler and CPU from\n+/// reordering certain types of memory operations around it.\n+/// That creates synchronizes-with relationships between it and atomic operations\n+/// or fences in other threads.\n+///\n+/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n+/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n+/// exist operations X and Y, both operating on some atomic object 'M' such\n /// that A is sequenced before X, Y is synchronized before B and Y observes\n /// the change to M. This provides a happens-before dependence between A and B.\n ///\n+/// ```text\n+///     Thread 1                                          Thread 2\n+///\n+/// fence(Release);      A --------------\n+/// x.store(3, Relaxed); X ---------    |\n+///                                |    |\n+///                                |    |\n+///                                -------------> Y  if x.load(Relaxed) == 3 {\n+///                                     |-------> B      fence(Acquire);\n+///                                                      ...\n+///                                                  }\n+/// ```\n+///\n /// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n /// with a fence.\n ///\n@@ -1592,6 +1610,37 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is [`Relaxed`].\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::sync::atomic::AtomicBool;\n+/// use std::sync::atomic::fence;\n+/// use std::sync::atomic::Ordering;\n+///\n+/// // A mutual exclusion primitive based on spinlock.\n+/// pub struct Mutex {\n+///     flag: AtomicBool,\n+/// }\n+///\n+/// impl Mutex {\n+///     pub fn new() -> Mutex {\n+///         Mutex {\n+///             flag: AtomicBool::new(false),\n+///         }\n+///     }\n+///\n+///     pub fn lock(&self) {\n+///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n+///         // This fence syncronizes-with store in `unlock`.\n+///         fence(Ordering::Acquire);\n+///     }\n+///\n+///     pub fn unlock(&self) {\n+///         self.flag.store(false, Ordering::Release);\n+///     }\n+/// }\n+/// ```\n+///\n /// [`Ordering`]: enum.Ordering.html\n /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst"}, {"sha": "37b8a56d9166b5c690b7ff968a3c43963ce592db", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -76,6 +76,7 @@ pub enum DepNode<D: Clone + Debug> {\n     BorrowCheck(D),\n     RvalueCheck(D),\n     Reachability,\n+    MirKeys,\n     LateLintCheck,\n     TransCrateItem(D),\n     TransInlinedItem(D),\n@@ -151,6 +152,8 @@ pub enum DepNode<D: Clone + Debug> {\n \n     DescribeDef(D),\n     DefSpan(D),\n+    Stability(D),\n+    Deprecation(D),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -202,6 +205,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n             Reachability => Some(Reachability),\n+            MirKeys => Some(MirKeys),\n             LateLintCheck => Some(LateLintCheck),\n             TransWriteMetadata => Some(TransWriteMetadata),\n \n@@ -258,6 +262,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             }\n             DescribeDef(ref d) => op(d).map(DescribeDef),\n             DefSpan(ref d) => op(d).map(DefSpan),\n+            Stability(ref d) => op(d).map(Stability),\n+            Deprecation(ref d) => op(d).map(Deprecation),\n         }\n     }\n }"}, {"sha": "6cb86a30400a772806fdcb546ad65b32871deff6", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -28,6 +28,5 @@ pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::visit::visit_all_bodies_in_krate;\n pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "59dce6f6bb0975a83f35090a27ac576ef1fccc60", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -50,6 +50,12 @@ impl<A, B> DepGraphSafe for (A, B)\n {\n }\n \n+/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a A\n+    where A: DepGraphSafe,\n+{\n+}\n+\n /// No data here! :)\n impl DepGraphSafe for () {\n }"}, {"sha": "bf3748659fe07f0e4f4e84e8bb7ccb7782a85eb0", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -75,15 +75,3 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     krate.visit_all_item_likes(&mut tracking_visitor)\n }\n \n-pub fn visit_all_bodies_in_krate<'a, 'tcx, C>(tcx: TyCtxt<'a, 'tcx, 'tcx>, callback: C)\n-    where C: Fn(/* body_owner */\n-                DefId,\n-                /* body id */\n-                hir::BodyId)\n-{\n-    let krate = tcx.hir.krate();\n-    for &body_id in &krate.body_ids {\n-        let body_owner_def_id = tcx.hir.body_owner_def_id(body_id);\n-        callback(body_owner_def_id, body_id);\n-    }\n-}"}, {"sha": "abc967dec905c23459cfc9fc567679316d5467af", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -455,7 +455,7 @@ impl<'hir> Map<'hir> {\n                 if let EntryExpr(_, expr) = entry {\n                     BodyId { node_id: expr.id }\n                 } else {\n-                    span_bug!(self.span(id), \"id `{}` has no associated body\", id);\n+                    span_bug!(self.span(id), \"id `{}` has no associated body: {:?}\", id, entry);\n                 }\n             }\n         } else {"}, {"sha": "d3954326e7b721c28586f0c001bbc82d3e703a6c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -43,6 +43,9 @@\n #![feature(unboxed_closures)]\n #![feature(discriminant_value)]\n #![feature(sort_unstable)]\n+#![feature(trace_macros)]\n+\n+#![recursion_limit=\"128\"]\n \n extern crate arena;\n extern crate core;"}, {"sha": "303c5059e7cf3d6136445d2a076dbe601243aeb4", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -38,7 +38,6 @@ use std::any::Any;\n use std::path::PathBuf;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -180,8 +179,6 @@ pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n     // item info\n-    fn stability(&self, def: DefId) -> Option<attr::Stability>;\n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n@@ -306,8 +303,6 @@ impl CrateStore for DummyCrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n-    fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")"}, {"sha": "198f7420f5d2b7af19a79a06ccb481ff2e5c1522", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if id.is_local() {\n             None // The stability cache is filled partially lazily\n         } else {\n-            self.sess.cstore.stability(id).map(|st| self.intern_stability(st))\n+            self.stability(id).map(|st| self.intern_stability(st))\n         }\n     }\n \n@@ -645,7 +645,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if id.is_local() {\n             None // The stability cache is filled partially lazily\n         } else {\n-            self.sess.cstore.deprecation(id).map(DeprecationEntry::external)\n+            self.deprecation(id).map(DeprecationEntry::external)\n         }\n     }\n }"}, {"sha": "e8ed8bf104cc8892fd60416a4fe752abff12ea48", "filename": "src/librustc/mir/README.md", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -0,0 +1,90 @@\n+# MIR definition and pass system\n+\n+This file contains the definition of the MIR datatypes along with the\n+various types for the \"MIR Pass\" system, which lets you easily\n+register and define new MIR transformations and analyses.\n+\n+Most of the code that operates on MIR can be found in the\n+`librustc_mir` crate or other crates. The code found here in\n+`librustc` is just the datatype definitions, alonging the functions\n+which operate on MIR to be placed everywhere else.\n+\n+## MIR Data Types and visitor\n+\n+The main MIR data type is `rustc::mir::Mir`, defined in `mod.rs`.\n+There is also the MIR visitor (in `visit.rs`) which allows you to walk\n+the MIR and override what actions will be taken at various points (you\n+can visit in either shared or mutable mode; the latter allows changing\n+the MIR in place). Finally `traverse.rs` contains various traversal\n+routines for visiting the MIR CFG in [different standard orders][traversal]\n+(e.g. pre-order, reverse post-order, and so forth).\n+\n+[traversal]: https://en.wikipedia.org/wiki/Tree_traversal\n+\n+## MIR pass suites and their integration into the query system\n+\n+As a MIR *consumer*, you are expected to use one of the queries that\n+returns a \"final MIR\". As of the time of this writing, there is only\n+one: `optimized_mir(def_id)`, but more are expected to come in the\n+future. For foreign def-ids, we simply read the MIR from the other\n+crate's metadata. But for local query, this query will construct the\n+MIR and then iteratively optimize it by putting it through various\n+pipeline stages. This section describes those pipeline stages and how\n+you can extend them.\n+\n+To produce the `optimized_mir(D)` for a given def-id `D`, the MIR\n+passes through several suites of optimizations, each represented by a\n+query. Each suite consists of multiple optimizations and\n+transformations. These suites represent useful intermediate points\n+where we want to access the MIR for type checking or other purposes:\n+\n+- `mir_build(D)` -- not a query, but this constructs the initial MIR\n+- `mir_const(D)` -- applies some simple transformations to make MIR ready for constant evaluation;\n+- `mir_validated(D)` -- applies some more transformations, making MIR ready for borrow checking;\n+- `optimized_mir(D)` -- the final state, after all optimizations have been performed.\n+\n+### Stealing\n+\n+The intermediate queries `mir_const()` and `mir_validated()` yield up\n+a `&'tcx Steal<Mir<'tcx>>`, allocated using\n+`tcx.alloc_steal_mir()`. This indicates that the result may be\n+**stolen** by the next suite of optimizations -- this is an\n+optimization to avoid cloning the MIR. Attempting to use a stolen\n+result will cause a panic in the compiler. Therefore, it is important\n+that you not read directly from these intermediate queries except as\n+part of the MIR processing pipeline.\n+\n+Because of this stealing mechanism, some care must also be taken to\n+ensure that, before the MIR at a particular phase in the processing\n+pipeline is stolen, anyone who may want to read from it has already\n+done so. Concretely, this means that if you have some query `foo(D)`\n+that wants to access the result of `mir_const(D)` or\n+`mir_validated(D)`, you need to have the successor pass either \"force\"\n+`foo(D)` using `ty::queries::foo::force(...)`. This will force a query\n+to execute even though you don't directly require its result.\n+\n+As an example, consider MIR const qualification. It wants to read the\n+result produced by the `mir_const()` suite. However, that result will\n+be **stolen** by the `mir_validated()` suite. If nothing was done,\n+then `mir_const_qualif(D)` would succeed if it came before\n+`mir_validated(D)`, but fail otherwise. Therefore, `mir_validated(D)`\n+will **force** `mir_const_qualif` before it actually steals, thus\n+ensuring that the reads have already happened:\n+\n+```\n+mir_const(D) --read-by--> mir_const_qualif(D)\n+     |                       ^\n+  stolen-by                  |\n+     |                    (forces)\n+     v                       |\n+mir_validated(D) ------------+\n+```\n+\n+### Implementing and registering a pass\n+\n+To create a new MIR pass, you simply implement the `MirPass` trait for\n+some fresh singleton type `Foo`. Once you have implemented a trait for\n+your type `Foo`, you then have to insert `Foo` into one of the suites;\n+this is done in `librustc_driver/driver.rs` by invoking `push_pass(S,\n+Foo)` with the appropriate suite substituted for `S`.\n+"}, {"sha": "b517ebabbe767622e9b4ab7e1b1e099a328bf3f1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! MIR datatypes and passes. See [the README](README.md) for details.\n+\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};"}, {"sha": "aa91123ef6952ac044781b2aac0369725292fd5e", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 90, "deletions": 97, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n+//! See [the README](README.md) for details on writing your own pass.\n+\n use hir;\n+use hir::def_id::DefId;\n use hir::map::DefPathData;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n+use std::rc::Rc;\n use syntax::ast::NodeId;\n-use util::common::time;\n \n use std::borrow::Cow;\n-use std::fmt;\n \n /// Where a specific Mir comes from.\n #[derive(Debug, Copy, Clone)]\n@@ -36,6 +37,11 @@ pub enum MirSource {\n }\n \n impl<'a, 'tcx> MirSource {\n+    pub fn from_local_def_id(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> MirSource {\n+        let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n+        Self::from_node(tcx, id)\n+    }\n+\n     pub fn from_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> MirSource {\n         use hir::*;\n \n@@ -70,124 +76,111 @@ impl<'a, 'tcx> MirSource {\n     }\n }\n \n-/// Various information about pass.\n-pub trait Pass {\n-    // fn should_run(Session) to check if pass should run?\n-    fn name<'a>(&self) -> Cow<'static, str> {\n-        let name = unsafe { ::std::intrinsics::type_name::<Self>() };\n-        if let Some(tail) = name.rfind(\":\") {\n-            Cow::from(&name[tail+1..])\n-        } else {\n-            Cow::from(name)\n-        }\n+/// Generates a default name for the pass based on the name of the\n+/// type `T`.\n+pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n+    let name = unsafe { ::std::intrinsics::type_name::<T>() };\n+    if let Some(tail) = name.rfind(\":\") {\n+        Cow::from(&name[tail+1..])\n+    } else {\n+        Cow::from(name)\n     }\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n }\n \n-/// A pass which inspects the whole Mir map.\n-pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        hooks: &mut [Box<for<'s> MirPassHook<'s>>]);\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirSuite(pub usize);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirPassIndex(pub usize);\n+\n+/// A pass hook is invoked both before and after each pass executes.\n+/// This is primarily used to dump MIR for debugging.\n+///\n+/// You can tell whether this is before or after by inspecting the\n+/// `mir` parameter -- before the pass executes, it will be `None` (in\n+/// which case you can inspect the MIR from previous pass by executing\n+/// `mir_cx.read_previous_mir()`); after the pass executes, it will be\n+/// `Some()` with the result of the pass (in which case the output\n+/// from the previous pass is most likely stolen, so you would not\n+/// want to try and access it). If the pass is interprocedural, then\n+/// the hook will be invoked once per output.\n+pub trait PassHook {\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool);\n }\n \n-pub trait MirPassHook<'tcx>: Pass {\n-    fn on_mir_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource,\n-        mir: &Mir<'tcx>,\n-        pass: &Pass,\n-        is_after: bool\n-    );\n-}\n-\n-/// A pass which inspects Mir of functions in isolation.\n-pub trait MirPass<'tcx>: Pass {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>);\n-}\n-\n-impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n-    {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for def_id in def_ids {\n-            if !def_id.is_local() {\n-                continue;\n-            }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n-            }\n-            MirPass::run_pass(self, tcx, src, mir);\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n-            }\n+/// The full suite of types that identifies a particular\n+/// application of a pass to a def-id.\n+pub type PassId = (MirSuite, MirPassIndex, DefId);\n \n-            for (i, mir) in mir.promoted.iter_enumerated_mut() {\n-                let src = MirSource::Promoted(id, i);\n-                for hook in &mut *hooks {\n-                    hook.on_mir_pass(tcx, src, mir, self, false);\n-                }\n-                MirPass::run_pass(self, tcx, src, mir);\n-                for hook in &mut *hooks {\n-                    hook.on_mir_pass(tcx, src, mir, self, true);\n-                }\n-            }\n-        }\n+/// A streamlined trait that you can implement to create a pass; the\n+/// pass will be named after the type, and it will consist of a main\n+/// loop that goes over each available MIR and applies `run_pass`.\n+pub trait MirPass {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        default_name::<Self>()\n     }\n+\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>);\n }\n \n /// A manager for MIR passes.\n+///\n+/// FIXME(#41712) -- it is unclear whether we should have this struct.\n+#[derive(Clone)]\n pub struct Passes {\n-    passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>,\n-    pass_hooks: Vec<Box<for<'tcx> MirPassHook<'tcx>>>,\n-    plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n+    pass_hooks: Vec<Rc<PassHook>>,\n+    suites: Vec<Vec<Rc<MirPass>>>,\n }\n \n+/// The number of \"pass suites\" that we have:\n+///\n+/// - ready for constant evaluation\n+/// - unopt\n+/// - optimized\n+pub const MIR_SUITES: usize = 3;\n+\n+/// Run the passes we need to do constant qualification and evaluation.\n+pub const MIR_CONST: MirSuite = MirSuite(0);\n+\n+/// Run the passes we need to consider the MIR validated and ready for borrowck etc.\n+pub const MIR_VALIDATED: MirSuite = MirSuite(1);\n+\n+/// Run the passes we need to consider the MIR *optimized*.\n+pub const MIR_OPTIMIZED: MirSuite = MirSuite(2);\n+\n impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n-        let passes = Passes {\n-            passes: Vec::new(),\n+        Passes {\n             pass_hooks: Vec::new(),\n-            plugin_passes: Vec::new()\n-        };\n-        passes\n-    }\n-\n-    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        let Passes { ref mut passes, ref mut plugin_passes, ref mut pass_hooks } = *self;\n-        for pass in plugin_passes.iter_mut().chain(passes.iter_mut()) {\n-            time(tcx.sess.time_passes(), &*pass.name(),\n-                 || pass.run_pass(tcx, pass_hooks));\n+            suites: (0..MIR_SUITES).map(|_| Vec::new()).collect(),\n         }\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass(&mut self, pass: Box<for<'b> MirMapPass<'b>>) {\n-        self.passes.push(pass);\n+    pub fn push_pass<T: MirPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n+        self.suites[suite.0].push(Rc::new(pass));\n     }\n \n     /// Pushes a pass hook.\n-    pub fn push_hook(&mut self, hook: Box<for<'b> MirPassHook<'b>>) {\n-        self.pass_hooks.push(hook);\n+    pub fn push_hook<T: PassHook + 'static>(&mut self, hook: T) {\n+        self.pass_hooks.push(Rc::new(hook));\n+    }\n+\n+    pub fn passes(&self, suite: MirSuite) -> &[Rc<MirPass>] {\n+        &self.suites[suite.0]\n     }\n-}\n \n-/// Copies the plugin passes.\n-impl ::std::iter::Extend<Box<for<'a> MirMapPass<'a>>> for Passes {\n-    fn extend<I: IntoIterator<Item=Box<for <'a> MirMapPass<'a>>>>(&mut self, it: I) {\n-        self.plugin_passes.extend(it);\n+    pub fn hooks(&self) -> &[Rc<PassHook>] {\n+        &self.pass_hooks\n     }\n }"}, {"sha": "fdfcd83d5b43545bf67c1026a2b1ff1aaa4e5f54", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -1003,6 +1003,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n+    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n+          \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "ec3eaa124c3078a253f804317843f0451aa16dda", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -21,7 +21,6 @@ use session::config::DebugInfoLevel;\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n-use mir::transform as mir_pass;\n \n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n@@ -85,7 +84,6 @@ pub struct Session {\n     /// redundantly verbose output (Issue #24690).\n     pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n-    pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n@@ -670,7 +668,6 @@ pub fn build_session_(sopts: config::Options,\n         lints: RefCell::new(lint::LintTable::new()),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n-        mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),"}, {"sha": "08807d0ced01e62de14fba310dda0a7612e738a6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -25,6 +25,7 @@ use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n+use mir::transform::Passes;\n use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use traits;\n@@ -39,6 +40,7 @@ use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n+use ty::steal::Steal;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -47,11 +49,12 @@ use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n+use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n use std::iter;\n-use std::cmp::Ordering;\n+use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -68,7 +71,8 @@ pub struct GlobalArenas<'tcx> {\n     generics: TypedArena<ty::Generics>,\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n-    mir: TypedArena<RefCell<Mir<'tcx>>>,\n+    steal_mir: TypedArena<Steal<Mir<'tcx>>>,\n+    mir: TypedArena<Mir<'tcx>>,\n     tables: TypedArena<ty::TypeckTables<'tcx>>,\n }\n \n@@ -79,6 +83,7 @@ impl<'tcx> GlobalArenas<'tcx> {\n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n+            steal_mir: TypedArena::new(),\n             mir: TypedArena::new(),\n             tables: TypedArena::new(),\n         }\n@@ -443,8 +448,11 @@ pub struct GlobalCtxt<'tcx> {\n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n     pub hir: hir_map::Map<'tcx>,\n+\n     pub maps: maps::Maps<'tcx>,\n \n+    pub mir_passes: Rc<Passes>,\n+\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n@@ -619,8 +627,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.generics.alloc(generics)\n     }\n \n-    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx RefCell<Mir<'gcx>> {\n-        self.global_arenas.mir.alloc(RefCell::new(mir))\n+    pub fn alloc_steal_mir(self, mir: Mir<'gcx>) -> &'gcx Steal<Mir<'gcx>> {\n+        self.global_arenas.steal_mir.alloc(Steal::new(mir))\n+    }\n+\n+    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx Mir<'gcx> {\n+        self.global_arenas.mir.alloc(mir)\n     }\n \n     pub fn alloc_tables(self, tables: ty::TypeckTables<'gcx>) -> &'gcx ty::TypeckTables<'gcx> {\n@@ -714,6 +726,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   local_providers: ty::maps::Providers<'tcx>,\n                                   extern_providers: ty::maps::Providers<'tcx>,\n+                                  mir_passes: Rc<Passes>,\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n@@ -748,6 +761,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n             maps: maps::Maps::new(dep_graph, providers),\n+            mir_passes,\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),"}, {"sha": "66df8dc050a245f5ee85081060dae82612821b0d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 207, "deletions": 26, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -16,22 +16,27 @@ use middle::const_val;\n use middle::privacy::AccessLevels;\n use middle::region::RegionMaps;\n use mir;\n+use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n+use ty::steal::Steal;\n use ty::subst::Substs;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax::attr;\n use syntax::symbol::Symbol;\n \n-trait Key {\n+pub trait Key: Clone + Hash + Eq + Debug {\n     fn map_crate(&self) -> CrateNum;\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n@@ -101,6 +106,24 @@ impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     }\n }\n \n+impl Key for (MirSuite, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, MirPassIndex, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.2.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.2.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -270,8 +293,13 @@ impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n \n impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n     fn describe(tcx: TyCtxt, (def_id, _): (DefId, &'tcx Substs<'tcx>)) -> String {\n-        format!(\"const-evaluating `{}`\",\n-                tcx.item_path_str(def_id))\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"getting a list of all mir_keys\")\n     }\n }\n \n@@ -293,6 +321,19 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> QueryDescription for queries::stability<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"stability\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::deprecation<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"deprecation\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n@@ -306,7 +347,7 @@ impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'t\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_item_mir_available<'tcx> {\n+impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is mir available: `{}`\",\n             tcx.item_path_str(def_id))\n@@ -316,11 +357,10 @@ impl<'tcx> QueryDescription for queries::is_item_mir_available<'tcx> {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       [$($pub:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n-        pub struct Maps<$tcx> {\n-            providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n+       [$($modifiers:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n         impl<$tcx> Maps<$tcx> {\n@@ -400,7 +440,7 @@ macro_rules! define_maps {\n                     provider(tcx.global_tcx(), key)\n                 })?;\n \n-                Ok(f(&tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n+                Ok(f(tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n@@ -461,25 +501,153 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $V),*\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n+            output: ()\n         }\n \n         impl<$tcx> Copy for Providers<$tcx> {}\n         impl<$tcx> Clone for Providers<$tcx> {\n             fn clone(&self) -> Self { *self }\n         }\n+    }\n+}\n+\n+macro_rules! define_map_struct {\n+    // Initial state\n+    (tcx: $tcx:tt,\n+     input: $input:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final output\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($($output:tt)*)) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n+            $($output)*\n+        }\n+    };\n+\n+    // Field recognized and ready to shift into the output\n+    (tcx: $tcx:tt,\n+     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)*\n+                     $(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>,)\n+        }\n+    };\n+\n+    // Detect things with the `pub` modifier\n+    (tcx: $tcx:tt,\n+     input: (([pub $($other_modifiers:tt)*] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([pub] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // No modifiers left? This is a private item.\n+    (tcx: $tcx:tt,\n+     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([pub] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip other modifiers\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}\n+\n+macro_rules! define_provider_struct {\n+    // Initial state:\n+    (tcx: $tcx:tt, input: $input:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final state:\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+        }\n \n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $V {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n                     bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n                 Providers { $($name),* }\n             }\n         }\n-    }\n+    };\n+\n+    // Something ready to shift:\n+    (tcx: $tcx:tt,\n+     ready: ($name:tt $K:tt $V:tt),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)* ($name $K $V))\n+        }\n+    };\n+\n+    // Regular queries produce a `V` only.\n+    (tcx: $tcx:tt,\n+     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            ready: ($name $K $V),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip modifiers.\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n }\n \n // Each of these maps also corresponds to a method on a\n@@ -537,20 +705,28 @@ define_maps! { <'tcx>\n     /// Methods in these implementations don't need to be exported.\n     [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n-    /// Maps from the def-id of a function/method or const/static\n-    /// to its MIR. Mutation is done at an item granularity to\n-    /// allow MIR optimization passes to function and still\n-    /// access cross-crate MIR (e.g. inlining or const eval).\n-    ///\n-    /// Note that cross-crate MIR appears to be always borrowed\n-    /// (in the `RefCell` sense) to prevent accidental mutation.\n-    [pub] mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    /// Set of all the def-ids in this crate that have MIR associated with\n+    /// them. This includes all the body owners, but also things like struct\n+    /// constructors.\n+    [] mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n     [] mir_const_qualif: Mir(DefId) -> u8,\n \n+    /// Fetch the MIR for a given def-id up till the point where it is\n+    /// ready for const evaluation.\n+    ///\n+    /// See the README for the `mir` module for details.\n+    [] mir_const: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    [] mir_validated: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    /// MIR after our optimization passes have run. This is MIR that is ready\n+    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n+    [] optimized_mir: Mir(DefId) -> &'tcx mir::Mir<'tcx>,\n+\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n@@ -598,17 +774,18 @@ define_maps! { <'tcx>\n     /// fn item.\n     [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n \n-    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n \n     [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n     [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n \n     [] describe_def: DescribeDef(DefId) -> Option<Def>,\n     [] def_span: DefSpan(DefId) -> Span,\n-\n+    [] stability: Stability(DefId) -> Option<attr::Stability>,\n+    [] deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n     [] item_body_nested_bodies: metadata_dep_node(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n     [] const_is_rvalue_promotable_to_static: metadata_dep_node(DefId) -> bool,\n-    [] is_item_mir_available: metadata_dep_node(DefId) -> bool,\n+    [] is_mir_available: metadata_dep_node(DefId) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -644,3 +821,7 @@ fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n     DepNode::ConstEval(def_id)\n }\n+\n+fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::MirKeys\n+}"}, {"sha": "55466b1f36dac513c687a61708e0d3ef38d6e81a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -35,7 +35,7 @@ use util::common::ErrorReported;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::collections::BTreeMap;\n use std::cmp;\n use std::fmt;\n@@ -96,6 +96,7 @@ pub mod _match;\n pub mod maps;\n pub mod outlives;\n pub mod relate;\n+pub mod steal;\n pub mod subst;\n pub mod trait_def;\n pub mod walk;\n@@ -2049,6 +2050,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.typeck_tables_of(self.hir.body_owner_def_id(body))\n     }\n \n+    /// Returns an iterator of the def-ids for all body-owners in this\n+    /// crate. If you would prefer to iterate over the bodies\n+    /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n+    pub fn body_owners(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.hir.krate()\n+                .body_ids\n+                .iter()\n+                .map(move |&body_id| self.hir.body_owner_def_id(body_id))\n+    }\n+\n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n             Some(hir_map::NodeExpr(e)) => {\n@@ -2313,33 +2324,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given the did of an item, returns its MIR, borrowed immutably.\n-    pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        self.mir(did).borrow()\n-    }\n-\n     /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n-                        -> Ref<'gcx, Mir<'gcx>>\n+                        -> &'gcx Mir<'gcx>\n     {\n         match instance {\n-            ty::InstanceDef::Item(did) if true => self.item_mir(did),\n-            _ => self.mir_shims(instance).borrow(),\n+            ty::InstanceDef::Item(did) => {\n+                self.optimized_mir(did)\n+            }\n+            ty::InstanceDef::Intrinsic(..) |\n+            ty::InstanceDef::FnPtrShim(..) |\n+            ty::InstanceDef::Virtual(..) |\n+            ty::InstanceDef::ClosureOnceShim { .. } |\n+            ty::InstanceDef::DropGlue(..) => {\n+                self.mir_shims(instance)\n+            }\n         }\n     }\n \n     /// Given the DefId of an item, returns its MIR, borrowed immutably.\n     /// Returns None if there is no MIR for the DefId\n-    pub fn maybe_item_mir(self, did: DefId) -> Option<Ref<'gcx, Mir<'gcx>>> {\n-        if did.is_local() && !self.maps.mir.borrow().contains_key(&did) {\n-            return None;\n-        }\n-\n-        if !did.is_local() && !self.is_item_mir_available(did) {\n-            return None;\n+    pub fn maybe_optimized_mir(self, did: DefId) -> Option<&'gcx Mir<'gcx>> {\n+        if self.is_mir_available(did) {\n+            Some(self.optimized_mir(did))\n+        } else {\n+            None\n         }\n-\n-        Some(self.item_mir(did))\n     }\n \n     /// Get the attributes of a definition.\n@@ -2541,17 +2551,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n-    /// Invokes `callback` for each body in the krate. This will\n-    /// create a read edge from `DepNode::Krate` to the current task;\n-    /// it is meant to be run in the context of some global task like\n-    /// `BorrowckCrate`. The callback would then create a task like\n-    /// `BorrowckBody(DefId)` to process each individual item.\n-    pub fn visit_all_bodies_in_krate<C>(self, callback: C)\n-        where C: Fn(/* body_owner */ DefId, /* body id */ hir::BodyId),\n-    {\n-        dep_graph::visit_all_bodies_in_krate(self.global_tcx(), callback)\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "0b0818888812f1700db4c8d4caf8b115b1e1ba3d", "filename": "src/librustc/ty/steal.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::{Ref, RefCell};\n+use std::mem;\n+\n+/// The `Steal` struct is intended to used as the value for a query.\n+/// Specifically, we sometimes have queries (*cough* MIR *cough*)\n+/// where we create a large, complex value that we want to iteratively\n+/// update (e.g., optimize). We could clone the value for each\n+/// optimization, but that'd be expensive. And yet we don't just want\n+/// to mutate it in place, because that would spoil the idea that\n+/// queries are these pure functions that produce an immutable value\n+/// (since if you did the query twice, you could observe the\n+/// mutations). So instead we have the query produce a `&'tcx\n+/// Steal<Mir<'tcx>>` (to be very specific). Now we can read from this\n+/// as much as we want (using `borrow()`), but you can also\n+/// `steal()`. Once you steal, any further attempt to read will panic.\n+/// Therefore we know that -- assuming no ICE -- nobody is observing\n+/// the fact that the MIR was updated.\n+///\n+/// Obviously, whenever you have a query that yields a `Steal` value,\n+/// you must treat it with caution, and make sure that you know that\n+/// -- once the value is stolen -- it will never be read from again.\n+///\n+/// FIXME(#41710) -- what is the best way to model linear queries?\n+pub struct Steal<T> {\n+    value: RefCell<Option<T>>\n+}\n+\n+impl<T> Steal<T> {\n+    pub fn new(value: T) -> Self {\n+        Steal {\n+            value: RefCell::new(Some(value))\n+        }\n+    }\n+\n+    pub fn borrow(&self) -> Ref<T> {\n+        Ref::map(self.value.borrow(), |opt| match *opt {\n+            None => bug!(\"attempted to read from stolen value\"),\n+            Some(ref v) => v\n+        })\n+    }\n+\n+    pub fn steal(&self) -> T {\n+        let value_ref = &mut *self.value.borrow_mut();\n+        let value = mem::replace(value_ref, None);\n+        value.expect(\"attempt to read from stolen value\")\n+    }\n+}"}, {"sha": "6bfe90af2ca167e398cf64f3a660f1139e6616c2", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -13,7 +13,8 @@ use target::{Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n-    base.features = \"+v7,+vfp3,+d16\".to_string();\n+    // https://developer.android.com/ndk/guides/abis.html#armeabi\n+    base.features = \"+v5te\".to_string();\n     base.max_atomic_width = Some(64);\n \n     Ok(Target {"}, {"sha": "b49b1d1c2138ab43179f9db651dbaaed2ecccefd", "filename": "src/librustc_back/target/armv7_linux_androideabi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -18,6 +18,8 @@ pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7,+thumb2,+vfp3,+d16,-neon\".to_string();\n     base.max_atomic_width = Some(64);\n+    base.pre_link_args\n+        .get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-march=armv7-a\".to_string());\n \n     Ok(Target {\n         llvm_target: \"armv7-none-linux-android\".to_string(),"}, {"sha": "b7ce9d982331c92a80b8e61c1154ece340dcf824", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -73,9 +73,16 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n         let mut err = report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n         match error.move_to_places.get(0) {\n-            Some(&MovePlace { pat_source: PatternSource::LetDecl(_), .. }) => {\n+            Some(&MovePlace { pat_source: PatternSource::LetDecl(ref e), .. }) => {\n                 // ignore patterns that are found at the top-level of a `let`;\n                 // see `get_pattern_source()` for details\n+                let initializer =\n+                    e.init.as_ref().expect(\"should have an initializer to get an error\");\n+                if let Ok(snippet) = bccx.tcx.sess.codemap().span_to_snippet(initializer.span) {\n+                    err.span_suggestion(initializer.span,\n+                                        \"consider using a reference instead\",\n+                                        format!(\"&{}\", snippet));\n+                }\n             }\n             _ => {\n                 for move_to in &error.move_to_places {"}, {"sha": "4ae8bdc284b226760c17ddcd924f71e715679711", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_lookup_result_bits};\n use super::MoveDataParamEnv;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -32,9 +32,11 @@ use std::u32;\n \n pub struct ElaborateDrops;\n \n-impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>)\n+impl MirPass for ElaborateDrops {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n         match src {\n@@ -74,8 +76,6 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n     }\n }\n \n-impl Pass for ElaborateDrops {}\n-\n /// Return the set of basic blocks whose unwind edges are known\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything."}, {"sha": "47f708bf58367215e64ba9b9e25e0a57f1425471", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -61,7 +61,10 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     let def_id = tcx.hir.local_def_id(id);\n     debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n \n-    let mir = &tcx.item_mir(def_id);\n+    // It is safe for us to borrow `mir_validated()`: `optimized_mir`\n+    // steals it, but it forces the `borrowck` query.\n+    let mir = &tcx.mir_validated(def_id).borrow();\n+\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };"}, {"sha": "f8073455bd08ad422077ffd583228274fa7aa002", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -63,9 +63,9 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+    for body_owner_def_id in tcx.body_owners() {\n         tcx.borrowck(body_owner_def_id);\n-    });\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -86,6 +86,19 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n+\n+    match tcx.hir.get(owner_id) {\n+        hir_map::NodeStructCtor(_) |\n+        hir_map::NodeVariant(_) => {\n+            // We get invoked with anything that has MIR, but some of\n+            // those things (notably the synthesized constructors from\n+            // tuple structs/variants) do not have an associated body\n+            // and do not need borrowchecking.\n+            return;\n+        }\n+        _ => { }\n+    }\n+\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n@@ -96,6 +109,16 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n \n     if bccx.tcx.has_attr(owner_def_id, \"rustc_mir_borrowck\") {\n         mir::borrowck_mir(bccx, owner_id, &attributes);\n+    } else {\n+        // Eventually, borrowck will always read the MIR, but at the\n+        // moment we do not. So, for now, we always force MIR to be\n+        // constructed for a given fn, since this may result in errors\n+        // being reported and we want that to happen.\n+        //\n+        // Note that `mir_validated` is a \"stealable\" result; the\n+        // thief, `optimized_mir()`, forces borrowck, so we know that\n+        // is not yet stolen.\n+        tcx.mir_validated(owner_def_id).borrow();\n     }\n \n     let cfg = cfg::CFG::new(bccx.tcx, &body);"}, {"sha": "9f0f567b6cee1b5519db89074683098de89e1d4a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -20,6 +20,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n+use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n@@ -35,8 +36,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts,\n-                   static_recursion, hir_stats, mir_stats};\n+use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n \n@@ -903,9 +903,44 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);\n \n+    // Setup the MIR passes that we want to run.\n+    let mut passes = Passes::new();\n+    passes.push_hook(mir::transform::dump_mir::DumpMir);\n+\n+    // What we need to do constant evaluation.\n+    passes.push_pass(MIR_CONST, mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n+    passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n+\n+    // What we need to run borrowck etc.\n+    passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+    passes.push_pass(MIR_VALIDATED,\n+                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n+    passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n+\n+    // Optimizations begin.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n+\n+    // From here on out, regions are gone.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, borrowck::ElaborateDrops);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n+\n+    // No lifetime analysis based on borrowing can be done from here on out.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::instcombine::InstCombine);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyLocals);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n+\n     TyCtxt::create_and_enter(sess,\n                              local_providers,\n                              extern_providers,\n+                             Rc::new(passes),\n                              arenas,\n                              arena,\n                              resolutions,\n@@ -962,30 +997,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"liveness checking\",\n              || middle::liveness::check_crate(tcx));\n \n-        time(time_passes,\n-             \"MIR dump\",\n-             || mir::mir_map::build_mir_for_crate(tcx));\n-\n-        if sess.opts.debugging_opts.mir_stats {\n-            mir_stats::print_mir_stats(tcx, \"PRE CLEANUP MIR STATS\");\n-        }\n-\n-        time(time_passes, \"MIR cleanup and validation\", || {\n-            let mut passes = sess.mir_passes.borrow_mut();\n-            // Push all the built-in validation passes.\n-            // NB: if you\u2019re adding an *optimisation* it ought to go to another set of passes\n-            // in stage 4 below.\n-            passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::type_check::TypeckMir);\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n-            passes.push_pass(\n-                box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n-            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n-            // And run everything.\n-            passes.run_passes(tcx);\n-        });\n-\n         time(time_passes,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n@@ -1034,43 +1045,6 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"PRE OPTIMISATION MIR STATS\");\n-    }\n-\n-    // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n-    // code.\n-    time(time_passes, \"MIR optimisations\", || {\n-        let mut passes = ::rustc::mir::transform::Passes::new();\n-        passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n-\n-        // From here on out, regions are gone.\n-        passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n-\n-        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n-        passes.push_pass(box borrowck::ElaborateDrops);\n-        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n-\n-        // No lifetime analysis based on borrowing can be done from here on out.\n-        passes.push_pass(box mir::transform::inline::Inline);\n-        passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n-        passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n-        passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n-\n-        passes.push_pass(box mir::transform::simplify::SimplifyLocals);\n-        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n-        passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n-\n-        passes.run_passes(tcx);\n-    });\n-\n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"POST OPTIMISATION MIR STATS\");\n-    }\n-\n     let translation =\n         time(time_passes,\n              \"translation\","}, {"sha": "d40a2ab0b530986128ee893f4de3d3e985167054", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -41,7 +41,6 @@ use graphviz as dot;\n use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n-use std::iter;\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n@@ -999,22 +998,14 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 if let Some(nodeid) = nodeid {\n                     let def_id = tcx.hir.local_def_id(nodeid);\n                     match ppm {\n-                        PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n+                        PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 } else {\n                     match ppm {\n-                        PpmMir => {\n-                            write_mir_pretty(tcx,\n-                                             tcx.maps.mir.borrow().keys().into_iter(),\n-                                             &mut out)\n-                        }\n-                        PpmMirCFG => {\n-                            write_mir_graphviz(tcx,\n-                                               tcx.maps.mir.borrow().keys().into_iter(),\n-                                               &mut out)\n-                        }\n+                        PpmMir => write_mir_pretty(tcx, None, &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 }"}, {"sha": "8b95be00fa752cb50bf6c90b00641aff783579e4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -27,6 +27,7 @@ use rustc::infer::{self, InferOk, InferResult};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n+use rustc::mir::transform::Passes;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::ast;\n@@ -141,6 +142,7 @@ fn test_env<F>(source_string: &str,\n     TyCtxt::create_and_enter(&sess,\n                              ty::maps::Providers::default(),\n                              ty::maps::Providers::default(),\n+                             Rc::new(Passes::new()),\n                              &arenas,\n                              &arena,\n                              resolutions,"}, {"sha": "a1794ec2d82cace665364da1860a24d09c90c9bb", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -30,7 +30,6 @@ use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n use std::any::Any;\n-use std::mem;\n use std::rc::Rc;\n \n use syntax::ast;\n@@ -95,16 +94,13 @@ provide! { <'tcx> tcx, def_id, cdata\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    mir => {\n-        let mir = cdata.maybe_get_item_mir(tcx, def_id.index).unwrap_or_else(|| {\n-            bug!(\"get_item_mir: missing MIR for `{:?}`\", def_id)\n+    optimized_mir => {\n+        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n+            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n         });\n \n         let mir = tcx.alloc_mir(mir);\n \n-        // Perma-borrow MIR from extern crates to prevent mutation.\n-        mem::forget(mir.borrow());\n-\n         mir\n     }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n@@ -115,6 +111,8 @@ provide! { <'tcx> tcx, def_id, cdata\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n+    stability => { cdata.get_stability(def_id.index) }\n+    deprecation => { cdata.get_deprecation(def_id.index) }\n     item_body_nested_bodies => {\n         let map: BTreeMap<_, _> = cdata.entry(def_id.index).ast.into_iter().flat_map(|ast| {\n             ast.decode(cdata).nested_bodies.decode(cdata).map(|body| (body.id(), body))\n@@ -126,7 +124,7 @@ provide! { <'tcx> tcx, def_id, cdata\n         cdata.entry(def_id.index).ast.expect(\"const item missing `ast`\")\n             .decode(cdata).rvalue_promotable_to_static\n     }\n-    is_item_mir_available => {\n+    is_mir_available => {\n         !cdata.is_proc_macro(def_id.index) &&\n         cdata.maybe_entry(def_id.index).and_then(|item| item.decode(cdata).mir).is_some()\n     }\n@@ -137,16 +135,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(krate)\n     }\n \n-    fn stability(&self, def: DefId) -> Option<attr::Stability> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_stability(def.index)\n-    }\n-\n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_deprecation(def.index)\n-    }\n-\n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_visibility(def.index)"}, {"sha": "ae755adcf5fbbe8bb92b76fc9fa7ad9144371b2d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -779,10 +779,10 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_tables(ast.tables.decode((self, tcx)))\n     }\n \n-    pub fn maybe_get_item_mir(&self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: DefIndex)\n-                              -> Option<Mir<'tcx>> {\n+    pub fn maybe_get_optimized_mir(&self,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   id: DefIndex)\n+                                   -> Option<Mir<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),"}, {"sha": "125026b799c98e3bdeef935d5d0c5277d1c6cb22", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -433,7 +433,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -528,7 +528,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -598,7 +598,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: ast.map(|body| self.encode_body(body)),\n-            mir: if mir { self.encode_mir(def_id) } else { None },\n+            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n         }\n     }\n \n@@ -619,9 +619,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         self.lazy_seq(names.iter().map(|name| name.node))\n     }\n \n-    fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n-        self.tcx.maps.mir.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n+        if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n+            let mir = self.tcx.optimized_mir(def_id);\n+            Some(self.lazy(&mir))\n+        } else {\n+            None\n+        }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n@@ -856,15 +861,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             },\n             mir: match item.node {\n                 hir::ItemStatic(..) if self.tcx.sess.opts.debugging_opts.always_encode_mir => {\n-                    self.encode_mir(def_id)\n+                    self.encode_optimized_mir(def_id)\n                 }\n-                hir::ItemConst(..) => self.encode_mir(def_id),\n+                hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();\n                     let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n-                        self.encode_mir(def_id)\n+                        self.encode_optimized_mir(def_id)\n                     } else {\n                         None\n                     }\n@@ -1161,7 +1166,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: None,\n \n             ast: None,\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n \n@@ -1187,7 +1192,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: Some(self.encode_body(body)),\n-            mir: self.encode_mir(def_id),\n+            mir: self.encode_optimized_mir(def_id),\n         }\n     }\n "}, {"sha": "0d912513c6c765fee1498667f2e1a815287d1055", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -18,7 +18,7 @@ use build::{BlockAnd, Builder};\n use hair::*;\n use rustc::mir::*;\n \n-pub trait EvalInto<'tcx> {\n+pub(in build) trait EvalInto<'tcx> {\n     fn eval_into<'a, 'gcx>(self,\n                            builder: &mut Builder<'a, 'gcx, 'tcx>,\n                            destination: &Lvalue<'tcx>,"}, {"sha": "8c057b02df2bf35c07c81dd550669a2ecbd82227", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 215, "deletions": 14, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -8,24 +8,225 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+use build;\n use hair::cx::Cx;\n use hair::Pattern;\n-\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{self, Ty};\n use rustc::mir::*;\n+use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::MutVisitor;\n+use rustc::traits::Reveal;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n-use rustc::hir;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use shim;\n+use std::mem;\n+use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n+use util as mir_util;\n \n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+/// Construct the MIR for a given def-id.\n+pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let unsupported = || {\n+        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n+    };\n \n-use std::u32;\n+    // Figure out what primary body this item has.\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _) => body,\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        hir::map::NodeVariant(variant) =>\n+            return create_constructor_shim(tcx, id, &variant.node.data),\n+        hir::map::NodeStructCtor(ctor) =>\n+            return create_constructor_shim(tcx, id, ctor),\n+        _ => unsupported()\n+    };\n+\n+    let src = MirSource::from_node(tcx, id);\n+    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n+        let cx = Cx::new(&infcx, src);\n+        let mut mir = if cx.tables().tainted_by_errors {\n+            build::construct_error(cx, body_id)\n+        } else if let MirSource::Fn(id) = src {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n+            let mut abi = fn_sig.abi;\n+            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n+                // HACK(eddyb) Avoid having RustCall on closures,\n+                // as it adds unnecessary (and wrong) auto-tupling.\n+                abi = Abi::Rust;\n+                Some((closure_self_ty(tcx, id, body_id), None))\n+            } else {\n+                None\n+            };\n+\n+            let body = tcx.hir.body(body_id);\n+            let explicit_arguments =\n+                body.arguments\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, arg)| {\n+                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                    });\n+\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+        } else {\n+            build::construct_const(cx, body_id)\n+        };\n+\n+        // Convert the Mir to global types.\n+        let mut globalizer = GlobalizeMir {\n+            tcx: tcx,\n+            span: mir.span\n+        };\n+        globalizer.visit_mir(&mut mir);\n+        let mir = unsafe {\n+            mem::transmute::<Mir, Mir<'tcx>>(mir)\n+        };\n+\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+        mir\n+    })\n+}\n+\n+/// A pass to lift all the types and substitutions in a Mir\n+/// to the global tcx. Sadly, we don't have a \"folder\" that\n+/// can change 'tcx so we have to transmute afterwards.\n+struct GlobalizeMir<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(ty) {\n+            *ty = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found type `{:?}` with inference types/regions in MIR\",\n+                      ty);\n+        }\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(substs) {\n+            *substs = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found substs `{:?}` with inference types/regions in MIR\",\n+                      substs);\n+        }\n+    }\n+}\n+\n+fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     ctor_id: ast::NodeId,\n+                                     v: &'tcx hir::VariantData)\n+                                     -> Mir<'tcx>\n+{\n+    let span = tcx.hir.span(ctor_id);\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n+        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+            let (mut mir, src) =\n+                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n+\n+            // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n+            let mut globalizer = GlobalizeMir {\n+                tcx: tcx,\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n+            };\n+\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+            mir\n+        })\n+    } else {\n+        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n+\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             closure_expr_id: ast::NodeId,\n+                             body_id: hir::BodyId)\n+                             -> Ty<'tcx> {\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: Some(tcx.item_extent(body_id.node_id)),\n+        bound_region: ty::BoundRegion::BrEnv,\n+    });\n+    let region = tcx.mk_region(region);\n+\n+    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n+        ty::ClosureKind::Fn =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutImmutable }),\n+        ty::ClosureKind::FnMut =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutMutable }),\n+        ty::ClosureKind::FnOnce =>\n+            closure_ty\n+    }\n+}\n \n-pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n \n@@ -82,7 +283,7 @@ impl Idx for ScopeId {\n /// convenient.\n \n #[must_use] // if you don't use one of these results, you're leaving a dangling edge\n-pub struct BlockAnd<T>(BasicBlock, T);\n+struct BlockAnd<T>(BasicBlock, T);\n \n trait BlockAndExtension {\n     fn and<T>(self, v: T) -> BlockAnd<T>;\n@@ -121,13 +322,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       fn_id: ast::NodeId,\n-                                       arguments: A,\n-                                       abi: Abi,\n-                                       return_ty: Ty<'gcx>,\n-                                       body: &'gcx hir::Body)\n-                                       -> Mir<'tcx>\n+fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                   fn_id: ast::NodeId,\n+                                   arguments: A,\n+                                   abi: Abi,\n+                                   return_ty: Ty<'gcx>,\n+                                   body: &'gcx hir::Body)\n+                                   -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let arguments: Vec<_> = arguments.collect();"}, {"sha": "69416289d8e2682b1d68e8f18a902b866b22f36e", "filename": "src/librustc_mir/callgraph.rs", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,252 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! MIR-based callgraph.\n-//!\n-//! This only considers direct calls\n-\n-use rustc::hir::def_id::DefId;\n-use rustc_data_structures::graph;\n-\n-use rustc::mir::*;\n-use rustc::mir::visit::*;\n-\n-use rustc::ty;\n-\n-use rustc::util::nodemap::DefIdMap;\n-\n-pub struct CallGraph {\n-    node_map: DefIdMap<graph::NodeIndex>,\n-    graph: graph::Graph<DefId, ()>\n-}\n-\n-impl CallGraph {\n-    // FIXME: allow for construction of a callgraph that inspects\n-    // cross-crate MIRs if available.\n-    pub fn build<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> CallGraph {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-\n-        let mut callgraph = CallGraph {\n-            node_map: DefIdMap(),\n-            graph: graph::Graph::new()\n-        };\n-\n-        for def_id in def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let idx = callgraph.add_node(def_id);\n-\n-            let mut call_visitor = CallVisitor {\n-                caller: idx,\n-                graph: &mut callgraph\n-            };\n-\n-            let mir = tcx.item_mir(def_id);\n-            call_visitor.visit_mir(&mir);\n-        }\n-\n-        callgraph\n-    }\n-\n-    // Iterate over the strongly-connected components of the graph\n-    pub fn scc_iter(&self) -> SCCIterator {\n-        SCCIterator::new(&self.graph)\n-    }\n-\n-    // Get the def_id for the given graph node\n-    pub fn def_id(&self, node: graph::NodeIndex) -> DefId {\n-        *self.graph.node_data(node)\n-    }\n-\n-    fn add_node(&mut self, id: DefId) -> graph::NodeIndex {\n-        let graph = &mut self.graph;\n-        *self.node_map.entry(id).or_insert_with(|| {\n-            graph.add_node(id)\n-        })\n-    }\n-}\n-\n-struct CallVisitor<'a> {\n-    caller: graph::NodeIndex,\n-    graph: &'a mut CallGraph\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for CallVisitor<'a> {\n-    fn visit_terminator_kind(&mut self, _block: BasicBlock,\n-                             kind: &TerminatorKind<'tcx>, _loc: Location) {\n-        if let TerminatorKind::Call {\n-            func: Operand::Constant(ref f)\n-            , .. } = *kind {\n-            if let ty::TyFnDef(def_id, _, _) = f.ty.sty {\n-                let callee = self.graph.add_node(def_id);\n-                self.graph.graph.add_edge(self.caller, callee, ());\n-            }\n-        }\n-    }\n-}\n-\n-struct StackElement<'g> {\n-    node: graph::NodeIndex,\n-    lowlink: usize,\n-    children: graph::AdjacentTargets<'g, DefId, ()>\n-}\n-\n-/**\n- * Iterator over strongly-connected-components using Tarjan's algorithm[1]\n- *\n- * [1]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n- */\n-pub struct SCCIterator<'g> {\n-    graph: &'g graph::Graph<DefId, ()>,\n-    index: usize,\n-    node_indices: Vec<Option<usize>>,\n-    scc_stack: Vec<graph::NodeIndex>,\n-    current_scc: Vec<graph::NodeIndex>,\n-    visit_stack: Vec<StackElement<'g>>,\n-}\n-\n-impl<'g> SCCIterator<'g> {\n-    pub fn new(graph: &'g graph::Graph<DefId, ()>) -> SCCIterator<'g> {\n-        if graph.len_nodes() == 0 {\n-            return SCCIterator {\n-                graph: graph,\n-                index: 0,\n-                node_indices: Vec::new(),\n-                scc_stack: Vec::new(),\n-                current_scc: Vec::new(),\n-                visit_stack: Vec::new()\n-            };\n-        }\n-\n-        let first = graph::NodeIndex(0);\n-\n-        SCCIterator::with_entry(graph, first)\n-    }\n-\n-    pub fn with_entry(graph: &'g graph::Graph<DefId, ()>,\n-                      entry: graph::NodeIndex) -> SCCIterator<'g> {\n-        let mut iter = SCCIterator {\n-            graph: graph,\n-            index: 0,\n-            node_indices: Vec::with_capacity(graph.len_nodes()),\n-            scc_stack: Vec::new(),\n-            current_scc: Vec::new(),\n-            visit_stack: Vec::new()\n-        };\n-\n-        iter.visit_one(entry);\n-\n-        iter\n-    }\n-\n-    fn get_next(&mut self) {\n-        self.current_scc.clear();\n-\n-        while !self.visit_stack.is_empty() {\n-            self.visit_children();\n-\n-            let node = self.visit_stack.pop().unwrap();\n-\n-            if let Some(last) = self.visit_stack.last_mut() {\n-                if last.lowlink > node.lowlink {\n-                    last.lowlink = node.lowlink;\n-                }\n-            }\n-\n-            debug!(\"TarjanSCC: Popped node {:?} : lowlink = {:?}; index = {:?}\",\n-                   node.node, node.lowlink, self.node_index(node.node).unwrap());\n-\n-            if node.lowlink != self.node_index(node.node).unwrap() {\n-                continue;\n-            }\n-\n-            loop {\n-                let n = self.scc_stack.pop().unwrap();\n-                self.current_scc.push(n);\n-                self.set_node_index(n, !0);\n-                if n == node.node { return; }\n-            }\n-        }\n-    }\n-\n-    fn visit_one(&mut self, node: graph::NodeIndex) {\n-        self.index += 1;\n-        let idx =  self.index;\n-        self.set_node_index(node, idx);\n-        self.scc_stack.push(node);\n-        self.visit_stack.push(StackElement {\n-            node: node,\n-            lowlink: self.index,\n-            children: self.graph.successor_nodes(node)\n-        });\n-        debug!(\"TarjanSCC: Node {:?} : index = {:?}\", node, idx);\n-    }\n-\n-    fn visit_children(&mut self) {\n-        while let Some(child) = self.visit_stack.last_mut().unwrap().children.next() {\n-            if let Some(child_num) = self.node_index(child) {\n-                let cur = self.visit_stack.last_mut().unwrap();\n-                if cur.lowlink > child_num {\n-                    cur.lowlink = child_num;\n-                }\n-            } else {\n-                self.visit_one(child);\n-            }\n-        }\n-    }\n-\n-    fn node_index(&self, node: graph::NodeIndex) -> Option<usize> {\n-        self.node_indices.get(node.node_id()).and_then(|&idx| idx)\n-    }\n-\n-    fn set_node_index(&mut self, node: graph::NodeIndex, idx: usize) {\n-        let i = node.node_id();\n-        if i >= self.node_indices.len() {\n-            self.node_indices.resize(i + 1, None);\n-        }\n-        self.node_indices[i] = Some(idx);\n-    }\n-}\n-\n-impl<'g> Iterator for SCCIterator<'g> {\n-    type Item = Vec<graph::NodeIndex>;\n-\n-    fn next(&mut self) -> Option<Vec<graph::NodeIndex>> {\n-        self.get_next();\n-\n-        if self.current_scc.is_empty() {\n-            // Try a new root for the next SCC, if the node_indices\n-            // map is doesn't contain all nodes, use the smallest one\n-            // with no entry, otherwise find the first empty node.\n-            //\n-            // FIXME: This should probably use a set of precomputed\n-            // roots instead\n-            if self.node_indices.len() < self.graph.len_nodes() {\n-                let idx = graph::NodeIndex(self.node_indices.len());\n-                self.visit_one(idx);\n-            } else {\n-                for idx in 0..self.node_indices.len() {\n-                    if self.node_indices[idx].is_none() {\n-                        let idx = graph::NodeIndex(idx);\n-                        self.visit_one(idx);\n-                        break;\n-                    }\n-                }\n-            }\n-            self.get_next();\n-        }\n-\n-        if self.current_scc.is_empty() {\n-            None\n-        } else {\n-            Some(self.current_scc.clone())\n-        }\n-    }\n-}"}, {"sha": "ee8547e5dd679f9f4694d8e75e6c8d6cdf37a50c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::region::RegionMaps;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n use std::rc::Rc;\n@@ -103,10 +103,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Str(value) }\n-    }\n-\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(true) }\n     }"}, {"sha": "5fa56bac1379be8b120ab0e044d77bd4bee40877", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -46,18 +46,15 @@ extern crate rustc_const_eval;\n \n pub mod diagnostics;\n \n-pub mod build;\n-pub mod callgraph;\n+mod build;\n mod hair;\n mod shim;\n-pub mod mir_map;\n pub mod transform;\n pub mod util;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n-    mir_map::provide(providers);\n     shim::provide(providers);\n-    transform::qualify_consts::provide(providers);\n+    transform::provide(providers);\n }"}, {"sha": "1abae515ae68374ee32c9a6672226f8a7dfdb862", "filename": "src/librustc_mir/mir_map.rs", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0634f0a30f94116ee13c16fb1a35c4c92253ab13/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=0634f0a30f94116ee13c16fb1a35c4c92253ab13", "patch": "@@ -1,273 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An experimental pass that scources for `#[rustc_mir]` attributes,\n-//! builds the resulting MIR, and dumps it out into a file for inspection.\n-//!\n-//! The attribute formats that are currently accepted are:\n-//!\n-//! - `#[rustc_mir(graphviz=\"file.gv\")]`\n-//! - `#[rustc_mir(pretty=\"file.mir\")]`\n-\n-use build;\n-use rustc::hir::def_id::DefId;\n-use rustc::dep_graph::DepNode;\n-use rustc::mir::Mir;\n-use rustc::mir::transform::MirSource;\n-use rustc::mir::visit::MutVisitor;\n-use shim;\n-use hair::cx::Cx;\n-use util as mir_util;\n-\n-use rustc::traits::Reveal;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::maps::Providers;\n-use rustc::ty::subst::Substs;\n-use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use syntax::abi::Abi;\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-use std::cell::RefCell;\n-use std::mem;\n-\n-pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.dep_graph.with_task(DepNode::MirKrate, tcx, (), build_mir_for_crate_task);\n-\n-    fn build_mir_for_crate_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n-        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n-            tcx.item_mir(body_owner_def_id);\n-        });\n-\n-        // Tuple struct/variant constructors don't have a BodyId, so we need\n-        // to build them separately.\n-        struct GatherCtors<'a, 'tcx: 'a> {\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n-            fn visit_variant_data(&mut self,\n-                                  v: &'tcx hir::VariantData,\n-                                  _: ast::Name,\n-                                  _: &'tcx hir::Generics,\n-                                  _: ast::NodeId,\n-                                  _: Span) {\n-                if let hir::VariantData::Tuple(_, node_id) = *v {\n-                    self.tcx.item_mir(self.tcx.hir.local_def_id(node_id));\n-                }\n-                intravisit::walk_struct_def(self, v)\n-            }\n-            fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n-                NestedVisitorMap::None\n-            }\n-        }\n-        tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n-            tcx: tcx\n-        }.as_deep_visitor());\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.mir = build_mir;\n-}\n-\n-fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                       -> &'tcx RefCell<Mir<'tcx>> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let unsupported = || {\n-        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n-    };\n-\n-    // Figure out what primary body this item has.\n-    let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) |\n-                hir::ItemFn(.., body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeTraitItem(item) => {\n-            match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) |\n-                hir::TraitItemKind::Method(_,\n-                    hir::TraitMethod::Provided(body)) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeImplItem(item) => {\n-            match item.node {\n-                hir::ImplItemKind::Const(_, body) |\n-                hir::ImplItemKind::Method(_, body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(_, _, body, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n-            }\n-        }\n-        hir::map::NodeVariant(variant) =>\n-            return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeStructCtor(ctor) =>\n-            return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n-    };\n-\n-    let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-        let cx = Cx::new(&infcx, src);\n-        let mut mir = if cx.tables().tainted_by_errors {\n-            build::construct_error(cx, body_id)\n-        } else if let MirSource::Fn(id) = src {\n-            // fetch the fully liberated fn signature (that is, all bound\n-            // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n-\n-            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n-            let mut abi = fn_sig.abi;\n-            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n-                // HACK(eddyb) Avoid having RustCall on closures,\n-                // as it adds unnecessary (and wrong) auto-tupling.\n-                abi = Abi::Rust;\n-                Some((closure_self_ty(tcx, id, body_id), None))\n-            } else {\n-                None\n-            };\n-\n-            let body = tcx.hir.body(body_id);\n-            let explicit_arguments =\n-                body.arguments\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(index, arg)| {\n-                        (fn_sig.inputs()[index], Some(&*arg.pat))\n-                    });\n-\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n-        } else {\n-            build::construct_const(cx, body_id)\n-        };\n-\n-        // Convert the Mir to global types.\n-        let mut globalizer = GlobalizeMir {\n-            tcx: tcx,\n-            span: mir.span\n-        };\n-        globalizer.visit_mir(&mut mir);\n-        let mir = unsafe {\n-            mem::transmute::<Mir, Mir<'tcx>>(mir)\n-        };\n-\n-        mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-        tcx.alloc_mir(mir)\n-    })\n-}\n-\n-/// A pass to lift all the types and substitutions in a Mir\n-/// to the global tcx. Sadly, we don't have a \"folder\" that\n-/// can change 'tcx so we have to transmute afterwards.\n-struct GlobalizeMir<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    span: Span\n-}\n-\n-impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(ty) {\n-            *ty = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found type `{:?}` with inference types/regions in MIR\",\n-                      ty);\n-        }\n-    }\n-\n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(substs) {\n-            *substs = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found substs `{:?}` with inference types/regions in MIR\",\n-                      substs);\n-        }\n-    }\n-}\n-\n-fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: ast::NodeId,\n-                                     v: &'tcx hir::VariantData)\n-                                     -> &'tcx RefCell<Mir<'tcx>>\n-{\n-    let span = tcx.hir.span(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n-        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n-            let (mut mir, src) =\n-                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n-\n-            // Convert the Mir to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx: tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_mir(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'tcx>>(mir)\n-            };\n-\n-            mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-            tcx.alloc_mir(mir)\n-        })\n-    } else {\n-        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n-\n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             closure_expr_id: ast::NodeId,\n-                             body_id: hir::BodyId)\n-                             -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n-\n-    let region = ty::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.item_extent(body_id.node_id)),\n-        bound_region: ty::BoundRegion::BrEnv,\n-    });\n-    let region = tcx.mk_region(region);\n-\n-    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n-        ty::ClosureKind::Fn =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutImmutable }),\n-        ty::ClosureKind::FnMut =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutMutable }),\n-        ty::ClosureKind::FnOnce =>\n-            closure_ty\n-    }\n-}"}, {"sha": "1458ea7fdd6a29fcd9fb5e9b75c5ddf88bf95337", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -24,10 +24,8 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::iter;\n-use std::mem;\n \n use transform::{add_call_guards, no_landing_pads, simplify};\n use util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n@@ -39,7 +37,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                        instance: ty::InstanceDef<'tcx>)\n-                       -> &'tcx RefCell<Mir<'tcx>>\n+                       -> &'tcx Mir<'tcx>\n {\n     debug!(\"make_shim({:?})\", instance);\n     let did = instance.def_id();\n@@ -116,10 +114,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         add_call_guards::add_call_guards(&mut result);\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n-    let result = tcx.alloc_mir(result);\n-    // Perma-borrow MIR from shims to prevent mutation.\n-    mem::forget(result.borrow());\n-    result\n+    tcx.alloc_mir(result)\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]"}, {"sha": "b7c7a1774dd356f3ab2aac43decccb7002904a36", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n pub struct AddCallGuards;\n@@ -35,8 +35,11 @@ pub struct AddCallGuards;\n  *\n  */\n \n-impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for AddCallGuards {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         add_call_guards(mir);\n     }\n }\n@@ -82,5 +85,3 @@ pub fn add_call_guards(mir: &mut Mir) {\n \n     mir.basic_blocks_mut().extend(new_blocks);\n }\n-\n-impl Pass for AddCallGuards {}"}, {"sha": "fbb67161bac9d82fb7d5034ccab663d481d9819c", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -30,21 +30,19 @@\n //! future.\n \n use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use util::def_use::DefUseAnalysis;\n use transform::qualify_consts;\n \n pub struct CopyPropagation;\n \n-impl Pass for CopyPropagation {}\n-\n-impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    source: MirSource,\n-                    mir: &mut Mir<'tcx>) {\n+impl MirPass for CopyPropagation {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         match source {\n             MirSource::Const(_) => {\n                 // Don't run on constants, because constant qualification might reject the"}, {"sha": "4309f91c635bb15bc6f733123354c0d24b733625", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -10,16 +10,16 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_vec::Idx;\n \n pub struct Deaggregator;\n \n-impl Pass for Deaggregator {}\n-\n-impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    source: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for Deaggregator {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let node_id = source.item_id();\n         let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n         debug!(\"running on: {:?}\", node_path);"}, {"sha": "67a3281dba48b0afacda60f88445690337336920", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -10,77 +10,73 @@\n \n //! This pass just dumps MIR at a specified point.\n \n+use std::borrow::Cow;\n use std::fmt;\n use std::fs::File;\n use std::io;\n \n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirPass, MirPassIndex, MirSource, MirSuite, PassHook};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n-use rustc::mir::*;\n-use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n use util as mir_util;\n \n-pub struct Marker<'a>(pub &'a str);\n+pub struct Marker(pub &'static str);\n \n-impl<'b, 'tcx> MirPass<'tcx> for Marker<'b> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _src: MirSource, _mir: &mut Mir<'tcx>)\n-    {}\n-}\n+impl MirPass for Marker {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(self.0)\n+    }\n \n-impl<'b> Pass for Marker<'b> {\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { String::from(self.0).into() }\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _source: MirSource,\n+                          _mir: &mut Mir<'tcx>)\n+    {\n+    }\n }\n \n-pub struct Disambiguator<'a> {\n-    pass: &'a Pass,\n+pub struct Disambiguator {\n     is_after: bool\n }\n \n-impl<'a> fmt::Display for Disambiguator<'a> {\n+impl fmt::Display for Disambiguator {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         let title = if self.is_after { \"after\" } else { \"before\" };\n-        if let Some(fmt) = self.pass.disambiguator() {\n-            write!(formatter, \"{}-{}\", fmt, title)\n-        } else {\n-            write!(formatter, \"{}\", title)\n-        }\n+        write!(formatter, \"{}\", title)\n     }\n }\n \n pub struct DumpMir;\n \n-impl<'tcx> MirPassHook<'tcx> for DumpMir {\n-    fn on_mir_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource,\n-        mir: &Mir<'tcx>,\n-        pass: &Pass,\n-        is_after: bool)\n+impl PassHook for DumpMir {\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool)\n     {\n-        mir_util::dump_mir(\n-            tcx,\n-            &*pass.name(),\n-            &Disambiguator {\n-                pass: pass,\n-                is_after: is_after\n-            },\n-            src,\n-            mir\n-        );\n+        if mir_util::dump_enabled(tcx, pass_name, source) {\n+            mir_util::dump_mir(tcx,\n+                               Some((suite, pass_num)),\n+                               pass_name,\n+                               &Disambiguator { is_after },\n+                               source,\n+                               mir);\n+        }\n     }\n }\n \n-impl<'b> Pass for DumpMir {}\n-\n pub fn emit_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     outputs: &OutputFilenames)\n     -> io::Result<()>\n {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n-    mir_util::write_mir_pretty(tcx, tcx.maps.mir.borrow().keys().into_iter(), &mut f)?;\n+    mir_util::write_mir_pretty(tcx, None, &mut f)?;\n     Ok(())\n }"}, {"sha": "19714849b09141c252cb1c9640fe679852768aaf", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -69,11 +69,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n \n pub struct EraseRegions;\n \n-impl Pass for EraseRegions {}\n-\n-impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for EraseRegions {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "f60dcbed6ba474bee54f34fd07d9042b35f97e39", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 76, "deletions": 188, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -14,24 +14,20 @@ use rustc::hir::def_id::DefId;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::graph;\n \n-use rustc::dep_graph::DepNode;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirMapPass, MirPassHook, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::*;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n-use rustc::util::nodemap::{DefIdSet};\n \n+use std::collections::VecDeque;\n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n \n use syntax::{attr};\n use syntax::abi::Abi;\n \n-use callgraph;\n-\n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n \n@@ -42,178 +38,94 @@ const UNKNOWN_SIZE_COST: usize = 10;\n \n pub struct Inline;\n \n-impl<'tcx> MirMapPass<'tcx> for Inline {\n-    fn run_pass<'a>(\n-        &mut self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n-\n-        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 { return; }\n-\n-        let _ignore = tcx.dep_graph.in_ignore();\n-\n-        let callgraph = callgraph::CallGraph::build(tcx);\n-\n-        let mut inliner = Inliner {\n-            tcx: tcx,\n-        };\n-\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for &def_id in &def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mut mir = if let Some(mir) = tcx.maps.mir.borrow().get(&def_id) {\n-                mir.borrow_mut()\n-            } else {\n-                continue;\n-            };\n-\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, &mut mir, self, false);\n-            }\n-        }\n-\n-        for scc in callgraph.scc_iter() {\n-            inliner.inline_scc(&callgraph, &scc);\n-        }\n-\n-        for def_id in def_ids {\n-            if !def_id.is_local() { continue; }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mut mir = tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, &mut mir, self, true);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Pass for Inline { }\n-\n-struct Inliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n #[derive(Copy, Clone)]\n struct CallSite<'tcx> {\n-    caller: DefId,\n     callee: DefId,\n     substs: &'tcx Substs<'tcx>,\n     bb: BasicBlock,\n     location: SourceInfo,\n }\n \n-impl<'a, 'tcx> Inliner<'a, 'tcx> {\n-    fn inline_scc(&mut self, callgraph: &callgraph::CallGraph, scc: &[graph::NodeIndex]) -> bool {\n-        let mut callsites = Vec::new();\n-        let mut in_scc = DefIdSet();\n-\n-        let mut inlined_into = DefIdSet();\n+impl MirPass for Inline {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            Inliner { tcx, source }.run_pass(mir);\n+        }\n+    }\n+}\n \n-        for &node in scc {\n-            let def_id = callgraph.def_id(node);\n+struct Inliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: MirSource,\n+}\n \n-            // Don't inspect functions from other crates\n-            let id = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                id\n-            } else {\n-                continue;\n-            };\n-            let src = MirSource::from_node(self.tcx, id);\n-            if let MirSource::Fn(_) = src {\n-                if let Some(mir) = self.tcx.maybe_item_mir(def_id) {\n-                    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-                        // Don't inline calls that are in cleanup blocks.\n-                        if bb_data.is_cleanup { continue; }\n-\n-                        // Only consider direct calls to functions\n-                        let terminator = bb_data.terminator();\n-                        if let TerminatorKind::Call {\n-                            func: Operand::Constant(ref f), .. } = terminator.kind {\n-                            if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n-                                callsites.push(CallSite {\n-                                    caller: def_id,\n-                                    callee: callee_def_id,\n-                                    substs: substs,\n-                                    bb: bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n-                        }\n+impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+    fn run_pass(&self, caller_mir: &mut Mir<'tcx>) {\n+        // Keep a queue of callsites to try inlining on. We take\n+        // advantage of the fact that queries detect cycles here to\n+        // allow us to try and fetch the fully optimized MIR of a\n+        // call; if it succeeds, we can inline it and we know that\n+        // they do not call us.  Otherwise, we just don't try to\n+        // inline.\n+        //\n+        // We use a queue so that we inline \"broadly\" before we inline\n+        // in depth. It is unclear if this is the best heuristic,\n+        // really, but that's true of all the heuristics in this\n+        // file. =)\n+\n+        let mut callsites = VecDeque::new();\n+\n+        // Only do inlining into fn bodies.\n+        if let MirSource::Fn(_) = self.source {\n+            for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n+                // Don't inline calls that are in cleanup blocks.\n+                if bb_data.is_cleanup { continue; }\n+\n+                // Only consider direct calls to functions\n+                let terminator = bb_data.terminator();\n+                if let TerminatorKind::Call {\n+                    func: Operand::Constant(ref f), .. } = terminator.kind {\n+                    if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                        callsites.push_back(CallSite {\n+                            callee: callee_def_id,\n+                            substs: substs,\n+                            bb: bb,\n+                            location: terminator.source_info\n+                        });\n                     }\n-\n-                    in_scc.insert(def_id);\n                 }\n             }\n         }\n \n-        // Move callsites that are in the the SCC to the end so\n-        // they're inlined after calls to outside the SCC\n-        let mut first_call_in_scc = callsites.len();\n-\n-        let mut i = 0;\n-        while i < first_call_in_scc {\n-            let f = callsites[i].caller;\n-            if in_scc.contains(&f) {\n-                first_call_in_scc -= 1;\n-                callsites.swap(i, first_call_in_scc);\n-            } else {\n-                i += 1;\n-            }\n-        }\n-\n         let mut local_change;\n         let mut changed = false;\n \n         loop {\n             local_change = false;\n-            let mut csi = 0;\n-            while csi < callsites.len() {\n-                let callsite = callsites[csi];\n-                csi += 1;\n-\n-                let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n-                self.tcx.dep_graph.write(DepNode::Mir(callsite.caller));\n-\n-                let callee_mir = {\n-                    if let Some(callee_mir) = self.tcx.maybe_item_mir(callsite.callee) {\n-                        if !self.should_inline(callsite, &callee_mir) {\n-                            continue;\n-                        }\n+            while let Some(callsite) = callsites.pop_front() {\n+                if !self.tcx.is_mir_available(callsite.callee) {\n+                    continue;\n+                }\n \n+                let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n+                                                                           callsite.location.span,\n+                                                                           callsite.callee) {\n+                    Ok(ref callee_mir) if self.should_inline(callsite, callee_mir) => {\n                         callee_mir.subst(self.tcx, callsite.substs)\n-                    } else {\n-                        continue;\n                     }\n \n-                };\n-\n-                let mut caller_mir = {\n-                    let map = self.tcx.maps.mir.borrow();\n-                    let mir = map.get(&callsite.caller).unwrap();\n-                    mir.borrow_mut()\n+                    _ => continue,\n                 };\n \n                 let start = caller_mir.basic_blocks().len();\n \n-                if !self.inline_call(callsite, &mut caller_mir, callee_mir) {\n+                if !self.inline_call(callsite, caller_mir, callee_mir) {\n                     continue;\n                 }\n \n-                inlined_into.insert(callsite.caller);\n-\n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n                     // Only consider direct calls to functions\n@@ -223,8 +135,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n-                                callsites.push(CallSite {\n-                                    caller: callsite.caller,\n+                                callsites.push_back(CallSite {\n                                     callee: callee_def_id,\n                                     substs: substs,\n                                     bb: bb,\n@@ -235,13 +146,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     }\n                 }\n \n-                csi -= 1;\n-                if scc.len() == 1 {\n-                    callsites.swap_remove(csi);\n-                } else {\n-                    callsites.remove(csi);\n-                }\n-\n                 local_change = true;\n                 changed = true;\n             }\n@@ -251,27 +155,19 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n         }\n \n-        // Simplify functions we inlined into.\n-        for def_id in inlined_into {\n-            let _task = self.tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            self.tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            let mut caller_mir = {\n-                let map = self.tcx.maps.mir.borrow();\n-                let mir = map.get(&def_id).unwrap();\n-                mir.borrow_mut()\n-            };\n-\n-            debug!(\"Running simplify cfg on {:?}\", def_id);\n-            CfgSimplifier::new(&mut caller_mir).simplify();\n-            remove_dead_blocks(&mut caller_mir);\n+        // Simplify if we inlined anything.\n+        if changed {\n+            debug!(\"Running simplify cfg on {:?}\", self.source);\n+            CfgSimplifier::new(caller_mir).simplify();\n+            remove_dead_blocks(caller_mir);\n         }\n-        changed\n     }\n \n-    fn should_inline(&self, callsite: CallSite<'tcx>,\n-                     callee_mir: &'a Mir<'tcx>) -> bool {\n-\n+    fn should_inline(&self,\n+                     callsite: CallSite<'tcx>,\n+                     callee_mir: &Mir<'tcx>)\n+                     -> bool\n+    {\n         let tcx = self.tcx;\n \n         // Don't inline closures that have captures\n@@ -323,8 +219,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         // FIXME: Give a bonus to functions with only a single caller\n \n-        let id = tcx.hir.as_local_node_id(callsite.caller).expect(\"Caller not local\");\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, self.source.item_id());\n \n         let mut first_block = true;\n         let mut cost = 0;\n@@ -423,22 +318,15 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-\n-    fn inline_call(&self, callsite: CallSite<'tcx>,\n-                             caller_mir: &mut Mir<'tcx>, mut callee_mir: Mir<'tcx>) -> bool {\n-\n-        // Don't inline a function into itself\n-        if callsite.caller == callsite.callee { return false; }\n-\n-        let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n-\n-\n+    fn inline_call(&self,\n+                   callsite: CallSite<'tcx>,\n+                   caller_mir: &mut Mir<'tcx>,\n+                   mut callee_mir: Mir<'tcx>) -> bool {\n         let terminator = caller_mir[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-\n-                debug!(\"Inlined {:?} into {:?}\", callsite.callee, callsite.caller);\n+                debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n                 let is_box_free = Some(callsite.callee) == self.tcx.lang_items.box_free_fn();\n "}, {"sha": "88a368077d4f5e94248dc4e15bcec93ed2a29cff", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -11,32 +11,20 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n-pub struct InstCombine {\n-    optimizations: OptimizationList,\n-}\n-\n-impl InstCombine {\n-    pub fn new() -> InstCombine {\n-        InstCombine {\n-            optimizations: OptimizationList::default(),\n-        }\n-    }\n-}\n-\n-impl Pass for InstCombine {}\n+pub struct InstCombine;\n \n-impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource,\n-                    mir: &mut Mir<'tcx>) {\n+impl MirPass for InstCombine {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -45,18 +33,22 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Lvalue::ty()`).\n-        {\n+        let optimizations = {\n             let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n             optimization_finder.visit_mir(mir);\n-            self.optimizations = optimization_finder.optimizations\n-        }\n+            optimization_finder.optimizations\n+        };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_mir(&mut *self, mir);\n+        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations }, mir);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for InstCombine {\n+pub struct InstCombineVisitor {\n+    optimizations: OptimizationList,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);"}, {"sha": "fcea5d4c86047cc6e05a5dd9fd4b2d34f6fa6b2e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -8,6 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource,\n+                            MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use rustc::ty::steal::Steal;\n+use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::util::nodemap::DefIdSet;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax_pos::{DUMMY_SP, Span};\n+use transform;\n+\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -21,3 +37,114 @@ pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n pub mod inline;\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    self::qualify_consts::provide(providers);\n+    *providers = Providers {\n+        mir_keys,\n+        mir_const,\n+        mir_validated,\n+        optimized_mir,\n+        is_mir_available,\n+        ..*providers\n+    };\n+}\n+\n+fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    tcx.mir_keys(def_id.krate).contains(&def_id)\n+}\n+\n+/// Finds the full set of def-ids within the current crate that have\n+/// MIR associated with them.\n+fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n+                      -> Rc<DefIdSet> {\n+    assert_eq!(krate, LOCAL_CRATE);\n+\n+    let mut set = DefIdSet();\n+\n+    // All body-owners have MIR associated with them.\n+    set.extend(tcx.body_owners());\n+\n+    // Additionally, tuple struct/variant constructors have MIR, but\n+    // they don't have a BodyId, so we need to build them separately.\n+    struct GatherCtors<'a, 'tcx: 'a> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        set: &'a mut DefIdSet,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n+        fn visit_variant_data(&mut self,\n+                              v: &'tcx hir::VariantData,\n+                              _: ast::Name,\n+                              _: &'tcx hir::Generics,\n+                              _: ast::NodeId,\n+                              _: Span) {\n+            if let hir::VariantData::Tuple(_, node_id) = *v {\n+                self.set.insert(self.tcx.hir.local_def_id(node_id));\n+            }\n+            intravisit::walk_struct_def(self, v)\n+        }\n+        fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+    tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n+        tcx: tcx,\n+        set: &mut set,\n+    }.as_deep_visitor());\n+\n+    Rc::new(set)\n+}\n+\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let mut mir = build::mir_build(tcx, def_id);\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_CONST, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    if let MirSource::Const(_) = source {\n+        // Ensure that we compute the `mir_const_qualif` for constants at\n+        // this point, before we steal the mir-const result. We don't\n+        // directly need the result or `mir_const_qualif`, so we can just force it.\n+        ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n+    }\n+\n+    let mut mir = tcx.mir_const(def_id).steal();\n+    transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n+    // Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    ty::queries::borrowck::force(tcx, DUMMY_SP, def_id);\n+\n+    let mut mir = tcx.mir_validated(def_id).steal();\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_OPTIMIZED, &mut mir);\n+    tcx.alloc_mir(mir)\n+}\n+\n+fn run_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       source: MirSource,\n+                       suite: MirSuite,\n+                       mir: &mut Mir<'tcx>)\n+{\n+    let passes = tcx.mir_passes.passes(suite);\n+\n+    for (pass, index) in passes.iter().zip(0..) {\n+        let pass_num = MirPassIndex(index);\n+\n+        for hook in tcx.mir_passes.hooks() {\n+            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, false);\n+        }\n+\n+        pass.run_pass(tcx, source, mir);\n+\n+        for hook in tcx.mir_passes.hooks() {\n+            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, true);\n+        }\n+    }\n+}"}, {"sha": "8595663ba18c4ea4051feaffa15dcd975f039ab3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -14,10 +14,25 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n \n pub struct NoLandingPads;\n \n+impl MirPass for NoLandingPads {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        no_landing_pads(tcx, mir)\n+    }\n+}\n+\n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+    if tcx.sess.no_landing_pads() {\n+        NoLandingPads.visit_mir(mir);\n+    }\n+}\n+\n impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n     fn visit_terminator(&mut self,\n                         bb: BasicBlock,\n@@ -41,18 +56,3 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n         self.super_terminator(bb, terminator, location);\n     }\n }\n-\n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n-    if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_mir(mir);\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        no_landing_pads(tcx, mir)\n-    }\n-}\n-\n-impl Pass for NoLandingPads {}"}, {"sha": "4b1c82f383f85ce1a638dc2e048b0980f1af43a3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -16,7 +16,6 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -27,7 +26,7 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n@@ -919,13 +918,21 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.mir_const_qualif = qualify_const_item;\n+    *providers = Providers {\n+        mir_const_qualif,\n+        ..*providers\n+    };\n }\n \n-fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> u8 {\n-    let mir = &tcx.item_mir(def_id);\n+fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> u8 {\n+    // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n+    // cannot yet be stolen), because `mir_validated()`, which steals\n+    // from `mir_const(), forces this query to execute before\n+    // performing the steal.\n+    let mir = &tcx.mir_const(def_id).borrow();\n+\n     if mir.return_ty.references_error() {\n         return Qualif::NOT_CONST.bits();\n     }\n@@ -939,45 +946,11 @@ fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct QualifyAndPromoteConstants;\n \n-impl Pass for QualifyAndPromoteConstants {}\n-\n-impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n-    {\n-        let def_ids = tcx.maps.mir.borrow().keys();\n-        for def_id in def_ids {\n-            if !def_id.is_local() {\n-                continue;\n-            }\n-\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-\n-            if let MirSource::Const(_) = src {\n-                tcx.mir_const_qualif(def_id);\n-                continue;\n-            }\n-\n-            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n-            tcx.dep_graph.write(DepNode::Mir(def_id));\n-\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n-            }\n-            self.run_pass(tcx, src, mir);\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for QualifyAndPromoteConstants {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n         let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {"}, {"sha": "d5b79c0d1c3829595379951c9e6f199fcddf4bd8", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -41,15 +41,15 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor, LvalueContext};\n-use std::fmt;\n+use std::borrow::Cow;\n \n-pub struct SimplifyCfg<'a> { label: &'a str }\n+pub struct SimplifyCfg { label: String }\n \n-impl<'a> SimplifyCfg<'a> {\n-    pub fn new(label: &'a str) -> Self {\n-        SimplifyCfg { label: label }\n+impl SimplifyCfg {\n+    pub fn new(label: &str) -> Self {\n+        SimplifyCfg { label: format!(\"SimplifyCfg-{}\", label) }\n     }\n }\n \n@@ -61,20 +61,18 @@ pub fn simplify_cfg(mir: &mut Mir) {\n     mir.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n-impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n-        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n-        simplify_cfg(mir);\n+impl MirPass for SimplifyCfg {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(&self.label)\n     }\n-}\n \n-impl<'l> Pass for SimplifyCfg<'l> {\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n-        Some(Box::new(self.label))\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n+        simplify_cfg(mir);\n     }\n-\n-    // avoid calling `type_name` - it contains `<'static>`\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyCfg\".into() }\n }\n \n pub struct CfgSimplifier<'a, 'tcx: 'a> {\n@@ -315,12 +313,11 @@ pub fn remove_dead_blocks(mir: &mut Mir) {\n \n pub struct SimplifyLocals;\n \n-impl Pass for SimplifyLocals {\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyLocals\".into() }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for SimplifyLocals {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live"}, {"sha": "d21a6ddfdfb970c85b57276238399370133ddeff", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -12,21 +12,28 @@\n \n use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::*;\n \n-use std::fmt;\n+use std::borrow::Cow;\n \n-pub struct SimplifyBranches<'a> { label: &'a str }\n+pub struct SimplifyBranches { label: String }\n \n-impl<'a> SimplifyBranches<'a> {\n-    pub fn new(label: &'a str) -> Self {\n-        SimplifyBranches { label: label }\n+impl SimplifyBranches {\n+    pub fn new(label: &str) -> Self {\n+        SimplifyBranches { label: format!(\"SimplifyBranches-{}\", label) }\n     }\n }\n \n-impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n-    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for SimplifyBranches {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        Cow::Borrowed(&self.label)\n+    }\n+\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n@@ -60,11 +67,3 @@ impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n     }\n }\n \n-impl<'l> Pass for SimplifyBranches<'l> {\n-    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n-        Some(Box::new(self.label))\n-    }\n-\n-    // avoid calling `type_name` - it contains `<'static>`\n-    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyBranches\".into() }\n-}"}, {"sha": "b325470ec818cadcd33f6dd3309ec408400a5351", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::Visitor;\n use std::fmt;\n use syntax::ast;\n@@ -737,9 +737,11 @@ impl TypeckMir {\n     }\n }\n \n-impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n+impl MirPass for TypeckMir {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let item_id = src.item_id();\n         let def_id = tcx.hir.local_def_id(item_id);\n         debug!(\"run_pass: {}\", tcx.item_path_str(def_id));\n@@ -765,6 +767,3 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         });\n     }\n }\n-\n-impl Pass for TypeckMir {\n-}"}, {"sha": "cf13a80e677b1266bac748cd8cfd43360ff00758", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -18,16 +18,18 @@ use syntax::ast::NodeId;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+use super::pretty::dump_mir_def_ids;\n+\n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                                              iter: I,\n-                                              w: &mut W)\n-                                              -> io::Result<()>\n-    where W: Write, I: Iterator<Item=DefId>\n+pub fn write_mir_graphviz<'a, 'tcx, W>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       single: Option<DefId>,\n+                                       w: &mut W)\n+                                       -> io::Result<()>\n+    where W: Write\n {\n-    for def_id in iter {\n+    for def_id in dump_mir_def_ids(tcx, single) {\n         let nodeid = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let mir = &tcx.item_mir(def_id);\n+        let mir = &tcx.optimized_mir(def_id);\n \n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n "}, {"sha": "4386bab38c0399650bb461a6a6d7cfc16cacedbe", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -15,6 +15,6 @@ pub mod patch;\n mod graphviz;\n mod pretty;\n \n-pub use self::pretty::{dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "5f51888019b9d2cd2f34b1d4ba2e4a55d8b08077", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n-use rustc::mir::transform::MirSource;\n+use rustc::mir::transform::{MirSuite, MirPassIndex, MirSource};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n@@ -28,7 +28,7 @@ const ALIGN: usize = 40;\n /// representation of the mir into:\n ///\n /// ```text\n-/// rustc.node<node_id>.<pass_name>.<disambiguator>\n+/// rustc.node<node_id>.<pass_num>.<pass_name>.<disambiguator>\n /// ```\n ///\n /// Output from this function is controlled by passing `-Z dump-mir=<filter>`,\n@@ -39,64 +39,95 @@ const ALIGN: usize = 40;\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          pass_num: Option<(MirSuite, MirPassIndex)>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n-                          src: MirSource,\n+                          source: MirSource,\n                           mir: &Mir<'tcx>) {\n+    if !dump_enabled(tcx, pass_name, source) {\n+        return;\n+    }\n+\n+    let node_path = tcx.item_path_str(tcx.hir.local_def_id(source.item_id()));\n+    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n+                          disambiguator, source, mir);\n+    for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n+        let promoted_source = MirSource::Promoted(source.item_id(), index);\n+        dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n+                              promoted_source, promoted_mir);\n+    }\n+}\n+\n+pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              pass_name: &str,\n+                              source: MirSource)\n+                              -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n-        None => return,\n+        None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_id = src.item_id();\n+    let node_id = source.item_id();\n     let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n-    let is_matched =\n-        filters.split(\"&\")\n-               .any(|filter| {\n-                   filter == \"all\" ||\n-                       pass_name.contains(filter) ||\n-                       node_path.contains(filter)\n-               });\n-    if !is_matched {\n-        return;\n-    }\n+    filters.split(\"&\")\n+           .any(|filter| {\n+               filter == \"all\" ||\n+                   pass_name.contains(filter) ||\n+                   node_path.contains(filter)\n+           })\n+}\n \n-    let promotion_id = match src {\n+fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                   pass_name: &str,\n+                                   node_path: &str,\n+                                   disambiguator: &Display,\n+                                   source: MirSource,\n+                                   mir: &Mir<'tcx>) {\n+    let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n         _ => String::new()\n     };\n \n+    let pass_num = if tcx.sess.opts.debugging_opts.dump_mir_exclude_pass_number {\n+        format!(\"\")\n+    } else {\n+        match pass_num {\n+            None => format!(\".-------\"),\n+            Some((suite, pass_num)) => format!(\".{:03}-{:03}\", suite.0, pass_num.0),\n+        }\n+    };\n+\n     let mut file_path = PathBuf::new();\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n-    let file_name = format!(\"rustc.node{}{}.{}.{}.mir\",\n-                            node_id, promotion_id, pass_name, disambiguator);\n+    let file_name = format!(\"rustc.node{}{}{}.{}.{}.mir\",\n+                            source.item_id(), promotion_id, pass_num, pass_name, disambiguator);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {\n         writeln!(file, \"// MIR for `{}`\", node_path)?;\n-        writeln!(file, \"// node_id = {}\", node_id)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, src, mir, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut file)?;\n         Ok(())\n     });\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                                         iter: I,\n-                                         w: &mut Write)\n-                                         -> io::Result<()>\n-    where I: Iterator<Item=DefId>, 'tcx: 'a\n+pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  single: Option<DefId>,\n+                                  w: &mut Write)\n+                                  -> io::Result<()>\n {\n     writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n     writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n \n     let mut first = true;\n-    for def_id in iter.filter(DefId::is_local) {\n-        let mir = &tcx.item_mir(def_id);\n+    for def_id in dump_mir_def_ids(tcx, single) {\n+        let mir = &tcx.optimized_mir(def_id);\n \n         if first {\n             first = false;\n@@ -312,3 +343,11 @@ fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n \n     Ok(())\n }\n+\n+pub fn dump_mir_def_ids(tcx: TyCtxt, single: Option<DefId>) -> Vec<DefId> {\n+    if let Some(i) = single {\n+        vec![i]\n+    } else {\n+        tcx.mir_keys(LOCAL_CRATE).iter().cloned().collect()\n+    }\n+}"}, {"sha": "d9921e62330b95e1fa098a7f39b60540641af3c5", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -13,6 +13,7 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n@@ -44,10 +45,9 @@ pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n     // For debugging instrumentation like this, we don't need to worry\n     // about maintaining the dep graph.\n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mir_map = tcx.maps.mir.borrow();\n-    for def_id in mir_map.keys() {\n-        let mir = mir_map.get(&def_id).unwrap();\n-        collector.visit_mir(&mir.borrow());\n+    for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n+        let mir = tcx.optimized_mir(def_id);\n+        collector.visit_mir(&mir);\n     }\n     collector.print(title);\n }"}, {"sha": "6d7d95f54872105ea12b790ee9cd1b8e656777a8", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -659,7 +659,7 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n                 // in this crate\n                 false\n             } else {\n-                if !tcx.is_item_mir_available(def_id) {\n+                if !tcx.is_mir_available(def_id) {\n                     bug!(\"Cannot create local trans-item for {:?}\", def_id)\n                 }\n                 true"}, {"sha": "11095e70f621c6e699a17e60d92d0f382f0dacda", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -640,9 +640,9 @@ pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> CompileResult {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.sess.track_errors(|| {\n-        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+        for body_owner_def_id in tcx.body_owners() {\n             tcx.typeck_tables_of(body_owner_def_id);\n-        });\n+        }\n     })\n }\n "}, {"sha": "e4eb1aeaf9be2db8e2576179d558ce6f0c49536d", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -36,7 +36,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyCfg.initial-after.mir\n+// START rustc.node4.SimplifyCfg-initial.after.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const false;\n@@ -82,4 +82,4 @@ fn main() {\n //         StorageDead(_1);\n //         return;\n //     }\n-// END rustc.node4.SimplifyCfg.initial-after.mir\n+// END rustc.node4.SimplifyCfg-initial.after.mir"}, {"sha": "5a9336e96592d6a287eb159eb6d667375622497d", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -21,7 +21,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyCfg.initial-after.mir\n+// START rustc.node4.SimplifyCfg-initial.after.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const false;\n@@ -48,4 +48,4 @@ fn main() {\n //         _2 = ();\n //         goto -> bb1;\n //     }\n-// END rustc.node4.SimplifyCfg.initial-after.mir\n+// END rustc.node4.SimplifyCfg-initial.after.mir"}, {"sha": "cff108246a550da31dd2e116b4460b8409e1f2fc", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -15,13 +15,13 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.SimplifyBranches.initial-before.mir\n+// START rustc.node4.SimplifyBranches-initial.before.mir\n // bb0: {\n //     switchInt(const false) -> [0u8: bb2, otherwise: bb1];\n // }\n-// END rustc.node4.SimplifyBranches.initial-before.mir\n-// START rustc.node4.SimplifyBranches.initial-after.mir\n+// END rustc.node4.SimplifyBranches-initial.before.mir\n+// START rustc.node4.SimplifyBranches-initial.after.mir\n // bb0: {\n //     goto -> bb2;\n // }\n-// END rustc.node4.SimplifyBranches.initial-after.mir\n+// END rustc.node4.SimplifyBranches-initial.after.mir"}, {"sha": "de110ac12b70398a3fc7f8d6ca7f051f71ff73b1", "filename": "src/test/ui/issue-40402-ref-hints/issue-40402-1.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -2,7 +2,10 @@ error[E0507]: cannot move out of indexed content\n   --> $DIR/issue-40402-1.rs:19:13\n    |\n 19 |     let e = f.v[0];\n-   |             ^^^^^^ cannot move out of indexed content\n+   |             ^^^^^^\n+   |             |\n+   |             help: consider using a reference instead `&f.v[0]`\n+   |             cannot move out of indexed content\n \n error: aborting due to previous error\n "}, {"sha": "a044282666da0a7ec100086b2927bdf097f3c3c9", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/146dc670cfec54a02bc1eddef62f6a595c6b3726/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=146dc670cfec54a02bc1eddef62f6a595c6b3726", "patch": "@@ -1402,18 +1402,16 @@ actual:\\n\\\n                 }\n             }\n             MirOpt => {\n-                args.extend([\"-Z\",\n-                             \"dump-mir=all\",\n-                             \"-Z\",\n-                             \"mir-opt-level=3\",\n-                             \"-Z\"]\n+                args.extend([\"-Zdump-mir=all\",\n+                             \"-Zmir-opt-level=3\",\n+                             \"-Zdump-mir-exclude-pass-number\"]\n                             .iter()\n                             .map(|s| s.to_string()));\n \n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n                 create_dir_all(mir_dump_dir.as_path()).unwrap();\n-                let mut dir_opt = \"dump-mir-dir=\".to_string();\n+                let mut dir_opt = \"-Zdump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n                 debug!(\"dir_opt: {:?}\", dir_opt);\n "}]}