{"sha": "19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZWNmY2QwZTJhZTAxYzc5MTU5ODg4YTQ1MDQyYTVkNmY0ZWQ0ODc=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-02-28T02:31:56Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-24T20:45:41Z"}, "message": "resolve late lifetimes by item\n\nThis reverts commit 22ae20733515d710c1134600bc1e29cdd76f6b9b.", "tree": {"sha": "cd5e3efeef464b6517ca0bb6e69a4f8f3a9a8169", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd5e3efeef464b6517ca0bb6e69a4f8f3a9a8169"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "html_url": "https://github.com/rust-lang/rust/commit/19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "html_url": "https://github.com/rust-lang/rust/commit/f5fe425c925ef36d5f4c18cfa44173fc42de31b8"}], "stats": {"total": 1035, "additions": 514, "deletions": 521}, "files": [{"sha": "32615f6c410c7289b155487cc1310173c9ddcea0", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -78,9 +78,4 @@ pub struct ResolveLifetimes {\n     /// be late-bound if (a) it does NOT appear in a where-clause and\n     /// (b) it DOES appear in the arguments.\n     pub late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n-\n-    /// For each type and trait definition, maps type parameters\n-    /// to the trait object lifetime defaults computed from them.\n-    pub object_lifetime_defaults:\n-        FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>>,\n }"}, {"sha": "93e4c97efd8719d4a5af2a67e86ea37ddfcc0869", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1253,7 +1253,12 @@ rustc_queries! {\n     }\n \n     /// Lifetime resolution. See `middle::resolve_lifetimes`.\n-    query resolve_lifetimes(_: CrateNum) -> ResolveLifetimes {\n+    query resolve_lifetimes_definition(_: LocalDefId) -> ResolveLifetimes {\n+        storage(ArenaCacheSelector<'tcx>)\n+        desc { \"resolving lifetimes in a definition\" }\n+    }\n+    /// Lifetime resolution. See `middle::resolve_lifetimes`.\n+    query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n         storage(ArenaCacheSelector<'tcx>)\n         desc { \"resolving lifetimes\" }\n     }\n@@ -1266,8 +1271,8 @@ rustc_queries! {\n         desc { \"testing if a region is late bound\" }\n     }\n     query object_lifetime_defaults_map(_: LocalDefId)\n-        -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>> {\n-        desc { \"looking up lifetime defaults for a region\" }\n+        -> Option<Vec<ObjectLifetimeDefault>> {\n+        desc { \"looking up lifetime defaults for a region on an item\" }\n     }\n \n     query visibility(def_id: DefId) -> ty::Visibility {"}, {"sha": "57225b7abf77c20b710c8a0719d054513baa9420", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -2641,6 +2641,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+        debug!(?id, \"named_region\");\n         self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n@@ -2649,9 +2650,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             .map_or(false, |(owner, set)| owner == id.owner && set.contains(&id.local_id))\n     }\n \n-    pub fn object_lifetime_defaults(self, id: HirId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n+    pub fn object_lifetime_defaults(self, id: HirId) -> Option<Vec<ObjectLifetimeDefault>> {\n         self.object_lifetime_defaults_map(id.owner)\n-            .and_then(|map| map.get(&id.local_id).map(|v| &**v))\n     }\n }\n "}, {"sha": "02b732e75efb96ab986f2f7a26f38edc0b5ae762", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 269, "deletions": 157, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Name resolution for lifetimes.\n //!\n //! Name resolution for lifetimes follows *much* simpler rules than the\n@@ -11,7 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::def_id::DefIdMap;\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName, QPath};\n@@ -26,6 +27,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::fmt;\n use std::mem::take;\n \n use tracing::debug;\n@@ -135,7 +137,7 @@ impl RegionExt for Region {\n /// FIXME. This struct gets converted to a `ResolveLifetimes` for\n /// actual use. It has the same data, but indexed by `LocalDefId`.  This\n /// is silly.\n-#[derive(Default)]\n+#[derive(Debug, Default)]\n struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n     // `Region` describing how that region is bound\n@@ -145,10 +147,6 @@ struct NamedRegionMap {\n     // be late-bound if (a) it does NOT appear in a where-clause and\n     // (b) it DOES appear in the arguments.\n     late_bound: HirIdSet,\n-\n-    // For each type and trait definition, maps type parameters\n-    // to the trait object lifetime defaults computed from them.\n-    object_lifetime_defaults: HirIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n crate struct LifetimeContext<'a, 'tcx> {\n@@ -176,6 +174,8 @@ crate struct LifetimeContext<'a, 'tcx> {\n \n     is_in_const_generic: bool,\n \n+    definition_only: bool,\n+\n     /// List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<Ident>,\n \n@@ -252,6 +252,42 @@ enum Scope<'a> {\n     Root,\n }\n \n+// A helper struct for debugging scopes without printing parent scopes\n+struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n+\n+impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {\n+            Scope::Binder {\n+                lifetimes,\n+                next_early_index,\n+                track_lifetime_uses,\n+                opaque_type_parent,\n+                s: _,\n+            } => f\n+                .debug_struct(\"Binder\")\n+                .field(\"lifetimes\", lifetimes)\n+                .field(\"next_early_index\", next_early_index)\n+                .field(\"track_lifetime_uses\", track_lifetime_uses)\n+                .field(\"opaque_type_parent\", opaque_type_parent)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n+            Scope::Body { id, s: _ } => {\n+                f.debug_struct(\"Body\").field(\"id\", id).field(\"s\", &\"..\").finish()\n+            }\n+            Scope::Elision { elide, s: _ } => {\n+                f.debug_struct(\"Elision\").field(\"elide\", elide).field(\"s\", &\"..\").finish()\n+            }\n+            Scope::ObjectLifetimeDefault { lifetime, s: _ } => f\n+                .debug_struct(\"ObjectLifetimeDefault\")\n+                .field(\"lifetime\", lifetime)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n+            Scope::Root => f.debug_struct(\"Root\").finish(),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n enum Elide {\n     /// Use a fresh anonymous late-bound lifetime each time, by\n@@ -283,26 +319,61 @@ const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n+        resolve_lifetimes_definition,\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id),\n+        named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_defaults_map: |tcx, id| {\n-            tcx.resolve_lifetimes(LOCAL_CRATE).object_lifetime_defaults.get(&id)\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n+            match tcx.hir().find(hir_id) {\n+                Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n+                _ => None,\n+            }\n         },\n \n         ..*providers\n     };\n }\n \n+/// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n+/// Also does not generate any diagnostics.\n+#[tracing::instrument(level = \"debug\", skip(tcx))]\n+fn resolve_lifetimes_definition(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n+    do_resolve(tcx, local_def_id, true)\n+}\n+\n /// Computes the `ResolveLifetimes` map that contains data for the\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> ResolveLifetimes {\n-    assert_eq!(for_krate, LOCAL_CRATE);\n+#[tracing::instrument(level = \"debug\", skip(tcx))]\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n+    do_resolve(tcx, local_def_id, false)\n+}\n \n-    let named_region_map = krate(tcx);\n+fn do_resolve(\n+    tcx: TyCtxt<'_>,\n+    local_def_id: LocalDefId,\n+    definition_only: bool,\n+) -> ResolveLifetimes {\n+    let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(local_def_id));\n+    let mut named_region_map =\n+        NamedRegionMap { defs: Default::default(), late_bound: Default::default() };\n+    let mut visitor = LifetimeContext {\n+        tcx,\n+        map: &mut named_region_map,\n+        scope: ROOT_SCOPE,\n+        trait_ref_hack: false,\n+        is_in_fn_syntax: false,\n+        is_in_const_generic: false,\n+        definition_only,\n+        labels_in_fn: vec![],\n+        xcrate_object_lifetime_defaults: Default::default(),\n+        lifetime_uses: &mut Default::default(),\n+        missing_named_lifetime_spots: vec![],\n+    };\n+    visitor.visit_item(item);\n \n     let mut rl = ResolveLifetimes::default();\n \n@@ -314,14 +385,47 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> ResolveLifetimes {\n         let map = rl.late_bound.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id);\n     }\n-    for (hir_id, v) in named_region_map.object_lifetime_defaults {\n-        let map = rl.object_lifetime_defaults.entry(hir_id.owner).or_default();\n-        map.insert(hir_id.local_id, v);\n-    }\n \n+    debug!(?rl.defs);\n     rl\n }\n \n+fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx ResolveLifetimes {\n+    let item_id = item_for(tcx, def_id);\n+    if item_id == def_id {\n+        let item = tcx.hir().item(hir::ItemId { def_id: item_id });\n+        match item.kind {\n+            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_definition(item_id),\n+            _ => tcx.resolve_lifetimes(item_id),\n+        }\n+    } else {\n+        tcx.resolve_lifetimes(item_id)\n+    }\n+}\n+\n+fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n+    match tcx.hir().find(hir_id) {\n+        Some(Node::Item(item)) => {\n+            return item.def_id;\n+        }\n+        _ => {}\n+    }\n+    let item = {\n+        let hir = tcx.hir();\n+        let mut parent_iter = hir.parent_iter(hir_id);\n+        loop {\n+            let node = parent_iter.next().map(|n| n.1);\n+            match node {\n+                Some(hir::Node::Item(item)) => break item.def_id,\n+                Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n+                _ => {}\n+            }\n+        }\n+    };\n+    item\n+}\n+\n fn is_late_bound_map<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n@@ -344,35 +448,8 @@ fn is_late_bound_map<'tcx>(\n \n             tcx.is_late_bound_map(def_id.expect_local())\n         }\n-        _ => tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n-    }\n-}\n-\n-fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n-    let krate = tcx.hir().krate();\n-    let mut map = NamedRegionMap {\n-        defs: Default::default(),\n-        late_bound: Default::default(),\n-        object_lifetime_defaults: compute_object_lifetime_defaults(tcx),\n-    };\n-    {\n-        let mut visitor = LifetimeContext {\n-            tcx,\n-            map: &mut map,\n-            scope: ROOT_SCOPE,\n-            trait_ref_hack: false,\n-            is_in_fn_syntax: false,\n-            is_in_const_generic: false,\n-            labels_in_fn: vec![],\n-            xcrate_object_lifetime_defaults: Default::default(),\n-            lifetime_uses: &mut Default::default(),\n-            missing_named_lifetime_spots: vec![],\n-        };\n-        for item in krate.items.values() {\n-            visitor.visit_item(item);\n-        }\n+        _ => resolve_lifetimes_for(tcx, def_id).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n     }\n-    map\n }\n \n /// In traits, there is an implicit `Self` type parameter which comes before the generics.\n@@ -392,6 +469,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     // We want to nest trait/impl items in their parent, but nothing else.\n     fn visit_nested_item(&mut self, _: hir::ItemId) {}\n \n+    fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n+        if !self.definition_only {\n+            intravisit::walk_trait_item_ref(self, ii)\n+        }\n+    }\n+\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n         let saved = take(&mut self.labels_in_fn);\n@@ -430,6 +513,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n                 // their parent opaque_ty in scope.\n+                for (_hir_id, node) in\n+                    self.tcx.hir().parent_iter(self.tcx.hir().local_def_id_to_hir_id(item.def_id))\n+                {\n+                    match node {\n+                        hir::Node::Item(parent_item) => {\n+                            let resolved_lifetimes: &ResolveLifetimes =\n+                                self.tcx.resolve_lifetimes(item_for(self.tcx, parent_item.def_id));\n+                            // We need to add *all* deps, since opaque tys may want them from *us*\n+                            for (&owner, defs) in resolved_lifetimes.defs.iter() {\n+                                defs.iter().for_each(|(&local_id, region)| {\n+                                    self.map\n+                                        .defs\n+                                        .insert(hir::HirId { owner, local_id }, region.clone());\n+                                });\n+                            }\n+                            for (&owner, late_bound) in resolved_lifetimes.late_bound.iter() {\n+                                late_bound.iter().for_each(|&local_id| {\n+                                    self.map.late_bound.insert(hir::HirId { owner, local_id });\n+                                });\n+                            }\n+                            break;\n+                        }\n+                        hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n+                        _ => {}\n+                    }\n+                }\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -495,9 +604,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-        debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n-        debug!(\"visit_ty: ty.kind={:?}\", ty.kind);\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -541,7 +649,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n+                debug!(?bounds, ?lifetime, \"TraitObject\");\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n@@ -652,14 +760,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 };\n \n                                 if !parent_is_item {\n-                                    struct_span_err!(\n-                                        self.tcx.sess,\n-                                        lifetime.span,\n-                                        E0657,\n-                                        \"`impl Trait` can only capture lifetimes \\\n-                                             bound at the fn or impl level\"\n-                                    )\n-                                    .emit();\n+                                    if !self.definition_only {\n+                                        struct_span_err!(\n+                                            self.tcx.sess,\n+                                            lifetime.span,\n+                                            E0657,\n+                                            \"`impl Trait` can only capture lifetimes \\\n+                                                bound at the fn or impl level\"\n+                                        )\n+                                        .emit();\n+                                    }\n                                     self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                                 }\n                             }\n@@ -670,7 +780,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n                 let mut index = self.next_early_index_for_opaque_type();\n-                debug!(\"visit_ty: index = {}\", index);\n+                debug!(?index);\n \n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap::default();\n@@ -862,8 +972,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        debug!(\"visit_lifetime(lifetime_ref={:?})\", lifetime_ref);\n         if lifetime_ref.is_elided() {\n             self.resolve_elided_lifetimes(vec![lifetime_ref]);\n             return;\n@@ -897,7 +1007,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n+        if !self.definition_only {\n+            check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n+        }\n         for param in generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => {}\n@@ -1224,56 +1336,53 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n-    let mut map = HirIdMap::default();\n-    for item in tcx.hir().krate().items.values() {\n-        match item.kind {\n-            hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics)\n-            | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                ref generics, impl_trait_fn: None, ..\n-            })\n-            | hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                let result = object_lifetime_defaults_for_item(tcx, generics);\n-\n-                // Debugging aid.\n-                let attrs = tcx.hir().attrs(item.hir_id());\n-                if tcx.sess.contains_name(attrs, sym::rustc_object_lifetime_default) {\n-                    let object_lifetime_default_reprs: String = result\n-                        .iter()\n-                        .map(|set| match *set {\n-                            Set1::Empty => \"BaseDefault\".into(),\n-                            Set1::One(Region::Static) => \"'static\".into(),\n-                            Set1::One(Region::EarlyBound(mut i, _, _)) => generics\n-                                .params\n-                                .iter()\n-                                .find_map(|param| match param.kind {\n-                                    GenericParamKind::Lifetime { .. } => {\n-                                        if i == 0 {\n-                                            return Some(param.name.ident().to_string().into());\n-                                        }\n-                                        i -= 1;\n-                                        None\n+fn compute_object_lifetime_defaults(\n+    tcx: TyCtxt<'_>,\n+    item: &hir::Item<'_>,\n+) -> Option<Vec<ObjectLifetimeDefault>> {\n+    match item.kind {\n+        hir::ItemKind::Struct(_, ref generics)\n+        | hir::ItemKind::Union(_, ref generics)\n+        | hir::ItemKind::Enum(_, ref generics)\n+        | hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+        | hir::ItemKind::TyAlias(_, ref generics)\n+        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+            let result = object_lifetime_defaults_for_item(tcx, generics);\n+\n+            // Debugging aid.\n+            let attrs = tcx.hir().attrs(item.hir_id());\n+            if tcx.sess.contains_name(attrs, sym::rustc_object_lifetime_default) {\n+                let object_lifetime_default_reprs: String = result\n+                    .iter()\n+                    .map(|set| match *set {\n+                        Set1::Empty => \"BaseDefault\".into(),\n+                        Set1::One(Region::Static) => \"'static\".into(),\n+                        Set1::One(Region::EarlyBound(mut i, _, _)) => generics\n+                            .params\n+                            .iter()\n+                            .find_map(|param| match param.kind {\n+                                GenericParamKind::Lifetime { .. } => {\n+                                    if i == 0 {\n+                                        return Some(param.name.ident().to_string().into());\n                                     }\n-                                    _ => None,\n-                                })\n-                                .unwrap(),\n-                            Set1::One(_) => bug!(),\n-                            Set1::Many => \"Ambiguous\".into(),\n-                        })\n-                        .collect::<Vec<Cow<'static, str>>>()\n-                        .join(\",\");\n-                    tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n-                }\n-\n-                map.insert(item.hir_id(), result);\n+                                    i -= 1;\n+                                    None\n+                                }\n+                                _ => None,\n+                            })\n+                            .unwrap(),\n+                        Set1::One(_) => bug!(),\n+                        Set1::Many => \"Ambiguous\".into(),\n+                    })\n+                    .collect::<Vec<Cow<'static, str>>>()\n+                    .join(\",\");\n+                tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n             }\n-            _ => {}\n+\n+            Some(result)\n         }\n+        _ => None,\n     }\n-    map\n }\n \n /// Scan the bounds and where-clauses on parameters to extract bounds\n@@ -1392,15 +1501,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             trait_ref_hack: self.trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n+            definition_only: self.definition_only,\n             labels_in_fn,\n             xcrate_object_lifetime_defaults,\n             lifetime_uses,\n             missing_named_lifetime_spots,\n         };\n-        debug!(\"entering scope {:?}\", this.scope);\n-        f(self.scope, &mut this);\n-        this.check_uses_for_lifetimes_defined_by_scope();\n-        debug!(\"exiting scope {:?}\", this.scope);\n+        let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n+        {\n+            let _enter = span.enter();\n+            f(self.scope, &mut this);\n+            if !self.definition_only {\n+                this.check_uses_for_lifetimes_defined_by_scope();\n+            }\n+        }\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n@@ -1859,7 +1973,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Check for fn-syntax conflicts with in-band lifetime definitions\n-            if self.is_in_fn_syntax {\n+            if !self.definition_only && self.is_in_fn_syntax {\n                 match def {\n                     Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n                     | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n@@ -1991,47 +2105,47 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(def_id) = def_id.as_local() {\n+            let set_to_region = |set: &ObjectLifetimeDefault| match *set {\n+                Set1::Empty => {\n+                    if in_body {\n+                        None\n+                    } else {\n+                        Some(Region::Static)\n+                    }\n+                }\n+                Set1::One(r) => {\n+                    let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+                        GenericArg::Lifetime(lt) => Some(lt),\n+                        _ => None,\n+                    });\n+                    r.subst(lifetimes, map)\n+                }\n+                Set1::Many => None,\n+            };\n+            if let Some(def_id) = def_id.as_local() {\n                 let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                &map.object_lifetime_defaults[&id]\n+                self.tcx.object_lifetime_defaults(id).unwrap().iter().map(set_to_region).collect()\n             } else {\n                 let tcx = self.tcx;\n-                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    tcx.generics_of(def_id)\n-                        .params\n-                        .iter()\n-                        .filter_map(|param| match param.kind {\n-                            GenericParamDefKind::Type { object_lifetime_default, .. } => {\n-                                Some(object_lifetime_default)\n-                            }\n-                            GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => {\n-                                None\n-                            }\n-                        })\n-                        .collect()\n-                })\n-            };\n-            debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n-            unsubst\n-                .iter()\n-                .map(|set| match *set {\n-                    Set1::Empty => {\n-                        if in_body {\n-                            None\n-                        } else {\n-                            Some(Region::Static)\n-                        }\n-                    }\n-                    Set1::One(r) => {\n-                        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-                            GenericArg::Lifetime(lt) => Some(lt),\n-                            _ => None,\n-                        });\n-                        r.subst(lifetimes, map)\n-                    }\n-                    Set1::Many => None,\n-                })\n-                .collect()\n+                self.xcrate_object_lifetime_defaults\n+                    .entry(def_id)\n+                    .or_insert_with(|| {\n+                        tcx.generics_of(def_id)\n+                            .params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamDefKind::Type { object_lifetime_default, .. } => {\n+                                    Some(object_lifetime_default)\n+                                }\n+                                GenericParamDefKind::Lifetime\n+                                | GenericParamDefKind::Const { .. } => None,\n+                            })\n+                            .collect()\n+                    })\n+                    .iter()\n+                    .map(set_to_region)\n+                    .collect()\n+            }\n         });\n \n         debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n@@ -2092,12 +2206,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_fn_like_elision(\n         &mut self,\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n     ) {\n-        debug!(\"visit_fn_like_elision: enter\");\n         let arg_scope = Scope::Elision { elide: Elide::FreshLateAnon(Cell::new(0)), s: self.scope };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n@@ -2110,7 +2224,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             None => return,\n         };\n \n-        debug!(\"visit_fn_like_elision: determine output\");\n+        debug!(\"determine output\");\n \n         // Figure out if there's a body we can get argument names from,\n         // and whether there's a `self` argument (treated specially).\n@@ -2276,11 +2390,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             Elide::Error(arg_lifetimes)\n         };\n \n-        debug!(\"visit_fn_like_elision: elide={:?}\", elide);\n+        debug!(?elide);\n \n         let scope = Scope::Elision { elide, s: self.scope };\n         self.with(scope, |_, this| this.visit_ty(output));\n-        debug!(\"visit_fn_like_elision: exit\");\n \n         struct GatherLifetimes<'a> {\n             map: &'a NamedRegionMap,\n@@ -2743,12 +2856,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n         debug!(\n-            \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n-            def,\n-            self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n+            node = ?self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n+            span = ?self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n \n@@ -2762,12 +2874,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             | Region::EarlyBound(_, def_id, _) => {\n                 // A lifetime declared by the user.\n                 let track_lifetime_uses = self.track_lifetime_uses();\n-                debug!(\"insert_lifetime: track_lifetime_uses={}\", track_lifetime_uses);\n+                debug!(?track_lifetime_uses);\n                 if track_lifetime_uses && !self.lifetime_uses.contains_key(&def_id) {\n-                    debug!(\"insert_lifetime: first use of {:?}\", def_id);\n+                    debug!(\"first use of {:?}\", def_id);\n                     self.lifetime_uses.insert(def_id, LifetimeUseSet::One(lifetime_ref));\n                 } else {\n-                    debug!(\"insert_lifetime: many uses of {:?}\", def_id);\n+                    debug!(\"many uses of {:?}\", def_id);\n                     self.lifetime_uses.insert(def_id, LifetimeUseSet::Many);\n                 }\n             }"}, {"sha": "dbc518da8c83aee41db732507d7bc1fa1298e3ce", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -198,6 +198,7 @@ pub trait CreateSubstsForGenericArgsCtxt<'a, 'tcx> {\n }\n \n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     pub fn ast_region_to_region(\n         &self,\n         lifetime: &hir::Lifetime,\n@@ -237,6 +238,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             None => {\n                 self.re_infer(def, lifetime.span).unwrap_or_else(|| {\n+                    debug!(?lifetime, \"unelided lifetime in signature\");\n+\n                     // This indicates an illegal lifetime\n                     // elision. `resolve_lifetime` should have\n                     // reported an error in this case -- but if\n@@ -2173,9 +2176,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n     /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool) -> Ty<'tcx> {\n-        debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\", ast_ty.hir_id, ast_ty, ast_ty.kind);\n-\n         let tcx = self.tcx();\n \n         let result_ty = match ast_ty.kind {\n@@ -2185,7 +2187,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n-                debug!(\"ast_ty_to_ty: r={:?}\", r);\n+                debug!(?r);\n                 let t = self.ast_ty_to_ty_inner(&mt.ty, true);\n                 tcx.mk_ref(r, ty::TypeAndMut { ty: t, mutbl: mt.mutbl })\n             }\n@@ -2209,7 +2211,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed)\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n-                debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n+                debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n@@ -2225,7 +2227,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n-                debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n+                debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n                 let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n@@ -2270,7 +2272,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Err => tcx.ty_error(),\n         };\n \n-        debug!(\"ast_ty_to_ty: result_ty={:?}\", result_ty);\n+        debug!(?result_ty);\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty"}, {"sha": "b961fc8aeeb534e6ce27821f70ffa95a4aac1925", "filename": "src/test/ui/error-codes/E0106.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -23,17 +23,6 @@ LL |     A(u8),\n LL |     B(&'a bool),\n    |\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/E0106.rs:10:14\n-   |\n-LL | type MyStr = &str;\n-   |              ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL | type MyStr<'a> = &'a str;\n-   |           ^^^^   ^^^\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/E0106.rs:17:10\n    |\n@@ -61,6 +50,17 @@ LL |\n LL |     buzz: Buzz<'a, 'a>,\n    |\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/E0106.rs:10:14\n+   |\n+LL | type MyStr = &str;\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | type MyStr<'a> = &'a str;\n+   |           ^^^^   ^^^\n+\n error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "497b8a429e0ed2a1fb4084c7eff16bc611ecf0c5", "filename": "src/test/ui/feature-gates/feature-gate-in_band_lifetimes.stderr", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-in_band_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-in_band_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-in_band_lifetimes.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,87 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:50:14\n+   |\n+LL | impl MyTrait<'a> for Y<&'a u8> {\n+   |     -        ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'a` here: `<'a>`\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:50:25\n+   |\n+LL | impl MyTrait<'a> for Y<&'a u8> {\n+   |     -                   ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'a` here: `<'a>`\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:53:31\n+   |\n+LL |     fn my_lifetime(&self) -> &'a u8 { self.0 }\n+   |                               ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | impl<'a> MyTrait<'a> for Y<&'a u8> {\n+   |     ^^^^\n+help: consider introducing lifetime `'a` here\n+   |\n+LL |     fn my_lifetime<'a>(&self) -> &'a u8 { self.0 }\n+   |                   ^^^^\n+\n+error[E0261]: use of undeclared lifetime name `'b`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:55:27\n+   |\n+LL |     fn any_lifetime() -> &'b u8 { &0 }\n+   |                           ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n+   |     ^^^^\n+help: consider introducing lifetime `'b` here\n+   |\n+LL |     fn any_lifetime<'b>() -> &'b u8 { &0 }\n+   |                    ^^^^\n+\n+error[E0261]: use of undeclared lifetime name `'b`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:57:27\n+   |\n+LL |     fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n+   |                           ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n+   |     ^^^^\n+help: consider introducing lifetime `'b` here\n+   |\n+LL |     fn borrowed_lifetime<'b>(&'b self) -> &'b u8 { &*self.0 }\n+   |                         ^^^^\n+\n+error[E0261]: use of undeclared lifetime name `'b`\n+  --> $DIR/feature-gate-in_band_lifetimes.rs:57:40\n+   |\n+LL |     fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n+   |                                        ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n+   |     ^^^^\n+help: consider introducing lifetime `'b` here\n+   |\n+LL |     fn borrowed_lifetime<'b>(&'b self) -> &'b u8 { &*self.0 }\n+   |                         ^^^^\n+\n error[E0261]: use of undeclared lifetime name `'x`\n   --> $DIR/feature-gate-in_band_lifetimes.rs:3:12\n    |\n@@ -142,90 +226,6 @@ help: consider introducing lifetime `'b` here\n LL |     fn borrowed_lifetime<'b>(&'b self) -> &'b u8;\n    |                         ^^^^\n \n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:50:14\n-   |\n-LL | impl MyTrait<'a> for Y<&'a u8> {\n-   |     -        ^^ undeclared lifetime\n-   |     |\n-   |     help: consider introducing lifetime `'a` here: `<'a>`\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:50:25\n-   |\n-LL | impl MyTrait<'a> for Y<&'a u8> {\n-   |     -                   ^^ undeclared lifetime\n-   |     |\n-   |     help: consider introducing lifetime `'a` here: `<'a>`\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:53:31\n-   |\n-LL |     fn my_lifetime(&self) -> &'a u8 { self.0 }\n-   |                               ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-help: consider introducing lifetime `'a` here\n-   |\n-LL | impl<'a> MyTrait<'a> for Y<&'a u8> {\n-   |     ^^^^\n-help: consider introducing lifetime `'a` here\n-   |\n-LL |     fn my_lifetime<'a>(&self) -> &'a u8 { self.0 }\n-   |                   ^^^^\n-\n-error[E0261]: use of undeclared lifetime name `'b`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:55:27\n-   |\n-LL |     fn any_lifetime() -> &'b u8 { &0 }\n-   |                           ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-help: consider introducing lifetime `'b` here\n-   |\n-LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n-   |     ^^^^\n-help: consider introducing lifetime `'b` here\n-   |\n-LL |     fn any_lifetime<'b>() -> &'b u8 { &0 }\n-   |                    ^^^^\n-\n-error[E0261]: use of undeclared lifetime name `'b`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:57:27\n-   |\n-LL |     fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n-   |                           ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-help: consider introducing lifetime `'b` here\n-   |\n-LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n-   |     ^^^^\n-help: consider introducing lifetime `'b` here\n-   |\n-LL |     fn borrowed_lifetime<'b>(&'b self) -> &'b u8 { &*self.0 }\n-   |                         ^^^^\n-\n-error[E0261]: use of undeclared lifetime name `'b`\n-  --> $DIR/feature-gate-in_band_lifetimes.rs:57:40\n-   |\n-LL |     fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n-   |                                        ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-help: consider introducing lifetime `'b` here\n-   |\n-LL | impl<'b> MyTrait<'a> for Y<&'a u8> {\n-   |     ^^^^\n-help: consider introducing lifetime `'b` here\n-   |\n-LL |     fn borrowed_lifetime<'b>(&'b self) -> &'b u8 { &*self.0 }\n-   |                         ^^^^\n-\n error: aborting due to 17 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "d45ef83873af725b811cd28b1561c5a5f4f8c5aa", "filename": "src/test/ui/generic-associated-types/shadowing.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -14,14 +14,6 @@ LL | impl<T> NoShadowT<T> for Option<T> {\n LL |     type Bar<T> = i32;\n    |              ^ already used\n \n-error[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\n-  --> $DIR/shadowing.rs:5:14\n-   |\n-LL | trait Shadow<'a> {\n-   |              -- first declared here\n-LL |     type Bar<'a>;\n-   |              ^^ lifetime `'a` already in scope\n-\n error[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\n   --> $DIR/shadowing.rs:14:14\n    |\n@@ -30,6 +22,14 @@ LL | impl<'a> NoShadow<'a> for &'a u32 {\n LL |     type Bar<'a> = i32;\n    |              ^^ lifetime `'a` already in scope\n \n+error[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\n+  --> $DIR/shadowing.rs:5:14\n+   |\n+LL | trait Shadow<'a> {\n+   |              -- first declared here\n+LL |     type Bar<'a>;\n+   |              ^^ lifetime `'a` already in scope\n+\n error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0403, E0496."}, {"sha": "ce853d4d36ddd64982f7bf523feb94d63eff0383", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -4,6 +4,17 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n LL | fn should_error<T>() where T : Into<&u32> {}\n    |                                     ^ explicit lifetime name needed here\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:17\n+   |\n+LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n+   |                 ^ expected named lifetime parameter\n+   |\n+help: consider using the `'b` lifetime\n+   |\n+LL | fn bar<'b, L: X<'b, &'b Nested<i32>>>(){}\n+   |                 ^^^\n+\n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:21\n    |\n@@ -22,17 +33,6 @@ help: consider using one of the available lifetimes here\n LL |     fn foo<'b, L: X<'lifetime, &'b Nested<K>>>();\n    |                     ^^^^^^^^^^\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:17\n-   |\n-LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n-   |                 ^ expected named lifetime parameter\n-   |\n-help: consider using the `'b` lifetime\n-   |\n-LL | fn bar<'b, L: X<'b, &'b Nested<i32>>>(){}\n-   |                 ^^^\n-\n error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0106, E0637."}, {"sha": "94fdd355d48caacf560e0d740199587f33bb986d", "filename": "src/test/ui/generics/wrong-number-of-args.stderr", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,36 +1,3 @@\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:44:14\n-   |\n-LL |     type A = Ty;\n-   |              ^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type A<'a> = Ty<'a>;\n-   |           ^^^^   ^^^^^^\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:54:17\n-   |\n-LL |     type C = Ty<usize>;\n-   |                 ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type C<'a> = Ty<'a, usize>;\n-   |           ^^^^      ^^^\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:100:22\n-   |\n-LL |     type B = Box<dyn GenericLifetime>;\n-   |                      ^^^^^^^^^^^^^^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type B<'a> = Box<dyn GenericLifetime<'a>>;\n-   |           ^^^^           ^^^^^^^^^^^^^^^^^^^\n-\n error[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/wrong-number-of-args.rs:6:14\n    |\n@@ -165,6 +132,17 @@ help: use angle brackets to add missing type argument\n LL |     type A = Ty<T>;\n    |                ^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:44:14\n+   |\n+LL |     type A = Ty;\n+   |              ^^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type A<'a> = Ty<'a>;\n+   |           ^^^^   ^^^^^^\n+\n error[E0107]: this struct takes 1 type argument but 0 type arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:50:14\n    |\n@@ -181,6 +159,17 @@ help: add missing type argument\n LL |     type B = Ty<'static, T>;\n    |                        ^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:54:17\n+   |\n+LL |     type C = Ty<usize>;\n+   |                 ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type C<'a> = Ty<'a, usize>;\n+   |           ^^^^      ^^^\n+\n error[E0107]: missing generics for struct `type_and_type_and_type::Ty`\n   --> $DIR/wrong-number-of-args.rs:64:14\n    |\n@@ -243,6 +232,17 @@ note: trait defined here, with 0 type parameters\n LL |     trait NonGeneric {\n    |           ^^^^^^^^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:100:22\n+   |\n+LL |     type B = Box<dyn GenericLifetime>;\n+   |                      ^^^^^^^^^^^^^^^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type B<'a> = Box<dyn GenericLifetime<'a>>;\n+   |           ^^^^           ^^^^^^^^^^^^^^^^^^^\n+\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:104:22\n    |"}, {"sha": "3b407871e37e1aea2766178153d1a4b1cecd851e", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -7,7 +7,7 @@ fn foo(x: &u32) {\n \n fn foo2(x: &u32) {}\n fn bar() {\n-    let y: fn(&'test u32) = foo2; //~ ERROR use of undeclared lifetime\n+    let y: fn(&'test u32) = foo2;\n }\n \n fn main() {}"}, {"sha": "7ecb6ff0c9da9f070a6695395224eb98cd0038b1", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.stderr", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -6,22 +6,6 @@ LL | fn foo(x: &u32) {\n LL |     let y: &'test u32 = x;\n    |             ^^^^^ undeclared lifetime\n \n-error[E0261]: use of undeclared lifetime name `'test`\n-  --> $DIR/no_introducing_in_band_in_locals.rs:10:16\n-   |\n-LL |     let y: fn(&'test u32) = foo2;\n-   |                ^^^^^ undeclared lifetime\n-   |\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider introducing lifetime `'test` here\n-   |\n-LL | fn bar<'test>() {\n-   |       ^^^^^^^\n-help: consider making the type lifetime-generic with a new `'test` lifetime\n-   |\n-LL |     let y: for<'test> fn(&'test u32) = foo2;\n-   |            ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "16333a7ca380c68e6a72400393cc6e0b60c32c5d", "filename": "src/test/ui/lifetimes/undeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,13 @@\n+error[E0261]: use of undeclared lifetime name `'b`\n+  --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:3:9\n+   |\n+LL | struct Test {\n+   |            - help: consider introducing lifetime `'b` here: `<'b>`\n+LL |     a: &'b str,\n+   |         ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:13:13\n    |\n@@ -14,16 +24,6 @@ help: consider introducing lifetime `'b` here\n LL |     fn foo<'b>(&'b self) {}\n    |           ^^^^\n \n-error[E0261]: use of undeclared lifetime name `'b`\n-  --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:3:9\n-   |\n-LL | struct Test {\n-   |            - help: consider introducing lifetime `'b` here: `<'b>`\n-LL |     a: &'b str,\n-   |         ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:3:9\n    |"}, {"sha": "d7760985ec6f0c2bfad5508e96b1d2ef5c72d2af", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,5 @@\n fn main() {\n     0.clone::<'a>(); //~ ERROR use of undeclared lifetime name `'a`\n+    //~^ WARNING cannot specify lifetime arguments\n+    //~| WARNING this was previously accepted\n }"}, {"sha": "5a958bc4b9c312fb164770fbc53365fffc65a212", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,18 @@\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/method-call-lifetime-args-unresolved.rs:2:15\n+   |\n+LL |     0.clone::<'a>();\n+   |               ^^\n+   | \n+  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |              - the late bound lifetime parameter is introduced here\n+   |\n+   = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+\n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/method-call-lifetime-args-unresolved.rs:2:15\n    |\n@@ -8,6 +23,6 @@ LL |     0.clone::<'a>();\n    |\n    = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "6aa34354a7ad947ca048e74bc57f1db900ebbc37", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -8,7 +8,7 @@ struct ChunkingIterator<T, S: 'static + Iterator<Item = T>> {\n impl<T, S: Iterator<Item = T>> Iterator for ChunkingIterator<T, S> {\n     type Item = IteratorChunk<T, S>; //~ ERROR missing lifetime\n \n-    fn next(&mut self) -> Option<IteratorChunk<T, S>> { //~ ERROR `impl`\n+    fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n         todo!()\n     }\n }"}, {"sha": "1e035ff99d0bcbb94b6d4099052028e47ecd42ed", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -9,22 +9,6 @@ help: consider introducing a named lifetime parameter\n LL |     type Item<'a> = IteratorChunk<'a, T, S>;\n    |              ^^^^                 ^^^\n \n-error: `impl` item signature doesn't match `trait` item signature\n-  --> $DIR/issue-74918-missing-lifetime.rs:11:5\n-   |\n-LL |     fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'_, T, S>>`\n-   | \n-  ::: $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn next(&mut self) -> Option<Self::Item>;\n-   |     ----------------------------------------- expected `fn(&mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, _, _>>`\n-   |\n-   = note: expected `fn(&mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, _, _>>`\n-              found `fn(&mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'_, _, _>>`\n-   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n-   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "5f6ff280e6531e38742e1afa2de99f0555eb83a7", "filename": "src/test/ui/regions/regions-name-undeclared.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,3 +1,23 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/regions-name-undeclared.rs:28:13\n+   |\n+LL |     enum E {\n+   |           - help: consider introducing lifetime `'a` here: `<'a>`\n+LL |         E1(&'a isize)\n+   |             ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/regions-name-undeclared.rs:31:13\n+   |\n+LL |     struct S {\n+   |             - help: consider introducing lifetime `'a` here: `<'a>`\n+LL |         f: &'a isize\n+   |             ^^ undeclared lifetime\n+   |\n+   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n+\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:16:24\n    |\n@@ -56,26 +76,6 @@ LL |     type X = Option<&'a isize>;\n    |\n    = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n \n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/regions-name-undeclared.rs:28:13\n-   |\n-LL |     enum E {\n-   |           - help: consider introducing lifetime `'a` here: `<'a>`\n-LL |         E1(&'a isize)\n-   |             ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/regions-name-undeclared.rs:31:13\n-   |\n-LL |     struct S {\n-   |             - help: consider introducing lifetime `'a` here: `<'a>`\n-LL |         f: &'a isize\n-   |             ^^ undeclared lifetime\n-   |\n-   = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n-\n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/regions-name-undeclared.rs:33:14\n    |"}, {"sha": "dd434ea5318781753c9ec94bbf55a6ada781a323", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -16,14 +16,13 @@ fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n where\n     G: Get<T>\n {\n-    move || { //~ ERROR `dest`\n+    move || {\n         *dest = g.get();\n     }\n }\n \n // After applying suggestion for `foo`:\n fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-//~^ ERROR the parameter type `G` may not live long enough\n where\n     G: Get<T>\n {\n@@ -45,7 +44,6 @@ where\n \n // After applying suggestion for `baz`:\n fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-//~^ ERROR the parameter type `G` may not live long enough\n where\n     G: Get<T>\n {\n@@ -57,7 +55,6 @@ where\n // Same as above, but show that we pay attention to lifetime names from parent item\n impl<'a> Foo {\n     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-        //~^ ERROR the parameter type `G` may not live long enough\n         move || {\n             *dest = g.get();\n         }\n@@ -66,7 +63,6 @@ impl<'a> Foo {\n \n // After applying suggestion for `qux`:\n fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-//~^ ERROR explicit lifetime required in the type of `dest`\n where\n     G: Get<T>\n {\n@@ -77,7 +73,6 @@ where\n \n // Potential incorrect attempt:\n fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n-//~^ ERROR the parameter type `G` may not live long enough\n where\n     G: Get<T>\n {"}, {"sha": "916a6c2bf12af6277f3affdfbb205a216295f3dc", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 3, "deletions": 104, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -1,112 +1,11 @@\n error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+  --> $DIR/missing-lifetimes-in-signature.rs:36:11\n    |\n LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        -  ^^ undeclared lifetime\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error[E0759]: `dest` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n-   |\n-LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n-   |                            ------ this data with an anonymous lifetime `'_`...\n-...\n-LL | /     move || {\n-LL | |         *dest = g.get();\n-LL | |     }\n-   | |_____^ ...is captured here...\n-   |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/missing-lifetimes-in-signature.rs:15:37\n-   |\n-LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n-   |                                     ^^^^^^^^^^^^^\n-help: to declare that the `impl Trait` captures data from argument `dest`, you can add an explicit `'_` lifetime bound\n-   |\n-LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                                   ^^^^\n-\n-error[E0311]: the parameter type `G` may not live long enough\n-  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n-   |\n-LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                     ^^^^^^^^^^^^^^^^^^\n-   |\n-note: the parameter type `G` must be valid for the anonymous lifetime defined on the function body at 25:26...\n-  --> $DIR/missing-lifetimes-in-signature.rs:25:26\n-   |\n-LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                          ^^^^^^\n-note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:30:5: 32:6]` will meet its required lifetime bounds\n-  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n-   |\n-LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                     ^^^^^^^^^^^^^^^^^^\n-help: consider introducing an explicit lifetime bound\n-   |\n-LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-   |        ^^^^^                                                   ^^^^\n-\n-error[E0311]: the parameter type `G` may not live long enough\n-  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n-   |\n-LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                             ^^^^^^^^^^^^^^^^^^\n-   |\n-note: the parameter type `G` must be valid for the anonymous lifetime defined on the function body at 47:34...\n-  --> $DIR/missing-lifetimes-in-signature.rs:47:34\n-   |\n-LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                  ^^^^^^\n-note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:52:5: 54:6]` will meet its required lifetime bounds\n-  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n-   |\n-LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                                             ^^^^^^^^^^^^^^^^^^\n-help: consider introducing an explicit lifetime bound\n-   |\n-LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n-   |        ^^^     ^^^^^^^                                                  ^^^^\n-\n-error[E0311]: the parameter type `G` may not live long enough\n-  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n-   |\n-LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-   |                                                          ^^^^^^^^^^^^^^^^^^\n-   |\n-note: the parameter type `G` must be valid for the anonymous lifetime defined on the method body at 59:47...\n-  --> $DIR/missing-lifetimes-in-signature.rs:59:47\n-   |\n-LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-   |                                               ^^^^^^\n-note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:61:9: 63:10]` will meet its required lifetime bounds\n-  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n-   |\n-LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-   |                                                          ^^^^^^^^^^^^^^^^^^\n-help: consider introducing an explicit lifetime bound\n-   |\n-LL |     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n-   |            ^^^     ^^^^^^^                                                           ^^^^\n-\n-error[E0621]: explicit lifetime required in the type of `dest`\n-  --> $DIR/missing-lifetimes-in-signature.rs:68:45\n-   |\n-LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-   |                                  ------     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required\n-   |                                  |\n-   |                                  help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n-\n-error[E0309]: the parameter type `G` may not live long enough\n-  --> $DIR/missing-lifetimes-in-signature.rs:79:44\n-   |\n-LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n-   |            -                               ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:84:5: 86:6]` will meet its required lifetime bounds\n-   |            |\n-   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0261, E0309, E0621, E0759.\n-For more information about an error, try `rustc --explain E0261`.\n+For more information about this error, try `rustc --explain E0261`."}, {"sha": "489926ea78a9d5f93a63f8d0ce248aa5cad53a97", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ecfcd0e2ae01c79159888a45042a5d6f4ed487/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "patch": "@@ -142,30 +142,6 @@ help: consider using the `'static` lifetime\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                 ^^^^^^^^^^^^^^^^^\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:50:44\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^^^^^^^^\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:50:44\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^^^^^^^^\n-\n error[E0107]: this union takes 2 lifetime arguments but only 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n@@ -256,6 +232,18 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        ^^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:50:44\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n error[E0107]: this trait takes 2 lifetime arguments but only 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:50:45\n    |\n@@ -274,6 +262,18 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        ^^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:50:44\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^^^^^^\n+\n error[E0107]: this trait takes 2 lifetime arguments but only 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:50:45\n    |"}]}