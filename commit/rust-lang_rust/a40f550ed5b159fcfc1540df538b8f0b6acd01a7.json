{"sha": "a40f550ed5b159fcfc1540df538b8f0b6acd01a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MGY1NTBlZDViMTU5ZmNmYzE1NDBkZjUzOGI4ZjBiNmFjZDAxYTc=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-18T17:27:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std: more docs and some methods for types in net::tcp", "tree": {"sha": "58675dc0ac4c9ea6b33bdc14b3ba90881f54df71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58675dc0ac4c9ea6b33bdc14b3ba90881f54df71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40f550ed5b159fcfc1540df538b8f0b6acd01a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40f550ed5b159fcfc1540df538b8f0b6acd01a7", "html_url": "https://github.com/rust-lang/rust/commit/a40f550ed5b159fcfc1540df538b8f0b6acd01a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40f550ed5b159fcfc1540df538b8f0b6acd01a7/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4b1e965e2815924f6ae1a0cac8a327b41ee4608", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b1e965e2815924f6ae1a0cac8a327b41ee4608", "html_url": "https://github.com/rust-lang/rust/commit/a4b1e965e2815924f6ae1a0cac8a327b41ee4608"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "ef21baea982166627d6ba1ca45bb4e3ae46a8ce4", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a40f550ed5b159fcfc1540df538b8f0b6acd01a7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40f550ed5b159fcfc1540df538b8f0b6acd01a7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a40f550ed5b159fcfc1540df538b8f0b6acd01a7", "patch": "@@ -12,9 +12,12 @@ export tcp_socket, tcp_conn_port, tcp_err_data;\n // operations on a tcp_socket\n export write, read_start, read_stop;\n // tcp server stuff\n-export new_listener, listen_for_conn, accept, conn_recv;\n+export listen_for_conn, accept;\n+export new_listener, conn_recv, conn_recv_spawn, conn_peek;\n // tcp client stuff\n export connect;\n+// helper methods\n+export conn_port_methods, sock_methods;\n \n #[nolink]\n native mod rustrt {\n@@ -410,6 +413,8 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint)\n #[doc=\"\n Block on a `net::tcp::tcp_conn_port` until a new connection arrives\n \n+This function behaves similarly to `comm::recv()`\n+\n # Arguments\n \n * server_port -- a `net::tcp::tcp_conn_port` that you wish to listen\n@@ -436,6 +441,22 @@ fn conn_recv(server_port: tcp_conn_port)\n     }\n }\n \n+#[doc=\"\n+Identical to `net::tcp::conn_recv`, but ran on a new task\n+\n+The recv'd tcp_socket is created with a new task on the current scheduler,\n+and given as a parameter to the provided callback\n+\n+# Arguments\n+\n+* `server_port` -- a `net::tcp::tcp_conn_port` that you wish to listen\n+on for an incoming connection\n+* `cb` -- a callback that will be ran, in a new task on the current scheduler,\n+once a new connection is recv'd. Its parameter:\n+  * A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n+    use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n+    variant\n+\"]\n fn conn_recv_spawn(server_port: tcp_conn_port,\n                    cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n     let new_conn_po = (**server_port).new_conn_po;\n@@ -454,6 +475,19 @@ fn conn_recv_spawn(server_port: tcp_conn_port,\n     };\n }\n \n+#[doc=\"\n+Check if a `net::tcp::tcp_conn_port` has one-or-more pending, new connections\n+\n+This function behaves similarly to `comm::peek()`\n+\n+# Arguments\n+\n+* `server_port` -- a `net::tcp::tcp_conn_port` representing a server connection\n+\n+# Returns\n+\n+`true` if there are one-or-more pending connections, `false` if there are none.\n+\"]\n fn conn_peek(server_port: tcp_conn_port) -> bool {\n     let new_conn_po = (**server_port).new_conn_po;\n     comm::peek(new_conn_po)\n@@ -713,6 +747,33 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n+#[doc=\"\n+Convenience methods extending `net::tcp::tcp_conn_port`\n+\"]\n+impl conn_port_methods for tcp_conn_port {\n+    fn recv() -> result::result<tcp_socket, tcp_err_data> { conn_recv(self) }\n+    fn recv_spawn(cb: fn~(result::result<tcp_socket,tcp_err_data>))\n+                  { conn_recv_spawn(self, cb); }\n+    fn peek() -> bool { conn_peek(self) }\n+}\n+\n+#[doc=\"\n+Convenience methods extending `net::tcp::tcp_socket`\n+\"]\n+impl sock_methods for tcp_socket {\n+    fn read_start() -> result::result<comm::port<\n+        result::result<[u8], tcp_err_data>>, tcp_err_data> {\n+        read_start(self)\n+    }\n+    fn read_stop() ->\n+        result::result<(), tcp_err_data> {\n+        read_stop(self)\n+    }\n+    fn write(raw_write_data: [[u8]])\n+        -> result::result<(), tcp_err_data> {\n+        write(self, raw_write_data)\n+    }\n+}\n // INTERNAL API\n \n // various recv_* can use a tcp_conn_port can re-use this..\n@@ -1256,7 +1317,7 @@ mod test {\n             // receive a single new connection.. normally this'd be\n             // in a loop {}, but we're just going to take a single\n             // client.. get their req, write a resp and then exit\n-            let new_conn_result = conn_recv(server_port);\n+            let new_conn_result = server_port.recv();\n             if result::is_failure(new_conn_result) {\n                 let err_data = result::get_err(new_conn_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n@@ -1324,7 +1385,7 @@ mod test {\n     fn tcp_read_single(sock: tcp_socket)\n         -> result::result<[u8],tcp_err_data> {\n         log(debug, \"starting tcp_read_single\");\n-        let rs_result = read_start(sock);\n+        let rs_result = sock.read_start();\n         if result::is_failure(rs_result) {\n             let err_data = result::get_err(rs_result);\n             result::err(err_data)\n@@ -1345,14 +1406,15 @@ mod test {\n               }\n               some(data_result) {\n                 log(debug, \"tcp_read_single: got data\");\n+                sock.read_stop();\n                 data_result\n               }\n             }\n         }\n     }\n \n     fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n-        let write_result = write(sock, [val]);\n+        let write_result = sock.write([val]);\n         if result::is_failure(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);"}]}