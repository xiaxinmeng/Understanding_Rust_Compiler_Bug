{"sha": "5974ec745e97af456e50a04473e468db9007bd07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NzRlYzc0NWU5N2FmNDU2ZTUwYTA0NDczZTQ2OGRiOTAwN2JkMDc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-22T11:00:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-23T17:47:28Z"}, "message": "incr.comp.: Serialize and deserialize new DepGraph", "tree": {"sha": "a26e515bdfb1df85f06f4f3ec767a7d5b8ab4512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26e515bdfb1df85f06f4f3ec767a7d5b8ab4512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5974ec745e97af456e50a04473e468db9007bd07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5974ec745e97af456e50a04473e468db9007bd07", "html_url": "https://github.com/rust-lang/rust/commit/5974ec745e97af456e50a04473e468db9007bd07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5974ec745e97af456e50a04473e468db9007bd07/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7428da41581a0af2bf9990a193b151ab9b1b816", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7428da41581a0af2bf9990a193b151ab9b1b816", "html_url": "https://github.com/rust-lang/rust/commit/a7428da41581a0af2bf9990a193b151ab9b1b816"}], "stats": {"total": 328, "additions": 264, "deletions": 64}, "files": [{"sha": "2ac3884dce1a5f99cc4586ea4765fa2a30b27787", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -25,6 +25,8 @@ use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n use super::edges::{self, DepGraphEdges};\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::prev::PreviousDepGraph;\n \n #[derive(Clone)]\n pub struct DepGraph {\n@@ -68,6 +70,10 @@ struct DepGraphData {\n     /// current one anymore.\n     current: RefCell<CurrentDepGraph>,\n \n+    /// The dep-graph from the previous compilation session. It contains all\n+    /// nodes and edges as well as all fingerprints of nodes that have them.\n+    previous: PreviousDepGraph,\n+\n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n@@ -81,19 +87,24 @@ struct DepGraphData {\n }\n \n impl DepGraph {\n-    pub fn new(enabled: bool) -> DepGraph {\n+\n+    pub fn new(prev_graph: PreviousDepGraph) -> DepGraph {\n         DepGraph {\n-            data: if enabled {\n-                Some(Rc::new(DepGraphData {\n-                    previous_work_products: RefCell::new(FxHashMap()),\n-                    work_products: RefCell::new(FxHashMap()),\n-                    edges: RefCell::new(DepGraphEdges::new()),\n-                    dep_node_debug: RefCell::new(FxHashMap()),\n-                    current: RefCell::new(CurrentDepGraph::new()),\n-                }))\n-            } else {\n-                None\n-            },\n+            data: Some(Rc::new(DepGraphData {\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n+                edges: RefCell::new(DepGraphEdges::new()),\n+                dep_node_debug: RefCell::new(FxHashMap()),\n+                current: RefCell::new(CurrentDepGraph::new()),\n+                previous: prev_graph,\n+            })),\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n+        }\n+    }\n+\n+    pub fn new_disabled() -> DepGraph {\n+        DepGraph {\n+            data: None,\n             fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n     }\n@@ -231,7 +242,16 @@ impl DepGraph {\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().read(v);\n-            data.current.borrow_mut().read(v);\n+\n+            let mut current = data.current.borrow_mut();\n+            debug_assert!(current.node_to_node_index.contains_key(&v),\n+                          \"DepKind {:?} should be pre-allocated but isn't.\",\n+                          v.kind);\n+            if let Some(&dep_node_index_new) = current.node_to_node_index.get(&v) {\n+                current.read_index(dep_node_index_new);\n+            } else {\n+                bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n+            }\n         }\n     }\n \n@@ -254,22 +274,12 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n-    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n-        if let Some(ref data) = self.data {\n-            let dep_node_index_legacy = data.edges.borrow_mut().add_node(node);\n-            let dep_node_index_new = data.current.borrow_mut()\n-                                                 .alloc_node(node, Vec::new());\n-            DepNodeIndex {\n-                legacy: dep_node_index_legacy,\n-                new: dep_node_index_new,\n-            }\n-        } else {\n-            DepNodeIndex::INVALID\n-        }\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.fingerprints.borrow()[dep_node]\n     }\n \n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        self.fingerprints.borrow().get(dep_node).cloned()\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     /// Indicates that a previous work product exists for `v`. This is\n@@ -338,6 +348,44 @@ impl DepGraph {\n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n         self.data.as_ref().and_then(|t| t.dep_node_debug.borrow().get(&dep_node).cloned())\n     }\n+\n+    pub fn serialize(&self) -> SerializedDepGraph {\n+        let fingerprints = self.fingerprints.borrow();\n+        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+\n+        let nodes: IndexVec<_, _> = current_dep_graph.nodes.iter().map(|dep_node| {\n+            let fingerprint = fingerprints.get(dep_node)\n+                                          .cloned()\n+                                          .unwrap_or(Fingerprint::zero());\n+            (*dep_node, fingerprint)\n+        }).collect();\n+\n+        let total_edge_count: usize = current_dep_graph.edges.iter()\n+                                                             .map(|v| v.len())\n+                                                             .sum();\n+\n+        let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n+        let mut edge_list_data = Vec::with_capacity(total_edge_count);\n+\n+        for (current_dep_node_index, edges) in current_dep_graph.edges.iter_enumerated() {\n+            let start = edge_list_data.len() as u32;\n+            // This should really just be a memcpy :/\n+            edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex(i.index)));\n+            let end = edge_list_data.len() as u32;\n+\n+            debug_assert_eq!(current_dep_node_index.index(), edge_list_indices.len());\n+            edge_list_indices.push((start, end));\n+        }\n+\n+        debug_assert!(edge_list_data.len() <= ::std::u32::MAX as usize);\n+        debug_assert_eq!(edge_list_data.len(), total_edge_count);\n+\n+        SerializedDepGraph {\n+            nodes,\n+            edge_list_indices,\n+            edge_list_data,\n+        }\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -478,11 +526,6 @@ impl CurrentDepGraph {\n         }\n     }\n \n-    fn read(&mut self, source: DepNode) {\n-        let dep_node_index = self.maybe_alloc_node(source);\n-        self.read_index(dep_node_index);\n-    }\n-\n     fn read_index(&mut self, source: DepNodeIndexNew) {\n         match self.task_stack.last_mut() {\n             Some(&mut OpenTask::Regular {\n@@ -521,27 +564,6 @@ impl CurrentDepGraph {\n         self.edges.push(edges);\n         dep_node_index\n     }\n-\n-    fn maybe_alloc_node(&mut self,\n-                        dep_node: DepNode)\n-                        -> DepNodeIndexNew {\n-        debug_assert_eq!(self.edges.len(), self.nodes.len());\n-        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n-\n-        let CurrentDepGraph {\n-            ref mut node_to_node_index,\n-            ref mut nodes,\n-            ref mut edges,\n-            ..\n-        } = *self;\n-\n-        *node_to_node_index.entry(dep_node).or_insert_with(|| {\n-            let next_id = nodes.len();\n-            nodes.push(dep_node);\n-            edges.push(Vec::new());\n-            DepNodeIndexNew::new(next_id)\n-        })\n-    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "cd77e06bdd6b03c6ace7f0e802ad2d279a0ca4a7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -13,18 +13,17 @@ mod dep_node;\n mod dep_tracking_map;\n mod edges;\n mod graph;\n+mod prev;\n mod query;\n mod raii;\n mod safe;\n+mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-pub use self::dep_node::DepNode;\n-pub use self::dep_node::WorkProductId;\n-pub use self::graph::DepGraph;\n-pub use self::graph::WorkProduct;\n-pub use self::graph::DepNodeIndex;\n+pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex};\n+pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-\n-pub use self::dep_node::{DepKind, DepConstructor};\n+pub use self::serialized::SerializedDepGraph;"}, {"sha": "882ca0414ccc9cdaec44161f6a960d81bbcba45b", "filename": "src/librustc/dep_graph/prev.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ich::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use super::dep_node::DepNode;\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph {\n+    data: SerializedDepGraph,\n+    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+}\n+\n+impl PreviousDepGraph {\n+    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+        let index: FxHashMap<_, _> = data.nodes\n+            .iter_enumerated()\n+            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .collect();\n+        PreviousDepGraph { data, index }\n+    }\n+\n+    pub fn with_edges_from<F>(&self, dep_node: &DepNode, mut f: F)\n+    where\n+        F: FnMut(&(DepNode, Fingerprint)),\n+    {\n+        let node_index = self.index[dep_node];\n+        self.data\n+            .edge_targets_from(node_index)\n+            .into_iter()\n+            .for_each(|&index| f(&self.data.nodes[index]));\n+    }\n+\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        let node_index = self.index[dep_node];\n+        self.data.nodes[node_index].1\n+    }\n+}"}, {"sha": "21beac9214eef9e3a9504a08f331c9f3a64d23b5", "filename": "src/librustc/dep_graph/serialized.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The data that we will serialize and deserialize.\n+\n+use dep_graph::DepNode;\n+use ich::Fingerprint;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+/// The index of a DepNode in the SerializedDepGraph::nodes array.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepNodeIndex(pub u32);\n+\n+impl SerializedDepNodeIndex {\n+    #[inline]\n+    pub fn new(idx: usize) -> SerializedDepNodeIndex {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        SerializedDepNodeIndex(idx as u32)\n+    }\n+}\n+\n+impl Idx for SerializedDepNodeIndex {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        SerializedDepNodeIndex(idx as u32)\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Data for use when recompiling the **current crate**.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph {\n+    /// The set of all DepNodes in the graph\n+    pub nodes: IndexVec<SerializedDepNodeIndex, (DepNode, Fingerprint)>,\n+    /// For each DepNode, stores the list of edges originating from that\n+    /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n+    /// which holds the actual DepNodeIndices of the target nodes.\n+    pub edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)>,\n+    /// A flattened list of all edge targets in the graph. Edge sources are\n+    /// implicit in edge_list_indices.\n+    pub edge_list_data: Vec<SerializedDepNodeIndex>,\n+}\n+\n+impl SerializedDepGraph {\n+\n+    pub fn new() -> SerializedDepGraph {\n+        SerializedDepGraph {\n+            nodes: IndexVec::new(),\n+            edge_list_indices: IndexVec::new(),\n+            edge_list_data: Vec::new(),\n+        }\n+    }\n+\n+    pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n+        let targets = self.edge_list_indices[source];\n+        &self.edge_list_data[targets.0 as usize..targets.1 as usize]\n+    }\n+}"}, {"sha": "bcfbc1980cf6a986f288ca888042355041721ee4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -643,7 +643,16 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         &crate_name,\n         &disambiguator.as_str(),\n     );\n-    let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n+\n+    let dep_graph = if sess.opts.build_dep_graph() {\n+        let prev_dep_graph = time(time_passes, \"load prev dep-graph (new)\", || {\n+            rustc_incremental::load_dep_graph_new(sess)\n+        });\n+\n+        DepGraph::new(prev_dep_graph)\n+    } else {\n+        DepGraph::new_disabled()\n+    };\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n@@ -713,7 +722,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n-    let _ignore = dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,"}, {"sha": "0fba6d8e9c67d13403e03f1d8d2807cc90cf8922", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -32,6 +32,7 @@ mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use persist::load_dep_graph;\n+pub use persist::load_dep_graph_new;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;\n pub use persist::save_work_products;"}, {"sha": "ccd2fdb608939bd1ab11ddd8d1fc32797f3657ab", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -132,6 +132,7 @@ use std::__rand::{thread_rng, Rng};\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n+const DEP_GRAPH_NEW_FILENAME: &'static str = \"dep-graph-new.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n \n@@ -145,6 +146,10 @@ pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n \n+pub fn dep_graph_path_new(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, DEP_GRAPH_NEW_FILENAME)\n+}\n+\n pub fn work_products_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, WORK_PRODUCTS_FILENAME)\n }"}, {"sha": "9e2036c522f7a233a501c316a2d7d46d5d1b2d32", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -433,3 +433,38 @@ fn process_edge<'a, 'tcx, 'edges>(\n         }\n     }\n }\n+\n+pub fn load_dep_graph_new(sess: &Session) -> PreviousDepGraph {\n+    use rustc::dep_graph::SerializedDepGraph as SerializedDepGraphNew;\n+\n+    let empty = PreviousDepGraph::new(SerializedDepGraphNew::new());\n+\n+    if sess.opts.incremental.is_none() {\n+        return empty\n+    }\n+\n+    if let Some(bytes) = load_data(sess, &dep_graph_path_new(sess)) {\n+        let mut decoder = Decoder::new(&bytes, 0);\n+        let prev_commandline_args_hash = u64::decode(&mut decoder)\n+            .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+\n+        if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n+            if sess.opts.debugging_opts.incremental_info {\n+                eprintln!(\"incremental: completely ignoring cache because of \\\n+                           differing commandline arguments\");\n+            }\n+            // We can't reuse the cache, purge it.\n+            debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n+\n+            // No need to do any further work\n+            return empty\n+        }\n+\n+        let dep_graph = SerializedDepGraphNew::decode(&mut decoder)\n+            .expect(\"Error reading cached dep-graph\");\n+\n+        PreviousDepGraph::new(dep_graph)\n+    } else {\n+        empty\n+    }\n+}"}, {"sha": "6514cb8555a7f27c6051e82f54b6a96514d7d403", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -26,6 +26,7 @@ pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;\n pub use self::load::load_dep_graph;\n+pub use self::load::load_dep_graph_new;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;"}, {"sha": "bc8cfd7da352d81b7ee86d0494fe24dfcdea6e1e", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -174,6 +174,19 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n+fn encode_dep_graph_new(tcx: TyCtxt,\n+                        encoder: &mut Encoder)\n+                        -> io::Result<()> {\n+    // First encode the commandline arguments hash\n+    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n+\n+    // Encode the graph data.\n+    let serialized_graph = tcx.dep_graph.serialize();\n+    serialized_graph.encode(encoder)?;\n+\n+    Ok(())\n+}\n+\n pub fn encode_dep_graph(tcx: TyCtxt,\n                         preds: &Predecessors,\n                         encoder: &mut Encoder)"}, {"sha": "74d610d1d120a28e52eab031752fa2598710372b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -942,8 +942,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n \n     let crate_hash = tcx.dep_graph\n-                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate))\n-                        .unwrap();\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n     let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n "}]}