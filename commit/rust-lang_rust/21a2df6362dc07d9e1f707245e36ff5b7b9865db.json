{"sha": "21a2df6362dc07d9e1f707245e36ff5b7b9865db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYTJkZjYzNjJkYzA3ZDllMWY3MDcyNDVlMzZmZjViN2I5ODY1ZGI=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-01-11T15:52:51Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-01-14T21:17:03Z"}, "message": "Remove old obsolete syntax errors", "tree": {"sha": "bace0fd81116f52c586dc01bfbbd05102bf20af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bace0fd81116f52c586dc01bfbbd05102bf20af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21a2df6362dc07d9e1f707245e36ff5b7b9865db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21a2df6362dc07d9e1f707245e36ff5b7b9865db", "html_url": "https://github.com/rust-lang/rust/commit/21a2df6362dc07d9e1f707245e36ff5b7b9865db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21a2df6362dc07d9e1f707245e36ff5b7b9865db/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "896cb36ecab3eaeb7f101087e030e43771eca5ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/896cb36ecab3eaeb7f101087e030e43771eca5ca", "html_url": "https://github.com/rust-lang/rust/commit/896cb36ecab3eaeb7f101087e030e43771eca5ca"}], "stats": {"total": 172, "additions": 4, "deletions": 168}, "files": [{"sha": "9d03ec73af8b127f0f0fa4e606d9510d23fb89e7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/21a2df6362dc07d9e1f707245e36ff5b7b9865db/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21a2df6362dc07d9e1f707245e36ff5b7b9865db/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=21a2df6362dc07d9e1f707245e36ff5b7b9865db", "patch": "@@ -24,14 +24,6 @@ use ptr::P;\n pub enum ObsoleteSyntax {\n     Sized,\n     ForSized,\n-    OwnedType,\n-    OwnedExpr,\n-    OwnedPattern,\n-    OwnedVector,\n-    OwnedSelf,\n-    ImportRenaming,\n-    SubsliceMatch,\n-    ExternCrateRenaming,\n     ProcType,\n     ProcExpr,\n     ClosureType,\n@@ -69,38 +61,6 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`proc` expression\",\n                 \"use a `move ||` expression instead\",\n             ),\n-            ObsoleteSyntax::OwnedType => (\n-                \"`~` notation for owned pointers\",\n-                \"use `Box<T>` in `std::owned` instead\"\n-            ),\n-            ObsoleteSyntax::OwnedExpr => (\n-                \"`~` notation for owned pointer allocation\",\n-                \"use the `box` operator instead of `~`\"\n-            ),\n-            ObsoleteSyntax::OwnedPattern => (\n-                \"`~` notation for owned pointer patterns\",\n-                \"use the `box` operator instead of `~`\"\n-            ),\n-            ObsoleteSyntax::OwnedVector => (\n-                \"`~[T]` is no longer a type\",\n-                \"use the `Vec` type instead\"\n-            ),\n-            ObsoleteSyntax::OwnedSelf => (\n-                \"`~self` is no longer supported\",\n-                \"write `self: Box<Self>` instead\"\n-            ),\n-            ObsoleteSyntax::ImportRenaming => (\n-                \"`use foo = bar` syntax\",\n-                \"write `use bar as foo` instead\"\n-            ),\n-            ObsoleteSyntax::SubsliceMatch => (\n-                \"subslice match syntax\",\n-                \"instead of `..xs`, write `xs..` in a pattern\"\n-            ),\n-            ObsoleteSyntax::ExternCrateRenaming => (\n-                \"`extern crate foo = bar` syntax\",\n-                \"write `extern crate bar as foo` instead\"\n-            ),\n             ObsoleteSyntax::ClosureType => (\n                 \"`|uint| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\""}, {"sha": "c09ae7b220bb49d30bc867f1d83f2ec863a85cba", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 128, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/21a2df6362dc07d9e1f707245e36ff5b7b9865db/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21a2df6362dc07d9e1f707245e36ff5b7b9865db/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=21a2df6362dc07d9e1f707245e36ff5b7b9865db", "patch": "@@ -71,7 +71,7 @@ use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n-use parse::obsolete::*;\n+use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n@@ -1404,22 +1404,6 @@ impl<'a> Parser<'a> {\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n-    /// Parse [mut/const/imm] ID : TY\n-    /// now used only by obsolete record syntax parser...\n-    pub fn parse_ty_field(&mut self) -> TypeField {\n-        let lo = self.span.lo;\n-        let mutbl = self.parse_mutability();\n-        let id = self.parse_ident();\n-        self.expect(&token::Colon);\n-        let ty = self.parse_ty_sum();\n-        let hi = ty.span.hi;\n-        ast::TypeField {\n-            ident: id,\n-            mt: MutTy { ty: ty, mutbl: mutbl },\n-            span: mk_sp(lo, hi),\n-        }\n-    }\n-\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> FunctionRetTy {\n         if self.eat(&token::RArrow) {\n@@ -1506,17 +1490,6 @@ impl<'a> Parser<'a> {\n             } else {\n                 TyTup(ts)\n             }\n-        } else if self.token == token::Tilde {\n-            // OWNED POINTER\n-            self.bump();\n-            let last_span = self.last_span;\n-            match self.token {\n-                token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n-                }\n-                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedType)\n-            }\n-            TyTup(vec![self.parse_ty()])\n         } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -2800,20 +2773,6 @@ impl<'a> Parser<'a> {\n             hi = e.span.hi;\n             ex = ExprAddrOf(m, e);\n           }\n-          token::Tilde => {\n-            self.bump();\n-            let last_span = self.last_span;\n-            match self.token {\n-                token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n-                },\n-                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedExpr)\n-            }\n-\n-            let e = self.parse_prefix_expr();\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnUniq, e);\n-          }\n           token::DotDot if !self.restrictions.contains(RESTRICTION_NO_DOTS) => {\n             // A range, closed above: `..expr`.\n             self.bump();\n@@ -3219,10 +3178,6 @@ impl<'a> Parser<'a> {\n                             span: self.span,\n                         }));\n                         before_slice = false;\n-                    } else {\n-                        let _ = self.parse_pat();\n-                        let span = self.span;\n-                        self.obsolete(span, ObsoleteSyntax::SubsliceMatch);\n                     }\n                     continue\n                 }\n@@ -3331,20 +3286,6 @@ impl<'a> Parser<'a> {\n                 span: mk_sp(lo, hi)\n             })\n           }\n-          token::Tilde => {\n-            // parse ~pat\n-            self.bump();\n-            let sub = self.parse_pat();\n-            pat = PatBox(sub);\n-            let last_span = self.last_span;\n-            hi = last_span.hi;\n-            self.obsolete(last_span, ObsoleteSyntax::OwnedPattern);\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n-          }\n           token::BinOp(token::And) | token::AndAnd => {\n             // parse &pat and &mut pat\n             let lo = self.span.lo;\n@@ -4453,16 +4394,6 @@ impl<'a> Parser<'a> {\n                 self_ident_hi = self.last_span.hi;\n                 eself\n             }\n-            token::Tilde => {\n-                // We need to make sure it isn't a type\n-                if self.look_ahead(1, |t| t.is_keyword(keywords::Self)) {\n-                    self.bump();\n-                    drop(self.expect_self_ident());\n-                    let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf)\n-                }\n-                SelfStatic\n-            }\n             token::BinOp(token::Star) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n                 // emitting cryptic \"unexpected token\" errors.\n@@ -4503,15 +4434,6 @@ impl<'a> Parser<'a> {\n                     } else {\n                         SelfValue(self_ident)\n                     }\n-                } else if self.token.is_mutability() &&\n-                        self.look_ahead(1, |t| *t == token::Tilde) &&\n-                        self.look_ahead(2, |t| t.is_keyword(keywords::Self)) {\n-                    mutbl_self = self.parse_mutability();\n-                    self.bump();\n-                    drop(self.expect_self_ident());\n-                    let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf);\n-                    SelfStatic\n                 } else {\n                     SelfStatic\n                 }\n@@ -5392,13 +5314,7 @@ impl<'a> Parser<'a> {\n         let (maybe_path, ident) = match self.token {\n             token::Ident(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if self.token == token::Eq {\n-                    self.bump();\n-                    let path = self.parse_str();\n-                    let span = self.span;\n-                    self.obsolete(span, ObsoleteSyntax::ExternCrateRenaming);\n-                    Some(path)\n-                } else if self.eat_keyword(keywords::As) {\n+                let path = if self.eat_keyword(keywords::As) {\n                     // skip the ident if there is one\n                     if self.token.is_ident() { self.bump(); }\n \n@@ -5668,17 +5584,7 @@ impl<'a> Parser<'a> {\n         }\n         // either a view item or an item:\n         if self.eat_keyword(keywords::Extern) {\n-            let next_is_mod = self.eat_keyword(keywords::Mod);\n-\n-            if next_is_mod || self.eat_keyword(keywords::Crate) {\n-                if next_is_mod {\n-                    let last_span = self.last_span;\n-                    self.span_err(mk_sp(lo, last_span.hi),\n-                                 &format!(\"`extern mod` is obsolete, use \\\n-                                          `extern crate` instead \\\n-                                          to refer to external \\\n-                                          crates.\")[])\n-                }\n+            if self.eat_keyword(keywords::Crate) {\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n \n@@ -6045,35 +5951,7 @@ impl<'a> Parser<'a> {\n \n         let first_ident = self.parse_ident();\n         let mut path = vec!(first_ident);\n-        match self.token {\n-          token::Eq => {\n-            // x = foo::bar\n-            self.bump();\n-            let path_lo = self.span.lo;\n-            path = vec!(self.parse_ident());\n-            while self.check(&token::ModSep) {\n-                self.bump();\n-                let id = self.parse_ident();\n-                path.push(id);\n-            }\n-            let span = mk_sp(path_lo, self.span.hi);\n-            self.obsolete(span, ObsoleteSyntax::ImportRenaming);\n-            let path = ast::Path {\n-                span: span,\n-                global: false,\n-                segments: path.into_iter().map(|identifier| {\n-                    ast::PathSegment {\n-                        identifier: identifier,\n-                        parameters: ast::PathParameters::none(),\n-                    }\n-                }).collect()\n-            };\n-            return P(spanned(lo, self.span.hi,\n-                             ViewPathSimple(first_ident, path,\n-                                           ast::DUMMY_NODE_ID)));\n-          }\n-\n-          token::ModSep => {\n+        if let token::ModSep = self.token {\n             // foo::bar or foo::{a,b,c} or foo::*\n             while self.check(&token::ModSep) {\n                 self.bump();\n@@ -6126,8 +6004,6 @@ impl<'a> Parser<'a> {\n                   _ => break\n                 }\n             }\n-          }\n-          _ => ()\n         }\n         let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {"}]}