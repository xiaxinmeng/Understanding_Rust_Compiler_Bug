{"sha": "8599bff5a3556059817503030e248507706e96b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTliZmY1YTM1NTYwNTk4MTc1MDMwMzBlMjQ4NTA3NzA2ZTk2YjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-19T08:24:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-19T08:24:01Z"}, "message": "Auto merge of #82281 - Dylan-DPC:rollup-raob2tu, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #79747 (Add explanations and suggestions to `irrefutable_let_patterns` lint)\n - #81496 (name async generators something more human friendly in type error diagnostic)\n - #81873 (Add Mutex::unlock)\n - #82093 (Add tests for Atomic*::fetch_{min,max})\n - #82238 (ast: Keep expansion status for out-of-line module items)\n - #82245 (Do not ICE when evaluating locals' types of invalid `yield`)\n - #82259 (Fix popping singleton paths in when generating E0433)\n - #82261 (rustdoc: Support argument files)\n - #82274 (libtest: Fix unwrap panic on duplicate TestDesc)\n - #82275 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2ec5c6709b5daa8a117a8f5f95c710fdb76c9bca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ec5c6709b5daa8a117a8f5f95c710fdb76c9bca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8599bff5a3556059817503030e248507706e96b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8599bff5a3556059817503030e248507706e96b4", "html_url": "https://github.com/rust-lang/rust/commit/8599bff5a3556059817503030e248507706e96b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8599bff5a3556059817503030e248507706e96b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0148b971c921a0831fbf3357e5936eec724e3566", "url": "https://api.github.com/repos/rust-lang/rust/commits/0148b971c921a0831fbf3357e5936eec724e3566", "html_url": "https://github.com/rust-lang/rust/commit/0148b971c921a0831fbf3357e5936eec724e3566"}, {"sha": "979b00ba6a2d40612544ec7bbf7311b02b7c7d76", "url": "https://api.github.com/repos/rust-lang/rust/commits/979b00ba6a2d40612544ec7bbf7311b02b7c7d76", "html_url": "https://github.com/rust-lang/rust/commit/979b00ba6a2d40612544ec7bbf7311b02b7c7d76"}], "stats": {"total": 940, "additions": 607, "deletions": 333}, "files": [{"sha": "9f43f5a8b36b22ab54ff5b7bb2f74010fd82f40b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -285,7 +285,7 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.52.0\"\n+version = \"0.53.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\","}, {"sha": "3550055ac10d3ce384cdc312df57e50a8394e231", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -486,8 +486,8 @@ pub struct WhereEqPredicate {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub module: Mod,\n     pub attrs: Vec<Attribute>,\n+    pub items: Vec<P<Item>>,\n     pub span: Span,\n     /// The order of items in the HIR is unrelated to the order of\n     /// items in the AST. However, we generate proc macro harnesses\n@@ -2299,21 +2299,22 @@ impl FnRetTy {\n     }\n }\n \n-/// Module declaration.\n-///\n-/// E.g., `mod foo;` or `mod foo { .. }`.\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n+pub enum Inline {\n+    Yes,\n+    No,\n+}\n+\n+/// Module item kind.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct Mod {\n-    /// A span from the first token past `{` to the last token until `}`.\n-    /// For `mod foo;`, the inner span ranges from the first token\n-    /// to the last token in the external file.\n-    pub inner: Span,\n-    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n-    /// semantically by Rust.\n-    pub unsafety: Unsafe,\n-    pub items: Vec<P<Item>>,\n-    /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n-    pub inline: bool,\n+pub enum ModKind {\n+    /// Module with inlined definition `mod foo { ... }`,\n+    /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n+    /// The inner span is from the first token past `{` to the last token until `}`,\n+    /// or from the first to the last token in the loaded file.\n+    Loaded(Vec<P<Item>>, Inline, Span),\n+    /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n+    Unloaded,\n }\n \n /// Foreign module declaration.\n@@ -2710,7 +2711,9 @@ pub enum ItemKind {\n     /// A module declaration (`mod`).\n     ///\n     /// E.g., `mod foo;` or `mod foo { .. }`.\n-    Mod(Mod),\n+    /// `unsafe` keyword on modules is accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    Mod(Unsafe, ModKind),\n     /// An external module (`extern`).\n     ///\n     /// E.g., `extern {}` or `extern \"C\" {}`."}, {"sha": "c286738811ca13c27648c1da000c6ed5f72bb64b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -170,10 +170,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_ty_constraint(t, self);\n     }\n \n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        noop_visit_mod(m, self);\n-    }\n-\n     fn visit_foreign_mod(&mut self, nm: &mut ForeignMod) {\n         noop_visit_foreign_mod(nm, self);\n     }\n@@ -917,7 +913,13 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n             visit_opt(body, |body| vis.visit_block(body));\n         }\n-        ItemKind::Mod(m) => vis.visit_mod(m),\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, inner_span) => {\n+                vis.visit_span(inner_span);\n+                items.flat_map_in_place(|item| vis.flat_map_item(item));\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n         ItemKind::GlobalAsm(_ga) => {}\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n@@ -998,14 +1000,10 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     vis.visit_asyncness(asyncness);\n }\n \n-pub fn noop_visit_mod<T: MutVisitor>(module: &mut Mod, vis: &mut T) {\n-    let Mod { inner, unsafety: _, items, inline: _ } = module;\n-    vis.visit_span(inner);\n-    items.flat_map_in_place(|item| vis.flat_map_item(item));\n-}\n-\n+// FIXME: Avoid visiting the crate as a `Mod` item, flat map only the inner items if possible,\n+// or make crate visiting first class if necessary.\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n-    visit_clobber(krate, |Crate { module, attrs, span, proc_macros }| {\n+    visit_clobber(krate, |Crate { attrs, items, span, proc_macros }| {\n         let item_vis =\n             Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n         let item = P(Item {\n@@ -1014,19 +1012,20 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: item_vis,\n             span,\n-            kind: ItemKind::Mod(module),\n+            kind: ItemKind::Mod(Unsafe::No, ModKind::Loaded(items, Inline::Yes, span)),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n \n         let len = items.len();\n         if len == 0 {\n-            let module = Mod { inner: span, unsafety: Unsafe::No, items: vec![], inline: true };\n-            Crate { module, attrs: vec![], span, proc_macros }\n+            Crate { attrs: vec![], items: vec![], span, proc_macros }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n             match kind {\n-                ItemKind::Mod(module) => Crate { module, attrs, span, proc_macros },\n+                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => {\n+                    Crate { attrs, items, span, proc_macros }\n+                }\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n         } else {"}, {"sha": "32b9dd46baef446dc6b2f78d88e6393de49f4133", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -74,7 +74,7 @@ impl<'a> FnKind<'a> {\n /// Each method of the `Visitor` trait is a hook to be potentially\n /// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n-/// e.g., the `visit_mod` method by default calls `visit::walk_mod`.\n+/// e.g., the `visit_item` method by default calls `visit::walk_item`.\n ///\n /// If you want to ensure that your code handles every variant\n /// explicitly, you need to override each method. (And you also need\n@@ -87,9 +87,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_ident(&mut self, ident: Ident) {\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n-        walk_mod(self, m);\n-    }\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n@@ -238,14 +235,10 @@ pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n }\n \n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, &krate.attrs, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_item, &krate.items);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n }\n \n-pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n-    walk_list!(visitor, visit_item, &module.items);\n-}\n-\n pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -297,7 +290,12 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(ref module) => visitor.visit_mod(module, item.span, &item.attrs, item.id),\n+        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, _inner_span) => {\n+                walk_list!(visitor, visit_item, items)\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }"}, {"sha": "8b740b77740892d875b3df8d64640a07f25578e3", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -15,11 +15,11 @@ use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n-\n use smallvec::{smallvec, SmallVec};\n-use std::collections::BTreeSet;\n use tracing::debug;\n \n+use std::mem;\n+\n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n@@ -34,25 +34,6 @@ impl ItemLowerer<'_, '_, '_> {\n }\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n-    fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-        let def_id = self.lctx.lower_node_id(n).expect_owner();\n-\n-        self.lctx.modules.insert(\n-            def_id,\n-            hir::ModuleItems {\n-                items: BTreeSet::new(),\n-                trait_items: BTreeSet::new(),\n-                impl_items: BTreeSet::new(),\n-                foreign_items: BTreeSet::new(),\n-            },\n-        );\n-\n-        let old = self.lctx.current_module;\n-        self.lctx.current_module = def_id;\n-        visit::walk_mod(self, m);\n-        self.lctx.current_module = old;\n-    }\n-\n     fn visit_item(&mut self, item: &'a Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n@@ -67,10 +48,18 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(box ImplKind { ref of_trait, .. }) = item.kind {\n-                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                } else {\n-                    visit::walk_item(this, item);\n+                match item.kind {\n+                    ItemKind::Mod(..) => {\n+                        let def_id = this.lctx.lower_node_id(item.id).expect_owner();\n+                        let old_current_module =\n+                            mem::replace(&mut this.lctx.current_module, def_id);\n+                        visit::walk_item(this, item);\n+                        this.lctx.current_module = old_current_module;\n+                    }\n+                    ItemKind::Impl(box ImplKind { ref of_trait, .. }) => {\n+                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                    }\n+                    _ => visit::walk_item(this, item),\n                 }\n             });\n         }\n@@ -94,13 +83,13 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n                 let hir_item = lctx.lower_trait_item(item);\n                 let id = hir_item.trait_item_id();\n                 lctx.trait_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().trait_items.insert(id);\n             }\n             AssocCtxt::Impl => {\n                 let hir_item = lctx.lower_impl_item(item);\n                 let id = hir_item.impl_item_id();\n                 lctx.impl_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().impl_items.insert(id);\n             }\n         });\n \n@@ -113,7 +102,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n             let hir_item = lctx.lower_foreign_item(item);\n             let id = hir_item.foreign_item_id();\n             lctx.foreign_items.insert(id, hir_item);\n-            lctx.modules.get_mut(&lctx.current_module).unwrap().foreign_items.insert(id);\n+            lctx.modules.entry(lctx.current_module).or_default().foreign_items.insert(id);\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -157,7 +146,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n-        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n \n         // this vector is only used when walking over impl headers,\n         // input types, and the like, and should not be non-empty in\n@@ -172,12 +161,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         res\n     }\n \n-    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod<'hir> {\n+    pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n-            inner: m.inner,\n-            item_ids: self\n-                .arena\n-                .alloc_from_iter(m.items.iter().flat_map(|x| self.lower_item_id(x))),\n+            inner,\n+            item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_id(x))),\n         }\n     }\n \n@@ -327,7 +314,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+                ModKind::Loaded(items, _, inner_span) => {\n+                    hir::ItemKind::Mod(self.lower_mod(items, *inner_span))\n+                }\n+                ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n+            },\n             ItemKind::ForeignMod(ref fm) => {\n                 if fm.abi.is_none() {\n                     self.maybe_lint_missing_abi(span, id, abi::Abi::C);"}, {"sha": "05b417effd491688e9782633fc90e3c3f4a6c706", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -560,7 +560,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.lower_mod(&c.module);\n+        let module = self.lower_mod(&c.items, c.span);\n         let attrs = self.lower_attrs(&c.attrs);\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n@@ -608,7 +608,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n         let id = hir::ItemId { def_id: item.def_id };\n         self.items.insert(id, item);\n-        self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n+        self.modules.entry(self.current_module).or_default().items.insert(id);\n         id\n     }\n "}, {"sha": "563bcda51906575cefaf6602b1553caa42bba11e", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1054,12 +1054,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+            ItemKind::Mod(unsafety, ref mod_kind) => {\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n+                if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n+                    && !self.session.contains_name(&item.attrs, sym::path)\n+                {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "fb7e0d3450fde5a0f1b1cf422838fa73a4d37574", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -20,10 +20,6 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) {\n-        self.count += 1;\n-        walk_mod(self, m)\n-    }\n     fn visit_foreign_item(&mut self, i: &ForeignItem) {\n         self.count += 1;\n         walk_foreign_item(self, i)"}, {"sha": "82f6e936b766eb041a8bc4458abab9fd25d56772", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{GenericArg, MacArgs};\n+use rustc_ast::{GenericArg, MacArgs, ModKind};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -87,7 +87,6 @@ pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n-    is_expanded: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -103,12 +102,8 @@ pub fn print_crate<'a>(\n     is_expanded: bool,\n     edition: Edition,\n ) -> String {\n-    let mut s = State {\n-        s: pp::mk_printer(),\n-        comments: Some(Comments::new(sm, filename, input)),\n-        ann,\n-        is_expanded,\n-    };\n+    let mut s =\n+        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann };\n \n     if is_expanded && !krate.attrs.iter().any(|attr| attr.has_name(sym::no_core)) {\n         // We need to print `#![no_std]` (and its feature gate) so that\n@@ -132,7 +127,10 @@ pub fn print_crate<'a>(\n         }\n     }\n \n-    s.print_mod(&krate.module, &krate.attrs);\n+    s.print_inner_attributes(&krate.attrs);\n+    for item in &krate.items {\n+        s.print_item(item);\n+    }\n     s.print_remaining_comments();\n     s.ann.post(&mut s, AnnNode::Crate(krate));\n     s.s.eof()\n@@ -853,7 +851,7 @@ impl<'a> PrintState<'a> for State<'a> {\n \n impl<'a> State<'a> {\n     pub fn new() -> State<'a> {\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false }\n+        State { s: pp::mk_printer(), comments: None, ann: &NoAnn }\n     }\n \n     // Synthesizes a comment that was not textually present in the original source\n@@ -891,13 +889,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &ast::Mod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &_mod.items {\n-            self.print_item(item);\n-        }\n-    }\n-\n     crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n@@ -1139,23 +1130,29 @@ impl<'a> State<'a> {\n                 let body = body.as_deref();\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n-            ast::ItemKind::Mod(ref _mod) => {\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n                 self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(_mod.unsafety);\n+                    s.print_unsafety(unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n \n-                if _mod.inline || self.is_expanded {\n-                    self.nbsp();\n-                    self.bopen();\n-                    self.print_mod(_mod, &item.attrs);\n-                    self.bclose(item.span);\n-                } else {\n-                    self.s.word(\";\");\n-                    self.end(); // end inner head-block\n-                    self.end(); // end outer head-block\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        self.bclose(item.span);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.s.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {"}, {"sha": "71bbae1161b4bebcef863c749dde5e5f53697b2b", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -91,7 +91,7 @@ pub fn inject(\n     }\n \n     let decls = mk_decls(&mut krate, &mut cx, &macros);\n-    krate.module.items.push(decls);\n+    krate.items.push(decls);\n \n     krate\n }"}, {"sha": "3a81d076dc52fdbd6ea2db324bdc90bee7cc40f0", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -44,7 +44,7 @@ pub fn inject(\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &name in names.iter().rev() {\n         let ident = if rust_2018 { Ident::new(name, span) } else { Ident::new(name, call_site) };\n-        krate.module.items.insert(\n+        krate.items.insert(\n             0,\n             cx.item(\n                 span,\n@@ -79,7 +79,7 @@ pub fn inject(\n         })),\n     );\n \n-    krate.module.items.insert(0, use_item);\n+    krate.items.insert(0, use_item);\n \n     krate\n }"}, {"sha": "28e8259784387078e064de865d09c7c62e8cb286", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,10 +1,10 @@\n // Code that generates a test runner to run all the tests in a crate\n \n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{attr, ModKind};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n@@ -89,7 +89,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n-        c.module.items.push(mk_main(&mut self.cx));\n+        c.items.push(mk_main(&mut self.cx));\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -103,18 +103,22 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(mut module) = item.kind {\n+        if let ast::ItemKind::Mod(..) = item.kind {\n             let tests = mem::take(&mut self.tests);\n-            noop_visit_mod(&mut module, self);\n+            noop_visit_item_kind(&mut item.kind, self);\n             let mut tests = mem::replace(&mut self.tests, tests);\n \n             if !tests.is_empty() {\n                 let parent =\n                     if item.id == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { item.id };\n                 // Create an identifier that will hygienically resolve the test\n                 // case name, even in another module.\n+                let inner_span = match item.kind {\n+                    ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) => span,\n+                    _ => unreachable!(),\n+                };\n                 let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n-                    module.inner,\n+                    inner_span,\n                     AstPass::TestHarness,\n                     &[],\n                     Some(parent),\n@@ -126,7 +130,6 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }"}, {"sha": "01338359f1af1d063ddc3d16130fc221a31657f4", "filename": "compiler/rustc_driver/src/args.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use std::fs;\n use std::io;\n \n-pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n+fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     if let Some(path) = arg.strip_prefix('@') {\n         let file = match fs::read_to_string(path) {\n             Ok(file) => file,\n@@ -18,6 +18,20 @@ pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     }\n }\n \n+pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n+    let mut args = Vec::new();\n+    for arg in at_args {\n+        match arg_expand(arg.clone()) {\n+            Ok(arg) => args.extend(arg),\n+            Err(err) => rustc_session::early_error(\n+                rustc_session::config::ErrorOutputType::default(),\n+                &format!(\"Failed to load argument file: {}\", err),\n+            ),\n+        }\n+    }\n+    args\n+}\n+\n #[derive(Debug)]\n pub enum Error {\n     Utf8Error(Option<String>),"}, {"sha": "cad5a87bb134663ad329c360df5a442709356ecb", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -55,7 +55,7 @@ use std::process::{self, Command, Stdio};\n use std::str;\n use std::time::Instant;\n \n-mod args;\n+pub mod args;\n pub mod pretty;\n \n /// Exit status code used for successful compilation and help output.\n@@ -188,16 +188,8 @@ fn run_compiler(\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n ) -> interface::Result<()> {\n-    let mut args = Vec::new();\n-    for arg in at_args {\n-        match args::arg_expand(arg.clone()) {\n-            Ok(arg) => args.extend(arg),\n-            Err(err) => early_error(\n-                ErrorOutputType::default(),\n-                &format!(\"Failed to load argument file: {}\", err),\n-            ),\n-        }\n-    }\n+    let args = args::arg_expand_all(at_args);\n+\n     let diagnostic_output = emitter.map_or(DiagnosticOutput::Default, DiagnosticOutput::Raw);\n     let matches = match handle_options(&args) {\n         Some(matches) => matches,"}, {"sha": "ad04fa9a95816b64e5c7cb88613f90c6835aa3b1", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -209,7 +209,7 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n-            krate.module.items = Vec::new();\n+            krate.items = Vec::new();\n             Features::default()\n         }\n         Some(attrs) => {"}, {"sha": "5a4737842f0af0e4e0a26fee4c01a5f03853a69b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -12,8 +12,8 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AttrItem, AttrStyle, Block, ItemKind, LitKind, MacArgs};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n@@ -350,6 +350,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx, monotonic }\n     }\n \n+    // FIXME: Avoid visiting the crate as a `Mod` item,\n+    // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n@@ -362,12 +364,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.root_path = module.directory.clone();\n         self.cx.current_expansion.module = Rc::new(module);\n \n-        let orig_mod_span = krate.module.inner;\n-\n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            kind: ast::ItemKind::Mod(krate.module),\n+            kind: ast::ItemKind::Mod(\n+                Unsafe::No,\n+                ModKind::Loaded(krate.items, Inline::Yes, krate.span)\n+            ),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility {\n@@ -379,28 +382,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item {\n+                attrs,\n+                kind: ast::ItemKind::Mod(_, ModKind::Loaded(items, ..)),\n+                ..\n+            }) => {\n                 krate.attrs = attrs;\n-                krate.module = module;\n+                krate.items = items;\n             }\n             None => {\n                 // Resolution failed so we return an empty expansion\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n             }\n             Some(ast::Item { span, kind, .. }) => {\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n                 self.cx.span_err(\n                     span,\n                     &format!(\n@@ -814,7 +811,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(module) if !module.inline => {\n+                    ast::ItemKind::Mod(_, mod_kind)\n+                        if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n+                    {\n                         feature_err(\n                             self.parse_sess,\n                             sym::proc_macro_hygiene,\n@@ -1271,52 +1270,47 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n+            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n                 let sess = &self.cx.sess.parse_sess;\n                 let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n \n                 let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n                 let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = if old_mod.inline {\n-                    // Inline `mod foo { ... }`, but we still need to push directories.\n-                    item.attrs = attrs;\n-                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                } else {\n-                    // We have an outline `mod foo;` so we need to parse the file.\n-                    let (new_mod, dir) = parse_external_mod(\n-                        &self.cx.sess,\n-                        ident,\n-                        span,\n-                        old_mod.unsafety,\n-                        dir,\n-                        &mut attrs,\n-                        pushed,\n-                    );\n-\n-                    let krate = ast::Crate {\n-                        span: new_mod.inner,\n-                        module: new_mod,\n-                        attrs,\n-                        proc_macros: vec![],\n-                    };\n-                    if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                        extern_mod_loaded(&krate, ident);\n+                let Directory { ownership, path } = match mod_kind {\n+                    ModKind::Loaded(_, Inline::Yes, _) => {\n+                        // Inline `mod foo { ... }`, but we still need to push directories.\n+                        item.attrs = attrs;\n+                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n+                    }\n+                    ModKind::Loaded(_, Inline::No, _) => {\n+                        panic!(\"`mod` item is loaded from a file for the second time\")\n                     }\n+                    ModKind::Unloaded => {\n+                        // We have an outline `mod foo;` so we need to parse the file.\n+                        let (items, inner_span, dir) =\n+                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+\n+                        let krate =\n+                            ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n+                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n+                            extern_mod_loaded(&krate, ident);\n+                        }\n \n-                    *old_mod = krate.module;\n-                    item.attrs = krate.attrs;\n-                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                    item = match self.configure(item) {\n-                        Some(node) => node,\n-                        None => {\n-                            if *pushed {\n-                                sess.included_mod_stack.borrow_mut().pop();\n+                        *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n+                        item.attrs = krate.attrs;\n+                        // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n+                        item = match self.configure(item) {\n+                            Some(node) => node,\n+                            None => {\n+                                if *pushed {\n+                                    sess.included_mod_stack.borrow_mut().pop();\n+                                }\n+                                return Default::default();\n                             }\n-                            return Default::default();\n-                        }\n-                    };\n-                    dir\n+                        };\n+                        dir\n+                    }\n                 };\n \n                 // Set the module info before we flat map."}, {"sha": "076d3b02be93fb45b565a17e4ac8cd6dec12074e", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,4 +1,5 @@\n-use rustc_ast::{token, Attribute, Mod, Unsafe};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{token, Attribute, Item};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n@@ -42,11 +43,10 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n-    unsafety: Unsafe,\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n     pop_mod_stack: &mut bool,\n-) -> (Mod, Directory) {\n+) -> (Vec<P<Item>>, Span, Directory) {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n@@ -62,26 +62,22 @@ crate fn parse_external_mod(\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let mut module = parser.parse_mod(&token::Eof, unsafety)?;\n-        module.0.inline = false;\n-        module\n+        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        attrs.append(&mut inner_attrs);\n+        (items, inner_span)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n-        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n-        (module, Vec::new())\n-    });\n-    attrs.append(&mut new_attrs);\n+    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n \n-    // Extract the directory path for submodules of `module`.\n-    let path = sess.source_map().span_to_unmapped_path(module.inner);\n+    // Extract the directory path for submodules of  the module.\n+    let path = sess.source_map().span_to_unmapped_path(inner_span);\n     let mut path = match path {\n         FileName::Real(name) => name.into_local_path(),\n         other => PathBuf::from(other.to_string()),\n     };\n     path.pop();\n \n-    (module, Directory { ownership, path })\n+    (items, inner_span, Directory { ownership, path })\n }\n \n fn error_on_circular_module<'a>("}, {"sha": "7e7155ad27876bff0571d97c42305eb518be8ade", "filename": "compiler/rustc_expand/src/mut_visit/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -7,8 +7,8 @@ use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n // This version doesn't care about getting comments or doc-strings in.\n-fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n-    s.print_mod(&krate.module, &krate.attrs)\n+fn print_crate_items(krate: &ast::Crate) -> String {\n+    krate.items.iter().map(|i| pprust::item_to_string(i)).collect::<Vec<_>>().join(\" \")\n }\n \n // Change every identifier to \"zz\".\n@@ -46,7 +46,7 @@ fn ident_transformation() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string()\n         );\n     })\n@@ -66,7 +66,7 @@ fn ident_transformation_in_defs() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string()\n         );\n     })"}, {"sha": "56f25ffdb0187cf7bc4ea2a8f8c3ea7c17d25898", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -309,8 +309,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.kind {\n-            assert!(m.items.len() == 2);\n+        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n+            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n         } else {\n             panic!();\n         }"}, {"sha": "4df8c44e62b38a0506cb89cce4bca53ef3c21d94", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n@@ -615,7 +616,7 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Default, Encodable, Debug, HashStable_Generic)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n@@ -1280,7 +1281,7 @@ impl Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1298,12 +1299,21 @@ impl fmt::Display for GeneratorKind {\n     }\n }\n \n+impl GeneratorKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GeneratorKind::Async(ask) => ask.descr(),\n+            GeneratorKind::Gen => \"generator\",\n+        }\n+    }\n+}\n+\n /// In the case of a generator created as part of an async construct,\n /// which kind of async construct caused it to be created?\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n@@ -1325,6 +1335,16 @@ impl fmt::Display for AsyncGeneratorKind {\n     }\n }\n \n+impl AsyncGeneratorKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            AsyncGeneratorKind::Block => \"`async` block\",\n+            AsyncGeneratorKind::Closure => \"`async` closure body\",\n+            AsyncGeneratorKind::Fn => \"`async fn` body\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BodyOwnerKind {\n     /// Functions and methods."}, {"sha": "9e55f7e558999db7703079092bb32d78912683d9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1509,7 +1509,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n+                if let Some((kind, def_id)) = TyCategory::from_ty(self.tcx, t) {\n                     let span = self.tcx.def_span(def_id);\n                     // Avoid cluttering the output when the \"found\" and error span overlap:\n                     //\n@@ -1582,11 +1582,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         if let Some((expected, found)) = expected_found {\n             let expected_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.expected.prefix_string(),\n+                Mismatch::Variable(ef) => ef.expected.prefix_string(self.tcx),\n                 Mismatch::Fixed(s) => s.into(),\n             };\n             let found_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.found.prefix_string(),\n+                Mismatch::Variable(ef) => ef.found.prefix_string(self.tcx),\n                 Mismatch::Fixed(s) => s.into(),\n             };\n             let exp_found = match exp_found {\n@@ -2489,7 +2489,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n pub enum TyCategory {\n     Closure,\n     Opaque,\n-    Generator,\n+    Generator(hir::GeneratorKind),\n     Foreign,\n }\n \n@@ -2498,16 +2498,18 @@ impl TyCategory {\n         match self {\n             Self::Closure => \"closure\",\n             Self::Opaque => \"opaque type\",\n-            Self::Generator => \"generator\",\n+            Self::Generator(gk) => gk.descr(),\n             Self::Foreign => \"foreign type\",\n         }\n     }\n \n-    pub fn from_ty(ty: Ty<'_>) -> Option<(Self, DefId)> {\n+    pub fn from_ty(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Self, DefId)> {\n         match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n             ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n-            ty::Generator(def_id, ..) => Some((Self::Generator, def_id)),\n+            ty::Generator(def_id, ..) => {\n+                Some((Self::Generator(tcx.generator_kind(def_id).unwrap()), def_id))\n+            }\n             ty::Foreign(def_id) => Some((Self::Foreign, def_id)),\n             _ => None,\n         }"}, {"sha": "d533e267fd702856ad1ca3a3e467fd0cd0fc8274", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 InferenceDiagnosticsData {\n                     name: s,\n                     span: None,\n-                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string() },\n+                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string(self.tcx) },\n                     parent: None,\n                 }\n             }"}, {"sha": "cc3bf4095fdef300fc8d3c7e1cb7aad65bf4eaf7", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -188,13 +188,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_ident, ident);\n     }\n \n-    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_early_pass!(self, check_mod, m, s, n);\n-        self.check_id(n);\n-        ast_visit::walk_mod(self, m);\n-        run_early_pass!(self, check_mod_post, m, s, n);\n-    }\n-\n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_early_pass!(cx, check_local, l);"}, {"sha": "ffbed3a0aff2d111ad897e81ad520085622e26f6", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -160,8 +160,6 @@ macro_rules! early_lint_methods {\n             fn check_ident(a: Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n-            fn check_mod(a: &ast::Mod, b: Span, c: ast::NodeId);\n-            fn check_mod_post(a: &ast::Mod, b: Span, c: ast::NodeId);\n             fn check_foreign_item(a: &ast::ForeignItem);\n             fn check_foreign_item_post(a: &ast::ForeignItem);\n             fn check_item(a: &ast::Item);"}, {"sha": "686d09dd7fcb4478e53fcc98ec42d404f1f81059", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1814,14 +1814,12 @@ declare_lint! {\n }\n \n declare_lint! {\n-    /// The `irrefutable_let_patterns` lint detects detects [irrefutable\n-    /// patterns] in [`if let`] and [`while let`] statements.\n-    ///\n-    ///\n+    /// The `irrefutable_let_patterns` lint detects [irrefutable patterns]\n+    /// in [`if let`]s, [`while let`]s, and `if let` guards.\n     ///\n     /// ### Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// if let _ = 123 {\n     ///     println!(\"always runs!\");\n     /// }"}, {"sha": "bf315c81588a902ceec75e7987964ba0af7ed0a6", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -270,7 +270,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n             }\n             ty::Closure(..) => \"closure\".into(),\n-            ty::Generator(..) => \"generator\".into(),\n+            ty::Generator(def_id, ..) => tcx.generator_kind(def_id).unwrap().descr().into(),\n             ty::GeneratorWitness(..) => \"generator witness\".into(),\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Infer(ty::TyVar(_)) => \"inferred type\".into(),\n@@ -288,7 +288,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn prefix_string(&self) -> Cow<'static, str> {\n+    pub fn prefix_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match *self.kind() {\n             ty::Infer(_)\n             | ty::Error(_)\n@@ -314,7 +314,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),\n-            ty::Generator(..) => \"generator\".into(),\n+            ty::Generator(def_id, ..) => tcx.generator_kind(def_id).unwrap().descr().into(),\n             ty::GeneratorWitness(..) => \"generator witness\".into(),\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),"}, {"sha": "fdecbb9478808f9323233fff3147754d3aba2dce", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -366,14 +366,31 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n-    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| {\n-        let msg = match source {\n-            hir::MatchSource::IfLetDesugar { .. } => \"irrefutable `if let` pattern\",\n-            hir::MatchSource::WhileLetDesugar => \"irrefutable `while let` pattern\",\n-            hir::MatchSource::IfLetGuardDesugar => \"irrefutable `if let` guard\",\n-            _ => bug!(),\n-        };\n-        lint.build(msg).emit()\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match source {\n+        hir::MatchSource::IfLetDesugar { .. } => {\n+            let mut diag = lint.build(\"irrefutable `if let` pattern\");\n+            diag.note(\"this pattern will always match, so the `if let` is useless\");\n+            diag.help(\"consider replacing the `if let` with a `let`\");\n+            diag.emit()\n+        }\n+        hir::MatchSource::WhileLetDesugar => {\n+            let mut diag = lint.build(\"irrefutable `while let` pattern\");\n+            diag.note(\"this pattern will always match, so the loop will never exit\");\n+            diag.help(\"consider instead using a `loop { ... }` with a `let` inside it\");\n+            diag.emit()\n+        }\n+        hir::MatchSource::IfLetGuardDesugar => {\n+            let mut diag = lint.build(\"irrefutable `if let` guard pattern\");\n+            diag.note(\"this pattern will always match, so the guard is useless\");\n+            diag.help(\"consider removing the guard and adding a `let` inside the match arm\");\n+            diag.emit()\n+        }\n+        _ => {\n+            bug!(\n+                \"expected `if let`, `while let`, or `if let` guard HIR match source, found {:?}\",\n+                source,\n+            )\n+        }\n     });\n }\n \n@@ -387,7 +404,7 @@ fn check_if_let_guard<'p, 'tcx>(\n     report_arm_reachability(&cx, &report, hir::MatchSource::IfLetGuardDesugar);\n \n     if report.non_exhaustiveness_witnesses.is_empty() {\n-        // The match is exhaustive, i.e. the if let pattern is irrefutable.\n+        // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n         irrefutable_let_pattern(cx.tcx, pat.span, pat_id, hir::MatchSource::IfLetGuardDesugar)\n     }\n }"}, {"sha": "0f907859a19a681d90ff554360a7cad0efc1e622", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -25,47 +25,36 @@ use tracing::debug;\n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n-        let lo = self.token.span;\n-        let (module, attrs) = self.parse_mod(&token::Eof, Unsafe::No)?;\n-        let span = lo.to(self.token.span);\n+        let (attrs, items, span) = self.parse_mod(&token::Eof)?;\n         let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n-        Ok(ast::Crate { attrs, module, span, proc_macros })\n+        Ok(ast::Crate { attrs, items, span, proc_macros })\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n         let unsafety = self.parse_unsafety();\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n-        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            (Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false }, Vec::new())\n+        let mod_kind = if self.eat(&token::Semi) {\n+            ModKind::Unloaded\n         } else {\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            self.parse_mod(&token::CloseDelim(token::Brace), unsafety)?\n+            let (mut inner_attrs, items, inner_span) =\n+                self.parse_mod(&token::CloseDelim(token::Brace))?;\n+            attrs.append(&mut inner_attrs);\n+            ModKind::Loaded(items, Inline::Yes, inner_span)\n         };\n-        attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(module)))\n+        Ok((id, ItemKind::Mod(unsafety, mod_kind)))\n     }\n \n     /// Parses the contents of a module (inner attributes followed by module items).\n     pub fn parse_mod(\n         &mut self,\n         term: &TokenKind,\n-        unsafety: Unsafe,\n-    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+    ) -> PResult<'a, (Vec<Attribute>, Vec<P<Item>>, Span)> {\n         let lo = self.token.span;\n         let attrs = self.parse_inner_attributes()?;\n-        let module = self.parse_mod_items(term, lo, unsafety)?;\n-        Ok((module, attrs))\n-    }\n \n-    /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(\n-        &mut self,\n-        term: &TokenKind,\n-        inner_lo: Span,\n-        unsafety: Unsafe,\n-    ) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = self.parse_item(ForceCollect::No)? {\n             items.push(item);\n@@ -82,9 +71,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n-\n-        Ok(Mod { inner: inner_lo.to(hi), unsafety, items, inline: true })\n+        Ok((attrs, items, lo.to(self.prev_token.span)))\n     }\n }\n "}, {"sha": "fac28281593c81b7609c15f026af3cb58ecf2078", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -124,11 +124,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'v hir::Mod<'v>, _s: Span, n: hir::HirId) {\n-        self.record(\"Mod\", Id::None, m);\n-        hir_visit::walk_mod(self, m, n)\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem<'v>) {\n         self.record(\"ForeignItem\", Id::Node(i.hir_id()), i);\n         hir_visit::walk_foreign_item(self, i)\n@@ -252,11 +247,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n }\n \n impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_mod(&mut self, m: &'v ast::Mod, _s: Span, _a: &[ast::Attribute], _n: NodeId) {\n-        self.record(\"Mod\", Id::None, m);\n-        ast_visit::walk_mod(self, m)\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n         self.record(\"ForeignItem\", Id::None, i);\n         ast_visit::walk_foreign_item(self, i)"}, {"sha": "701d48a982d36db8c9c1d040d2bfbe31b9e70801", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1023,7 +1023,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 });\n             }\n \n-            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n+            ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n                 self.with_scope(item.id, |this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -1801,7 +1801,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         crate_lint: CrateLint,\n     ) -> PartialRes {\n         tracing::debug!(\n-            \"smart_resolve_path_fragment(id={:?},qself={:?},path={:?}\",\n+            \"smart_resolve_path_fragment(id={:?}, qself={:?}, path={:?})\",\n             id,\n             qself,\n             path\n@@ -1841,11 +1841,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             // Before we start looking for candidates, we have to get our hands\n             // on the type user is trying to perform invocation on; basically:\n-            // we're transforming `HashMap::new` into just `HashMap`\n-            let path = if let Some((_, path)) = path.split_last() {\n-                path\n-            } else {\n-                return Some(parent_err);\n+            // we're transforming `HashMap::new` into just `HashMap`.\n+            let path = match path.split_last() {\n+                Some((_, path)) if !path.is_empty() => path,\n+                _ => return Some(parent_err),\n             };\n \n             let (mut err, candidates) ="}, {"sha": "77fbbaa1532af38a15fa6b4967ff79688fa34ab6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -11,6 +11,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(bool_to_option)]\n+#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n #![feature(nll)]\n@@ -23,11 +24,12 @@ use Determinacy::*;\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n+use rustc_ast::ptr::P;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{ItemKind, Path};\n+use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n@@ -59,6 +61,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt, iter, ptr};\n use tracing::debug;\n \n@@ -283,36 +286,29 @@ struct UsePlacementFinder {\n impl UsePlacementFinder {\n     fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n         let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n-        visit::walk_crate(&mut finder, krate);\n+        if let ControlFlow::Continue(..) = finder.check_mod(&krate.items, CRATE_NODE_ID) {\n+            visit::walk_crate(&mut finder, krate);\n+        }\n         (finder.span, finder.found_use)\n     }\n-}\n \n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n-    fn visit_mod(\n-        &mut self,\n-        module: &'tcx ast::Mod,\n-        _: Span,\n-        _: &[ast::Attribute],\n-        node_id: NodeId,\n-    ) {\n+    fn check_mod(&mut self, items: &[P<ast::Item>], node_id: NodeId) -> ControlFlow<()> {\n         if self.span.is_some() {\n-            return;\n+            return ControlFlow::Break(());\n         }\n         if node_id != self.target_module {\n-            visit::walk_mod(self, module);\n-            return;\n+            return ControlFlow::Continue(());\n         }\n         // find a use statement\n-        for item in &module.items {\n+        for item in items {\n             match item.kind {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                 }\n                 // don't place use before extern crate\n@@ -337,6 +333,18 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 }\n             }\n         }\n+        ControlFlow::Continue(())\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_item(&mut self, item: &'tcx ast::Item) {\n+        if let ItemKind::Mod(_, ModKind::Loaded(items, ..)) = &item.kind {\n+            if let ControlFlow::Break(..) = self.check_mod(items, item.id) {\n+                return;\n+            }\n+        }\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "bfb5ebcea58b114bf58f11bf5c8d881e129c4422", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1368,8 +1368,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(t) => Some(t),\n                     None => {\n                         let ty = parent_trait_ref.skip_binder().self_ty();\n-                        let span =\n-                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        let span = TyCategory::from_ty(self.tcx, ty)\n+                            .map(|(_, def_id)| self.tcx.def_span(def_id));\n                         Some((ty.to_string(), span))\n                     }\n                 }"}, {"sha": "32bf0ab7e85331fe01ff02aaae4ef841cefa5ada", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -2081,6 +2081,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => {\n                 self.tcx.sess.emit_err(YieldExprOutsideOfGenerator { span: expr.span });\n+                // Avoid expressions without types during writeback (#78653).\n+                self.check_expr(value);\n                 self.tcx.mk_unit()\n             }\n         }"}, {"sha": "721e8ec54f05f273ae53712951d84e97b97950a6", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"no {} named `{}` found for {} `{}` in the current scope\",\n                             item_kind,\n                             item_name,\n-                            actual.prefix_string(),\n+                            actual.prefix_string(self.tcx),\n                             ty_str,\n                         );\n                         if let Mode::MethodCall = mode {\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .map(|(_, path)| path)\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n-                        let actual_prefix = actual.prefix_string();\n+                        let actual_prefix = actual.prefix_string(self.tcx);\n                         err.set_primary_message(&format!(\n                             \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n                         ));"}, {"sha": "b735957666fc52b8d4a35235fc8cc22d2b532a02", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -59,6 +59,26 @@ fn uint_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn uint_min() {\n+    let x = AtomicUsize::new(0xf731);\n+    assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0x137f);\n+    assert_eq!(x.fetch_min(0xf731, SeqCst), 0x137f);\n+    assert_eq!(x.load(SeqCst), 0x137f);\n+}\n+\n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn uint_max() {\n+    let x = AtomicUsize::new(0x137f);\n+    assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);\n+    assert_eq!(x.load(SeqCst), 0xf731);\n+    assert_eq!(x.fetch_max(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731);\n+}\n+\n #[test]\n fn int_and() {\n     let x = AtomicIsize::new(0xf731);\n@@ -87,6 +107,26 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn int_min() {\n+    let x = AtomicIsize::new(0xf731);\n+    assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0x137f);\n+    assert_eq!(x.fetch_min(0xf731, SeqCst), 0x137f);\n+    assert_eq!(x.load(SeqCst), 0x137f);\n+}\n+\n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn int_max() {\n+    let x = AtomicIsize::new(0x137f);\n+    assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);\n+    assert_eq!(x.load(SeqCst), 0xf731);\n+    assert_eq!(x.fetch_max(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731);\n+}\n+\n static S_FALSE: AtomicBool = AtomicBool::new(false);\n static S_TRUE: AtomicBool = AtomicBool::new(true);\n static S_INT: AtomicIsize = AtomicIsize::new(0);"}, {"sha": "ab61618dc7d7bb92fb5ad805b9f81d068a1c852c", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -219,6 +219,26 @@ impl<T> Mutex<T> {\n             data: UnsafeCell::new(t),\n         }\n     }\n+\n+    /// Immediately drops the guard, and consequently unlocks the mutex.\n+    ///\n+    /// This function is equivalent to calling [`drop`] on the guard but is more self-documenting.\n+    /// Alternately, the guard will be automatically dropped when it goes out of scope.\n+    ///\n+    /// ```\n+    /// #![feature(mutex_unlock)]\n+    ///\n+    /// use std::sync::Mutex;\n+    /// let mutex = Mutex::new(0);\n+    ///\n+    /// let mut guard = mutex.lock().unwrap();\n+    /// *guard += 20;\n+    /// Mutex::unlock(guard);\n+    /// ```\n+    #[unstable(feature = \"mutex_unlock\", issue = \"81872\")]\n+    pub fn unlock(guard: MutexGuard<'_, T>) {\n+        drop(guard);\n+    }\n }\n \n impl<T: ?Sized> Mutex<T> {"}, {"sha": "f9e65be9b0d40028ebfaff37963020756274b9f0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -353,12 +353,13 @@ where\n             }\n \n             let mut completed_test = res.unwrap();\n-            let running_test = running_tests.remove(&completed_test.desc).unwrap();\n-            if let Some(join_handle) = running_test.join_handle {\n-                if let Err(_) = join_handle.join() {\n-                    if let TrOk = completed_test.result {\n-                        completed_test.result =\n-                            TrFailedMsg(\"panicked after reporting success\".to_string());\n+            if let Some(running_test) = running_tests.remove(&completed_test.desc) {\n+                if let Some(join_handle) = running_test.join_handle {\n+                    if let Err(_) = join_handle.join() {\n+                        if let TrOk = completed_test.result {\n+                            completed_test.result =\n+                                TrFailedMsg(\"panicked after reporting success\".to_string());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "0302fbecb6ed09ca0ba63a2771cad70715c16a6d", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -422,3 +422,10 @@ $ rustdoc src/lib.rs --crate-version 1.3.37\n When `rustdoc` receives this flag, it will print an extra \"Version (version)\" into the sidebar of\n the crate root's docs. You can use this flag to differentiate between different versions of your\n library's documentation.\n+\n+## `@path`: load command-line flags from a path\n+\n+If you specify `@path` on the command-line, then it will open `path` and read\n+command line options from it. These options are one per line; a blank line indicates\n+an empty option. The file can use Unix or Windows style line endings, and must be\n+encoded as UTF-8."}, {"sha": "d7978c4a0228db64f252037a25106accf8d50a1f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -432,13 +432,16 @@ fn usage(argv0: &str) {\n         (option.apply)(&mut options);\n     }\n     println!(\"{}\", options.usage(&format!(\"{} [options] <input>\", argv0)));\n+    println!(\"    @path               Read newline separated options from `path`\\n\");\n     println!(\"More information available at https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html\")\n }\n \n /// A result type used by several functions under `main()`.\n type MainResult = Result<(), ErrorReported>;\n \n-fn main_args(args: &[String]) -> MainResult {\n+fn main_args(at_args: &[String]) -> MainResult {\n+    let args = rustc_driver::args::arg_expand_all(at_args);\n+\n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);"}, {"sha": "c070b0c2400d84bf703e9c647d2b988c60fca366", "filename": "src/test/rustdoc-ui/commandline-argfile-badutf8.args", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.args", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.args", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.args?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,2 @@\n+--cfg\n+unbroken\ufffd\n\\ No newline at end of file"}, {"sha": "e2984e3ca97acb9ce9a5a665d2a1995ef8d42269", "filename": "src/test/rustdoc-ui/commandline-argfile-badutf8.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,12 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-badutf8.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "9af6fc0a518dfd05e76c56920bbd17ff3359e18e", "filename": "src/test/rustdoc-ui/commandline-argfile-badutf8.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-badutf8.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,2 @@\n+error: Failed to load argument file: Utf8 error in $DIR/commandline-argfile-badutf8.args\n+"}, {"sha": "020c3ff3c7e6346fe6770170d8a68314323f3caa", "filename": "src/test/rustdoc-ui/commandline-argfile-missing.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,15 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// ignore-tidy-linelength\n+// normalize-stderr-test: \"os error \\d+\" -> \"os error $$ERR\"\n+// normalize-stderr-test: \"commandline-argfile-missing.args:[^(]*\" -> \"commandline-argfile-missing.args: $$FILE_MISSING \"\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-missing.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "179ad83100419591c92ae7f948be2255c2fcd193", "filename": "src/test/rustdoc-ui/commandline-argfile-missing.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile-missing.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,2 @@\n+error: Failed to load argument file: IO Error: $DIR/commandline-argfile-missing.args: $FILE_MISSING (os error $ERR)\n+"}, {"sha": "972938bf6c8dddf9a1a3a24d94e3fdc20f07fc29", "filename": "src/test/rustdoc-ui/commandline-argfile.args", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.args", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.args", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.args?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,2 @@\n+--cfg\n+unbroken\n\\ No newline at end of file"}, {"sha": "cc8c8722c1c3599cc76bdb13e6b90880f0241241", "filename": "src/test/rustdoc-ui/commandline-argfile.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcommandline-argfile.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,13 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// check-pass\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "0307875c154b8bc291f608841b70dd4eba35bb85", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "d26530efe3ecd7fb337cb57afb0e5b0700685013", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "5008120166711006120736ef2cfb112304cc09d7", "filename": "src/test/ui/async-await/generator-desc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+#![feature(async_closure)]\n+use std::future::Future;\n+\n+async fn one() {}\n+async fn two() {}\n+\n+fn fun<F: Future<Output = ()>>(f1: F, f2: F) {}\n+fn main() {\n+    fun(async {}, async {});\n+    //~^ ERROR mismatched types\n+    fun(one(), two());\n+    //~^ ERROR mismatched types\n+    fun((async || {})(), (async || {})());\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "b85926c7a03c0012d030cc097b4d33dec85e414a", "filename": "src/test/ui/async-await/generator-desc.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,49 @@\n+error[E0308]: mismatched types\n+  --> $DIR/generator-desc.rs:10:25\n+   |\n+LL |     fun(async {}, async {});\n+   |               --        ^^ expected `async` block, found a different `async` block\n+   |               |\n+   |               the expected `async` block\n+   |\n+   = note: expected `async` block `[static generator@$DIR/generator-desc.rs:10:15: 10:17]`\n+              found `async` block `[static generator@$DIR/generator-desc.rs:10:25: 10:27]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/generator-desc.rs:12:16\n+   |\n+LL | async fn one() {}\n+   |                - the `Output` of this `async fn`'s expected opaque type\n+LL | async fn two() {}\n+   |                - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |     fun(one(), two());\n+   |                ^^^^^ expected opaque type, found a different opaque type\n+   |\n+   = note: expected opaque type `impl Future` (opaque type at <$DIR/generator-desc.rs:5:16>)\n+              found opaque type `impl Future` (opaque type at <$DIR/generator-desc.rs:6:16>)\n+   = help: consider `await`ing on both `Future`s\n+   = note: distinct uses of `impl Trait` result in different opaque types\n+\n+error[E0308]: mismatched types\n+  --> $DIR/generator-desc.rs:14:26\n+   |\n+LL |     fun((async || {})(), (async || {})());\n+   |                   --     ^^^^^^^^^^^^^^^ expected `async` closure body, found a different `async` closure body\n+   |                   |\n+   |                   the expected `async` closure body\n+   | \n+  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n+   |\n+LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+   |                                           -------------------------------\n+   |                                           |\n+   |                                           the expected opaque type\n+   |                                           the found opaque type\n+   |\n+   = note: expected opaque type `impl Future` (`async` closure body)\n+              found opaque type `impl Future` (`async` closure body)\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8586dfd91863cb13a605cad3d3946e814559a043", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -17,6 +17,8 @@ LL | |         }\n    | |_________^\n    |\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n error[E0382]: use of moved value: `c`\n   --> $DIR/closure-origin-single-variant-diagnostics.rs:25:13"}, {"sha": "c64c9093ee54a9771cfe7c94efafac2e0aef766d", "filename": "src/test/ui/expr/if/if-let.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -10,6 +10,8 @@ LL | |     });\n    | |_______- in this macro invocation\n    |\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `if let` pattern\n@@ -23,6 +25,8 @@ LL | |         println!(\"irrefutable pattern\");\n LL | |     });\n    | |_______- in this macro invocation\n    |\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `if let` pattern\n@@ -32,6 +36,9 @@ LL | /     if let a = 1 {\n LL | |         println!(\"irrefutable pattern\");\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:30:5\n@@ -44,6 +51,9 @@ LL | |     } else {\n LL | |         println!(\"else in irrefutable `if let`\");\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:40:12\n@@ -53,6 +63,9 @@ LL |       } else if let a = 1 {\n LL | |         println!(\"irrefutable pattern\");\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:46:12\n@@ -62,6 +75,9 @@ LL |       } else if let a = 1 {\n LL | |         println!(\"irrefutable pattern\");\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n warning: 6 warnings emitted\n "}, {"sha": "4e8050c81b0d34bc3053b22a2d144fda4bcad21a", "filename": "src/test/ui/generator/yield-outside-generator-issue-78653.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,7 @@\n+#![feature(generators)]\n+\n+fn main() {\n+    yield || for i in 0 { }\n+    //~^ ERROR yield expression outside of generator literal\n+    //~| ERROR `{integer}` is not an iterator\n+}"}, {"sha": "f0c7cb0e5d50c305fdad3f45b1620368f2f1a082", "filename": "src/test/ui/generator/yield-outside-generator-issue-78653.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-outside-generator-issue-78653.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,21 @@\n+error[E0627]: yield expression outside of generator literal\n+  --> $DIR/yield-outside-generator-issue-78653.rs:4:5\n+   |\n+LL |     yield || for i in 0 { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `{integer}` is not an iterator\n+  --> $DIR/yield-outside-generator-issue-78653.rs:4:23\n+   |\n+LL |     yield || for i in 0 { }\n+   |                       ^ `{integer}` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `{integer}`\n+   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `{integer}`\n+   = note: required by `into_iter`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0627.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "56befe3a0a75d7eff1216f6c2080a11176b488c9", "filename": "src/test/ui/issues/issue-49040.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -7,10 +7,8 @@ LL | #![allow(unused_variables)];\n error[E0601]: `main` function not found in crate `issue_49040`\n   --> $DIR/issue-49040.rs:1:1\n    |\n-LL | / #![allow(unused_variables)];\n-LL | |\n-LL | | fn foo() {}\n-   | |__^ consider adding a `main` function to `$DIR/issue-49040.rs`\n+LL | #![allow(unused_variables)];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider adding a `main` function to `$DIR/issue-49040.rs`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7549eae7016b56844c89fde92fffafb06de1d8a8", "filename": "src/test/ui/pattern/usefulness/deny-irrefutable-let-patterns.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,3 +1,6 @@\n+#![feature(if_let_guard)]\n+#![allow(incomplete_features)]\n+\n #![deny(irrefutable_let_patterns)]\n \n fn main() {\n@@ -6,4 +9,9 @@ fn main() {\n     while let _ = 5 { //~ ERROR irrefutable `while let` pattern\n         break;\n     }\n+\n+    match 5 {\n+        _ if let _ = 2 => {} //~ ERROR irrefutable `if let` guard pattern\n+        _ => {}\n+    }\n }"}, {"sha": "d6926ee12eeaa6673bbe8aec2e9fd51e5cb43e2d", "filename": "src/test/ui/pattern/usefulness/deny-irrefutable-let-patterns.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,22 +1,36 @@\n error: irrefutable `if let` pattern\n-  --> $DIR/deny-irrefutable-let-patterns.rs:4:5\n+  --> $DIR/deny-irrefutable-let-patterns.rs:7:5\n    |\n LL |     if let _ = 5 {}\n    |     ^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/deny-irrefutable-let-patterns.rs:1:9\n+  --> $DIR/deny-irrefutable-let-patterns.rs:4:9\n    |\n LL | #![deny(irrefutable_let_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this pattern will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n \n error: irrefutable `while let` pattern\n-  --> $DIR/deny-irrefutable-let-patterns.rs:6:5\n+  --> $DIR/deny-irrefutable-let-patterns.rs:9:5\n    |\n LL | /     while let _ = 5 {\n LL | |         break;\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n+\n+error: irrefutable `if let` guard pattern\n+  --> $DIR/deny-irrefutable-let-patterns.rs:14:18\n+   |\n+LL |         _ if let _ = 2 => {}\n+   |                  ^\n+   |\n+   = note: this pattern will always match, so the guard is useless\n+   = help: consider removing the guard and adding a `let` inside the match arm\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "6215259e4865740ceae2115b1de1f99f1d2735fd", "filename": "src/test/ui/resolve/issue-82156.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    super(); //~ ERROR failed to resolve: there are too many leading `super` keywords\n+}"}, {"sha": "d53599dcce61bd82418549e0953ac419f92b8043", "filename": "src/test/ui/resolve/issue-82156.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-82156.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: there are too many leading `super` keywords\n+  --> $DIR/issue-82156.rs:2:5\n+   |\n+LL |     super();\n+   |     ^^^^^ there are too many leading `super` keywords\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "c7627f1c3c50c1c6c100d381cbb8a47c656a0926", "filename": "src/test/ui/rfc-2294-if-let-guard/warns.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1,4 +1,4 @@\n-error: irrefutable `if let` guard\n+error: irrefutable `if let` guard pattern\n   --> $DIR/warns.rs:7:24\n    |\n LL |         Some(x) if let () = x => {}\n@@ -9,6 +9,8 @@ note: the lint level is defined here\n    |\n LL | #[deny(irrefutable_let_patterns)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this pattern will always match, so the guard is useless\n+   = help: consider removing the guard and adding a `let` inside the match arm\n \n error: unreachable pattern\n   --> $DIR/warns.rs:16:25"}, {"sha": "04e77bf9470a29d38d78dc9490ca081fa8932784", "filename": "src/test/ui/while-let.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fwhile-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftest%2Fui%2Fwhile-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhile-let.stderr?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -10,6 +10,8 @@ LL | |     });\n    | |_______- in this macro invocation\n    |\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n+   = note: this pattern will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `while let` pattern\n@@ -23,6 +25,8 @@ LL | |         println!(\"irrefutable pattern\");\n LL | |     });\n    | |_______- in this macro invocation\n    |\n+   = note: this pattern will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `while let` pattern\n@@ -33,6 +37,9 @@ LL | |         println!(\"irrefutable pattern\");\n LL | |         break;\n LL | |     }\n    | |_____^\n+   |\n+   = note: this pattern will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n \n warning: 3 warnings emitted\n "}, {"sha": "bf5a5d5e5d3ae842a63bfce6d070dfd438cf6070", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -1 +1 @@\n-Subproject commit ab64d1393b5b77c66b6534ef5023a1b89ee7bf64\n+Subproject commit bf5a5d5e5d3ae842a63bfce6d070dfd438cf6070"}, {"sha": "9ff7ef7cc3b55e17cb9acf107a732c5fb11e8ce5", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8599bff5a3556059817503030e248507706e96b4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8599bff5a3556059817503030e248507706e96b4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=8599bff5a3556059817503030e248507706e96b4", "patch": "@@ -241,9 +241,12 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && eq_generics(lg, rg)\n                 && both(lb, rb, |l, r| eq_block(l, r))\n         }\n-        (Mod(l), Mod(r)) => {\n-            l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind))\n-        }\n+        (Mod(lu, lmk), Mod(ru, rmk)) => lu == ru && match (lmk, rmk) {\n+            (ModKind::Loaded(litems, linline, _), ModKind::Loaded(ritems, rinline, _)) =>\n+                linline == rinline && over(litems, ritems, |l, r| eq_item(l, r, eq_item_kind)),\n+            (ModKind::Unloaded, ModKind::Unloaded) => true,\n+            _ => false,\n+        },\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n                 && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))"}]}