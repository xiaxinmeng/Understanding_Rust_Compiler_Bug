{"sha": "51500882166c403907be4d2977df6a30d5d1993b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNTAwODgyMTY2YzQwMzkwN2JlNGQyOTc3ZGY2YTMwZDVkMTk5M2I=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-04-26T14:22:35Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-04-26T14:22:35Z"}, "message": "Merge pull request #882 from Manishearth/rustup\n\nRustup to rustc 1.10.0-nightly (645dd013a 2016-04-24); release 0.0.64", "tree": {"sha": "aee6b066b6b1f009b2e80f2c1dae5fbdfb2b6bc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aee6b066b6b1f009b2e80f2c1dae5fbdfb2b6bc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51500882166c403907be4d2977df6a30d5d1993b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51500882166c403907be4d2977df6a30d5d1993b", "html_url": "https://github.com/rust-lang/rust/commit/51500882166c403907be4d2977df6a30d5d1993b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51500882166c403907be4d2977df6a30d5d1993b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66e90303fe7cd0df6f3191d157e65f4d58b5de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e90303fe7cd0df6f3191d157e65f4d58b5de5", "html_url": "https://github.com/rust-lang/rust/commit/c66e90303fe7cd0df6f3191d157e65f4d58b5de5"}, {"sha": "ffd9f5a3ac23fbc264290d365f76df17195c7493", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd9f5a3ac23fbc264290d365f76df17195c7493", "html_url": "https://github.com/rust-lang/rust/commit/ffd9f5a3ac23fbc264290d365f76df17195c7493"}], "stats": {"total": 152, "additions": 93, "deletions": 59}, "files": [{"sha": "37cdcc571a03d05b9de21af60a10b9a09eadafa4", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -1,7 +1,8 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n-## Unreleased\n+## 0.0.64 \u2014 2016-04-26\n+* Rustup to *rustc 1.10.0-nightly (645dd013a 2016-04-24)*\n * New lints: [`temporary_cstring_as_ptr`], [`unsafe_removed_from_name`], and [`mem_forget`]\n \n ## 0.0.63 \u2014 2016-04-08"}, {"sha": "5a8968ac2f58ece383ae2d8b52d54b774a311647", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.63\"\n+version = \"0.0.64\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "cdaf53684c539c161585a460652ebae6c46c5698", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -43,7 +43,7 @@ struct ExVisitor<'v> {\n \n impl<'v> Visitor<'v> for ExVisitor<'v> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprClosure(_, _, ref block) = expr.node {\n+        if let ExprClosure(_, _, ref block, _) = expr.node {\n             let complex = {\n                 if block.stmts.is_empty() {\n                     if let Some(ref ex) = block.expr {"}, {"sha": "c9a9ef85ede9c8d1ecf850e68e2c6e62770750d6", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -40,7 +40,7 @@ impl LateLintPass for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, ref blk) = expr.node {\n+    if let ExprClosure(_, ref decl, ref blk, _) = expr.node {\n         if !blk.stmts.is_empty() {\n             // || {foo(); bar()}; can't be reduced here\n             return;"}, {"sha": "70abb7a1aac7f3c35728c2ed491c66860991688b", "filename": "src/loops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -285,7 +285,7 @@ impl LateLintPass for LoopsPass {\n                 let iter_expr = &method_args[0];\n                 if let Some(lhs_constructor) = path.segments.last() {\n                     if method_name.node.as_str() == \"next\" &&\n-                       match_trait_method(cx, match_expr, &[\"core\", \"iter\", \"Iterator\"]) &&\n+                       match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n                        lhs_constructor.identifier.name.as_str() == \"Some\" &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n@@ -305,7 +305,7 @@ impl LateLintPass for LoopsPass {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.node.as_str() == \"collect\" &&\n-                   match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+                   match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n                               expr.span,\n@@ -488,7 +488,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        object,\n                                        method_name));\n                 }\n-            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(cx,\n                           ITER_NEXT_LOOP,\n                           expr.span,\n@@ -739,11 +739,11 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::VEC) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n     match_type(cx, ty, &paths::HASHMAP) ||\n-    match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n-    match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n-    match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n+    match_type(cx, ty, &paths::HASHSET) ||\n+    match_type(cx, ty, &paths::VEC_DEQUE) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n     match_type(cx, ty, &paths::BTREEMAP) ||\n-    match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n+    match_type(cx, ty, &paths::BTREESET)\n }\n \n fn is_iterable_array(ty: ty::Ty) -> bool {"}, {"sha": "d015a165457a760472f18f3fb2403a413f9f8335", "filename": "src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -25,7 +25,7 @@ impl LateLintPass for MapClonePass {\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n             if name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, ref blk) => {\n+                    ExprClosure(_, ref decl, ref blk, _) => {\n                         if_let_chain! {\n                             [\n                             // just one expression in the closure\n@@ -51,7 +51,7 @@ impl LateLintPass for MapClonePass {\n                                 else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n                                     if clone_call.node.as_str() == \"clone\" &&\n                                         clone_args.len() == 1 &&\n-                                        match_trait_method(cx, closure_expr, &[\"core\", \"clone\", \"Clone\"]) &&\n+                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                         expr_eq_ident(&clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n@@ -96,7 +96,7 @@ fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n }\n \n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n-    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n     } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")"}, {"sha": "e25154bd38b653b133a980dfe30624cf0c4fa4f5", "filename": "src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -752,7 +752,7 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n /// lint use of `filter().next() for Iterators`\n fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n     // lint if caller of `.filter().next()` is an Iterator\n-    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by calling `.find(p)` \\\n                    instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -776,7 +776,7 @@ fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n                        is_some_args: &MethodArgs) {\n     // lint if caller of search is an Iterator\n-    if match_trait_method(cx, &*is_some_args[0], &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, &*is_some_args[0], &paths::ITERATOR) {\n         let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more succinctly expressed \\\n                            by calling `any()`.\",\n                           search_method);"}, {"sha": "eaba19b08e418fc9a843da6adff49a1c05de7dd1", "filename": "src/minmax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use std::cmp::{PartialOrd, Ordering};\n use syntax::ptr::P;\n-use utils::{match_def_path, span_lint};\n+use utils::{match_def_path, paths, span_lint};\n \n /// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n ///\n@@ -57,9 +57,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n         if let ExprPath(None, _) = path.node {\n             let def_id = cx.tcx.def_map.borrow()[&path.id].def_id();\n \n-            if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"min\"]) {\n+            if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)\n-            } else if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"max\"]) {\n+            } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n                 fetch_const(args, MinMax::Max)\n             } else {\n                 None"}, {"sha": "a7ab59497ac6bbcdfca5349332318c80201dcaea", "filename": "src/misc_early.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -128,7 +128,7 @@ impl EarlyLintPass for MiscEarly {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprKind::Call(ref paren, _) = expr.node {\n             if let ExprKind::Paren(ref closure) = paren.node {\n-                if let ExprKind::Closure(_, ref decl, ref block) = closure.node {\n+                if let ExprKind::Closure(_, ref decl, ref block, _) = closure.node {\n                     span_lint_and_then(cx,\n                                        REDUNDANT_CLOSURE_CALL,\n                                        expr.span,\n@@ -150,7 +150,7 @@ impl EarlyLintPass for MiscEarly {\n                 let StmtKind::Decl(ref first, _) = w[0].node,\n                 let DeclKind::Local(ref local) = first.node,\n                 let Option::Some(ref t) = local.init,\n-                let ExprKind::Closure(_,_,_) = t.node,\n+                let ExprKind::Closure(_,_,_,_) = t.node,\n                 let PatKind::Ident(_,sp_ident,_) = local.pat.node,\n                 let StmtKind::Semi(ref second,_) = w[1].node,\n                 let ExprKind::Assign(_,ref call) = second.node,"}, {"sha": "e96212a9cefa3151fb5ec9e06d38a07c8eb99c03", "filename": "src/ranges.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet, span_lint, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, paths, snippet, span_lint, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -39,7 +39,7 @@ impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             // Range with step_by(0).\n-            if name.as_str() == \"step_by\" && args.len() == 2 && is_range(cx, &args[0]) &&\n+            if name.as_str() == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n                is_integer_literal(&args[1], 0) {\n                 span_lint(cx,\n                           RANGE_STEP_BY_ZERO,\n@@ -77,10 +77,13 @@ impl LateLintPass for StepByZero {\n     }\n }\n \n-fn is_range(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tcx.expr_ty(expr);\n-    // Note: RangeTo and RangeFull don't have step_by\n-    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n+\n+    // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n+    match_type(cx, ty, &paths::RANGE)\n+        || match_type(cx, ty, &paths::RANGE_FROM)\n+        || match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n }"}, {"sha": "fe4c6d309520fc90536966a30f20c1cb3cce0f99", "filename": "src/utils/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -333,8 +333,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n                 // TODO: _ty\n             }\n-            ExprClosure(cap, _, ref b) => {\n-                let c: fn(_, _, _) -> _ = ExprClosure;\n+            ExprClosure(cap, _, ref b, _) => {\n+                let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n                 self.hash_block(b);"}, {"sha": "83247a59174930fb40e639d7540ba844fcc8bc0d", "filename": "src/utils/mod.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -122,23 +122,33 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n /// ```\n /// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n /// ```\n+///\n+/// See also the `paths` module.\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n-    let krate = &cx.tcx.crate_name(def_id.krate);\n-    if krate != &path[0] {\n-        return false;\n+    use syntax::parse::token;\n+\n+    struct AbsolutePathBuffer {\n+        names: Vec<token::InternedString>,\n     }\n \n-    let path = &path[1..];\n-    let other = cx.tcx.def_path(def_id).data;\n+    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n+        fn root_mode(&self) -> &ty::item_path::RootMode {\n+            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n+            ABSOLUTE\n+        }\n \n-    if other.len() != path.len() {\n-        return false;\n+        fn push(&mut self, text: &str) {\n+            self.names.push(token::intern(text).as_str());\n+        }\n     }\n \n-    other.into_iter()\n-         .map(|e| e.data)\n-         .zip(path)\n-         .all(|(nm, p)| nm.as_interned_str() == *p)\n+    let mut apb = AbsolutePathBuffer {\n+        names: vec![],\n+    };\n+\n+    cx.tcx.push_item_path(&mut apb, def_id);\n+\n+    apb.names == path\n }\n \n /// Check if type is struct or enum type with given def path.\n@@ -730,9 +740,12 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n         Some(unwrap_unstable(expr))\n     }\n \n-    match unwrap_unstable(&expr).node {\n+    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n+    // `#[no_std]`. Testing both instead of resolving the paths.\n+\n+    match unwrap_unstable(expr).node {\n         ExprPath(None, ref path) => {\n-            if match_path(path, &paths::RANGE_FULL) {\n+            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: None,\n@@ -743,31 +756,31 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n             }\n         }\n         ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &paths::RANGE_FROM) {\n+            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: None,\n                     limits: RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) || match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::Closed,\n                 })\n-            } else if match_path(path, &paths::RANGE) {\n+            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::Closed,\n                 })\n-            } else if match_path(path, &paths::RANGE_TO) {\n+            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: get_field(\"end\", fields),"}, {"sha": "c52324a7448f1983aaa5027f06f3a878ec99d804", "filename": "src/utils/paths.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -1,12 +1,16 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n-pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n+pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n-pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const CLONE: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n-pub const CLONE_TRAIT: [&'static str; 2] = [\"clone\", \"Clone\"];\n+pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREESET: [&'static str; 4] = [\"collections\", \"btree\", \"set\", \"BTreeSet\"];\n+pub const CLONE: [&'static str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n+pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n+pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n+pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n@@ -15,25 +19,36 @@ pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\n pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n-pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n+pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHSET: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const MEM_FORGET: [&'static str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RANGE_FROM: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n-pub const RANGE: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n+pub const RANGE: [&'static str; 3] = [\"core\", \"ops\", \"Range\"];\n+pub const RANGE_FROM: [&'static str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FROM_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL: [&'static str; 3] = [\"core\", \"ops\", \"RangeFull\"];\n+pub const RANGE_FULL_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE: [&'static str; 3] = [\"core\", \"ops\", \"RangeInclusive\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY_STD: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_INCLUSIVE_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeInclusive\"];\n+pub const RANGE_STD: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO: [&'static str; 3] = [\"core\", \"ops\", \"RangeTo\"];\n+pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_INCLUSIVE_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const REGEX: [&'static str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_NEW: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n-pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];"}, {"sha": "fc12155ce9cb816b7d0569d9a9a5ba66511b2890", "filename": "tests/compile-fail/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51500882166c403907be4d2977df6a30d5d1993b/tests%2Fcompile-fail%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51500882166c403907be4d2977df6a30d5d1993b/tests%2Fcompile-fail%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frange.rs?ref=51500882166c403907be4d2977df6a30d5d1993b", "patch": "@@ -1,4 +1,5 @@\n #![feature(step_by)]\n+#![feature(inclusive_range_syntax)]\n #![feature(plugin)]\n #![plugin(clippy)]\n \n@@ -14,6 +15,7 @@ fn main() {\n     (0..1).step_by(1);\n \n     (1..).step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator\n+    (1...2).step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator\n \n     let x = 0..1;\n     x.step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator"}]}