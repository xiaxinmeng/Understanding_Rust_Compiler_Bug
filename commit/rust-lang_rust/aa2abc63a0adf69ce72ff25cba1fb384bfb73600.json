{"sha": "aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMmFiYzYzYTBhZGY2OWNlNzJmZjI1Y2JhMWZiMzg0YmZiNzM2MDA=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-09-08T21:14:15Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-09-08T21:14:15Z"}, "message": "Merge pull request #288 from marcusklaas/closure-return\n\nFormat closures' return types", "tree": {"sha": "ec02e52d856f255156d8c5d5e3686c561ebfb007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec02e52d856f255156d8c5d5e3686c561ebfb007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "html_url": "https://github.com/rust-lang/rust/commit/aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db79a5aec5055b58c5f8f576adc1aa551087bce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/db79a5aec5055b58c5f8f576adc1aa551087bce6", "html_url": "https://github.com/rust-lang/rust/commit/db79a5aec5055b58c5f8f576adc1aa551087bce6"}, {"sha": "582aa4f2fed9ab3e6bcfe4112c20cae42a5570e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/582aa4f2fed9ab3e6bcfe4112c20cae42a5570e0", "html_url": "https://github.com/rust-lang/rust/commit/582aa4f2fed9ab3e6bcfe4112c20cae42a5570e0"}], "stats": {"total": 117, "additions": 85, "deletions": 32}, "files": [{"sha": "ab20dc1738dd29b307e094d1066fa146553ec538", "filename": "src/expr.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "patch": "@@ -163,9 +163,12 @@ fn rewrite_closure(capture: ast::CaptureClause,\n \n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n-    let argument_budget = try_opt!(width.checked_sub(4 + mover.len()));\n+    let budget = try_opt!(width.checked_sub(4 + mover.len()));\n     // 1 = |\n     let argument_offset = offset + 1;\n+    let ret_str = try_opt!(fn_decl.output.rewrite(context, budget, argument_offset));\n+    // 1 = space between arguments and return type.\n+    let horizontal_budget = budget.checked_sub(ret_str.len() + 1).unwrap_or(0);\n \n     let arg_items = itemize_list(context.codemap,\n                                  fn_decl.inputs.iter(),\n@@ -176,13 +179,37 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                                  span_after(span, \"|\", context.codemap),\n                                  body.span.lo);\n \n-    let fmt = ListFormatting::for_fn(argument_budget, argument_offset);\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::HorizontalVertical,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: argument_offset,\n+        h_width: horizontal_budget,\n+        v_width: budget,\n+        ends_with_newline: false,\n+    };\n     let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n-    let prefix = format!(\"{}|{}|\", mover, list_str);\n+    let mut prefix = format!(\"{}|{}|\", mover, list_str);\n+\n+    if !ret_str.is_empty() {\n+        if prefix.contains('\\n') {\n+            prefix.push('\\n');\n+            prefix.push_str(&make_indent(argument_offset));\n+        } else {\n+            prefix.push(' ');\n+        }\n+        prefix.push_str(&ret_str);\n+    }\n+\n     let closure_indent = closure_indent(context, offset);\n \n     // Try to format closure body as a single line expression without braces.\n-    if body.stmts.is_empty() {\n+    if is_simple_block(body, context.codemap) && !prefix.contains('\\n') {\n+        let (spacer, closer) = if ret_str.is_empty() {\n+            (\" \", \"\")\n+        } else {\n+            (\" { \", \" }\")\n+        };\n         let expr = body.expr.as_ref().unwrap();\n         // All closure bodies are blocks in the eyes of the AST, but we may not\n         // want to unwrap them when they only contain a single expression.\n@@ -192,28 +219,31 @@ fn rewrite_closure(capture: ast::CaptureClause,\n             }\n             _ => expr,\n         };\n-\n-        // 1 = the separating space between arguments and the body.\n-        let extra_offset = extra_offset(&prefix, offset) + 1;\n-        let budget = try_opt!(width.checked_sub(extra_offset));\n+        let extra_offset = extra_offset(&prefix, offset) + spacer.len();\n+        let budget = try_opt!(width.checked_sub(extra_offset + closer.len()));\n         let rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n \n         // Checks if rewrite succeeded and fits on a single line.\n         let accept_rewrite = rewrite.as_ref().map(|result| !result.contains('\\n')).unwrap_or(false);\n \n         if accept_rewrite {\n-            return Some(format!(\"{} {}\", prefix, rewrite.unwrap()));\n+            return Some(format!(\"{}{}{}{}\", prefix, spacer, rewrite.unwrap(), closer));\n         }\n     }\n \n     // We couldn't format the closure body as a single line expression; fall\n     // back to block formatting.\n     let inner_context = context.overflow_context(closure_indent - context.block_indent);\n-    let body_rewrite = if let ast::Expr_::ExprBlock(ref inner) = body.expr.as_ref().unwrap().node {\n-        inner.rewrite(&inner_context, 0, 0)\n-    } else {\n-        body.rewrite(&inner_context, 0, 0)\n-    };\n+    let body_rewrite = body.expr\n+                           .as_ref()\n+                           .and_then(|body_expr| {\n+                               if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n+                                   Some(inner.rewrite(&inner_context, 2, 0))\n+                               } else {\n+                                   None\n+                               }\n+                           })\n+                           .unwrap_or_else(|| body.rewrite(&inner_context, 2, 0));\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }"}, {"sha": "7555ea01199ac0171e2dda356317252df94bf418", "filename": "src/items.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "patch": "@@ -17,7 +17,7 @@ use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic,\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n-use rewrite::Rewrite;\n+use rewrite::{Rewrite, RewriteContext};\n use config::{Config, BlockIndentStyle, Density};\n \n use syntax::{ast, abi};\n@@ -207,7 +207,8 @@ impl<'a> FmtVisitor<'a> {\n                                                           generics_span));\n         result.push_str(&generics_str);\n \n-        let ret_str = self.rewrite_return(&fd.output, indent);\n+        let context = self.get_context();\n+        let ret_str = fd.output.rewrite(&context, self.config.max_width - indent, indent).unwrap();\n \n         // Args.\n         let (one_line_budget, multi_line_budget, mut arg_indent) =\n@@ -902,14 +903,22 @@ impl<'a> FmtVisitor<'a> {\n             Some(format!(\" where {}\", preds_str))\n         }\n     }\n+}\n \n-    fn rewrite_return(&self, ret: &ast::FunctionRetTy, indent: usize) -> String {\n-        match *ret {\n-            ast::FunctionRetTy::DefaultReturn(_) => String::new(),\n-            ast::FunctionRetTy::NoReturn(_) => \"-> !\".to_owned(),\n+impl Rewrite for ast::FunctionRetTy {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match *self {\n+            ast::FunctionRetTy::DefaultReturn(_) => Some(String::new()),\n+            ast::FunctionRetTy::NoReturn(_) => {\n+                if width >= 4 {\n+                    Some(\"-> !\".to_owned())\n+                } else {\n+                    None\n+                }\n+            }\n             ast::FunctionRetTy::Return(ref ty) => {\n-                let ctxt = &self.get_context();\n-                format!(\"-> {}\", ty.rewrite(ctxt, ctxt.config.max_width, indent).unwrap())\n+                let inner_width = try_opt!(width.checked_sub(3));\n+                ty.rewrite(context, inner_width, offset + 3).map(|r| format!(\"-> {}\", r))\n             }\n         }\n     }"}, {"sha": "43ec6860243d447ea63e16bc1b633bec6ac0a8ce", "filename": "tests/source/closure.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "patch": "@@ -3,9 +3,6 @@\n fn main() {\n     let square = ( |i:  i32 | i  *  i );\n \n-    let commented = |/* first */ a /*argument*/, /* second*/ b: WithType /* argument*/, /* ignored */ _ |\n-        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbb);\n-\n     let commented = |/* first */ a /*argument*/, /* second*/ b: WithType /* argument*/, /* ignored */ _ |\n         (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n \n@@ -28,12 +25,22 @@ fn main() {\n \n     let empty = |arg|    {};\n \n+    let simple = |arg| { /* TODO(#27): comment formatting */ foo(arg) };\n+\n     let test = |  | { do_something(); do_something_else(); };\n \n     let arg_test = |big_argument_name, test123| looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame();\n \n     let arg_test = |big_argument_name, test123| {looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()};\n \n+    let simple_closure = move ||   ->  () {};\n+\n+    let closure = |input: Ty| -> Option<String> {\n+        foo()\n+    };\n+\n+    let closure_with_return_type = |aaaaaaaaaaaaaaaaaaaaaaarg1, aaaaaaaaaaaaaaaaaaaaaaarg2| -> Strong { \"sup\".to_owned() };\n+\n     |arg1, arg2, _, _, arg3, arg4| { let temp = arg4 + arg3;\n                                      arg2 * arg1 - temp }\n }"}, {"sha": "a0565167093b1a4ee01ca599680e681f2c19a7d5", "filename": "tests/target/closure.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2abc63a0adf69ce72ff25cba1fb384bfb73600/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=aa2abc63a0adf69ce72ff25cba1fb384bfb73600", "patch": "@@ -3,13 +3,6 @@\n fn main() {\n     let square = (|i: i32| i * i);\n \n-    let commented = |// first\n-                     a, // argument\n-                     // second\n-                     b: WithType, // argument\n-                     // ignored\n-                     _| (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbb);\n-\n     let commented = |// first\n                      a, // argument\n                      // second\n@@ -46,6 +39,10 @@ fn main() {\n \n     let empty = |arg| {};\n \n+    let simple = |arg| { /* TODO(#27): comment formatting */\n+                     foo(arg)\n+                 };\n+\n     let test = || {\n                    do_something();\n                    do_something_else();\n@@ -59,6 +56,16 @@ fn main() {\n                        looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n                    };\n \n+    let simple_closure = move || -> () {};\n+\n+    let closure = |input: Ty| -> Option<String> { foo() };\n+\n+    let closure_with_return_type = |aaaaaaaaaaaaaaaaaaaaaaarg1,\n+                                    aaaaaaaaaaaaaaaaaaaaaaarg2|\n+                                    -> Strong {\n+                                       \"sup\".to_owned()\n+                                   };\n+\n     |arg1, arg2, _, _, arg3, arg4| {\n         let temp = arg4 + arg3;\n         arg2 * arg1 - temp"}]}