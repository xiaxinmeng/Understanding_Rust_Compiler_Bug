{"sha": "803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwM2ZmMmU1NWVlYjZiZDFkOTAyOGZiYmZmZTM0NzIxZjBlNmQ0NTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-28T13:36:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-28T13:36:44Z"}, "message": "Merge #7804\n\n7804: Introduce TypeCtor::Scalar r=lnicola a=Veykril\n\n`TypeCtor::Int(..) | TypeCtor::Float(..) | TypeCtor::Char | TypeCtor::Bool` => `TypeCtor::Scalar(..)`, in this case we can actually just straight up use `chalk_ir::Scalar` already since its just a POD without any IDs or anything.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "c0df3cba7d22fe49e1ea33dde6ed8d4c9e0f663f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0df3cba7d22fe49e1ea33dde6ed8d4c9e0f663f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgO5xsCRBK7hj4Ov3rIwAAdHIIABBJQbT7X01Z5eul2IDTheBq\ne9Mr0K1+4jePPmme/bz0Fay6t2uI3Xzr4/UHYp5mNYKP512BuFpX5zadnT9lqTwy\nptI5AORSB+fVKK95gZ8khAA238tq1TDNthG6a8ZJjm8Q2i6E7Vm7ACC6fGfnW79j\nFdD3oHvwfJwnGWv/81akF945Ao/yAkJf1kCGtZbDALWOn/3CPmHUqHIKcJBs9Fij\n3N4NPqmWnpHoIP27sGS/9cKIAIkGo8y7PG65U8yXj9/AoteGoln8EvwziS4eYaEt\nRdy2C0a3BqHrCfjUQs4SIiuKSkSCfjKj39tiPlDso6RcHm6FLsJCjcq8TJS4exA=\n=YNMb\n-----END PGP SIGNATURE-----\n", "payload": "tree c0df3cba7d22fe49e1ea33dde6ed8d4c9e0f663f\nparent 7f57a01b3d524a5ed85a30265b8aee2c81118f15\nparent 7c2dd85a32e320fd412a720ea5b847c66bf246ae\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614519404 +0000\ncommitter GitHub <noreply@github.com> 1614519404 +0000\n\nMerge #7804\n\n7804: Introduce TypeCtor::Scalar r=lnicola a=Veykril\n\n`TypeCtor::Int(..) | TypeCtor::Float(..) | TypeCtor::Char | TypeCtor::Bool` => `TypeCtor::Scalar(..)`, in this case we can actually just straight up use `chalk_ir::Scalar` already since its just a POD without any IDs or anything.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "html_url": "https://github.com/rust-lang/rust/commit/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f57a01b3d524a5ed85a30265b8aee2c81118f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f57a01b3d524a5ed85a30265b8aee2c81118f15", "html_url": "https://github.com/rust-lang/rust/commit/7f57a01b3d524a5ed85a30265b8aee2c81118f15"}, {"sha": "7c2dd85a32e320fd412a720ea5b847c66bf246ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2dd85a32e320fd412a720ea5b847c66bf246ae", "html_url": "https://github.com/rust-lang/rust/commit/7c2dd85a32e320fd412a720ea5b847c66bf246ae"}], "stats": {"total": 689, "additions": 270, "deletions": 419}, "files": [{"sha": "4109b2ea84faf4526956af37bf2cfa81f46eab45", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -32,8 +32,8 @@ use hir_ty::{\n     method_resolution,\n     traits::{FnTrait, Solution, SolutionVariables},\n     ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n-    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n-    TyDefId, TyKind, TypeCtor,\n+    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n+    Ty, TyDefId, TyKind, TypeCtor,\n };\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n@@ -1553,7 +1553,10 @@ impl Type {\n         )\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. }))\n+        matches!(\n+            self.ty.value,\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Scalar(Scalar::Bool), .. })\n+        )\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {"}, {"sha": "40beb2f7a7c82d626d4f3f92110f5fd8915b7161", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -24,7 +24,7 @@ use test_utils::mark;\n use crate::{\n     adt::StructKind,\n     body::{Body, BodySourceMap, Expander, LabelSource, PatPtr, SyntheticSyntax},\n-    builtin_type::{BuiltinFloat, BuiltinInt},\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     diagnostics::{InactiveCode, MacroError, UnresolvedProcMacro},\n     expr::{\n@@ -1065,19 +1065,24 @@ impl From<ast::LiteralKind> for Literal {\n     fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n         match ast_lit_kind {\n             LiteralKind::IntNumber(lit) => {\n-                if let Some(float_suffix) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n-                    return Literal::Float(Default::default(), Some(float_suffix));\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    return Literal::Float(Default::default(), builtin);\n+                } else if let builtin @ Some(_) =\n+                    lit.suffix().and_then(|it| BuiltinInt::from_suffix(&it))\n+                {\n+                    Literal::Int(Default::default(), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(|it| BuiltinUint::from_suffix(&it));\n+                    Literal::Uint(Default::default(), builtin)\n                 }\n-                let ty = lit.suffix().and_then(|it| BuiltinInt::from_suffix(&it));\n-                Literal::Int(Default::default(), ty)\n             }\n             LiteralKind::FloatNumber(lit) => {\n                 let ty = lit.suffix().and_then(|it| BuiltinFloat::from_suffix(&it));\n                 Literal::Float(Default::default(), ty)\n             }\n             LiteralKind::ByteString(_) => Literal::ByteString(Default::default()),\n             LiteralKind::String(_) => Literal::String(Default::default()),\n-            LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n+            LiteralKind::Byte => Literal::Uint(Default::default(), Some(BuiltinUint::U8)),\n             LiteralKind::Bool(val) => Literal::Bool(val),\n             LiteralKind::Char => Literal::Char(Default::default()),\n         }"}, {"sha": "7cbaf30b858403f411044176fed313d5e1d056cb", "filename": "crates/hir_def/src/builtin_type.rs", "status": "modified", "additions": 60, "deletions": 72, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -6,38 +6,32 @@\n use std::fmt;\n \n use hir_expand::name::{name, AsName, Name};\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum Signedness {\n-    Signed,\n-    Unsigned,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum IntBitness {\n-    Xsize,\n-    X8,\n-    X16,\n-    X32,\n-    X64,\n-    X128,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum FloatBitness {\n-    X32,\n-    X64,\n+/// Different signed int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinInt {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct BuiltinInt {\n-    pub signedness: Signedness,\n-    pub bitness: IntBitness,\n+/// Different unsigned int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinUint {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct BuiltinFloat {\n-    pub bitness: FloatBitness,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinFloat {\n+    F32,\n+    F64,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -46,6 +40,7 @@ pub enum BuiltinType {\n     Bool,\n     Str,\n     Int(BuiltinInt),\n+    Uint(BuiltinUint),\n     Float(BuiltinFloat),\n }\n \n@@ -56,19 +51,19 @@ impl BuiltinType {\n         (name![bool], BuiltinType::Bool),\n         (name![str],  BuiltinType::Str),\n \n-        (name![isize], BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name![isize], BuiltinType::Int(BuiltinInt::Isize)),\n         (name![i8],    BuiltinType::Int(BuiltinInt::I8)),\n         (name![i16],   BuiltinType::Int(BuiltinInt::I16)),\n         (name![i32],   BuiltinType::Int(BuiltinInt::I32)),\n         (name![i64],   BuiltinType::Int(BuiltinInt::I64)),\n         (name![i128],  BuiltinType::Int(BuiltinInt::I128)),\n \n-        (name![usize], BuiltinType::Int(BuiltinInt::USIZE)),\n-        (name![u8],    BuiltinType::Int(BuiltinInt::U8)),\n-        (name![u16],   BuiltinType::Int(BuiltinInt::U16)),\n-        (name![u32],   BuiltinType::Int(BuiltinInt::U32)),\n-        (name![u64],   BuiltinType::Int(BuiltinInt::U64)),\n-        (name![u128],  BuiltinType::Int(BuiltinInt::U128)),\n+        (name![usize], BuiltinType::Uint(BuiltinUint::Usize)),\n+        (name![u8],    BuiltinType::Uint(BuiltinUint::U8)),\n+        (name![u16],   BuiltinType::Uint(BuiltinUint::U16)),\n+        (name![u32],   BuiltinType::Uint(BuiltinUint::U32)),\n+        (name![u64],   BuiltinType::Uint(BuiltinUint::U64)),\n+        (name![u128],  BuiltinType::Uint(BuiltinUint::U128)),\n \n         (name![f32], BuiltinType::Float(BuiltinFloat::F32)),\n         (name![f64], BuiltinType::Float(BuiltinFloat::F64)),\n@@ -81,24 +76,25 @@ impl AsName for BuiltinType {\n             BuiltinType::Char => name![char],\n             BuiltinType::Bool => name![bool],\n             BuiltinType::Str => name![str],\n-            BuiltinType::Int(BuiltinInt { signedness, bitness }) => match (signedness, bitness) {\n-                (Signedness::Signed, IntBitness::Xsize) => name![isize],\n-                (Signedness::Signed, IntBitness::X8) => name![i8],\n-                (Signedness::Signed, IntBitness::X16) => name![i16],\n-                (Signedness::Signed, IntBitness::X32) => name![i32],\n-                (Signedness::Signed, IntBitness::X64) => name![i64],\n-                (Signedness::Signed, IntBitness::X128) => name![i128],\n-\n-                (Signedness::Unsigned, IntBitness::Xsize) => name![usize],\n-                (Signedness::Unsigned, IntBitness::X8) => name![u8],\n-                (Signedness::Unsigned, IntBitness::X16) => name![u16],\n-                (Signedness::Unsigned, IntBitness::X32) => name![u32],\n-                (Signedness::Unsigned, IntBitness::X64) => name![u64],\n-                (Signedness::Unsigned, IntBitness::X128) => name![u128],\n+            BuiltinType::Int(it) => match it {\n+                BuiltinInt::Isize => name![isize],\n+                BuiltinInt::I8 => name![i8],\n+                BuiltinInt::I16 => name![i16],\n+                BuiltinInt::I32 => name![i32],\n+                BuiltinInt::I64 => name![i64],\n+                BuiltinInt::I128 => name![i128],\n+            },\n+            BuiltinType::Uint(it) => match it {\n+                BuiltinUint::Usize => name![usize],\n+                BuiltinUint::U8 => name![u8],\n+                BuiltinUint::U16 => name![u16],\n+                BuiltinUint::U32 => name![u32],\n+                BuiltinUint::U64 => name![u64],\n+                BuiltinUint::U128 => name![u128],\n             },\n-            BuiltinType::Float(BuiltinFloat { bitness }) => match bitness {\n-                FloatBitness::X32 => name![f32],\n-                FloatBitness::X64 => name![f64],\n+            BuiltinType::Float(it) => match it {\n+                BuiltinFloat::F32 => name![f32],\n+                BuiltinFloat::F64 => name![f64],\n             },\n         }\n     }\n@@ -113,31 +109,26 @@ impl fmt::Display for BuiltinType {\n \n #[rustfmt::skip]\n impl BuiltinInt {\n-    pub const ISIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::Xsize   };\n-    pub const I8   : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X8      };\n-    pub const I16  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X16     };\n-    pub const I32  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X32     };\n-    pub const I64  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X64     };\n-    pub const I128 : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X128    };\n-\n-    pub const USIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize };\n-    pub const U8   : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X8    };\n-    pub const U16  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X16   };\n-    pub const U32  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X32   };\n-    pub const U64  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X64   };\n-    pub const U128 : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X128  };\n-\n-\n     pub fn from_suffix(suffix: &str) -> Option<BuiltinInt> {\n         let res = match suffix {\n-            \"isize\" => Self::ISIZE,\n+            \"isize\" => Self::Isize,\n             \"i8\"    => Self::I8,\n             \"i16\"   => Self::I16,\n             \"i32\"   => Self::I32,\n             \"i64\"   => Self::I64,\n             \"i128\"  => Self::I128,\n \n-            \"usize\" => Self::USIZE,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinUint {\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinUint> {\n+        let res = match suffix {\n+            \"usize\" => Self::Usize,\n             \"u8\"    => Self::U8,\n             \"u16\"   => Self::U16,\n             \"u32\"   => Self::U32,\n@@ -152,9 +143,6 @@ impl BuiltinInt {\n \n #[rustfmt::skip]\n impl BuiltinFloat {\n-    pub const F32: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X32 };\n-    pub const F64: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X64 };\n-\n     pub fn from_suffix(suffix: &str) -> Option<BuiltinFloat> {\n         let res = match suffix {\n             \"f32\" => BuiltinFloat::F32,"}, {"sha": "24be9377395ec21e17bd7521218c5133896bfb31", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -17,7 +17,7 @@ use la_arena::{Idx, RawIdx};\n use syntax::ast::RangeOp;\n \n use crate::{\n-    builtin_type::{BuiltinFloat, BuiltinInt},\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     BlockId,\n@@ -43,6 +43,7 @@ pub enum Literal {\n     Char(char),\n     Bool(bool),\n     Int(u64, Option<BuiltinInt>),\n+    Uint(u64, Option<BuiltinUint>),\n     Float(u64, Option<BuiltinFloat>), // FIXME: f64 is not Eq\n }\n "}, {"sha": "b4801cb2158334449a71f6603df8b44f60cde3d8", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -3,8 +3,9 @@\n use std::{borrow::Cow, fmt};\n \n use crate::{\n-    db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n-    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    db::HirDatabase, primitive, utils::generics, ApplicationTy, CallableDefId, FnSig,\n+    GenericPredicate, Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs,\n+    TraitRef, Ty, TypeCtor,\n };\n use arrayvec::ArrayVec;\n use hir_def::{\n@@ -241,10 +242,13 @@ impl HirDisplay for ApplicationTy {\n         }\n \n         match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n+            TypeCtor::Scalar(Scalar::Char) => write!(f, \"char\")?,\n+            TypeCtor::Scalar(Scalar::Float(t)) => {\n+                write!(f, \"{}\", primitive::float_ty_to_string(t))?\n+            }\n+            TypeCtor::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n+            TypeCtor::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n             TypeCtor::Str => write!(f, \"str\")?,\n             TypeCtor::Slice => {\n                 let t = self.parameters.as_single();"}, {"sha": "657f011d26a8ba2a41d7c47b560b897025aea5e9", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -41,7 +41,7 @@ use super::{\n     InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, Scalar,\n };\n \n pub(crate) use unify::unify;\n@@ -684,8 +684,8 @@ impl InferTy {\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => Ty::simple(TypeCtor::Int(IntTy::i32())),\n-            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(FloatTy::f64())),\n+            InferTy::IntVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n             InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }"}, {"sha": "3fec0e431845e5278b60305af30b6fbbdc242b03", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -4,7 +4,6 @@ use std::iter::{repeat, repeat_with};\n use std::{mem, sync::Arc};\n \n use hir_def::{\n-    builtin_type::Signedness,\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -16,10 +15,11 @@ use test_utils::mark;\n \n use crate::{\n     autoderef, method_resolution, op,\n+    primitive::{self, UintTy},\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, OpaqueTyId,\n-    Rawness, Substs, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDefId, InferTy, Mutability, Obligation, OpaqueTyId, Rawness,\n+    Scalar, Substs, TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -120,7 +120,10 @@ impl<'a> InferenceContext<'a> {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n+                );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n@@ -203,7 +206,10 @@ impl<'a> InferenceContext<'a> {\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n+                );\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -321,7 +327,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n                         );\n                     }\n \n@@ -534,10 +540,13 @@ impl<'a> InferenceContext<'a> {\n                         match &inner_ty {\n                             // Fast path for builtins\n                             Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Int(IntTy { signedness: Signedness::Signed, .. }),\n+                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Float(_)),\n                                 ..\n                             })\n-                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n                             | Ty::Infer(InferTy::IntVar(..))\n                             | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Neg trait\n@@ -548,8 +557,18 @@ impl<'a> InferenceContext<'a> {\n                     UnaryOp::Not => {\n                         match &inner_ty {\n                             // Fast path for builtins\n-                            Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. })\n-                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(_), .. })\n+                            Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Bool),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Uint(_)),\n+                                ..\n+                            })\n                             | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Not trait\n                             _ => self\n@@ -561,7 +580,9 @@ impl<'a> InferenceContext<'a> {\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                        BinaryOp::LogicOp(..) => {\n+                            Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool)))\n+                        }\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n@@ -688,30 +709,42 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Int(IntTy::usize()))),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Uint(\n+                                UintTy::Usize,\n+                            )))),\n                         );\n                     }\n                 }\n \n                 Ty::apply_one(TypeCtor::Array, elem_ty)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n+                Literal::Bool(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n                 Literal::String(..) => {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n                 }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Int(IntTy::u8()));\n+                    let byte_type = Ty::simple(TypeCtor::Scalar(Scalar::Uint(UintTy::U8)));\n                     let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n-                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n+                Literal::Char(..) => Ty::simple(TypeCtor::Scalar(Scalar::Char)),\n                 Literal::Int(_v, ty) => match ty {\n-                    Some(int_ty) => Ty::simple(TypeCtor::Int((*int_ty).into())),\n+                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Int(\n+                        primitive::int_ty_from_builtin(*int_ty),\n+                    ))),\n+                    None => self.table.new_integer_var(),\n+                },\n+                Literal::Uint(_v, ty) => match ty {\n+                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Uint(\n+                        primitive::uint_ty_from_builtin(*int_ty),\n+                    ))),\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Float(_v, ty) => match ty {\n-                    Some(float_ty) => Ty::simple(TypeCtor::Float((*float_ty).into())),\n+                    Some(float_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Float(\n+                        primitive::float_ty_from_builtin(*float_ty),\n+                    ))),\n                     None => self.table.new_float_var(),\n                 },\n             },"}, {"sha": "57eb8cede7795e6ef18083703ff93d2717124d9d", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -8,8 +8,8 @@ use test_utils::mark;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Substs, Ty,\n-    TyKind, TypeCtor, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Scalar, Substs,\n+    Ty, TyKind, TypeCtor, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -300,10 +300,24 @@ impl InferenceTable {\n             | (other, Ty::Infer(InferTy::TypeVar(tv)))\n             | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n             | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n-            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n-            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))))\n+            | (other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))), Ty::Infer(InferTy::IntVar(tv)))\n+            | (\n+                Ty::Infer(InferTy::IntVar(tv)),\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n+            )\n+            | (\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n+                Ty::Infer(InferTy::IntVar(tv)),\n+            )\n+            | (\n+                Ty::Infer(InferTy::FloatVar(tv)),\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n+            )\n+            | (\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n+                Ty::Infer(InferTy::FloatVar(tv)),\n+            ) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true"}, {"sha": "676519594b43169557f4729abdbba46c12deaa58", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -38,7 +38,6 @@ use itertools::Itertools;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    primitive::{FloatTy, IntTy},\n     utils::{generics, make_mut_slice, Generics},\n };\n \n@@ -50,7 +49,7 @@ pub use lower::{\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n-pub use chalk_ir::{BoundVar, DebruijnIndex};\n+pub use chalk_ir::{BoundVar, DebruijnIndex, Scalar};\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Lifetime {\n@@ -63,18 +62,8 @@ pub enum Lifetime {\n /// tuples.\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum TypeCtor {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive integer type. For example, `i32`.\n-    Int(IntTy),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(FloatTy),\n+    /// a scalar type like `bool` or `u32`\n+    Scalar(Scalar),\n \n     /// Structures, enumerations and unions.\n     Adt(AdtId),\n@@ -152,10 +141,7 @@ pub enum TypeCtor {\n impl TypeCtor {\n     pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never => 0,\n             TypeCtor::Slice\n@@ -197,10 +183,7 @@ impl TypeCtor {\n \n     pub fn krate(self, db: &dyn HirDatabase) -> Option<CrateId> {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never\n             | TypeCtor::Slice\n@@ -232,10 +215,7 @@ impl TypeCtor {\n \n     pub fn as_generic_def(self) -> Option<GenericDefId> {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never\n             | TypeCtor::Slice\n@@ -741,11 +721,16 @@ impl Ty {\n     }\n     pub fn builtin(builtin: BuiltinType) -> Self {\n         Ty::simple(match builtin {\n-            BuiltinType::Char => TypeCtor::Char,\n-            BuiltinType::Bool => TypeCtor::Bool,\n+            BuiltinType::Char => TypeCtor::Scalar(Scalar::Char),\n+            BuiltinType::Bool => TypeCtor::Scalar(Scalar::Bool),\n             BuiltinType::Str => TypeCtor::Str,\n-            BuiltinType::Int(t) => TypeCtor::Int(IntTy::from(t).into()),\n-            BuiltinType::Float(t) => TypeCtor::Float(FloatTy::from(t).into()),\n+            BuiltinType::Int(t) => TypeCtor::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))),\n+            BuiltinType::Uint(t) => {\n+                TypeCtor::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t)))\n+            }\n+            BuiltinType::Float(t) => {\n+                TypeCtor::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t)))\n+            }\n         })\n     }\n "}, {"sha": "66d8de95917031d50ce5ca8809cabab872a9edc4", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 30, "deletions": 64, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -7,22 +7,19 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::CrateId;\n use hir_def::{\n-    builtin_type::{IntBitness, Signedness},\n-    lang_item::LangItemTarget,\n-    type_ref::Mutability,\n-    AssocContainerId, AssocItemId, FunctionId, GenericDefId, HasModule, ImplId, Lookup, ModuleId,\n-    TraitId,\n+    lang_item::LangItemTarget, type_ref::Mutability, AssocContainerId, AssocItemId, FunctionId,\n+    GenericDefId, HasModule, ImplId, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     autoderef,\n     db::HirDatabase,\n-    primitive::{FloatBitness, FloatTy, IntTy},\n+    primitive::{self, FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n-    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, Substs, TraitEnvironment, TraitRef, Ty,\n-    TyKind, TypeCtor, TypeWalk,\n+    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, Scalar, Substs, TraitEnvironment,\n+    TraitRef, Ty, TyKind, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -46,59 +43,23 @@ impl TyFingerprint {\n }\n \n pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X8,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X16,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X32,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X64,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X128,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::Xsize,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X8,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X16,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X32,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X64,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X128,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::Xsize,\n-    })),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I8))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I16))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I64))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I128))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::Isize))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U8))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U16))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U64))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U128))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::Usize))),\n ];\n \n pub(crate) const ALL_FLOAT_FPS: [TyFingerprint; 2] = [\n-    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 })),\n-    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 })),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n ];\n \n /// Trait impls defined or available in some crate.\n@@ -257,14 +218,19 @@ impl Ty {\n                 TypeCtor::ForeignType(type_alias_id) => {\n                     return mod_to_crate_ids(type_alias_id.lookup(db.upcast()).module(db.upcast()));\n                 }\n-                TypeCtor::Bool => lang_item_crate!(\"bool\"),\n-                TypeCtor::Char => lang_item_crate!(\"char\"),\n-                TypeCtor::Float(f) => match f.bitness {\n+                TypeCtor::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n+                TypeCtor::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n+                TypeCtor::Scalar(Scalar::Float(f)) => match f {\n                     // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                    FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                    FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+                    FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                    FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n                 },\n-                TypeCtor::Int(i) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Scalar(Scalar::Int(t)) => {\n+                    lang_item_crate!(primitive::int_ty_to_string(t))\n+                }\n+                TypeCtor::Scalar(Scalar::Uint(t)) => {\n+                    lang_item_crate!(primitive::uint_ty_to_string(t))\n+                }\n                 TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n                 TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n                 TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),"}, {"sha": "a4999c51d4d4de82d2e473793502550ac2efd3db", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -2,23 +2,27 @@\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n use super::{InferTy, Ty, TypeCtor};\n-use crate::ApplicationTy;\n+use crate::{ApplicationTy, Scalar};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n         BinaryOp::Assignment { .. } => Ty::unit(),\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(_) => match rhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => rhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => rhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n@@ -29,15 +33,11 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n         BinaryOp::Assignment { op: None } => lhs_ty,\n         BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..)\n-                | TypeCtor::Float(..)\n-                | TypeCtor::Str\n-                | TypeCtor::Char\n-                | TypeCtor::Bool => lhs_ty,\n+                TypeCtor::Scalar(_) | TypeCtor::Str => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n@@ -48,7 +48,9 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::Assignment { op: Some(_) }\n         | BinaryOp::ArithOp(_) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,"}, {"sha": "2449addfb75ef25834ce71e69c99b1fb7984bfee", "filename": "crates/hir_ty/src/primitive.rs", "status": "modified", "additions": 43, "deletions": 117, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -3,137 +3,63 @@\n //! * during type inference, they can be uncertain (ie, `let x = 92;`)\n //! * they don't belong to any particular crate.\n \n-use std::fmt;\n-\n-pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, FloatBitness, IntBitness, Signedness};\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct IntTy {\n-    pub signedness: Signedness,\n-    pub bitness: IntBitness,\n-}\n-\n-impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl IntTy {\n-    pub fn isize() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn i8() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn i16() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn i32() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn i64() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X64 }\n-    }\n-\n-    pub fn i128() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X128 }\n+pub use chalk_ir::{FloatTy, IntTy, UintTy};\n+pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint};\n+\n+pub fn int_ty_to_string(ty: IntTy) -> &'static str {\n+    match ty {\n+        IntTy::Isize => \"isize\",\n+        IntTy::I8 => \"i8\",\n+        IntTy::I16 => \"i16\",\n+        IntTy::I32 => \"i32\",\n+        IntTy::I64 => \"i64\",\n+        IntTy::I128 => \"i128\",\n     }\n-\n-    pub fn usize() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn u8() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn u16() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn u32() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn u64() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X64 }\n-    }\n-\n-    pub fn u128() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 }\n-    }\n-\n-    pub fn ty_to_string(self) -> &'static str {\n-        match (self.signedness, self.bitness) {\n-            (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n-            (Signedness::Signed, IntBitness::X8) => \"i8\",\n-            (Signedness::Signed, IntBitness::X16) => \"i16\",\n-            (Signedness::Signed, IntBitness::X32) => \"i32\",\n-            (Signedness::Signed, IntBitness::X64) => \"i64\",\n-            (Signedness::Signed, IntBitness::X128) => \"i128\",\n-            (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n-            (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n-            (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n-            (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n-            (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n-            (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct FloatTy {\n-    pub bitness: FloatBitness,\n }\n \n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n+pub fn uint_ty_to_string(ty: UintTy) -> &'static str {\n+    match ty {\n+        UintTy::Usize => \"usize\",\n+        UintTy::U8 => \"u8\",\n+        UintTy::U16 => \"u16\",\n+        UintTy::U32 => \"u32\",\n+        UintTy::U64 => \"u64\",\n+        UintTy::U128 => \"u128\",\n     }\n }\n \n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n+pub fn float_ty_to_string(ty: FloatTy) -> &'static str {\n+    match ty {\n+        FloatTy::F32 => \"f32\",\n+        FloatTy::F64 => \"f64\",\n     }\n }\n \n-impl FloatTy {\n-    pub fn f32() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X32 }\n-    }\n-\n-    pub fn f64() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X64 }\n-    }\n-\n-    pub fn ty_to_string(self) -> &'static str {\n-        match self.bitness {\n-            FloatBitness::X32 => \"f32\",\n-            FloatBitness::X64 => \"f64\",\n-        }\n+pub(super) fn int_ty_from_builtin(t: BuiltinInt) -> IntTy {\n+    match t {\n+        BuiltinInt::Isize => IntTy::Isize,\n+        BuiltinInt::I8 => IntTy::I8,\n+        BuiltinInt::I16 => IntTy::I16,\n+        BuiltinInt::I32 => IntTy::I32,\n+        BuiltinInt::I64 => IntTy::I64,\n+        BuiltinInt::I128 => IntTy::I128,\n     }\n }\n \n-impl From<BuiltinInt> for IntTy {\n-    fn from(t: BuiltinInt) -> Self {\n-        IntTy { signedness: t.signedness, bitness: t.bitness }\n+pub(super) fn uint_ty_from_builtin(t: BuiltinUint) -> UintTy {\n+    match t {\n+        BuiltinUint::Usize => UintTy::Usize,\n+        BuiltinUint::U8 => UintTy::U8,\n+        BuiltinUint::U16 => UintTy::U16,\n+        BuiltinUint::U32 => UintTy::U32,\n+        BuiltinUint::U64 => UintTy::U64,\n+        BuiltinUint::U128 => UintTy::U128,\n     }\n }\n \n-impl From<BuiltinFloat> for FloatTy {\n-    fn from(t: BuiltinFloat) -> Self {\n-        FloatTy { bitness: t.bitness }\n+pub(super) fn float_ty_from_builtin(t: BuiltinFloat) -> FloatTy {\n+    match t {\n+        BuiltinFloat::F32 => FloatTy::F32,\n+        BuiltinFloat::F64 => FloatTy::F64,\n     }\n }"}, {"sha": "5a3cb7906003d3ff2948708ad4e03bc878878c85", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 7, "deletions": 83, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803ff2e55eeb6bd1d9028fbbffe34721f0e6d459/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=803ff2e55eeb6bd1d9028fbbffe34721f0e6d459", "patch": "@@ -4,7 +4,7 @@\n //! conversions.\n \n use chalk_ir::{\n-    cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeData, PlaceholderIndex, Scalar,\n+    cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeData, PlaceholderIndex,\n     UniverseIndex,\n };\n use chalk_solve::rust_ir;\n@@ -14,10 +14,11 @@ use hir_def::{type_ref::Mutability, AssocContainerId, GenericDefId, Lookup, Type\n \n use crate::{\n     db::HirDatabase,\n-    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n+    primitive::UintTy,\n     traits::{Canonical, Obligation},\n     ApplicationTy, CallableDefId, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n+    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind,\n+    TypeCtor,\n };\n \n use super::interner::*;\n@@ -63,19 +64,7 @@ impl ToChalk for Ty {\n                     chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n                 }\n \n-                TypeCtor::Bool => chalk_ir::TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-                TypeCtor::Char => chalk_ir::TyKind::Scalar(Scalar::Char).intern(&Interner),\n-                TypeCtor::Int(int_ty) => {\n-                    chalk_ir::TyKind::Scalar(int_ty_to_chalk(int_ty)).intern(&Interner)\n-                }\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }) => {\n-                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n-                        .intern(&Interner)\n-                }\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }) => {\n-                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n-                        .intern(&Interner)\n-                }\n+                TypeCtor::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n \n                 TypeCtor::Tuple { cardinality } => {\n                     let substitution = apply_ty.parameters.to_chalk(db);\n@@ -219,22 +208,7 @@ impl ToChalk for Ty {\n                 apply_ty_from_chalk(db, TypeCtor::OpaqueType(from_chalk(db, opaque_type_id)), subst)\n             }\n \n-            chalk_ir::TyKind::Scalar(Scalar::Bool) => Ty::simple(TypeCtor::Bool),\n-            chalk_ir::TyKind::Scalar(Scalar::Char) => Ty::simple(TypeCtor::Char),\n-            chalk_ir::TyKind::Scalar(Scalar::Int(int_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n-                signedness: Signedness::Signed,\n-                bitness: bitness_from_chalk_int(int_ty),\n-            })),\n-            chalk_ir::TyKind::Scalar(Scalar::Uint(uint_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n-                signedness: Signedness::Unsigned,\n-                bitness: bitness_from_chalk_uint(uint_ty),\n-            })),\n-            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n-                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }))\n-            }\n-            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n-                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }))\n-            }\n+            chalk_ir::TyKind::Scalar(scalar) => Ty::simple(TypeCtor::Scalar(scalar)),\n             chalk_ir::TyKind::Tuple(cardinality, subst) => {\n                 apply_ty_from_chalk(db, TypeCtor::Tuple { cardinality: cardinality as u16 }, subst)\n             }\n@@ -292,8 +266,7 @@ fn ref_to_chalk(\n /// fake constant here, because Chalks built-in logic may expect it to be there.\n fn array_to_chalk(db: &dyn HirDatabase, subst: Substs) -> chalk_ir::Ty<Interner> {\n     let arg = subst[0].clone().to_chalk(db);\n-    let usize_ty =\n-        chalk_ir::TyKind::Scalar(Scalar::Uint(chalk_ir::UintTy::Usize)).intern(&Interner);\n+    let usize_ty = chalk_ir::TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner);\n     let const_ = chalk_ir::ConstData {\n         ty: usize_ty,\n         value: chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: () }),\n@@ -364,55 +337,6 @@ impl ToChalk for OpaqueTyId {\n     }\n }\n \n-fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n-    use chalk_ir::UintTy;\n-\n-    match uint_ty {\n-        UintTy::Usize => IntBitness::Xsize,\n-        UintTy::U8 => IntBitness::X8,\n-        UintTy::U16 => IntBitness::X16,\n-        UintTy::U32 => IntBitness::X32,\n-        UintTy::U64 => IntBitness::X64,\n-        UintTy::U128 => IntBitness::X128,\n-    }\n-}\n-\n-fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n-    use chalk_ir::IntTy;\n-\n-    match int_ty {\n-        IntTy::Isize => IntBitness::Xsize,\n-        IntTy::I8 => IntBitness::X8,\n-        IntTy::I16 => IntBitness::X16,\n-        IntTy::I32 => IntBitness::X32,\n-        IntTy::I64 => IntBitness::X64,\n-        IntTy::I128 => IntBitness::X128,\n-    }\n-}\n-\n-fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n-    use chalk_ir::{IntTy, UintTy};\n-\n-    match int_ty.signedness {\n-        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n-            IntBitness::Xsize => IntTy::Isize,\n-            IntBitness::X8 => IntTy::I8,\n-            IntBitness::X16 => IntTy::I16,\n-            IntBitness::X32 => IntTy::I32,\n-            IntBitness::X64 => IntTy::I64,\n-            IntBitness::X128 => IntTy::I128,\n-        }),\n-        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n-            IntBitness::Xsize => UintTy::Usize,\n-            IntBitness::X8 => UintTy::U8,\n-            IntBitness::X16 => UintTy::U16,\n-            IntBitness::X32 => UintTy::U32,\n-            IntBitness::X64 => UintTy::U64,\n-            IntBitness::X128 => UintTy::U128,\n-        }),\n-    }\n-}\n-\n impl ToChalk for Mutability {\n     type Chalk = chalk_ir::Mutability;\n     fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {"}]}