{"sha": "a10917a6a9b087d10ac4fd0186b719218627281e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMDkxN2E2YTliMDg3ZDEwYWM0ZmQwMTg2YjcxOTIxODYyNzI4MWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-24T17:32:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-24T17:32:04Z"}, "message": "auto merge of #16388 : Zoxc/rust/stmesg, r=alexcrichton\n\nThis installs signal handlers to print out stack overflow messages on Linux. It also ensures the main thread has a guard page.\r\n\r\nThis will catch stack overflows in external code. It's done in preparation of switching to stack probes (#16012).\r\n\r\nI've done some simple tests with overflowing the main thread, native threads and green threads (with and without UV) on x86-64.\r\nThis might work on ARM, MIPS and x86-32.\r\n\r\nI've been unable to run the test suite on this because of #16305.", "tree": {"sha": "c4baa90b9916b1b1ab179fa97b832632ac06d2fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4baa90b9916b1b1ab179fa97b832632ac06d2fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a10917a6a9b087d10ac4fd0186b719218627281e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a10917a6a9b087d10ac4fd0186b719218627281e", "html_url": "https://github.com/rust-lang/rust/commit/a10917a6a9b087d10ac4fd0186b719218627281e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a10917a6a9b087d10ac4fd0186b719218627281e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "083578ddec6fa07a757959efe64b02de38e73ce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/083578ddec6fa07a757959efe64b02de38e73ce6", "html_url": "https://github.com/rust-lang/rust/commit/083578ddec6fa07a757959efe64b02de38e73ce6"}, {"sha": "70cef9474a3307ec763efc01fe6969e542083823", "url": "https://api.github.com/repos/rust-lang/rust/commits/70cef9474a3307ec763efc01fe6969e542083823", "html_url": "https://github.com/rust-lang/rust/commit/70cef9474a3307ec763efc01fe6969e542083823"}], "stats": {"total": 817, "additions": 774, "deletions": 43}, "files": [{"sha": "686a039d6d600758d9b348b95b1bac12e6d74892", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -81,6 +81,7 @@ impl Runtime for SimpleTask {\n     }\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n+    fn stack_guard(&self) -> Option<uint> { fail!() }\n     fn can_block(&self) -> bool { true }\n     fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { fail!() }\n }"}, {"sha": "cccf0ec698779af0e0962f5b395e9464e36a7d5f", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -82,6 +82,11 @@ impl Stack {\n         }\n     }\n \n+    /// Point to the last writable byte of the stack\n+    pub fn guard(&self) -> *const uint {\n+        (self.start() as uint + page_size()) as *const uint\n+    }\n+\n     /// Point to the low end of the allocated stack\n     pub fn start(&self) -> *const uint {\n         self.buf.as_ref().map(|m| m.data() as *const uint)"}, {"sha": "f151e00f56d567c1c2febab9f4929d31a988ed58", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -486,6 +486,13 @@ impl Runtime for GreenTask {\n          c.current_stack_segment.end() as uint)\n     }\n \n+    fn stack_guard(&self) -> Option<uint> {\n+        let c = self.coroutine.as_ref()\n+            .expect(\"GreenTask.stack_guard called without a coroutine\");\n+\n+        Some(c.current_stack_segment.guard() as uint)\n+    }\n+\n     fn can_block(&self) -> bool { false }\n \n     fn wrap(self: Box<GreenTask>) -> Box<Any+'static> {"}, {"sha": "f1757d367c3559c7c45e0aff1be85b5b23b29030", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -252,16 +252,6 @@ mod signal {\n         pub status: libc::c_int,\n     }\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        sa_tramp: *mut libc::c_void,\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_int,\n-    }\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n     #[repr(C)]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),"}, {"sha": "c99143f0a5d7b05d844f011ea5510c35dafb26a8", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -132,7 +132,8 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);\n-    let mut task = task::new((my_stack_bottom, my_stack_top));\n+    let mut task = task::new((my_stack_bottom, my_stack_top),\n+                             rt::thread::main_guard_page());\n     task.name = Some(str::Slice(\"<main>\"));\n     drop(task.run(|| {\n         unsafe {"}, {"sha": "455656c09d493279a45975b40c99c53e6771f094", "filename": "src/libnative/task.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -29,10 +29,11 @@ use io;\n use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n-pub fn new(stack_bounds: (uint, uint)) -> Box<Task> {\n+pub fn new(stack_bounds: (uint, uint), stack_guard: uint) -> Box<Task> {\n     let mut task = box Task::new();\n     let mut ops = ops();\n     ops.stack_bounds = stack_bounds;\n+    ops.stack_guard = stack_guard;\n     task.put_runtime(ops);\n     return task;\n }\n@@ -44,6 +45,7 @@ fn ops() -> Box<Ops> {\n         io: io::IoFactory::new(),\n         // these *should* get overwritten\n         stack_bounds: (0, 0),\n+        stack_guard: 0\n     }\n }\n \n@@ -82,6 +84,7 @@ impl Spawner for NativeSpawner {\n                                                       my_stack);\n             }\n             let mut ops = ops;\n+            ops.stack_guard = rt::thread::current_guard_page();\n             ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n \n             let mut f = Some(f);\n@@ -115,6 +118,8 @@ struct Ops {\n     // native tasks necessarily know their precise bounds, hence this is\n     // optional.\n     stack_bounds: (uint, uint),\n+\n+    stack_guard: uint\n }\n \n impl rt::Runtime for Ops {\n@@ -138,6 +143,14 @@ impl rt::Runtime for Ops {\n \n     fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }\n \n+    fn stack_guard(&self) -> Option<uint> {\n+        if self.stack_guard != 0 {\n+            Some(self.stack_guard)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn can_block(&self) -> bool { true }\n \n     // This function gets a little interesting. There are a few safety and"}, {"sha": "972497f98188309f3aa0ec481e9c053f683966ff", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -51,6 +51,7 @@ mod local_ptr;\n mod thread_local_storage;\n mod util;\n mod libunwind;\n+mod stack_overflow;\n \n pub mod args;\n pub mod bookkeeping;\n@@ -92,6 +93,8 @@ pub trait Runtime {\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n+    /// The last writable byte of the stack next to the guard page\n+    fn stack_guard(&self) -> Option<uint>;\n     fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n@@ -113,6 +116,7 @@ pub fn init(argc: int, argv: *const *const u8) {\n         args::init(argc, argv);\n         local_ptr::init();\n         at_exit_imp::init();\n+        thread::init();\n     }\n \n     // FIXME(#14344) this shouldn't be necessary\n@@ -151,6 +155,7 @@ pub unsafe fn cleanup() {\n     bookkeeping::wait_for_other_tasks();\n     at_exit_imp::run();\n     args::cleanup();\n+    thread::cleanup();\n     local_ptr::cleanup();\n }\n "}, {"sha": "4874f642a93afac63e627a4e09b5a7e89ab322b7", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -55,10 +55,6 @@ pub const RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n-    use core::prelude::*;\n-    use alloc::boxed::Box;\n-    use local::Local;\n-    use task::Task;\n     use core::intrinsics;\n \n     unsafe {\n@@ -104,21 +100,7 @@ extern fn stack_exhausted() {\n         //  #9854 - unwinding on windows through __morestack has never worked\n         //  #2361 - possible implementation of not using landing pads\n \n-        let task: Option<Box<Task>> = Local::try_take();\n-        let name = match task {\n-            Some(ref task) => {\n-                task.name.as_ref().map(|n| n.as_slice())\n-            }\n-            None => None\n-        };\n-        let name = name.unwrap_or(\"<unknown>\");\n-\n-        // See the message below for why this is not emitted to the\n-        // task's logger. This has the additional conundrum of the\n-        // logger may not be initialized just yet, meaning that an FFI\n-        // call would happen to initialized it (calling out to libuv),\n-        // and the FFI call needs 2MB of stack when we just ran out.\n-        rterrln!(\"task '{}' has overflowed its stack\", name);\n+        ::stack_overflow::report();\n \n         intrinsics::abort();\n     }"}, {"sha": "aaaeb8846ccafd3a699bbb25aa401e726d6d57c6", "filename": "src/librustrt/stack_overflow.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack_overflow.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+\n+use core::prelude::*;\n+use libc;\n+use local::Local;\n+use task::Task;\n+\n+pub unsafe fn init() {\n+    imp::init();\n+}\n+\n+pub unsafe fn cleanup() {\n+    imp::cleanup();\n+}\n+\n+pub struct Handler {\n+    _data: *mut libc::c_void\n+}\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        imp::make_handler()\n+    }\n+}\n+\n+impl Drop for Handler {\n+    fn drop(&mut self) {\n+        unsafe {\n+            imp::drop_handler(self);\n+        }\n+    }\n+}\n+\n+pub unsafe fn report() {\n+    // See the message below for why this is not emitted to the\n+    // ^ Where did the message below go?\n+    // task's logger. This has the additional conundrum of the\n+    // logger may not be initialized just yet, meaning that an FFI\n+    // call would happen to initialized it (calling out to libuv),\n+    // and the FFI call needs 2MB of stack when we just ran out.\n+\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+\n+    let name = task.and_then(|task| {\n+        (*task).name.as_ref().map(|n| n.as_slice())\n+    });\n+\n+    rterrln!(\"\\ntask '{}' has overflowed its stack\", name.unwrap_or(\"<unknown>\"));\n+}\n+\n+// get_task_info is called from an exception / signal handler.\n+// It returns the guard page of the current task or 0 if that\n+// guard page doesn't exist. None is returned if there's currently\n+// no local task.\n+#[cfg(any(windows, target_os = \"linux\", target_os = \"macos\"))]\n+unsafe fn get_task_guard_page() -> Option<uint> {\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+\n+    task.map(|task| {\n+        let runtime = (*task).take_runtime();\n+        let guard = runtime.stack_guard();\n+        (*task).put_runtime(runtime);\n+\n+        guard.unwrap_or(0)\n+    })\n+}\n+\n+#[cfg(windows)]\n+#[allow(non_snake_case)]\n+mod imp {\n+    use core::ptr;\n+    use core::mem;\n+    use libc;\n+    use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n+    use stack;\n+    use super::{Handler, get_task_guard_page, report};\n+\n+    // This is initialized in init() and only read from after\n+    static mut PAGE_SIZE: uint = 0;\n+\n+    #[no_stack_check]\n+    extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n+        unsafe {\n+            let rec = &(*(*ExceptionInfo).ExceptionRecord);\n+            let code = rec.ExceptionCode;\n+\n+            if code != EXCEPTION_STACK_OVERFLOW {\n+                return EXCEPTION_CONTINUE_SEARCH;\n+            }\n+\n+            // We're calling into functions with stack checks,\n+            // however stack checks by limit should be disabled on Windows\n+            stack::record_sp_limit(0);\n+\n+            if get_task_guard_page().is_some() {\n+               report();\n+            }\n+\n+            EXCEPTION_CONTINUE_SEARCH\n+        }\n+    }\n+\n+    pub unsafe fn init() {\n+        let mut info = mem::zeroed();\n+        libc::GetSystemInfo(&mut info);\n+        PAGE_SIZE = info.dwPageSize as uint;\n+\n+        if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n+            fail!(\"failed to install exception handler\");\n+        }\n+\n+        mem::forget(make_handler());\n+    }\n+\n+    pub unsafe fn cleanup() {\n+    }\n+\n+    pub unsafe fn make_handler() -> Handler {\n+        if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+            fail!(\"failed to reserve stack space for exception handling\");\n+        }\n+\n+        super::Handler { _data: 0i as *mut libc::c_void }\n+    }\n+\n+    pub unsafe fn drop_handler(_handler: &mut Handler) {\n+    }\n+\n+    pub struct EXCEPTION_RECORD {\n+        pub ExceptionCode: DWORD,\n+        pub ExceptionFlags: DWORD,\n+        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+        pub ExceptionAddress: LPVOID,\n+        pub NumberParameters: DWORD,\n+        pub ExceptionInformation: [LPVOID, ..EXCEPTION_MAXIMUM_PARAMETERS]\n+    }\n+\n+    pub struct EXCEPTION_POINTERS {\n+        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+        pub ContextRecord: LPVOID\n+    }\n+\n+    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n+            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+\n+    pub type ULONG = libc::c_ulong;\n+\n+    const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n+    const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n+    const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n+\n+    extern \"system\" {\n+        fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n+                                       VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n+                                      -> LPVOID;\n+        fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+mod imp {\n+    use core::prelude::*;\n+    use stack;\n+\n+    use super::{Handler, get_task_guard_page, report};\n+    use core::mem;\n+    use core::ptr;\n+    use core::intrinsics;\n+    use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n+                       SA_SIGINFO, SA_ONSTACK, sigaltstack,\n+                       SIGSTKSZ};\n+    use libc;\n+    use libc::funcs::posix88::mman::{mmap, munmap};\n+    use libc::consts::os::posix88::{SIGSEGV,\n+                                    PROT_READ,\n+                                    PROT_WRITE,\n+                                    MAP_PRIVATE,\n+                                    MAP_ANON,\n+                                    MAP_FAILED};\n+\n+\n+    // This is initialized in init() and only read from after\n+    static mut PAGE_SIZE: uint = 0;\n+\n+    #[no_stack_check]\n+    unsafe extern fn signal_handler(signum: libc::c_int,\n+                                     info: *mut siginfo,\n+                                     _data: *mut libc::c_void) {\n+\n+        // We can not return from a SIGSEGV or SIGBUS signal.\n+        // See: https://www.gnu.org/software/libc/manual/html_node/Handler-Returns.html\n+\n+        unsafe fn term(signum: libc::c_int) -> ! {\n+            use core::mem::transmute;\n+\n+            signal(signum, transmute(SIG_DFL));\n+            raise(signum);\n+            intrinsics::abort();\n+        }\n+\n+        // We're calling into functions with stack checks\n+        stack::record_sp_limit(0);\n+\n+        match get_task_guard_page() {\n+            Some(guard) => {\n+                let addr = (*info).si_addr as uint;\n+\n+                if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n+                    term(signum);\n+                }\n+\n+                report();\n+\n+                intrinsics::abort()\n+            }\n+            None => term(signum)\n+        }\n+    }\n+\n+    static mut MAIN_ALTSTACK: *mut libc::c_void = 0 as *mut libc::c_void;\n+\n+    pub unsafe fn init() {\n+        let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n+        if psize == -1 {\n+            fail!(\"failed to get page size\");\n+        }\n+\n+        PAGE_SIZE = psize as uint;\n+\n+        let mut action: sigaction = mem::zeroed();\n+        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+        action.sa_sigaction = signal_handler as sighandler_t;\n+        sigaction(SIGSEGV, &action, ptr::null_mut());\n+        sigaction(SIGBUS, &action, ptr::null_mut());\n+\n+        let handler = make_handler();\n+        MAIN_ALTSTACK = handler._data;\n+        mem::forget(handler);\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        Handler { _data: MAIN_ALTSTACK };\n+    }\n+\n+    pub unsafe fn make_handler() -> Handler {\n+        let alt_stack = mmap(ptr::null_mut(),\n+                             signal::SIGSTKSZ,\n+                             PROT_READ | PROT_WRITE,\n+                             MAP_PRIVATE | MAP_ANON,\n+                             -1,\n+                             0);\n+        if alt_stack == MAP_FAILED {\n+            fail!(\"failed to allocate an alternative stack\");\n+        }\n+\n+        let mut stack: sigaltstack = mem::zeroed();\n+\n+        stack.ss_sp = alt_stack;\n+        stack.ss_flags = 0;\n+        stack.ss_size = SIGSTKSZ;\n+\n+        sigaltstack(&stack, ptr::null_mut());\n+\n+        Handler { _data: alt_stack }\n+    }\n+\n+    pub unsafe fn drop_handler(handler: &mut Handler) {\n+        munmap(handler._data, SIGSTKSZ);\n+    }\n+\n+    type sighandler_t = *mut libc::c_void;\n+\n+    #[cfg(any(all(target_os = \"linux\", target_arch = \"x86\"), // may not match\n+              all(target_os = \"linux\", target_arch = \"x86_64\"),\n+              all(target_os = \"linux\", target_arch = \"arm\"), // may not match\n+              target_os = \"android\"))] // may not match\n+    mod signal {\n+        use libc;\n+        use super::sighandler_t;\n+\n+        pub static SA_ONSTACK: libc::c_int = 0x08000000;\n+        pub static SA_SIGINFO: libc::c_int = 0x00000004;\n+        pub static SIGBUS: libc::c_int = 7;\n+\n+        pub static SIGSTKSZ: libc::size_t = 8192;\n+\n+        pub static SIG_DFL: sighandler_t = 0i as sighandler_t;\n+\n+        // This definition is not as accurate as it could be, {si_addr} is\n+        // actually a giant union. Currently we're only interested in that field,\n+        // however.\n+        #[repr(C)]\n+        pub struct siginfo {\n+            si_signo: libc::c_int,\n+            si_errno: libc::c_int,\n+            si_code: libc::c_int,\n+            pub si_addr: *mut libc::c_void\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_int,\n+            sa_restorer: *mut libc::c_void,\n+        }\n+\n+        #[cfg(target_word_size = \"32\")]\n+        #[repr(C)]\n+        pub struct sigset_t {\n+            __val: [libc::c_ulong, ..32],\n+        }\n+        #[cfg(target_word_size = \"64\")]\n+        #[repr(C)]\n+        pub struct sigset_t {\n+            __val: [libc::c_ulong, ..16],\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_flags: libc::c_int,\n+            pub ss_size: libc::size_t\n+        }\n+\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    mod signal {\n+        use libc;\n+        use super::sighandler_t;\n+\n+        pub const SA_ONSTACK: libc::c_int = 0x0001;\n+        pub const SA_SIGINFO: libc::c_int = 0x0040;\n+        pub const SIGBUS: libc::c_int = 10;\n+\n+        pub const SIGSTKSZ: libc::size_t = 131072;\n+\n+        pub const SIG_DFL: sighandler_t = 0i as sighandler_t;\n+\n+        pub type sigset_t = u32;\n+\n+        // This structure has more fields, but we're not all that interested in\n+        // them.\n+        #[repr(C)]\n+        pub struct siginfo {\n+            pub si_signo: libc::c_int,\n+            pub si_errno: libc::c_int,\n+            pub si_code: libc::c_int,\n+            pub pid: libc::pid_t,\n+            pub uid: libc::uid_t,\n+            pub status: libc::c_int,\n+            pub si_addr: *mut libc::c_void\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_size: libc::size_t,\n+            pub ss_flags: libc::c_int\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_int,\n+        }\n+    }\n+\n+    extern {\n+        pub fn signal(signum: libc::c_int, handler: sighandler_t) -> sighandler_t;\n+        pub fn raise(signum: libc::c_int) -> libc::c_int;\n+\n+        pub fn sigaction(signum: libc::c_int,\n+                         act: *const sigaction,\n+                         oldact: *mut sigaction) -> libc::c_int;\n+\n+        pub fn sigaltstack(ss: *const sigaltstack,\n+                           oss: *mut sigaltstack) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"macos\",\n+              windows)))]\n+mod imp {\n+    use libc;\n+\n+    pub unsafe fn init() {\n+    }\n+\n+    pub unsafe fn cleanup() {\n+    }\n+\n+    pub unsafe fn make_handler() -> super::Handler {\n+        super::Handler { _data: 0i as *mut libc::c_void }\n+    }\n+\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n+    }\n+}"}, {"sha": "5eb28412abdab2dccf6d85c90f775f05426dec8f", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -72,7 +72,7 @@ use collections::str::SendStr;\n /// # fn main() {\n ///\n /// // Create a task using a native runtime\n-/// let task = native::task::new((0, uint::MAX));\n+/// let task = native::task::new((0, uint::MAX), 0);\n ///\n /// // Run some code, catching any possible failures\n /// let task = task.run(|| {\n@@ -197,7 +197,7 @@ impl Task {\n     /// # fn main() {\n     ///\n     /// // Create a new native task\n-    /// let task = native::task::new((0, uint::MAX));\n+    /// let task = native::task::new((0, uint::MAX), 0);\n     ///\n     /// // Run some code once and then destroy this task\n     /// task.run(|| {"}, {"sha": "50b570091ada146246270bb266165966bb440db5", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 203, "deletions": 2, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -24,7 +24,21 @@ use core::uint;\n use libc;\n \n use stack;\n+use stack_overflow;\n \n+pub unsafe fn init() {\n+    imp::guard::init();\n+    stack_overflow::init();\n+}\n+\n+pub unsafe fn cleanup() {\n+    stack_overflow::cleanup();\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+type StartFn = extern \"system\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n+\n+#[cfg(not(target_os = \"windows\"))]\n type StartFn = extern \"C\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n \n /// This struct represents a native thread's state. This is used to join on an\n@@ -42,15 +56,45 @@ static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n // no_stack_check annotation), and then we extract the main function\n // and invoke it.\n #[no_stack_check]\n-extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n+fn start_thread(main: *mut libc::c_void) -> imp::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, uint::MAX);\n+        let handler = stack_overflow::Handler::new();\n         let f: Box<proc()> = mem::transmute(main);\n         (*f)();\n+        drop(handler);\n         mem::transmute(0 as imp::rust_thread_return)\n     }\n }\n \n+#[no_stack_check]\n+#[cfg(target_os = \"windows\")]\n+extern \"system\" fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+#[no_stack_check]\n+#[cfg(not(target_os = \"windows\"))]\n+extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+/// Returns the last writable byte of the main thread's stack next to the guard\n+/// page. Must be called from the main thread.\n+pub fn main_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::main()\n+    }\n+}\n+\n+/// Returns the last writable byte of the current thread's stack next to the\n+/// guard page. Must not be called from the main thread.\n+pub fn current_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::current()\n+    }\n+}\n+\n // There are two impl blocks b/c if T were specified at the top then it's just a\n // pain to specify a type parameter on Thread::spawn (which doesn't need the\n // type parameter).\n@@ -144,6 +188,7 @@ impl<T: Send> Drop for Thread<T> {\n }\n \n #[cfg(windows)]\n+#[allow(non_snake_case)]\n mod imp {\n     use core::prelude::*;\n \n@@ -159,6 +204,19 @@ mod imp {\n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n \n+    pub mod guard {\n+        pub unsafe fn main() -> uint {\n+            0\n+        }\n+\n+        pub unsafe fn current() -> uint {\n+            0\n+        }\n+\n+        pub unsafe fn init() {\n+        }\n+    }\n+\n     pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         let arg: *mut libc::c_void = mem::transmute(p);\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n@@ -227,6 +285,130 @@ mod imp {\n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *mut u8;\n \n+    #[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n+    pub mod guard {\n+        pub unsafe fn current() -> uint {\n+            0\n+        }\n+\n+        pub unsafe fn main() -> uint {\n+            0\n+        }\n+\n+        pub unsafe fn init() {\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+    pub mod guard {\n+        use super::*;\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        use core::mem;\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        use core::ptr;\n+        use libc;\n+        use libc::funcs::posix88::mman::{mmap};\n+        use libc::consts::os::posix88::{PROT_NONE,\n+                                        MAP_PRIVATE,\n+                                        MAP_ANON,\n+                                        MAP_FAILED,\n+                                        MAP_FIXED};\n+\n+        // These are initialized in init() and only read from after\n+        static mut PAGE_SIZE: uint = 0;\n+        static mut GUARD_PAGE: uint = 0;\n+\n+        #[cfg(target_os = \"macos\")]\n+        unsafe fn get_stack_start() -> *mut libc::c_void {\n+            current() as *mut libc::c_void\n+        }\n+\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        unsafe fn get_stack_start() -> *mut libc::c_void {\n+            let mut attr: libc::pthread_attr_t = mem::zeroed();\n+            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+                fail!(\"failed to get thread attributes\");\n+            }\n+            let mut stackaddr = ptr::null_mut();\n+            let mut stacksize = 0;\n+            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+                fail!(\"failed to get stack information\");\n+            }\n+            if pthread_attr_destroy(&mut attr) != 0 {\n+                fail!(\"failed to destroy thread attributes\");\n+            }\n+            stackaddr\n+        }\n+\n+        pub unsafe fn init() {\n+            let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n+            if psize == -1 {\n+                fail!(\"failed to get page size\");\n+            }\n+\n+            PAGE_SIZE = psize as uint;\n+\n+            let stackaddr = get_stack_start();\n+\n+            // Rellocate the last page of the stack.\n+            // This ensures SIGBUS will be raised on\n+            // stack overflow.\n+            let result = mmap(stackaddr,\n+                              PAGE_SIZE as libc::size_t,\n+                              PROT_NONE,\n+                              MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                              -1,\n+                              0);\n+\n+            if result != stackaddr || result == MAP_FAILED {\n+                fail!(\"failed to allocate a guard page\");\n+            }\n+\n+            let offset = if cfg!(target_os = \"linux\") {\n+                2\n+            } else {\n+                1\n+            };\n+\n+            GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n+        }\n+\n+        pub unsafe fn main() -> uint {\n+            GUARD_PAGE\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        pub unsafe fn current() -> uint {\n+            (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n+             pthread_get_stacksize_np(pthread_self())) as uint\n+        }\n+\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        pub unsafe fn current() -> uint {\n+            let mut attr: libc::pthread_attr_t = mem::zeroed();\n+            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+                fail!(\"failed to get thread attributes\");\n+            }\n+            let mut guardsize = 0;\n+            if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n+                fail!(\"failed to get stack guard page\");\n+            }\n+            if guardsize == 0 {\n+                fail!(\"there is no guard page\");\n+            }\n+            let mut stackaddr = ptr::null_mut();\n+            let mut stacksize = 0;\n+            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+                fail!(\"failed to get stack information\");\n+            }\n+            if pthread_attr_destroy(&mut attr) != 0 {\n+                fail!(\"failed to destroy thread attributes\");\n+            }\n+\n+            stackaddr as uint + guardsize as uint\n+        }\n+    }\n+\n     pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n@@ -307,6 +489,25 @@ mod imp {\n         PTHREAD_STACK_MIN\n     }\n \n+    #[cfg(any(target_os = \"linux\"))]\n+    extern {\n+        pub fn pthread_self() -> libc::pthread_t;\n+        pub fn pthread_getattr_np(native: libc::pthread_t,\n+                                  attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+        pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n+                                         guardsize: *mut libc::size_t) -> libc::c_int;\n+        pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n+                                     stackaddr: *mut *mut libc::c_void,\n+                                     stacksize: *mut libc::size_t) -> libc::c_int;\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    extern {\n+        pub fn pthread_self() -> libc::pthread_t;\n+        pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n+        pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n+    }\n+\n     extern {\n         fn pthread_create(native: *mut libc::pthread_t,\n                           attr: *const libc::pthread_attr_t,\n@@ -315,7 +516,7 @@ mod imp {\n         fn pthread_join(native: libc::pthread_t,\n                         value: *mut *mut libc::c_void) -> libc::c_int;\n         fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+        pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n         fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                      stack_size: libc::size_t) -> libc::c_int;\n         fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,"}, {"sha": "e4a4216132214271f5698556e85c519e9e54a189", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//ignore-android\n+//ignore-freebsd\n+//ignore-ios\n+//ignore-dragonfly\n+\n+#![feature(asm)]\n+\n+use std::io::process::Command;\n+use std::os;\n+\n+// lifted from the test module\n+// Inlining to avoid llvm turning the recursive functions into tail calls,\n+// which doesn't consume stack.\n+#[inline(always)]\n+#[no_stack_check]\n+pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n+\n+#[no_stack_check]\n+fn recurse() {\n+    let buf = [0i, ..10];\n+    black_box(buf);\n+    recurse();\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let args = args.as_slice();\n+    if args.len() > 1 && args[1].as_slice() == \"recurse\" {\n+        spawn(proc() {\n+            recurse();\n+        });\n+    } else {\n+        let recurse = Command::new(args[0].as_slice()).arg(\"recurse\").output().unwrap();\n+        assert!(!recurse.status.success());\n+        let error = String::from_utf8_lossy(recurse.error.as_slice());\n+        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+    }\n+}"}, {"sha": "ecb93cc6f8c7ef152e11c3a8499bcc4b244df77e", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//ignore-android\n+//ignore-linux\n+//ignore-freebsd\n+//ignore-ios\n+//ignore-dragonfly\n+\n+#![feature(asm)]\n+\n+use std::io::process::Command;\n+use std::os;\n+\n+// lifted from the test module\n+// Inlining to avoid llvm turning the recursive functions into tail calls,\n+// which doesn't consume stack.\n+#[inline(always)]\n+#[no_stack_check]\n+pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n+\n+#[no_stack_check]\n+fn recurse() {\n+    let buf = [0i, ..10];\n+    black_box(buf);\n+    recurse();\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let args = args.as_slice();\n+    if args.len() > 1 && args[1].as_slice() == \"recurse\" {\n+        recurse();\n+    } else {\n+        let recurse = Command::new(args[0].as_slice()).arg(\"recurse\").output().unwrap();\n+        assert!(!recurse.status.success());\n+        let error = String::from_utf8_lossy(recurse.error.as_slice());\n+        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+    }\n+}"}, {"sha": "7f2f9f9ece83de1ffc9398d49b99b99db0be3ea2", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -42,17 +42,11 @@ fn main() {\n         let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n-        if !cfg!(windows) {\n-            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n-        }\n+        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n         let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n-        if !cfg!(windows) {\n-            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n-        }\n+        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "6ef33c1a11211df21278ba672dbb03daf32111cd", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10917a6a9b087d10ac4fd0186b719218627281e/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=a10917a6a9b087d10ac4fd0186b719218627281e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::process::Command;\n+use std::os;\n+\n+fn main() {\n+    let args = os::args();\n+    let args = args.as_slice();\n+    if args.len() > 1 && args[1].as_slice() == \"segfault\" {\n+        unsafe { *(0 as *mut int) = 1 }; // trigger a segfault\n+    } else {\n+        let segfault = Command::new(args[0].as_slice()).arg(\"segfault\").output().unwrap();\n+        assert!(!segfault.status.success());\n+        let error = String::from_utf8_lossy(segfault.error.as_slice());\n+        assert!(!error.as_slice().contains(\"has overflowed its stack\"));\n+    }\n+}"}]}