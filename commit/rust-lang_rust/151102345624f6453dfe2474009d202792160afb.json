{"sha": "151102345624f6453dfe2474009d202792160afb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MTEwMjM0NTYyNGY2NDUzZGZlMjQ3NDAwOWQyMDI3OTIxNjBhZmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-11T07:39:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-11T07:39:52Z"}, "message": "Merge pull request #237 from RalfJung/reallocate\n\nUpdate for allcator API, simplify reallocate", "tree": {"sha": "1727d200e351c2ffc32cb358d1f4f8c1402bc1c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1727d200e351c2ffc32cb358d1f4f8c1402bc1c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/151102345624f6453dfe2474009d202792160afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/151102345624f6453dfe2474009d202792160afb", "html_url": "https://github.com/rust-lang/rust/commit/151102345624f6453dfe2474009d202792160afb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/151102345624f6453dfe2474009d202792160afb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8bd42e8d473e6fcce76f7690023820fe34c09a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bd42e8d473e6fcce76f7690023820fe34c09a3", "html_url": "https://github.com/rust-lang/rust/commit/b8bd42e8d473e6fcce76f7690023820fe34c09a3"}, {"sha": "1cbf5e896219be3e1eda8b1f92d1ba76ae30bd55", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbf5e896219be3e1eda8b1f92d1ba76ae30bd55", "html_url": "https://github.com/rust-lang/rust/commit/1cbf5e896219be3e1eda8b1f92d1ba76ae30bd55"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "0f32ac5183def49cb1fa7f228f737bcdce8ddc37", "filename": "src/memory.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -223,8 +223,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n-        assert!(align.is_power_of_two());\n+    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n+        use std::cmp::min;\n+\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             return Err(EvalError::ReallocateNonBasePtr);\n@@ -233,39 +234,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::ReallocatedStaticMemory);\n         }\n \n-        let size = self.get(ptr.alloc_id)?.bytes.len() as u64;\n-        let real_align = self.get(ptr.alloc_id)?.align;\n-        if size != old_size || real_align != align {\n-            return Err(EvalError::IncorrectAllocationInformation);\n-        }\n-\n-        if new_size > size {\n-            let amount = new_size - size;\n-            self.memory_usage += amount;\n-            let alloc = self.get_mut(ptr.alloc_id)?;\n-            assert_eq!(amount as usize as u64, amount);\n-            alloc.bytes.extend(iter::repeat(0).take(amount as usize));\n-            alloc.undef_mask.grow(amount, false);\n-        } else if size > new_size {\n-            self.memory_usage -= size - new_size;\n-            self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n-            let alloc = self.get_mut(ptr.alloc_id)?;\n-            // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n-            alloc.bytes.truncate(new_size as usize);\n-            alloc.bytes.shrink_to_fit();\n-            alloc.undef_mask.truncate(new_size);\n-        }\n-\n-        // Change allocation ID.  We do this after the above to be able to re-use methods like `clear_relocations`.\n-        let id = {\n-            let alloc = self.alloc_map.remove(&ptr.alloc_id).expect(\"We already used this pointer above\");\n-            let id = self.next_id;\n-            self.next_id.0 += 1;\n-            self.alloc_map.insert(id, alloc);\n-            id\n-        };\n+        // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n+        let new_ptr = self.allocate(new_size, new_align)?;\n+        self.copy(PrimVal::Ptr(ptr), PrimVal::Ptr(new_ptr), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n+        self.deallocate(ptr, Some((old_size, old_align)))?;\n \n-        Ok(Pointer::new(id, 0))\n+        Ok(new_ptr)\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n@@ -689,6 +663,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn copy(&mut self, src: PrimVal, dest: PrimVal, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n+            // TODO: Should we check for alignment here? (Also see write_bytes intrinsic)\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -1138,14 +1113,6 @@ impl UndefMask {\n         self.len += amount;\n         self.set_range_inbounds(start, start + amount, new_state);\n     }\n-\n-    fn truncate(&mut self, length: u64) {\n-        self.len = length;\n-        let truncate = self.len / BLOCK_SIZE + 1;\n-        assert_eq!(truncate as usize as u64, truncate);\n-        self.blocks.truncate(truncate as usize);\n-        self.blocks.shrink_to_fit();\n-    }\n }\n \n fn bit_index(bits: u64) -> (usize, usize) {"}, {"sha": "f2b0446618a0692ba1a256991277aa082529cbdd", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -463,6 +463,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n+                    // TODO: Should we, at least, validate the alignment? (Also see memory::copy)\n                     self.memory.check_align(ptr, ty_align, size * count)?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }"}, {"sha": "38fd4654741732242ee5cd9f7eb5ce4ca15a5108", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 91, "deletions": 72, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -520,37 +520,111 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         sig: ty::FnSig<'tcx>,\n         path: String,\n     ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n         if sig.abi == Abi::C {\n             // An external C function\n-            let ty = sig.output();\n-            let (ret, target) = destination.unwrap();\n-            self.call_c_abi(instance.def_id(), arg_operands, ret, ty, target)?;\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n             return Ok(());\n         }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n     \n-        // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-        // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n         match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)))?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n             \"std::io::_print\" => {\n                 trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n-                self.goto_block(destination.unwrap().1);\n-                Ok(())\n-            },\n-            \"std::thread::Builder::new\" => Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => Err(EvalError::Panic),\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n             \"std::panicking::panicking\" |\n             \"std::rt::panicking\" => {\n-                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n                 // we abort on panic -> `std::rt::panicking` always returns false\n                 let bool = self.tcx.types.bool;\n-                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                self.goto_block(block);\n-                Ok(())\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n             }\n-            _ => Err(EvalError::NoMirFor(path)),\n+            _ => return Err(EvalError::NoMirFor(path)),\n         }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n     }\n \n     fn call_c_abi(\n@@ -609,61 +683,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n             }\n \n-            \"__rust_allocate\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-\n-            \"__rust_allocate_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-\n-            \"__rust_deallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(ptr, Some((old_size, align)))?;\n-            },\n-\n-            \"__rust_reallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                if old_size == 0 || size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, size, align)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n             \"__rust_maybe_catch_panic\" => {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure"}, {"sha": "a0bcffa47d9fc784a5eb5d8d549ce4a5de35dbdb", "filename": "tests/compile-fail/deallocate-bad-alignment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,13 +1,16 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n // error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n \n use alloc::heap::*;\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        deallocate(x, 1, 2);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 2));\n     }\n }"}, {"sha": "d8c4493043dbb7984bda084c8b9f9ffc912f5782", "filename": "tests/compile-fail/deallocate-bad-size.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,13 +1,16 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n // error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n \n use alloc::heap::*;\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        deallocate(x, 1, 2);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Heap.dealloc(x, Layout::from_size_align_unchecked(2, 1));\n     }\n }"}, {"sha": "3c4399eaa3ed63e63d15ff3443bbd958fa77a0cd", "filename": "tests/compile-fail/deallocate-twice.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-twice.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,14 +1,17 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n // error-pattern: tried to deallocate with a pointer not to the beginning of an existing object\n \n use alloc::heap::*;\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        deallocate(x, 1, 1);\n-        deallocate(x, 1, 1);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n+        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n     }\n }"}, {"sha": "246d5592957748fe23723720658c1ebf893ac470", "filename": "tests/compile-fail/reallocate-bad-alignment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,13 +1,16 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n // error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n \n use alloc::heap::*;\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        let _y = reallocate(x, 1, 1, 2);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 2)).unwrap();\n+        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 2)).unwrap();\n     }\n }"}, {"sha": "2e5a641838020239c98dd28f828dc78fe98bc8af", "filename": "tests/compile-fail/reallocate-bad-size.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-size.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,13 +1,16 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n // error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n \n use alloc::heap::*;\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        let _y = reallocate(x, 2, 1, 1);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(2, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n     }\n }"}, {"sha": "290c966a2bc8a8acb3b3e440c5286a713444a554", "filename": "tests/compile-fail/reallocate-change-alloc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-change-alloc.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -1,12 +1,14 @@\n-#![feature(alloc, heap_api)]\n+#![feature(alloc, allocator_api)]\n \n extern crate alloc;\n \n-use alloc::heap::*;\n+use alloc::heap::Heap;\n+use alloc::allocator::*;\n+\n fn main() {\n     unsafe {\n-        let x = allocate(1, 1);\n-        let _y = reallocate(x, 1, 1, 1);\n+        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n         let _z = *x; //~ ERROR: dangling pointer was dereferenced\n     }\n }"}, {"sha": "fe5da49f807d57cb409f38fa4c9162c516f37a3d", "filename": "tests/run-pass/associated-const.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Frun-pass%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Frun-pass%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fassociated-const.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(associated_consts)]\n-\n trait Foo {\n     const ID: i32;\n }"}, {"sha": "14e38f43c527bd2df3e69f09436e439e4c316cd0", "filename": "tests/run-pass/issue-31267-additional.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/151102345624f6453dfe2474009d202792160afb/tests%2Frun-pass%2Fissue-31267-additional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151102345624f6453dfe2474009d202792160afb/tests%2Frun-pass%2Fissue-31267-additional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-31267-additional.rs?ref=151102345624f6453dfe2474009d202792160afb", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(unused_variables)]\n \n-#![feature(associated_consts)]\n-\n #[derive(Clone, Copy, Debug)]\n struct Bar;\n "}]}