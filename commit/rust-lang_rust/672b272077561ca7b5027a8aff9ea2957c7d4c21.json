{"sha": "672b272077561ca7b5027a8aff9ea2957c7d4c21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MmIyNzIwNzc1NjFjYTdiNTAyN2E4YWZmOWVhMjk1N2M3ZDRjMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-19T15:12:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-19T15:12:12Z"}, "message": "Auto merge of #72227 - nnethercote:tiny-vecs-are-dumb, r=Amanieu\n\nTiny Vecs are dumb.\n\nCurrently, if you repeatedly push to an empty vector, the capacity\ngrowth sequence is 0, 1, 2, 4, 8, 16, etc. This commit changes the\nrelevant code (the \"amortized\" growth strategy) to skip 1 and 2, instead\nusing 0, 4, 8, 16, etc. (You can still get a capacity of 1 or 2 using\nthe \"exact\" growth strategy, e.g. via `reserve_exact()`.)\n\nThis idea (along with the phrase \"tiny Vecs are dumb\") comes from the\n\"doubling\" growth strategy that was removed from `RawVec` in #72013.\nThat strategy was barely ever used -- only when a `VecDeque` was grown,\noddly enough -- which is why it was removed in #72013.\n\n(Fun fact: until just a few days ago, I thought the \"doubling\" strategy\nwas used for repeated push case. In other words, this commit makes\n`Vec`s behave the way I always thought they behaved.)\n\nThis change reduces the number of allocations done by rustc itself by\n10% or more. It speeds up rustc, and will also speed up any other Rust\nprogram that uses `Vec`s a lot.\n\nIn theory, the change could increase memory usage, but in practice it\ndoesn't. It would be an unusual program where very small `Vec`s having a\ncapacity of 4 rather than 1 or 2 would make a difference. You'd need a\n*lot* of very small `Vec`s, and/or some very small `Vec`s with very\nlarge elements.\n\nr? @Amanieu", "tree": {"sha": "3802fd229a7d61a2fe0342ae02a0d6096a7f3e87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3802fd229a7d61a2fe0342ae02a0d6096a7f3e87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21", "html_url": "https://github.com/rust-lang/rust/commit/672b272077561ca7b5027a8aff9ea2957c7d4c21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42acd9086f93fdc68a61cd79152abca77c6cd369", "url": "https://api.github.com/repos/rust-lang/rust/commits/42acd9086f93fdc68a61cd79152abca77c6cd369", "html_url": "https://github.com/rust-lang/rust/commit/42acd9086f93fdc68a61cd79152abca77c6cd369"}, {"sha": "f4b9dc31f68ff5b3dd19a22c4a3e3eefeaa0611a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b9dc31f68ff5b3dd19a22c4a3e3eefeaa0611a", "html_url": "https://github.com/rust-lang/rust/commit/f4b9dc31f68ff5b3dd19a22c4a3e3eefeaa0611a"}], "stats": {"total": 146, "additions": 141, "deletions": 5}, "files": [{"sha": "f348b5b69780be9cf97f3e25213bac8e5dcfcfba", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=672b272077561ca7b5027a8aff9ea2957c7d4c21", "patch": "@@ -407,13 +407,34 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             return Err(CapacityOverflow);\n         }\n \n+        if needed_extra_capacity == 0 {\n+            return Ok(());\n+        }\n+\n         // Nothing we can really do about these checks, sadly.\n         let required_cap =\n             used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-        let double_cap = self.cap * 2;\n-        // `double_cap` guarantees exponential growth.\n-        let cap = cmp::max(double_cap, required_cap);\n+\n+        // This guarantees exponential growth. The doubling cannot overflow\n+        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n+        let cap = cmp::max(self.cap * 2, required_cap);\n+\n+        // Tiny Vecs are dumb. Skip to:\n+        // - 8 if the element size is 1, because any heap allocators is likely\n+        //   to round up a request of less than 8 bytes to at least 8 bytes.\n+        // - 4 if elements are moderate-sized (<= 1 KiB).\n+        // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n+        // Note that `min_non_zero_cap` is computed statically.\n+        let elem_size = mem::size_of::<T>();\n+        let min_non_zero_cap = if elem_size == 1 {\n+            8\n+        } else if elem_size <= 1024 {\n+            4\n+        } else {\n+            1\n+        };\n+        let cap = cmp::max(min_non_zero_cap, cap);\n+\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`."}, {"sha": "17622d72a059c2e99266c23f7e489023bdea8f7c", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=672b272077561ca7b5027a8aff9ea2957c7d4c21", "patch": "@@ -59,7 +59,7 @@ fn reserve_does_not_overallocate() {\n         let mut v: RawVec<u32> = RawVec::new();\n         v.reserve(0, 7);\n         assert_eq!(7, v.capacity());\n-        // 97 if more than double of 7, so `reserve` should work\n+        // 97 is more than double of 7, so `reserve` should work\n         // like `reserve_exact`.\n         v.reserve(7, 90);\n         assert_eq!(97, v.capacity());"}, {"sha": "b16044d9640457a38a9f784b69fcc6558f6e3421", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672b272077561ca7b5027a8aff9ea2957c7d4c21/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=672b272077561ca7b5027a8aff9ea2957c7d4c21", "patch": "@@ -1473,3 +1473,118 @@ fn vec_macro_repeating_null_raw_fat_pointer() {\n         vtable: *mut (),\n     }\n }\n+\n+// This test will likely fail if you change the capacities used in\n+// `RawVec::grow_amortized`.\n+#[test]\n+fn test_push_growth_strategy() {\n+    // If the element size is 1, we jump from 0 to 8, then double.\n+    {\n+        let mut v1: Vec<u8> = vec![];\n+        assert_eq!(v1.capacity(), 0);\n+\n+        for _ in 0..8 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 64);\n+        }\n+    }\n+\n+    // If the element size is 2..=1024, we jump from 0 to 4, then double.\n+    {\n+        let mut v2: Vec<u16> = vec![];\n+        let mut v1024: Vec<[u8; 1024]> = vec![];\n+        assert_eq!(v2.capacity(), 0);\n+        assert_eq!(v1024.capacity(), 0);\n+\n+        for _ in 0..4 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 4);\n+            assert_eq!(v1024.capacity(), 4);\n+        }\n+\n+        for _ in 4..8 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 8);\n+            assert_eq!(v1024.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 16);\n+            assert_eq!(v1024.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 32);\n+            assert_eq!(v1024.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 64);\n+            assert_eq!(v1024.capacity(), 64);\n+        }\n+    }\n+\n+    // If the element size is > 1024, we jump from 0 to 1, then double.\n+    {\n+        let mut v1025: Vec<[u8; 1025]> = vec![];\n+        assert_eq!(v1025.capacity(), 0);\n+\n+        for _ in 0..1 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 1);\n+        }\n+\n+        for _ in 1..2 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 2);\n+        }\n+\n+        for _ in 2..4 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 4);\n+        }\n+\n+        for _ in 4..8 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 64);\n+        }\n+    }\n+}"}]}