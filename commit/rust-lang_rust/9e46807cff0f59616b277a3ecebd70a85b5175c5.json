{"sha": "9e46807cff0f59616b277a3ecebd70a85b5175c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNDY4MDdjZmYwZjU5NjE2YjI3N2EzZWNlYmQ3MGE4NWI1MTc1YzU=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-14T21:40:08Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T16:28:57Z"}, "message": "Add function eval_maybe_thread_local_static_const that allows handling thread locals without touching debug info; address other PR comments.", "tree": {"sha": "4637113fca07679f5603001bee0f0441e214a315", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4637113fca07679f5603001bee0f0441e214a315"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e46807cff0f59616b277a3ecebd70a85b5175c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e46807cff0f59616b277a3ecebd70a85b5175c5", "html_url": "https://github.com/rust-lang/rust/commit/9e46807cff0f59616b277a3ecebd70a85b5175c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e46807cff0f59616b277a3ecebd70a85b5175c5/comments", "author": null, "committer": null, "parents": [{"sha": "2960a6cf0482ca45aab399836e8b46bad8f91a6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2960a6cf0482ca45aab399836e8b46bad8f91a6e", "html_url": "https://github.com/rust-lang/rust/commit/2960a6cf0482ca45aab399836e8b46bad8f91a6e"}], "stats": {"total": 122, "additions": 70, "deletions": 52}, "files": [{"sha": "6b3c61a83fcbd115e7d4fad214581bbf63a19a7f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -28,6 +28,8 @@ use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n+    ///\n+    /// Note: the stack is provided by the machine.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n@@ -343,17 +345,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n+    pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         M::stack(self)\n     }\n \n     #[inline(always)]\n-    pub fn stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>> {\n+    pub(crate) fn stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>> {\n         M::stack_mut(self)\n     }\n \n     #[inline(always)]\n-    pub fn cur_frame(&self) -> usize {\n+    pub fn frame_idx(&self) -> usize {\n         let stack = self.stack();\n         assert!(!stack.is_empty());\n         stack.len() - 1\n@@ -598,7 +602,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         if !self.stack().is_empty() {\n-            info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n+            info!(\"PAUSING({}) {}\", self.frame_idx(), self.frame().instance);\n         }\n         ::log_settings::settings().indentation += 1;\n \n@@ -649,7 +653,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         M::after_stack_push(self)?;\n-        info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n+        info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n         if self.stack().len() > *self.tcx.sess.recursion_limit.get() {\n             throw_exhaust!(StackFrameLimitReached)\n@@ -706,7 +710,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn pop_stack_frame(&mut self, unwinding: bool) -> InterpResult<'tcx> {\n         info!(\n             \"LEAVING({}) {} (unwinding = {})\",\n-            self.cur_frame(),\n+            self.frame_idx(),\n             self.frame().instance,\n             unwinding\n         );\n@@ -789,7 +793,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if !self.stack().is_empty() {\n             info!(\n                 \"CONTINUING({}) {} (unwinding = {})\",\n-                self.cur_frame(),\n+                self.frame_idx(),\n                 self.frame().instance,\n                 unwinding\n             );\n@@ -897,8 +901,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();\n                 let mut msg = format!(\"{:?}\", local);\n-                if frame != self.cur_frame() {\n-                    write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n+                if frame != self.frame_idx() {\n+                    write!(msg, \" ({} frames up)\", self.frame_idx() - frame).unwrap();\n                 }\n                 write!(msg, \":\").unwrap();\n "}, {"sha": "4daadb9726ba4929692b97f5e3b9c42ab6c7fd3a", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -120,16 +120,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether memory accesses should be alignment-checked.\n     fn enforce_alignment(memory_extra: &Self::MemoryExtra) -> bool;\n \n-    /// Borrow the current thread's stack.\n-    fn stack(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n-\n-    /// Mutably borrow the current thread's stack.\n-    fn stack_mut(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n-\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n@@ -229,32 +219,43 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called for *every* memory access to determine the real ID of the given\n-    /// allocation. This provides a way for the machine to \"redirect\" certain\n-    /// allocations as it sees fit.\n+    /// Called for *every* memory access to determine the real ID of the given allocation.\n+    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n     ///\n-    /// This is used by Miri for two purposes:\n-    /// 1.  Redirecting extern statics to real allocations.\n-    /// 2.  Creating unique allocation ids for thread locals.\n-    ///\n-    ///     In Rust, one way for creating a thread local is by marking a static\n-    ///     with `#[thread_local]`. On supported platforms this gets translated\n-    ///     to a LLVM thread local. The problem with supporting these thread\n-    ///     locals in Miri is that in the internals of the compiler they look as\n-    ///     normal statics, except that they have the `thread_local` attribute.\n-    ///     However, in Miri we want to have a property that each allocation has\n-    ///     a unique id. Therefore, for these thread locals in\n-    ///     `canonical_alloc_id` we reserve fresh allocation ids for each\n-    ///     thread. Please note that `canonical_alloc_id` only reserves the\n-    ///     allocation ids, the actual allocation for the thread local statics\n-    ///     is done in the same way as for regular statics.\n+    /// This is used by Miri to redirect extern statics to real allocations.\n     ///\n     /// This function must be idempotent.\n     #[inline]\n     fn canonical_alloc_id(_mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n         id\n     }\n \n+    /// Called when converting a `ty::Const` to an operand.\n+    ///\n+    /// Miri uses this callback for creating unique allocation ids for thread\n+    /// locals. In Rust, one way for creating a thread local is by marking a\n+    /// static with `#[thread_local]`. On supported platforms this gets\n+    /// translated to a LLVM thread local for which LLVM automatically ensures\n+    /// that each thread gets its own copy. Since LLVM automatically handles\n+    /// thread locals, the Rust compiler just treats thread local statics as\n+    /// regular statics even though accessing a thread local static should be an\n+    /// effectful computation that depends on the current thread. The long term\n+    /// plan is to change MIR to make accesses to thread locals explicit\n+    /// (https://github.com/rust-lang/rust/issues/70685). While the issue 70685\n+    /// is not fixed, our current workaround in Miri is to use this function to\n+    /// reserve fresh allocation ids for each thread. Please note that here we\n+    /// only **reserve** the allocation ids; the actual allocation for the\n+    /// thread local statics is done in `Memory::get_global_alloc`, which uses\n+    /// `resolve_maybe_global_alloc` to retrieve information about the\n+    /// allocation id we generated.\n+    #[inline]\n+    fn eval_maybe_thread_local_static_const(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        val: mir::interpret::ConstValue<'tcx>,\n+    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n+        Ok(val)\n+    }\n+\n     /// Called to obtain the `GlobalAlloc` associated with the allocation id.\n     ///\n     /// Miri uses this callback to resolve the information about the original\n@@ -326,6 +327,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame: Frame<'mir, 'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n \n+    /// Borrow the current thread's stack.\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n+\n+    /// Mutably borrow the current thread's stack.\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+\n     /// Called immediately after a stack frame got pushed and its locals got initialized.\n     fn after_stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())"}, {"sha": "27c8bf45906487ae8338d422d59b78e652821f05", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -430,11 +430,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         // The call to `resolve_maybe_global_alloc` is needed to enable Miri to\n-        // support thread local statics. In `M::canonical_alloc_id`, for a\n-        // thread local static, Miri reserves a fresh allocation id, but the\n-        // actual allocation is left to the code that handles statics which\n-        // calls this function (`get_global_alloc`). Since the allocation id is\n-        // fresh, it has no information about the original static. The call to\n+        // support thread local statics. In\n+        // `M::eval_maybe_thread_local_static_const`, for a thread local static,\n+        // Miri reserves a fresh allocation id, but the actual allocation is\n+        // left to the code that handles statics which calls this function\n+        // (`get_global_alloc`). Since the allocation id is fresh, it has no\n+        // information about the original static. The call to\n         // `resolve_maybe_global_alloc` allows Miri to retrieve this information\n         // for us.\n         let (alloc, def_id) = match M::resolve_maybe_global_alloc(tcx, memory_extra, id) {\n@@ -598,9 +599,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // # Statics\n         // The call to `resolve_maybe_global_alloc` is needed here because Miri\n-        // via the call to `canonical_alloc_id` above reserves fresh allocation\n-        // ids for thread local statics. However, the actual allocation is done\n-        // not in `canonical_alloc_id`, but in `get_raw` and `get_raw_mut`.\n+        // via the callback to `eval_maybe_thread_local_static_const` in\n+        // `eval_const_to_op` reserves fresh allocation ids for thread local\n+        // statics. However, the actual allocation is done not in\n+        // `resolve_maybe_global_alloc`, but in `get_raw` and `get_raw_mut`.\n         // Since this function may get called before `get_raw`, we need to allow\n         // Miri to retrieve the information about the static for us.\n         match M::resolve_maybe_global_alloc(self.tcx, &self.extra, id) {"}, {"sha": "df9ce3f18a9fed5c569f1ec7506ddb983044785f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -537,6 +537,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n+        let val_val = M::eval_maybe_thread_local_static_const(self, val_val)?;\n         // Other cases need layout.\n         let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {"}, {"sha": "6dad6b923149370a4391748d9a721c5d256fb977", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -662,7 +662,7 @@ where\n             }\n             local => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.cur_frame(), local },\n+                place: Place::Local { frame: self.frame_idx(), local },\n                 layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n         };"}, {"sha": "aae708827b953e8e835812f38eb5b8fc4752ec38", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -60,18 +60,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let body = self.body();\n         let basic_block = &body.basic_blocks()[block];\n \n-        let old_frames = self.cur_frame();\n+        let old_frames = self.frame_idx();\n \n         if let Some(stmt) = basic_block.statements.get(stmt_id) {\n-            assert_eq!(old_frames, self.cur_frame());\n+            assert_eq!(old_frames, self.frame_idx());\n             self.statement(stmt)?;\n             return Ok(true);\n         }\n \n         M::before_terminator(self)?;\n \n         let terminator = basic_block.terminator();\n-        assert_eq!(old_frames, self.cur_frame());\n+        assert_eq!(old_frames, self.frame_idx());\n         self.terminator(terminator)?;\n         Ok(true)\n     }\n@@ -84,7 +84,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // Some statements (e.g., box) push new stack frames.\n         // We have to record the stack frame number *before* executing the statement.\n-        let frame_idx = self.cur_frame();\n+        let frame_idx = self.frame_idx();\n \n         match &stmt.kind {\n             Assign(box (place, rvalue)) => self.eval_rvalue_into_place(rvalue, *place)?,"}, {"sha": "7157225e5c9bb398b565deded00205a1e417e29c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e46807cff0f59616b277a3ecebd70a85b5175c5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=9e46807cff0f59616b277a3ecebd70a85b5175c5", "patch": "@@ -52,7 +52,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Call { ref func, ref args, destination, ref cleanup, .. } => {\n-                let old_stack = self.cur_frame();\n+                let old_stack = self.frame_idx();\n                 let old_bb = self.frame().block;\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n@@ -80,7 +80,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n-                if self.cur_frame() == old_stack && self.frame().block == old_bb {\n+                if self.frame_idx() == old_stack && self.frame().block == old_bb {\n                     span_bug!(terminator.source_info.span, \"evaluating this call made no progress\");\n                 }\n             }"}]}