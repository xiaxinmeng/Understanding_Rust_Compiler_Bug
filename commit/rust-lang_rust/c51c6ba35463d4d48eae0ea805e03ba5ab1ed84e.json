{"sha": "c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MWM2YmEzNTQ2M2Q0ZDQ4ZWFlMGVhODA1ZTAzYmE1YWIxZWQ4NGU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-10T01:15:55Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-10T01:16:28Z"}, "message": "Sketching trans_anon_obj.", "tree": {"sha": "0f31fe7403abd9cd87dc3795c53dd307868ed045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f31fe7403abd9cd87dc3795c53dd307868ed045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e", "html_url": "https://github.com/rust-lang/rust/commit/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40e3a9fcbcd6d9ebb98bc29729b1ef1b4dbec95c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40e3a9fcbcd6d9ebb98bc29729b1ef1b4dbec95c", "html_url": "https://github.com/rust-lang/rust/commit/40e3a9fcbcd6d9ebb98bc29729b1ef1b4dbec95c"}], "stats": {"total": 226, "additions": 219, "deletions": 7}, "files": [{"sha": "2ce915d0fc63786710ec2db0c4290e0a73fb25d0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 219, "deletions": 7, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c51c6ba35463d4d48eae0ea805e03ba5ab1ed84e", "patch": "@@ -5701,7 +5701,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n         }\n \n         case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n-            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid, ann);\n+            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, ann);\n         }\n \n         case (_) {\n@@ -6352,12 +6352,27 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs,\n   wrapped inner object.\n \n */\n-fn trans_anon_obj(&@block_ctxt cx, &span sp,\n+\n+// trans_anon_obj: create (and return!) an LLVM function that is the object\n+// constructor for the anonymous object being translated.  \n+//\n+// This code differs from trans_obj in that, rather than creating an object\n+// constructor function and putting it in the generated code as an object\n+// item, we are instead \"inlining\" the construction of the object.\n+fn trans_anon_obj(@block_ctxt cx, &span sp,\n                   &ast::anon_obj anon_obj, \n                   &vec[ast::ty_param] ty_params,\n-                  &ast::obj_def_ids oid,\n+                  ast::def_id oid,\n                   &ast::ann ann) -> result {\n+    auto ccx = cx.fcx.lcx.ccx;\n \n+    // A crate_ctxt has an item_ids hashmap, which has all of the def_ids of\n+    // everything in the crate.  By looking up a def_id, you can get the\n+    // ValueRef of that item.\n+    auto llctor_decl = ccx.item_ids.get(oid);\n+\n+    // If with_obj (the object being extended) exists, translate it, producing\n+    // a result.\n     let option::t[result] with_obj_val = none[result];\n     alt (anon_obj.with_obj) {\n         case (none) { }\n@@ -6369,25 +6384,222 @@ fn trans_anon_obj(&@block_ctxt cx, &span sp,\n         }\n     }\n \n+    // If the anonymous object we're translating adds any additional fields,\n+    // they'll become the arguments to the function we're creating.\n+\n+    // FIXME (part of issue #417): all of the following code is copypasta from\n+    // trans_obj for translating the anonymous wrapper object.  Eventually we\n+    // should abstract this code out of trans_anon_obj and trans_obj.\n+\n     // For the anon obj's additional fields, if any exist, translate object\n     // constructor arguments to function arguments.\n-    let option::t[vec[ast::obj_field]] addtl_fields \n-        = none[vec[ast::obj_field]];\n+    let vec[ast::obj_field] addtl_fields = [];\n     let vec[ast::arg] addtl_fn_args = [];\n \n     alt (anon_obj.fields) {\n         case (none) { }\n         case (some(?fields)) {\n+            addtl_fields = fields;\n             for (ast::obj_field f in fields) {\n                 addtl_fn_args += [rec(mode=ast::alias, ty=f.ty, \n                                       ident=f.ident, id=f.id)];\n             }\n         }\n     }\n+    auto fcx = new_fn_ctxt(cx.fcx.lcx, sp, llctor_decl);\n+\n+    // Both regular arguments and type parameters are handled here.\n+    create_llargs_for_fn_args(fcx, ast::proto_fn,\n+                              none[ty_self_pair],\n+                              ret_ty_of_fn(ccx, ann),\n+                              addtl_fn_args, ty_params);\n+    \n+    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n+    copy_args_to_allocas(fcx, addtl_fn_args, arg_tys);\n+\n+    //  Create the first block context in the function and keep a handle on it\n+    //  to pass to finish_fn later.\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n+\n+    // Pick up the type of this object by looking at our own output type, that\n+    // is, the output type of the object constructor we're building.\n+    auto self_ty = ret_ty_of_fn(ccx, ann);\n+    auto llself_ty = type_of(ccx, sp, self_ty);\n+\n+    // Set up the two-word pair that we're going to return from the object\n+    // constructor we're building.  The two elements of this pair will be a\n+    // vtable pointer and a body pointer.  (llretptr already points to the\n+    // place where this two-word pair should go; it was pre-allocated by the\n+    // caller of the function.)\n+    auto pair = bcx.fcx.llretptr;\n+\n+    // Grab onto the first and second elements of the pair.\n+    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n+    // of 'pair'.\n+    auto pair_vtbl = bcx.build.GEP(pair,\n+                                   [C_int(0),\n+                                    C_int(abi::obj_field_vtbl)]);\n+    auto pair_box = bcx.build.GEP(pair,\n+                                  [C_int(0),\n+                                   C_int(abi::obj_field_box)]);\n+\n+    // Make a vtable for this object: a static array of pointers to functions.\n+    // It will be located in the read-only memory of the executable we're\n+    // creating and will contain ValueRefs for all of this object's methods.\n+    // create_vtbl returns a pointer to the vtable, which we store.\n+\n+    // create_vtbl() wants an ast::_obj and all we have is an\n+    // ast::anon_obj, so we need to roll our own.\n+    let ast::_obj wrapper_obj = rec(\n+        fields = addtl_fields,\n+        methods = anon_obj.methods,\n+        dtor = none[@ast::method]);\n+\n+    auto vtbl = create_vtbl(cx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n+                            ty_params);\n+    bcx.build.Store(vtbl, pair_vtbl);\n+\n+    // FIXME (part of issue #417): This vtable needs to contain \"forwarding\n+    // slots\" for the methods that exist in the with_obj, as well.  How do we\n+    // do that?\n+\n+    // Next we have to take care of the other half of the pair we're\n+    // returning: a boxed (reference-counted) tuple containing a tydesc,\n+    // typarams, and fields.\n+\n+    // FIXME (part of issue #417): Because this is an anonymous object, we\n+    // also have to fill in the with_obj field of this tuple.\n+\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+    \n+    // FIXME: we should probably also allocate a box for empty objs that have\n+    // a dtor, since otherwise they are never dropped, and the dtor never\n+    // runs.\n+    if (vec::len[ast::ty_param](ty_params) == 0u &&\n+        vec::len[ty::arg](arg_tys) == 0u) {\n+        // If the object we're translating has no fields or type parameters,\n+        // there's not much to do.\n+\n+        // Store null into pair, if no args or typarams.\n+        bcx.build.Store(C_null(llbox_ty), pair_box);\n+    } else {\n+        // Otherwise, we have to synthesize a big structural type for the\n+        // object body.\n+\n+        let vec[ty::t] obj_fields = [];\n+        for (ty::arg a in arg_tys) {\n+            vec::push[ty::t](obj_fields, a.ty);\n+        }\n+\n+        // Tuple type for fields: [field, ...]\n+        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n+\n+        // Tuple type for typarams: [typaram, ...]\n+        auto tydesc_ty = ty::mk_type(ccx.tcx);\n+        let vec[ty::t] tps = [];\n+        for (ast::ty_param tp in ty_params) {\n+            vec::push[ty::t](tps, tydesc_ty);\n+        }\n+        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n+ \n+        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n+        let ty::t body_ty = ty::mk_imm_tup(ccx.tcx,\n+                                          [tydesc_ty,\n+                                           typarams_ty,\n+                                           fields_ty]);\n+\n+        // Hand this type we've synthesized off to trans_malloc_boxed, which\n+        // allocates a box, including space for a refcount.\n+        auto box = trans_malloc_boxed(bcx, body_ty);\n+        bcx = box.bcx;\n+\n+        // mk_imm_box throws a refcount into the type we're synthesizing, so\n+        // that it looks like: [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n+        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n+\n+        // Grab onto the refcount and body parts of the box we allocated.\n+        auto rc = GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                               [0, \n+                                abi::box_rc_field_refcnt]);\n+        bcx = rc.bcx;\n+\n+        auto body = GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                                 [0, abi::box_rc_field_body]);\n+        bcx = body.bcx;\n+\n+        bcx.build.Store(C_int(1), rc.val);\n+\n+        // Put together a tydesc for the body, so that the object can later be\n+        // freed by calling through its tydesc.\n+\n+        // Every object (not just those with type parameters) needs to have a\n+        // tydesc to describe its body, since all objects have unknown type to\n+        // the user of the object.  So the tydesc is needed to keep track of\n+        // the types of the object's fields, so that the fields can be freed\n+        // later.\n+        auto body_tydesc =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_tydesc]);\n+        bcx = body_tydesc.bcx;\n+\n+        auto ti = none[@tydesc_info];\n+        auto body_td = get_tydesc(bcx, body_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+\n+        bcx = body_td.bcx;\n+        bcx.build.Store(body_td.val, body_tydesc.val);\n+\n+        // Copy the object's type parameters and fields into the space we\n+        // allocated for the object body.  (This is something like saving the\n+        // lexical environment of a function in its closure: the \"captured\n+        // typarams\" are any type parameters that are passed to the object\n+        // constructor and are then available to the object's methods.\n+        // Likewise for the object's fields.)\n+\n+        // Copy typarams into captured typarams.\n+        auto body_typarams =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_typarams]);\n+        bcx = body_typarams.bcx;\n+        let int i = 0;\n+        for (ast::ty_param tp in ty_params) {\n+            auto typaram = bcx.fcx.lltydescs.(i);\n+            auto capture = GEP_tup_like(bcx, typarams_ty, body_typarams.val,\n+                                        [0, i]);\n+            bcx = capture.bcx;\n+            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n+            i += 1;\n+        }\n+\n+        // Copy args into body fields.\n+        auto body_fields =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_fields]);\n+        bcx = body_fields.bcx;\n+\n+        i = 0;\n+        for (ast::obj_field f in wrapper_obj.fields) {\n+            auto arg = bcx.fcx.llargs.get(f.id);\n+            arg = load_if_immediate(bcx, arg, arg_tys.(i).ty);\n+            auto field = GEP_tup_like(bcx, fields_ty, body_fields.val,\n+                                      [0, i]);\n+            bcx = field.bcx;\n+            bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n+            i += 1;\n+        }\n+        // Store box ptr in outer pair.\n+        auto p = bcx.build.PointerCast(box.val, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n+    }\n+    bcx.build.RetVoid();\n \n-    // TODO: everything else.\n+    // Insert the mandatory first few basic blocks before lltop.\n+    finish_fn(fcx, lltop);\n \n-    cx.fcx.lcx.ccx.sess.unimpl(\"support for anonymous objects\");\n+    // Return the object we built.\n+    ret res(bcx, pair);\n }\n \n fn init_local(&@block_ctxt cx, &@ast::local local) -> result {"}]}