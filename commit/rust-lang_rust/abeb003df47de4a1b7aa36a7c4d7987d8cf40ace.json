{"sha": "abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZWIwMDNkZjQ3ZGU0YTFiN2FhMzZhN2M0ZDc5ODdkOGNmNDBhY2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T12:57:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T12:58:10Z"}, "message": "Allow multiline annotations", "tree": {"sha": "c81e83fcb3c9abdae2a7b38020f6da9d5d05d833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c81e83fcb3c9abdae2a7b38020f6da9d5d05d833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "html_url": "https://github.com/rust-lang/rust/commit/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b0865ab226d57c88e22b6b395d033f68f2c11af", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0865ab226d57c88e22b6b395d033f68f2c11af", "html_url": "https://github.com/rust-lang/rust/commit/0b0865ab226d57c88e22b6b395d033f68f2c11af"}], "stats": {"total": 72, "additions": 59, "deletions": 13}, "files": [{"sha": "3870c6d9c3f433b5866dea1985b358ab470f3adc", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "patch": "@@ -261,8 +261,7 @@ fn check_diagnostics(ra_fixture: &str) {\n         // FXIME: macros...\n         let file_id = d.source().file_id.original_file(&db);\n         let range = d.syntax_node(&db).text_range();\n-        // FIXME: support multi-line messages in annotations\n-        let message = d.message().lines().next().unwrap().to_owned();\n+        let message = d.message().to_owned();\n         actual.entry(file_id).or_default().push((range, message));\n     });\n     actual.values_mut().for_each(|diags| diags.sort_by_key(|it| it.0.start()));"}, {"sha": "95f272811fcec06411299cb287e92f2ce0350c68", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "patch": "@@ -1162,12 +1162,14 @@ fn main() {\n     match a {\n         Either::A { } => (),\n                 //^^^ Missing structure fields:\n+                //  | - foo\n         Either::B => (),\n     }\n     match a {\n         //^ Missing match arm\n         Either::A { } => (),\n     }           //^^^ Missing structure fields:\n+                //  | - foo\n \n     match a {\n         Either::A { foo: true } => (),"}, {"sha": "ad586c882bec6c60cf28ea82cc961a286caae5f7", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abeb003df47de4a1b7aa36a7c4d7987d8cf40ace/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=abeb003df47de4a1b7aa36a7c4d7987d8cf40ace", "patch": "@@ -179,39 +179,80 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     let mut res = Vec::new();\n     let mut prev_line_start: Option<TextSize> = None;\n     let mut line_start: TextSize = 0.into();\n+    let mut prev_line_annotations: Vec<(TextSize, usize)> = Vec::new();\n     for line in lines_with_ends(text) {\n+        let mut this_line_annotations = Vec::new();\n         if let Some(idx) = line.find(\"//\") {\n-            let offset = prev_line_start.unwrap() + TextSize::of(&line[..idx + \"//\".len()]);\n-            for (line_range, text) in extract_line_annotations(&line[idx + \"//\".len()..]) {\n-                res.push((line_range + offset, text))\n+            let annotation_offset = TextSize::of(&line[..idx + \"//\".len()]);\n+            for annotation in extract_line_annotations(&line[idx + \"//\".len()..]) {\n+                match annotation {\n+                    LineAnnotation::Annotation { mut range, content } => {\n+                        range += annotation_offset;\n+                        this_line_annotations.push((range.end(), res.len()));\n+                        res.push((range + prev_line_start.unwrap(), content))\n+                    }\n+                    LineAnnotation::Continuation { mut offset, content } => {\n+                        offset += annotation_offset;\n+                        let &(_, idx) = prev_line_annotations\n+                            .iter()\n+                            .find(|&&(off, _idx)| off == offset)\n+                            .unwrap();\n+                        res[idx].1.push('\\n');\n+                        res[idx].1.push_str(&content);\n+                        res[idx].1.push('\\n');\n+                    }\n+                }\n             }\n         }\n+\n         prev_line_start = Some(line_start);\n         line_start += TextSize::of(line);\n+\n+        prev_line_annotations = this_line_annotations;\n     }\n     res\n }\n \n-fn extract_line_annotations(mut line: &str) -> Vec<(TextRange, String)> {\n+enum LineAnnotation {\n+    Annotation { range: TextRange, content: String },\n+    Continuation { offset: TextSize, content: String },\n+}\n+\n+fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n     let mut res = Vec::new();\n     let mut offset: TextSize = 0.into();\n+    let marker: fn(char) -> bool = if line.contains('^') { |c| c == '^' } else { |c| c == '|' };\n     loop {\n-        match line.find('^') {\n+        match line.find(marker) {\n             Some(idx) => {\n                 offset += TextSize::try_from(idx).unwrap();\n                 line = &line[idx..];\n             }\n             None => break,\n         };\n \n-        let len = line.chars().take_while(|&it| it == '^').count();\n-        assert!(len > 0);\n+        let mut len = line.chars().take_while(|&it| it == '^').count();\n+        let mut continuation = false;\n+        if len == 0 {\n+            assert!(line.starts_with('|'));\n+            continuation = true;\n+            len = 1;\n+        }\n         let range = TextRange::at(offset, len.try_into().unwrap());\n-        let next = line[len..].find('^').map_or(line.len(), |it| it + len);\n-        res.push((range, line[len..][..next - len].trim().to_string()));\n+        let next = line[len..].find(marker).map_or(line.len(), |it| it + len);\n+        let content = line[len..][..next - len].trim().to_string();\n+\n+        let annotation = if continuation {\n+            LineAnnotation::Continuation { offset: range.end(), content }\n+        } else {\n+            LineAnnotation::Annotation { range, content }\n+        };\n+        res.push(annotation);\n+\n         line = &line[next..];\n         offset += TextSize::try_from(next).unwrap();\n     }\n+\n     res\n }\n \n@@ -223,14 +264,18 @@ fn main() {\n     let (x,     y) = (9, 2);\n        //^ def  ^ def\n     zoo + 1\n-} //^^^ i32\n+} //^^^ type:\n+  //  | i32\n     \"#,\n     );\n     let res = extract_annotations(&text)\n         .into_iter()\n         .map(|(range, ann)| (&text[range], ann))\n         .collect::<Vec<_>>();\n-    assert_eq!(res, vec![(\"x\", \"def\".into()), (\"y\", \"def\".into()), (\"zoo\", \"i32\".into()),]);\n+    assert_eq!(\n+        res,\n+        vec![(\"x\", \"def\".into()), (\"y\", \"def\".into()), (\"zoo\", \"type:\\ni32\\n\".into()),]\n+    );\n }\n \n // Comparison functionality borrowed from cargo:"}]}