{"sha": "d783371b862c15d6d402d68e8edce4e37d63796c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ODMzNzFiODYyYzE1ZDZkNDAyZDY4ZThlZGNlNGUzN2Q2Mzc5NmM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-08T10:18:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-15T18:20:20Z"}, "message": "migrate modue map to salsa", "tree": {"sha": "927354d027fc6778aeb520ec0b74673d446e525d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/927354d027fc6778aeb520ec0b74673d446e525d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d783371b862c15d6d402d68e8edce4e37d63796c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d783371b862c15d6d402d68e8edce4e37d63796c", "html_url": "https://github.com/rust-lang/rust/commit/d783371b862c15d6d402d68e8edce4e37d63796c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d783371b862c15d6d402d68e8edce4e37d63796c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "html_url": "https://github.com/rust-lang/rust/commit/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b"}], "stats": {"total": 337, "additions": 172, "deletions": 165}, "files": [{"sha": "c54d502529b9eaff74a19423f3119dd648d161a3", "filename": "crates/ra_analysis/src/db/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs?ref=d783371b862c15d6d402d68e8edce4e37d63796c", "patch": "@@ -9,7 +9,8 @@ use ra_syntax::File;\n use ra_editor::{LineIndex};\n use crate::{\n     symbol_index::SymbolIndex,\n-    FileId, FileResolverImp\n+    module_map::{ModulesDatabase, ModuleTreeQuery, ModuleDescriptorQuery},\n+    FileId, FileResolverImp,\n };\n \n #[derive(Default)]\n@@ -40,6 +41,10 @@ salsa::database_storage! {\n             fn file_lines() for FileLinesQuery;\n             fn file_symbols() for FileSymbolsQuery;\n         }\n+        impl ModulesDatabase {\n+            fn module_tree() for ModuleTreeQuery;\n+            fn module_descriptor() for ModuleDescriptorQuery;\n+        }\n     }\n }\n "}, {"sha": "8d9f38ca592535adaf43d76f0992944295f74133", "filename": "crates/ra_analysis/src/descriptors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs?ref=d783371b862c15d6d402d68e8edce4e37d63796c", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     imp::FileResolverImp,\n };\n \n-#[derive(Debug, Hash)]\n+#[derive(Debug, PartialEq, Eq, Hash)]\n pub struct ModuleDescriptor {\n     pub submodules: Vec<Submodule>\n }\n@@ -43,7 +43,7 @@ pub struct Submodule {\n     pub name: SmolStr,\n }\n \n-#[derive(Hash, Debug)]\n+#[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct ModuleTreeDescriptor {\n     nodes: Vec<NodeData>,\n     links: Vec<LinkData>,\n@@ -52,7 +52,7 @@ pub(crate) struct ModuleTreeDescriptor {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n struct Node(usize);\n-#[derive(Hash, Debug)]\n+#[derive(Hash, Debug, PartialEq, Eq)]\n struct NodeData {\n     file_id: FileId,\n     links: Vec<Link>,\n@@ -61,7 +61,7 @@ struct NodeData {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub(crate) struct Link(usize);\n-#[derive(Hash, Debug)]\n+#[derive(Hash, Debug, PartialEq, Eq)]\n struct LinkData {\n     owner: Node,\n     name: SmolStr,\n@@ -70,7 +70,7 @@ struct LinkData {\n }\n \n \n-#[derive(Clone, Debug, Hash)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Problem {\n     UnresolvedModule {\n         candidate: RelativePathBuf,"}, {"sha": "d49132513ccc8d226fb6369aeaeb92565f9ef197", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=d783371b862c15d6d402d68e8edce4e37d63796c", "patch": "@@ -14,7 +14,7 @@ extern crate salsa;\n extern crate rustc_hash;\n \n mod symbol_index;\n-// mod module_map;\n+mod module_map;\n mod imp;\n mod job;\n mod roots;"}, {"sha": "95a770ae72004d8a57aef703cca66ab7dd1a92d9", "filename": "crates/ra_analysis/src/module_map.rs", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs?ref=d783371b862c15d6d402d68e8edce4e37d63796c", "patch": "@@ -1,157 +1,157 @@\n use std::sync::Arc;\n use crate::{\n     FileId,\n-    db::{\n-        Query, QueryRegistry, QueryCtx,\n-        file_set\n-    },\n-    queries::file_syntax,\n+    db::{SyntaxDatabase},\n     descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n };\n \n-pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n-    reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n-    reg.add(MODULE_TREE, \"MODULE_TREE\");\n-}\n-\n-pub(crate) fn module_tree(ctx: QueryCtx) -> Arc<ModuleTreeDescriptor> {\n-    ctx.get(MODULE_TREE, ())\n-}\n-\n-const MODULE_DESCR: Query<FileId, ModuleDescriptor> = Query(30, |ctx, &file_id| {\n-    let file = file_syntax(ctx, file_id);\n-    ModuleDescriptor::new(file.ast())\n-});\n-\n-const MODULE_TREE: Query<(), ModuleTreeDescriptor> = Query(31, |ctx, _| {\n-    let file_set = file_set(ctx);\n-    let mut files = Vec::new();\n-    for &file_id in file_set.0.iter() {\n-        let module_descr = ctx.get(MODULE_DESCR, file_id);\n-        files.push((file_id, module_descr));\n-    }\n-    ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.1)\n-});\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::collections::HashMap;\n-    use im;\n-    use relative_path::{RelativePath, RelativePathBuf};\n-    use crate::{\n-        db::{Db},\n-        imp::FileResolverImp,\n-        FileId, FileResolver,\n-    };\n-    use super::*;\n-\n-    #[derive(Debug)]\n-    struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n-\n-    impl FileResolver for FileMap {\n-        fn file_stem(&self, file_id: FileId) -> String {\n-            self.0[&file_id].file_stem().unwrap().to_string()\n+salsa::query_group! {\n+    pub(crate) trait ModulesDatabase: SyntaxDatabase {\n+        fn module_tree(key: ()) -> Arc<ModuleTreeDescriptor> {\n+            type ModuleTreeQuery;\n         }\n-        fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n-            let path = self.0[&file_id].join(rel).normalize();\n-            self.0.iter()\n-                .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n-                .next()\n+        fn module_descriptor(file_id: FileId) -> Arc<ModuleDescriptor> {\n+            type ModuleDescriptorQuery;\n         }\n     }\n+}\n \n-    struct Fixture {\n-        next_file_id: u32,\n-        fm: im::HashMap<FileId, RelativePathBuf>,\n-        db: Db,\n-    }\n-\n-    impl Fixture {\n-        fn new() -> Fixture {\n-            Fixture {\n-                next_file_id: 1,\n-                fm: im::HashMap::new(),\n-                db: Db::new(),\n-            }\n-        }\n-        fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-            assert!(path.starts_with(\"/\"));\n-            let file_id = FileId(self.next_file_id);\n-            self.next_file_id += 1;\n-            self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n-            new_state.file_resolver = FileResolverImp::new(\n-                Arc::new(FileMap(self.fm.clone()))\n-            );\n-            self.db = self.db.with_changes(new_state, &[file_id], true);\n-            file_id\n-        }\n-        fn remove_file(&mut self, file_id: FileId) {\n-            self.fm.remove(&file_id);\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.remove(&file_id);\n-            new_state.file_resolver = FileResolverImp::new(\n-                Arc::new(FileMap(self.fm.clone()))\n-            );\n-            self.db = self.db.with_changes(new_state, &[file_id], true);\n-        }\n-        fn change_file(&mut self, file_id: FileId, new_text: &str) {\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n-            self.db = self.db.with_changes(new_state, &[file_id], false);\n-        }\n-        fn check_parent_modules(\n-            &self,\n-            file_id: FileId,\n-            expected: &[FileId],\n-            queries: &[(&'static str, u64)]\n-        ) {\n-            let (tree, events) = self.db.trace_query(|ctx| module_tree(ctx));\n-            let actual = tree.parent_modules(file_id)\n-                .into_iter()\n-                .map(|link| link.owner(&tree))\n-                .collect::<Vec<_>>();\n-            assert_eq!(actual.as_slice(), expected);\n-            let mut counts = HashMap::new();\n-            events.into_iter()\n-               .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n-            for &(query_id, expected_count) in queries.iter() {\n-                let actual_count = *counts.get(&query_id).unwrap_or(&0);\n-                assert_eq!(\n-                    actual_count,\n-                    expected_count,\n-                    \"counts for {} differ\",\n-                    query_id,\n-                )\n-            }\n-\n-        }\n-    }\n-\n-    #[test]\n-    fn test_parent_module() {\n-        let mut f = Fixture::new();\n-        let foo = f.add_file(\"/foo.rs\", \"\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-        let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n-\n-        f.change_file(lib, \"\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.change_file(lib, \"mod bar;\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-        f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+fn module_descriptor(db: &impl ModulesDatabase, file_id: FileId) -> Arc<ModuleDescriptor> {\n+    let file = db.file_syntax(file_id);\n+    Arc::new(ModuleDescriptor::new(file.ast()))\n+}\n \n-        f.remove_file(lib);\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n+fn module_tree(db: &impl ModulesDatabase, (): ()) -> Arc<ModuleTreeDescriptor> {\n+    let file_set = db.file_set(());\n+    let mut files = Vec::new();\n+    for &file_id in file_set.files.iter() {\n+        let module_descr = db.module_descriptor(file_id);\n+        files.push((file_id, module_descr));\n     }\n+    let res = ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.resolver);\n+    Arc::new(res)\n }\n+\n+// #[cfg(test)]\n+// mod tests {\n+//     use std::collections::HashMap;\n+//     use im;\n+//     use relative_path::{RelativePath, RelativePathBuf};\n+//     use {\n+//         db::{Db},\n+//         imp::FileResolverImp,\n+//         FileId, FileResolver,\n+//     };\n+//     use super::*;\n+\n+//     #[derive(Debug)]\n+//     struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n+\n+//     impl FileResolver for FileMap {\n+//         fn file_stem(&self, file_id: FileId) -> String {\n+//             self.0[&file_id].file_stem().unwrap().to_string()\n+//         }\n+//         fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n+//             let path = self.0[&file_id].join(rel).normalize();\n+//             self.0.iter()\n+//                 .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n+//                 .next()\n+//         }\n+//     }\n+\n+//     struct Fixture {\n+//         next_file_id: u32,\n+//         fm: im::HashMap<FileId, RelativePathBuf>,\n+//         db: Db,\n+//     }\n+\n+//     impl Fixture {\n+//         fn new() -> Fixture {\n+//             Fixture {\n+//                 next_file_id: 1,\n+//                 fm: im::HashMap::new(),\n+//                 db: Db::new(),\n+//             }\n+//         }\n+//         fn add_file(&mut self, path: &str, text: &str) -> FileId {\n+//             assert!(path.starts_with(\"/\"));\n+//             let file_id = FileId(self.next_file_id);\n+//             self.next_file_id += 1;\n+//             self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n+//             let mut new_state = self.db.state().clone();\n+//             new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n+//             new_state.file_resolver = FileResolverImp::new(\n+//                 Arc::new(FileMap(self.fm.clone()))\n+//             );\n+//             self.db = self.db.with_changes(new_state, &[file_id], true);\n+//             file_id\n+//         }\n+//         fn remove_file(&mut self, file_id: FileId) {\n+//             self.fm.remove(&file_id);\n+//             let mut new_state = self.db.state().clone();\n+//             new_state.file_map.remove(&file_id);\n+//             new_state.file_resolver = FileResolverImp::new(\n+//                 Arc::new(FileMap(self.fm.clone()))\n+//             );\n+//             self.db = self.db.with_changes(new_state, &[file_id], true);\n+//         }\n+//         fn change_file(&mut self, file_id: FileId, new_text: &str) {\n+//             let mut new_state = self.db.state().clone();\n+//             new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n+//             self.db = self.db.with_changes(new_state, &[file_id], false);\n+//         }\n+//         fn check_parent_modules(\n+//             &self,\n+//             file_id: FileId,\n+//             expected: &[FileId],\n+//             queries: &[(&'static str, u64)]\n+//         ) {\n+//             let (tree, events) = self.db.trace_query(|ctx| module_tree(ctx));\n+//             let actual = tree.parent_modules(file_id)\n+//                 .into_iter()\n+//                 .map(|link| link.owner(&tree))\n+//                 .collect::<Vec<_>>();\n+//             assert_eq!(actual.as_slice(), expected);\n+//             let mut counts = HashMap::new();\n+//             events.into_iter()\n+//                .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n+//             for &(query_id, expected_count) in queries.iter() {\n+//                 let actual_count = *counts.get(&query_id).unwrap_or(&0);\n+//                 assert_eq!(\n+//                     actual_count,\n+//                     expected_count,\n+//                     \"counts for {} differ\",\n+//                     query_id,\n+//                 )\n+//             }\n+\n+//         }\n+//     }\n+\n+//     #[test]\n+//     fn test_parent_module() {\n+//         let mut f = Fixture::new();\n+//         let foo = f.add_file(\"/foo.rs\", \"\");\n+//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n+\n+//         let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n+//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n+\n+//         f.change_file(lib, \"\");\n+//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n+\n+//         f.change_file(lib, \"mod foo;\");\n+//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+\n+//         f.change_file(lib, \"mod bar;\");\n+//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n+\n+//         f.change_file(lib, \"mod foo;\");\n+//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+\n+//         f.remove_file(lib);\n+//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n+//     }\n+// }"}, {"sha": "908f49b0a52f2ff1a67e101e0ab731a8d71d569f", "filename": "crates/ra_analysis/src/roots.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d783371b862c15d6d402d68e8edce4e37d63796c/crates%2Fra_analysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Froots.rs?ref=d783371b862c15d6d402d68e8edce4e37d63796c", "patch": "@@ -16,7 +16,8 @@ use crate::{\n     imp::FileResolverImp,\n     symbol_index::SymbolIndex,\n     descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n-    db::{self, FilesDatabase, SyntaxDatabase}\n+    db::{self, FilesDatabase, SyntaxDatabase},\n+    module_map::ModulesDatabase,\n };\n \n pub(crate) trait SourceRoot {\n@@ -53,17 +54,17 @@ impl WritableSourceRoot {\n                 }\n             }\n         }\n-        if let Some(resolver) = file_resolver {\n-            let mut files: HashSet<FileId> = db.file_set(())\n-                .files\n-                .clone();\n-            for file_id in removed {\n-                files.remove(&file_id);\n-            }\n-            files.extend(changed);\n-            db.query(db::FileSetQuery)\n-                .set((), Arc::new(db::FileSet { files, resolver }))\n+        let file_set = db.file_set(());\n+        let mut files: HashSet<FileId> = file_set\n+            .files\n+            .clone();\n+        for file_id in removed {\n+            files.remove(&file_id);\n         }\n+        files.extend(changed);\n+        let resolver = file_resolver.unwrap_or_else(|| file_set.resolver.clone());\n+        db.query(db::FileSetQuery)\n+            .set((), Arc::new(db::FileSet { files, resolver }));\n         // TODO: reconcile sasla's API with our needs\n         // https://github.com/salsa-rs/salsa/issues/12\n         self.clone()\n@@ -72,12 +73,13 @@ impl WritableSourceRoot {\n \n impl SourceRoot for WritableSourceRoot {\n     fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n-        unimplemented!()\n-        //self.db.make_query(::module_map::module_tree)\n+        self.db.read().module_tree(())\n     }\n-\n     fn contains(&self, file_id: FileId) -> bool {\n-        self.db.read().file_set(()).files.contains(&file_id)\n+        let db = self.db.read();\n+        let files = &db.file_set(()).files;\n+        eprintln!(\"files = {:?}\", files);\n+        files.contains(&file_id)\n     }\n     fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.db.read().file_lines(file_id)"}]}