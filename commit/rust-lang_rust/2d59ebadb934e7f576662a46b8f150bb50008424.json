{"sha": "2d59ebadb934e7f576662a46b8f150bb50008424", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNTllYmFkYjkzNGU3ZjU3NjY2MmE0NmI4ZjE1MGJiNTAwMDg0MjQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-06T21:17:00Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-06T21:21:07Z"}, "message": "add test cases for fold traversing macros", "tree": {"sha": "ae4379873540278bbf416ddc76f54f7f9c0f2de7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae4379873540278bbf416ddc76f54f7f9c0f2de7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d59ebadb934e7f576662a46b8f150bb50008424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d59ebadb934e7f576662a46b8f150bb50008424", "html_url": "https://github.com/rust-lang/rust/commit/2d59ebadb934e7f576662a46b8f150bb50008424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d59ebadb934e7f576662a46b8f150bb50008424/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51fae097f17792edf98ec8e7aaf1a1aad58a86f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51fae097f17792edf98ec8e7aaf1a1aad58a86f", "html_url": "https://github.com/rust-lang/rust/commit/a51fae097f17792edf98ec8e7aaf1a1aad58a86f"}], "stats": {"total": 150, "additions": 150, "deletions": 0}, "files": [{"sha": "7562930b655798fd57d601069ab3493927e250b8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2d59ebadb934e7f576662a46b8f150bb50008424/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d59ebadb934e7f576662a46b8f150bb50008424/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2d59ebadb934e7f576662a46b8f150bb50008424", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use ast::*;\n use ast;\n use codemap::{span, spanned};\n+use parse::token;\n use opt_vec::OptVec;\n \n use core::vec;\n@@ -904,3 +905,74 @@ impl AstFoldExtensions for @ast_fold {\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use ast;\n+    use util::parser_testing::{string_to_crate, matches_codepattern};\n+    use parse::token;\n+    use print::pprust;\n+    use super::*;\n+\n+    // taken from expand\n+    // given a function from idents to idents, produce\n+    // an ast_fold that applies that function:\n+    pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n+        let afp = default_ast_fold();\n+        let f_pre = @AstFoldFns{\n+            fold_ident : |id, _| f(id),\n+            .. *afp\n+        };\n+        make_fold(f_pre)\n+    }\n+\n+    // this version doesn't care about getting comments or docstrings in.\n+    fn fake_print_crate(s: @pprust::ps, crate: ast::crate) {\n+        pprust::print_mod(s, &crate.node.module, crate.node.attrs);\n+    }\n+\n+    // change every identifier to \"zz\"\n+    pub fn to_zz() -> @fn(ast::ident)->ast::ident {\n+        let zz_id = token::str_to_ident(\"zz\");\n+        |id| {zz_id}\n+    }\n+\n+    // maybe add to expand.rs...\n+    macro_rules! assert_pred (\n+        ($pred:expr, $predname:expr, $a:expr , $b:expr) => (\n+            {\n+                let pred_val = $pred;\n+                let a_val = $a;\n+                let b_val = $b;\n+                if !(pred_val(a_val,b_val)) {\n+                    fail!(\"expected args satisfying %s, got %? and %?\",\n+                          $predname, a_val, b_val);\n+                }\n+            }\n+        )\n+    )\n+\n+    // make sure idents get transformed everywhere\n+    #[test] fn ident_transformation () {\n+        let zz_fold = fun_to_ident_folder(to_zz());\n+        let ast = string_to_crate(@~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        assert_pred!(matches_codepattern,\n+                     \"matches_codepattern\",\n+                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                                    token::get_ident_interner()),\n+                     ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n+    }\n+\n+    // even inside macro defs....\n+    #[test] fn ident_transformation_in_defs () {\n+        let zz_fold = fun_to_ident_folder(to_zz());\n+        let ast = string_to_crate(@~\"macro_rules! a {(b $c:expr $(d $e:token)f+\n+=> (g $(d $d $e)+))} \");\n+        assert_pred!(matches_codepattern,\n+                     \"matches_codepattern\",\n+                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                                    token::get_ident_interner()),\n+                     ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n+    }\n+\n+}"}, {"sha": "76055ca7914e729be822c339b03d431f2693c0ee", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2d59ebadb934e7f576662a46b8f150bb50008424/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d59ebadb934e7f576662a46b8f150bb50008424/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=2d59ebadb934e7f576662a46b8f150bb50008424", "patch": "@@ -69,3 +69,81 @@ pub fn string_to_pat(source_str : @~str) -> @ast::pat {\n pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::ident] {\n     ids.map(|u| token::str_to_ident(*u))\n }\n+\n+// does the given string match the pattern? whitespace in the first string\n+// may be deleted or replaced with other whitespace to match the pattern.\n+// this function is unicode-ignorant; fortunately, the careful design of\n+// UTF-8 mitigates this ignorance.  In particular, this function only collapses\n+// sequences of \\n, \\r, ' ', and \\t, but it should otherwise tolerate unicode\n+// chars. Unsurprisingly, it doesn't do NKF-normalization(?).\n+pub fn matches_codepattern(a : &str, b : &str) -> bool {\n+    let mut idx_a = 0;\n+    let mut idx_b = 0;\n+    loop {\n+        if (idx_a == a.len() && idx_b == b.len()) {\n+            return true;\n+        }\n+        else if (idx_a == a.len()) {return false;}\n+        else if (idx_b == b.len()) {\n+            // maybe the stuff left in a is all ws?\n+            if (is_whitespace(a.char_at(idx_a))) {\n+                return (scan_for_non_ws_or_end(a,idx_a) == a.len());\n+            } else {\n+                return false;\n+            }\n+        }\n+        // ws in both given and pattern:\n+        else if (is_whitespace(a.char_at(idx_a))\n+           && is_whitespace(b.char_at(idx_b))) {\n+            idx_a = scan_for_non_ws_or_end(a,idx_a);\n+            idx_b = scan_for_non_ws_or_end(b,idx_b);\n+        }\n+        // ws in given only:\n+        else if (is_whitespace(a.char_at(idx_a))) {\n+            idx_a = scan_for_non_ws_or_end(a,idx_a);\n+        }\n+        // *don't* silently eat ws in expected only.\n+        else if (a.char_at(idx_a) == b.char_at(idx_b)) {\n+            idx_a += 1;\n+            idx_b += 1;\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+}\n+\n+// given a string and an index, return the first uint >= idx\n+// that is a non-ws-char or is outside of the legal range of\n+// the string.\n+fn scan_for_non_ws_or_end(a : &str, idx: uint) -> uint {\n+    let mut i = idx;\n+    let len = a.len();\n+    while ((i < len) && (is_whitespace(a.char_at(i)))) {\n+        i += 1;\n+    }\n+    i\n+}\n+\n+// copied from lexer.\n+pub fn is_whitespace(c: char) -> bool {\n+    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test] fn eqmodws() {\n+        assert_eq!(matches_codepattern(\"\",\"\"),true);\n+        assert_eq!(matches_codepattern(\"\",\"a\"),false);\n+        assert_eq!(matches_codepattern(\"a\",\"\"),false);\n+        assert_eq!(matches_codepattern(\"a\",\"a\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b \",\"a   \\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b \"),false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n+        assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n+    }\n+}"}]}