{"sha": "1acbe7573dc32f917f51a784a36b7afc690900e3", "node_id": "C_kwDOAAsO6NoAKDFhY2JlNzU3M2RjMzJmOTE3ZjUxYTc4NGEzNmI3YWZjNjkwOTAwZTM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-07T03:30:45Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-07T21:01:26Z"}, "message": "Use delayed error handling for `Encodable` and `Encoder` infallible.\n\nThere are two impls of the `Encoder` trait: `opaque::Encoder` and\n`opaque::FileEncoder`. The former encodes into memory and is infallible, the\nlatter writes to file and is fallible.\n\nCurrently, standard `Result`/`?`/`unwrap` error handling is used, but this is a\nbit verbose and has non-trivial cost, which is annoying given how rare failures\nare (especially in the infallible `opaque::Encoder` case).\n\nThis commit changes how `Encoder` fallibility is handled. All the `emit_*`\nmethods are now infallible. `opaque::Encoder` requires no great changes for\nthis. `opaque::FileEncoder` now implements a delayed error handling strategy.\nIf a failure occurs, it records this via the `res` field, and all subsequent\nencoding operations are skipped if `res` indicates an error has occurred. Once\nencoding is complete, the new `finish` method is called, which returns a\n`Result`. In other words, there is now a single `Result`-producing method\ninstead of many of them.\n\nThis has very little effect on how any file errors are reported if\n`opaque::FileEncoder` has any failures.\n\nMuch of this commit is boring mechanical changes, removing `Result` return\nvalues and `?` or `unwrap` from expressions. The more interesting parts are as\nfollows.\n- serialize.rs: The `Encoder` trait gains an `Ok` associated type. The\n  `into_inner` method is changed into `finish`, which returns\n  `Result<Vec<u8>, !>`.\n- opaque.rs: The `FileEncoder` adopts the delayed error handling\n  strategy. Its `Ok` type is a `usize`, returning the number of bytes\n  written, replacing previous uses of `FileEncoder::position`.\n- Various methods that take an encoder now consume it, rather than being\n  passed a mutable reference, e.g. `serialize_query_result_cache`.", "tree": {"sha": "1b4e8d414de3d349bd3ae038c28e9dc77e54c345", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4e8d414de3d349bd3ae038c28e9dc77e54c345"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1acbe7573dc32f917f51a784a36b7afc690900e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1acbe7573dc32f917f51a784a36b7afc690900e3", "html_url": "https://github.com/rust-lang/rust/commit/1acbe7573dc32f917f51a784a36b7afc690900e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1acbe7573dc32f917f51a784a36b7afc690900e3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "582b9cbc45334a73467d6ccaf0a8b9de559c2011", "url": "https://api.github.com/repos/rust-lang/rust/commits/582b9cbc45334a73467d6ccaf0a8b9de559c2011", "html_url": "https://github.com/rust-lang/rust/commit/582b9cbc45334a73467d6ccaf0a8b9de559c2011"}], "stats": {"total": 1291, "additions": 610, "deletions": 681}, "files": [{"sha": "9e6a186219b643f9e02dc19300303fb339765795", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -2473,9 +2473,7 @@ rustc_index::newtype_index! {\n }\n \n impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {"}, {"sha": "30481eddf9160ee30009d679ade670127c96fc32", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -121,8 +121,8 @@ impl<D: Decoder, T: 'static + Decodable<D>> Decodable<D> for P<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s);\n     }\n }\n \n@@ -191,8 +191,8 @@ impl<'a, T> IntoIterator for &'a P<[T]> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<[T]> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&**self, s)\n+    fn encode(&self, s: &mut S) {\n+        Encodable::encode(&**self, s);\n     }\n }\n "}, {"sha": "84d8829c398e61b5727da2be837eac28cd6b5ae6", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -142,9 +142,9 @@ impl fmt::Debug for LazyTokenStream {\n }\n \n impl<S: Encoder> Encodable<S> for LazyTokenStream {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         // Used by AST json printing.\n-        Encodable::encode(&self.create_token_stream(), s)\n+        Encodable::encode(&self.create_token_stream(), s);\n     }\n }\n "}, {"sha": "771157dcad95493a9c412549fb852f661412b620", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -29,7 +29,7 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_serialize::{opaque, Decodable, Decoder, Encoder};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::{CrateType, OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_session::cstore::{self, CrateSource};\n use rustc_session::utils::NativeLibKind;\n@@ -204,13 +204,13 @@ const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n impl CodegenResults {\n     pub fn serialize_rlink(codegen_results: &CodegenResults) -> Vec<u8> {\n         let mut encoder = opaque::Encoder::new();\n-        encoder.emit_raw_bytes(RLINK_MAGIC).unwrap();\n+        encoder.emit_raw_bytes(RLINK_MAGIC);\n         // `emit_raw_bytes` is used to make sure that the version representation does not depend on\n         // Encoder's inner representation of `u32`.\n-        encoder.emit_raw_bytes(&RLINK_VERSION.to_be_bytes()).unwrap();\n-        encoder.emit_str(RUSTC_VERSION.unwrap()).unwrap();\n-        rustc_serialize::Encodable::encode(codegen_results, &mut encoder).unwrap();\n-        encoder.into_inner()\n+        encoder.emit_raw_bytes(&RLINK_VERSION.to_be_bytes());\n+        encoder.emit_str(RUSTC_VERSION.unwrap());\n+        Encodable::encode(codegen_results, &mut encoder);\n+        encoder.finish().unwrap()\n     }\n \n     pub fn deserialize_rlink(data: Vec<u8>) -> Result<Self, String> {"}, {"sha": "a032b039f34ef234f980dddd4de6ab7c02ffaf8c", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -144,9 +144,8 @@ impl_stable_hash_via_hash!(Fingerprint);\n \n impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n     #[inline]\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_raw_bytes(&self.to_le_bytes())?;\n-        Ok(())\n+    fn encode(&self, s: &mut E) {\n+        s.emit_raw_bytes(&self.to_le_bytes());\n     }\n }\n \n@@ -187,10 +186,10 @@ impl std::fmt::Display for PackedFingerprint {\n \n impl<E: rustc_serialize::Encoder> Encodable<E> for PackedFingerprint {\n     #[inline]\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) {\n         // Copy to avoid taking reference to packed field.\n         let copy = self.0;\n-        copy.encode(s)\n+        copy.encode(s);\n     }\n }\n "}, {"sha": "61654b9e8f5f5f0104fe426ff274ef771478080c", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -49,8 +49,8 @@ impl fmt::Display for Svh {\n }\n \n impl<S: Encoder> Encodable<S> for Svh {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u64(self.as_u64().to_le())\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u64(self.as_u64().to_le());\n     }\n }\n "}, {"sha": "2dbd4b6bce85a9b3076b93a46d8d3326eade2996", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -30,22 +30,20 @@ const HEADER_FORMAT_VERSION: u16 = 0;\n /// the Git commit hash.\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n-pub(crate) fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) -> FileEncodeResult {\n-    stream.emit_raw_bytes(FILE_MAGIC)?;\n-    stream.emit_raw_bytes(&[\n-        (HEADER_FORMAT_VERSION >> 0) as u8,\n-        (HEADER_FORMAT_VERSION >> 8) as u8,\n-    ])?;\n+pub(crate) fn write_file_header(stream: &mut FileEncoder, nightly_build: bool) {\n+    stream.emit_raw_bytes(FILE_MAGIC);\n+    stream\n+        .emit_raw_bytes(&[(HEADER_FORMAT_VERSION >> 0) as u8, (HEADER_FORMAT_VERSION >> 8) as u8]);\n \n     let rustc_version = rustc_version(nightly_build);\n     assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n-    stream.emit_raw_bytes(&[rustc_version.len() as u8])?;\n-    stream.emit_raw_bytes(rustc_version.as_bytes())\n+    stream.emit_raw_bytes(&[rustc_version.len() as u8]);\n+    stream.emit_raw_bytes(rustc_version.as_bytes());\n }\n \n pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n where\n-    F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n+    F: FnOnce(FileEncoder) -> FileEncodeResult,\n {\n     debug!(\"save: storing data in {}\", path_buf.display());\n \n@@ -80,28 +78,21 @@ where\n         }\n     };\n \n-    if let Err(err) = write_file_header(&mut encoder, sess.is_nightly_build()) {\n-        sess.err(&format!(\"failed to write {} header to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n-    }\n-\n-    if let Err(err) = encode(&mut encoder) {\n-        sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n-    }\n+    write_file_header(&mut encoder, sess.is_nightly_build());\n \n-    if let Err(err) = encoder.flush() {\n-        sess.err(&format!(\"failed to flush {} to `{}`: {}\", name, path_buf.display(), err));\n-        return;\n+    match encode(encoder) {\n+        Ok(position) => {\n+            sess.prof.artifact_size(\n+                &name.replace(' ', \"_\"),\n+                path_buf.file_name().unwrap().to_string_lossy(),\n+                position as u64,\n+            );\n+            debug!(\"save: data written to disk successfully\");\n+        }\n+        Err(err) => {\n+            sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n+        }\n     }\n-\n-    sess.prof.artifact_size(\n-        &name.replace(' ', \"_\"),\n-        path_buf.file_name().unwrap().to_string_lossy(),\n-        encoder.position() as u64,\n-    );\n-\n-    debug!(\"save: data written to disk successfully\");\n }\n \n /// Reads the contents of a file with a file header as defined in this module."}, {"sha": "9341a742925d9d321438d647b78701cba3ad0489", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::sync::join;\n use rustc_middle::dep_graph::{DepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n-use rustc_serialize::Encodable as RustcEncodable;\n+use rustc_serialize::{Encodable as RustcEncodable, Encoder};\n use rustc_session::Session;\n use std::fs;\n \n@@ -96,8 +96,9 @@ pub fn save_work_product_index(\n     debug!(\"save_work_product_index()\");\n     dep_graph.assert_ignored();\n     let path = work_products_path(sess);\n-    file_format::save_in(sess, path, \"work product index\", |e| {\n-        encode_work_product_index(&new_work_products, e)\n+    file_format::save_in(sess, path, \"work product index\", |mut e| {\n+        encode_work_product_index(&new_work_products, &mut e);\n+        e.finish()\n     });\n \n     // We also need to clean out old work-products, as not all of them are\n@@ -123,7 +124,7 @@ pub fn save_work_product_index(\n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n     encoder: &mut FileEncoder,\n-) -> FileEncodeResult {\n+) {\n     let serialized_products: Vec<_> = work_products\n         .iter()\n         .map(|(id, work_product)| SerializedWorkProduct {\n@@ -135,7 +136,7 @@ fn encode_work_product_index(\n     serialized_products.encode(encoder)\n }\n \n-fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n+fn encode_query_cache(tcx: TyCtxt<'_>, encoder: FileEncoder) -> FileEncodeResult {\n     tcx.sess.time(\"incr_comp_serialize_result_cache\", || tcx.serialize_query_result_cache(encoder))\n }\n \n@@ -170,24 +171,10 @@ pub fn build_dep_graph(\n         }\n     };\n \n-    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n-        sess.err(&format!(\n-            \"failed to write dependency graph header to `{}`: {}\",\n-            path_buf.display(),\n-            err\n-        ));\n-        return None;\n-    }\n+    file_format::write_file_header(&mut encoder, sess.is_nightly_build());\n \n     // First encode the commandline arguments hash\n-    if let Err(err) = sess.opts.dep_tracking_hash(false).encode(&mut encoder) {\n-        sess.err(&format!(\n-            \"failed to write dependency graph hash `{}`: {}\",\n-            path_buf.display(),\n-            err\n-        ));\n-        return None;\n-    }\n+    sess.opts.dep_tracking_hash(false).encode(&mut encoder);\n \n     Some(DepGraph::new(\n         &sess.prof,"}, {"sha": "1a55519d7b120f21ba24c9b6b4d801df74de1499", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -60,8 +60,8 @@ pub struct IndexVec<I: Idx, T> {\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&self.raw, s)\n+    fn encode(&self, s: &mut S) {\n+        Encodable::encode(&self.raw, s);\n     }\n }\n "}, {"sha": "0a77b734c7641a5912810d08e7acd091fb73dd3b", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -137,8 +137,8 @@ impl Parse for Newtype {\n                     }\n                 }\n                 impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for #name {\n-                    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-                        e.emit_u32(self.private)\n+                    fn encode(&self, e: &mut E) {\n+                        e.emit_u32(self.private);\n                     }\n                 }\n             }"}, {"sha": "82e6972d0270c583d65d0aa632d73d15cc079669", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -146,21 +146,17 @@ fn encodable_body(\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                            ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n                                 #bind_ident,\n                                 __encoder,\n-                            ) {\n-                                ::std::result::Result::Ok(()) => (),\n-                                ::std::result::Result::Err(__err)\n-                                    => return ::std::result::Result::Err(__err),\n-                            }\n+                            );\n                         };\n                         result\n                     })\n                     .collect::<TokenStream>()\n             });\n             quote! {\n-                ::std::result::Result::Ok(match *self { #encode_inner })\n+                match *self { #encode_inner }\n             }\n         }\n         _ => {\n@@ -172,14 +168,10 @@ fn encodable_body(\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                            ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n                                 #bind_ident,\n                                 __encoder,\n-                            ) {\n-                                ::std::result::Result::Ok(()) => (),\n-                                ::std::result::Result::Err(__err)\n-                                    => return ::std::result::Result::Err(__err),\n-                            }\n+                            );\n                         };\n                         result\n                     })\n@@ -190,7 +182,7 @@ fn encodable_body(\n                         ::rustc_serialize::Encoder::emit_enum_variant(\n                             __encoder,\n                             #variant_idx,\n-                            |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n+                            |__encoder| { #encode_fields }\n                         )\n                     }\n                 } else {\n@@ -223,7 +215,7 @@ fn encodable_body(\n             fn encode(\n                 &self,\n                 __encoder: &mut #encoder_ty,\n-            ) -> ::std::result::Result<(), <#encoder_ty as ::rustc_serialize::Encoder>::Error> {\n+            ) {\n                 #lints\n                 #encode_body\n             }"}, {"sha": "40c94b372bbf39d3bb5ece8cdb1c9c70c6c16397", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -4,7 +4,7 @@ use crate::rmeta::MetadataBlob;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_middle::parameterized_over_tcx;\n-use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::def_id::{DefIndex, DefPathHash};\n \n pub(crate) enum DefPathHashMapRef<'tcx> {\n@@ -29,12 +29,12 @@ impl DefPathHashMapRef<'_> {\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefPathHashMapRef<'tcx> {\n-    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) {\n         match *self {\n             DefPathHashMapRef::BorrowedFromTcx(def_path_hash_map) => {\n                 let bytes = def_path_hash_map.raw_bytes();\n-                e.emit_usize(bytes.len())?;\n-                e.emit_raw_bytes(bytes)\n+                e.emit_usize(bytes.len());\n+                e.emit_raw_bytes(bytes);\n             }\n             DefPathHashMapRef::OwnedFromMetadata(_) => {\n                 panic!(\"DefPathHashMap::OwnedFromMetadata variant only exists for deserialization\")"}, {"sha": "3285273ba909e4f903952321cbfa45e53f8dad0a", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -86,14 +86,15 @@ macro_rules! empty_proc_macro {\n \n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n-        $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n+        $(fn $name(&mut self, value: $ty) {\n             self.opaque.$name(value)\n         })*\n     }\n }\n \n impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n-    type Error = <opaque::Encoder as Encoder>::Error;\n+    type Ok = <opaque::Encoder as Encoder>::Ok;\n+    type Err = <opaque::Encoder as Encoder>::Err;\n \n     encoder_methods! {\n         emit_usize(usize);\n@@ -117,74 +118,77 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n+\n+    fn finish(self) -> Result<Self::Ok, Self::Err> {\n+        self.opaque.finish()\n+    }\n }\n \n impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyValue<T> {\n-    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_lazy_distance(self.position)\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) {\n+        e.emit_lazy_distance(self.position);\n     }\n }\n \n impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyArray<T> {\n-    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.num_elems)?;\n-        if self.num_elems == 0 {\n-            return Ok(());\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) {\n+        e.emit_usize(self.num_elems);\n+        if self.num_elems > 0 {\n+            e.emit_lazy_distance(self.position)\n         }\n-        e.emit_lazy_distance(self.position)\n     }\n }\n \n impl<'a, 'tcx, I, T> Encodable<EncodeContext<'a, 'tcx>> for LazyTable<I, T> {\n-    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.encoded_size)?;\n-        e.emit_lazy_distance(self.position)\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) {\n+        e.emit_usize(self.encoded_size);\n+        e.emit_lazy_distance(self.position);\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for CrateNum {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         if *self != LOCAL_CRATE && s.is_proc_macro {\n             panic!(\"Attempted to encode non-local CrateNum {:?} for proc-macro crate\", self);\n         }\n-        s.emit_u32(self.as_u32())\n+        s.emit_u32(self.as_u32());\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        s.emit_u32(self.as_u32())\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n+        s.emit_u32(self.as_u32());\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnIndex {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        s.emit_u32(self.as_u32())\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n+        s.emit_u32(self.as_u32());\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s)\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s);\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         if self.krate == LOCAL_CRATE {\n             // We will only write details for local expansions.  Non-local expansions will fetch\n             // data from the corresponding crate's metadata.\n             // FIXME(#43047) FIXME(#74731) We may eventually want to avoid relying on external\n             // metadata from proc-macro crates.\n             s.hygiene_ctxt.schedule_expn_data_for_encoding(*self);\n         }\n-        self.krate.encode(s)?;\n-        self.local_id.encode(s)\n+        self.krate.encode(s);\n+        self.local_id.encode(s);\n     }\n }\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n-    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         let span = self.data();\n \n         // Don't serialize any `SyntaxContext`s from a proc-macro crate,\n@@ -219,9 +223,9 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // `rustc_span::hygiene::raw_encode_expn_id` to handle\n         // encoding `ExpnData` for proc-macro crates.\n         if s.is_proc_macro {\n-            SyntaxContext::root().encode(s)?;\n+            SyntaxContext::root().encode(s);\n         } else {\n-            span.ctxt.encode(s)?;\n+            span.ctxt.encode(s);\n         }\n \n         if self.is_dummy() {\n@@ -289,22 +293,20 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n         };\n \n-        tag.encode(s)?;\n-        lo.encode(s)?;\n+        tag.encode(s);\n+        lo.encode(s);\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n         let len = hi - lo;\n-        len.encode(s)?;\n+        len.encode(s);\n \n         if tag == TAG_VALID_SPAN_FOREIGN {\n             // This needs to be two lines to avoid holding the `s.source_file_cache`\n             // while calling `cnum.encode(s)`\n             let cnum = s.source_file_cache.0.cnum;\n-            cnum.encode(s)?;\n+            cnum.encode(s);\n         }\n-\n-        Ok(())\n     }\n }\n \n@@ -325,13 +327,10 @@ impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n         &mut self.predicate_shorthands\n     }\n \n-    fn encode_alloc_id(\n-        &mut self,\n-        alloc_id: &rustc_middle::mir::interpret::AllocId,\n-    ) -> Result<(), Self::Error> {\n+    fn encode_alloc_id(&mut self, alloc_id: &rustc_middle::mir::interpret::AllocId) {\n         let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n \n-        index.encode(self)\n+        index.encode(self);\n     }\n }\n \n@@ -360,10 +359,7 @@ macro_rules! record_array {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn emit_lazy_distance(\n-        &mut self,\n-        position: NonZeroUsize,\n-    ) -> Result<(), <Self as Encoder>::Error> {\n+    fn emit_lazy_distance(&mut self, position: NonZeroUsize) {\n         let pos = position.get();\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n@@ -382,7 +378,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n         };\n         self.lazy_state = LazyState::Previous(NonZeroUsize::new(pos).unwrap());\n-        self.emit_usize(distance)\n+        self.emit_usize(distance);\n     }\n \n     fn lazy<T: ParameterizedOverTcx, B: Borrow<T::Value<'tcx>>>(&mut self, value: B) -> LazyValue<T>\n@@ -393,7 +389,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         self.lazy_state = LazyState::NodeStart(pos);\n-        value.borrow().encode(self).unwrap();\n+        value.borrow().encode(self);\n         self.lazy_state = LazyState::NoNode;\n \n         assert!(pos.get() <= self.position());\n@@ -412,7 +408,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         self.lazy_state = LazyState::NodeStart(pos);\n-        let len = values.into_iter().map(|value| value.borrow().encode(self).unwrap()).count();\n+        let len = values.into_iter().map(|value| value.borrow().encode(self)).count();\n         self.lazy_state = LazyState::NoNode;\n \n         assert!(pos.get() <= self.position());\n@@ -615,7 +611,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let id = self.interpret_allocs[idx];\n                     let pos = self.position() as u32;\n                     interpret_alloc_index.push(pos);\n-                    interpret::specialized_encode_alloc_id(self, tcx, id).unwrap();\n+                    interpret::specialized_encode_alloc_id(self, tcx, id);\n                 }\n                 n = new_n;\n             }\n@@ -1640,18 +1636,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let mut expn_data_table: TableBuilder<_, _> = Default::default();\n         let mut expn_hash_table: TableBuilder<_, _> = Default::default();\n \n-        let _: Result<(), !> = self.hygiene_ctxt.encode(\n+        self.hygiene_ctxt.encode(\n             &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table, &mut expn_hash_table),\n             |(this, syntax_contexts, _, _), index, ctxt_data| {\n                 syntax_contexts.set(index, this.lazy(ctxt_data));\n-                Ok(())\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n                 if let Some(index) = index.as_local() {\n                     expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n                     expn_hash_table.set(index.as_raw(), this.lazy(hash));\n                 }\n-                Ok(())\n             },\n         );\n \n@@ -2195,10 +2189,10 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new();\n-    encoder.emit_raw_bytes(METADATA_HEADER).unwrap();\n+    encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n-    encoder.emit_raw_bytes(&[0, 0, 0, 0]).unwrap();\n+    encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n \n     let source_map_files = tcx.sess.source_map().files();\n     let source_file_cache = (source_map_files[0].clone(), 0);\n@@ -2223,13 +2217,13 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     };\n \n     // Encode the rustc version string in a predictable location.\n-    rustc_version().encode(&mut ecx).unwrap();\n+    rustc_version().encode(&mut ecx);\n \n     // Encode all the entries and extra information in the crate,\n     // culminating in the `CrateRoot` which points to all of it.\n     let root = ecx.encode_crate_root();\n \n-    let mut result = ecx.opaque.into_inner();\n+    let mut result = ecx.opaque.finish().unwrap();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();"}, {"sha": "8baa67a8f9fcf91cddcd8568e36b7fe44996276b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -287,7 +287,7 @@ where\n     {\n         let pos = buf.position();\n         for block in &self.blocks {\n-            buf.emit_raw_bytes(block).unwrap();\n+            buf.emit_raw_bytes(block);\n         }\n         let num_bytes = self.blocks.len() * N;\n         LazyTable::from_position_and_encoded_size("}, {"sha": "096bf8cbc158a1a996b58d8979c3e0aa13cb7687", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -38,8 +38,8 @@ impl GraphIsCyclicCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for GraphIsCyclicCache {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        serialize::Encodable::encode(&(), s)\n+    fn encode(&self, s: &mut S) {\n+        serialize::Encodable::encode(&(), s);\n     }\n }\n "}, {"sha": "214b919e24d034243abbf60f9592b1710b452f67", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -207,27 +207,26 @@ pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n-) -> Result<(), E::Error> {\n+) {\n     match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            AllocDiscriminant::Alloc.encode(encoder)?;\n-            alloc.encode(encoder)?;\n+            AllocDiscriminant::Alloc.encode(encoder);\n+            alloc.encode(encoder);\n         }\n         GlobalAlloc::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            AllocDiscriminant::Fn.encode(encoder)?;\n-            fn_instance.encode(encoder)?;\n+            AllocDiscriminant::Fn.encode(encoder);\n+            fn_instance.encode(encoder);\n         }\n         GlobalAlloc::Static(did) => {\n             assert!(!tcx.is_thread_local_static(did));\n             // References to statics doesn't need to know about their allocations,\n             // just about its `DefId`.\n-            AllocDiscriminant::Static.encode(encoder)?;\n-            did.encode(encoder)?;\n+            AllocDiscriminant::Static.encode(encoder);\n+            did.encode(encoder);\n         }\n     }\n-    Ok(())\n }\n \n // Used to avoid infinite recursion when decoding cyclic allocations."}, {"sha": "581b3257c736f137d3f9011daf2f910848fc37cc", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -672,16 +672,16 @@ const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n impl<E: TyEncoder, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n     #[inline]\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) {\n         if E::CLEAR_CROSS_CRATE {\n-            return Ok(());\n+            return;\n         }\n \n         match *self {\n             ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(e),\n             ClearCrossCrate::Set(ref val) => {\n-                TAG_CLEAR_CROSS_CRATE_SET.encode(e)?;\n-                val.encode(e)\n+                TAG_CLEAR_CROSS_CRATE_SET.encode(e);\n+                val.encode(e);\n             }\n         }\n     }"}, {"sha": "9bc0cb1138ff1ac0ee39eac77283817bc4f402fa", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -56,9 +56,7 @@ impl PredecessorCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: serialize::Decoder> serialize::Decodable<D> for PredecessorCache {"}, {"sha": "4872a7835e3fadea4e2cc066be0997cb74f9cfa6", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -56,9 +56,7 @@ impl SwitchSourceCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for SwitchSourceCache {\n     #[inline]\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: serialize::Decoder> serialize::Decodable<D> for SwitchSourceCache {"}, {"sha": "f745e55307ae23a661b1e16528e84c65b0772c61", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -367,9 +367,7 @@ impl PostorderCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for PostorderCache {\n     #[inline]\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: serialize::Decoder> serialize::Decodable<D> for PostorderCache {"}, {"sha": "9a363914dc3326187796e34c70d39b897a57ed88", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -69,11 +69,7 @@ pub trait RefDecodable<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> {\n }\n \n /// Encode the given value or a previously cached shorthand.\n-pub fn encode_with_shorthand<'tcx, E, T, M>(\n-    encoder: &mut E,\n-    value: &T,\n-    cache: M,\n-) -> Result<(), E::Error>\n+pub fn encode_with_shorthand<'tcx, E, T, M>(encoder: &mut E, value: &T, cache: M)\n where\n     E: TyEncoder<I = TyCtxt<'tcx>>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n@@ -83,13 +79,14 @@ where\n {\n     let existing_shorthand = cache(encoder).get(value).copied();\n     if let Some(shorthand) = existing_shorthand {\n-        return encoder.emit_usize(shorthand);\n+        encoder.emit_usize(shorthand);\n+        return;\n     }\n \n     let variant = value.variant();\n \n     let start = encoder.position();\n-    variant.encode(encoder)?;\n+    variant.encode(encoder);\n     let len = encoder.position() - start;\n \n     // The shorthand encoding uses the same usize as the\n@@ -108,57 +105,55 @@ where\n     if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n         cache(encoder).insert(*value, shorthand);\n     }\n-\n-    Ok(())\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for Ty<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n+    fn encode(&self, e: &mut E) {\n+        encode_with_shorthand(e, self, TyEncoder::type_shorthands);\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E>\n     for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        self.bound_vars().encode(e)?;\n-        encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n+    fn encode(&self, e: &mut E) {\n+        self.bound_vars().encode(e);\n+        encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands);\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Predicate<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        self.kind().encode(e)\n+    fn encode(&self, e: &mut E) {\n+        self.kind().encode(e);\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Region<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        self.kind().encode(e)\n+    fn encode(&self, e: &mut E) {\n+        self.kind().encode(e);\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Const<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        self.0.0.encode(e)\n+    fn encode(&self, e: &mut E) {\n+        self.0.0.encode(e);\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ConstAllocation<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) {\n         self.inner().encode(e)\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AdtDef<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) {\n         self.0.0.encode(e)\n     }\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AllocId {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) {\n         e.encode_alloc_id(self)\n     }\n }\n@@ -508,9 +503,9 @@ macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n             impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Binder<'tcx, $t> {\n-                fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-                    self.bound_vars().encode(e)?;\n-                    self.as_ref().skip_binder().encode(e)\n+                fn encode(&self, e: &mut E) {\n+                    self.bound_vars().encode(e);\n+                    self.as_ref().skip_binder().encode(e);\n                 }\n             }\n             impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Binder<'tcx, $t> {"}, {"sha": "51e51a63fd043edec90d6f005cba2f2c049bdad1", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -140,9 +140,9 @@ impl<CTX> crate::ty::HashStable<CTX> for ScalarInt {\n }\n \n impl<S: Encoder> Encodable<S> for ScalarInt {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u128(self.data)?;\n-        s.emit_u8(self.size)\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u128(self.data);\n+        s.emit_u8(self.size);\n     }\n }\n "}, {"sha": "610234d45ce675519d2e95029b2ae6cf022626c3", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -87,7 +87,7 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n \n     fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>);\n \n-    fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n+    fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: FileEncoder) -> FileEncodeResult;\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n@@ -1466,8 +1466,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {\n-        self.on_disk_cache.as_ref().map_or(Ok(()), |c| c.serialize(self, encoder))\n+    pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n+        self.on_disk_cache.as_ref().map_or(Ok(0), |c| c.serialize(self, encoder))\n     }\n \n     /// If `true`, we should use lazy normalization for constants, otherwise"}, {"sha": "db3b5cfd180565e9094b471132459ccd6a9b18b0", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -117,8 +117,8 @@ impl<T: fmt::Debug> fmt::Debug for List<T> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for List<T> {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s);\n     }\n }\n "}, {"sha": "de30387ef4c5b3b58da08933ef33b6a4cc124f9a", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -217,7 +217,7 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n }\n \n impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for GenericArg<'tcx> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) {\n         self.unpack().encode(e)\n     }\n }"}, {"sha": "d06eb97798e73f59d2e325ae42773cd77580b9c9", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -2,6 +2,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]"}, {"sha": "c2c876f7f1a128756128d4707d90b9535f9aa33e", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 68, "deletions": 83, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -221,7 +221,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         *self.serialized_data.write() = None;\n     }\n \n-    fn serialize<'tcx>(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult {\n+    fn serialize<'tcx>(&self, tcx: TyCtxt<'tcx>, encoder: FileEncoder) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -259,27 +259,25 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             // Encode query results.\n             let mut query_result_index = EncodedDepNodeIndex::new();\n \n-            tcx.sess.time(\"encode_query_results\", || -> FileEncodeResult {\n+            tcx.sess.time(\"encode_query_results\", || {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n-                QueryCtxt::from_tcx(tcx).encode_query_results(enc, qri)\n-            })?;\n+                QueryCtxt::from_tcx(tcx).encode_query_results(enc, qri);\n+            });\n \n             // Encode side effects.\n             let side_effects_index: EncodedDepNodeIndex = self\n                 .current_side_effects\n                 .borrow()\n                 .iter()\n-                .map(\n-                    |(dep_node_index, side_effects)| -> Result<_, <FileEncoder as Encoder>::Error> {\n-                        let pos = AbsoluteBytePos::new(encoder.position());\n-                        let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                        encoder.encode_tagged(dep_node_index, side_effects)?;\n+                .map(|(dep_node_index, side_effects)| {\n+                    let pos = AbsoluteBytePos::new(encoder.position());\n+                    let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                    encoder.encode_tagged(dep_node_index, side_effects);\n \n-                        Ok((dep_node_index, pos))\n-                    },\n-                )\n-                .collect::<Result<_, _>>()?;\n+                    (dep_node_index, pos)\n+                })\n+                .collect();\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n@@ -296,7 +294,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                         let id = encoder.interpret_allocs[idx];\n                         let pos = encoder.position() as u32;\n                         interpret_alloc_index.push(pos);\n-                        interpret::specialized_encode_alloc_id(&mut encoder, tcx, id)?;\n+                        interpret::specialized_encode_alloc_id(&mut encoder, tcx, id);\n                     }\n                     n = new_n;\n                 }\n@@ -312,23 +310,21 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n \n             hygiene_encode_context.encode(\n                 &mut encoder,\n-                |encoder, index, ctxt_data| -> FileEncodeResult {\n+                |encoder, index, ctxt_data| {\n                     let pos = AbsoluteBytePos::new(encoder.position());\n-                    encoder.encode_tagged(TAG_SYNTAX_CONTEXT, ctxt_data)?;\n+                    encoder.encode_tagged(TAG_SYNTAX_CONTEXT, ctxt_data);\n                     syntax_contexts.insert(index, pos);\n-                    Ok(())\n                 },\n-                |encoder, expn_id, data, hash| -> FileEncodeResult {\n+                |encoder, expn_id, data, hash| {\n                     if expn_id.krate == LOCAL_CRATE {\n                         let pos = AbsoluteBytePos::new(encoder.position());\n-                        encoder.encode_tagged(TAG_EXPN_DATA, data)?;\n+                        encoder.encode_tagged(TAG_EXPN_DATA, data);\n                         expn_data.insert(hash, pos);\n                     } else {\n                         foreign_expn_data.insert(hash, expn_id.local_id.as_u32());\n                     }\n-                    Ok(())\n                 },\n-            )?;\n+            );\n \n             // `Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n@@ -343,16 +339,16 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                     expn_data,\n                     foreign_expn_data,\n                 },\n-            )?;\n+            );\n \n             // Encode the position of the footer as the last 8 bytes of the\n             // file so we know where to look for it.\n-            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n+            IntEncodedWithFixedSize(footer_pos).encode(&mut encoder.encoder);\n \n             // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n             // of the footer must be the last thing in the data stream.\n \n-            Ok(())\n+            encoder.finish()\n         })\n     }\n }\n@@ -825,7 +821,7 @@ impl OpaqueEncoder for FileEncoder {\n /// An encoder that can write to the incremental compilation cache.\n pub struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n-    encoder: &'a mut E,\n+    encoder: E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::PredicateKind<'tcx>, usize>,\n     interpret_allocs: FxIndexSet<interpret::AllocId>,\n@@ -836,7 +832,7 @@ pub struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -847,48 +843,44 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(\n-        &mut self,\n-        tag: T,\n-        value: &V,\n-    ) -> Result<(), E::Error> {\n+    fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(&mut self, tag: T, value: &V) {\n         let start_pos = self.position();\n \n-        tag.encode(self)?;\n-        value.encode(self)?;\n+        tag.encode(self);\n+        value.encode(self);\n \n         let end_pos = self.position();\n-        ((end_pos - start_pos) as u64).encode(self)\n+        ((end_pos - start_pos) as u64).encode(self);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for SyntaxContext\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        rustc_span::hygiene::raw_encode_syntax_context(*self, s.hygiene_context, s)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, s.hygiene_context, s);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for ExpnId\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         s.hygiene_context.schedule_expn_data_for_encoding(*self);\n-        self.expn_hash().encode(s)\n+        self.expn_hash().encode(s);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for Span\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n         let span_data = self.data_untracked();\n-        span_data.ctxt.encode(s)?;\n-        span_data.parent.encode(s)?;\n+        span_data.ctxt.encode(s);\n+        span_data.parent.encode(s);\n \n         if span_data.is_dummy() {\n             return TAG_PARTIAL_SPAN.encode(s);\n@@ -897,10 +889,10 @@ where\n         if let Some(parent) = span_data.parent {\n             let enclosing = s.tcx.definitions_untracked().def_span(parent).data_untracked();\n             if enclosing.contains(span_data) {\n-                TAG_RELATIVE_SPAN.encode(s)?;\n-                (span_data.lo - enclosing.lo).to_u32().encode(s)?;\n-                (span_data.hi - enclosing.lo).to_u32().encode(s)?;\n-                return Ok(());\n+                TAG_RELATIVE_SPAN.encode(s);\n+                (span_data.lo - enclosing.lo).to_u32().encode(s);\n+                (span_data.hi - enclosing.lo).to_u32().encode(s);\n+                return;\n             }\n         }\n \n@@ -920,17 +912,17 @@ where\n \n         let source_file_index = s.source_file_index(file_lo);\n \n-        TAG_FULL_SPAN.encode(s)?;\n-        source_file_index.encode(s)?;\n-        line_lo.encode(s)?;\n-        col_lo.encode(s)?;\n-        len.encode(s)\n+        TAG_FULL_SPAN.encode(s);\n+        source_file_index.encode(s);\n+        line_lo.encode(s);\n+        col_lo.encode(s);\n+        len.encode(s);\n     }\n }\n \n impl<'a, 'tcx, E> TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n     type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n@@ -944,54 +936,55 @@ where\n     fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize> {\n         &mut self.predicate_shorthands\n     }\n-    fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+    fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) {\n         let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n \n-        index.encode(self)\n+        index.encode(self);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for CrateNum\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        s.tcx.stable_crate_id(*self).encode(s)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n+        s.tcx.stable_crate_id(*self).encode(s);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefId\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        s.tcx.def_path_hash(*self).encode(s)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) {\n+        s.tcx.def_path_hash(*self).encode(s);\n     }\n }\n \n impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefIndex\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx, E>) {\n         bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         #[inline]\n-        $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n+        $(fn $name(&mut self, value: $ty) {\n             self.encoder.$name(value)\n         })*\n     }\n }\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + OpaqueEncoder,\n+    E: OpaqueEncoder,\n {\n-    type Error = E::Error;\n+    type Ok = E::Ok;\n+    type Err = E::Err;\n \n     encoder_methods! {\n         emit_usize(usize);\n@@ -1015,24 +1008,27 @@ where\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n+\n+    fn finish(self) -> Result<E::Ok, E::Err> {\n+        self.encoder.finish()\n+    }\n }\n \n // This ensures that the `Encodable<opaque::FileEncoder>::encode` specialization for byte slices\n // is used when a `CacheEncoder` having an `opaque::FileEncoder` is passed to `Encodable::encode`.\n // Unfortunately, we have to manually opt into specializations this way, given how `CacheEncoder`\n // and the encoding traits currently work.\n impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, FileEncoder>> for [u8] {\n-    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, FileEncoder>) -> FileEncodeResult {\n-        self.encode(e.encoder)\n+    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, FileEncoder>) {\n+        self.encode(&mut e.encoder);\n     }\n }\n \n pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n     tcx: CTX,\n     encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,\n     query_result_index: &mut EncodedDepNodeIndex,\n-) -> FileEncodeResult\n-where\n+) where\n     CTX: QueryContext + 'tcx,\n     Q: super::QueryDescription<CTX>,\n     Q::Value: Encodable<CacheEncoder<'a, 'tcx, FileEncoder>>,\n@@ -1044,11 +1040,7 @@ where\n \n     assert!(Q::query_state(tcx).all_inactive());\n     let cache = Q::query_cache(tcx);\n-    let mut res = Ok(());\n     cache.iter(&mut |key, value, dep_node| {\n-        if res.is_err() {\n-            return;\n-        }\n         if Q::cache_on_disk(*tcx.dep_context(), &key) {\n             let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n@@ -1057,14 +1049,7 @@ where\n \n             // Encode the type check tables with the `SerializedDepNodeIndex`\n             // as tag.\n-            match encoder.encode_tagged(dep_node, value) {\n-                Ok(()) => {}\n-                Err(e) => {\n-                    res = Err(e);\n-                }\n-            }\n+            encoder.encode_tagged(dep_node, value);\n         }\n     });\n-\n-    res\n }"}, {"sha": "87aedc6542d8d44a369dacbf183e274605e4a158", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -142,22 +142,20 @@ impl<'tcx> QueryCtxt<'tcx> {\n         self,\n         encoder: &mut on_disk_cache::CacheEncoder<'_, 'tcx, opaque::FileEncoder>,\n         query_result_index: &mut on_disk_cache::EncodedDepNodeIndex,\n-    ) -> opaque::FileEncodeResult {\n+    ) {\n         macro_rules! encode_queries {\n             ($($query:ident,)*) => {\n                 $(\n                     on_disk_cache::encode_query_results::<_, super::queries::$query<'_>>(\n                         self,\n                         encoder,\n                         query_result_index\n-                    )?;\n+                    );\n                 )*\n             }\n         }\n \n         rustc_cached_queries!(encode_queries!);\n-\n-        Ok(())\n     }\n \n     pub fn try_print_query_stack("}, {"sha": "5a32d7075db06fd315f7ed1aa46f1b2c5a20c161", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -842,7 +842,7 @@ impl<K: DepKind> DepGraph<K> {\n         if let Some(data) = &self.data {\n             data.current.encoder.steal().finish(profiler)\n         } else {\n-            Ok(())\n+            Ok(0)\n         }\n     }\n "}, {"sha": "7fde9c0119b855e30c588e376ec148e240d08523", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n-use rustc_serialize::{Decodable, Decoder, Encodable};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use smallvec::SmallVec;\n use std::convert::TryInto;\n \n@@ -166,7 +166,6 @@ struct EncoderState<K: DepKind> {\n     encoder: FileEncoder,\n     total_node_count: usize,\n     total_edge_count: usize,\n-    result: FileEncodeResult,\n     stats: Option<FxHashMap<K, Stat<K>>>,\n }\n \n@@ -176,7 +175,6 @@ impl<K: DepKind> EncoderState<K> {\n             encoder,\n             total_edge_count: 0,\n             total_node_count: 0,\n-            result: Ok(()),\n             stats: record_stats.then(FxHashMap::default),\n         }\n     }\n@@ -208,29 +206,28 @@ impl<K: DepKind> EncoderState<K> {\n         }\n \n         let encoder = &mut self.encoder;\n-        if self.result.is_ok() {\n-            self.result = node.encode(encoder);\n-        }\n+        node.encode(encoder);\n         index\n     }\n \n     fn finish(self, profiler: &SelfProfilerRef) -> FileEncodeResult {\n-        let Self { mut encoder, total_node_count, total_edge_count, result, stats: _ } = self;\n-        let () = result?;\n+        let Self { mut encoder, total_node_count, total_edge_count, stats: _ } = self;\n \n         let node_count = total_node_count.try_into().unwrap();\n         let edge_count = total_edge_count.try_into().unwrap();\n \n         debug!(?node_count, ?edge_count);\n         debug!(\"position: {:?}\", encoder.position());\n-        IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n-        IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n+        IntEncodedWithFixedSize(node_count).encode(&mut encoder);\n+        IntEncodedWithFixedSize(edge_count).encode(&mut encoder);\n         debug!(\"position: {:?}\", encoder.position());\n         // Drop the encoder so that nothing is written after the counts.\n-        let result = encoder.flush();\n-        // FIXME(rylev): we hardcode the dep graph file name so we don't need a dependency on\n-        // rustc_incremental just for that.\n-        profiler.artifact_size(\"dep_graph\", \"dep-graph.bin\", encoder.position() as u64);\n+        let result = encoder.finish();\n+        if let Ok(position) = result {\n+            // FIXME(rylev): we hardcode the dep graph file name so we\n+            // don't need a dependency on rustc_incremental just for that.\n+            profiler.artifact_size(\"dep_graph\", \"dep-graph.bin\", position as u64);\n+        }\n         result\n     }\n }"}, {"sha": "5e53f0b104dfc6f398bb7f5670758a3f7cd3adc4", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -10,9 +10,9 @@ use std::sync::Arc;\n use smallvec::{Array, SmallVec};\n \n impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         let slice: &[A::Item] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n \n@@ -24,12 +24,11 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(self.len())?;\n+    fn encode(&self, s: &mut S) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?;\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n@@ -41,12 +40,11 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(self.len())?;\n+    fn encode(&self, s: &mut S) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?;\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n@@ -62,13 +60,12 @@ where\n     K: Encodable<S> + PartialEq + Ord,\n     V: Encodable<S>,\n {\n-    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n-        e.emit_usize(self.len())?;\n+    fn encode(&self, e: &mut S) {\n+        e.emit_usize(self.len());\n         for (key, val) in self.iter() {\n-            key.encode(e)?;\n-            val.encode(e)?;\n+            key.encode(e);\n+            val.encode(e);\n         }\n-        Ok(())\n     }\n }\n \n@@ -93,12 +90,11 @@ impl<S: Encoder, T> Encodable<S> for BTreeSet<T>\n where\n     T: Encodable<S> + PartialEq + Ord,\n {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(self.len())?;\n+    fn encode(&self, s: &mut S) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?;\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n@@ -122,13 +118,12 @@ where\n     V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_usize(self.len())?;\n+    fn encode(&self, e: &mut E) {\n+        e.emit_usize(self.len());\n         for (key, val) in self.iter() {\n-            key.encode(e)?;\n-            val.encode(e)?;\n+            key.encode(e);\n+            val.encode(e);\n         }\n-        Ok(())\n     }\n }\n \n@@ -156,12 +151,11 @@ where\n     T: Encodable<E> + Eq,\n     S: BuildHasher,\n {\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_usize(self.len())?;\n+    fn encode(&self, s: &mut E) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?;\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n@@ -187,13 +181,12 @@ where\n     V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_usize(self.len())?;\n+    fn encode(&self, e: &mut E) {\n+        e.emit_usize(self.len());\n         for (key, val) in self.iter() {\n-            key.encode(e)?;\n-            val.encode(e)?;\n+            key.encode(e);\n+            val.encode(e);\n         }\n-        Ok(())\n     }\n }\n \n@@ -221,12 +214,11 @@ where\n     T: Encodable<E> + Hash + Eq,\n     S: BuildHasher,\n {\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_usize(self.len())?;\n+    fn encode(&self, s: &mut E) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?;\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n@@ -247,9 +239,9 @@ where\n }\n \n impl<E: Encoder, T: Encodable<E>> Encodable<E> for Rc<[T]> {\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) {\n         let slice: &[T] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n \n@@ -261,9 +253,9 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<[T]> {\n }\n \n impl<E: Encoder, T: Encodable<E>> Encodable<E> for Arc<[T]> {\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) {\n         let slice: &[T] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n "}, {"sha": "b2dbf937eb75a7155448945ebb2c3e6c7e03e10a", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 130, "deletions": 110, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -11,8 +11,6 @@ use std::ptr;\n // Encoder\n // -----------------------------------------------------------------------------\n \n-pub type EncodeResult = Result<(), !>;\n-\n pub struct Encoder {\n     pub data: Vec<u8>,\n }\n@@ -22,10 +20,6 @@ impl Encoder {\n         Encoder { data: vec![] }\n     }\n \n-    pub fn into_inner(self) -> Vec<u8> {\n-        self.data\n-    }\n-\n     #[inline]\n     pub fn position(&self) -> usize {\n         self.data.len()\n@@ -49,8 +43,6 @@ macro_rules! write_leb128 {\n             let encoded = leb128::$fun(buf, $value);\n             $enc.data.set_len(old_len + encoded.len());\n         }\n-\n-        Ok(())\n     }};\n }\n \n@@ -62,108 +54,109 @@ macro_rules! write_leb128 {\n const STR_SENTINEL: u8 = 0xC1;\n \n impl serialize::Encoder for Encoder {\n-    type Error = !;\n+    type Ok = Vec<u8>;\n+    type Err = !;\n \n     #[inline]\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n+    fn emit_usize(&mut self, v: usize) {\n         write_leb128!(self, v, usize, write_usize_leb128)\n     }\n \n     #[inline]\n-    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        write_leb128!(self, v, u128, write_u128_leb128)\n+    fn emit_u128(&mut self, v: u128) {\n+        write_leb128!(self, v, u128, write_u128_leb128);\n     }\n \n     #[inline]\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        write_leb128!(self, v, u64, write_u64_leb128)\n+    fn emit_u64(&mut self, v: u64) {\n+        write_leb128!(self, v, u64, write_u64_leb128);\n     }\n \n     #[inline]\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        write_leb128!(self, v, u32, write_u32_leb128)\n+    fn emit_u32(&mut self, v: u32) {\n+        write_leb128!(self, v, u32, write_u32_leb128);\n     }\n \n     #[inline]\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n+    fn emit_u16(&mut self, v: u16) {\n         self.data.extend_from_slice(&v.to_le_bytes());\n-        Ok(())\n     }\n \n     #[inline]\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n+    fn emit_u8(&mut self, v: u8) {\n         self.data.push(v);\n-        Ok(())\n     }\n \n     #[inline]\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n+    fn emit_isize(&mut self, v: isize) {\n         write_leb128!(self, v, isize, write_isize_leb128)\n     }\n \n     #[inline]\n-    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n+    fn emit_i128(&mut self, v: i128) {\n         write_leb128!(self, v, i128, write_i128_leb128)\n     }\n \n     #[inline]\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n+    fn emit_i64(&mut self, v: i64) {\n         write_leb128!(self, v, i64, write_i64_leb128)\n     }\n \n     #[inline]\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n+    fn emit_i32(&mut self, v: i32) {\n         write_leb128!(self, v, i32, write_i32_leb128)\n     }\n \n     #[inline]\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n+    fn emit_i16(&mut self, v: i16) {\n         self.data.extend_from_slice(&v.to_le_bytes());\n-        Ok(())\n     }\n \n     #[inline]\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        self.emit_u8(v as u8)\n+    fn emit_i8(&mut self, v: i8) {\n+        self.emit_u8(v as u8);\n     }\n \n     #[inline]\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        self.emit_u8(if v { 1 } else { 0 })\n+    fn emit_bool(&mut self, v: bool) {\n+        self.emit_u8(if v { 1 } else { 0 });\n     }\n \n     #[inline]\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+    fn emit_f64(&mut self, v: f64) {\n         let as_u64: u64 = v.to_bits();\n-        self.emit_u64(as_u64)\n+        self.emit_u64(as_u64);\n     }\n \n     #[inline]\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+    fn emit_f32(&mut self, v: f32) {\n         let as_u32: u32 = v.to_bits();\n-        self.emit_u32(as_u32)\n+        self.emit_u32(as_u32);\n     }\n \n     #[inline]\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        self.emit_u32(v as u32)\n+    fn emit_char(&mut self, v: char) {\n+        self.emit_u32(v as u32);\n     }\n \n     #[inline]\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        self.emit_usize(v.len())?;\n-        self.emit_raw_bytes(v.as_bytes())?;\n-        self.emit_u8(STR_SENTINEL)\n+    fn emit_str(&mut self, v: &str) {\n+        self.emit_usize(v.len());\n+        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_u8(STR_SENTINEL);\n     }\n \n     #[inline]\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> EncodeResult {\n+    fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n-        Ok(())\n+    }\n+\n+    fn finish(self) -> Result<Self::Ok, Self::Err> {\n+        Ok(self.data)\n     }\n }\n \n-pub type FileEncodeResult = Result<(), io::Error>;\n+pub type FileEncodeResult = Result<usize, io::Error>;\n \n // `FileEncoder` encodes data to file via fixed-size buffer.\n //\n@@ -182,6 +175,9 @@ pub struct FileEncoder {\n     buffered: usize,\n     flushed: usize,\n     file: File,\n+    // This is used to implement delayed error handling, as described in the\n+    // comment on `trait Encoder`.\n+    res: Result<(), io::Error>,\n }\n \n impl FileEncoder {\n@@ -202,7 +198,13 @@ impl FileEncoder {\n \n         let file = File::create(path)?;\n \n-        Ok(FileEncoder { buf: Box::new_uninit_slice(capacity), buffered: 0, flushed: 0, file })\n+        Ok(FileEncoder {\n+            buf: Box::new_uninit_slice(capacity),\n+            buffered: 0,\n+            flushed: 0,\n+            file,\n+            res: Ok(()),\n+        })\n     }\n \n     #[inline]\n@@ -212,7 +214,7 @@ impl FileEncoder {\n         self.flushed + self.buffered\n     }\n \n-    pub fn flush(&mut self) -> FileEncodeResult {\n+    pub fn flush(&mut self) {\n         // This is basically a copy of `BufWriter::flush`. If `BufWriter` ever\n         // offers a raw buffer access API, we can use it, and remove this.\n \n@@ -267,6 +269,12 @@ impl FileEncoder {\n             }\n         }\n \n+        // If we've already had an error, do nothing. It'll get reported after\n+        // `finish` is called.\n+        if self.res.is_err() {\n+            return;\n+        }\n+\n         let mut guard = BufGuard::new(\n             unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[..self.buffered]) },\n             &mut self.buffered,\n@@ -276,18 +284,20 @@ impl FileEncoder {\n         while !guard.done() {\n             match self.file.write(guard.remaining()) {\n                 Ok(0) => {\n-                    return Err(io::Error::new(\n+                    self.res = Err(io::Error::new(\n                         io::ErrorKind::WriteZero,\n                         \"failed to write the buffered data\",\n                     ));\n+                    return;\n                 }\n                 Ok(n) => guard.consume(n),\n                 Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n+                Err(e) => {\n+                    self.res = Err(e);\n+                    return;\n+                }\n             }\n         }\n-\n-        Ok(())\n     }\n \n     #[inline]\n@@ -296,14 +306,14 @@ impl FileEncoder {\n     }\n \n     #[inline]\n-    fn write_one(&mut self, value: u8) -> FileEncodeResult {\n+    fn write_one(&mut self, value: u8) {\n         // We ensure this during `FileEncoder` construction.\n         debug_assert!(self.capacity() >= 1);\n \n         let mut buffered = self.buffered;\n \n         if std::intrinsics::unlikely(buffered >= self.capacity()) {\n-            self.flush()?;\n+            self.flush();\n             buffered = 0;\n         }\n \n@@ -314,20 +324,18 @@ impl FileEncoder {\n         }\n \n         self.buffered = buffered + 1;\n-\n-        Ok(())\n     }\n \n     #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> FileEncodeResult {\n+    fn write_all(&mut self, buf: &[u8]) {\n         let capacity = self.capacity();\n         let buf_len = buf.len();\n \n         if std::intrinsics::likely(buf_len <= capacity) {\n             let mut buffered = self.buffered;\n \n             if std::intrinsics::unlikely(buf_len > capacity - buffered) {\n-                self.flush()?;\n+                self.flush();\n                 buffered = 0;\n             }\n \n@@ -340,16 +348,20 @@ impl FileEncoder {\n             }\n \n             self.buffered = buffered + buf_len;\n-\n-            Ok(())\n         } else {\n-            self.write_all_unbuffered(buf)\n+            self.write_all_unbuffered(buf);\n         }\n     }\n \n-    fn write_all_unbuffered(&mut self, mut buf: &[u8]) -> FileEncodeResult {\n+    fn write_all_unbuffered(&mut self, mut buf: &[u8]) {\n+        // If we've already had an error, do nothing. It'll get reported after\n+        // `finish` is called.\n+        if self.res.is_err() {\n+            return;\n+        }\n+\n         if self.buffered > 0 {\n-            self.flush()?;\n+            self.flush();\n         }\n \n         // This is basically a copy of `Write::write_all` but also updates our\n@@ -359,26 +371,30 @@ impl FileEncoder {\n         while !buf.is_empty() {\n             match self.file.write(buf) {\n                 Ok(0) => {\n-                    return Err(io::Error::new(\n+                    self.res = Err(io::Error::new(\n                         io::ErrorKind::WriteZero,\n                         \"failed to write whole buffer\",\n                     ));\n+                    return;\n                 }\n                 Ok(n) => {\n                     buf = &buf[n..];\n                     self.flushed += n;\n                 }\n                 Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n+                Err(e) => {\n+                    self.res = Err(e);\n+                    return;\n+                }\n             }\n         }\n-\n-        Ok(())\n     }\n }\n \n impl Drop for FileEncoder {\n     fn drop(&mut self) {\n+        // Likely to be a no-op, because `finish` should have been called and\n+        // it also flushes. But do it just in case.\n         let _result = self.flush();\n     }\n }\n@@ -394,7 +410,7 @@ macro_rules! file_encoder_write_leb128 {\n \n         // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n         if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > $enc.capacity()) {\n-            $enc.flush()?;\n+            $enc.flush();\n             buffered = 0;\n         }\n \n@@ -406,106 +422,112 @@ macro_rules! file_encoder_write_leb128 {\n \n         let encoded = leb128::$fun(buf, $value);\n         $enc.buffered = buffered + encoded.len();\n-\n-        Ok(())\n     }};\n }\n \n impl serialize::Encoder for FileEncoder {\n-    type Error = io::Error;\n+    type Ok = usize;\n+    type Err = io::Error;\n \n     #[inline]\n-    fn emit_usize(&mut self, v: usize) -> FileEncodeResult {\n+    fn emit_usize(&mut self, v: usize) {\n         file_encoder_write_leb128!(self, v, usize, write_usize_leb128)\n     }\n \n     #[inline]\n-    fn emit_u128(&mut self, v: u128) -> FileEncodeResult {\n+    fn emit_u128(&mut self, v: u128) {\n         file_encoder_write_leb128!(self, v, u128, write_u128_leb128)\n     }\n \n     #[inline]\n-    fn emit_u64(&mut self, v: u64) -> FileEncodeResult {\n+    fn emit_u64(&mut self, v: u64) {\n         file_encoder_write_leb128!(self, v, u64, write_u64_leb128)\n     }\n \n     #[inline]\n-    fn emit_u32(&mut self, v: u32) -> FileEncodeResult {\n+    fn emit_u32(&mut self, v: u32) {\n         file_encoder_write_leb128!(self, v, u32, write_u32_leb128)\n     }\n \n     #[inline]\n-    fn emit_u16(&mut self, v: u16) -> FileEncodeResult {\n-        self.write_all(&v.to_le_bytes())\n+    fn emit_u16(&mut self, v: u16) {\n+        self.write_all(&v.to_le_bytes());\n     }\n \n     #[inline]\n-    fn emit_u8(&mut self, v: u8) -> FileEncodeResult {\n-        self.write_one(v)\n+    fn emit_u8(&mut self, v: u8) {\n+        self.write_one(v);\n     }\n \n     #[inline]\n-    fn emit_isize(&mut self, v: isize) -> FileEncodeResult {\n+    fn emit_isize(&mut self, v: isize) {\n         file_encoder_write_leb128!(self, v, isize, write_isize_leb128)\n     }\n \n     #[inline]\n-    fn emit_i128(&mut self, v: i128) -> FileEncodeResult {\n+    fn emit_i128(&mut self, v: i128) {\n         file_encoder_write_leb128!(self, v, i128, write_i128_leb128)\n     }\n \n     #[inline]\n-    fn emit_i64(&mut self, v: i64) -> FileEncodeResult {\n+    fn emit_i64(&mut self, v: i64) {\n         file_encoder_write_leb128!(self, v, i64, write_i64_leb128)\n     }\n \n     #[inline]\n-    fn emit_i32(&mut self, v: i32) -> FileEncodeResult {\n+    fn emit_i32(&mut self, v: i32) {\n         file_encoder_write_leb128!(self, v, i32, write_i32_leb128)\n     }\n \n     #[inline]\n-    fn emit_i16(&mut self, v: i16) -> FileEncodeResult {\n-        self.write_all(&v.to_le_bytes())\n+    fn emit_i16(&mut self, v: i16) {\n+        self.write_all(&v.to_le_bytes());\n     }\n \n     #[inline]\n-    fn emit_i8(&mut self, v: i8) -> FileEncodeResult {\n-        self.emit_u8(v as u8)\n+    fn emit_i8(&mut self, v: i8) {\n+        self.emit_u8(v as u8);\n     }\n \n     #[inline]\n-    fn emit_bool(&mut self, v: bool) -> FileEncodeResult {\n-        self.emit_u8(if v { 1 } else { 0 })\n+    fn emit_bool(&mut self, v: bool) {\n+        self.emit_u8(if v { 1 } else { 0 });\n     }\n \n     #[inline]\n-    fn emit_f64(&mut self, v: f64) -> FileEncodeResult {\n+    fn emit_f64(&mut self, v: f64) {\n         let as_u64: u64 = v.to_bits();\n-        self.emit_u64(as_u64)\n+        self.emit_u64(as_u64);\n     }\n \n     #[inline]\n-    fn emit_f32(&mut self, v: f32) -> FileEncodeResult {\n+    fn emit_f32(&mut self, v: f32) {\n         let as_u32: u32 = v.to_bits();\n-        self.emit_u32(as_u32)\n+        self.emit_u32(as_u32);\n     }\n \n     #[inline]\n-    fn emit_char(&mut self, v: char) -> FileEncodeResult {\n-        self.emit_u32(v as u32)\n+    fn emit_char(&mut self, v: char) {\n+        self.emit_u32(v as u32);\n     }\n \n     #[inline]\n-    fn emit_str(&mut self, v: &str) -> FileEncodeResult {\n-        self.emit_usize(v.len())?;\n-        self.emit_raw_bytes(v.as_bytes())?;\n-        self.emit_u8(STR_SENTINEL)\n+    fn emit_str(&mut self, v: &str) {\n+        self.emit_usize(v.len());\n+        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_u8(STR_SENTINEL);\n     }\n \n     #[inline]\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n-        self.write_all(s)\n+    fn emit_raw_bytes(&mut self, s: &[u8]) {\n+        self.write_all(s);\n+    }\n+\n+    fn finish(mut self) -> Result<usize, io::Error> {\n+        self.flush();\n+\n+        let res = std::mem::replace(&mut self.res, Ok(()));\n+        res.map(|()| self.position())\n     }\n }\n \n@@ -667,16 +689,16 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n // Specialize encoding byte slices. This specialization also applies to encoding `Vec<u8>`s, etc.,\n // since the default implementations call `encode` on their slices internally.\n impl serialize::Encodable<Encoder> for [u8] {\n-    fn encode(&self, e: &mut Encoder) -> EncodeResult {\n-        serialize::Encoder::emit_usize(e, self.len())?;\n-        e.emit_raw_bytes(self)\n+    fn encode(&self, e: &mut Encoder) {\n+        serialize::Encoder::emit_usize(e, self.len());\n+        e.emit_raw_bytes(self);\n     }\n }\n \n impl serialize::Encodable<FileEncoder> for [u8] {\n-    fn encode(&self, e: &mut FileEncoder) -> FileEncodeResult {\n-        serialize::Encoder::emit_usize(e, self.len())?;\n-        e.emit_raw_bytes(self)\n+    fn encode(&self, e: &mut FileEncoder) {\n+        serialize::Encoder::emit_usize(e, self.len());\n+        e.emit_raw_bytes(self);\n     }\n }\n \n@@ -698,23 +720,21 @@ impl IntEncodedWithFixedSize {\n \n impl serialize::Encodable<Encoder> for IntEncodedWithFixedSize {\n     #[inline]\n-    fn encode(&self, e: &mut Encoder) -> EncodeResult {\n+    fn encode(&self, e: &mut Encoder) {\n         let _start_pos = e.position();\n-        e.emit_raw_bytes(&self.0.to_le_bytes())?;\n+        e.emit_raw_bytes(&self.0.to_le_bytes());\n         let _end_pos = e.position();\n         debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-        Ok(())\n     }\n }\n \n impl serialize::Encodable<FileEncoder> for IntEncodedWithFixedSize {\n     #[inline]\n-    fn encode(&self, e: &mut FileEncoder) -> FileEncodeResult {\n+    fn encode(&self, e: &mut FileEncoder) {\n         let _start_pos = e.position();\n-        e.emit_raw_bytes(&self.0.to_le_bytes())?;\n+        e.emit_raw_bytes(&self.0.to_le_bytes());\n         let _end_pos = e.position();\n         debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-        Ok(())\n     }\n }\n "}, {"sha": "98bb18581f517f03a0d7d6b48f4bc6001e021232", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 83, "deletions": 73, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -11,36 +11,47 @@ use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+/// A note about error handling.\n+///\n+/// Encoders may be fallible, but in practice failure is rare and there are so\n+/// many nested calls that typical Rust error handling (via `Result` and `?`)\n+/// is pervasive and has non-trivial cost. Instead, impls of this trait must\n+/// implement a delayed error handling strategy. If a failure occurs, they\n+/// should record this internally, and all subsequent encoding operations can\n+/// be processed or ignored, whichever is appropriate. Then when `finish()` is\n+/// called, an error result should be returned to indicate the failure. If no\n+/// failures occurred, then `finish()` should return a success result.\n pub trait Encoder {\n-    type Error;\n+    type Ok;\n+    type Err;\n \n     // Primitive types:\n-    fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n-    fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n-    fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n-    fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n-    fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n-    fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n-    fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n-    fn emit_i128(&mut self, v: i128) -> Result<(), Self::Error>;\n-    fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n-    fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n-    fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n-    fn emit_i8(&mut self, v: i8) -> Result<(), Self::Error>;\n-    fn emit_bool(&mut self, v: bool) -> Result<(), Self::Error>;\n-    fn emit_f64(&mut self, v: f64) -> Result<(), Self::Error>;\n-    fn emit_f32(&mut self, v: f32) -> Result<(), Self::Error>;\n-    fn emit_char(&mut self, v: char) -> Result<(), Self::Error>;\n-    fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>;\n+    fn emit_usize(&mut self, v: usize);\n+    fn emit_u128(&mut self, v: u128);\n+    fn emit_u64(&mut self, v: u64);\n+    fn emit_u32(&mut self, v: u32);\n+    fn emit_u16(&mut self, v: u16);\n+    fn emit_u8(&mut self, v: u8);\n+    fn emit_isize(&mut self, v: isize);\n+    fn emit_i128(&mut self, v: i128);\n+    fn emit_i64(&mut self, v: i64);\n+    fn emit_i32(&mut self, v: i32);\n+    fn emit_i16(&mut self, v: i16);\n+    fn emit_i8(&mut self, v: i8);\n+    fn emit_bool(&mut self, v: bool);\n+    fn emit_f64(&mut self, v: f64);\n+    fn emit_f32(&mut self, v: f32);\n+    fn emit_char(&mut self, v: char);\n+    fn emit_str(&mut self, v: &str);\n+    fn emit_raw_bytes(&mut self, s: &[u8]);\n \n     // Convenience for the derive macro:\n-    fn emit_enum_variant<F>(&mut self, v_id: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_enum_variant<F>(&mut self, v_id: usize, f: F)\n     where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n+        F: FnOnce(&mut Self),\n     {\n-        self.emit_usize(v_id)?;\n-        f(self)\n+        self.emit_usize(v_id);\n+        f(self);\n     }\n \n     // We put the field index in a const generic to allow the emit_usize to be\n@@ -50,9 +61,12 @@ pub trait Encoder {\n     // optimization that would otherwise be necessary here, likely due to the\n     // multiple levels of inlining and const-prop that are needed.\n     #[inline]\n-    fn emit_fieldless_enum_variant<const ID: usize>(&mut self) -> Result<(), Self::Error> {\n+    fn emit_fieldless_enum_variant<const ID: usize>(&mut self) {\n         self.emit_usize(ID)\n     }\n+\n+    // Consume the encoder, getting the result.\n+    fn finish(self) -> Result<Self::Ok, Self::Err>;\n }\n \n // Note: all the methods in this trait are infallible, which may be surprising.\n@@ -95,7 +109,7 @@ pub trait Decoder {\n /// * `TyEncodable` should be used for types that are only serialized in crate\n ///   metadata or the incremental cache. This is most types in `rustc_middle`.\n pub trait Encodable<S: Encoder> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n+    fn encode(&self, s: &mut S);\n }\n \n /// Trait for types that can be deserialized\n@@ -117,8 +131,8 @@ macro_rules! direct_serialize_impls {\n     ($($ty:ident $emit_method:ident $read_method:ident),*) => {\n         $(\n             impl<S: Encoder> Encodable<S> for $ty {\n-                fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-                    s.$emit_method(*self)\n+                fn encode(&self, s: &mut S) {\n+                    s.$emit_method(*self);\n                 }\n             }\n \n@@ -138,12 +152,14 @@ direct_serialize_impls! {\n     u32 emit_u32 read_u32,\n     u64 emit_u64 read_u64,\n     u128 emit_u128 read_u128,\n+\n     isize emit_isize read_isize,\n     i8 emit_i8 read_i8,\n     i16 emit_i16 read_i16,\n     i32 emit_i32 read_i32,\n     i64 emit_i64 read_i64,\n     i128 emit_i128 read_i128,\n+\n     f32 emit_f32 read_f32,\n     f64 emit_f64 read_f64,\n     bool emit_bool read_bool,\n@@ -154,14 +170,14 @@ impl<S: Encoder, T: ?Sized> Encodable<S> for &T\n where\n     T: Encodable<S>,\n {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n impl<S: Encoder> Encodable<S> for ! {\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        unreachable!()\n+    fn encode(&self, _s: &mut S) {\n+        unreachable!();\n     }\n }\n \n@@ -172,8 +188,8 @@ impl<D: Decoder> Decodable<D> for ! {\n }\n \n impl<S: Encoder> Encodable<S> for ::std::num::NonZeroU32 {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.get())\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u32(self.get());\n     }\n }\n \n@@ -184,14 +200,14 @@ impl<D: Decoder> Decodable<D> for ::std::num::NonZeroU32 {\n }\n \n impl<S: Encoder> Encodable<S> for str {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self)\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(self);\n     }\n }\n \n impl<S: Encoder> Encodable<S> for String {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self[..])\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(&self[..]);\n     }\n }\n \n@@ -202,19 +218,15 @@ impl<D: Decoder> Decodable<D> for String {\n }\n \n impl<S: Encoder> Encodable<S> for () {\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: Decoder> Decodable<D> for () {\n     fn decode(_: &mut D) -> () {}\n }\n \n impl<S: Encoder, T> Encodable<S> for PhantomData<T> {\n-    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n-    }\n+    fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: Decoder, T> Decodable<D> for PhantomData<T> {\n@@ -231,8 +243,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<[T]> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Rc<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s);\n     }\n }\n \n@@ -243,19 +255,18 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n-    default fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(self.len())?;\n+    default fn encode(&self, s: &mut S) {\n+        s.emit_usize(self.len());\n         for e in self.iter() {\n-            e.encode(s)?\n+            e.encode(s);\n         }\n-        Ok(())\n     }\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         let slice: &[T] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n \n@@ -277,9 +288,9 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>, const N: usize> Encodable<S> for [T; N] {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         let slice: &[T] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n \n@@ -299,9 +310,9 @@ impl<'a, S: Encoder, T: Encodable<S>> Encodable<S> for Cow<'a, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         let slice: &[T] = self;\n-        slice.encode(s)\n+        slice.encode(s);\n     }\n }\n \n@@ -316,7 +327,7 @@ where\n }\n \n impl<'a, S: Encoder> Encodable<S> for Cow<'a, str> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         let val: &str = self;\n         val.encode(s)\n     }\n@@ -330,9 +341,9 @@ impl<'a, D: Decoder> Decodable<D> for Cow<'a, str> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n-            None => s.emit_enum_variant(0, |_| Ok(())),\n+            None => s.emit_enum_variant(0, |_| {}),\n             Some(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n         }\n     }\n@@ -349,7 +360,7 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n }\n \n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n             Ok(ref v) => s.emit_enum_variant(0, |s| v.encode(s)),\n             Err(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n@@ -381,10 +392,9 @@ macro_rules! tuple {\n         }\n         impl<S: Encoder, $($name: Encodable<S>),+> Encodable<S> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+            fn encode(&self, s: &mut S) {\n                 let ($(ref $name,)+) = *self;\n-                $($name.encode(s)?;)+\n-                Ok(())\n+                $($name.encode(s);)+\n             }\n         }\n         peel! { $($name,)+ }\n@@ -394,14 +404,14 @@ macro_rules! tuple {\n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n impl<S: Encoder> Encodable<S> for path::Path {\n-    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n-        self.to_str().unwrap().encode(e)\n+    fn encode(&self, e: &mut S) {\n+        self.to_str().unwrap().encode(e);\n     }\n }\n \n impl<S: Encoder> Encodable<S> for path::PathBuf {\n-    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n-        path::Path::encode(self, e)\n+    fn encode(&self, e: &mut S) {\n+        path::Path::encode(self, e);\n     }\n }\n \n@@ -413,8 +423,8 @@ impl<D: Decoder> Decodable<D> for path::PathBuf {\n }\n \n impl<S: Encoder, T: Encodable<S> + Copy> Encodable<S> for Cell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.get().encode(s)\n+    fn encode(&self, s: &mut S) {\n+        self.get().encode(s);\n     }\n }\n \n@@ -430,8 +440,8 @@ impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n // from `encode` when `try_borrow` returns `None`.\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.borrow().encode(s)\n+    fn encode(&self, s: &mut S) {\n+        self.borrow().encode(s);\n     }\n }\n \n@@ -442,8 +452,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for RefCell<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Arc<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s);\n     }\n }\n \n@@ -454,8 +464,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<T> {\n }\n \n impl<S: Encoder, T: ?Sized + Encodable<S>> Encodable<S> for Box<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s);\n     }\n }\n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<T> {"}, {"sha": "703b7f5e7a5f468f217b70466949c5ede51713cc", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::opaque::{Decoder, Encoder};\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::{Decodable, Encodable, Encoder as EncoderTrait};\n use std::fmt::Debug;\n \n #[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n@@ -32,12 +32,11 @@ fn check_round_trip<T: Encodable<Encoder> + for<'a> Decodable<Decoder<'a>> + Par\n     values: Vec<T>,\n ) {\n     let mut encoder = Encoder::new();\n-\n     for value in &values {\n-        Encodable::encode(value, &mut encoder).unwrap();\n+        Encodable::encode(value, &mut encoder);\n     }\n \n-    let data = encoder.into_inner();\n+    let data = encoder.finish().unwrap();\n     let mut decoder = Decoder::new(&data[..], 0);\n \n     for value in values {"}, {"sha": "a1533fe46b3ef6e5b828c46fc7ed7f48bc07cddf", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -41,8 +41,8 @@ impl fmt::Display for CrateNum {\n /// As a local identifier, a `CrateNum` is only meaningful within its context, e.g. within a tcx.\n /// Therefore, make sure to include the context when encode a `CrateNum`.\n impl<E: Encoder> Encodable<E> for CrateNum {\n-    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_u32(self.as_u32())\n+    default fn encode(&self, s: &mut E) {\n+        s.emit_u32(self.as_u32());\n     }\n }\n \n@@ -203,7 +203,7 @@ rustc_index::newtype_index! {\n }\n \n impl<E: Encoder> Encodable<E> for DefIndex {\n-    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+    default fn encode(&self, _: &mut E) {\n         panic!(\"cannot encode `DefIndex` with `{}`\", std::any::type_name::<E>());\n     }\n }\n@@ -306,9 +306,9 @@ impl DefId {\n }\n \n impl<E: Encoder> Encodable<E> for DefId {\n-    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        self.krate.encode(s)?;\n-        self.index.encode(s)\n+    default fn encode(&self, s: &mut E) {\n+        self.krate.encode(s);\n+        self.index.encode(s);\n     }\n }\n \n@@ -382,8 +382,8 @@ impl fmt::Debug for LocalDefId {\n }\n \n impl<E: Encoder> Encodable<E> for LocalDefId {\n-    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        self.to_def_id().encode(s)\n+    fn encode(&self, s: &mut E) {\n+        self.to_def_id().encode(s);\n     }\n }\n "}, {"sha": "955db72157c6a75636c7a156608d3845815e809f", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -1189,12 +1189,12 @@ impl HygieneEncodeContext {\n         }\n     }\n \n-    pub fn encode<T, R>(\n+    pub fn encode<T>(\n         &self,\n         encoder: &mut T,\n-        mut encode_ctxt: impl FnMut(&mut T, u32, &SyntaxContextData) -> Result<(), R>,\n-        mut encode_expn: impl FnMut(&mut T, ExpnId, &ExpnData, ExpnHash) -> Result<(), R>,\n-    ) -> Result<(), R> {\n+        mut encode_ctxt: impl FnMut(&mut T, u32, &SyntaxContextData),\n+        mut encode_expn: impl FnMut(&mut T, ExpnId, &ExpnData, ExpnHash),\n+    ) {\n         // When we serialize a `SyntaxContextData`, we may end up serializing\n         // a `SyntaxContext` that we haven't seen before\n         while !self.latest_ctxts.lock().is_empty() || !self.latest_expns.lock().is_empty() {\n@@ -1213,22 +1213,19 @@ impl HygieneEncodeContext {\n             // order\n             for_all_ctxts_in(latest_ctxts.into_iter(), |index, ctxt, data| {\n                 if self.serialized_ctxts.lock().insert(ctxt) {\n-                    encode_ctxt(encoder, index, data)?;\n+                    encode_ctxt(encoder, index, data);\n                 }\n-                Ok(())\n-            })?;\n+            });\n \n             let latest_expns = { std::mem::take(&mut *self.latest_expns.lock()) };\n \n             for_all_expns_in(latest_expns.into_iter(), |expn, data, hash| {\n                 if self.serialized_expns.lock().insert(expn) {\n-                    encode_expn(encoder, expn, data, hash)?;\n+                    encode_expn(encoder, expn, data, hash);\n                 }\n-                Ok(())\n-            })?;\n+            });\n         }\n         debug!(\"encode_hygiene: Done serializing SyntaxContextData\");\n-        Ok(())\n     }\n }\n \n@@ -1378,40 +1375,38 @@ pub fn decode_syntax_context<D: Decoder, F: FnOnce(&mut D, u32) -> SyntaxContext\n     new_ctxt\n }\n \n-fn for_all_ctxts_in<E, F: FnMut(u32, SyntaxContext, &SyntaxContextData) -> Result<(), E>>(\n+fn for_all_ctxts_in<F: FnMut(u32, SyntaxContext, &SyntaxContextData)>(\n     ctxts: impl Iterator<Item = SyntaxContext>,\n     mut f: F,\n-) -> Result<(), E> {\n+) {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n         ctxts.map(|ctxt| (ctxt, data.syntax_context_data[ctxt.0 as usize].clone())).collect()\n     });\n     for (ctxt, data) in all_data.into_iter() {\n-        f(ctxt.0, ctxt, &data)?;\n+        f(ctxt.0, ctxt, &data);\n     }\n-    Ok(())\n }\n \n-fn for_all_expns_in<E>(\n+fn for_all_expns_in(\n     expns: impl Iterator<Item = ExpnId>,\n-    mut f: impl FnMut(ExpnId, &ExpnData, ExpnHash) -> Result<(), E>,\n-) -> Result<(), E> {\n+    mut f: impl FnMut(ExpnId, &ExpnData, ExpnHash),\n+) {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n         expns.map(|expn| (expn, data.expn_data(expn).clone(), data.expn_hash(expn))).collect()\n     });\n     for (expn, data, hash) in all_data.into_iter() {\n-        f(expn, &data, hash)?;\n+        f(expn, &data, hash);\n     }\n-    Ok(())\n }\n \n impl<E: Encoder> Encodable<E> for LocalExpnId {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        self.to_expn_id().encode(e)\n+    fn encode(&self, e: &mut E) {\n+        self.to_expn_id().encode(e);\n     }\n }\n \n impl<E: Encoder> Encodable<E> for ExpnId {\n-    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+    default fn encode(&self, _: &mut E) {\n         panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n     }\n }\n@@ -1432,15 +1427,15 @@ pub fn raw_encode_syntax_context<E: Encoder>(\n     ctxt: SyntaxContext,\n     context: &HygieneEncodeContext,\n     e: &mut E,\n-) -> Result<(), E::Error> {\n+) {\n     if !context.serialized_ctxts.lock().contains(&ctxt) {\n         context.latest_ctxts.lock().insert(ctxt);\n     }\n-    ctxt.0.encode(e)\n+    ctxt.0.encode(e);\n }\n \n impl<E: Encoder> Encodable<E> for SyntaxContext {\n-    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+    default fn encode(&self, _: &mut E) {\n         panic!(\"cannot encode `SyntaxContext` with `{}`\", std::any::type_name::<E>());\n     }\n }"}, {"sha": "7f227217e3c2f88fb425ac8bb43f0b178cbbd11d", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -194,22 +194,19 @@ impl Hash for RealFileName {\n // This is functionally identical to #[derive(Encodable)], with the exception of\n // an added assert statement\n impl<S: Encoder> Encodable<S> for RealFileName {\n-    fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, encoder: &mut S) {\n         match *self {\n             RealFileName::LocalPath(ref local_path) => encoder.emit_enum_variant(0, |encoder| {\n-                Ok({\n-                    local_path.encode(encoder)?;\n-                })\n+                local_path.encode(encoder);\n             }),\n \n             RealFileName::Remapped { ref local_path, ref virtual_name } => encoder\n                 .emit_enum_variant(1, |encoder| {\n                     // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n-                    local_path.encode(encoder)?;\n-                    virtual_name.encode(encoder)?;\n-                    Ok(())\n+                    local_path.encode(encoder);\n+                    virtual_name.encode(encoder);\n                 }),\n         }\n     }\n@@ -946,10 +943,10 @@ impl Default for Span {\n }\n \n impl<E: Encoder> Encodable<E> for Span {\n-    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+    default fn encode(&self, s: &mut E) {\n         let span = self.data();\n-        span.lo.encode(s)?;\n-        span.hi.encode(s)\n+        span.lo.encode(s);\n+        span.hi.encode(s);\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n@@ -1297,17 +1294,17 @@ pub struct SourceFile {\n }\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)?;\n-        self.src_hash.encode(s)?;\n-        self.start_pos.encode(s)?;\n-        self.end_pos.encode(s)?;\n+    fn encode(&self, s: &mut S) {\n+        self.name.encode(s);\n+        self.src_hash.encode(s);\n+        self.start_pos.encode(s);\n+        self.end_pos.encode(s);\n \n         // We are always in `Lines` form by the time we reach here.\n         assert!(self.lines.borrow().is_lines());\n         self.lines(|lines| {\n             // Store the length.\n-            s.emit_u32(lines.len() as u32)?;\n+            s.emit_u32(lines.len() as u32);\n \n             // Compute and store the difference list.\n             if lines.len() != 0 {\n@@ -1329,10 +1326,10 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n                 };\n \n                 // Encode the number of bytes used per diff.\n-                s.emit_u8(bytes_per_diff as u8)?;\n+                s.emit_u8(bytes_per_diff as u8);\n \n                 // Encode the first element.\n-                lines[0].encode(s)?;\n+                lines[0].encode(s);\n \n                 // Encode the difference list.\n                 let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n@@ -1359,16 +1356,15 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n                     }\n                     _ => unreachable!(),\n                 }\n-                s.emit_raw_bytes(&raw_diffs)?;\n+                s.emit_raw_bytes(&raw_diffs);\n             }\n-            Ok(())\n-        })?;\n+        });\n \n-        self.multibyte_chars.encode(s)?;\n-        self.non_narrow_chars.encode(s)?;\n-        self.name_hash.encode(s)?;\n-        self.normalized_pos.encode(s)?;\n-        self.cnum.encode(s)\n+        self.multibyte_chars.encode(s);\n+        self.non_narrow_chars.encode(s);\n+        self.name_hash.encode(s);\n+        self.normalized_pos.encode(s);\n+        self.cnum.encode(s);\n     }\n }\n \n@@ -1916,8 +1912,8 @@ impl_pos! {\n }\n \n impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.0)\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u32(self.0);\n     }\n }\n "}, {"sha": "7b0fa65e8086be144b322533a43f2e4b2f6ce880", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -1802,8 +1802,8 @@ impl fmt::Display for Symbol {\n }\n \n impl<S: Encoder> Encodable<S> for Symbol {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.as_str())\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(self.as_str());\n     }\n }\n "}, {"sha": "6a9ea790a3020d4c3034772baf0ff9081ff84cb4", "filename": "compiler/rustc_type_ir/src/codec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -31,10 +31,7 @@ pub trait TyEncoder: Encoder {\n     fn predicate_shorthands(\n         &mut self,\n     ) -> &mut FxHashMap<<Self::I as Interner>::PredicateKind, usize>;\n-    fn encode_alloc_id(\n-        &mut self,\n-        alloc_id: &<Self::I as Interner>::AllocId,\n-    ) -> Result<(), Self::Error>;\n+    fn encode_alloc_id(&mut self, alloc_id: &<Self::I as Interner>::AllocId);\n }\n \n pub trait TyDecoder: Decoder {"}, {"sha": "a6a0d02c8ba992caf9acb36ce7cc6c19d0dbba63", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -715,115 +715,92 @@ where\n     I::PredicateKind: Encodable<E>,\n     I::AllocId: Encodable<E>,\n {\n-    fn encode(&self, e: &mut E) -> Result<(), <E as rustc_serialize::Encoder>::Error> {\n+    fn encode(&self, e: &mut E) {\n         let disc = discriminant(self);\n         match self {\n-            Bool => e.emit_enum_variant(disc, |_| Ok(())),\n-            Char => e.emit_enum_variant(disc, |_| Ok(())),\n+            Bool => e.emit_enum_variant(disc, |_| {}),\n+            Char => e.emit_enum_variant(disc, |_| {}),\n             Int(i) => e.emit_enum_variant(disc, |e| {\n-                i.encode(e)?;\n-                Ok(())\n+                i.encode(e);\n             }),\n             Uint(u) => e.emit_enum_variant(disc, |e| {\n-                u.encode(e)?;\n-                Ok(())\n+                u.encode(e);\n             }),\n             Float(f) => e.emit_enum_variant(disc, |e| {\n-                f.encode(e)?;\n-                Ok(())\n+                f.encode(e);\n             }),\n             Adt(adt, substs) => e.emit_enum_variant(disc, |e| {\n-                adt.encode(e)?;\n-                substs.encode(e)?;\n-                Ok(())\n+                adt.encode(e);\n+                substs.encode(e);\n             }),\n             Foreign(def_id) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e)?;\n-                Ok(())\n+                def_id.encode(e);\n             }),\n-            Str => e.emit_enum_variant(disc, |_| Ok(())),\n+            Str => e.emit_enum_variant(disc, |_| {}),\n             Array(t, c) => e.emit_enum_variant(disc, |e| {\n-                t.encode(e)?;\n-                c.encode(e)?;\n-                Ok(())\n+                t.encode(e);\n+                c.encode(e);\n             }),\n             Slice(t) => e.emit_enum_variant(disc, |e| {\n-                t.encode(e)?;\n-                Ok(())\n+                t.encode(e);\n             }),\n             RawPtr(tam) => e.emit_enum_variant(disc, |e| {\n-                tam.encode(e)?;\n-                Ok(())\n+                tam.encode(e);\n             }),\n             Ref(r, t, m) => e.emit_enum_variant(disc, |e| {\n-                r.encode(e)?;\n-                t.encode(e)?;\n-                m.encode(e)?;\n-                Ok(())\n+                r.encode(e);\n+                t.encode(e);\n+                m.encode(e);\n             }),\n             FnDef(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e)?;\n-                substs.encode(e)?;\n-                Ok(())\n+                def_id.encode(e);\n+                substs.encode(e);\n             }),\n             FnPtr(polyfnsig) => e.emit_enum_variant(disc, |e| {\n-                polyfnsig.encode(e)?;\n-                Ok(())\n+                polyfnsig.encode(e);\n             }),\n             Dynamic(l, r) => e.emit_enum_variant(disc, |e| {\n-                l.encode(e)?;\n-                r.encode(e)?;\n-                Ok(())\n+                l.encode(e);\n+                r.encode(e);\n             }),\n             Closure(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e)?;\n-                substs.encode(e)?;\n-                Ok(())\n+                def_id.encode(e);\n+                substs.encode(e);\n             }),\n             Generator(def_id, substs, m) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e)?;\n-                substs.encode(e)?;\n-                m.encode(e)?;\n-                Ok(())\n+                def_id.encode(e);\n+                substs.encode(e);\n+                m.encode(e);\n             }),\n             GeneratorWitness(b) => e.emit_enum_variant(disc, |e| {\n-                b.encode(e)?;\n-                Ok(())\n+                b.encode(e);\n             }),\n-            Never => e.emit_enum_variant(disc, |_| Ok(())),\n+            Never => e.emit_enum_variant(disc, |_| {}),\n             Tuple(substs) => e.emit_enum_variant(disc, |e| {\n-                substs.encode(e)?;\n-                Ok(())\n+                substs.encode(e);\n             }),\n             Projection(p) => e.emit_enum_variant(disc, |e| {\n-                p.encode(e)?;\n-                Ok(())\n+                p.encode(e);\n             }),\n             Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e)?;\n-                substs.encode(e)?;\n-                Ok(())\n+                def_id.encode(e);\n+                substs.encode(e);\n             }),\n             Param(p) => e.emit_enum_variant(disc, |e| {\n-                p.encode(e)?;\n-                Ok(())\n+                p.encode(e);\n             }),\n             Bound(d, b) => e.emit_enum_variant(disc, |e| {\n-                d.encode(e)?;\n-                b.encode(e)?;\n-                Ok(())\n+                d.encode(e);\n+                b.encode(e);\n             }),\n             Placeholder(p) => e.emit_enum_variant(disc, |e| {\n-                p.encode(e)?;\n-                Ok(())\n+                p.encode(e);\n             }),\n             Infer(i) => e.emit_enum_variant(disc, |e| {\n-                i.encode(e)?;\n-                Ok(())\n+                i.encode(e);\n             }),\n             Error(d) => e.emit_enum_variant(disc, |e| {\n-                d.encode(e)?;\n-                Ok(())\n+                d.encode(e);\n             }),\n         }\n     }"}, {"sha": "242f926967c937201b83318c18b55e895f44d3ec", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_serialize::{\n     opaque::{Decoder, FileEncoder},\n-    Decodable, Encodable,\n+    Decodable, Encodable, Encoder,\n };\n use rustc_session::getopts;\n use rustc_span::{\n@@ -314,8 +314,8 @@ pub(crate) fn run(\n \n         // Save output to provided path\n         let mut encoder = FileEncoder::new(options.output_path).map_err(|e| e.to_string())?;\n-        calls.encode(&mut encoder).map_err(|e| e.to_string())?;\n-        encoder.flush().map_err(|e| e.to_string())?;\n+        calls.encode(&mut encoder);\n+        encoder.finish().map_err(|e| e.to_string())?;\n \n         Ok(())\n     };"}, {"sha": "a09deeec4f182f6c1cdc136f65d2820d5d75cb68", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::opaque;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n \n #[derive(Encodable, Decodable)]\n struct A {\n@@ -17,9 +17,13 @@ struct A {\n \n fn main() {\n     let obj = A { foo: Box::new([true, false]) };\n-    let mut encoder = opaque::Encoder::new(vec![]);\n-    obj.encode(&mut encoder).unwrap();\n-    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+\n+    let mut encoder = opaque::Encoder::new();\n+    obj.encode(&mut encoder);\n+    let data = encoder.finish().unwrap();\n+\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = A::decode(&mut decoder);\n+\n     assert_eq!(obj.foo, obj2.foo);\n }"}, {"sha": "9b6fb0e580621ee2f7572ad6ae3aa9828b447e3c", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -10,7 +10,7 @@ extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::opaque;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n use std::cell::{Cell, RefCell};\n \n #[derive(Encodable, Decodable)]\n@@ -26,10 +26,14 @@ struct B {\n \n fn main() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n-    let mut encoder = opaque::Encoder::new(vec![]);\n-    obj.encode(&mut encoder).unwrap();\n-    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+\n+    let mut encoder = opaque::Encoder::new();\n+    obj.encode(&mut encoder);\n+    let data = encoder.finish().unwrap();\n+\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = B::decode(&mut decoder);\n+\n     assert_eq!(obj.foo.get(), obj2.foo.get());\n     assert_eq!(obj.bar.borrow().baz, obj2.bar.borrow().baz);\n }"}, {"sha": "f6360db9b5f447caafcc9faddf30cbd4025fc57c", "filename": "src/test/ui-fulldeps/issue-11881.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -75,6 +75,7 @@ enum WireProtocol {\n fn encode_json<T: for<'a> Encodable<JsonEncoder<'a>>>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", as_json(val));\n }\n+\n fn encode_opaque<T: Encodable<OpaqueEncoder>>(val: &T, wr: Vec<u8>) {\n     let mut encoder = OpaqueEncoder(wr);\n     val.encode(&mut encoder);"}, {"sha": "4241456367e46fe0a25377aa58eb4a5029ebe1c4", "filename": "src/test/ui-fulldeps/issue-14021.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acbe7573dc32f917f51a784a36b7afc690900e3/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs?ref=1acbe7573dc32f917f51a784a36b7afc690900e3", "patch": "@@ -9,16 +9,20 @@ extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::opaque;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n \n #[derive(Encodable, Decodable, PartialEq, Debug)]\n struct UnitLikeStruct;\n \n pub fn main() {\n     let obj = UnitLikeStruct;\n-    let mut encoder = opaque::Encoder::new(vec![]);\n-    obj.encode(&mut encoder).unwrap();\n-    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+\n+    let mut encoder = opaque::Encoder::new();\n+    obj.encode(&mut encoder);\n+    let data = encoder.finish().unwrap();\n+\n+    let mut decoder = opaque::Decoder::new(&data, 0);\n     let obj2 = UnitLikeStruct::decode(&mut decoder);\n+\n     assert_eq!(obj, obj2);\n }"}]}