{"sha": "222d2508375a363be7a4f6ded3c9bd7be0803d19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMmQyNTA4Mzc1YTM2M2JlN2E0ZjZkZWQzYzliZDdiZTA4MDNkMTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-17T21:09:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-17T21:09:26Z"}, "message": "Rollup merge of #74424 - sexxi-goose:move_hir_place, r=nikomatsakis\n\nMove hir::Place to librustc_middle/hir\n\nNeeded to support https://github.com/rust-lang/project-rfc-2229/issues/7\n\nCurrently rustc_typeck depends on rustc_middle for definition TypeckTables, etc.\nFor supporting project-rfc-2229#7, rustc_middle would've to depend on\nrustc_typeck for Place -- introducing a circular dependency.\n\nThis resembles the MIR equivalent of `Place` located in `lbrustc_middle/mir`.\n\nSeparate PR for this move will make the actual PR for using Places to represent captures cleaner/more focused.\n\nr? @nikomatsakis  @matthewjasper", "tree": {"sha": "24ab5e17a9ba90e90965d10de9314e4821fc5cea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ab5e17a9ba90e90965d10de9314e4821fc5cea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/222d2508375a363be7a4f6ded3c9bd7be0803d19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEhOGCRBK7hj4Ov3rIwAAdHIIAGff7ShxQcImz7qjfET87oBc\nxBtmYvZyZJ08iGNKQayFgsCmWfr2h49q9+rMXZSrI0G6BwSIKGRGU/0zX0opONU4\nfS0C7LCIR1ync/M9njiwV6Pb6bYiCvSJVxk3yz/yfOQsouBkHXYIhcAhMuS8xBdD\nPXvDLdPjQbUnSM9E5tc00vmr0sXZwweFUDp0dr8poPqtaty2vB0YijmHOGRaCyOg\nkPtUFkG+7sMFfR/hFhIntHUqY5SF1ucXeyBfjX5EfK/xHgfxglg41fhluJ5gYTYX\ngzOoomafc7O1EojlUvxgnA5NNTM83cGatl1fe79PvreGOQYovGHddqCFVaL35ws=\n=Aq8S\n-----END PGP SIGNATURE-----\n", "payload": "tree 24ab5e17a9ba90e90965d10de9314e4821fc5cea\nparent eef22dae7e0ccbf484f1fef3989759fc75b6dddb\nparent 50f3dbd1214fb9e582b845a364fc4746622e96a0\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595020166 -0700\ncommitter GitHub <noreply@github.com> 1595020166 -0700\n\nRollup merge of #74424 - sexxi-goose:move_hir_place, r=nikomatsakis\n\nMove hir::Place to librustc_middle/hir\n\nNeeded to support https://github.com/rust-lang/project-rfc-2229/issues/7\n\nCurrently rustc_typeck depends on rustc_middle for definition TypeckTables, etc.\nFor supporting project-rfc-2229#7, rustc_middle would've to depend on\nrustc_typeck for Place -- introducing a circular dependency.\n\nThis resembles the MIR equivalent of `Place` located in `lbrustc_middle/mir`.\n\nSeparate PR for this move will make the actual PR for using Places to represent captures cleaner/more focused.\n\nr? @nikomatsakis  @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/222d2508375a363be7a4f6ded3c9bd7be0803d19", "html_url": "https://github.com/rust-lang/rust/commit/222d2508375a363be7a4f6ded3c9bd7be0803d19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/222d2508375a363be7a4f6ded3c9bd7be0803d19/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eef22dae7e0ccbf484f1fef3989759fc75b6dddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef22dae7e0ccbf484f1fef3989759fc75b6dddb", "html_url": "https://github.com/rust-lang/rust/commit/eef22dae7e0ccbf484f1fef3989759fc75b6dddb"}, {"sha": "50f3dbd1214fb9e582b845a364fc4746622e96a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f3dbd1214fb9e582b845a364fc4746622e96a0", "html_url": "https://github.com/rust-lang/rust/commit/50f3dbd1214fb9e582b845a364fc4746622e96a0"}], "stats": {"total": 274, "additions": 141, "deletions": 133}, "files": [{"sha": "b014f3c8eb7949635854fa1618581e7e5b4a660a", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -4,6 +4,7 @@\n \n pub mod exports;\n pub mod map;\n+pub mod place;\n \n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;"}, {"sha": "d85165bcccfdc99cf38fc11348f60787bdc0a9b3", "filename": "src/librustc_middle/hir/place.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fplace.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -0,0 +1,115 @@\n+use crate::ty;\n+use crate::ty::Ty;\n+\n+use rustc_hir::HirId;\n+use rustc_target::abi::VariantIdx;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum PlaceBase {\n+    /// A temporary variable\n+    Rvalue,\n+    /// A named `static` item\n+    StaticItem,\n+    /// A named local variable\n+    Local(HirId),\n+    /// An upvar referenced by closure env\n+    Upvar(ty::UpvarId),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ProjectionKind {\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    Deref,\n+\n+    /// `B.F` where `B` is the base expression and `F` is\n+    /// the field. The field is identified by which variant\n+    /// it appears in along with a field index. The variant\n+    /// is used for enums.\n+    Field(u32, VariantIdx),\n+\n+    /// Some index like `B[x]`, where `B` is the base\n+    /// expression. We don't preserve the index `x` because\n+    /// we won't need it.\n+    Index,\n+\n+    /// A subslice covering a range of values like `B[x..y]`.\n+    Subslice,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Projection<'tcx> {\n+    /// Type after the projection is being applied.\n+    pub ty: Ty<'tcx>,\n+\n+    /// Defines the type of access\n+    pub kind: ProjectionKind,\n+}\n+\n+/// A `Place` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Place<'tcx> {\n+    /// The type of the `PlaceBase`\n+    pub base_ty: Ty<'tcx>,\n+    /// The \"outermost\" place that holds this value.\n+    pub base: PlaceBase,\n+    /// How this place is derived from the base place.\n+    pub projections: Vec<Projection<'tcx>>,\n+}\n+\n+/// A `PlaceWithHirId` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct PlaceWithHirId<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: HirId,\n+\n+    /// Information about the `Place`\n+    pub place: Place<'tcx>,\n+}\n+\n+impl<'tcx> PlaceWithHirId<'tcx> {\n+    pub fn new(\n+        hir_id: HirId,\n+        base_ty: Ty<'tcx>,\n+        base: PlaceBase,\n+        projections: Vec<Projection<'tcx>>,\n+    ) -> PlaceWithHirId<'tcx> {\n+        PlaceWithHirId {\n+            hir_id: hir_id,\n+            place: Place { base_ty: base_ty, base: base, projections: projections },\n+        }\n+    }\n+}\n+\n+impl<'tcx> Place<'tcx> {\n+    /// Returns an iterator of the types that have to be dereferenced to access\n+    /// the `Place`.\n+    ///\n+    /// The types are in the reverse order that they are applied. So if\n+    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n+    ///`*const u32` then `&*const u32`.\n+    pub fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n+        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n+            if ProjectionKind::Deref == proj.kind {\n+                Some(self.ty_before_projection(index))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the type of this `Place` after all projections have been applied.\n+    pub fn ty(&self) -> Ty<'tcx> {\n+        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n+    }\n+\n+    /// Returns the type of this `Place` immediately before `projection_index`th projection\n+    /// is applied.\n+    pub fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n+        assert!(projection_index < self.projections.len());\n+        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n+    }\n+}"}, {"sha": "b72152d1911f7dc5851f627149f7d5d1205335aa", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -82,6 +82,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n@@ -442,7 +443,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_adjustments(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -483,10 +484,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         span: Span,\n     ) {\n-        if let mc::PlaceBase::Rvalue = place_with_id.place.base {\n+        if let PlaceBase::Rvalue = place_with_id.place.base {\n             if place_with_id.place.projections.is_empty() {\n                 let typ = self.resolve_type(place_with_id.place.ty());\n                 let body_id = self.body_id;\n@@ -573,7 +574,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n+    fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -594,7 +595,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr<'_>,\n-        expr_cmt: &mc::PlaceWithHirId<'tcx>,\n+        expr_cmt: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n@@ -615,7 +616,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::PlaceWithHirId<'tcx>,\n+        cmt_borrowed: &PlaceWithHirId<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -638,7 +639,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_place: &mc::PlaceWithHirId<'tcx>,\n+        borrow_place: &PlaceWithHirId<'tcx>,\n     ) {\n         let origin = infer::DataBorrowed(borrow_place.place.ty(), span);\n         self.type_must_outlive(origin, borrow_place.place.ty(), borrow_region);\n@@ -659,7 +660,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n             }\n         }\n-        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n+        if let PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n             self.link_upvar_region(span, borrow_region, upvar_id);\n         }\n     }"}, {"sha": "030c0ab668a8005db6a0a7bbf374697cbfabf06d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -33,14 +33,13 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use crate::mem_categorization as mc;\n-use crate::mem_categorization::PlaceBase;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::{Span, Symbol};\n \n@@ -276,7 +275,7 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\n@@ -315,7 +314,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -340,7 +339,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -470,12 +469,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         debug!(\"consume(place_with_id={:?},mode={:?})\", place_with_id, mode);\n         self.adjust_upvar_borrow_kind_for_consume(place_with_id, mode);\n     }\n \n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         debug!(\"borrow(place_with_id={:?}, bk={:?})\", place_with_id, bk);\n \n         match bk {\n@@ -489,7 +488,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>) {\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>) {\n         debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_place);"}, {"sha": "d1b386c9d4d47279ca3915cb5256f94a8b03d1be", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -5,14 +5,15 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use mc::{PlaceBase, PlaceWithHirId, Projection};\n+pub use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -27,13 +28,13 @@ use rustc_span::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: ConsumeMode);\n \n     // The value found at `place` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n \n     // The path at `place_with_id` is being assigned to.\n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>);\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             &*with_expr,\n                             with_place.clone(),\n                             with_field.ty(self.tcx(), substs),\n-                            mc::ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n+                            ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n                         );\n                         self.delegate_consume(&field_place);\n                     }\n@@ -462,7 +463,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_autoref(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-        base_place: &mc::PlaceWithHirId<'tcx>,\n+        base_place: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -575,7 +576,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         closure_hir_id: hir::HirId,\n         closure_span: Span,\n         var_id: hir::HirId,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;"}, {"sha": "afc7cb346eb428299fec3bb7093a749d2916e30c", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d2508375a363be7a4f6ded3c9bd7be0803d19/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=222d2508375a363be7a4f6ded3c9bd7be0803d19", "patch": "@@ -48,6 +48,7 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n+use rustc_middle::hir::place::*;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -64,116 +65,6 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-#[derive(Clone, Debug)]\n-pub enum PlaceBase {\n-    /// A temporary variable\n-    Rvalue,\n-    /// A named `static` item\n-    StaticItem,\n-    /// A named local variable\n-    Local(hir::HirId),\n-    /// An upvar referenced by closure env\n-    Upvar(ty::UpvarId),\n-}\n-\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub enum ProjectionKind {\n-    /// A dereference of a pointer, reference or `Box<T>` of the given type\n-    Deref,\n-\n-    /// `B.F` where `B` is the base expression and `F` is\n-    /// the field. The field is identified by which variant\n-    /// it appears in along with a field index. The variant\n-    /// is used for enums.\n-    Field(u32, VariantIdx),\n-\n-    /// Some index like `B[x]`, where `B` is the base\n-    /// expression. We don't preserve the index `x` because\n-    /// we won't need it.\n-    Index,\n-\n-    /// A subslice covering a range of values like `B[x..y]`.\n-    Subslice,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Projection<'tcx> {\n-    // Type after the projection is being applied.\n-    ty: Ty<'tcx>,\n-\n-    /// Defines the type of access\n-    kind: ProjectionKind,\n-}\n-\n-/// A `Place` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct Place<'tcx> {\n-    /// The type of the `PlaceBase`\n-    pub base_ty: Ty<'tcx>,\n-    /// The \"outermost\" place that holds this value.\n-    pub base: PlaceBase,\n-    /// How this place is derived from the base place.\n-    pub projections: Vec<Projection<'tcx>>,\n-}\n-\n-/// A `PlaceWithHirId` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct PlaceWithHirId<'tcx> {\n-    /// `HirId` of the expression or pattern producing this value.\n-    pub hir_id: hir::HirId,\n-\n-    /// Information about the `Place`\n-    pub place: Place<'tcx>,\n-}\n-\n-impl<'tcx> PlaceWithHirId<'tcx> {\n-    crate fn new(\n-        hir_id: hir::HirId,\n-        base_ty: Ty<'tcx>,\n-        base: PlaceBase,\n-        projections: Vec<Projection<'tcx>>,\n-    ) -> PlaceWithHirId<'tcx> {\n-        PlaceWithHirId {\n-            hir_id: hir_id,\n-            place: Place { base_ty: base_ty, base: base, projections: projections },\n-        }\n-    }\n-}\n-\n-impl<'tcx> Place<'tcx> {\n-    /// Returns an iterator of the types that have to be dereferenced to access\n-    /// the `Place`.\n-    ///\n-    /// The types are in the reverse order that they are applied. So if\n-    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n-    ///`*const u32` then `&*const u32`.\n-    crate fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n-        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n-            if ProjectionKind::Deref == proj.kind {\n-                Some(self.ty_before_projection(index))\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // Returns the type of this `Place` after all projections have been applied.\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n-    }\n-\n-    // Returns the type of this `Place` immediately before `projection_index`th projection\n-    // is applied.\n-    crate fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n-        assert!(projection_index < self.projections.len());\n-        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n-    }\n-}\n-\n crate trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;"}]}