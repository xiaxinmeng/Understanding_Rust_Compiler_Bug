{"sha": "b5302217f026ba00e9f0514992b5f8226f7cb541", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzAyMjE3ZjAyNmJhMDBlOWYwNTE0OTkyYjVmODIyNmY3Y2I1NDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:34:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:25Z"}, "message": "rollup merge of #19821: bkoropoff/issue-19791\n\nNormalize late-bound regions in bare functions, stack closures, and traits and include them in the generated hash.\n\nCloses #19791\n\nr? @nikomatsakis (does my normalization make sense?)\ncc @alexcrichton", "tree": {"sha": "e138ac4c2c083a2cfdac32ec98879ff576018f9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e138ac4c2c083a2cfdac32ec98879ff576018f9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5302217f026ba00e9f0514992b5f8226f7cb541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5302217f026ba00e9f0514992b5f8226f7cb541", "html_url": "https://github.com/rust-lang/rust/commit/b5302217f026ba00e9f0514992b5f8226f7cb541", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5302217f026ba00e9f0514992b5f8226f7cb541/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be0c8fb50729c76ad22c4f5c2294626dc32524aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/be0c8fb50729c76ad22c4f5c2294626dc32524aa", "html_url": "https://github.com/rust-lang/rust/commit/be0c8fb50729c76ad22c4f5c2294626dc32524aa"}, {"sha": "0a1798dd1e7fad9f04a99c58623661ffb1747de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1798dd1e7fad9f04a99c58623661ffb1747de0", "html_url": "https://github.com/rust-lang/rust/commit/0a1798dd1e7fad9f04a99c58623661ffb1747de0"}], "stats": {"total": 362, "additions": 248, "deletions": 114}, "files": [{"sha": "3a59fb5016075e54c31d66cb634d825f0d0af2fc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 158, "deletions": 114, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b5302217f026ba00e9f0514992b5f8226f7cb541", "patch": "@@ -5825,126 +5825,153 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n-    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n-    macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n-\n-    let region = |_state: &mut sip::SipState, r: Region| {\n-        match r {\n-            ReStatic => {}\n-\n-            ReEmpty |\n-            ReEarlyBound(..) |\n-            ReLateBound(..) |\n-            ReFree(..) |\n-            ReScope(..) |\n-            ReInfer(..) => {\n-                tcx.sess.bug(\"non-static region found when hashing a type\")\n+    helper(tcx, ty, svh, &mut state);\n+    return state.result();\n+\n+    fn helper(tcx: &ctxt, ty: Ty, svh: &Svh, state: &mut sip::SipState) {\n+        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n+        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+\n+        let region = |state: &mut sip::SipState, r: Region| {\n+            match r {\n+                ReStatic => {}\n+                ReLateBound(db, BrAnon(i)) => {\n+                    db.hash(state);\n+                    i.hash(state);\n+                }\n+                ReEmpty |\n+                ReEarlyBound(..) |\n+                ReLateBound(..) |\n+                ReFree(..) |\n+                ReScope(..) |\n+                ReInfer(..) => {\n+                    tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                }\n             }\n-        }\n-    };\n-    let did = |state: &mut sip::SipState, did: DefId| {\n-        let h = if ast_util::is_local(did) {\n-            svh.clone()\n-        } else {\n-            tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_str().hash(state);\n-        did.node.hash(state);\n-    };\n-    let mt = |state: &mut sip::SipState, mt: mt| {\n-        mt.mutbl.hash(state);\n-    };\n-    ty::walk_ty(ty, |ty| {\n-        match ty.sty {\n-            ty_bool => byte!(2),\n-            ty_char => byte!(3),\n-            ty_int(i) => {\n-                byte!(4);\n-                hash!(i);\n-            }\n-            ty_uint(u) => {\n-                byte!(5);\n-                hash!(u);\n-            }\n-            ty_float(f) => {\n-                byte!(6);\n-                hash!(f);\n-            }\n-            ty_str => {\n-                byte!(7);\n-            }\n-            ty_enum(d, _) => {\n-                byte!(8);\n-                did(&mut state, d);\n-            }\n-            ty_uniq(_) => {\n-                byte!(9);\n-            }\n-            ty_vec(_, Some(n)) => {\n-                byte!(10);\n-                n.hash(&mut state);\n-            }\n-            ty_vec(_, None) => {\n-                byte!(11);\n-            }\n-            ty_ptr(m) => {\n-                byte!(12);\n-                mt(&mut state, m);\n-            }\n-            ty_rptr(r, m) => {\n-                byte!(13);\n-                region(&mut state, r);\n-                mt(&mut state, m);\n-            }\n-            ty_bare_fn(ref b) => {\n-                byte!(14);\n-                hash!(b.unsafety);\n-                hash!(b.abi);\n+        let did = |state: &mut sip::SipState, did: DefId| {\n+            let h = if ast_util::is_local(did) {\n+                svh.clone()\n+            } else {\n+                tcx.sess.cstore.get_crate_hash(did.krate)\n+            };\n+            h.as_str().hash(state);\n+            did.node.hash(state);\n+        };\n+        let mt = |state: &mut sip::SipState, mt: mt| {\n+            mt.mutbl.hash(state);\n+        };\n+        let fn_sig = |state: &mut sip::SipState, sig: &FnSig| {\n+            let sig = anonymize_late_bound_regions(tcx, sig);\n+            for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n+            if let ty::FnConverging(output) = sig.output {\n+                helper(tcx, output, svh, state);\n             }\n-            ty_closure(ref c) => {\n-                byte!(15);\n-                hash!(c.unsafety);\n-                hash!(c.onceness);\n-                hash!(c.bounds);\n-                match c.store {\n-                    UniqTraitStore => byte!(0),\n-                    RegionTraitStore(r, m) => {\n-                        byte!(1)\n-                        region(&mut state, r);\n-                        assert_eq!(m, ast::MutMutable);\n+        };\n+        maybe_walk_ty(ty, |ty| {\n+            match ty.sty {\n+                ty_bool => byte!(2),\n+                ty_char => byte!(3),\n+                ty_int(i) => {\n+                    byte!(4);\n+                    hash!(i);\n+                }\n+                ty_uint(u) => {\n+                    byte!(5);\n+                    hash!(u);\n+                }\n+                ty_float(f) => {\n+                    byte!(6);\n+                    hash!(f);\n+                }\n+                ty_str => {\n+                    byte!(7);\n+                }\n+                ty_enum(d, _) => {\n+                    byte!(8);\n+                    did(state, d);\n+                }\n+                ty_uniq(_) => {\n+                    byte!(9);\n+                }\n+                ty_vec(_, Some(n)) => {\n+                    byte!(10);\n+                    n.hash(state);\n+                }\n+                ty_vec(_, None) => {\n+                    byte!(11);\n+                }\n+                ty_ptr(m) => {\n+                    byte!(12);\n+                    mt(state, m);\n+                }\n+                ty_rptr(r, m) => {\n+                    byte!(13);\n+                    region(state, r);\n+                    mt(state, m);\n+                }\n+                ty_bare_fn(ref b) => {\n+                    byte!(14);\n+                    hash!(b.unsafety);\n+                    hash!(b.abi);\n+                    fn_sig(state, &b.sig);\n+                    return false;\n+                }\n+                ty_closure(ref c) => {\n+                    byte!(15);\n+                    hash!(c.unsafety);\n+                    hash!(c.onceness);\n+                    hash!(c.bounds);\n+                    match c.store {\n+                        UniqTraitStore => byte!(0),\n+                        RegionTraitStore(r, m) => {\n+                            byte!(1);\n+                            region(state, r);\n+                            assert_eq!(m, ast::MutMutable);\n+                        }\n                     }\n+\n+                    fn_sig(state, &c.sig);\n+\n+                    return false;\n                 }\n-            }\n-            ty_trait(box TyTrait { ref principal, bounds }) => {\n-                byte!(17);\n-                did(&mut state, principal.def_id);\n-                hash!(bounds);\n-            }\n-            ty_struct(d, _) => {\n-                byte!(18);\n-                did(&mut state, d);\n-            }\n-            ty_tup(ref inner) => {\n-                byte!(19);\n-                hash!(inner.len());\n-            }\n-            ty_param(p) => {\n-                byte!(20);\n-                hash!(p.idx);\n-                did(&mut state, p.def_id);\n-            }\n-            ty_open(_) => byte!(22),\n-            ty_infer(_) => unreachable!(),\n-            ty_err => byte!(23),\n-            ty_unboxed_closure(d, r, _) => {\n-                byte!(24);\n-                did(&mut state, d);\n-                region(&mut state, r);\n-            }\n-        }\n-    });\n+                ty_trait(box TyTrait { ref principal, bounds }) => {\n+                    byte!(17);\n+                    did(state, principal.def_id);\n+                    hash!(bounds);\n+\n+                    let principal = anonymize_late_bound_regions(tcx, principal);\n+                    for subty in principal.substs.types.iter() {\n+                        helper(tcx, *subty, svh, state);\n+                    }\n \n-    state.result()\n+                    return false;\n+                }\n+                ty_struct(d, _) => {\n+                    byte!(18);\n+                    did(state, d);\n+                }\n+                ty_tup(ref inner) => {\n+                    byte!(19);\n+                    hash!(inner.len());\n+                }\n+                ty_param(p) => {\n+                    byte!(20);\n+                    hash!(p.idx);\n+                    did(state, p.def_id);\n+                }\n+                ty_open(_) => byte!(22),\n+                ty_infer(_) => unreachable!(),\n+                ty_err => byte!(23),\n+                ty_unboxed_closure(d, r, _) => {\n+                    byte!(24);\n+                    did(state, d);\n+                    region(state, r);\n+                }\n+            }\n+            true\n+        });\n+    }\n }\n \n impl Variance {\n@@ -6284,6 +6311,23 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n \n+/// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+/// assigned starting at 1 and increasing monotonically in the order traversed\n+/// by the fold operation.\n+///\n+/// The chief purpose of this function is to canonicalize regions so that two\n+/// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n+/// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n+/// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n+pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n+                                              where HR: HigherRankedFoldable<'tcx> {\n+    let mut counter = 0;\n+    replace_late_bound_regions(tcx, sig, |_, db| {\n+        counter += 1;\n+        ReLateBound(db, BrAnon(counter))\n+    }).0\n+}\n+\n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n pub fn replace_late_bound_regions<'tcx, HR, F>(\n     tcx: &ty::ctxt<'tcx>,"}, {"sha": "b08cf1112fbcfdb897b55019a765b8033e179042", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b5302217f026ba00e9f0514992b5f8226f7cb541", "patch": "@@ -1005,8 +1005,13 @@ impl<'a> State<'a> {\n     fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n         if !t.bound_lifetimes.is_empty() {\n             try!(word(&mut self.s, \"for<\"));\n+            let mut comma = false;\n             for lifetime_def in t.bound_lifetimes.iter() {\n+                if comma {\n+                    try!(self.word_space(\",\"))\n+                }\n                 try!(self.print_lifetime_def(lifetime_def));\n+                comma = true;\n             }\n             try!(word(&mut self.s, \">\"));\n         }"}, {"sha": "efda7771403a393066a13bc24b6d609198d6dad2", "filename": "src/test/run-pass/type-id-higher-rank.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5302217f026ba00e9f0514992b5f8226f7cb541/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs?ref=b5302217f026ba00e9f0514992b5f8226f7cb541", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that type IDs correctly account for higher-rank lifetimes\n+// Also acts as a regression test for an ICE (issue #19791)\n+\n+#![feature(unboxed_closures)]\n+\n+use std::intrinsics::TypeId;\n+\n+fn main() {\n+    // Bare fns\n+    {\n+        let a = TypeId::of::<fn(&'static int, &'static int)>();\n+        let b = TypeId::of::<for<'a> fn(&'static int, &'a int)>();\n+        let c = TypeId::of::<for<'a, 'b> fn(&'a int, &'b int)>();\n+        let d = TypeId::of::<for<'a, 'b> fn(&'b int, &'a int)>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<for<'a> fn(fn(&'a int) -> &'a int)>();\n+        let f = TypeId::of::<fn(for<'a> fn(&'a int) -> &'a int)>();\n+        assert!(e != f);\n+    }\n+    // Stack closures\n+    {\n+        let a = TypeId::of::<|&'static int, &'static int|>();\n+        let b = TypeId::of::<for<'a> |&'static int, &'a int|>();\n+        let c = TypeId::of::<for<'a, 'b> |&'a int, &'b int|>();\n+        let d = TypeId::of::<for<'a, 'b> |&'b int, &'a int|>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<for<'a> |(|&'a int| -> &'a int)|>();\n+        let f = TypeId::of::<|for<'a> |&'a int| -> &'a int|>();\n+        assert!(e != f);\n+    }\n+    // Boxed unboxed closures\n+    {\n+        let a = TypeId::of::<Box<Fn(&'static int, &'static int)>>();\n+        let b = TypeId::of::<Box<for<'a> Fn(&'static int, &'a int)>>();\n+        let c = TypeId::of::<Box<for<'a, 'b> Fn(&'a int, &'b int)>>();\n+        let d = TypeId::of::<Box<for<'a, 'b> Fn(&'b int, &'a int)>>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<Box<for<'a> Fn(Box<Fn(&'a int) -> &'a int>)>>();\n+        let f = TypeId::of::<Box<Fn(Box<for<'a> Fn(&'a int) -> &'a int>)>>();\n+        assert!(e != f);\n+    }\n+    // Raw unboxed closures\n+    // Note that every unboxed closure has its own anonymous type,\n+    // so no two IDs should equal each other, even when compatible\n+    {\n+        let a = id(|&: _: &int, _: &int| {});\n+        let b = id(|&: _: &int, _: &int| {});\n+        assert!(a != b);\n+    }\n+\n+    fn id<T:'static>(_: T) -> TypeId {\n+        TypeId::of::<T>()\n+    }\n+}"}]}