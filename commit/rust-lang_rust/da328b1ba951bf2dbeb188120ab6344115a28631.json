{"sha": "da328b1ba951bf2dbeb188120ab6344115a28631", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMzI4YjFiYTk1MWJmMmRiZWIxODgxMjBhYjYzNDQxMTVhMjg2MzE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-25T23:17:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-25T23:40:25Z"}, "message": "Kick ty_var and ty_local entries out of the type store. Pre-compute presence of var, local, param and bound_params in types.", "tree": {"sha": "7313c9f7edf929248890e7fde5baa13b3fd64153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7313c9f7edf929248890e7fde5baa13b3fd64153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da328b1ba951bf2dbeb188120ab6344115a28631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da328b1ba951bf2dbeb188120ab6344115a28631", "html_url": "https://github.com/rust-lang/rust/commit/da328b1ba951bf2dbeb188120ab6344115a28631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da328b1ba951bf2dbeb188120ab6344115a28631/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f77e7df6dc2eabd47f3708cacc4124d43e79c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f77e7df6dc2eabd47f3708cacc4124d43e79c77", "html_url": "https://github.com/rust-lang/rust/commit/3f77e7df6dc2eabd47f3708cacc4124d43e79c77"}], "stats": {"total": 255, "additions": 183, "deletions": 72}, "files": [{"sha": "8d8c9926b81bc5be061f24f66c8a8cf58888178c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da328b1ba951bf2dbeb188120ab6344115a28631/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da328b1ba951bf2dbeb188120ab6344115a28631/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=da328b1ba951bf2dbeb188120ab6344115a28631", "patch": "@@ -120,7 +120,7 @@ type local_ctxt = rec(vec[str] path,\n                       vec[ast.ty_param] obj_typarams,\n                       vec[ast.obj_field] obj_fields,\n                       @crate_ctxt ccx);\n-                \n+\n \n type self_vt = rec(ValueRef v, ty.t t);\n \n@@ -1565,7 +1565,7 @@ fn get_tydesc(&@block_ctxt cx, ty.t t) -> result {\n     // Does it contain a type param? If so, generate a derived tydesc.\n     let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n \n-    if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t) > 0u) {\n+    if (n_params > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n         check (n_params == _vec.len[uint](tys._0));\n@@ -4312,7 +4312,8 @@ fn trans_bind_thunk(@local_ctxt cx,\n \n                 if (out_arg.mode == ast.val) {\n                     val = bcx.build.Load(val);\n-                } else if (ty.count_ty_params(cx.ccx.tcx, out_arg.ty) > 0u) {\n+                } else if (ty.type_contains_params(cx.ccx.tcx,\n+                                                   out_arg.ty)) {\n                     check (out_arg.mode == ast.alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n@@ -4325,7 +4326,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n             case (none[@ast.expr]) {\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n-                if (ty.count_ty_params(cx.ccx.tcx, out_arg.ty) > 0u) {\n+                if (ty.type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n                     check (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n@@ -4593,7 +4594,7 @@ fn trans_arg_expr(@block_ctxt cx,\n         bcx = re.bcx;\n     }\n \n-    if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, arg.ty) > 0u) {\n+    if (ty.type_contains_params(cx.fcx.lcx.ccx.tcx, arg.ty)) {\n         auto lldestty = lldestty0;\n         if (arg.mode == ast.val) {\n             // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n@@ -4655,7 +4656,7 @@ fn trans_args(@block_ctxt cx,\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, retty)) {\n         llargs += vec(bcx.build.PointerCast\n                       (llretslot, T_typaram_ptr(cx.fcx.lcx.ccx.tn)));\n-    } else if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, retty) != 0u) {\n+    } else if (ty.type_contains_params(cx.fcx.lcx.ccx.tcx, retty)) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view"}, {"sha": "194dcf442b67f85f7fb7751b97351969deed1be4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 176, "deletions": 66, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/da328b1ba951bf2dbeb188120ab6344115a28631/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da328b1ba951bf2dbeb188120ab6344115a28631/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=da328b1ba951bf2dbeb188120ab6344115a28631", "patch": "@@ -61,7 +61,14 @@ fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariants.\n-type raw_t = rec(sty struct, option.t[str] cname, uint magic, uint hash);\n+type raw_t = rec(sty struct,\n+                 option.t[str] cname,\n+                 uint magic,\n+                 uint hash,\n+                 bool has_params,\n+                 bool has_bound_params,\n+                 bool has_vars,\n+                 bool has_locals);\n type t = @raw_t;\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -145,6 +152,7 @@ type type_store = rec(vec[ty.t] empty_vec_ty,\n                       ty.t t_char,\n                       ty.t t_str,\n \n+                      ty.t t_task,\n                       ty.t t_native,\n                       ty.t t_type,\n \n@@ -164,7 +172,7 @@ fn mk_type_store() -> @type_store {\n              t_int = mk_ty_full(ty_int, none[str]),\n              t_float = mk_ty_full(ty_float, none[str]),\n              t_uint = mk_ty_full(ty_uint, none[str]),\n-             \n+\n              t_i8 = mk_ty_full(ty_machine(ty_i8), none[str]),\n              t_i16 = mk_ty_full(ty_machine(ty_i16), none[str]),\n              t_i32 = mk_ty_full(ty_machine(ty_i32), none[str]),\n@@ -181,6 +189,7 @@ fn mk_type_store() -> @type_store {\n              t_char = mk_ty_full(ty_char, none[str]),\n              t_str = mk_ty_full(ty_str, none[str]),\n \n+             t_task = mk_ty_full(ty_task, none[str]),\n              t_native = mk_ty_full(ty_native, none[str]),\n              t_type = mk_ty_full(ty_type, none[str]),\n \n@@ -195,20 +204,140 @@ fn mk_ctxt() -> ctxt { ret rec(ts=mk_type_store()); }\n \n // Type constructors\n \n-// These are private constructors to this module. External users should always\n-// use the mk_foo() functions below.\n-fn gen_ty(ctxt cx, &sty st) -> t {\n-    ret gen_ty_full(cx, st, none[str]);\n-}\n-\n fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n     auto h = hash_type_info(st, cname);\n     auto magic = mk_magic(st);\n-    ret @rec(struct=st, cname=cname, magic=magic, hash=h);\n+\n+    let bool has_params = false;\n+    let bool has_bound_params = false;\n+    let bool has_vars = false;\n+    let bool has_locals = false;\n+\n+    fn derive_flags_t(&mutable bool has_params,\n+                      &mutable bool has_bound_params,\n+                      &mutable bool has_vars,\n+                      &mutable bool has_locals,\n+                      &t tt) {\n+        has_params = has_params || tt.has_params;\n+        has_bound_params = has_bound_params || tt.has_bound_params;\n+        has_vars = has_vars || tt.has_vars;\n+        has_locals = has_locals || tt.has_locals;\n+    }\n+\n+    fn derive_flags_mt(&mutable bool has_params,\n+                       &mutable bool has_bound_params,\n+                       &mutable bool has_vars,\n+                       &mutable bool has_locals,\n+                       &mt m) {\n+        derive_flags_t(has_params, has_bound_params,\n+                       has_vars, has_locals, m.ty);\n+    }\n+\n+\n+    fn derive_flags_arg(&mutable bool has_params,\n+                        &mutable bool has_bound_params,\n+                        &mutable bool has_vars,\n+                        &mutable bool has_locals,\n+                        &arg a) {\n+        derive_flags_t(has_params, has_bound_params,\n+                       has_vars, has_locals, a.ty);\n+    }\n+\n+    fn derive_flags_sig(&mutable bool has_params,\n+                        &mutable bool has_bound_params,\n+                        &mutable bool has_vars,\n+                        &mutable bool has_locals,\n+                        &vec[arg] args,\n+                        &t tt) {\n+        for (arg a in args) {\n+            derive_flags_arg(has_params, has_bound_params,\n+                             has_vars, has_locals, a);\n+        }\n+        derive_flags_t(has_params, has_bound_params,\n+                       has_vars, has_locals, tt);\n+    }\n+\n+    alt (st) {\n+        case (ty_param(_)) { has_params = true; }\n+        case (ty_bound_param(_)) { has_bound_params = true; }\n+        case (ty_var(_)) { has_vars = true; }\n+        case (ty_local(_)) { has_locals = true; }\n+        case (ty_tag(_, ?tys)) {\n+            for (t tt in tys) {\n+                derive_flags_t(has_params, has_bound_params,\n+                               has_vars, has_locals, tt);\n+            }\n+        }\n+        case (ty_box(?m)) {\n+            derive_flags_mt(has_params, has_bound_params,\n+                            has_vars, has_locals, m);\n+        }\n+\n+        case (ty_vec(?m)) {\n+            derive_flags_mt(has_params, has_bound_params,\n+                            has_vars, has_locals, m);\n+        }\n+\n+        case (ty_port(?tt)) {\n+            derive_flags_t(has_params, has_bound_params,\n+                           has_vars, has_locals, tt);\n+        }\n+\n+        case (ty_chan(?tt)) {\n+            derive_flags_t(has_params, has_bound_params,\n+                           has_vars, has_locals, tt);\n+        }\n+\n+        case (ty_tup(?mts)) {\n+            for (mt m in mts) {\n+                derive_flags_mt(has_params, has_bound_params,\n+                                has_vars, has_locals, m);\n+            }\n+        }\n+\n+        case (ty_rec(?flds)) {\n+            for (field f in flds) {\n+                derive_flags_mt(has_params, has_bound_params,\n+                                has_vars, has_locals, f.mt);\n+            }\n+        }\n+\n+        case (ty_fn(_, ?args, ?tt)) {\n+            derive_flags_sig(has_params, has_bound_params,\n+                             has_vars, has_locals, args, tt);\n+        }\n+\n+        case (ty_native_fn(_, ?args, ?tt)) {\n+            derive_flags_sig(has_params, has_bound_params,\n+                             has_vars, has_locals, args, tt);\n+        }\n+\n+        case (ty_obj(?meths)) {\n+            for (method m in meths) {\n+                derive_flags_sig(has_params, has_bound_params,\n+                                 has_vars, has_locals,\n+                                 m.inputs, m.output);\n+            }\n+        }\n+        case (_) { }\n+    }\n+\n+    ret @rec(struct=st, cname=cname, magic=magic, hash=h,\n+             has_params = has_params,\n+             has_bound_params = has_bound_params,\n+             has_vars = has_vars,\n+             has_locals = has_locals);\n }\n \n fn gen_ty_full(ctxt cx, &sty st, option.t[str] cname) -> t {\n     auto new_type = mk_ty_full(st, cname);\n+\n+    // Do not intern anything with locals or vars; it'll be nearly\n+    // single-use anyways, easier to regenerate than fill up the table.\n+    if (new_type.has_locals || new_type.has_vars) {\n+        ret new_type;\n+    }\n+\n     // Is it interned?\n     alt (cx.ts.others.find(new_type)) {\n         case (some[t](?typ)) {\n@@ -217,16 +346,23 @@ fn gen_ty_full(ctxt cx, &sty st, option.t[str] cname) -> t {\n         case (none[t]) {\n             // Nope. Insert it and return.\n             cx.ts.others.insert(new_type, new_type);\n+            // log_err \"added: \" + ty_to_str(tystore, new_type);\n             ret new_type;\n         }\n     }\n }\n \n-fn mk_nil(ctxt cx) -> t     { ret cx.ts.t_nil; }\n-fn mk_bool(ctxt cx) -> t    { ret cx.ts.t_bool; }\n-fn mk_int(ctxt cx) -> t     { ret cx.ts.t_int; }\n-fn mk_float(ctxt cx) -> t   { ret cx.ts.t_float; }\n-fn mk_uint(ctxt cx) -> t    { ret cx.ts.t_uint; }\n+// These are private constructors to this module. External users should always\n+// use the mk_foo() functions below.\n+fn gen_ty(ctxt cx, &sty st) -> t {\n+    ret gen_ty_full(cx, st, none[str]);\n+}\n+\n+fn mk_nil(ctxt cx) -> t          { ret cx.ts.t_nil; }\n+fn mk_bool(ctxt cx) -> t         { ret cx.ts.t_bool; }\n+fn mk_int(ctxt cx) -> t          { ret cx.ts.t_int; }\n+fn mk_float(ctxt cx) -> t        { ret cx.ts.t_float; }\n+fn mk_uint(ctxt cx) -> t         { ret cx.ts.t_uint; }\n \n fn mk_mach(ctxt cx, util.common.ty_mach tm) -> t {\n     alt (tm) {\n@@ -291,17 +427,12 @@ fn mk_obj(ctxt cx, vec[method] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n-fn mk_var(ctxt cx, int v) -> t    {\n-    let int i = _vec.len[t](cx.ts.t_vars) as int;\n-    while (i <= v) {\n-        cx.ts.t_vars += vec(mk_ty_full(ty_var(i), none[str]));\n-        i += 1;\n-    }\n-    ret cx.ts.t_vars.(v);\n+fn mk_var(ctxt cx, int v) -> t {\n+    ret mk_ty_full(ty_var(v), none[str]);\n }\n \n fn mk_local(ctxt cx, ast.def_id did) -> t {\n-    ret gen_ty(cx, ty_local(did));\n+    ret mk_ty_full(ty_local(did), none[str]);\n }\n \n fn mk_param(ctxt cx, uint n) -> t {\n@@ -414,6 +545,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     }\n \n     auto s = \"\";\n+\n     alt (struct(cx, typ)) {\n         case (ty_native)       { s += \"native\";                         }\n         case (ty_nil)          { s += \"()\";                             }\n@@ -1041,7 +1173,6 @@ fn hash_ty(&t typ) -> uint { ret typ.hash; }\n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n fn equal_type_structures(&sty a, &sty b) -> bool {\n-    fn equal_ty(t a, t b) -> bool { ret Box.ptr_eq[raw_t](a, b); }\n \n     fn equal_proto(ast.proto a, ast.proto b) -> bool {\n         alt (a) {\n@@ -1124,22 +1255,21 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n     }\n \n     fn equal_mt(&mt a, &mt b) -> bool {\n-        ret equal_mut(a.mut, b.mut) && equal_ty(a.ty, b.ty);\n+        ret equal_mut(a.mut, b.mut) && eq_ty(a.ty, b.ty);\n     }\n \n     fn equal_fn(vec[arg] args_a, t rty_a,\n                 vec[arg] args_b, t rty_b) -> bool {\n-        if (!equal_ty(rty_a, rty_b)) { ret false; }\n+        if (!eq_ty(rty_a, rty_b)) { ret false; }\n \n         auto len = _vec.len[arg](args_a);\n         if (len != _vec.len[arg](args_b)) { ret false; }\n+\n         auto i = 0u;\n         while (i < len) {\n             auto arg_a = args_a.(i); auto arg_b = args_b.(i);\n-            if (!equal_mode(arg_a.mode, arg_b.mode) ||\n-                    !equal_ty(arg_a.ty, arg_b.ty)) {\n-                ret false;\n-            }\n+            if (!equal_mode(arg_a.mode, arg_b.mode)) { ret false; }\n+            if (!eq_ty(arg_a.ty, arg_b.ty)) { ret false; }\n             i += 1u;\n         }\n         ret true;\n@@ -1209,7 +1339,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                     if (len != _vec.len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n-                        if (!equal_ty(tys_a.(i), tys_b.(i))) { ret false; }\n+                        if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n                         i += 1u;\n                     }\n                     ret true;\n@@ -1231,13 +1361,13 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         }\n         case (ty_port(?t_a)) {\n             alt (b) {\n-                case (ty_port(?t_b)) { ret equal_ty(t_a, t_b); }\n+                case (ty_port(?t_b)) { ret eq_ty(t_a, t_b); }\n                 case (_) { ret false; }\n             }\n         }\n         case (ty_chan(?t_a)) {\n             alt (b) {\n-                case (ty_chan(?t_b)) { ret equal_ty(t_a, t_b); }\n+                case (ty_chan(?t_b)) { ret eq_ty(t_a, t_b); }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1394,7 +1524,17 @@ fn eq_ty_full(&t a, &t b) -> bool {\n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(&t a, &t b) -> bool { ret Box.ptr_eq[raw_t](a, b); }\n+fn eq_ty(&t a, &t b) -> bool {\n+    let bool full = false;\n+    full = full || a.has_vars;\n+    full = full || a.has_locals;\n+    full = full || b.has_vars;\n+    full = full || b.has_locals;\n+    if (full) {\n+        ret eq_ty_full(a, b);\n+    }\n+    ret Box.ptr_eq[raw_t](a, b);\n+}\n \n \n fn ann_to_type(&ast.ann ann) -> t {\n@@ -1480,45 +1620,15 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n }\n \n fn type_contains_vars(ctxt cx, t typ) -> bool {\n-    fn checker(ctxt cx, @mutable bool flag, t typ) {\n-        alt (struct(cx, typ)) {\n-            case (ty_var(_)) { *flag = true; }\n-            case (_) { /* fall through */ }\n-        }\n-    }\n-\n-    let @mutable bool flag = @mutable false;\n-    auto f = bind checker(cx, flag, _);\n-    walk_ty(cx, f, typ);\n-    ret *flag;\n+    ret typ.has_vars;\n }\n \n fn type_contains_params(ctxt cx, t typ) -> bool {\n-    fn checker(ctxt cx, @mutable bool flag, t typ) {\n-        alt (struct(cx, typ)) {\n-            case (ty_param(_)) { *flag = true; }\n-            case (_) { /* fall through */ }\n-        }\n-    }\n-\n-    let @mutable bool flag = @mutable false;\n-    auto f = bind checker(cx, flag, _);\n-    walk_ty(cx, f, typ);\n-    ret *flag;\n+    ret typ.has_params;\n }\n \n fn type_contains_bound_params(ctxt cx, t typ) -> bool {\n-    fn checker(ctxt cx, @mutable bool flag, t typ) {\n-        alt (struct(cx, typ)) {\n-            case (ty_bound_param(_)) { *flag = true; }\n-            case (_) { /* fall through */ }\n-        }\n-    }\n-\n-    let @mutable bool flag = @mutable false;\n-    auto f = bind checker(cx, flag, _);\n-    walk_ty(cx, f, typ);\n-    ret *flag;\n+    ret typ.has_bound_params;\n }\n \n // Type accessors for substructures of types"}]}