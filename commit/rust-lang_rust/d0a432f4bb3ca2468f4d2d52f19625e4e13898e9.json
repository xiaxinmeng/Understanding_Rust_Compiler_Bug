{"sha": "d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYTQzMmY0YmIzY2EyNDY4ZjRkMmQ1MmYxOTYyNWU0ZTEzODk4ZTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-08T06:55:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-08T16:37:01Z"}, "message": "Don't export tyencode from the metadata module\n\nThis involves pulling the type_abbrev cache out of crate_ctxt", "tree": {"sha": "400c315fa3e6bc96bb5ea3c057ecc41b73705ac7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/400c315fa3e6bc96bb5ea3c057ecc41b73705ac7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "html_url": "https://github.com/rust-lang/rust/commit/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00d54018f15aa6ce6a913d0ae07d308f4b9ec5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/00d54018f15aa6ce6a913d0ae07d308f4b9ec5e5", "html_url": "https://github.com/rust-lang/rust/commit/00d54018f15aa6ce6a913d0ae07d308f4b9ec5e5"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "53af9b00dbc10680e2f317737e00ef44fa89b09e", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "patch": "@@ -9,6 +9,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::ebml;\n+import std::map;\n import syntax::ast::*;\n import common::*;\n import middle::trans::crate_ctxt;\n@@ -19,6 +20,11 @@ import front::attr;\n export encode_metadata;\n export encoded_ty;\n \n+type abbrev_map = map::hashmap[ty::t, tyencode::ty_abbrev];\n+\n+type encode_ctxt = rec(@crate_ctxt ccx,\n+                       abbrev_map type_abbrevs);\n+\n // Path table encoding\n fn encode_name(&ebml::writer ebml_w, &str name) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n@@ -175,27 +181,27 @@ fn encode_variant_id(&ebml::writer ebml_w, &def_id vid) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(&@crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n+fn encode_type(&@encode_ctxt ecx, &ebml::writer ebml_w, &ty::t typ) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n     auto ty_str_ctxt =\n-        @rec(ds=f, tcx=cx.tcx,\n-             abbrevs=tyencode::ac_use_abbrevs(cx.type_abbrevs));\n+        @rec(ds=f, tcx=ecx.ccx.tcx,\n+             abbrevs=tyencode::ac_use_abbrevs(ecx.type_abbrevs));\n     tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_symbol(&@crate_ctxt cx, &ebml::writer ebml_w,\n+fn encode_symbol(&@encode_ctxt ecx, &ebml::writer ebml_w,\n                  node_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.item_symbols.get(id)));\n+    ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(&@crate_ctxt cx, &ebml::writer ebml_w,\n+fn encode_discriminant(&@encode_ctxt ecx, &ebml::writer ebml_w,\n                        node_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(id)));\n+    ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -205,7 +211,7 @@ fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(&@crate_ctxt cx, &ebml::writer ebml_w,\n+fn encode_tag_variant_info(&@encode_ctxt ecx, &ebml::writer ebml_w,\n                            node_id id, &variant[] variants,\n                            &mutable vec[tup(int, uint)] index,\n                            &ty_param[] ty_params) {\n@@ -215,25 +221,27 @@ fn encode_tag_variant_info(&@crate_ctxt cx, &ebml::writer ebml_w,\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n-        encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, variant.node.id));\n+        encode_type(ecx, ebml_w,\n+                    node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n         if (ivec::len[variant_arg](variant.node.args) > 0u) {\n-            encode_symbol(cx, ebml_w, variant.node.id);\n+            encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n-        encode_discriminant(cx, ebml_w, variant.node.id);\n+        encode_discriminant(ecx, ebml_w, variant.node.id);\n         encode_type_param_count(ebml_w, ty_params);\n         ebml::end_tag(ebml_w);\n     }\n }\n \n-fn encode_info_for_item(@crate_ctxt cx, &ebml::writer ebml_w,\n+fn encode_info_for_item(@encode_ctxt ecx, &ebml::writer ebml_w,\n                         @item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n         case (item_const(_, _)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'c' as u8);\n-            encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, item.id));\n-            encode_symbol(cx, ebml_w, item.id);\n+            encode_type(ecx, ebml_w,\n+                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n+            encode_symbol(ecx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n         case (item_fn(?fd, ?tps)) {\n@@ -243,8 +251,9 @@ fn encode_info_for_item(@crate_ctxt cx, &ebml::writer ebml_w,\n                                   case (pure_fn) { 'p' }\n                                   case (impure_fn) { 'f' } } as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, item.id));\n-            encode_symbol(cx, ebml_w, item.id);\n+            encode_type(ecx, ebml_w,\n+                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n+            encode_symbol(ecx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n         case (item_mod(_)) {\n@@ -264,99 +273,102 @@ fn encode_info_for_item(@crate_ctxt cx, &ebml::writer ebml_w,\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, item.id));\n+            encode_type(ecx, ebml_w,\n+                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n             ebml::end_tag(ebml_w);\n         }\n         case (item_tag(?variants, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, item.id));\n+            encode_type(ecx, ebml_w,\n+                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n             for (variant v in variants) {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n             ebml::end_tag(ebml_w);\n-            encode_tag_variant_info(cx, ebml_w, item.id, variants, index,\n+            encode_tag_variant_info(ecx, ebml_w, item.id, variants, index,\n                                     tps);\n         }\n         case (item_res(_, _, ?tps, ?ctor_id)) {\n-            auto fn_ty = node_id_to_monotype(cx.tcx, ctor_id);\n+            auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n-            encode_symbol(cx, ebml_w, item.id);\n+            encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+            encode_symbol(ecx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n \n             index += [tup(ctor_id, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, fn_ty);\n-            encode_symbol(cx, ebml_w, ctor_id);\n+            encode_type(ecx, ebml_w, fn_ty);\n+            encode_symbol(ecx, ebml_w, ctor_id);\n             ebml::end_tag(ebml_w);\n         }\n         case (item_obj(_, ?tps, ?ctor_id)) {\n-            auto fn_ty = node_id_to_monotype(cx.tcx, ctor_id);\n+            auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n+            encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n             ebml::end_tag(ebml_w);\n \n             index += [tup(ctor_id, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, fn_ty);\n-            encode_symbol(cx, ebml_w, ctor_id);\n+            encode_type(ecx, ebml_w, fn_ty);\n+            encode_symbol(ecx, ebml_w, ctor_id);\n             ebml::end_tag(ebml_w);\n         }\n     }\n }\n \n-fn encode_info_for_native_item(&@crate_ctxt cx, &ebml::writer ebml_w,\n+fn encode_info_for_native_item(&@encode_ctxt ecx, &ebml::writer ebml_w,\n                                &@native_item nitem) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n         case (native_item_ty) {\n             encode_def_id(ebml_w, local_def(nitem.id));\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(cx, ebml_w,\n-                        ty::mk_native(cx.tcx, local_def(nitem.id)));\n+            encode_type(ecx, ebml_w,\n+                        ty::mk_native(ecx.ccx.tcx, local_def(nitem.id)));\n         }\n         case (native_item_fn(_, _, ?tps)) {\n             encode_def_id(ebml_w, local_def(nitem.id));\n             encode_kind(ebml_w, 'F' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, nitem.id));\n-            encode_symbol(cx, ebml_w, nitem.id);\n+            encode_type(ecx, ebml_w,\n+                        node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n+            encode_symbol(ecx, ebml_w, nitem.id);\n         }\n     }\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@crate_ctxt cx, &ebml::writer ebml_w) ->\n+fn encode_info_for_items(&@encode_ctxt ecx, &ebml::writer ebml_w) ->\n    vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n     for each (@tup(node_id, middle::ast_map::ast_node) kvp in\n-              cx.ast_map.items()) {\n+              ecx.ccx.ast_map.items()) {\n         alt (kvp._1) {\n             case (middle::ast_map::node_item(?i)) {\n                 index += [tup(kvp._0, ebml_w.writer.tell())];\n-                encode_info_for_item(cx, ebml_w, i, index);\n+                encode_info_for_item(ecx, ebml_w, i, index);\n             }\n             case (middle::ast_map::node_native_item(?i)) {\n                 index += [tup(kvp._0, ebml_w.writer.tell())];\n-                encode_info_for_native_item(cx, ebml_w, i);\n+                encode_info_for_native_item(ecx, ebml_w, i);\n             }\n             case (_) {}\n         }\n@@ -460,19 +472,19 @@ fn encode_attributes(&ebml::writer ebml_w, &vec[attribute] attrs) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(&@crate_ctxt cx,\n+fn synthesize_crate_attrs(&@encode_ctxt ecx,\n                           &@crate crate) -> vec[attribute] {\n \n-    fn synthesize_link_attr(&@crate_ctxt cx, &(@meta_item)[] items)\n+    fn synthesize_link_attr(&@encode_ctxt ecx, &(@meta_item)[] items)\n             -> attribute {\n \n-        assert cx.link_meta.name != \"\";\n-        assert cx.link_meta.vers != \"\";\n+        assert ecx.ccx.link_meta.name != \"\";\n+        assert ecx.ccx.link_meta.vers != \"\";\n \n         auto name_item = attr::mk_name_value_item_str(\"name\",\n-                                                      cx.link_meta.name);\n+                                                      ecx.ccx.link_meta.name);\n         auto vers_item = attr::mk_name_value_item_str(\"vers\",\n-                                                      cx.link_meta.vers);\n+                                                      ecx.ccx.link_meta.vers);\n \n         auto other_items = {\n             auto tmp = attr::remove_meta_items_by_name(items, \"name\");\n@@ -494,26 +506,30 @@ fn synthesize_crate_attrs(&@crate_ctxt cx,\n             alt (attr.node.value.node) {\n                 case (meta_list(?n, ?l)) {\n                     found_link_attr = true;\n-                    [synthesize_link_attr(cx, l)]\n+                    [synthesize_link_attr(ecx, l)]\n                 }\n                 case (_) { [attr] }\n             }\n         }\n     }\n \n     if (!found_link_attr) {\n-        attrs += [synthesize_link_attr(cx, ~[])];\n+        attrs += [synthesize_link_attr(ecx, ~[])];\n     }\n \n     ret attrs;\n }\n \n fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n+\n+    auto abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n+    auto ecx = @rec(ccx = cx, type_abbrevs = abbrevs);\n+\n     auto string_w = io::string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n     auto ebml_w = ebml::create_writer(buf_w);\n \n-    auto crate_attrs = synthesize_crate_attrs(cx, crate);\n+    auto crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n     // Encode and index the paths.\n \n@@ -527,7 +543,7 @@ fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n     // Encode and index the items.\n \n     ebml::start_tag(ebml_w, tag_items);\n-    auto items_index = encode_info_for_items(cx, ebml_w);\n+    auto items_index = encode_info_for_items(ecx, ebml_w);\n     auto int_writer = write_int;\n     auto item_hasher = hash_node_id;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n@@ -544,7 +560,7 @@ fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n fn encoded_ty(&ty::ctxt tcx, &ty::t t) -> str {\n     auto cx = @rec(ds = def_to_str,\n                    tcx = tcx,\n-                   abbrevs = metadata::tyencode::ac_no_abbrevs);\n+                   abbrevs = tyencode::ac_no_abbrevs);\n     auto sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);\n     ret sw.get_str();"}, {"sha": "9e9d4a59fdc5f162d283a7b9b8e4b4c700ae88de", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "patch": "@@ -63,7 +63,6 @@ import link::mangle_internal_name_by_seq;\n import link::mangle_internal_name_by_path;\n import link::mangle_internal_name_by_path_and_seq;\n import link::mangle_exported_name;\n-import metadata::tyencode;\n import metadata::creader;\n import metadata::csearch;\n import metadata::cstore;\n@@ -147,7 +146,6 @@ type crate_ctxt =\n         namegen names,\n         std::sha1::sha1 sha,\n         hashmap[ty::t, str] type_sha1s,\n-        hashmap[ty::t, tyencode::ty_abbrev] type_abbrevs,\n         hashmap[ty::t, str] type_short_names,\n         ty::ctxt tcx,\n         stats stats,\n@@ -9318,7 +9316,6 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     auto tydescs = map::mk_hashmap[ty::t, @tydesc_info](hasher, eqer);\n     auto lltypes = map::mk_hashmap[ty::t, TypeRef](hasher, eqer);\n     auto sha1s = map::mk_hashmap[ty::t, str](hasher, eqer);\n-    auto abbrevs = map::mk_hashmap[ty::t, tyencode::ty_abbrev](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto sha = std::sha1::mk_sha1();\n     auto ccx =\n@@ -9346,7 +9343,6 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n              names=namegen(0),\n              sha=sha,\n              type_sha1s=sha1s,\n-             type_abbrevs=abbrevs,\n              type_short_names=short_names,\n              tcx=tcx,\n              stats=rec(mutable n_static_tydescs=0u,"}, {"sha": "a76602ecda60e9933bc3d900c30bf19bc6d4e72e", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d0a432f4bb3ca2468f4d2d52f19625e4e13898e9/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=d0a432f4bb3ca2468f4d2d52f19625e4e13898e9", "patch": "@@ -77,7 +77,6 @@ mod back {\n }\n \n mod metadata {\n-    export tyencode;\n     export encoder;\n     export creader;\n     export cstore;"}]}