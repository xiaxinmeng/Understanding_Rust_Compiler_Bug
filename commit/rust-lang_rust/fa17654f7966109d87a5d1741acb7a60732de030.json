{"sha": "fa17654f7966109d87a5d1741acb7a60732de030", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMTc2NTRmNzk2NjEwOWQ4N2E1ZDE3NDFhY2I3YTYwNzMyZGUwMzA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-04-11T13:06:42Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-25T08:07:01Z"}, "message": "Make `ConstValue::Slice` solely take `[u8]` and `str`", "tree": {"sha": "1b30cb5b5507abcbaff8400113bf495341fee9a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b30cb5b5507abcbaff8400113bf495341fee9a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa17654f7966109d87a5d1741acb7a60732de030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa17654f7966109d87a5d1741acb7a60732de030", "html_url": "https://github.com/rust-lang/rust/commit/fa17654f7966109d87a5d1741acb7a60732de030", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa17654f7966109d87a5d1741acb7a60732de030/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6ac1fa14b8a753261c19f2afbc62cabdd894d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6ac1fa14b8a753261c19f2afbc62cabdd894d2", "html_url": "https://github.com/rust-lang/rust/commit/af6ac1fa14b8a753261c19f2afbc62cabdd894d2"}], "stats": {"total": 319, "additions": 157, "deletions": 162}, "files": [{"sha": "8f52ef7a3f3a4c1d0ad8b827fcda24585aa67b1e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n             ConstValue::Param(_) |\n             ConstValue::Scalar(_) |\n-            ConstValue::Slice(..) |\n+            ConstValue::Slice { .. } |\n             ConstValue::ByRef(..) |\n             ConstValue::Unevaluated(..) => {}\n         }"}, {"sha": "72545f23f8e2bf3ac67a39ebef68f6afd60c0e76", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -35,14 +35,12 @@ pub enum ConstValue<'tcx> {\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n     Scalar(Scalar),\n \n-    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`,\n-    /// etc.).\n-    ///\n-    /// Empty slices don't necessarily have an address backed by an `AllocId`, thus we also need to\n-    /// enable integer pointers. The `Scalar` type covers exactly those two cases. While we could\n-    /// create dummy-`AllocId`s, the additional code effort for the conversions doesn't seem worth\n-    /// it.\n-    Slice(Scalar, u64),\n+    /// Used only for `&[u8]` and `&str`\n+    Slice {\n+        data: &'tcx Allocation,\n+        start: usize,\n+        end: usize,\n+    },\n \n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n@@ -54,7 +52,7 @@ pub enum ConstValue<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ConstValue<'_>, 40);\n+static_assert_size!(ConstValue<'_>, 32);\n \n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n@@ -65,7 +63,7 @@ impl<'tcx> ConstValue<'tcx> {\n             ConstValue::Placeholder(_) |\n             ConstValue::ByRef(..) |\n             ConstValue::Unevaluated(..) |\n-            ConstValue::Slice(..) => None,\n+            ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n         }\n     }\n@@ -79,14 +77,6 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn try_to_ptr(&self) -> Option<Pointer> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n-\n-    #[inline]\n-    pub fn new_slice(\n-        val: Scalar,\n-        len: u64,\n-    ) -> Self {\n-        ConstValue::Slice(val, len)\n-    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a"}, {"sha": "793d3d8ec6df33249b6ef08774929d6a9364a3ab", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -1567,21 +1567,27 @@ define_print_and_forward_display! {\n                 => p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap())),\n             (_, ty::FnDef(did, _)) => p!(write(\"{}\", cx.tcx().def_path_str(*did))),\n             (\n-                ConstValue::Slice(place, len),\n-                ty::Ref(_, &ty::TyS { sty: ty::Str, .. }, _),\n+                ConstValue::Slice { data, start, end },\n+                ty::Ref(_, slice_ty, _),\n             ) => {\n-                match (place, len) {\n-                    (_, 0) => \"\",\n-                    (Scalar::Ptr(ptr), len) => {\n-                        let alloc = cx.tcx().alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                        assert_eq!(len as usize as u64, len);\n-                        let slice =\n-                            &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                        let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                let slice = &data.bytes[start..end];\n+                match slice_ty.sty {\n+                    ty::Str => {\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n                         p!(write(\"{:?}\", s))\n                     },\n+                    ty::Slice(elem) if elem == cx.tcx().types.u8 => {\n+                        p!(write(\"b\\\"\"));\n+                        for &c in slice {\n+                            for e in std::ascii::escape_default(c) {\n+                                p!(write(\"{}\", e));\n+                            }\n+                        }\n+                        p!(write(\"\\\"\"));\n+                    },\n                     _ => bug!(\"invalid slice: {:#?}\", self),\n-                };\n+                }\n             },\n             _ => p!(write(\"{:?} : \", self.val), print(self.ty)),\n         }"}, {"sha": "0daa567052d5662ec881cad2b4c366f30b6c5ca4", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -1345,7 +1345,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),\n             ConstValue::Scalar(a) => ConstValue::Scalar(a),\n-            ConstValue::Slice(a, b) => ConstValue::Slice(a, b),\n+            ConstValue::Slice { data, start, end } => ConstValue::Slice { data, start, end },\n             ConstValue::Unevaluated(did, substs)\n                 => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n         }\n@@ -1358,7 +1358,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n             ConstValue::Param(p) => p.visit_with(visitor),\n             ConstValue::Placeholder(_) => false,\n             ConstValue::Scalar(_) => false,\n-            ConstValue::Slice(..) => false,\n+            ConstValue::Slice { .. } => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "a2b2fc7a4451a23eba0d5e6bffc3c2e039e5c671", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -2207,7 +2207,7 @@ pub struct Const<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Const<'_>, 48);\n+static_assert_size!(Const<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]"}, {"sha": "ec471a1323eab917dd548d77c968fadb1b5d1621", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -1,7 +1,7 @@\n-use rustc::mir::interpret::{ConstValue, ErrorHandled};\n+use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n use rustc::mir;\n use rustc::ty;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n \n use crate::base;\n use crate::MemFlags;\n@@ -92,17 +92,21 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 );\n                 OperandValue::Immediate(llval)\n             },\n-            ConstValue::Slice(a, b) => {\n+            ConstValue::Slice { data, start, end } => {\n                 let a_scalar = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n+                let a = Scalar::from(Pointer::new(\n+                    bx.tcx().alloc_map.lock().allocate(data),\n+                    Size::from_bytes(start as u64),\n+                )).into();\n                 let a_llval = bx.scalar_to_backend(\n                     a,\n                     a_scalar,\n                     bx.scalar_pair_element_backend_type(layout, 0, true),\n                 );\n-                let b_llval = bx.const_usize(b);\n+                let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(ptr, alloc) => {"}, {"sha": "776d4c242415a494dfc72c5d9183b139d627fbf0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -5,6 +5,7 @@ use std::error::Error;\n use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n+use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n@@ -89,7 +90,14 @@ fn op_to_const<'tcx>(\n     // We do not normalize just any data.  Only non-union scalars and slices.\n     let normalize = match op.layout.abi {\n         layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n-        layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n+            ty::Ref(_, inner, _) => match inner.sty {\n+                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n+                ty::Str => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        },\n         _ => false,\n     };\n     let normalized_op = if normalize {\n@@ -101,8 +109,26 @@ fn op_to_const<'tcx>(\n         Ok(mplace) => return mplace_to_const(ecx, mplace),\n         Err(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef().unwrap()),\n-        Err(Immediate::ScalarPair(a, b)) =>\n-            ConstValue::Slice(a.not_undef().unwrap(), b.to_usize(ecx).unwrap()),\n+        Err(Immediate::ScalarPair(a, b)) => {\n+            let (data, start) = match a.not_undef().unwrap() {\n+                Scalar::Ptr(ptr) => (\n+                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    ptr.offset.bytes(),\n+                ),\n+                Scalar::Bits { .. } => (\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\", ())),\n+                    0,\n+                ),\n+            };\n+            let len = b.to_usize(&ecx.tcx.tcx).unwrap();\n+            let start = start.try_into().unwrap();\n+            let len: usize = len.try_into().unwrap();\n+            ConstValue::Slice {\n+                data,\n+                start,\n+                end: start + len,\n+            }\n+        },\n     };\n     ecx.tcx.mk_const(ty::Const { val, ty: op.layout.ty })\n }"}, {"sha": "d2c86d36238e1eeb76358dfe8e9cb0cd32f71a69", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -33,14 +33,16 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_bytes(s.as_bytes());\n-            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64)\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         },\n         LitKind::Err(ref s) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_bytes(s.as_bytes());\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = tcx.intern_const_alloc(allocation);\n             return Ok(tcx.mk_const(ty::Const {\n-                val: ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64),\n+                val: ConstValue::Slice{ data: allocation, start: 0, end: s.len() },\n                 ty: tcx.types.err,\n             }));\n         },"}, {"sha": "29e9c425685e858bf9e3ac31b28dd7343b438bd8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 47, "deletions": 76, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar, truncate};\n+use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -186,6 +186,7 @@ use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n use std::u128;\n+use std::convert::TryInto;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n@@ -221,16 +222,17 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n-                ConstValue::Slice(\n-                    Scalar::Ptr(p),\n-                    n.val.try_to_scalar()\n-                        .unwrap()\n-                        .to_usize(&self.tcx)\n-                        .unwrap(),\n-                )\n+                ConstValue::Slice {\n+                    data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                    start: p.offset.bytes().try_into().unwrap(),\n+                    end: n.unwrap_usize(self.tcx).try_into().unwrap(),\n+                }\n             },\n             // fat pointers stay the same\n-            (ConstValue::Slice(..), _, _) => val,\n+            | (ConstValue::Slice { .. }, _, _)\n+            | (_, ty::Slice(_), ty::Slice(_))\n+            | (_, ty::Str, ty::Str)\n+            => val,\n             // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n             _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n         }\n@@ -786,9 +788,9 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                         max_fixed_len,\n                         n.unwrap_usize(cx.tcx),\n                     ),\n-                    (ConstValue::Slice(_, n), ty::Slice(_)) => max_fixed_len = cmp::max(\n+                    (ConstValue::Slice{ start, end, .. }, ty::Slice(_)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n-                        n,\n+                        (end - start) as u64,\n                     ),\n                     _ => {},\n                 }\n@@ -1431,42 +1433,17 @@ fn slice_pat_covered_by_const<'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n         (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n+            assert_eq!(*t, tcx.types.u8);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n-        // a slice fat pointer to a zero length slice\n-        (ConstValue::Slice(Scalar::Bits { .. }, 0), ty::Slice(t)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n-            &[]\n-        },\n-        //\n-        (ConstValue::Slice(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n-            tcx.alloc_map\n-                .lock()\n-                .unwrap_memory(ptr.alloc_id)\n-                .get_bytes(&tcx, ptr, Size::from_bytes(n))\n-                .unwrap()\n+        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n+            assert_eq!(*t, tcx.types.u8);\n+            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n+            data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n         },\n+        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n+        (_, ty::Slice(_)) => return Ok(false),\n         _ => bug!(\n             \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n             const_val, prefix, slice, suffix,\n@@ -1774,11 +1751,12 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, n, ty) = match value.ty.sty {\n+                    let (alloc, offset, n, ty) = match value.ty.sty {\n                         ty::Array(t, n) => {\n                             match value.val {\n                                 ConstValue::ByRef(ptr, alloc) => (\n-                                    Some((ptr, alloc)),\n+                                    alloc,\n+                                    ptr.offset,\n                                     n.unwrap_usize(cx.tcx),\n                                     t,\n                                 ),\n@@ -1790,14 +1768,16 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         },\n                         ty::Slice(t) => {\n                             match value.val {\n-                                ConstValue::Slice(ptr, n) => (\n-                                    ptr.to_ptr().ok().map(|ptr| (\n-                                        ptr,\n-                                        cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                                    )),\n-                                    n,\n+                                ConstValue::Slice { data, start, end } => (\n+                                    data,\n+                                    Size::from_bytes(start as u64),\n+                                    (end - start) as u64,\n                                     t,\n                                 ),\n+                                ConstValue::ByRef(..) => {\n+                                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n+                                    return None;\n+                                },\n                                 _ => span_bug!(\n                                     pat.span,\n                                     \"slice pattern constant must be scalar pair but is {:?}\",\n@@ -1814,31 +1794,22 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     };\n                     if wild_patterns.len() as u64 == n {\n                         // convert a constant slice/array pattern to a list of patterns.\n-                        match (n, opt_ptr) {\n-                            (0, _) => Some(SmallVec::new()),\n-                            (_, Some((ptr, alloc))) => {\n-                                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                                (0..n).map(|i| {\n-                                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                                    let scalar = alloc.read_scalar(\n-                                        &cx.tcx, ptr, layout.size,\n-                                    ).ok()?;\n-                                    let scalar = scalar.not_undef().ok()?;\n-                                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                                    let pattern = Pattern {\n-                                        ty,\n-                                        span: pat.span,\n-                                        kind: box PatternKind::Constant { value },\n-                                    };\n-                                    Some(&*cx.pattern_arena.alloc(pattern))\n-                                }).collect()\n-                            },\n-                            (_, None) => span_bug!(\n-                                pat.span,\n-                                \"non zero length slice with const-val {:?}\",\n-                                value,\n-                            ),\n-                        }\n+                        let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+                        let ptr = Pointer::new(AllocId(0), offset);\n+                        (0..n).map(|i| {\n+                            let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                            let scalar = alloc.read_scalar(\n+                                &cx.tcx, ptr, layout.size,\n+                            ).ok()?;\n+                            let scalar = scalar.not_undef().ok()?;\n+                            let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                            let pattern = Pattern {\n+                                ty,\n+                                span: pat.span,\n+                                kind: box PatternKind::Constant { value },\n+                            };\n+                            Some(&*cx.pattern_arena.alloc(pattern))\n+                        }).collect()\n                     } else {\n                         None\n                     }"}, {"sha": "1c47f850ddb75d051a382ea3b22d50d9ebeccdc1", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -12,11 +12,11 @@ use crate::hair::constant::*;\n \n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n-use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n+use rustc::mir::interpret::{GlobalId, ConstValue, sign_extend, AllocId, Pointer};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n-use rustc::ty::layout::VariantIdx;\n+use rustc::ty::layout::{VariantIdx, Size};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -1293,22 +1293,25 @@ pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n     if let ty::Str = ty.value.sty {\n         match (a.val, b.val) {\n             (\n-                ConstValue::Slice(\n-                    Scalar::Ptr(ptr_a),\n-                    len_a,\n-                ),\n-                ConstValue::Slice(\n-                    Scalar::Ptr(ptr_b),\n-                    len_b,\n-                ),\n-            ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                if len_a == len_b {\n-                    let map = tcx.alloc_map.lock();\n-                    let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n-                    let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n-                    if alloc_a.bytes.len() as u64 == len_a {\n-                        return from_bool(alloc_a == alloc_b);\n-                    }\n+                ConstValue::Slice { data: alloc_a, start: offset_a, end: end_a },\n+                ConstValue::Slice { data: alloc_b, start: offset_b, end: end_b },\n+            ) => {\n+                let len_a = end_a - offset_a;\n+                let len_b = end_b - offset_b;\n+                let a = alloc_a.get_bytes(\n+                    &tcx,\n+                    // invent a pointer, only the offset is relevant anyway\n+                    Pointer::new(AllocId(0), Size::from_bytes(offset_a as u64)),\n+                    Size::from_bytes(len_a as u64),\n+                );\n+                let b = alloc_b.get_bytes(\n+                    &tcx,\n+                    // invent a pointer, only the offset is relevant anyway\n+                    Pointer::new(AllocId(0), Size::from_bytes(offset_b as u64)),\n+                    Size::from_bytes(len_b as u64),\n+                );\n+                if let (Ok(a), Ok(b)) = (a, b) {\n+                    return from_bool(a == b);\n                 }\n             }\n             _ => (),"}, {"sha": "407622dc2599b6a78de69202a911fc481af13e87", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -533,11 +533,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n                 )\n             },\n-            ConstValue::Slice(a, b) =>\n+            ConstValue::Slice { data, start, end } =>\n                 Operand::Immediate(Immediate::ScalarPair(\n-                    a.with_default_tag().into(),\n-                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size)\n-                        .with_default_tag().into(),\n+                    Scalar::from(Pointer::new(\n+                        self.tcx.alloc_map.lock().allocate(data),\n+                        Size::from_bytes(start as u64),\n+                    )).with_default_tag().into(),\n+                    Scalar::from_uint(\n+                        (end - start) as u64,\n+                        self.tcx.data_layout.pointer_size,\n+                    ).with_default_tag().into(),\n                 )),\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),"}, {"sha": "b90db7646d4929f1be224ccc83f112cfefbac787", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -1255,10 +1255,10 @@ fn collect_const<'a, 'tcx>(\n     debug!(\"visiting const {:?}\", constant);\n \n     match constant.val {\n-        ConstValue::Slice(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(_ptr, alloc) => {\n+        ConstValue::Slice { data: alloc, start: _, end: _ } |\n+        ConstValue::ByRef(_, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "a36c550f530a9a0f90113cb0f112b4db701a1532", "filename": "src/test/ui/pattern/slice-pattern-const-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -6,13 +6,13 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {"}, {"sha": "0c7401269dfc744c3f4ac02dee90ff2b4a4e4f0a", "filename": "src/test/ui/pattern/slice-pattern-const-2.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa17654f7966109d87a5d1741acb7a60732de030/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa17654f7966109d87a5d1741acb7a60732de030/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr?ref=fa17654f7966109d87a5d1741acb7a60732de030", "patch": "@@ -1,26 +1,14 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:9:9\n+  --> $DIR/slice-pattern-const-2.rs:28:9\n    |\n-LL |         [4, 5, 6, 7] => (),\n-   |         ^^^^^^^^^^^^\n+LL |         FOO => (),\n+   |         ^^^\n    |\n note: lint level defined here\n   --> $DIR/slice-pattern-const-2.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:15:9\n-   |\n-LL |         [4, 5, 6, 7] => (),\n-   |         ^^^^^^^^^^^^\n-\n-error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:28:9\n-   |\n-LL |         FOO => (),\n-   |         ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}]}