{"sha": "e63315b8f189396cf556f21d4ca27ae4281d17d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MzMxNWI4ZjE4OTM5NmNmNTU2ZjIxZDRjYTI3YWU0MjgxZDE3ZDc=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-09T03:23:51Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-10T13:35:52Z"}, "message": "add record pat missing field diagnostic", "tree": {"sha": "48d6f6bae33a58d378939f766a1725c73bac7f2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d6f6bae33a58d378939f766a1725c73bac7f2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e63315b8f189396cf556f21d4ca27ae4281d17d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e63315b8f189396cf556f21d4ca27ae4281d17d7", "html_url": "https://github.com/rust-lang/rust/commit/e63315b8f189396cf556f21d4ca27ae4281d17d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e63315b8f189396cf556f21d4ca27ae4281d17d7/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "176f7f61175bc433c56083a758bd7a28a8ae31f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/176f7f61175bc433c56083a758bd7a28a8ae31f8", "html_url": "https://github.com/rust-lang/rust/commit/176f7f61175bc433c56083a758bd7a28a8ae31f8"}], "stats": {"total": 216, "additions": 159, "deletions": 57}, "files": [{"sha": "226fb453487e218e03bec8bc57dedf7b0d3fe513", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -255,7 +255,7 @@ impl SourceAnalyzer {\n             _ => return None,\n         };\n \n-        let (variant, missing_fields) =\n+        let (variant, missing_fields, _exhaustive) =\n             record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;\n         let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n         Some(res)"}, {"sha": "0855c1d3a250f1951959dcc076d6b21bde481d2c", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -668,7 +668,9 @@ impl ExprCollector<'_> {\n                 });\n                 fields.extend(iter);\n \n-                Pat::Record { path, args: fields }\n+                let ellipsis = record_field_pat_list.dotdot_token().is_some();\n+\n+                Pat::Record { path, args: fields, ellipsis }\n             }\n             ast::Pat::SlicePat(p) => {\n                 let SlicePatComponents { prefix, slice, suffix } = p.components();"}, {"sha": "e11bdf3ec21f7f6bad0260e6ebdc6bd551e9ffd7", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -376,35 +376,14 @@ pub enum Pat {\n     Wild,\n     Tuple(Vec<PatId>),\n     Or(Vec<PatId>),\n-    Record {\n-        path: Option<Path>,\n-        args: Vec<RecordFieldPat>,\n-        // FIXME: 'ellipsis' option\n-    },\n-    Range {\n-        start: ExprId,\n-        end: ExprId,\n-    },\n-    Slice {\n-        prefix: Vec<PatId>,\n-        slice: Option<PatId>,\n-        suffix: Vec<PatId>,\n-    },\n+    Record { path: Option<Path>, args: Vec<RecordFieldPat>, ellipsis: bool },\n+    Range { start: ExprId, end: ExprId },\n+    Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n     Path(Path),\n     Lit(ExprId),\n-    Bind {\n-        mode: BindingAnnotation,\n-        name: Name,\n-        subpat: Option<PatId>,\n-    },\n-    TupleStruct {\n-        path: Option<Path>,\n-        args: Vec<PatId>,\n-    },\n-    Ref {\n-        pat: PatId,\n-        mutability: Mutability,\n-    },\n+    Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n+    TupleStruct { path: Option<Path>, args: Vec<PatId> },\n+    Ref { pat: PatId, mutability: Mutability },\n }\n \n impl Pat {"}, {"sha": "3f18acf1dacab5146399e108836883c845daeea2", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -62,6 +62,29 @@ impl AstDiagnostic for MissingFields {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct MissingPatFields {\n+    pub file: HirFileId,\n+    pub field_list: AstPtr<ast::RecordFieldPatList>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingPatFields {\n+    fn message(&self) -> String {\n+        let mut buf = String::from(\"Missing structure fields:\\n\");\n+        for field in &self.missed_fields {\n+            format_to!(buf, \"- {}\", field);\n+        }\n+        buf\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.field_list.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MissingMatchArms {\n     pub file: HirFileId,"}, {"sha": "a7c8d74abde4994ed2619e56448934b7783e2a2d", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 85, "deletions": 27, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -9,7 +9,7 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr},\n+    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields},\n     utils::variant_data,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n     _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n@@ -49,39 +49,97 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             if let Some((variant_def, missed_fields, true)) =\n                 record_literal_missing_fields(db, &self.infer, id, expr)\n             {\n-                // XXX: only look at source_map if we do have missing fields\n-                let (_, source_map) = db.body_with_source_map(self.func.into());\n-\n-                if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-                    if let Some(expr) = source_ptr.value.left() {\n-                        let root = source_ptr.file_syntax(db.upcast());\n-                        if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                            if let Some(field_list) = record_lit.record_field_list() {\n-                                let variant_data = variant_data(db.upcast(), variant_def);\n-                                let missed_fields = missed_fields\n-                                    .into_iter()\n-                                    .map(|idx| variant_data.fields()[idx].name.clone())\n-                                    .collect();\n-                                self.sink.push(MissingFields {\n-                                    file: source_ptr.file_id,\n-                                    field_list: AstPtr::new(&field_list),\n-                                    missed_fields,\n-                                })\n-                            }\n-                        }\n-                    }\n-                }\n+                self.create_record_literal_missing_fields_diagnostic(\n+                    id,\n+                    db,\n+                    variant_def,\n+                    missed_fields,\n+                );\n             }\n             if let Expr::Match { expr, arms } = expr {\n                 self.validate_match(id, *expr, arms, db, self.infer.clone());\n             }\n         }\n+        for (id, pat) in body.pats.iter() {\n+            if let Some((variant_def, missed_fields, true)) =\n+                record_pattern_missing_fields(db, &self.infer, id, pat)\n+            {\n+                self.create_record_pattern_missing_fields_diagnostic(\n+                    id,\n+                    db,\n+                    variant_def,\n+                    missed_fields,\n+                );\n+            }\n+        }\n         let body_expr = &body[body.body_expr];\n         if let Expr::Block { tail: Some(t), .. } = body_expr {\n             self.validate_results_in_tail_expr(body.body_expr, *t, db);\n         }\n     }\n \n+    fn create_record_literal_missing_fields_diagnostic(\n+        &mut self,\n+        id: ExprId,\n+        db: &dyn HirDatabase,\n+        variant_def: VariantId,\n+        missed_fields: Vec<LocalStructFieldId>,\n+    ) {\n+        // XXX: only look at source_map if we do have missing fields\n+        let (_, source_map) = db.body_with_source_map(self.func.into());\n+\n+        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.value.left() {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                    if let Some(field_list) = record_lit.record_field_list() {\n+                        let variant_data = variant_data(db.upcast(), variant_def);\n+                        let missed_fields = missed_fields\n+                            .into_iter()\n+                            .map(|idx| variant_data.fields()[idx].name.clone())\n+                            .collect();\n+                        self.sink.push(MissingFields {\n+                            file: source_ptr.file_id,\n+                            field_list: AstPtr::new(&field_list),\n+                            missed_fields,\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn create_record_pattern_missing_fields_diagnostic(\n+        &mut self,\n+        id: PatId,\n+        db: &dyn HirDatabase,\n+        variant_def: VariantId,\n+        missed_fields: Vec<LocalStructFieldId>,\n+    ) {\n+        // XXX: only look at source_map if we do have missing fields\n+        let (_, source_map) = db.body_with_source_map(self.func.into());\n+\n+        if let Ok(source_ptr) = source_map.pat_syntax(id) {\n+            if let Some(expr) = source_ptr.value.left() {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n+                    if let Some(field_list) = record_pat.record_field_pat_list() {\n+                        let variant_data = variant_data(db.upcast(), variant_def);\n+                        let missed_fields = missed_fields\n+                            .into_iter()\n+                            .map(|idx| variant_data.fields()[idx].name.clone())\n+                            .collect();\n+                        self.sink.push(MissingPatFields {\n+                            file: source_ptr.file_id,\n+                            field_list: AstPtr::new(&field_list),\n+                            missed_fields,\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n@@ -232,9 +290,9 @@ pub fn record_pattern_missing_fields(\n     infer: &InferenceResult,\n     id: PatId,\n     pat: &Pat,\n-) -> Option<(VariantId, Vec<LocalStructFieldId>)> {\n-    let fields = match pat {\n-        Pat::Record { path: _, args } => args,\n+) -> Option<(VariantId, Vec<LocalStructFieldId>, /*exhaustive*/ bool)> {\n+    let (fields, exhaustive) = match pat {\n+        Pat::Record { path: _, args, ellipsis } => (args, !ellipsis),\n         _ => return None,\n     };\n \n@@ -254,5 +312,5 @@ pub fn record_pattern_missing_fields(\n     if missed_fields.is_empty() {\n         return None;\n     }\n-    Some((variant_def, missed_fields))\n+    Some((variant_def, missed_fields, exhaustive))\n }"}, {"sha": "078476f76a9cc5c5ec52d206ebc81567b17d5ded", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -158,7 +158,7 @@ impl<'a> InferenceContext<'a> {\n             Pat::TupleStruct { path: p, args: subpats } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n-            Pat::Record { path: p, args: fields } => {\n+            Pat::Record { path: p, args: fields, ellipsis: _ } => {\n                 self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n             }\n             Pat::Path(path) => {"}, {"sha": "47a7b9ffd61d46a4873db988e709d5254a07c0ae", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63315b8f189396cf556f21d4ca27ae4281d17d7/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=e63315b8f189396cf556f21d4ca27ae4281d17d7", "patch": "@@ -409,3 +409,43 @@ fn no_such_field_with_feature_flag_diagnostics_on_struct_fields() {\n \n     assert_snapshot!(diagnostics, @r###\"\"###);\n }\n+\n+#[test]\n+fn missing_record_pat_field_diagnostic() {\n+    let diagnostics = TestDB::with_files(\n+        r\"\n+        //- /lib.rs\n+        struct S { foo: i32, bar: () }\n+        fn baz(s: S) {\n+            let S { foo: _ } = s;\n+        }\n+        \",\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\n+    \"{ foo: _ }\": Missing structure fields:\n+    - bar\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+    let diagnostics = TestDB::with_files(\n+        r\"\n+        //- /lib.rs\n+        struct S { foo: i32, bar: () }\n+        fn baz(s: S) -> i32 {\n+            match s {\n+                S { foo, .. } => foo,\n+            }\n+        }\n+        \",\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @\"\");\n+}"}]}