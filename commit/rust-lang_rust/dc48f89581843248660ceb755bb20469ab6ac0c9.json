{"sha": "dc48f89581843248660ceb755bb20469ab6ac0c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDhmODk1ODE4NDMyNDg2NjBjZWI3NTViYjIwNDY5YWI2YWMwYzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-29T12:57:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-29T12:57:24Z"}, "message": "Merge #2668\n\n2668: In-server cargo check watching r=matklad a=kiljacken\n\nOpening a draft now so people can follow the progress, and comment if they spot something stupid.\r\n\r\nThings that need doing:\r\n- [x] Running cargo check on save\r\n- [x] Pipe through configuration options from client\r\n- [x] Tests for parsing behavior\r\n- [x] Remove existing cargo watch support from VSCode extension\r\n- [x] Progress notification in VSCode extension using LSP 3.15 `$/progress` notification\r\n- [ ] ~~Rework ra-ide diagnostics to support secondary messages~~\r\n- [ ] ~~Make cargo-check watcher use ra-ide diagnostics~~\r\n\r\n~~I'd love some input on whether to try to keep the status bar progress thingy for VSCode? It will require some plumbing, and maintaining yet another rust-analyzer specific LSP notification, which I'm not sure we want to.~~\r\n\r\nFixes #1894 \n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>", "tree": {"sha": "05a7e47d1c68c250025be1ce6492f56c15353749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a7e47d1c68c250025be1ce6492f56c15353749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc48f89581843248660ceb755bb20469ab6ac0c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeCKK0CRBK7hj4Ov3rIwAAdHIIAIFRZtyaVj4zeoZVhZTJ0SBp\nr2z3AbTxiJ+JgdmRzyOZOKV7lfTsU3NJ3+lFeRaeJYN/VoeDTwODSCqHzzIM20PT\n6oL3I6rZSwvJ4n0lDFL/4nfJPJdE1aGQPnK4YXomnI3rMU/D07H8s04KEUAtyHvd\nNs+7pOT0cTgbgjl+HKC/PZdr0Dh/UvobVDP220F49Vm/N1BRmVuvKdDmyC6Humzx\nQ7VyAMwoq49Ig5yNMLRVPjZHV4859UZpaBDDD8dCKye8AIV5LYqugw7F61ojD5D3\n2wjXgamW60IunTmLAB44xHnyr6lBiuWO7mzUcA6TJSR4m9BGtjy7XVIjx3RaRLY=\n=TD4l\n-----END PGP SIGNATURE-----\n", "payload": "tree 05a7e47d1c68c250025be1ce6492f56c15353749\nparent cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea\nparent 899dbebd02b41b12d89c9f485e85208b39b81932\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1577624244 +0000\ncommitter GitHub <noreply@github.com> 1577624244 +0000\n\nMerge #2668\n\n2668: In-server cargo check watching r=matklad a=kiljacken\n\nOpening a draft now so people can follow the progress, and comment if they spot something stupid.\r\n\r\nThings that need doing:\r\n- [x] Running cargo check on save\r\n- [x] Pipe through configuration options from client\r\n- [x] Tests for parsing behavior\r\n- [x] Remove existing cargo watch support from VSCode extension\r\n- [x] Progress notification in VSCode extension using LSP 3.15 `$/progress` notification\r\n- [ ] ~~Rework ra-ide diagnostics to support secondary messages~~\r\n- [ ] ~~Make cargo-check watcher use ra-ide diagnostics~~\r\n\r\n~~I'd love some input on whether to try to keep the status bar progress thingy for VSCode? It will require some plumbing, and maintaining yet another rust-analyzer specific LSP notification, which I'm not sure we want to.~~\r\n\r\nFixes #1894 \n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc48f89581843248660ceb755bb20469ab6ac0c9", "html_url": "https://github.com/rust-lang/rust/commit/dc48f89581843248660ceb755bb20469ab6ac0c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc48f89581843248660ceb755bb20469ab6ac0c9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "html_url": "https://github.com/rust-lang/rust/commit/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea"}, {"sha": "899dbebd02b41b12d89c9f485e85208b39b81932", "url": "https://api.github.com/repos/rust-lang/rust/commits/899dbebd02b41b12d89c9f485e85208b39b81932", "html_url": "https://github.com/rust-lang/rust/commit/899dbebd02b41b12d89c9f485e85208b39b81932"}], "stats": {"total": 4142, "additions": 1933, "deletions": 2209}, "files": [{"sha": "b63b5ae13448d0f383e0044eb117454cc76b81b5", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -898,6 +898,20 @@ dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_cargo_watch\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo_metadata 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jod-thread 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-types 0.67.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ra_cfg\"\n version = \"0.1.0\"\n@@ -1059,6 +1073,7 @@ dependencies = [\n  \"lsp-server 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.67.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_cargo_watch 0.1.0\",\n  \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_project_model 0.1.0\","}, {"sha": "bcc4648ff44d454f38d1f346b0c5e642b7967d22", "filename": "crates/ra_cargo_watch/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2FCargo.toml?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_cargo_watch\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+crossbeam-channel = \"0.4\"\n+lsp-types = { version = \"0.67.0\", features = [\"proposed\"] }\n+log = \"0.4.3\"\n+cargo_metadata = \"0.9.1\"\n+jod-thread = \"0.1.0\"\n+parking_lot = \"0.10.0\"\n+\n+[dev-dependencies]\n+insta = \"0.12.0\"\n+serde_json = \"1.0\"\n\\ No newline at end of file"}, {"sha": "3bd4bf7a5f62ff5a86c0ea033e1d7fa1ab3f4dbe", "filename": "crates/ra_cargo_watch/src/conv.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,280 @@\n+//! This module provides the functionality needed to convert diagnostics from\n+//! `cargo check` json format to the LSP diagnostic format.\n+use cargo_metadata::diagnostic::{\n+    Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n+    DiagnosticSpanMacroExpansion,\n+};\n+use lsp_types::{\n+    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n+    NumberOrString, Position, Range, Url,\n+};\n+use std::{fmt::Write, path::PathBuf};\n+\n+#[cfg(test)]\n+mod test;\n+\n+/// Converts a Rust level string to a LSP severity\n+fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n+    match val {\n+        DiagnosticLevel::Ice => Some(DiagnosticSeverity::Error),\n+        DiagnosticLevel::Error => Some(DiagnosticSeverity::Error),\n+        DiagnosticLevel::Warning => Some(DiagnosticSeverity::Warning),\n+        DiagnosticLevel::Note => Some(DiagnosticSeverity::Information),\n+        DiagnosticLevel::Help => Some(DiagnosticSeverity::Hint),\n+        DiagnosticLevel::Unknown => None,\n+    }\n+}\n+\n+/// Check whether a file name is from macro invocation\n+fn is_from_macro(file_name: &str) -> bool {\n+    file_name.starts_with('<') && file_name.ends_with('>')\n+}\n+\n+/// Converts a Rust macro span to a LSP location recursively\n+fn map_macro_span_to_location(\n+    span_macro: &DiagnosticSpanMacroExpansion,\n+    workspace_root: &PathBuf,\n+) -> Option<Location> {\n+    if !is_from_macro(&span_macro.span.file_name) {\n+        return Some(map_span_to_location(&span_macro.span, workspace_root));\n+    }\n+\n+    if let Some(expansion) = &span_macro.span.expansion {\n+        return map_macro_span_to_location(&expansion, workspace_root);\n+    }\n+\n+    None\n+}\n+\n+/// Converts a Rust span to a LSP location\n+fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n+    if is_from_macro(&span.file_name) && span.expansion.is_some() {\n+        let expansion = span.expansion.as_ref().unwrap();\n+        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n+            return macro_range;\n+        }\n+    }\n+\n+    let mut file_name = workspace_root.clone();\n+    file_name.push(&span.file_name);\n+    let uri = Url::from_file_path(file_name).unwrap();\n+\n+    let range = Range::new(\n+        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n+        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n+    );\n+\n+    Location { uri, range }\n+}\n+\n+/// Converts a secondary Rust span to a LSP related information\n+///\n+/// If the span is unlabelled this will return `None`.\n+fn map_secondary_span_to_related(\n+    span: &DiagnosticSpan,\n+    workspace_root: &PathBuf,\n+) -> Option<DiagnosticRelatedInformation> {\n+    if let Some(label) = &span.label {\n+        let location = map_span_to_location(span, workspace_root);\n+        Some(DiagnosticRelatedInformation { location, message: label.clone() })\n+    } else {\n+        // Nothing to label this with\n+        None\n+    }\n+}\n+\n+/// Determines if diagnostic is related to unused code\n+fn is_unused_or_unnecessary(rd: &RustDiagnostic) -> bool {\n+    if let Some(code) = &rd.code {\n+        match code.code.as_str() {\n+            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n+            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Determines if diagnostic is related to deprecated code\n+fn is_deprecated(rd: &RustDiagnostic) -> bool {\n+    if let Some(code) = &rd.code {\n+        match code.code.as_str() {\n+            \"deprecated\" => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SuggestedFix {\n+    pub title: String,\n+    pub location: Location,\n+    pub replacement: String,\n+    pub applicability: Applicability,\n+    pub diagnostics: Vec<Diagnostic>,\n+}\n+\n+impl std::cmp::PartialEq<SuggestedFix> for SuggestedFix {\n+    fn eq(&self, other: &SuggestedFix) -> bool {\n+        if self.title == other.title\n+            && self.location == other.location\n+            && self.replacement == other.replacement\n+        {\n+            // Applicability doesn't impl PartialEq...\n+            match (&self.applicability, &other.applicability) {\n+                (Applicability::MachineApplicable, Applicability::MachineApplicable) => true,\n+                (Applicability::HasPlaceholders, Applicability::HasPlaceholders) => true,\n+                (Applicability::MaybeIncorrect, Applicability::MaybeIncorrect) => true,\n+                (Applicability::Unspecified, Applicability::Unspecified) => true,\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+enum MappedRustChildDiagnostic {\n+    Related(DiagnosticRelatedInformation),\n+    SuggestedFix(SuggestedFix),\n+    MessageLine(String),\n+}\n+\n+fn map_rust_child_diagnostic(\n+    rd: &RustDiagnostic,\n+    workspace_root: &PathBuf,\n+) -> MappedRustChildDiagnostic {\n+    let span: &DiagnosticSpan = match rd.spans.iter().find(|s| s.is_primary) {\n+        Some(span) => span,\n+        None => {\n+            // `rustc` uses these spanless children as a way to print multi-line\n+            // messages\n+            return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n+        }\n+    };\n+\n+    // If we have a primary span use its location, otherwise use the parent\n+    let location = map_span_to_location(&span, workspace_root);\n+\n+    if let Some(suggested_replacement) = &span.suggested_replacement {\n+        // Include our replacement in the title unless it's empty\n+        let title = if !suggested_replacement.is_empty() {\n+            format!(\"{}: '{}'\", rd.message, suggested_replacement)\n+        } else {\n+            rd.message.clone()\n+        };\n+\n+        MappedRustChildDiagnostic::SuggestedFix(SuggestedFix {\n+            title,\n+            location,\n+            replacement: suggested_replacement.clone(),\n+            applicability: span.suggestion_applicability.clone().unwrap_or(Applicability::Unknown),\n+            diagnostics: vec![],\n+        })\n+    } else {\n+        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n+            location,\n+            message: rd.message.clone(),\n+        })\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct MappedRustDiagnostic {\n+    pub location: Location,\n+    pub diagnostic: Diagnostic,\n+    pub suggested_fixes: Vec<SuggestedFix>,\n+}\n+\n+/// Converts a Rust root diagnostic to LSP form\n+///\n+/// This flattens the Rust diagnostic by:\n+///\n+/// 1. Creating a LSP diagnostic with the root message and primary span.\n+/// 2. Adding any labelled secondary spans to `relatedInformation`\n+/// 3. Categorising child diagnostics as either `SuggestedFix`es,\n+///    `relatedInformation` or additional message lines.\n+///\n+/// If the diagnostic has no primary span this will return `None`\n+pub(crate) fn map_rust_diagnostic_to_lsp(\n+    rd: &RustDiagnostic,\n+    workspace_root: &PathBuf,\n+) -> Option<MappedRustDiagnostic> {\n+    let primary_span = rd.spans.iter().find(|s| s.is_primary)?;\n+\n+    let location = map_span_to_location(&primary_span, workspace_root);\n+\n+    let severity = map_level_to_severity(rd.level);\n+    let mut primary_span_label = primary_span.label.as_ref();\n+\n+    let mut source = String::from(\"rustc\");\n+    let mut code = rd.code.as_ref().map(|c| c.code.clone());\n+    if let Some(code_val) = &code {\n+        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n+        let scoped_code: Vec<&str> = code_val.split(\"::\").collect();\n+        if scoped_code.len() == 2 {\n+            source = String::from(scoped_code[0]);\n+            code = Some(String::from(scoped_code[1]));\n+        }\n+    }\n+\n+    let mut related_information = vec![];\n+    let mut tags = vec![];\n+\n+    for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n+        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n+        if let Some(related) = related {\n+            related_information.push(related);\n+        }\n+    }\n+\n+    let mut suggested_fixes = vec![];\n+    let mut message = rd.message.clone();\n+    for child in &rd.children {\n+        let child = map_rust_child_diagnostic(&child, workspace_root);\n+        match child {\n+            MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n+            MappedRustChildDiagnostic::SuggestedFix(suggested_fix) => {\n+                suggested_fixes.push(suggested_fix)\n+            }\n+            MappedRustChildDiagnostic::MessageLine(message_line) => {\n+                write!(&mut message, \"\\n{}\", message_line).unwrap();\n+\n+                // These secondary messages usually duplicate the content of the\n+                // primary span label.\n+                primary_span_label = None;\n+            }\n+        }\n+    }\n+\n+    if let Some(primary_span_label) = primary_span_label {\n+        write!(&mut message, \"\\n{}\", primary_span_label).unwrap();\n+    }\n+\n+    if is_unused_or_unnecessary(rd) {\n+        tags.push(DiagnosticTag::Unnecessary);\n+    }\n+\n+    if is_deprecated(rd) {\n+        tags.push(DiagnosticTag::Deprecated);\n+    }\n+\n+    let diagnostic = Diagnostic {\n+        range: location.range,\n+        severity,\n+        code: code.map(NumberOrString::String),\n+        source: Some(source),\n+        message,\n+        related_information: if !related_information.is_empty() {\n+            Some(related_information)\n+        } else {\n+            None\n+        },\n+        tags: if !tags.is_empty() { Some(tags) } else { None },\n+    };\n+\n+    Some(MappedRustDiagnostic { location, diagnostic, suggested_fixes })\n+}"}, {"sha": "cb0920914b670163f61dee9eb9069c365abaf3dd", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_clippy_pass_by_ref.snap", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_clippy_pass_by_ref.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_clippy_pass_by_ref.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_clippy_pass_by_ref.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,85 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/compiler/mir/tagset.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 41,\n+                character: 23,\n+            },\n+            end: Position {\n+                line: 41,\n+                character: 28,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 41,\n+                character: 23,\n+            },\n+            end: Position {\n+                line: 41,\n+                character: 28,\n+            },\n+        },\n+        severity: Some(\n+            Warning,\n+        ),\n+        code: Some(\n+            String(\n+                \"trivially_copy_pass_by_ref\",\n+            ),\n+        ),\n+        source: Some(\n+            \"clippy\",\n+        ),\n+        message: \"this argument is passed by reference, but would be more efficient if passed by value\\n#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\nfor further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n+        related_information: Some(\n+            [\n+                DiagnosticRelatedInformation {\n+                    location: Location {\n+                        uri: \"file:///test/compiler/lib.rs\",\n+                        range: Range {\n+                            start: Position {\n+                                line: 0,\n+                                character: 8,\n+                            },\n+                            end: Position {\n+                                line: 0,\n+                                character: 19,\n+                            },\n+                        },\n+                    },\n+                    message: \"lint level defined here\",\n+                },\n+            ],\n+        ),\n+        tags: None,\n+    },\n+    suggested_fixes: [\n+        SuggestedFix {\n+            title: \"consider passing by value instead: \\'self\\'\",\n+            location: Location {\n+                uri: \"file:///test/compiler/mir/tagset.rs\",\n+                range: Range {\n+                    start: Position {\n+                        line: 41,\n+                        character: 23,\n+                    },\n+                    end: Position {\n+                        line: 41,\n+                        character: 28,\n+                    },\n+                },\n+            },\n+            replacement: \"self\",\n+            applicability: Unspecified,\n+            diagnostics: [],\n+        },\n+    ],\n+}"}, {"sha": "19510ecc1ee793cbe5fe67e39cf452264ae5e8b5", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_handles_macro_location.snap", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_handles_macro_location.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_handles_macro_location.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_handles_macro_location.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,46 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/src/main.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 1,\n+                character: 4,\n+            },\n+            end: Position {\n+                line: 1,\n+                character: 26,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 1,\n+                character: 4,\n+            },\n+            end: Position {\n+                line: 1,\n+                character: 26,\n+            },\n+        },\n+        severity: Some(\n+            Error,\n+        ),\n+        code: Some(\n+            String(\n+                \"E0277\",\n+            ),\n+        ),\n+        source: Some(\n+            \"rustc\",\n+        ),\n+        message: \"can\\'t compare `{integer}` with `&str`\\nthe trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n+        related_information: None,\n+        tags: None,\n+    },\n+    suggested_fixes: [],\n+}"}, {"sha": "cf683e4b6f86d7465768159275fc104f1bc038d8", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_incompatible_type_for_trait.snap", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_incompatible_type_for_trait.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_incompatible_type_for_trait.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_incompatible_type_for_trait.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,46 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/compiler/ty/list_iter.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 51,\n+                character: 4,\n+            },\n+            end: Position {\n+                line: 51,\n+                character: 47,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 51,\n+                character: 4,\n+            },\n+            end: Position {\n+                line: 51,\n+                character: 47,\n+            },\n+        },\n+        severity: Some(\n+            Error,\n+        ),\n+        code: Some(\n+            String(\n+                \"E0053\",\n+            ),\n+        ),\n+        source: Some(\n+            \"rustc\",\n+        ),\n+        message: \"method `next` has an incompatible type for trait\\nexpected type `fn(&mut ty::list_iter::ListIterator<\\'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<\\'list, M>) -> std::option::Option<&\\'list ty::Ref<M>>`\",\n+        related_information: None,\n+        tags: None,\n+    },\n+    suggested_fixes: [],\n+}"}, {"sha": "8c1483c74b112a805bfe9c67f47329731d4567eb", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_mismatched_type.snap", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_mismatched_type.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_mismatched_type.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_mismatched_type.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,46 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/runtime/compiler_support.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 47,\n+                character: 64,\n+            },\n+            end: Position {\n+                line: 47,\n+                character: 69,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 47,\n+                character: 64,\n+            },\n+            end: Position {\n+                line: 47,\n+                character: 69,\n+            },\n+        },\n+        severity: Some(\n+            Error,\n+        ),\n+        code: Some(\n+            String(\n+                \"E0308\",\n+            ),\n+        ),\n+        source: Some(\n+            \"rustc\",\n+        ),\n+        message: \"mismatched types\\nexpected usize, found u32\",\n+        related_information: None,\n+        tags: None,\n+    },\n+    suggested_fixes: [],\n+}"}, {"sha": "eb5a2247be549e897a2fd35a37a18a4ee6901eff", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_unused_variable.snap", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_unused_variable.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,70 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/driver/subcommand/repl.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 290,\n+                character: 8,\n+            },\n+            end: Position {\n+                line: 290,\n+                character: 11,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 290,\n+                character: 8,\n+            },\n+            end: Position {\n+                line: 290,\n+                character: 11,\n+            },\n+        },\n+        severity: Some(\n+            Warning,\n+        ),\n+        code: Some(\n+            String(\n+                \"unused_variables\",\n+            ),\n+        ),\n+        source: Some(\n+            \"rustc\",\n+        ),\n+        message: \"unused variable: `foo`\\n#[warn(unused_variables)] on by default\",\n+        related_information: None,\n+        tags: Some(\n+            [\n+                Unnecessary,\n+            ],\n+        ),\n+    },\n+    suggested_fixes: [\n+        SuggestedFix {\n+            title: \"consider prefixing with an underscore: \\'_foo\\'\",\n+            location: Location {\n+                uri: \"file:///test/driver/subcommand/repl.rs\",\n+                range: Range {\n+                    start: Position {\n+                        line: 290,\n+                        character: 8,\n+                    },\n+                    end: Position {\n+                        line: 290,\n+                        character: 11,\n+                    },\n+                },\n+            },\n+            replacement: \"_foo\",\n+            applicability: MachineApplicable,\n+            diagnostics: [],\n+        },\n+    ],\n+}"}, {"sha": "2f4518931ec6da989f45e6bf6b47c13c55ed5e0d", "filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_wrong_number_of_parameters.snap", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_wrong_number_of_parameters.snap", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_wrong_number_of_parameters.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Ftest__snap_rustc_wrong_number_of_parameters.snap?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,65 @@\n+---\n+source: crates/ra_cargo_watch/src/conv/test.rs\n+expression: diag\n+---\n+MappedRustDiagnostic {\n+    location: Location {\n+        uri: \"file:///test/compiler/ty/select.rs\",\n+        range: Range {\n+            start: Position {\n+                line: 103,\n+                character: 17,\n+            },\n+            end: Position {\n+                line: 103,\n+                character: 29,\n+            },\n+        },\n+    },\n+    diagnostic: Diagnostic {\n+        range: Range {\n+            start: Position {\n+                line: 103,\n+                character: 17,\n+            },\n+            end: Position {\n+                line: 103,\n+                character: 29,\n+            },\n+        },\n+        severity: Some(\n+            Error,\n+        ),\n+        code: Some(\n+            String(\n+                \"E0061\",\n+            ),\n+        ),\n+        source: Some(\n+            \"rustc\",\n+        ),\n+        message: \"this function takes 2 parameters but 3 parameters were supplied\\nexpected 2 parameters\",\n+        related_information: Some(\n+            [\n+                DiagnosticRelatedInformation {\n+                    location: Location {\n+                        uri: \"file:///test/compiler/ty/select.rs\",\n+                        range: Range {\n+                            start: Position {\n+                                line: 218,\n+                                character: 4,\n+                            },\n+                            end: Position {\n+                                line: 230,\n+                                character: 5,\n+                            },\n+                        },\n+                    },\n+                    message: \"defined here\",\n+                },\n+            ],\n+        ),\n+        tags: None,\n+    },\n+    suggested_fixes: [],\n+}"}, {"sha": "6817245c2bde518855f9cc726dd42c927eb8470b", "filename": "crates/ra_cargo_watch/src/conv/test.rs", "status": "added", "additions": 700, "deletions": 0, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Ftest.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,700 @@\n+//! This module contains the large and verbose snapshot tests for the\n+//! conversions between `cargo check` json and LSP diagnostics.\n+use crate::*;\n+\n+fn parse_diagnostic(val: &str) -> cargo_metadata::diagnostic::Diagnostic {\n+    serde_json::from_str::<cargo_metadata::diagnostic::Diagnostic>(val).unwrap()\n+}\n+\n+#[test]\n+fn snap_rustc_incompatible_type_for_trait() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+            \"message\": \"method `next` has an incompatible type for trait\",\n+            \"code\": {\n+                \"code\": \"E0053\",\n+                \"explanation\": \"\\nThe parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nHere are a couple examples of this error:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\"\n+            },\n+            \"level\": \"error\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"compiler/ty/list_iter.rs\",\n+                    \"byte_start\": 1307,\n+                    \"byte_end\": 1350,\n+                    \"line_start\": 52,\n+                    \"line_end\": 52,\n+                    \"column_start\": 5,\n+                    \"column_end\": 48,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"    fn next(&self) -> Option<&'list ty::Ref<M>> {\",\n+                            \"highlight_start\": 5,\n+                            \"highlight_end\": 48\n+                        }\n+                    ],\n+                    \"label\": \"types differ in mutability\",\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [\n+                {\n+                    \"message\": \"expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n+                    \"code\": null,\n+                    \"level\": \"note\",\n+                    \"spans\": [],\n+                    \"children\": [],\n+                    \"rendered\": null\n+                }\n+            ],\n+            \"rendered\": \"error[E0053]: method `next` has an incompatible type for trait\\n  --> compiler/ty/list_iter.rs:52:5\\n   |\\n52 |     fn next(&self) -> Option<&'list ty::Ref<M>> {\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\\n   |\\n   = note: expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n              found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\\n\\n\"\n+        }\n+        \"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}\n+\n+#[test]\n+fn snap_rustc_unused_variable() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+\"message\": \"unused variable: `foo`\",\n+\"code\": {\n+    \"code\": \"unused_variables\",\n+    \"explanation\": null\n+},\n+\"level\": \"warning\",\n+\"spans\": [\n+    {\n+        \"file_name\": \"driver/subcommand/repl.rs\",\n+        \"byte_start\": 9228,\n+        \"byte_end\": 9231,\n+        \"line_start\": 291,\n+        \"line_end\": 291,\n+        \"column_start\": 9,\n+        \"column_end\": 12,\n+        \"is_primary\": true,\n+        \"text\": [\n+            {\n+                \"text\": \"    let foo = 42;\",\n+                \"highlight_start\": 9,\n+                \"highlight_end\": 12\n+            }\n+        ],\n+        \"label\": null,\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"expansion\": null\n+    }\n+],\n+\"children\": [\n+    {\n+        \"message\": \"#[warn(unused_variables)] on by default\",\n+        \"code\": null,\n+        \"level\": \"note\",\n+        \"spans\": [],\n+        \"children\": [],\n+        \"rendered\": null\n+    },\n+    {\n+        \"message\": \"consider prefixing with an underscore\",\n+        \"code\": null,\n+        \"level\": \"help\",\n+        \"spans\": [\n+            {\n+                \"file_name\": \"driver/subcommand/repl.rs\",\n+                \"byte_start\": 9228,\n+                \"byte_end\": 9231,\n+                \"line_start\": 291,\n+                \"line_end\": 291,\n+                \"column_start\": 9,\n+                \"column_end\": 12,\n+                \"is_primary\": true,\n+                \"text\": [\n+                    {\n+                        \"text\": \"    let foo = 42;\",\n+                        \"highlight_start\": 9,\n+                        \"highlight_end\": 12\n+                    }\n+                ],\n+                \"label\": null,\n+                \"suggested_replacement\": \"_foo\",\n+                \"suggestion_applicability\": \"MachineApplicable\",\n+                \"expansion\": null\n+            }\n+        ],\n+        \"children\": [],\n+        \"rendered\": null\n+    }\n+],\n+\"rendered\": \"warning: unused variable: `foo`\\n   --> driver/subcommand/repl.rs:291:9\\n    |\\n291 |     let foo = 42;\\n    |         ^^^ help: consider prefixing with an underscore: `_foo`\\n    |\\n    = note: #[warn(unused_variables)] on by default\\n\\n\"\n+}\"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}\n+\n+#[test]\n+fn snap_rustc_wrong_number_of_parameters() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+\"message\": \"this function takes 2 parameters but 3 parameters were supplied\",\n+\"code\": {\n+    \"code\": \"E0061\",\n+    \"explanation\": \"\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\"\n+},\n+\"level\": \"error\",\n+\"spans\": [\n+    {\n+        \"file_name\": \"compiler/ty/select.rs\",\n+        \"byte_start\": 8787,\n+        \"byte_end\": 9241,\n+        \"line_start\": 219,\n+        \"line_end\": 231,\n+        \"column_start\": 5,\n+        \"column_end\": 6,\n+        \"is_primary\": false,\n+        \"text\": [\n+            {\n+                \"text\": \"    pub fn add_evidence(\",\n+                \"highlight_start\": 5,\n+                \"highlight_end\": 25\n+            },\n+            {\n+                \"text\": \"        &mut self,\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 19\n+            },\n+            {\n+                \"text\": \"        target_poly: &ty::Ref<ty::Poly>,\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 41\n+            },\n+            {\n+                \"text\": \"        evidence_poly: &ty::Ref<ty::Poly>,\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 43\n+            },\n+            {\n+                \"text\": \"    ) {\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 8\n+            },\n+            {\n+                \"text\": \"        match target_poly {\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 28\n+            },\n+            {\n+                \"text\": \"            ty::Ref::Var(tvar, _) => self.add_var_evidence(tvar, evidence_poly),\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 81\n+            },\n+            {\n+                \"text\": \"            ty::Ref::Fixed(target_ty) => {\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 43\n+            },\n+            {\n+                \"text\": \"                let evidence_ty = evidence_poly.resolve_to_ty();\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 65\n+            },\n+            {\n+                \"text\": \"                self.add_evidence_ty(target_ty, evidence_poly, evidence_ty)\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 76\n+            },\n+            {\n+                \"text\": \"            }\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 14\n+            },\n+            {\n+                \"text\": \"        }\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 10\n+            },\n+            {\n+                \"text\": \"    }\",\n+                \"highlight_start\": 1,\n+                \"highlight_end\": 6\n+            }\n+        ],\n+        \"label\": \"defined here\",\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"expansion\": null\n+    },\n+    {\n+        \"file_name\": \"compiler/ty/select.rs\",\n+        \"byte_start\": 4045,\n+        \"byte_end\": 4057,\n+        \"line_start\": 104,\n+        \"line_end\": 104,\n+        \"column_start\": 18,\n+        \"column_end\": 30,\n+        \"is_primary\": true,\n+        \"text\": [\n+            {\n+                \"text\": \"            self.add_evidence(target_fixed, evidence_fixed, false);\",\n+                \"highlight_start\": 18,\n+                \"highlight_end\": 30\n+            }\n+        ],\n+        \"label\": \"expected 2 parameters\",\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"expansion\": null\n+    }\n+],\n+\"children\": [],\n+\"rendered\": \"error[E0061]: this function takes 2 parameters but 3 parameters were supplied\\n   --> compiler/ty/select.rs:104:18\\n    |\\n104 |               self.add_evidence(target_fixed, evidence_fixed, false);\\n    |                    ^^^^^^^^^^^^ expected 2 parameters\\n...\\n219 | /     pub fn add_evidence(\\n220 | |         &mut self,\\n221 | |         target_poly: &ty::Ref<ty::Poly>,\\n222 | |         evidence_poly: &ty::Ref<ty::Poly>,\\n...   |\\n230 | |         }\\n231 | |     }\\n    | |_____- defined here\\n\\n\"\n+}\"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}\n+\n+#[test]\n+fn snap_clippy_pass_by_ref() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+\"message\": \"this argument is passed by reference, but would be more efficient if passed by value\",\n+\"code\": {\n+    \"code\": \"clippy::trivially_copy_pass_by_ref\",\n+    \"explanation\": null\n+},\n+\"level\": \"warning\",\n+\"spans\": [\n+    {\n+        \"file_name\": \"compiler/mir/tagset.rs\",\n+        \"byte_start\": 941,\n+        \"byte_end\": 946,\n+        \"line_start\": 42,\n+        \"line_end\": 42,\n+        \"column_start\": 24,\n+        \"column_end\": 29,\n+        \"is_primary\": true,\n+        \"text\": [\n+            {\n+                \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n+                \"highlight_start\": 24,\n+                \"highlight_end\": 29\n+            }\n+        ],\n+        \"label\": null,\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"expansion\": null\n+    }\n+],\n+\"children\": [\n+    {\n+        \"message\": \"lint level defined here\",\n+        \"code\": null,\n+        \"level\": \"note\",\n+        \"spans\": [\n+            {\n+                \"file_name\": \"compiler/lib.rs\",\n+                \"byte_start\": 8,\n+                \"byte_end\": 19,\n+                \"line_start\": 1,\n+                \"line_end\": 1,\n+                \"column_start\": 9,\n+                \"column_end\": 20,\n+                \"is_primary\": true,\n+                \"text\": [\n+                    {\n+                        \"text\": \"#![warn(clippy::all)]\",\n+                        \"highlight_start\": 9,\n+                        \"highlight_end\": 20\n+                    }\n+                ],\n+                \"label\": null,\n+                \"suggested_replacement\": null,\n+                \"suggestion_applicability\": null,\n+                \"expansion\": null\n+            }\n+        ],\n+        \"children\": [],\n+        \"rendered\": null\n+    },\n+    {\n+        \"message\": \"#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\",\n+        \"code\": null,\n+        \"level\": \"note\",\n+        \"spans\": [],\n+        \"children\": [],\n+        \"rendered\": null\n+    },\n+    {\n+        \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n+        \"code\": null,\n+        \"level\": \"help\",\n+        \"spans\": [],\n+        \"children\": [],\n+        \"rendered\": null\n+    },\n+    {\n+        \"message\": \"consider passing by value instead\",\n+        \"code\": null,\n+        \"level\": \"help\",\n+        \"spans\": [\n+            {\n+                \"file_name\": \"compiler/mir/tagset.rs\",\n+                \"byte_start\": 941,\n+                \"byte_end\": 946,\n+                \"line_start\": 42,\n+                \"line_end\": 42,\n+                \"column_start\": 24,\n+                \"column_end\": 29,\n+                \"is_primary\": true,\n+                \"text\": [\n+                    {\n+                        \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n+                        \"highlight_start\": 24,\n+                        \"highlight_end\": 29\n+                    }\n+                ],\n+                \"label\": null,\n+                \"suggested_replacement\": \"self\",\n+                \"suggestion_applicability\": \"Unspecified\",\n+                \"expansion\": null\n+            }\n+        ],\n+        \"children\": [],\n+        \"rendered\": null\n+    }\n+],\n+\"rendered\": \"warning: this argument is passed by reference, but would be more efficient if passed by value\\n  --> compiler/mir/tagset.rs:42:24\\n   |\\n42 |     pub fn is_disjoint(&self, other: Self) -> bool {\\n   |                        ^^^^^ help: consider passing by value instead: `self`\\n   |\\nnote: lint level defined here\\n  --> compiler/lib.rs:1:9\\n   |\\n1  | #![warn(clippy::all)]\\n   |         ^^^^^^^^^^^\\n   = note: #[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\\n\\n\"\n+}\"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}\n+\n+#[test]\n+fn snap_rustc_mismatched_type() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+\"message\": \"mismatched types\",\n+\"code\": {\n+    \"code\": \"E0308\",\n+    \"explanation\": \"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail,E0308\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\"\n+},\n+\"level\": \"error\",\n+\"spans\": [\n+    {\n+        \"file_name\": \"runtime/compiler_support.rs\",\n+        \"byte_start\": 1589,\n+        \"byte_end\": 1594,\n+        \"line_start\": 48,\n+        \"line_end\": 48,\n+        \"column_start\": 65,\n+        \"column_end\": 70,\n+        \"is_primary\": true,\n+        \"text\": [\n+            {\n+                \"text\": \"    let layout = alloc::Layout::from_size_align_unchecked(size, align);\",\n+                \"highlight_start\": 65,\n+                \"highlight_end\": 70\n+            }\n+        ],\n+        \"label\": \"expected usize, found u32\",\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"expansion\": null\n+    }\n+],\n+\"children\": [],\n+\"rendered\": \"error[E0308]: mismatched types\\n  --> runtime/compiler_support.rs:48:65\\n   |\\n48 |     let layout = alloc::Layout::from_size_align_unchecked(size, align);\\n   |                                                                 ^^^^^ expected usize, found u32\\n\\n\"\n+}\"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}\n+\n+#[test]\n+fn snap_handles_macro_location() {\n+    let diag = parse_diagnostic(\n+        r##\"{\n+\"rendered\": \"error[E0277]: can't compare `{integer}` with `&str`\\n --> src/main.rs:2:5\\n  |\\n2 |     assert_eq!(1, \\\"love\\\");\\n  |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &str`\\n  |\\n  = help: the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\\n\\n\",\n+\"children\": [\n+    {\n+        \"children\": [],\n+        \"code\": null,\n+        \"level\": \"help\",\n+        \"message\": \"the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n+        \"rendered\": null,\n+        \"spans\": []\n+    }\n+],\n+\"code\": {\n+    \"code\": \"E0277\",\n+    \"explanation\": \"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"\n+},\n+\"level\": \"error\",\n+\"message\": \"can't compare `{integer}` with `&str`\",\n+\"spans\": [\n+    {\n+        \"byte_end\": 155,\n+        \"byte_start\": 153,\n+        \"column_end\": 33,\n+        \"column_start\": 31,\n+        \"expansion\": {\n+            \"def_site_span\": {\n+                \"byte_end\": 940,\n+                \"byte_start\": 0,\n+                \"column_end\": 6,\n+                \"column_start\": 1,\n+                \"expansion\": null,\n+                \"file_name\": \"<::core::macros::assert_eq macros>\",\n+                \"is_primary\": false,\n+                \"label\": null,\n+                \"line_end\": 36,\n+                \"line_start\": 1,\n+                \"suggested_replacement\": null,\n+                \"suggestion_applicability\": null,\n+                \"text\": [\n+                    {\n+                        \"highlight_end\": 35,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"($ left : expr, $ right : expr) =>\"\n+                    },\n+                    {\n+                        \"highlight_end\": 3,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"({\"\n+                    },\n+                    {\n+                        \"highlight_end\": 33,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     match (& $ left, & $ right)\"\n+                    },\n+                    {\n+                        \"highlight_end\": 7,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 34,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         (left_val, right_val) =>\"\n+                    },\n+                    {\n+                        \"highlight_end\": 11,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 46,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             if ! (* left_val == * right_val)\"\n+                    },\n+                    {\n+                        \"highlight_end\": 15,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 25,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                 panic !\"\n+                    },\n+                    {\n+                        \"highlight_end\": 57,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n+                    },\n+                    {\n+                        \"highlight_end\": 16,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"  left: `{:?}`,\"\n+                    },\n+                    {\n+                        \"highlight_end\": 18,\n+                        \"highlight_start\": 1,\n+                        \"text\": \" right: `{:?}`\\\"#,\"\n+                    },\n+                    {\n+                        \"highlight_end\": 47,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                  & * left_val, & * right_val)\"\n+                    },\n+                    {\n+                        \"highlight_end\": 15,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 11,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 7,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 42,\n+                        \"highlight_start\": 1,\n+                        \"text\": \" }) ; ($ left : expr, $ right : expr,) =>\"\n+                    },\n+                    {\n+                        \"highlight_end\": 49,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"({ $ crate :: assert_eq ! ($ left, $ right) }) ;\"\n+                    },\n+                    {\n+                        \"highlight_end\": 53,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>\"\n+                    },\n+                    {\n+                        \"highlight_end\": 3,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"({\"\n+                    },\n+                    {\n+                        \"highlight_end\": 37,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     match (& ($ left), & ($ right))\"\n+                    },\n+                    {\n+                        \"highlight_end\": 7,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 34,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         (left_val, right_val) =>\"\n+                    },\n+                    {\n+                        \"highlight_end\": 11,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 46,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             if ! (* left_val == * right_val)\"\n+                    },\n+                    {\n+                        \"highlight_end\": 15,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             {\"\n+                    },\n+                    {\n+                        \"highlight_end\": 25,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                 panic !\"\n+                    },\n+                    {\n+                        \"highlight_end\": 57,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n+                    },\n+                    {\n+                        \"highlight_end\": 16,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"  left: `{:?}`,\"\n+                    },\n+                    {\n+                        \"highlight_end\": 22,\n+                        \"highlight_start\": 1,\n+                        \"text\": \" right: `{:?}`: {}\\\"#,\"\n+                    },\n+                    {\n+                        \"highlight_end\": 72,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                  & * left_val, & * right_val, $ crate :: format_args !\"\n+                    },\n+                    {\n+                        \"highlight_end\": 33,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"                  ($ ($ arg) +))\"\n+                    },\n+                    {\n+                        \"highlight_end\": 15,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"             }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 11,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"         }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 7,\n+                        \"highlight_start\": 1,\n+                        \"text\": \"     }\"\n+                    },\n+                    {\n+                        \"highlight_end\": 6,\n+                        \"highlight_start\": 1,\n+                        \"text\": \" }) ;\"\n+                    }\n+                ]\n+            },\n+            \"macro_decl_name\": \"assert_eq!\",\n+            \"span\": {\n+                \"byte_end\": 38,\n+                \"byte_start\": 16,\n+                \"column_end\": 27,\n+                \"column_start\": 5,\n+                \"expansion\": null,\n+                \"file_name\": \"src/main.rs\",\n+                \"is_primary\": false,\n+                \"label\": null,\n+                \"line_end\": 2,\n+                \"line_start\": 2,\n+                \"suggested_replacement\": null,\n+                \"suggestion_applicability\": null,\n+                \"text\": [\n+                    {\n+                        \"highlight_end\": 27,\n+                        \"highlight_start\": 5,\n+                        \"text\": \"    assert_eq!(1, \\\"love\\\");\"\n+                    }\n+                ]\n+            }\n+        },\n+        \"file_name\": \"<::core::macros::assert_eq macros>\",\n+        \"is_primary\": true,\n+        \"label\": \"no implementation for `{integer} == &str`\",\n+        \"line_end\": 7,\n+        \"line_start\": 7,\n+        \"suggested_replacement\": null,\n+        \"suggestion_applicability\": null,\n+        \"text\": [\n+            {\n+                \"highlight_end\": 33,\n+                \"highlight_start\": 31,\n+                \"text\": \"             if ! (* left_val == * right_val)\"\n+            }\n+        ]\n+    }\n+]\n+}\"##,\n+    );\n+\n+    let workspace_root = PathBuf::from(\"/test/\");\n+    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root).expect(\"couldn't map diagnostic\");\n+    insta::assert_debug_snapshot!(diag);\n+}"}, {"sha": "78250f91075446ceee61ef885e88c77971ebab0f", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -0,0 +1,392 @@\n+//! cargo_check provides the functionality needed to run `cargo check` or\n+//! another compatible command (f.x. clippy) in a background thread and provide\n+//! LSP diagnostics based on the output of the command.\n+use cargo_metadata::Message;\n+use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n+use lsp_types::{\n+    Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressEnd,\n+    WorkDoneProgressReport,\n+};\n+use parking_lot::RwLock;\n+use std::{\n+    collections::HashMap,\n+    path::PathBuf,\n+    process::{Command, Stdio},\n+    sync::Arc,\n+    thread::JoinHandle,\n+    time::Instant,\n+};\n+\n+mod conv;\n+\n+use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic, SuggestedFix};\n+\n+#[derive(Clone, Debug)]\n+pub struct CheckOptions {\n+    pub enable: bool,\n+    pub args: Vec<String>,\n+    pub command: String,\n+    pub all_targets: bool,\n+}\n+\n+/// CheckWatcher wraps the shared state and communication machinery used for\n+/// running `cargo check` (or other compatible command) and providing\n+/// diagnostics based on the output.\n+/// The spawned thread is shut down when this struct is dropped.\n+#[derive(Debug)]\n+pub struct CheckWatcher {\n+    pub task_recv: Receiver<CheckTask>,\n+    pub cmd_send: Option<Sender<CheckCommand>>,\n+    pub shared: Arc<RwLock<CheckWatcherSharedState>>,\n+    handle: Option<JoinHandle<()>>,\n+}\n+\n+impl CheckWatcher {\n+    pub fn new(options: &CheckOptions, workspace_root: PathBuf) -> CheckWatcher {\n+        let options = options.clone();\n+        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n+\n+        let (task_send, task_recv) = unbounded::<CheckTask>();\n+        let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n+        let shared_ = shared.clone();\n+        let handle = std::thread::spawn(move || {\n+            let mut check = CheckWatcherState::new(options, workspace_root, shared_);\n+            check.run(&task_send, &cmd_recv);\n+        });\n+        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), shared }\n+    }\n+\n+    /// Schedule a re-start of the cargo check worker.\n+    pub fn update(&self) {\n+        if let Some(cmd_send) = &self.cmd_send {\n+            cmd_send.send(CheckCommand::Update).unwrap();\n+        }\n+    }\n+}\n+\n+impl std::ops::Drop for CheckWatcher {\n+    fn drop(&mut self) {\n+        if let Some(handle) = self.handle.take() {\n+            // Take the sender out of the option\n+            let recv = self.cmd_send.take();\n+\n+            // Dropping the sender finishes the thread loop\n+            drop(recv);\n+\n+            // Join the thread, it should finish shortly. We don't really care\n+            // whether it panicked, so it is safe to ignore the result\n+            let _ = handle.join();\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct CheckWatcherSharedState {\n+    diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n+    suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n+}\n+\n+impl CheckWatcherSharedState {\n+    fn new() -> CheckWatcherSharedState {\n+        CheckWatcherSharedState {\n+            diagnostic_collection: HashMap::new(),\n+            suggested_fix_collection: HashMap::new(),\n+        }\n+    }\n+\n+    /// Clear the cached diagnostics, and schedule updating diagnostics by the\n+    /// server, to clear stale results.\n+    pub fn clear(&mut self, task_send: &Sender<CheckTask>) {\n+        let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n+\n+        self.diagnostic_collection.clear();\n+        self.suggested_fix_collection.clear();\n+\n+        for uri in cleared_files {\n+            task_send.send(CheckTask::Update(uri.clone())).unwrap();\n+        }\n+    }\n+\n+    pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n+        self.diagnostic_collection.get(uri).map(|d| d.as_slice())\n+    }\n+\n+    pub fn fixes_for(&self, uri: &Url) -> Option<&[SuggestedFix]> {\n+        self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n+    }\n+\n+    fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n+        let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n+\n+        // If we're building multiple targets it's possible we've already seen this diagnostic\n+        let is_duplicate = diagnostics.iter().any(|d| are_diagnostics_equal(d, &diagnostic));\n+        if is_duplicate {\n+            return;\n+        }\n+\n+        diagnostics.push(diagnostic);\n+    }\n+\n+    fn add_suggested_fix_for_diagnostic(\n+        &mut self,\n+        mut suggested_fix: SuggestedFix,\n+        diagnostic: &Diagnostic,\n+    ) {\n+        let file_uri = suggested_fix.location.uri.clone();\n+        let file_suggestions = self.suggested_fix_collection.entry(file_uri).or_default();\n+\n+        let existing_suggestion: Option<&mut SuggestedFix> =\n+            file_suggestions.iter_mut().find(|s| s == &&suggested_fix);\n+        if let Some(existing_suggestion) = existing_suggestion {\n+            // The existing suggestion also applies to this new diagnostic\n+            existing_suggestion.diagnostics.push(diagnostic.clone());\n+        } else {\n+            // We haven't seen this suggestion before\n+            suggested_fix.diagnostics.push(diagnostic.clone());\n+            file_suggestions.push(suggested_fix);\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum CheckTask {\n+    /// Request a update of the given files diagnostics\n+    Update(Url),\n+\n+    /// Request check progress notification to client\n+    Status(WorkDoneProgress),\n+}\n+\n+pub enum CheckCommand {\n+    /// Request re-start of check thread\n+    Update,\n+}\n+\n+struct CheckWatcherState {\n+    options: CheckOptions,\n+    workspace_root: PathBuf,\n+    watcher: WatchThread,\n+    last_update_req: Option<Instant>,\n+    shared: Arc<RwLock<CheckWatcherSharedState>>,\n+}\n+\n+impl CheckWatcherState {\n+    pub fn new(\n+        options: CheckOptions,\n+        workspace_root: PathBuf,\n+        shared: Arc<RwLock<CheckWatcherSharedState>>,\n+    ) -> CheckWatcherState {\n+        let watcher = WatchThread::new(&options, &workspace_root);\n+        CheckWatcherState { options, workspace_root, watcher, last_update_req: None, shared }\n+    }\n+\n+    pub fn run(&mut self, task_send: &Sender<CheckTask>, cmd_recv: &Receiver<CheckCommand>) {\n+        loop {\n+            select! {\n+                recv(&cmd_recv) -> cmd => match cmd {\n+                    Ok(cmd) => self.handle_command(cmd),\n+                    Err(RecvError) => {\n+                        // Command channel has closed, so shut down\n+                        break;\n+                    },\n+                },\n+                recv(self.watcher.message_recv) -> msg => match msg {\n+                    Ok(msg) => self.handle_message(msg, task_send),\n+                    Err(RecvError) => {\n+                        // Watcher finished, replace it with a never channel to\n+                        // avoid busy-waiting.\n+                        std::mem::replace(&mut self.watcher.message_recv, never());\n+                    },\n+                }\n+            };\n+\n+            if self.should_recheck() {\n+                self.last_update_req.take();\n+                self.shared.write().clear(task_send);\n+\n+                // By replacing the watcher, we drop the previous one which\n+                // causes it to shut down automatically.\n+                self.watcher = WatchThread::new(&self.options, &self.workspace_root);\n+            }\n+        }\n+    }\n+\n+    fn should_recheck(&mut self) -> bool {\n+        if let Some(_last_update_req) = &self.last_update_req {\n+            // We currently only request an update on save, as we need up to\n+            // date source on disk for cargo check to do it's magic, so we\n+            // don't really need to debounce the requests at this point.\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn handle_command(&mut self, cmd: CheckCommand) {\n+        match cmd {\n+            CheckCommand::Update => self.last_update_req = Some(Instant::now()),\n+        }\n+    }\n+\n+    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+        match msg {\n+            CheckEvent::Begin => {\n+                task_send\n+                    .send(CheckTask::Status(WorkDoneProgress::Begin(WorkDoneProgressBegin {\n+                        title: \"Running 'cargo check'\".to_string(),\n+                        cancellable: Some(false),\n+                        message: None,\n+                        percentage: None,\n+                    })))\n+                    .unwrap();\n+            }\n+\n+            CheckEvent::End => {\n+                task_send\n+                    .send(CheckTask::Status(WorkDoneProgress::End(WorkDoneProgressEnd {\n+                        message: None,\n+                    })))\n+                    .unwrap();\n+            }\n+\n+            CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n+                task_send\n+                    .send(CheckTask::Status(WorkDoneProgress::Report(WorkDoneProgressReport {\n+                        cancellable: Some(false),\n+                        message: Some(msg.target.name),\n+                        percentage: None,\n+                    })))\n+                    .unwrap();\n+            }\n+\n+            CheckEvent::Msg(Message::CompilerMessage(msg)) => {\n+                let map_result =\n+                    match map_rust_diagnostic_to_lsp(&msg.message, &self.workspace_root) {\n+                        Some(map_result) => map_result,\n+                        None => return,\n+                    };\n+\n+                let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n+                let file_uri = location.uri.clone();\n+\n+                if !suggested_fixes.is_empty() {\n+                    for suggested_fix in suggested_fixes {\n+                        self.shared\n+                            .write()\n+                            .add_suggested_fix_for_diagnostic(suggested_fix, &diagnostic);\n+                    }\n+                }\n+                self.shared.write().add_diagnostic(file_uri, diagnostic);\n+\n+                task_send.send(CheckTask::Update(location.uri)).unwrap();\n+            }\n+\n+            CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n+            CheckEvent::Msg(Message::Unknown) => {}\n+        }\n+    }\n+}\n+\n+/// WatchThread exists to wrap around the communication needed to be able to\n+/// run `cargo check` without blocking. Currently the Rust standard library\n+/// doesn't provide a way to read sub-process output without blocking, so we\n+/// have to wrap sub-processes output handling in a thread and pass messages\n+/// back over a channel.\n+/// The correct way to dispose of the thread is to drop it, on which the\n+/// sub-process will be killed, and the thread will be joined.\n+struct WatchThread {\n+    handle: Option<JoinHandle<()>>,\n+    message_recv: Receiver<CheckEvent>,\n+}\n+\n+enum CheckEvent {\n+    Begin,\n+    Msg(cargo_metadata::Message),\n+    End,\n+}\n+\n+impl WatchThread {\n+    fn new(options: &CheckOptions, workspace_root: &PathBuf) -> WatchThread {\n+        let mut args: Vec<String> = vec![\n+            options.command.clone(),\n+            \"--message-format=json\".to_string(),\n+            \"--manifest-path\".to_string(),\n+            format!(\"{}/Cargo.toml\", workspace_root.to_string_lossy()),\n+        ];\n+        if options.all_targets {\n+            args.push(\"--all-targets\".to_string());\n+        }\n+        args.extend(options.args.iter().cloned());\n+\n+        let (message_send, message_recv) = unbounded();\n+        let enabled = options.enable;\n+        let handle = std::thread::spawn(move || {\n+            if !enabled {\n+                return;\n+            }\n+\n+            let mut command = Command::new(\"cargo\")\n+                .args(&args)\n+                .stdout(Stdio::piped())\n+                .stderr(Stdio::null())\n+                .spawn()\n+                .expect(\"couldn't launch cargo\");\n+\n+            // If we trigger an error here, we will do so in the loop instead,\n+            // which will break out of the loop, and continue the shutdown\n+            let _ = message_send.send(CheckEvent::Begin);\n+\n+            for message in cargo_metadata::parse_messages(command.stdout.take().unwrap()) {\n+                let message = match message {\n+                    Ok(message) => message,\n+                    Err(err) => {\n+                        log::error!(\"Invalid json from cargo check, ignoring: {}\", err);\n+                        continue;\n+                    }\n+                };\n+\n+                match message_send.send(CheckEvent::Msg(message)) {\n+                    Ok(()) => {}\n+                    Err(_err) => {\n+                        // The send channel was closed, so we want to shutdown\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // We can ignore any error here, as we are already in the progress\n+            // of shutting down.\n+            let _ = message_send.send(CheckEvent::End);\n+\n+            // It is okay to ignore the result, as it only errors if the process is already dead\n+            let _ = command.kill();\n+\n+            // Again, we don't care about the exit status so just ignore the result\n+            let _ = command.wait();\n+        });\n+        WatchThread { handle: Some(handle), message_recv }\n+    }\n+}\n+\n+impl std::ops::Drop for WatchThread {\n+    fn drop(&mut self) {\n+        if let Some(handle) = self.handle.take() {\n+            // Replace our reciever with dummy one, so we can drop and close the\n+            // one actually communicating with the thread\n+            let recv = std::mem::replace(&mut self.message_recv, never());\n+\n+            // Dropping the original reciever initiates thread sub-process shutdown\n+            drop(recv);\n+\n+            // Join the thread, it should finish shortly. We don't really care\n+            // whether it panicked, so it is safe to ignore the result\n+            let _ = handle.join();\n+        }\n+    }\n+}\n+\n+fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n+    left.source == right.source\n+        && left.severity == right.severity\n+        && left.range == right.range\n+        && left.message == right.message\n+}"}, {"sha": "9b7dcb6e9ada277730c1daef727c29aeca343588", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -27,6 +27,7 @@ ra_project_model = { path = \"../ra_project_model\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_vfs_glob = { path = \"../ra_vfs_glob\" }\n env_logger = { version = \"0.7.1\", default-features = false, features = [\"humantime\"] }\n+ra_cargo_watch = { path = \"../ra_cargo_watch\" }\n \n [dev-dependencies]\n tempfile = \"3\""}, {"sha": "0dee1f6fead726771f484243a61851e1157633d8", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -3,7 +3,7 @@\n use lsp_types::{\n     CodeActionProviderCapability, CodeLensOptions, CompletionOptions,\n     DocumentOnTypeFormattingOptions, FoldingRangeProviderCapability,\n-    ImplementationProviderCapability, RenameOptions, RenameProviderCapability,\n+    ImplementationProviderCapability, RenameOptions, RenameProviderCapability, SaveOptions,\n     SelectionRangeProviderCapability, ServerCapabilities, SignatureHelpOptions,\n     TextDocumentSyncCapability, TextDocumentSyncKind, TextDocumentSyncOptions,\n     TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n@@ -16,7 +16,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n             change: Some(TextDocumentSyncKind::Full),\n             will_save: None,\n             will_save_wait_until: None,\n-            save: None,\n+            save: Some(SaveOptions::default()),\n         })),\n         hover_provider: Some(true),\n         completion_provider: Some(CompletionOptions {"}, {"sha": "2d7948d74aed79fd871a1ab88b99594484784260", "filename": "crates/ra_lsp_server/src/config.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -32,6 +32,11 @@ pub struct ServerConfig {\n \n     pub max_inlay_hint_length: Option<usize>,\n \n+    pub cargo_watch_enable: bool,\n+    pub cargo_watch_args: Vec<String>,\n+    pub cargo_watch_command: String,\n+    pub cargo_watch_all_targets: bool,\n+\n     /// For internal usage to make integrated tests faster.\n     #[serde(deserialize_with = \"nullable_bool_true\")]\n     pub with_sysroot: bool,\n@@ -51,6 +56,10 @@ impl Default for ServerConfig {\n             use_client_watching: false,\n             lru_capacity: None,\n             max_inlay_hint_length: None,\n+            cargo_watch_enable: true,\n+            cargo_watch_args: Vec::new(),\n+            cargo_watch_command: \"check\".to_string(),\n+            cargo_watch_all_targets: true,\n             with_sysroot: true,\n             feature_flags: FxHashMap::default(),\n             cargo_features: Default::default(),"}, {"sha": "af1a487ded10abb6ff6d7d814bcc3ff373af33f2", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -10,6 +10,7 @@ use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{ClientCapabilities, NumberOrString};\n+use ra_cargo_watch::{CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n use ra_vfs::{VfsTask, Watch};\n@@ -126,6 +127,12 @@ pub fn main_loop(\n                     .and_then(|it| it.line_folding_only)\n                     .unwrap_or(false),\n                 max_inlay_hint_length: config.max_inlay_hint_length,\n+                cargo_watch: CheckOptions {\n+                    enable: config.cargo_watch_enable,\n+                    args: config.cargo_watch_args,\n+                    command: config.cargo_watch_command,\n+                    all_targets: config.cargo_watch_all_targets,\n+                },\n             }\n         };\n \n@@ -176,7 +183,11 @@ pub fn main_loop(\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => Err(\"vfs died\")?,\n                 },\n-                recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n+                recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n+                recv(world_state.check_watcher.task_recv) -> task => match task {\n+                    Ok(task) => Event::CheckWatcher(task),\n+                    Err(RecvError) => Err(\"check watcher died\")?,\n+                }\n             };\n             if let Event::Msg(Message::Request(req)) = &event {\n                 if connection.handle_shutdown(&req)? {\n@@ -222,6 +233,7 @@ enum Event {\n     Task(Task),\n     Vfs(VfsTask),\n     Lib(LibraryData),\n+    CheckWatcher(CheckTask),\n }\n \n impl fmt::Debug for Event {\n@@ -259,6 +271,7 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::Lib(it) => fmt::Debug::fmt(it, f),\n+            Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n@@ -318,6 +331,28 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n+        Event::CheckWatcher(task) => match task {\n+            CheckTask::Update(uri) => {\n+                // We manually send a diagnostic update when the watcher asks\n+                // us to, to avoid the issue of having to change the file to\n+                // receive updated diagnostics.\n+                let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n+                if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n+                    let params =\n+                        handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n+                    let not = notification_new::<req::PublishDiagnostics>(params);\n+                    task_sender.send(Task::Notify(not)).unwrap();\n+                }\n+            }\n+            CheckTask::Status(progress) => {\n+                let params = req::ProgressParams {\n+                    token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n+                    value: req::ProgressParamsValue::WorkDone(progress),\n+                };\n+                let not = notification_new::<req::Progress>(params);\n+                task_sender.send(Task::Notify(not)).unwrap();\n+            }\n+        },\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -517,6 +552,13 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n+    let not = match notification_cast::<req::DidSaveTextDocument>(not) {\n+        Ok(_params) => {\n+            state.check_watcher.update();\n+            return Ok(());\n+        }\n+        Err(not) => not,\n+    };\n     let not = match notification_cast::<req::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;"}, {"sha": "331beab1345e679c00a50233e869adf05698dc23", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -654,6 +654,29 @@ pub fn handle_code_action(\n         res.push(action.into());\n     }\n \n+    for fix in world.check_watcher.read().fixes_for(&params.text_document.uri).into_iter().flatten()\n+    {\n+        let fix_range = fix.location.range.conv_with(&line_index);\n+        if fix_range.intersection(&range).is_none() {\n+            continue;\n+        }\n+\n+        let edits = vec![TextEdit::new(fix.location.range, fix.replacement.clone())];\n+        let mut edit_map = std::collections::HashMap::new();\n+        edit_map.insert(fix.location.uri.clone(), edits);\n+        let edit = WorkspaceEdit::new(edit_map);\n+\n+        let action = CodeAction {\n+            title: fix.title.clone(),\n+            kind: Some(\"quickfix\".to_string()),\n+            diagnostics: Some(fix.diagnostics.clone()),\n+            edit: Some(edit),\n+            command: None,\n+            is_preferred: None,\n+        };\n+        res.push(action.into());\n+    }\n+\n     for assist in assists {\n         let title = assist.change.label.clone();\n         let edit = assist.change.try_conv_with(&world)?;\n@@ -820,7 +843,7 @@ pub fn publish_diagnostics(\n     let _p = profile(\"publish_diagnostics\");\n     let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics = world\n+    let mut diagnostics: Vec<Diagnostic> = world\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -834,6 +857,9 @@ pub fn publish_diagnostics(\n             tags: None,\n         })\n         .collect();\n+    if let Some(check_diags) = world.check_watcher.read().diagnostics_for(&uri) {\n+        diagnostics.extend(check_diags.iter().cloned());\n+    }\n     Ok(req::PublishDiagnosticsParams { uri, diagnostics, version: None })\n }\n "}, {"sha": "40edaf6770e4de77fb66f4eb9e9fd9ca80176bc8", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -9,10 +9,10 @@ pub use lsp_types::{\n     CodeLensParams, CompletionParams, CompletionResponse, DidChangeConfigurationParams,\n     DidChangeWatchedFilesParams, DidChangeWatchedFilesRegistrationOptions,\n     DocumentOnTypeFormattingParams, DocumentSymbolParams, DocumentSymbolResponse,\n-    FileSystemWatcher, Hover, InitializeResult, MessageType, PublishDiagnosticsParams,\n-    ReferenceParams, Registration, RegistrationParams, SelectionRange, SelectionRangeParams,\n-    ShowMessageParams, SignatureHelp, TextDocumentEdit, TextDocumentPositionParams, TextEdit,\n-    WorkspaceEdit, WorkspaceSymbolParams,\n+    FileSystemWatcher, Hover, InitializeResult, MessageType, ProgressParams, ProgressParamsValue,\n+    ProgressToken, PublishDiagnosticsParams, ReferenceParams, Registration, RegistrationParams,\n+    SelectionRange, SelectionRangeParams, ShowMessageParams, SignatureHelp, TextDocumentEdit,\n+    TextDocumentPositionParams, TextEdit, WorkspaceEdit, WorkspaceSymbolParams,\n };\n \n pub enum AnalyzerStatus {}"}, {"sha": "4b3959e38a0f8193846523fb5c01c7032109c14a", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -12,6 +12,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n+use ra_cargo_watch::{CheckOptions, CheckWatcher, CheckWatcherSharedState};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n@@ -34,6 +35,7 @@ pub struct Options {\n     pub supports_location_link: bool,\n     pub line_folding_only: bool,\n     pub max_inlay_hint_length: Option<usize>,\n+    pub cargo_watch: CheckOptions,\n }\n \n /// `WorldState` is the primary mutable state of the language server\n@@ -52,6 +54,7 @@ pub struct WorldState {\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub task_receiver: Receiver<VfsTask>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n+    pub check_watcher: CheckWatcher,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -61,6 +64,7 @@ pub struct WorldSnapshot {\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n+    pub check_watcher: Arc<RwLock<CheckWatcherSharedState>>,\n }\n \n impl WorldState {\n@@ -127,6 +131,10 @@ impl WorldState {\n         }\n         change.set_crate_graph(crate_graph);\n \n+        // FIXME: Figure out the multi-workspace situation\n+        let check_watcher =\n+            CheckWatcher::new(&options.cargo_watch, folder_roots.first().cloned().unwrap());\n+\n         let mut analysis_host = AnalysisHost::new(lru_capacity, feature_flags);\n         analysis_host.apply_change(change);\n         WorldState {\n@@ -138,6 +146,7 @@ impl WorldState {\n             vfs: Arc::new(RwLock::new(vfs)),\n             task_receiver,\n             latest_requests: Default::default(),\n+            check_watcher,\n         }\n     }\n \n@@ -199,6 +208,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n+            check_watcher: self.check_watcher.shared.clone(),\n         }\n     }\n "}, {"sha": "69298e917854ae0c091df4e4b34569a69bacf56d", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 44, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -18,7 +18,7 @@\n     \"scripts\": {\n         \"vscode:prepublish\": \"npm run compile\",\n         \"package\": \"vsce package\",\n-        \"compile\": \"rollup -c && shx cp src/utils/terminateProcess.sh bundle/terminateProcess.sh\",\n+        \"compile\": \"rollup -c\",\n         \"watch\": \"tsc -watch -p ./\",\n         \"fix\": \"prettier **/*.{json,ts} --write && tslint --project . --fix\",\n         \"lint\": \"tslint --project .\",\n@@ -133,16 +133,6 @@\n                 \"command\": \"rust-analyzer.reload\",\n                 \"title\": \"Restart server\",\n                 \"category\": \"Rust Analyzer\"\n-            },\n-            {\n-                \"command\": \"rust-analyzer.startCargoWatch\",\n-                \"title\": \"Start Cargo Watch\",\n-                \"category\": \"Rust Analyzer\"\n-            },\n-            {\n-                \"command\": \"rust-analyzer.stopCargoWatch\",\n-                \"title\": \"Stop Cargo Watch\",\n-                \"category\": \"Rust Analyzer\"\n             }\n         ],\n         \"keybindings\": [\n@@ -198,21 +188,6 @@\n                     \"default\": \"ra_lsp_server\",\n                     \"description\": \"Path to ra_lsp_server executable\"\n                 },\n-                \"rust-analyzer.enableCargoWatchOnStartup\": {\n-                    \"type\": \"string\",\n-                    \"default\": \"ask\",\n-                    \"enum\": [\n-                        \"ask\",\n-                        \"enabled\",\n-                        \"disabled\"\n-                    ],\n-                    \"enumDescriptions\": [\n-                        \"Asks each time whether to run `cargo watch`\",\n-                        \"`cargo watch` is always started\",\n-                        \"Don't start `cargo watch`\"\n-                    ],\n-                    \"description\": \"Whether to run `cargo watch` on startup\"\n-                },\n                 \"rust-analyzer.excludeGlobs\": {\n                     \"type\": \"array\",\n                     \"default\": [],\n@@ -223,21 +198,21 @@\n                     \"default\": true,\n                     \"description\": \"client provided file watching instead of notify watching.\"\n                 },\n+                \"rust-analyzer.cargo-watch.enable\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": true,\n+                    \"description\": \"Run `cargo check` for diagnostics on save\"\n+                },\n                 \"rust-analyzer.cargo-watch.arguments\": {\n-                    \"type\": \"string\",\n+                    \"type\": \"array\",\n                     \"description\": \"`cargo-watch` arguments. (e.g: `--features=\\\"shumway,pdf\\\"` will run as `cargo watch -x \\\"check --features=\\\"shumway,pdf\\\"\\\"` )\",\n-                    \"default\": \"\"\n+                    \"default\": []\n                 },\n                 \"rust-analyzer.cargo-watch.command\": {\n                     \"type\": \"string\",\n                     \"description\": \"`cargo-watch` command. (e.g: `clippy` will run as `cargo watch -x clippy` )\",\n                     \"default\": \"check\"\n                 },\n-                \"rust-analyzer.cargo-watch.ignore\": {\n-                    \"type\": \"array\",\n-                    \"description\": \"A list of patterns for cargo-watch to ignore (will be passed as `--ignore`)\",\n-                    \"default\": []\n-                },\n                 \"rust-analyzer.cargo-watch.allTargets\": {\n                     \"type\": \"boolean\",\n                     \"description\": \"Check all targets and tests (will be passed as `--all-targets`)\",\n@@ -259,17 +234,6 @@\n                     \"default\": \"off\",\n                     \"description\": \"Trace requests to the ra_lsp_server\"\n                 },\n-                \"rust-analyzer.trace.cargo-watch\": {\n-                    \"type\": \"string\",\n-                    \"scope\": \"window\",\n-                    \"enum\": [\n-                        \"off\",\n-                        \"error\",\n-                        \"verbose\"\n-                    ],\n-                    \"default\": \"off\",\n-                    \"description\": \"Trace output of cargo-watch\"\n-                },\n                 \"rust-analyzer.lruCapacity\": {\n                     \"type\": \"number\",\n                     \"default\": null,"}, {"sha": "ac62bdd48d20144951c6c67cfa86d470c610581e", "filename": "editors/code/src/commands/cargo_watch.ts", "status": "removed", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fcargo_watch.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,264 +0,0 @@\n-import * as child_process from 'child_process';\n-import * as path from 'path';\n-import * as vscode from 'vscode';\n-\n-import { Server } from '../server';\n-import { terminate } from '../utils/processes';\n-import { LineBuffer } from './line_buffer';\n-import { StatusDisplay } from './watch_status';\n-\n-import {\n-    mapRustDiagnosticToVsCode,\n-    RustDiagnostic,\n-} from '../utils/diagnostics/rust';\n-import SuggestedFixCollection from '../utils/diagnostics/SuggestedFixCollection';\n-import { areDiagnosticsEqual } from '../utils/diagnostics/vscode';\n-\n-export async function registerCargoWatchProvider(\n-    subscriptions: vscode.Disposable[],\n-): Promise<CargoWatchProvider | undefined> {\n-    let cargoExists = false;\n-\n-    // Check if the working directory is valid cargo root path\n-    const cargoTomlPath = path.join(vscode.workspace.rootPath!, 'Cargo.toml');\n-    const cargoTomlUri = vscode.Uri.file(cargoTomlPath);\n-    const cargoTomlFileInfo = await vscode.workspace.fs.stat(cargoTomlUri);\n-\n-    if (cargoTomlFileInfo) {\n-        cargoExists = true;\n-    }\n-\n-    if (!cargoExists) {\n-        vscode.window.showErrorMessage(\n-            `Couldn\\'t find \\'Cargo.toml\\' at ${cargoTomlPath}`,\n-        );\n-        return;\n-    }\n-\n-    const provider = new CargoWatchProvider();\n-    subscriptions.push(provider);\n-    return provider;\n-}\n-\n-export class CargoWatchProvider implements vscode.Disposable {\n-    private readonly diagnosticCollection: vscode.DiagnosticCollection;\n-    private readonly statusDisplay: StatusDisplay;\n-    private readonly outputChannel: vscode.OutputChannel;\n-\n-    private suggestedFixCollection: SuggestedFixCollection;\n-    private codeActionDispose: vscode.Disposable;\n-\n-    private cargoProcess?: child_process.ChildProcess;\n-\n-    constructor() {\n-        this.diagnosticCollection = vscode.languages.createDiagnosticCollection(\n-            'rustc',\n-        );\n-        this.statusDisplay = new StatusDisplay(\n-            Server.config.cargoWatchOptions.command,\n-        );\n-        this.outputChannel = vscode.window.createOutputChannel(\n-            'Cargo Watch Trace',\n-        );\n-\n-        // Track `rustc`'s suggested fixes so we can convert them to code actions\n-        this.suggestedFixCollection = new SuggestedFixCollection();\n-        this.codeActionDispose = vscode.languages.registerCodeActionsProvider(\n-            [{ scheme: 'file', language: 'rust' }],\n-            this.suggestedFixCollection,\n-            {\n-                providedCodeActionKinds:\n-                    SuggestedFixCollection.PROVIDED_CODE_ACTION_KINDS,\n-            },\n-        );\n-    }\n-\n-    public start() {\n-        if (this.cargoProcess) {\n-            vscode.window.showInformationMessage(\n-                'Cargo Watch is already running',\n-            );\n-            return;\n-        }\n-\n-        let args =\n-            Server.config.cargoWatchOptions.command + ' --message-format json';\n-        if (Server.config.cargoWatchOptions.allTargets) {\n-            args += ' --all-targets';\n-        }\n-        if (Server.config.cargoWatchOptions.command.length > 0) {\n-            // Excape the double quote string:\n-            args += ' ' + Server.config.cargoWatchOptions.arguments;\n-        }\n-        // Windows handles arguments differently than the unix-likes, so we need to wrap the args in double quotes\n-        if (process.platform === 'win32') {\n-            args = '\"' + args + '\"';\n-        }\n-\n-        const ignoreFlags = Server.config.cargoWatchOptions.ignore.reduce(\n-            (flags, pattern) => [...flags, '--ignore', pattern],\n-            [] as string[],\n-        );\n-\n-        // Start the cargo watch with json message\n-        this.cargoProcess = child_process.spawn(\n-            'cargo',\n-            ['watch', '-x', args, ...ignoreFlags],\n-            {\n-                stdio: ['ignore', 'pipe', 'pipe'],\n-                cwd: vscode.workspace.rootPath,\n-                windowsVerbatimArguments: true,\n-            },\n-        );\n-\n-        if (!this.cargoProcess) {\n-            vscode.window.showErrorMessage('Cargo Watch failed to start');\n-            return;\n-        }\n-\n-        const stdoutData = new LineBuffer();\n-        this.cargoProcess.stdout?.on('data', (s: string) => {\n-            stdoutData.processOutput(s, line => {\n-                this.logInfo(line);\n-                try {\n-                    this.parseLine(line);\n-                } catch (err) {\n-                    this.logError(`Failed to parse: ${err}, content : ${line}`);\n-                }\n-            });\n-        });\n-\n-        const stderrData = new LineBuffer();\n-        this.cargoProcess.stderr?.on('data', (s: string) => {\n-            stderrData.processOutput(s, line => {\n-                this.logError('Error on cargo-watch : {\\n' + line + '}\\n');\n-            });\n-        });\n-\n-        this.cargoProcess.on('error', (err: Error) => {\n-            this.logError(\n-                'Error on cargo-watch process : {\\n' + err.message + '}\\n',\n-            );\n-        });\n-\n-        this.logInfo('cargo-watch started.');\n-    }\n-\n-    public stop() {\n-        if (this.cargoProcess) {\n-            this.cargoProcess.kill();\n-            terminate(this.cargoProcess);\n-            this.cargoProcess = undefined;\n-        } else {\n-            vscode.window.showInformationMessage('Cargo Watch is not running');\n-        }\n-    }\n-\n-    public dispose(): void {\n-        this.stop();\n-\n-        this.diagnosticCollection.clear();\n-        this.diagnosticCollection.dispose();\n-        this.outputChannel.dispose();\n-        this.statusDisplay.dispose();\n-        this.codeActionDispose.dispose();\n-    }\n-\n-    private logInfo(line: string) {\n-        if (Server.config.cargoWatchOptions.trace === 'verbose') {\n-            this.outputChannel.append(line);\n-        }\n-    }\n-\n-    private logError(line: string) {\n-        if (\n-            Server.config.cargoWatchOptions.trace === 'error' ||\n-            Server.config.cargoWatchOptions.trace === 'verbose'\n-        ) {\n-            this.outputChannel.append(line);\n-        }\n-    }\n-\n-    private parseLine(line: string) {\n-        if (line.startsWith('[Running')) {\n-            this.diagnosticCollection.clear();\n-            this.suggestedFixCollection.clear();\n-            this.statusDisplay.show();\n-        }\n-\n-        if (line.startsWith('[Finished running')) {\n-            this.statusDisplay.hide();\n-        }\n-\n-        interface CargoArtifact {\n-            reason: string;\n-            package_id: string;\n-        }\n-\n-        // https://github.com/rust-lang/cargo/blob/master/src/cargo/util/machine_message.rs\n-        interface CargoMessage {\n-            reason: string;\n-            package_id: string;\n-            message: RustDiagnostic;\n-        }\n-\n-        // cargo-watch itself output non json format\n-        // Ignore these lines\n-        let data: CargoMessage;\n-        try {\n-            data = JSON.parse(line.trim());\n-        } catch (error) {\n-            this.logError(`Fail to parse to json : { ${error} }`);\n-            return;\n-        }\n-\n-        if (data.reason === 'compiler-artifact') {\n-            const msg = data as CargoArtifact;\n-\n-            // The format of the package_id is \"{name} {version} ({source_id})\",\n-            // https://github.com/rust-lang/cargo/blob/37ad03f86e895bb80b474c1c088322634f4725f5/src/cargo/core/package_id.rs#L53\n-            this.statusDisplay.packageName = msg.package_id.split(' ')[0];\n-        } else if (data.reason === 'compiler-message') {\n-            const msg = data.message as RustDiagnostic;\n-\n-            const mapResult = mapRustDiagnosticToVsCode(msg);\n-            if (!mapResult) {\n-                return;\n-            }\n-\n-            const { location, diagnostic, suggestedFixes } = mapResult;\n-            const fileUri = location.uri;\n-\n-            const diagnostics: vscode.Diagnostic[] = [\n-                ...(this.diagnosticCollection!.get(fileUri) || []),\n-            ];\n-\n-            // If we're building multiple targets it's possible we've already seen this diagnostic\n-            const isDuplicate = diagnostics.some(d =>\n-                areDiagnosticsEqual(d, diagnostic),\n-            );\n-            if (isDuplicate) {\n-                return;\n-            }\n-\n-            diagnostics.push(diagnostic);\n-            this.diagnosticCollection!.set(fileUri, diagnostics);\n-\n-            if (suggestedFixes.length) {\n-                for (const suggestedFix of suggestedFixes) {\n-                    this.suggestedFixCollection.addSuggestedFixForDiagnostic(\n-                        suggestedFix,\n-                        diagnostic,\n-                    );\n-                }\n-\n-                // Have VsCode query us for the code actions\n-                vscode.commands.executeCommand(\n-                    'vscode.executeCodeActionProvider',\n-                    fileUri,\n-                    diagnostic.range,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "7728541de61bd356390ffe57f6de4fece182d850", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -1,11 +1,7 @@\n-import * as child_process from 'child_process';\n-\n-import * as util from 'util';\n import * as vscode from 'vscode';\n import * as lc from 'vscode-languageclient';\n \n import { Server } from '../server';\n-import { CargoWatchProvider, registerCargoWatchProvider } from './cargo_watch';\n \n interface RunnablesParams {\n     textDocument: lc.TextDocumentIdentifier;\n@@ -131,90 +127,3 @@ export async function handleSingle(runnable: Runnable) {\n \n     return vscode.tasks.executeTask(task);\n }\n-\n-/**\n- * Interactively asks the user whether we should run `cargo check` in order to\n- * provide inline diagnostics; the user is met with a series of dialog boxes\n- * that, when accepted, allow us to `cargo install cargo-watch` and then run it.\n- */\n-export async function interactivelyStartCargoWatch(\n-    context: vscode.ExtensionContext,\n-): Promise<CargoWatchProvider | undefined> {\n-    if (Server.config.cargoWatchOptions.enableOnStartup === 'disabled') {\n-        return;\n-    }\n-\n-    if (Server.config.cargoWatchOptions.enableOnStartup === 'ask') {\n-        const watch = await vscode.window.showInformationMessage(\n-            'Start watching changes with cargo? (Executes `cargo watch`, provides inline diagnostics)',\n-            'yes',\n-            'no',\n-        );\n-        if (watch !== 'yes') {\n-            return;\n-        }\n-    }\n-\n-    return startCargoWatch(context);\n-}\n-\n-export async function startCargoWatch(\n-    context: vscode.ExtensionContext,\n-): Promise<CargoWatchProvider | undefined> {\n-    const execPromise = util.promisify(child_process.exec);\n-\n-    const { stderr, code = 0 } = await execPromise(\n-        'cargo watch --version',\n-    ).catch(e => e);\n-\n-    if (stderr.includes('no such subcommand: `watch`')) {\n-        const msg =\n-            'The `cargo-watch` subcommand is not installed. Install? (takes ~1-2 minutes)';\n-        const install = await vscode.window.showInformationMessage(\n-            msg,\n-            'yes',\n-            'no',\n-        );\n-        if (install !== 'yes') {\n-            return;\n-        }\n-\n-        const label = 'install-cargo-watch';\n-        const taskFinished = new Promise((resolve, _reject) => {\n-            const disposable = vscode.tasks.onDidEndTask(({ execution }) => {\n-                if (execution.task.name === label) {\n-                    disposable.dispose();\n-                    resolve();\n-                }\n-            });\n-        });\n-\n-        vscode.tasks.executeTask(\n-            createTask({\n-                label,\n-                bin: 'cargo',\n-                args: ['install', 'cargo-watch'],\n-                env: {},\n-            }),\n-        );\n-        await taskFinished;\n-        const output = await execPromise('cargo watch --version').catch(e => e);\n-        if (output.stderr !== '') {\n-            vscode.window.showErrorMessage(\n-                `Couldn't install \\`cargo-\\`watch: ${output.stderr}`,\n-            );\n-            return;\n-        }\n-    } else if (code !== 0) {\n-        vscode.window.showErrorMessage(\n-            `\\`cargo watch\\` failed with ${code}: ${stderr}`,\n-        );\n-        return;\n-    }\n-\n-    const provider = await registerCargoWatchProvider(context.subscriptions);\n-    if (provider) {\n-        provider.start();\n-    }\n-    return provider;\n-}"}, {"sha": "10787b5101f75211a1eecad05772bd0809fc7439", "filename": "editors/code/src/commands/watch_status.ts", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fwatch_status.ts?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -57,7 +57,49 @@ export class StatusDisplay implements vscode.Disposable {\n         this.statusBarItem.dispose();\n     }\n \n+    public handleProgressNotification(params: ProgressParams) {\n+        const { token, value } = params;\n+        if (token !== 'rustAnalyzer/cargoWatcher') {\n+            return;\n+        }\n+\n+        switch (value.kind) {\n+            case 'begin':\n+                this.show();\n+                break;\n+\n+            case 'report':\n+                if (value.message) {\n+                    this.packageName = value.message;\n+                }\n+                break;\n+\n+            case 'end':\n+                this.hide();\n+                break;\n+        }\n+    }\n+\n     private frame() {\n         return spinnerFrames[(this.i = ++this.i % spinnerFrames.length)];\n     }\n }\n+\n+// FIXME: Replace this once vscode-languageclient is updated to LSP 3.15\n+interface ProgressParams {\n+    token: string;\n+    value: WorkDoneProgress;\n+}\n+\n+enum WorkDoneProgressKind {\n+    Begin = 'begin',\n+    Report = 'report',\n+    End = 'end',\n+}\n+\n+interface WorkDoneProgress {\n+    kind: WorkDoneProgressKind;\n+    message?: string;\n+    cancelable?: boolean;\n+    percentage?: string;\n+}"}, {"sha": "4b388b80c54b0c0f4baed3ff136832cd0133b8fc", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -4,15 +4,10 @@ import { Server } from './server';\n \n const RA_LSP_DEBUG = process.env.__RA_LSP_SERVER_DEBUG;\n \n-export type CargoWatchStartupOptions = 'ask' | 'enabled' | 'disabled';\n-export type CargoWatchTraceOptions = 'off' | 'error' | 'verbose';\n-\n export interface CargoWatchOptions {\n-    enableOnStartup: CargoWatchStartupOptions;\n-    arguments: string;\n+    enable: boolean;\n+    arguments: string[];\n     command: string;\n-    trace: CargoWatchTraceOptions;\n-    ignore: string[];\n     allTargets: boolean;\n }\n \n@@ -36,11 +31,9 @@ export class Config {\n     // for internal use\n     public withSysroot: null | boolean = null;\n     public cargoWatchOptions: CargoWatchOptions = {\n-        enableOnStartup: 'ask',\n-        trace: 'off',\n-        arguments: '',\n+        enable: true,\n+        arguments: [],\n         command: '',\n-        ignore: [],\n         allTargets: true,\n     };\n     public cargoFeatures: CargoFeatures = {\n@@ -100,23 +93,17 @@ export class Config {\n                 RA_LSP_DEBUG || (config.get('raLspServerPath') as string);\n         }\n \n-        if (config.has('enableCargoWatchOnStartup')) {\n-            this.cargoWatchOptions.enableOnStartup = config.get<\n-                CargoWatchStartupOptions\n-            >('enableCargoWatchOnStartup', 'ask');\n-        }\n-\n-        if (config.has('trace.cargo-watch')) {\n-            this.cargoWatchOptions.trace = config.get<CargoWatchTraceOptions>(\n-                'trace.cargo-watch',\n-                'off',\n+        if (config.has('cargo-watch.enable')) {\n+            this.cargoWatchOptions.enable = config.get<boolean>(\n+                'cargo-watch.enable',\n+                true,\n             );\n         }\n \n         if (config.has('cargo-watch.arguments')) {\n-            this.cargoWatchOptions.arguments = config.get<string>(\n+            this.cargoWatchOptions.arguments = config.get<string[]>(\n                 'cargo-watch.arguments',\n-                '',\n+                [],\n             );\n         }\n \n@@ -127,13 +114,6 @@ export class Config {\n             );\n         }\n \n-        if (config.has('cargo-watch.ignore')) {\n-            this.cargoWatchOptions.ignore = config.get<string[]>(\n-                'cargo-watch.ignore',\n-                [],\n-            );\n-        }\n-\n         if (config.has('cargo-watch.allTargets')) {\n             this.cargoWatchOptions.allTargets = config.get<boolean>(\n                 'cargo-watch.allTargets',"}, {"sha": "1da10ebd06fc1de9edf7d6677a0aab55bf5d42a8", "filename": "editors/code/src/extension.ts", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fextension.ts?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -2,14 +2,10 @@ import * as vscode from 'vscode';\n import * as lc from 'vscode-languageclient';\n \n import * as commands from './commands';\n-import { CargoWatchProvider } from './commands/cargo_watch';\n import { ExpandMacroContentProvider } from './commands/expand_macro';\n import { HintsUpdater } from './commands/inlay_hints';\n-import {\n-    interactivelyStartCargoWatch,\n-    startCargoWatch,\n-} from './commands/runnables';\n import { SyntaxTreeContentProvider } from './commands/syntaxTree';\n+import { StatusDisplay } from './commands/watch_status';\n import * as events from './events';\n import * as notifications from './notifications';\n import { Server } from './server';\n@@ -88,6 +84,11 @@ export async function activate(context: vscode.ExtensionContext) {\n         overrideCommand('type', commands.onEnter.handle);\n     }\n \n+    const watchStatus = new StatusDisplay(\n+        Server.config.cargoWatchOptions.command,\n+    );\n+    disposeOnDeactivation(watchStatus);\n+\n     // Notifications are events triggered by the language server\n     const allNotifications: Iterable<[\n         string,\n@@ -97,6 +98,10 @@ export async function activate(context: vscode.ExtensionContext) {\n             'rust-analyzer/publishDecorations',\n             notifications.publishDecorations.handle,\n         ],\n+        [\n+            '$/progress',\n+            params => watchStatus.handleProgressNotification(params),\n+        ],\n     ];\n     const syntaxTreeContentProvider = new SyntaxTreeContentProvider();\n     const expandMacroContentProvider = new ExpandMacroContentProvider();\n@@ -139,26 +144,6 @@ export async function activate(context: vscode.ExtensionContext) {\n \n     vscode.commands.registerCommand('rust-analyzer.reload', reloadCommand);\n \n-    // Executing `cargo watch` provides us with inline diagnostics on save\n-    let provider: CargoWatchProvider | undefined;\n-    interactivelyStartCargoWatch(context).then(p => {\n-        provider = p;\n-    });\n-    registerCommand('rust-analyzer.startCargoWatch', () => {\n-        if (provider) {\n-            provider.start();\n-        } else {\n-            startCargoWatch(context).then(p => {\n-                provider = p;\n-            });\n-        }\n-    });\n-    registerCommand('rust-analyzer.stopCargoWatch', () => {\n-        if (provider) {\n-            provider.stop();\n-        }\n-    });\n-\n     // Start the language server, finally!\n     try {\n         await startServer();"}, {"sha": "ae81af84835b6ddc3a6ff627557dcf2ce0f68851", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc48f89581843248660ceb755bb20469ab6ac0c9/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=dc48f89581843248660ceb755bb20469ab6ac0c9", "patch": "@@ -55,6 +55,11 @@ export class Server {\n                 publishDecorations: true,\n                 lruCapacity: Server.config.lruCapacity,\n                 maxInlayHintLength: Server.config.maxInlayHintLength,\n+                cargoWatchEnable: Server.config.cargoWatchOptions.enable,\n+                cargoWatchArgumets: Server.config.cargoWatchOptions.arguments,\n+                cargoWatchCommand: Server.config.cargoWatchOptions.command,\n+                cargoWatchAllTargets:\n+                    Server.config.cargoWatchOptions.allTargets,\n                 excludeGlobs: Server.config.excludeGlobs,\n                 useClientWatching: Server.config.useClientWatching,\n                 featureFlags: Server.config.featureFlags,"}, {"sha": "d874e99bc556dc198bc44ff0fd494c66c1d44caf", "filename": "editors/code/src/test/fixtures/rust-diagnostics/clippy/trivially_copy_pass_by_ref.json", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fclippy%2Ftrivially_copy_pass_by_ref.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fclippy%2Ftrivially_copy_pass_by_ref.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fclippy%2Ftrivially_copy_pass_by_ref.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,110 +0,0 @@\n-{\n-    \"message\": \"this argument is passed by reference, but would be more efficient if passed by value\",\n-    \"code\": {\n-        \"code\": \"clippy::trivially_copy_pass_by_ref\",\n-        \"explanation\": null\n-    },\n-    \"level\": \"warning\",\n-    \"spans\": [\n-        {\n-            \"file_name\": \"compiler/mir/tagset.rs\",\n-            \"byte_start\": 941,\n-            \"byte_end\": 946,\n-            \"line_start\": 42,\n-            \"line_end\": 42,\n-            \"column_start\": 24,\n-            \"column_end\": 29,\n-            \"is_primary\": true,\n-            \"text\": [\n-                {\n-                    \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                    \"highlight_start\": 24,\n-                    \"highlight_end\": 29\n-                }\n-            ],\n-            \"label\": null,\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        }\n-    ],\n-    \"children\": [\n-        {\n-            \"message\": \"lint level defined here\",\n-            \"code\": null,\n-            \"level\": \"note\",\n-            \"spans\": [\n-                {\n-                    \"file_name\": \"compiler/lib.rs\",\n-                    \"byte_start\": 8,\n-                    \"byte_end\": 19,\n-                    \"line_start\": 1,\n-                    \"line_end\": 1,\n-                    \"column_start\": 9,\n-                    \"column_end\": 20,\n-                    \"is_primary\": true,\n-                    \"text\": [\n-                        {\n-                            \"text\": \"#![warn(clippy::all)]\",\n-                            \"highlight_start\": 9,\n-                            \"highlight_end\": 20\n-                        }\n-                    ],\n-                    \"label\": null,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"expansion\": null\n-                }\n-            ],\n-            \"children\": [],\n-            \"rendered\": null\n-        },\n-        {\n-            \"message\": \"#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\",\n-            \"code\": null,\n-            \"level\": \"note\",\n-            \"spans\": [],\n-            \"children\": [],\n-            \"rendered\": null\n-        },\n-        {\n-            \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n-            \"code\": null,\n-            \"level\": \"help\",\n-            \"spans\": [],\n-            \"children\": [],\n-            \"rendered\": null\n-        },\n-        {\n-            \"message\": \"consider passing by value instead\",\n-            \"code\": null,\n-            \"level\": \"help\",\n-            \"spans\": [\n-                {\n-                    \"file_name\": \"compiler/mir/tagset.rs\",\n-                    \"byte_start\": 941,\n-                    \"byte_end\": 946,\n-                    \"line_start\": 42,\n-                    \"line_end\": 42,\n-                    \"column_start\": 24,\n-                    \"column_end\": 29,\n-                    \"is_primary\": true,\n-                    \"text\": [\n-                        {\n-                            \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                            \"highlight_start\": 24,\n-                            \"highlight_end\": 29\n-                        }\n-                    ],\n-                    \"label\": null,\n-                    \"suggested_replacement\": \"self\",\n-                    \"suggestion_applicability\": \"Unspecified\",\n-                    \"expansion\": null\n-                }\n-            ],\n-            \"children\": [],\n-            \"rendered\": null\n-        }\n-    ],\n-    \"rendered\": \"warning: this argument is passed by reference, but would be more efficient if passed by value\\n  --> compiler/mir/tagset.rs:42:24\\n   |\\n42 |     pub fn is_disjoint(&self, other: Self) -> bool {\\n   |                        ^^^^^ help: consider passing by value instead: `self`\\n   |\\nnote: lint level defined here\\n  --> compiler/lib.rs:1:9\\n   |\\n1  | #![warn(clippy::all)]\\n   |         ^^^^^^^^^^^\\n   = note: #[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\\n\\n\"\n-}"}, {"sha": "ea5c976d1d4198f68a3cb07947625357884791cc", "filename": "editors/code/src/test/fixtures/rust-diagnostics/error/E0053.json", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0053.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0053.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0053.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,42 +0,0 @@\n-{\n-    \"message\": \"method `next` has an incompatible type for trait\",\n-    \"code\": {\n-        \"code\": \"E0053\",\n-        \"explanation\": \"\\nThe parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nHere are a couple examples of this error:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\"\n-    },\n-    \"level\": \"error\",\n-    \"spans\": [\n-        {\n-            \"file_name\": \"compiler/ty/list_iter.rs\",\n-            \"byte_start\": 1307,\n-            \"byte_end\": 1350,\n-            \"line_start\": 52,\n-            \"line_end\": 52,\n-            \"column_start\": 5,\n-            \"column_end\": 48,\n-            \"is_primary\": true,\n-            \"text\": [\n-                {\n-                    \"text\": \"    fn next(&self) -> Option<&'list ty::Ref<M>> {\",\n-                    \"highlight_start\": 5,\n-                    \"highlight_end\": 48\n-                }\n-            ],\n-            \"label\": \"types differ in mutability\",\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        }\n-    ],\n-    \"children\": [\n-        {\n-            \"message\": \"expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n-            \"code\": null,\n-            \"level\": \"note\",\n-            \"spans\": [],\n-            \"children\": [],\n-            \"rendered\": null\n-        }\n-    ],\n-    \"rendered\": \"error[E0053]: method `next` has an incompatible type for trait\\n  --> compiler/ty/list_iter.rs:52:5\\n   |\\n52 |     fn next(&self) -> Option<&'list ty::Ref<M>> {\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\\n   |\\n   = note: expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n              found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\\n\\n\"\n-}"}, {"sha": "3154d1098cdccd54ce706625cfa0191ffe284556", "filename": "editors/code/src/test/fixtures/rust-diagnostics/error/E0061.json", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0061.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0061.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0061.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,114 +0,0 @@\n-{\n-    \"message\": \"this function takes 2 parameters but 3 parameters were supplied\",\n-    \"code\": {\n-        \"code\": \"E0061\",\n-        \"explanation\": \"\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\"\n-    },\n-    \"level\": \"error\",\n-    \"spans\": [\n-        {\n-            \"file_name\": \"compiler/ty/select.rs\",\n-            \"byte_start\": 8787,\n-            \"byte_end\": 9241,\n-            \"line_start\": 219,\n-            \"line_end\": 231,\n-            \"column_start\": 5,\n-            \"column_end\": 6,\n-            \"is_primary\": false,\n-            \"text\": [\n-                {\n-                    \"text\": \"    pub fn add_evidence(\",\n-                    \"highlight_start\": 5,\n-                    \"highlight_end\": 25\n-                },\n-                {\n-                    \"text\": \"        &mut self,\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 19\n-                },\n-                {\n-                    \"text\": \"        target_poly: &ty::Ref<ty::Poly>,\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 41\n-                },\n-                {\n-                    \"text\": \"        evidence_poly: &ty::Ref<ty::Poly>,\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 43\n-                },\n-                {\n-                    \"text\": \"    ) {\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 8\n-                },\n-                {\n-                    \"text\": \"        match target_poly {\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 28\n-                },\n-                {\n-                    \"text\": \"            ty::Ref::Var(tvar, _) => self.add_var_evidence(tvar, evidence_poly),\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 81\n-                },\n-                {\n-                    \"text\": \"            ty::Ref::Fixed(target_ty) => {\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 43\n-                },\n-                {\n-                    \"text\": \"                let evidence_ty = evidence_poly.resolve_to_ty();\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 65\n-                },\n-                {\n-                    \"text\": \"                self.add_evidence_ty(target_ty, evidence_poly, evidence_ty)\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 76\n-                },\n-                {\n-                    \"text\": \"            }\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 14\n-                },\n-                {\n-                    \"text\": \"        }\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 10\n-                },\n-                {\n-                    \"text\": \"    }\",\n-                    \"highlight_start\": 1,\n-                    \"highlight_end\": 6\n-                }\n-            ],\n-            \"label\": \"defined here\",\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        },\n-        {\n-            \"file_name\": \"compiler/ty/select.rs\",\n-            \"byte_start\": 4045,\n-            \"byte_end\": 4057,\n-            \"line_start\": 104,\n-            \"line_end\": 104,\n-            \"column_start\": 18,\n-            \"column_end\": 30,\n-            \"is_primary\": true,\n-            \"text\": [\n-                {\n-                    \"text\": \"            self.add_evidence(target_fixed, evidence_fixed, false);\",\n-                    \"highlight_start\": 18,\n-                    \"highlight_end\": 30\n-                }\n-            ],\n-            \"label\": \"expected 2 parameters\",\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        }\n-    ],\n-    \"children\": [],\n-    \"rendered\": \"error[E0061]: this function takes 2 parameters but 3 parameters were supplied\\n   --> compiler/ty/select.rs:104:18\\n    |\\n104 |               self.add_evidence(target_fixed, evidence_fixed, false);\\n    |                    ^^^^^^^^^^^^ expected 2 parameters\\n...\\n219 | /     pub fn add_evidence(\\n220 | |         &mut self,\\n221 | |         target_poly: &ty::Ref<ty::Poly>,\\n222 | |         evidence_poly: &ty::Ref<ty::Poly>,\\n...   |\\n230 | |         }\\n231 | |     }\\n    | |_____- defined here\\n\\n\"\n-}"}, {"sha": "bfef33c7de786dd8f8dfd2a5a415b96767ac62bf", "filename": "editors/code/src/test/fixtures/rust-diagnostics/error/E0277.json", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0277.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,261 +0,0 @@\n-{\n-    \"rendered\": \"error[E0277]: can't compare `{integer}` with `&str`\\n --> src/main.rs:2:5\\n  |\\n2 |     assert_eq!(1, \\\"love\\\");\\n  |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &str`\\n  |\\n  = help: the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\\n\\n\",\n-    \"children\": [\n-        {\n-            \"children\": [],\n-            \"code\": null,\n-            \"level\": \"help\",\n-            \"message\": \"the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n-            \"rendered\": null,\n-            \"spans\": []\n-        }\n-    ],\n-    \"code\": {\n-        \"code\": \"E0277\",\n-        \"explanation\": \"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"\n-    },\n-    \"level\": \"error\",\n-    \"message\": \"can't compare `{integer}` with `&str`\",\n-    \"spans\": [\n-        {\n-            \"byte_end\": 155,\n-            \"byte_start\": 153,\n-            \"column_end\": 33,\n-            \"column_start\": 31,\n-            \"expansion\": {\n-                \"def_site_span\": {\n-                    \"byte_end\": 940,\n-                    \"byte_start\": 0,\n-                    \"column_end\": 6,\n-                    \"column_start\": 1,\n-                    \"expansion\": null,\n-                    \"file_name\": \"<::core::macros::assert_eq macros>\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 36,\n-                    \"line_start\": 1,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 35,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"($ left : expr, $ right : expr) =>\"\n-                        },\n-                        {\n-                            \"highlight_end\": 3,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"({\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     match (& $ left, & $ right)\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 34,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         (left_val, right_val) =>\"\n-                        },\n-                        {\n-                            \"highlight_end\": 11,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 46,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             if ! (* left_val == * right_val)\"\n-                        },\n-                        {\n-                            \"highlight_end\": 15,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 25,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                 panic !\"\n-                        },\n-                        {\n-                            \"highlight_end\": 57,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                        },\n-                        {\n-                            \"highlight_end\": 16,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"  left: `{:?}`,\"\n-                        },\n-                        {\n-                            \"highlight_end\": 18,\n-                            \"highlight_start\": 1,\n-                            \"text\": \" right: `{:?}`\\\"#,\"\n-                        },\n-                        {\n-                            \"highlight_end\": 47,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                  & * left_val, & * right_val)\"\n-                        },\n-                        {\n-                            \"highlight_end\": 15,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 11,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 42,\n-                            \"highlight_start\": 1,\n-                            \"text\": \" }) ; ($ left : expr, $ right : expr,) =>\"\n-                        },\n-                        {\n-                            \"highlight_end\": 49,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"({ $ crate :: assert_eq ! ($ left, $ right) }) ;\"\n-                        },\n-                        {\n-                            \"highlight_end\": 53,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>\"\n-                        },\n-                        {\n-                            \"highlight_end\": 3,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"({\"\n-                        },\n-                        {\n-                            \"highlight_end\": 37,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     match (& ($ left), & ($ right))\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 34,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         (left_val, right_val) =>\"\n-                        },\n-                        {\n-                            \"highlight_end\": 11,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 46,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             if ! (* left_val == * right_val)\"\n-                        },\n-                        {\n-                            \"highlight_end\": 15,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 25,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                 panic !\"\n-                        },\n-                        {\n-                            \"highlight_end\": 57,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                        },\n-                        {\n-                            \"highlight_end\": 16,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"  left: `{:?}`,\"\n-                        },\n-                        {\n-                            \"highlight_end\": 22,\n-                            \"highlight_start\": 1,\n-                            \"text\": \" right: `{:?}`: {}\\\"#,\"\n-                        },\n-                        {\n-                            \"highlight_end\": 72,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                  & * left_val, & * right_val, $ crate :: format_args !\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"                  ($ ($ arg) +))\"\n-                        },\n-                        {\n-                            \"highlight_end\": 15,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"             }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 11,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"         }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"     }\"\n-                        },\n-                        {\n-                            \"highlight_end\": 6,\n-                            \"highlight_start\": 1,\n-                            \"text\": \" }) ;\"\n-                        }\n-                    ]\n-                },\n-                \"macro_decl_name\": \"assert_eq!\",\n-                \"span\": {\n-                    \"byte_end\": 38,\n-                    \"byte_start\": 16,\n-                    \"column_end\": 27,\n-                    \"column_start\": 5,\n-                    \"expansion\": null,\n-                    \"file_name\": \"src/main.rs\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 2,\n-                    \"line_start\": 2,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 27,\n-                            \"highlight_start\": 5,\n-                            \"text\": \"    assert_eq!(1, \\\"love\\\");\"\n-                        }\n-                    ]\n-                }\n-            },\n-            \"file_name\": \"<::core::macros::assert_eq macros>\",\n-            \"is_primary\": true,\n-            \"label\": \"no implementation for `{integer} == &str`\",\n-            \"line_end\": 7,\n-            \"line_start\": 7,\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"text\": [\n-                {\n-                    \"highlight_end\": 33,\n-                    \"highlight_start\": 31,\n-                    \"text\": \"             if ! (* left_val == * right_val)\"\n-                }\n-            ]\n-        }\n-    ]\n-}"}, {"sha": "fb23824a3c7fef3983f81688a7925cb71ac27648", "filename": "editors/code/src/test/fixtures/rust-diagnostics/error/E0308.json", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0308.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0308.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Ferror%2FE0308.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,33 +0,0 @@\n-{\n-    \"message\": \"mismatched types\",\n-    \"code\": {\n-        \"code\": \"E0308\",\n-        \"explanation\": \"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail,E0308\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\"\n-    },\n-    \"level\": \"error\",\n-    \"spans\": [\n-        {\n-            \"file_name\": \"runtime/compiler_support.rs\",\n-            \"byte_start\": 1589,\n-            \"byte_end\": 1594,\n-            \"line_start\": 48,\n-            \"line_end\": 48,\n-            \"column_start\": 65,\n-            \"column_end\": 70,\n-            \"is_primary\": true,\n-            \"text\": [\n-                {\n-                    \"text\": \"    let layout = alloc::Layout::from_size_align_unchecked(size, align);\",\n-                    \"highlight_start\": 65,\n-                    \"highlight_end\": 70\n-                }\n-            ],\n-            \"label\": \"expected usize, found u32\",\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        }\n-    ],\n-    \"children\": [],\n-    \"rendered\": \"error[E0308]: mismatched types\\n  --> runtime/compiler_support.rs:48:65\\n   |\\n48 |     let layout = alloc::Layout::from_size_align_unchecked(size, align);\\n   |                                                                 ^^^^^ expected usize, found u32\\n\\n\"\n-}"}, {"sha": "d1e2be722147045a184d14fe1c1cc5864b730059", "filename": "editors/code/src/test/fixtures/rust-diagnostics/warning/unused_variables.json", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fwarning%2Funused_variables.json", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fwarning%2Funused_variables.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Ffixtures%2Frust-diagnostics%2Fwarning%2Funused_variables.json?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,72 +0,0 @@\n-{\n-    \"message\": \"unused variable: `foo`\",\n-    \"code\": {\n-        \"code\": \"unused_variables\",\n-        \"explanation\": null\n-    },\n-    \"level\": \"warning\",\n-    \"spans\": [\n-        {\n-            \"file_name\": \"driver/subcommand/repl.rs\",\n-            \"byte_start\": 9228,\n-            \"byte_end\": 9231,\n-            \"line_start\": 291,\n-            \"line_end\": 291,\n-            \"column_start\": 9,\n-            \"column_end\": 12,\n-            \"is_primary\": true,\n-            \"text\": [\n-                {\n-                    \"text\": \"    let foo = 42;\",\n-                    \"highlight_start\": 9,\n-                    \"highlight_end\": 12\n-                }\n-            ],\n-            \"label\": null,\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"expansion\": null\n-        }\n-    ],\n-    \"children\": [\n-        {\n-            \"message\": \"#[warn(unused_variables)] on by default\",\n-            \"code\": null,\n-            \"level\": \"note\",\n-            \"spans\": [],\n-            \"children\": [],\n-            \"rendered\": null\n-        },\n-        {\n-            \"message\": \"consider prefixing with an underscore\",\n-            \"code\": null,\n-            \"level\": \"help\",\n-            \"spans\": [\n-                {\n-                    \"file_name\": \"driver/subcommand/repl.rs\",\n-                    \"byte_start\": 9228,\n-                    \"byte_end\": 9231,\n-                    \"line_start\": 291,\n-                    \"line_end\": 291,\n-                    \"column_start\": 9,\n-                    \"column_end\": 12,\n-                    \"is_primary\": true,\n-                    \"text\": [\n-                        {\n-                            \"text\": \"    let foo = 42;\",\n-                            \"highlight_start\": 9,\n-                            \"highlight_end\": 12\n-                        }\n-                    ],\n-                    \"label\": null,\n-                    \"suggested_replacement\": \"_foo\",\n-                    \"suggestion_applicability\": \"MachineApplicable\",\n-                    \"expansion\": null\n-                }\n-            ],\n-            \"children\": [],\n-            \"rendered\": null\n-        }\n-    ],\n-    \"rendered\": \"warning: unused variable: `foo`\\n   --> driver/subcommand/repl.rs:291:9\\n    |\\n291 |     let foo = 42;\\n    |         ^^^ help: consider prefixing with an underscore: `_foo`\\n    |\\n    = note: #[warn(unused_variables)] on by default\\n\\n\"\n-}"}, {"sha": "2b25eb705dd35743f432df559326249c34ba4244", "filename": "editors/code/src/test/utils/diagnotics/SuggestedFix.test.ts", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFix.test.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,134 +0,0 @@\n-import * as assert from 'assert';\n-import * as vscode from 'vscode';\n-\n-import { SuggestionApplicability } from '../../../utils/diagnostics/rust';\n-import SuggestedFix from '../../../utils/diagnostics/SuggestedFix';\n-\n-const location1 = new vscode.Location(\n-    vscode.Uri.file('/file/1'),\n-    new vscode.Range(new vscode.Position(1, 2), new vscode.Position(3, 4)),\n-);\n-\n-const location2 = new vscode.Location(\n-    vscode.Uri.file('/file/2'),\n-    new vscode.Range(new vscode.Position(5, 6), new vscode.Position(7, 8)),\n-);\n-\n-describe('SuggestedFix', () => {\n-    describe('isEqual', () => {\n-        it('should treat identical instances as equal', () => {\n-            const suggestion1 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            const suggestion2 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            assert(suggestion1.isEqual(suggestion2));\n-        });\n-\n-        it('should treat instances with different titles as inequal', () => {\n-            const suggestion1 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            const suggestion2 = new SuggestedFix(\n-                'Not the same title!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            assert(!suggestion1.isEqual(suggestion2));\n-        });\n-\n-        it('should treat instances with different replacements as inequal', () => {\n-            const suggestion1 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            const suggestion2 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With something else!',\n-            );\n-\n-            assert(!suggestion1.isEqual(suggestion2));\n-        });\n-\n-        it('should treat instances with different locations as inequal', () => {\n-            const suggestion1 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            const suggestion2 = new SuggestedFix(\n-                'Replace me!',\n-                location2,\n-                'With this!',\n-            );\n-\n-            assert(!suggestion1.isEqual(suggestion2));\n-        });\n-\n-        it('should treat instances with different applicability as inequal', () => {\n-            const suggestion1 = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-                SuggestionApplicability.MachineApplicable,\n-            );\n-\n-            const suggestion2 = new SuggestedFix(\n-                'Replace me!',\n-                location2,\n-                'With this!',\n-                SuggestionApplicability.HasPlaceholders,\n-            );\n-\n-            assert(!suggestion1.isEqual(suggestion2));\n-        });\n-    });\n-\n-    describe('toCodeAction', () => {\n-        it('should map a simple suggestion', () => {\n-            const suggestion = new SuggestedFix(\n-                'Replace me!',\n-                location1,\n-                'With this!',\n-            );\n-\n-            const codeAction = suggestion.toCodeAction();\n-            assert.strictEqual(codeAction.kind, vscode.CodeActionKind.QuickFix);\n-            assert.strictEqual(codeAction.title, 'Replace me!');\n-            assert.strictEqual(codeAction.isPreferred, false);\n-\n-            const edit = codeAction.edit;\n-            if (!edit) {\n-                assert.fail('Code Action edit unexpectedly missing');\n-                return;\n-            }\n-\n-            const editEntries = edit.entries();\n-            assert.strictEqual(editEntries.length, 1);\n-\n-            const [[editUri, textEdits]] = editEntries;\n-            assert.strictEqual(editUri.toString(), location1.uri.toString());\n-\n-            assert.strictEqual(textEdits.length, 1);\n-            const [textEdit] = textEdits;\n-\n-            assert(textEdit.range.isEqual(location1.range));\n-            assert.strictEqual(textEdit.newText, 'With this!');\n-        });\n-    });\n-});"}, {"sha": "ef09013f413040e763c942dad1bc006a118a1312", "filename": "editors/code/src/test/utils/diagnotics/SuggestedFixCollection.test.ts", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2FSuggestedFixCollection.test.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,127 +0,0 @@\n-import * as assert from 'assert';\n-import * as vscode from 'vscode';\n-\n-import SuggestedFix from '../../../utils/diagnostics/SuggestedFix';\n-import SuggestedFixCollection from '../../../utils/diagnostics/SuggestedFixCollection';\n-\n-const uri1 = vscode.Uri.file('/file/1');\n-const uri2 = vscode.Uri.file('/file/2');\n-\n-const mockDocument1 = ({\n-    uri: uri1,\n-} as unknown) as vscode.TextDocument;\n-\n-const mockDocument2 = ({\n-    uri: uri2,\n-} as unknown) as vscode.TextDocument;\n-\n-const range1 = new vscode.Range(\n-    new vscode.Position(1, 2),\n-    new vscode.Position(3, 4),\n-);\n-const range2 = new vscode.Range(\n-    new vscode.Position(5, 6),\n-    new vscode.Position(7, 8),\n-);\n-\n-const diagnostic1 = new vscode.Diagnostic(range1, 'First diagnostic');\n-const diagnostic2 = new vscode.Diagnostic(range2, 'Second diagnostic');\n-\n-// This is a mutable object so return a fresh instance every time\n-function suggestion1(): SuggestedFix {\n-    return new SuggestedFix(\n-        'Replace me!',\n-        new vscode.Location(uri1, range1),\n-        'With this!',\n-    );\n-}\n-\n-describe('SuggestedFixCollection', () => {\n-    it('should add a suggestion then return it as a code action', () => {\n-        const suggestedFixes = new SuggestedFixCollection();\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic1);\n-\n-        // Specify the document and range that exactly matches\n-        const codeActions = suggestedFixes.provideCodeActions(\n-            mockDocument1,\n-            range1,\n-        );\n-\n-        assert.strictEqual(codeActions.length, 1);\n-        const [codeAction] = codeActions;\n-        assert.strictEqual(codeAction.title, suggestion1().title);\n-\n-        const { diagnostics } = codeAction;\n-        if (!diagnostics) {\n-            assert.fail('Diagnostics unexpectedly missing');\n-            return;\n-        }\n-\n-        assert.strictEqual(diagnostics.length, 1);\n-        assert.strictEqual(diagnostics[0], diagnostic1);\n-    });\n-\n-    it('should not return code actions for different ranges', () => {\n-        const suggestedFixes = new SuggestedFixCollection();\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic1);\n-\n-        const codeActions = suggestedFixes.provideCodeActions(\n-            mockDocument1,\n-            range2,\n-        );\n-\n-        assert(!codeActions || codeActions.length === 0);\n-    });\n-\n-    it('should not return code actions for different documents', () => {\n-        const suggestedFixes = new SuggestedFixCollection();\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic1);\n-\n-        const codeActions = suggestedFixes.provideCodeActions(\n-            mockDocument2,\n-            range1,\n-        );\n-\n-        assert(!codeActions || codeActions.length === 0);\n-    });\n-\n-    it('should not return code actions that have been cleared', () => {\n-        const suggestedFixes = new SuggestedFixCollection();\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic1);\n-        suggestedFixes.clear();\n-\n-        const codeActions = suggestedFixes.provideCodeActions(\n-            mockDocument1,\n-            range1,\n-        );\n-\n-        assert(!codeActions || codeActions.length === 0);\n-    });\n-\n-    it('should merge identical suggestions together', () => {\n-        const suggestedFixes = new SuggestedFixCollection();\n-\n-        // Add the same suggestion for two diagnostics\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic1);\n-        suggestedFixes.addSuggestedFixForDiagnostic(suggestion1(), diagnostic2);\n-\n-        const codeActions = suggestedFixes.provideCodeActions(\n-            mockDocument1,\n-            range1,\n-        );\n-\n-        assert.strictEqual(codeActions.length, 1);\n-        const [codeAction] = codeActions;\n-        const { diagnostics } = codeAction;\n-\n-        if (!diagnostics) {\n-            assert.fail('Diagnostics unexpectedly missing');\n-            return;\n-        }\n-\n-        // We should be associated with both diagnostics\n-        assert.strictEqual(diagnostics.length, 2);\n-        assert.strictEqual(diagnostics[0], diagnostic1);\n-        assert.strictEqual(diagnostics[1], diagnostic2);\n-    });\n-});"}, {"sha": "358325cc8dde6082cb0eda52f1fbdbe38483bf34", "filename": "editors/code/src/test/utils/diagnotics/rust.test.ts", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Frust.test.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,236 +0,0 @@\n-import * as assert from 'assert';\n-import * as fs from 'fs';\n-import * as vscode from 'vscode';\n-\n-import {\n-    MappedRustDiagnostic,\n-    mapRustDiagnosticToVsCode,\n-    RustDiagnostic,\n-    SuggestionApplicability,\n-} from '../../../utils/diagnostics/rust';\n-\n-function loadDiagnosticFixture(name: string): RustDiagnostic {\n-    const jsonText = fs\n-        .readFileSync(\n-            // We're actually in our JavaScript output directory, climb out\n-            `${__dirname}/../../../../src/test/fixtures/rust-diagnostics/${name}.json`,\n-        )\n-        .toString();\n-\n-    return JSON.parse(jsonText);\n-}\n-\n-function mapFixtureToVsCode(name: string): MappedRustDiagnostic {\n-    const rd = loadDiagnosticFixture(name);\n-    const mapResult = mapRustDiagnosticToVsCode(rd);\n-\n-    if (!mapResult) {\n-        return assert.fail('Mapping unexpectedly failed');\n-    }\n-    return mapResult;\n-}\n-\n-describe('mapRustDiagnosticToVsCode', () => {\n-    it('should map an incompatible type for trait error', () => {\n-        const { diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'error/E0053',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        assert.strictEqual(diagnostic.source, 'rustc');\n-        assert.strictEqual(\n-            diagnostic.message,\n-            [\n-                `method \\`next\\` has an incompatible type for trait`,\n-                `expected type \\`fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>\\``,\n-                `   found type \\`fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>\\``,\n-            ].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'E0053');\n-        assert.deepStrictEqual(diagnostic.tags, []);\n-\n-        // No related information\n-        assert.deepStrictEqual(diagnostic.relatedInformation, []);\n-\n-        // There are no suggested fixes\n-        assert.strictEqual(suggestedFixes.length, 0);\n-    });\n-\n-    it('should map an unused variable warning', () => {\n-        const { diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'warning/unused_variables',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Warning,\n-        );\n-        assert.strictEqual(\n-            diagnostic.message,\n-            [\n-                'unused variable: `foo`',\n-                '#[warn(unused_variables)] on by default',\n-            ].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'unused_variables');\n-        assert.strictEqual(diagnostic.source, 'rustc');\n-        assert.deepStrictEqual(diagnostic.tags, [\n-            vscode.DiagnosticTag.Unnecessary,\n-        ]);\n-\n-        // No related information\n-        assert.deepStrictEqual(diagnostic.relatedInformation, []);\n-\n-        // One suggested fix available to prefix the variable\n-        assert.strictEqual(suggestedFixes.length, 1);\n-        const [suggestedFix] = suggestedFixes;\n-        assert.strictEqual(\n-            suggestedFix.title,\n-            'consider prefixing with an underscore: `_foo`',\n-        );\n-        assert.strictEqual(\n-            suggestedFix.applicability,\n-            SuggestionApplicability.MachineApplicable,\n-        );\n-    });\n-\n-    it('should map a wrong number of parameters error', () => {\n-        const { diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'error/E0061',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        assert.strictEqual(\n-            diagnostic.message,\n-            [\n-                'this function takes 2 parameters but 3 parameters were supplied',\n-                'expected 2 parameters',\n-            ].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'E0061');\n-        assert.strictEqual(diagnostic.source, 'rustc');\n-        assert.deepStrictEqual(diagnostic.tags, []);\n-\n-        // One related information for the original definition\n-        const relatedInformation = diagnostic.relatedInformation;\n-        if (!relatedInformation) {\n-            assert.fail('Related information unexpectedly undefined');\n-            return;\n-        }\n-        assert.strictEqual(relatedInformation.length, 1);\n-        const [related] = relatedInformation;\n-        assert.strictEqual(related.message, 'defined here');\n-\n-        // There are no suggested fixes\n-        assert.strictEqual(suggestedFixes.length, 0);\n-    });\n-\n-    it('should map a Clippy copy pass by ref warning', () => {\n-        const { diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'clippy/trivially_copy_pass_by_ref',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Warning,\n-        );\n-        assert.strictEqual(diagnostic.source, 'clippy');\n-        assert.strictEqual(\n-            diagnostic.message,\n-            [\n-                'this argument is passed by reference, but would be more efficient if passed by value',\n-                '#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]',\n-                'for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref',\n-            ].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'trivially_copy_pass_by_ref');\n-        assert.deepStrictEqual(diagnostic.tags, []);\n-\n-        // One related information for the lint definition\n-        const relatedInformation = diagnostic.relatedInformation;\n-        if (!relatedInformation) {\n-            assert.fail('Related information unexpectedly undefined');\n-            return;\n-        }\n-        assert.strictEqual(relatedInformation.length, 1);\n-        const [related] = relatedInformation;\n-        assert.strictEqual(related.message, 'lint level defined here');\n-\n-        // One suggested fix to pass by value\n-        assert.strictEqual(suggestedFixes.length, 1);\n-        const [suggestedFix] = suggestedFixes;\n-        assert.strictEqual(\n-            suggestedFix.title,\n-            'consider passing by value instead: `self`',\n-        );\n-        // Clippy does not mark this with any applicability\n-        assert.strictEqual(\n-            suggestedFix.applicability,\n-            SuggestionApplicability.Unspecified,\n-        );\n-    });\n-\n-    it('should map a mismatched type error', () => {\n-        const { diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'error/E0308',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        assert.strictEqual(\n-            diagnostic.message,\n-            ['mismatched types', 'expected usize, found u32'].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'E0308');\n-        assert.strictEqual(diagnostic.source, 'rustc');\n-        assert.deepStrictEqual(diagnostic.tags, []);\n-\n-        // No related information\n-        assert.deepStrictEqual(diagnostic.relatedInformation, []);\n-\n-        // There are no suggested fixes\n-        assert.strictEqual(suggestedFixes.length, 0);\n-    });\n-\n-    it('should map a macro invocation location to normal file path', () => {\n-        const { location, diagnostic, suggestedFixes } = mapFixtureToVsCode(\n-            'error/E0277',\n-        );\n-\n-        assert.strictEqual(\n-            diagnostic.severity,\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        assert.strictEqual(\n-            diagnostic.message,\n-            [\n-                \"can't compare `{integer}` with `&str`\",\n-                'the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`',\n-            ].join('\\n'),\n-        );\n-        assert.strictEqual(diagnostic.code, 'E0277');\n-        assert.strictEqual(diagnostic.source, 'rustc');\n-        assert.deepStrictEqual(diagnostic.tags, []);\n-\n-        // No related information\n-        assert.deepStrictEqual(diagnostic.relatedInformation, []);\n-\n-        // There are no suggested fixes\n-        assert.strictEqual(suggestedFixes.length, 0);\n-\n-        // The file url should be normal file\n-        // Ignore the first part because it depends on vs workspace location\n-        assert.strictEqual(\n-            location.uri.path.substr(-'src/main.rs'.length),\n-            'src/main.rs',\n-        );\n-    });\n-});"}, {"sha": "4944dd0328ce3ff6000c300a90d5e9687b2fa7a3", "filename": "editors/code/src/test/utils/diagnotics/vscode.test.ts", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftest%2Futils%2Fdiagnotics%2Fvscode.test.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,98 +0,0 @@\n-import * as assert from 'assert';\n-import * as vscode from 'vscode';\n-\n-import { areDiagnosticsEqual } from '../../../utils/diagnostics/vscode';\n-\n-const range1 = new vscode.Range(\n-    new vscode.Position(1, 2),\n-    new vscode.Position(3, 4),\n-);\n-\n-const range2 = new vscode.Range(\n-    new vscode.Position(5, 6),\n-    new vscode.Position(7, 8),\n-);\n-\n-describe('areDiagnosticsEqual', () => {\n-    it('should treat identical diagnostics as equal', () => {\n-        const diagnostic1 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        const diagnostic2 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        assert(areDiagnosticsEqual(diagnostic1, diagnostic2));\n-    });\n-\n-    it('should treat diagnostics with different sources as inequal', () => {\n-        const diagnostic1 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        diagnostic1.source = 'rustc';\n-\n-        const diagnostic2 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-        diagnostic2.source = 'clippy';\n-\n-        assert(!areDiagnosticsEqual(diagnostic1, diagnostic2));\n-    });\n-\n-    it('should treat diagnostics with different ranges as inequal', () => {\n-        const diagnostic1 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        const diagnostic2 = new vscode.Diagnostic(\n-            range2,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        assert(!areDiagnosticsEqual(diagnostic1, diagnostic2));\n-    });\n-\n-    it('should treat diagnostics with different messages as inequal', () => {\n-        const diagnostic1 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        const diagnostic2 = new vscode.Diagnostic(\n-            range1,\n-            'Goodbye!, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        assert(!areDiagnosticsEqual(diagnostic1, diagnostic2));\n-    });\n-\n-    it('should treat diagnostics with different severities as inequal', () => {\n-        const diagnostic1 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Warning,\n-        );\n-\n-        const diagnostic2 = new vscode.Diagnostic(\n-            range1,\n-            'Hello, world!',\n-            vscode.DiagnosticSeverity.Error,\n-        );\n-\n-        assert(!areDiagnosticsEqual(diagnostic1, diagnostic2));\n-    });\n-});"}, {"sha": "6e660bb61d95517f4476512019c88addb9b7e861", "filename": "editors/code/src/utils/diagnostics/SuggestedFix.ts", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFix.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,67 +0,0 @@\n-import * as vscode from 'vscode';\n-\n-import { SuggestionApplicability } from './rust';\n-\n-/**\n- * Model object for text replacements suggested by the Rust compiler\n- *\n- * This is an intermediate form between the raw `rustc` JSON and a\n- * `vscode.CodeAction`. It's optimised for the use-cases of\n- * `SuggestedFixCollection`.\n- */\n-export default class SuggestedFix {\n-    public readonly title: string;\n-    public readonly location: vscode.Location;\n-    public readonly replacement: string;\n-    public readonly applicability: SuggestionApplicability;\n-\n-    /**\n-     * Diagnostics this suggested fix could resolve\n-     */\n-    public diagnostics: vscode.Diagnostic[];\n-\n-    constructor(\n-        title: string,\n-        location: vscode.Location,\n-        replacement: string,\n-        applicability: SuggestionApplicability = SuggestionApplicability.Unspecified,\n-    ) {\n-        this.title = title;\n-        this.location = location;\n-        this.replacement = replacement;\n-        this.applicability = applicability;\n-        this.diagnostics = [];\n-    }\n-\n-    /**\n-     * Determines if this suggested fix is equivalent to another instance\n-     */\n-    public isEqual(other: SuggestedFix): boolean {\n-        return (\n-            this.title === other.title &&\n-            this.location.range.isEqual(other.location.range) &&\n-            this.replacement === other.replacement &&\n-            this.applicability === other.applicability\n-        );\n-    }\n-\n-    /**\n-     * Converts this suggested fix to a VS Code Quick Fix code action\n-     */\n-    public toCodeAction(): vscode.CodeAction {\n-        const codeAction = new vscode.CodeAction(\n-            this.title,\n-            vscode.CodeActionKind.QuickFix,\n-        );\n-\n-        const edit = new vscode.WorkspaceEdit();\n-        edit.replace(this.location.uri, this.location.range, this.replacement);\n-        codeAction.edit = edit;\n-\n-        codeAction.isPreferred =\n-            this.applicability === SuggestionApplicability.MachineApplicable;\n-\n-        codeAction.diagnostics = [...this.diagnostics];\n-        return codeAction;\n-    }\n-}"}, {"sha": "57c9856cfa3cb7ebdad64c3d78622e296d9c7aa5", "filename": "editors/code/src/utils/diagnostics/SuggestedFixCollection.ts", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2FSuggestedFixCollection.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,77 +0,0 @@\n-import * as vscode from 'vscode';\n-import SuggestedFix from './SuggestedFix';\n-\n-/**\n- * Collection of suggested fixes across multiple documents\n- *\n- * This stores `SuggestedFix` model objects and returns them via the\n- * `vscode.CodeActionProvider` interface.\n- */\n-export default class SuggestedFixCollection\n-    implements vscode.CodeActionProvider {\n-    public static PROVIDED_CODE_ACTION_KINDS = [vscode.CodeActionKind.QuickFix];\n-\n-    /**\n-     * Map of document URI strings to suggested fixes\n-     */\n-    private suggestedFixes: Map<string, SuggestedFix[]>;\n-\n-    constructor() {\n-        this.suggestedFixes = new Map();\n-    }\n-\n-    /**\n-     * Clears all suggested fixes across all documents\n-     */\n-    public clear(): void {\n-        this.suggestedFixes = new Map();\n-    }\n-\n-    /**\n-     * Adds a suggested fix for the given diagnostic\n-     *\n-     * Some suggested fixes will appear in multiple diagnostics. For example,\n-     * forgetting a `mut` on a variable will suggest changing the delaration on\n-     * every mutable usage site. If the suggested fix has already been added\n-     * this method will instead associate the existing fix with the new\n-     * diagnostic.\n-     */\n-    public addSuggestedFixForDiagnostic(\n-        suggestedFix: SuggestedFix,\n-        diagnostic: vscode.Diagnostic,\n-    ): void {\n-        const fileUriString = suggestedFix.location.uri.toString();\n-        const fileSuggestions = this.suggestedFixes.get(fileUriString) || [];\n-\n-        const existingSuggestion = fileSuggestions.find(s =>\n-            s.isEqual(suggestedFix),\n-        );\n-\n-        if (existingSuggestion) {\n-            // The existing suggestion also applies to this new diagnostic\n-            existingSuggestion.diagnostics.push(diagnostic);\n-        } else {\n-            // We haven't seen this suggestion before\n-            suggestedFix.diagnostics.push(diagnostic);\n-            fileSuggestions.push(suggestedFix);\n-        }\n-\n-        this.suggestedFixes.set(fileUriString, fileSuggestions);\n-    }\n-\n-    /**\n-     * Filters suggested fixes by their document and range and converts them to\n-     * code actions\n-     */\n-    public provideCodeActions(\n-        document: vscode.TextDocument,\n-        range: vscode.Range,\n-    ): vscode.CodeAction[] {\n-        const documentUriString = document.uri.toString();\n-\n-        const suggestedFixes = this.suggestedFixes.get(documentUriString);\n-        return (suggestedFixes || [])\n-            .filter(({ location }) => location.range.intersection(range))\n-            .map(suggestedEdit => suggestedEdit.toCodeAction());\n-    }\n-}"}, {"sha": "1f0c0d3e4057a85d6dcca373474b421f177c53be", "filename": "editors/code/src/utils/diagnostics/rust.ts", "status": "removed", "additions": 0, "deletions": 299, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Frust.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,299 +0,0 @@\n-import * as path from 'path';\n-import * as vscode from 'vscode';\n-\n-import SuggestedFix from './SuggestedFix';\n-\n-export enum SuggestionApplicability {\n-    MachineApplicable = 'MachineApplicable',\n-    HasPlaceholders = 'HasPlaceholders',\n-    MaybeIncorrect = 'MaybeIncorrect',\n-    Unspecified = 'Unspecified',\n-}\n-\n-export interface RustDiagnosticSpanMacroExpansion {\n-    span: RustDiagnosticSpan;\n-    macro_decl_name: string;\n-    def_site_span?: RustDiagnosticSpan;\n-}\n-\n-// Reference:\n-// https://github.com/rust-lang/rust/blob/master/src/libsyntax/json.rs\n-export interface RustDiagnosticSpan {\n-    line_start: number;\n-    line_end: number;\n-    column_start: number;\n-    column_end: number;\n-    is_primary: boolean;\n-    file_name: string;\n-    label?: string;\n-    expansion?: RustDiagnosticSpanMacroExpansion;\n-    suggested_replacement?: string;\n-    suggestion_applicability?: SuggestionApplicability;\n-}\n-\n-export interface RustDiagnostic {\n-    spans: RustDiagnosticSpan[];\n-    rendered: string;\n-    message: string;\n-    level: string;\n-    code?: {\n-        code: string;\n-    };\n-    children: RustDiagnostic[];\n-}\n-\n-export interface MappedRustDiagnostic {\n-    location: vscode.Location;\n-    diagnostic: vscode.Diagnostic;\n-    suggestedFixes: SuggestedFix[];\n-}\n-\n-interface MappedRustChildDiagnostic {\n-    related?: vscode.DiagnosticRelatedInformation;\n-    suggestedFix?: SuggestedFix;\n-    messageLine?: string;\n-}\n-\n-/**\n- * Converts a Rust level string to a VsCode severity\n- */\n-function mapLevelToSeverity(s: string): vscode.DiagnosticSeverity {\n-    if (s === 'error') {\n-        return vscode.DiagnosticSeverity.Error;\n-    }\n-    if (s.startsWith('warn')) {\n-        return vscode.DiagnosticSeverity.Warning;\n-    }\n-    return vscode.DiagnosticSeverity.Information;\n-}\n-\n-/**\n- * Check whether a file name is from macro invocation\n- */\n-function isFromMacro(fileName: string): boolean {\n-    return fileName.startsWith('<') && fileName.endsWith('>');\n-}\n-\n-/**\n- * Converts a Rust macro span to a VsCode location recursively\n- */\n-function mapMacroSpanToLocation(\n-    spanMacro: RustDiagnosticSpanMacroExpansion,\n-): vscode.Location | undefined {\n-    if (!isFromMacro(spanMacro.span.file_name)) {\n-        return mapSpanToLocation(spanMacro.span);\n-    }\n-\n-    if (spanMacro.span.expansion) {\n-        return mapMacroSpanToLocation(spanMacro.span.expansion);\n-    }\n-\n-    return;\n-}\n-\n-/**\n- * Converts a Rust span to a VsCode location\n- */\n-function mapSpanToLocation(span: RustDiagnosticSpan): vscode.Location {\n-    if (isFromMacro(span.file_name) && span.expansion) {\n-        const macroLoc = mapMacroSpanToLocation(span.expansion);\n-        if (macroLoc) {\n-            return macroLoc;\n-        }\n-    }\n-\n-    const fileName = path.join(vscode.workspace.rootPath || '', span.file_name);\n-    const fileUri = vscode.Uri.file(fileName);\n-\n-    const range = new vscode.Range(\n-        new vscode.Position(span.line_start - 1, span.column_start - 1),\n-        new vscode.Position(span.line_end - 1, span.column_end - 1),\n-    );\n-\n-    return new vscode.Location(fileUri, range);\n-}\n-\n-/**\n- * Converts a secondary Rust span to a VsCode related information\n- *\n- * If the span is unlabelled this will return `undefined`.\n- */\n-function mapSecondarySpanToRelated(\n-    span: RustDiagnosticSpan,\n-): vscode.DiagnosticRelatedInformation | undefined {\n-    if (!span.label) {\n-        // Nothing to label this with\n-        return;\n-    }\n-\n-    const location = mapSpanToLocation(span);\n-    return new vscode.DiagnosticRelatedInformation(location, span.label);\n-}\n-\n-/**\n- * Determines if diagnostic is related to unused code\n- */\n-function isUnusedOrUnnecessary(rd: RustDiagnostic): boolean {\n-    if (!rd.code) {\n-        return false;\n-    }\n-\n-    return [\n-        'dead_code',\n-        'unknown_lints',\n-        'unreachable_code',\n-        'unused_attributes',\n-        'unused_imports',\n-        'unused_macros',\n-        'unused_variables',\n-    ].includes(rd.code.code);\n-}\n-\n-/**\n- * Determines if diagnostic is related to deprecated code\n- */\n-function isDeprecated(rd: RustDiagnostic): boolean {\n-    if (!rd.code) {\n-        return false;\n-    }\n-\n-    return ['deprecated'].includes(rd.code.code);\n-}\n-\n-/**\n- * Converts a Rust child diagnostic to a VsCode related information\n- *\n- * This can have three outcomes:\n- *\n- * 1. If this is no primary span this will return a `noteLine`\n- * 2. If there is a primary span with a suggested replacement it will return a\n- *    `codeAction`.\n- * 3. If there is a primary span without a suggested replacement it will return\n- *    a `related`.\n- */\n-function mapRustChildDiagnostic(rd: RustDiagnostic): MappedRustChildDiagnostic {\n-    const span = rd.spans.find(s => s.is_primary);\n-\n-    if (!span) {\n-        // `rustc` uses these spanless children as a way to print multi-line\n-        // messages\n-        return { messageLine: rd.message };\n-    }\n-\n-    // If we have a primary span use its location, otherwise use the parent\n-    const location = mapSpanToLocation(span);\n-\n-    // We need to distinguish `null` from an empty string\n-    if (span && typeof span.suggested_replacement === 'string') {\n-        // Include our replacement in the title unless it's empty\n-        const title = span.suggested_replacement\n-            ? `${rd.message}: \\`${span.suggested_replacement}\\``\n-            : rd.message;\n-\n-        return {\n-            suggestedFix: new SuggestedFix(\n-                title,\n-                location,\n-                span.suggested_replacement,\n-                span.suggestion_applicability,\n-            ),\n-        };\n-    } else {\n-        const related = new vscode.DiagnosticRelatedInformation(\n-            location,\n-            rd.message,\n-        );\n-\n-        return { related };\n-    }\n-}\n-\n-/**\n- * Converts a Rust root diagnostic to VsCode form\n- *\n- * This flattens the Rust diagnostic by:\n- *\n- * 1. Creating a `vscode.Diagnostic` with the root message and primary span.\n- * 2. Adding any labelled secondary spans to `relatedInformation`\n- * 3. Categorising child diagnostics as either `SuggestedFix`es,\n- *    `relatedInformation` or additional message lines.\n- *\n- * If the diagnostic has no primary span this will return `undefined`\n- */\n-export function mapRustDiagnosticToVsCode(\n-    rd: RustDiagnostic,\n-): MappedRustDiagnostic | undefined {\n-    const primarySpan = rd.spans.find(s => s.is_primary);\n-    if (!primarySpan) {\n-        return;\n-    }\n-\n-    const location = mapSpanToLocation(primarySpan);\n-    const secondarySpans = rd.spans.filter(s => !s.is_primary);\n-\n-    const severity = mapLevelToSeverity(rd.level);\n-    let primarySpanLabel = primarySpan.label;\n-\n-    const vd = new vscode.Diagnostic(location.range, rd.message, severity);\n-\n-    let source = 'rustc';\n-    let code = rd.code && rd.code.code;\n-    if (code) {\n-        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n-        const scopedCode = code.split('::');\n-        if (scopedCode.length === 2) {\n-            [source, code] = scopedCode;\n-        }\n-    }\n-\n-    vd.source = source;\n-    vd.code = code;\n-    vd.relatedInformation = [];\n-    vd.tags = [];\n-\n-    for (const secondarySpan of secondarySpans) {\n-        const related = mapSecondarySpanToRelated(secondarySpan);\n-        if (related) {\n-            vd.relatedInformation.push(related);\n-        }\n-    }\n-\n-    const suggestedFixes = [];\n-    for (const child of rd.children) {\n-        const { related, suggestedFix, messageLine } = mapRustChildDiagnostic(\n-            child,\n-        );\n-\n-        if (related) {\n-            vd.relatedInformation.push(related);\n-        }\n-        if (suggestedFix) {\n-            suggestedFixes.push(suggestedFix);\n-        }\n-        if (messageLine) {\n-            vd.message += `\\n${messageLine}`;\n-\n-            // These secondary messages usually duplicate the content of the\n-            // primary span label.\n-            primarySpanLabel = undefined;\n-        }\n-    }\n-\n-    if (primarySpanLabel) {\n-        vd.message += `\\n${primarySpanLabel}`;\n-    }\n-\n-    if (isUnusedOrUnnecessary(rd)) {\n-        vd.tags.push(vscode.DiagnosticTag.Unnecessary);\n-    }\n-\n-    if (isDeprecated(rd)) {\n-        vd.tags.push(vscode.DiagnosticTag.Deprecated);\n-    }\n-\n-    return {\n-        location,\n-        diagnostic: vd,\n-        suggestedFixes,\n-    };\n-}"}, {"sha": "f4a5450e2b8c19bc946f2fc6a4488d8797ef583f", "filename": "editors/code/src/utils/diagnostics/vscode.ts", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fdiagnostics%2Fvscode.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,14 +0,0 @@\n-import * as vscode from 'vscode';\n-\n-/** Compares two `vscode.Diagnostic`s for equality */\n-export function areDiagnosticsEqual(\n-    left: vscode.Diagnostic,\n-    right: vscode.Diagnostic,\n-): boolean {\n-    return (\n-        left.source === right.source &&\n-        left.severity === right.severity &&\n-        left.range.isEqual(right.range) &&\n-        left.message === right.message\n-    );\n-}"}, {"sha": "a1d6b7eafbc8f30eb07a5b5a5eb30d2ca48091b1", "filename": "editors/code/src/utils/processes.ts", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2Fprocesses.ts?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,51 +0,0 @@\n-'use strict';\n-\n-import * as cp from 'child_process';\n-import ChildProcess = cp.ChildProcess;\n-\n-import { join } from 'path';\n-\n-const isWindows = process.platform === 'win32';\n-const isMacintosh = process.platform === 'darwin';\n-const isLinux = process.platform === 'linux';\n-\n-// this is very complex, but is basically copy-pased from VSCode implementation here:\n-// https://github.com/Microsoft/vscode-languageserver-node/blob/dbfd37e35953ad0ee14c4eeced8cfbc41697b47e/client/src/utils/processes.ts#L15\n-\n-// And see discussion at\n-// https://github.com/rust-analyzer/rust-analyzer/pull/1079#issuecomment-478908109\n-\n-export function terminate(process: ChildProcess, cwd?: string): boolean {\n-    if (isWindows) {\n-        try {\n-            // This we run in Atom execFileSync is available.\n-            // Ignore stderr since this is otherwise piped to parent.stderr\n-            // which might be already closed.\n-            const options: any = {\n-                stdio: ['pipe', 'pipe', 'ignore'],\n-            };\n-            if (cwd) {\n-                options.cwd = cwd;\n-            }\n-            cp.execFileSync(\n-                'taskkill',\n-                ['/T', '/F', '/PID', process.pid.toString()],\n-                options,\n-            );\n-            return true;\n-        } catch (err) {\n-            return false;\n-        }\n-    } else if (isLinux || isMacintosh) {\n-        try {\n-            const cmd = join(__dirname, 'terminateProcess.sh');\n-            const result = cp.spawnSync(cmd, [process.pid.toString()]);\n-            return result.error ? false : true;\n-        } catch (err) {\n-            return false;\n-        }\n-    } else {\n-        process.kill('SIGKILL');\n-        return true;\n-    }\n-}"}, {"sha": "2ec9e1c2ec32949ee319e96df948e0eb50084ed9", "filename": "editors/code/src/utils/terminateProcess.sh", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,12 +0,0 @@\n-#!/bin/bash\n-\n-terminateTree() {\n-    for cpid in $(pgrep -P $1); do\n-        terminateTree $cpid\n-    done\n-    kill -9 $1 > /dev/null 2>&1\n-}\n-\n-for pid in $*; do\n-    terminateTree $pid\n-done\n\\ No newline at end of file"}]}