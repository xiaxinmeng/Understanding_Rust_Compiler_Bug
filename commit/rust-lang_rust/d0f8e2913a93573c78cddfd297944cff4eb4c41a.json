{"sha": "d0f8e2913a93573c78cddfd297944cff4eb4c41a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZjhlMjkxM2E5MzU3M2M3OGNkZGZkMjk3OTQ0Y2ZmNGViNGM0MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-16T20:56:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-16T20:56:26Z"}, "message": "Auto merge of #45825 - nikomatsakis:nll-factor-region-inference, r=arielb1\n\nintegrate MIR type-checker with NLL inference\n\nThis branch refactors NLL type inference so that it uses the MIR type-checker to gather constraints. Along the way, it also refactors how region constraints are gathered in the normal inference context mildly. The new setup is like this:\n\n- What used to be `region_inference` is split into two parts:\n    - `region_constraints`, which just collects up sets of constraints\n    - `lexical_region_resolve`, which does the iterative, lexical region resolution\n- When `resolve_regions_and_report_errors` is invoked, the inference engine converts the constraints into final values.\n- In the MIR type checker, however, we do not invoke this method, but instead periodically take the region constraints and package them up for the NLL solver to use later.\n    - This allows us to track when and where those constraints were incurred.\n    - We also remove the central fulfillment context from the MIR type checker, instead instantiating new fulfillment contexts at each point. This allows us to capture the set of obligations that occurred at a particular point, and also to ensure that if the same obligation arises at two points, we will enforce the region constraints at both locations.\n- The MIR type checker is also enhanced to instantiate late-bound-regions with fresh variables and handle a few other corner cases that arose.\n- I also extracted some of the 'outlives' logic from the regionck, which will be needed later (see future work) to handle the type-outlives relationships.\n\nOne concern I have with this branch: since the MIR type checker is used even without the `-Znll` switch, I'm not sure if it will impact performance. One simple fix here would be to only enable the MIR type-checker if debug-assertions are enabled, since it just serves to validate the MIR. Longer term I hope to address this by improving the interface to the trait solver to be more query-based (ongoing work).\n\nThere is plenty of future work left. Here are two things that leap to mind:\n\n- **Type-region outlives.** Currently, the NLL solver will ICE if it is required to handle a constraint like `T: 'a`. Fixing this will require a small amount of refactoring to extract the implied bounds code. I plan to follow a file-up bug on this (hopefully with mentoring instructions).\n- **Testing.** It's a good idea to enumerate some of the tricky scenarios that need testing, but I think it'd be nice to try and parallelize some of the actual test writing (and resulting bug fixing):\n    - Same obligation occurring at two points.\n    - Well-formedness and trait obligations of various kinds (which are not all processed by the current MIR type-checker).\n    - More tests for how subtyping and region inferencing interact.\n    - More suggestions welcome!\n\nr? @arielb1", "tree": {"sha": "082973283d8296ac7048be91df19dbd06afad0c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/082973283d8296ac7048be91df19dbd06afad0c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0f8e2913a93573c78cddfd297944cff4eb4c41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f8e2913a93573c78cddfd297944cff4eb4c41a", "html_url": "https://github.com/rust-lang/rust/commit/d0f8e2913a93573c78cddfd297944cff4eb4c41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0f8e2913a93573c78cddfd297944cff4eb4c41a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d8761ab3f2eda3536c0a8e81f2179655a6fb00", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d8761ab3f2eda3536c0a8e81f2179655a6fb00", "html_url": "https://github.com/rust-lang/rust/commit/58d8761ab3f2eda3536c0a8e81f2179655a6fb00"}, {"sha": "8c109f5681c08ed70f85926a2a18f8ed98fef77c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c109f5681c08ed70f85926a2a18f8ed98fef77c", "html_url": "https://github.com/rust-lang/rust/commit/8c109f5681c08ed70f85926a2a18f8ed98fef77c"}], "stats": {"total": 8451, "additions": 4835, "deletions": 3616}, "files": [{"sha": "e7daff3e2c371664789f24836a57521a165667f7", "filename": "src/librustc/infer/README.md", "status": "modified", "additions": 213, "deletions": 225, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,239 +1,227 @@\n # Type inference engine\n \n-This is loosely based on standard HM-type inference, but with an\n-extension to try and accommodate subtyping.  There is nothing\n-principled about this extension; it's sound---I hope!---but it's a\n-heuristic, ultimately, and does not guarantee that it finds a valid\n-typing even if one exists (in fact, there are known scenarios where it\n-fails, some of which may eventually become problematic).\n-\n-## Key idea\n-\n-The main change is that each type variable T is associated with a\n-lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n-respectively, but gradually narrow in response to new constraints\n-being introduced.  When a variable is finally resolved to a concrete\n-type, it can (theoretically) select any type that is a supertype of L\n-and a subtype of U.\n-\n-There are several critical invariants which we maintain:\n-\n-- the upper-bound of a variable only becomes lower and the lower-bound\n-  only becomes higher over time;\n-- the lower-bound L is always a subtype of the upper bound U;\n-- the lower-bound L and upper-bound U never refer to other type variables,\n-  but only to types (though those types may contain type variables).\n-\n-> An aside: if the terms upper- and lower-bound confuse you, think of\n-> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n-> (super=upper in Latin, or something like that anyway) and the lower-bound\n-> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n-> a simple class hierarchy, like Java minus interfaces and\n-> primitive types.  The class Object is at the root (top) and other\n-> types lie in between.  The bottom type is then the Null type.\n-> So the tree looks like:\n->\n-> ```text\n->         Object\n->         /    \\\n->     String   Other\n->         \\    /\n->         (null)\n-> ```\n->\n-> So the upper bound type is the \"supertype\" and the lower bound is the\n-> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n-> like that anyway).\n-\n-## Satisfying constraints\n-\n-At a primitive level, there is only one form of constraint that the\n-inference understands: a subtype relation.  So the outside world can\n-say \"make type A a subtype of type B\".  If there are variables\n-involved, the inferencer will adjust their upper- and lower-bounds as\n-needed to ensure that this relation is satisfied. (We also allow \"make\n-type A equal to type B\", but this is translated into \"A <: B\" and \"B\n-<: A\")\n-\n-As stated above, we always maintain the invariant that type bounds\n-never refer to other variables.  This keeps the inference relatively\n-simple, avoiding the scenario of having a kind of graph where we have\n-to pump constraints along and reach a fixed point, but it does impose\n-some heuristics in the case where the user is relating two type\n-variables A <: B.\n-\n-Combining two variables such that variable A will forever be a subtype\n-of variable B is the trickiest part of the algorithm because there is\n-often no right choice---that is, the right choice will depend on\n-future constraints which we do not yet know. The problem comes about\n-because both A and B have bounds that can be adjusted in the future.\n-Let's look at some of the cases that can come up.\n-\n-Imagine, to start, the best case, where both A and B have an upper and\n-lower bound (that is, the bounds are not top nor bot respectively). In\n-that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n-A and B should become, they will forever have the desired subtyping\n-relation.  We can just leave things as they are.\n-\n-### Option 1: Unify\n-\n-However, suppose that A.ub is *not* a subtype of B.lb.  In\n-that case, we must make a decision.  One option is to unify A\n-and B so that they are one variable whose bounds are:\n-\n-    UB = GLB(A.ub, B.ub)\n-    LB = LUB(A.lb, B.lb)\n-\n-(Note that we will have to verify that LB <: UB; if it does not, the\n-types are not intersecting and there is an error) In that case, A <: B\n-holds trivially because A==B.  However, we have now lost some\n-flexibility, because perhaps the user intended for A and B to end up\n-as different types and not the same type.\n-\n-Pictorially, what this does is to take two distinct variables with\n-(hopefully not completely) distinct type ranges and produce one with\n-the intersection.\n-\n-```text\n-                  B.ub                  B.ub\n-                   /\\                    /\n-           A.ub   /  \\           A.ub   /\n-           /   \\ /    \\              \\ /\n-          /     X      \\              UB\n-         /     / \\      \\            / \\\n-        /     /   /      \\          /   /\n-        \\     \\  /       /          \\  /\n-         \\      X       /             LB\n-          \\    / \\     /             / \\\n-           \\  /   \\   /             /   \\\n-           A.lb    B.lb          A.lb    B.lb\n-```\n+The type inference is based on standard HM-type inference, but\n+extended in various way to accommodate subtyping, region inference,\n+and higher-ranked types.\n+\n+## A note on terminology\n+\n+We use the notation `?T` to refer to inference variables, also called\n+existential variables.\n+\n+We use the term \"region\" and \"lifetime\" interchangeably. Both refer to\n+the `'a` in `&'a T`.\n+\n+The term \"bound region\" refers to regions bound in a function\n+signature, such as the `'a` in `for<'a> fn(&'a u32)`. A region is\n+\"free\" if it is not bound.\n \n+## Creating an inference context\n \n-### Option 2: Relate UB/LB\n-\n-Another option is to keep A and B as distinct variables but set their\n-bounds in such a way that, whatever happens, we know that A <: B will hold.\n-This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n-are two ways to do that, depicted pictorially here:\n-\n-```text\n-    Before                Option #1            Option #2\n-\n-             B.ub                B.ub                B.ub\n-              /\\                 /  \\                /  \\\n-      A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n-      /   \\ /    \\           \\ /     /           \\ /     /\n-     /     X      \\         __UB____/             UB    /\n-    /     / \\      \\       /  |                   |    /\n-   /     /   /      \\     /   |                   |   /\n-   \\     \\  /       /    /(A')|                   |  /\n-    \\      X       /    /     LB            ______LB/\n-     \\    / \\     /    /     / \\           / (A')/ \\\n-      \\  /   \\   /     \\    /   \\          \\    /   \\\n-      A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+You create and \"enter\" an inference context by doing something like\n+the following:\n+\n+```rust\n+tcx.infer_ctxt().enter(|infcx| {\n+    // use the inference context `infcx` in here\n+})\n ```\n \n-In these diagrams, UB and LB are defined as before.  As you can see,\n-the new ranges `A'` and `B'` are quite different from the range that\n-would be produced by unifying the variables.\n+Each inference context creates a short-lived type arena to store the\n+fresh types and things that it will create, as described in\n+[the README in the ty module][ty-readme]. This arena is created by the `enter`\n+function and disposed after it returns.\n \n-### What we do now\n+[ty-readme]: src/librustc/ty/README.md\n \n-Our current technique is to *try* (transactionally) to relate the\n-existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n-&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n-we merge A and B into same variable.\n+Within the closure, the infcx will have the type `InferCtxt<'cx, 'gcx,\n+'tcx>` for some fresh `'cx` and `'tcx` -- the latter corresponds to\n+the lifetime of this temporary arena, and the `'cx` is the lifetime of\n+the `InferCtxt` itself. (Again, see [that ty README][ty-readme] for\n+more details on this setup.)\n \n-This is not clearly the correct course.  For example, if `UB(A) !=\n-top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n-and leave the variables unmerged.  This is sometimes the better\n-course, it depends on the program.\n+The `tcx.infer_ctxt` method actually returns a build, which means\n+there are some kinds of configuration you can do before the `infcx` is\n+created. See `InferCtxtBuilder` for more information.\n \n-The main case which fails today that I would like to support is:\n+## Inference variables\n \n-```rust\n-fn foo<T>(x: T, y: T) { ... }\n+The main purpose of the inference context is to house a bunch of\n+**inference variables** -- these represent types or regions whose precise\n+value is not yet known, but will be uncovered as we perform type-checking.\n+\n+If you're familiar with the basic ideas of unification from H-M type\n+systems, or logic languages like Prolog, this is the same concept. If\n+you're not, you might want to read a tutorial on how H-M type\n+inference works, or perhaps this blog post on\n+[unification in the Chalk project].\n \n-fn bar() {\n-    let x: @mut int = @mut 3;\n-    let y: @int = @3;\n-    foo(x, y);\n-}\n+[Unification in the Chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/\n+\n+All told, the inference context stores four kinds of inference variables as of this\n+writing:\n+\n+- Type variables, which come in three varieties:\n+  - General type variables (the most common). These can be unified with any type.\n+  - Integral type variables, which can only be unified with an integral type, and\n+    arise from an integer literal expression like `22`.\n+  - Float type variables, which can only be unified with a float type, and\n+    arise from a float literal expression like `22.0`.\n+- Region variables, which represent lifetimes, and arise all over the dang place.\n+\n+All the type variables work in much the same way: you can create a new\n+type variable, and what you get is `Ty<'tcx>` representing an\n+unresolved type `?T`. Then later you can apply the various operations\n+that the inferencer supports, such as equality or subtyping, and it\n+will possibly **instantiate** (or **bind**) that `?T` to a specific\n+value as a result.\n+\n+The region variables work somewhat differently, and are described\n+below in a separate section.\n+\n+## Enforcing equality / subtyping\n+\n+The most basic operations you can perform in the type inferencer is\n+**equality**, which forces two types `T` and `U` to be the same. The\n+recommended way to add an equality constraint is using the `at`\n+method, roughly like so:\n+\n+```\n+infcx.at(...).eq(t, u);\n ```\n \n-In principle, the inferencer ought to find that the parameter `T` to\n-`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n-because the type variable `T` is merged with the type variable for\n-`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n-flexibility for `T` to later adjust to accommodate `@int`.\n-\n-Note: `@` and `@mut` are replaced with `Rc<T>` and `Rc<RefCell<T>>` in current Rust.\n-\n-### What to do when not all bounds are present\n-\n-In the prior discussion we assumed that A.ub was not top and B.lb was\n-not bot.  Unfortunately this is rarely the case.  Often type variables\n-have \"lopsided\" bounds.  For example, if a variable in the program has\n-been initialized but has not been used, then its corresponding type\n-variable will have a lower bound but no upper bound.  When that\n-variable is then used, we would like to know its upper bound---but we\n-don't have one!  In this case we'll do different things depending on\n-how the variable is being used.\n-\n-## Transactional support\n-\n-Whenever we adjust merge variables or adjust their bounds, we always\n-keep a record of the old value.  This allows the changes to be undone.\n-\n-## Regions\n-\n-I've only talked about type variables here, but region variables\n-follow the same principle.  They have upper- and lower-bounds.  A\n-region A is a subregion of a region B if A being valid implies that B\n-is valid.  This basically corresponds to the block nesting structure:\n-the regions for outer block scopes are superregions of those for inner\n-block scopes.\n-\n-## Integral and floating-point type variables\n-\n-There is a third variety of type variable that we use only for\n-inferring the types of unsuffixed integer literals.  Integral type\n-variables differ from general-purpose type variables in that there's\n-no subtyping relationship among the various integral types, so instead\n-of associating each variable with an upper and lower bound, we just\n-use simple unification.  Each integer variable is associated with at\n-most one integer type.  Floating point types are handled similarly to\n-integral types.\n-\n-## GLB/LUB\n-\n-Computing the greatest-lower-bound and least-upper-bound of two\n-types/regions is generally straightforward except when type variables\n-are involved. In that case, we follow a similar \"try to use the bounds\n-when possible but otherwise merge the variables\" strategy.  In other\n-words, `GLB(A, B)` where `A` and `B` are variables will often result\n-in `A` and `B` being merged and the result being `A`.\n-\n-## Type coercion\n-\n-We have a notion of assignability which differs somewhat from\n-subtyping; in particular it may cause region borrowing to occur.  See\n-the big comment later in this file on Type Coercion for specifics.\n-\n-### In conclusion\n-\n-I showed you three ways to relate `A` and `B`.  There are also more,\n-of course, though I'm not sure if there are any more sensible options.\n-The main point is that there are various options, each of which\n-produce a distinct range of types for `A` and `B`.  Depending on what\n-the correct values for A and B are, one of these options will be the\n-right choice: but of course we don't know the right values for A and B\n-yet, that's what we're trying to find!  In our code, we opt to unify\n-(Option #1).\n-\n-# Implementation details\n-\n-We make use of a trait-like implementation strategy to consolidate\n-duplicated code between subtypes, GLB, and LUB computations.  See the\n-section on \"Type Combining\" in combine.rs for more details.\n+The first `at()` call provides a bit of context, i.e., why you are\n+doing this unification, and in what environment, and the `eq` method\n+performs the actual equality constraint.\n+\n+When you equate things, you force them to be precisely equal. Equating\n+returns a `InferResult` -- if it returns `Err(err)`, then equating\n+failed, and the enclosing `TypeError` will tell you what went wrong.\n+\n+The success case is perhaps more interesting. The \"primary\" return\n+type of `eq` is `()` -- that is, when it succeeds, it doesn't return a\n+value of any particular interest. Rather, it is executed for its\n+side-effects of constraining type variables and so forth. However, the\n+actual return type is not `()`, but rather `InferOk<()>`. The\n+`InferOk` type is used to carry extra trait obligations -- your job is\n+to ensure that these are fulfilled (typically by enrolling them in a\n+fulfillment context). See the [trait README] for more background here.\n+\n+[trait README]: ../traits/README.md\n+\n+You can also enforce subtyping through `infcx.at(..).sub(..)`. The same\n+basic concepts apply as above.\n+\n+## \"Trying\" equality\n+\n+Sometimes you would like to know if it is *possible* to equate two\n+types without error.  You can test that with `infcx.can_eq` (or\n+`infcx.can_sub` for subtyping). If this returns `Ok`, then equality\n+is possible -- but in all cases, any side-effects are reversed.\n+\n+Be aware though that the success or failure of these methods is always\n+**modulo regions**. That is, two types `&'a u32` and `&'b u32` will\n+return `Ok` for `can_eq`, even if `'a != 'b`.  This falls out from the\n+\"two-phase\" nature of how we solve region constraints.\n+\n+## Snapshots\n+\n+As described in the previous section on `can_eq`, often it is useful\n+to be able to do a series of operations and then roll back their\n+side-effects. This is done for various reasons: one of them is to be\n+able to backtrack, trying out multiple possibilities before settling\n+on which path to take. Another is in order to ensure that a series of\n+smaller changes take place atomically or not at all.\n+\n+To allow for this, the inference context supports a `snapshot` method.\n+When you call it, it will start recording changes that occur from the\n+operations you perform. When you are done, you can either invoke\n+`rollback_to`, which will undo those changes, or else `confirm`, which\n+will make the permanent. Snapshots can be nested as long as you follow\n+a stack-like discipline.\n+\n+Rather than use snapshots directly, it is often helpful to use the\n+methods like `commit_if_ok` or `probe` that encapsulte higher-level\n+patterns.\n+\n+## Subtyping obligations\n+\n+One thing worth discussing are subtyping obligations. When you force\n+two types to be a subtype, like `?T <: i32`, we can often convert those\n+into equality constraints. This follows from Rust's rather limited notion\n+of subtyping: so, in the above case, `?T <: i32` is equivalent to `?T = i32`.\n+\n+However, in some cases we have to be more careful. For example, when\n+regions are involved. So if you have `?T <: &'a i32`, what we would do\n+is to first \"generalize\" `&'a i32` into a type with a region variable:\n+`&'?b i32`, and then unify `?T` with that (`?T = &'?b i32`). We then\n+relate this new variable with the original bound:\n+\n+    &'?b i32 <: &'a i32\n+    \n+This will result in a region constraint (see below) of `'?b: 'a`.\n+\n+One final interesting case is relating two unbound type variables,\n+like `?T <: ?U`.  In that case, we can't make progress, so we enqueue\n+an obligation `Subtype(?T, ?U)` and return it via the `InferOk`\n+mechanism. You'll have to try again when more details about `?T` or\n+`?U` are known.\n+\n+## Region constraints\n+\n+Regions are inferred somewhat differently from types. Rather than\n+eagerly unifying things, we simply collect constraints as we go, but\n+make (almost) no attempt to solve regions. These constraints have the\n+form of an outlives constraint:\n+\n+    'a: 'b\n+    \n+Actually the code tends to view them as a subregion relation, but it's the same\n+idea:\n+\n+    'b <= 'a\n+\n+(There are various other kinds of constriants, such as \"verifys\"; see\n+the `region_constraints` module for details.)\n+\n+There is one case where we do some amount of eager unification. If you have an equality constraint\n+between two regions\n+\n+    'a = 'b\n+    \n+we will record that fact in a unification table. You can then use\n+`opportunistic_resolve_var` to convert `'b` to `'a` (or vice\n+versa). This is sometimes needed to ensure termination of fixed-point\n+algorithms.\n+\n+## Extracting region constraints\n+\n+Ultimately, region constraints are only solved at the very end of\n+type-checking, once all other constraints are known. There are two\n+ways to solve region constraints right now: lexical and\n+non-lexical. Eventually there will only be one.\n+\n+To solve **lexical** region constraints, you invoke\n+`resolve_regions_and_report_errors`.  This will \"close\" the region\n+constraint process and invoke the `lexical_region_resolve` code. Once\n+this is done, any further attempt to equate or create a subtyping\n+relationship will yield an ICE.\n+\n+Non-lexical region constraints are not handled within the inference\n+context. Instead, the NLL solver (actually, the MIR type-checker)\n+invokes `take_and_reset_region_constraints` periodically. This\n+extracts all of the outlives constraints from the region solver, but\n+leaves the set of variables intact. This is used to get *just* the\n+region constraints that resulted from some particular point in the\n+program, since the NLL solver needs to know not just *what* regions\n+were subregions but *where*. Finally, the NLL solver invokes\n+`take_region_var_origins`, which \"closes\" the region constraint\n+process in the same way as normal solving.\n+\n+## Lexical region resolution\n+\n+Lexical region resolution is done by initially assigning each region\n+variable to an empty value. We then process each outlives constraint\n+repeatedly, growing region variables until a fixed-point is reached.\n+Region variables can be grown using a least-upper-bound relation on\n+the region lattice in a fairly straight-forward fashion."}, {"sha": "2ae8f8ae9335711f41a9d693f764b4bf30c82e86", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -104,7 +104,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                a,\n                b);\n         let origin = Subtype(self.fields.trace.clone());\n-        self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n+        self.fields.infcx.borrow_region_constraints()\n+                         .make_eqregion(origin, a, b);\n         Ok(a)\n     }\n "}, {"sha": "c64bd610962eb440a4b4180cd2931c0fb227bcc4", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -13,8 +13,8 @@\n use hir;\n use infer::InferCtxt;\n use ty::{self, Region};\n-use infer::region_inference::RegionResolutionError::*;\n-use infer::region_inference::RegionResolutionError;\n+use infer::lexical_region_resolve::RegionResolutionError::*;\n+use infer::lexical_region_resolve::RegionResolutionError;\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};"}, {"sha": "d22eb20e70a88a8b588f3c4be6fafb58423174fa", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -57,8 +57,8 @@\n \n use infer;\n use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n-use super::region_inference::{RegionResolutionError, ConcreteFailure, SubSupConflict,\n-                              GenericBoundFailure, GenericKind};\n+use super::region_constraints::GenericKind;\n+use super::lexical_region_resolve::RegionResolutionError;\n \n use std::fmt;\n use hir;\n@@ -177,13 +177,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEarlyBound(_) |\n             ty::ReFree(_) => {\n-                let scope = match *region {\n-                    ty::ReEarlyBound(ref br) => {\n-                        self.parent_def_id(br.def_id).unwrap()\n-                    }\n-                    ty::ReFree(ref fr) => fr.scope,\n-                    _ => bug!()\n-                };\n+                let scope = region.free_region_binding_scope(self);\n                 let prefix = match *region {\n                     ty::ReEarlyBound(ref br) => {\n                         format!(\"the lifetime {} as defined on\", br.name)\n@@ -293,33 +287,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"report_region_errors: error = {:?}\", error);\n \n             if !self.try_report_named_anon_conflict(&error) &&\n-               !self.try_report_anon_anon_conflict(&error) {\n-\n-               match error.clone() {\n-                  // These errors could indicate all manner of different\n-                  // problems with many different solutions. Rather\n-                  // than generate a \"one size fits all\" error, what we\n-                  // attempt to do is go through a number of specific\n-                  // scenarios and try to find the best way to present\n-                  // the error. If all of these fails, we fall back to a rather\n-                  // general bit of code that displays the error information\n-                  ConcreteFailure(origin, sub, sup) => {\n-                      self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n-                  }\n-\n-                  GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n-                  }\n-\n-                  SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n+                !self.try_report_anon_anon_conflict(&error)\n+            {\n+                match error.clone() {\n+                    // These errors could indicate all manner of different\n+                    // problems with many different solutions. Rather\n+                    // than generate a \"one size fits all\" error, what we\n+                    // attempt to do is go through a number of specific\n+                    // scenarios and try to find the best way to present\n+                    // the error. If all of these fails, we fall back to a rather\n+                    // general bit of code that displays the error information\n+                    RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n+                        self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n+                    }\n+\n+                    RegionResolutionError::GenericBoundFailure(kind, param_ty, sub) => {\n+                        self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n+                    }\n+\n+                    RegionResolutionError::SubSupConflict(var_origin,\n+                                                          sub_origin,\n+                                                          sub_r,\n+                                                          sup_origin,\n+                                                          sup_r) => {\n                         self.report_sub_sup_conflict(region_scope_tree,\n                                                      var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n                                                      sup_origin,\n                                                      sup_r);\n-                  }\n-               }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -351,9 +349,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // the only thing in the list.\n \n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n-            ConcreteFailure(..) => false,\n-            SubSupConflict(..) => false,\n-            GenericBoundFailure(..) => true,\n+            RegionResolutionError::GenericBoundFailure(..) => true,\n+            RegionResolutionError::ConcreteFailure(..) |\n+            RegionResolutionError::SubSupConflict(..) => false,\n         };\n \n \n@@ -365,9 +363,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // sort the errors by span, for better error message stability.\n         errors.sort_by_key(|u| match *u {\n-            ConcreteFailure(ref sro, _, _) => sro.span(),\n-            GenericBoundFailure(ref sro, _, _) => sro.span(),\n-            SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n+            RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n+            RegionResolutionError::SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n         });\n         errors\n     }\n@@ -880,14 +878,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let SubregionOrigin::CompareImplMethodObligation {\n-            span, item_name, impl_item_def_id, trait_item_def_id, lint_id\n+            span, item_name, impl_item_def_id, trait_item_def_id,\n         } = origin {\n             self.report_extra_impl_obligation(span,\n                                               item_name,\n                                               impl_item_def_id,\n                                               trait_item_def_id,\n-                                              &format!(\"`{}: {}`\", bound_kind, sub),\n-                                              lint_id)\n+                                              &format!(\"`{}: {}`\", bound_kind, sub))\n                 .emit();\n             return;\n         }\n@@ -1026,6 +1023,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let var_name = self.tcx.hir.name(var_node_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n+            infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n         struct_span_err!(self.tcx.sess, var_origin.span(), E0495,"}, {"sha": "6af7415ba5371147a88fd79b01ad918aaa2766d9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -11,8 +11,8 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use infer::InferCtxt;\n-use infer::region_inference::RegionResolutionError::*;\n-use infer::region_inference::RegionResolutionError;\n+use infer::lexical_region_resolve::RegionResolutionError::*;\n+use infer::lexical_region_resolve::RegionResolutionError;\n use ty;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "e46613b3e4da0cd0fa804878c50ae8d1c12193fc", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -445,14 +445,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::CompareImplMethodObligation { span,\n                                                  item_name,\n                                                  impl_item_def_id,\n-                                                 trait_item_def_id,\n-                                                 lint_id } => {\n+                                                 trait_item_def_id } => {\n                 self.report_extra_impl_obligation(span,\n                                                   item_name,\n                                                   impl_item_def_id,\n                                                   trait_item_def_id,\n-                                                  &format!(\"`{}: {}`\", sup, sub),\n-                                                  lint_id)\n+                                                  &format!(\"`{}: {}`\", sup, sub))\n             }\n         }\n     }"}, {"sha": "756a6947ee3f850d489f8f6f6f6f6a65f2cb8d96", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -78,8 +78,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         self.type_variables.borrow_mut().types_created_since_snapshot(\n                             &snapshot.type_snapshot);\n                     let region_vars =\n-                        self.region_vars.vars_created_since_snapshot(\n-                            &snapshot.region_vars_snapshot);\n+                        self.borrow_region_constraints().vars_created_since_snapshot(\n+                            &snapshot.region_constraints_snapshot);\n \n                     Ok((type_variables, region_vars, value))\n                 }"}, {"sha": "8b42314ed97cf31f1c028b6662468b8626eeacc3", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))\n+        Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "c49b3b4b9c87365ed039dedba95226cc81269ed1", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -17,7 +17,7 @@ use super::{CombinedSnapshot,\n             SubregionOrigin,\n             SkolemizationMap};\n use super::combine::CombineFields;\n-use super::region_inference::{TaintDirections};\n+use super::region_constraints::{TaintDirections};\n \n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n@@ -176,9 +176,10 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                      .filter(|&r| r != representative)\n                 {\n                     let origin = SubregionOrigin::Subtype(self.trace.clone());\n-                    self.infcx.region_vars.make_eqregion(origin,\n-                                                         *representative,\n-                                                         *region);\n+                    self.infcx.borrow_region_constraints()\n+                              .make_eqregion(origin,\n+                                             *representative,\n+                                             *region);\n                 }\n             }\n \n@@ -427,7 +428,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 debruijn: ty::DebruijnIndex)\n                                                 -> ty::Region<'tcx> {\n-            infcx.region_vars.new_bound(debruijn)\n+            infcx.borrow_region_constraints().new_bound(infcx.tcx, debruijn)\n         }\n     }\n }\n@@ -481,7 +482,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n-        self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n+        self.borrow_region_constraints().tainted(\n+            self.tcx,\n+            &snapshot.region_constraints_snapshot,\n+            r,\n+            directions)\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -539,7 +544,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          */\n \n         let mut region_vars =\n-            self.region_vars.vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n+            self.borrow_region_constraints().vars_created_since_snapshot(\n+                &snapshot.region_constraints_snapshot);\n \n         let escaping_types =\n             self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n@@ -581,7 +587,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.region_vars.push_skolemized(br, &snapshot.region_vars_snapshot)\n+            self.borrow_region_constraints()\n+                .push_skolemized(self.tcx, br, &snapshot.region_constraints_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -766,7 +773,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n-        self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n+        self.borrow_region_constraints()\n+            .pop_skolemized(self.tcx, &skol_regions, &snapshot.region_constraints_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized(\n                 &snapshot.projection_cache_snapshot);"}, {"sha": "a90230870a6c0d77f05a7ecd70f07bf132a6f1b3", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "renamed", "additions": 10, "deletions": 69, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,10 +1,13 @@\n-Region inference\n+# Region inference\n \n-# Terminology\n+## Terminology\n \n Note that we use the terms region and lifetime interchangeably.\n \n-# Introduction\n+## Introduction\n+\n+See the [general inference README](../README.md) for an overview of\n+how lexical-region-solving fits into the bigger picture.\n \n Region inference uses a somewhat more involved algorithm than type\n inference. It is not the most efficient thing ever written though it\n@@ -16,63 +19,6 @@ it's worth spending more time on a more involved analysis.  Moreover,\n regions are a simpler case than types: they don't have aggregate\n structure, for example.\n \n-Unlike normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-The constraints are always of one of three possible forms:\n-\n-- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n-  a subregion of Rj\n-- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n-  must not be a variable) must be a subregion of the variable Ri\n-- `ConstrainVarSubReg(Ri, R)` states the variable Ri shoudl be less\n-  than the concrete region R. This is kind of deprecated and ought to\n-  be replaced with a verify (they essentially play the same role).\n-\n-In addition to constraints, we also gather up a set of \"verifys\"\n-(what, you don't think Verify is a noun? Get used to it my\n-friend!). These represent relations that must hold but which don't\n-influence inference proper. These take the form of:\n-\n-- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n-  where Rj is not an inference variable (and Ri may or may not contain\n-  one). This doesn't influence inference because we will already have\n-  inferred Ri to be as small as possible, so then we just test whether\n-  that result was less than Rj or not.\n-- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n-  that the region R must satisfy the bound `Vb`. The bounds themselves\n-  may have structure like \"must outlive one of the following regions\"\n-  or \"must outlive ALL of the following regions. These bounds arise\n-  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n-  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n-  'a` *or* `'c: 'a`.\n-\n-# Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n-- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the smallest region that is greater than both Ri and Rj\n-- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the greatest region that is smaller than both Ri and Rj\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n ## The problem\n \n Basically our input is a directed graph where nodes can be divided\n@@ -109,9 +55,9 @@ step where we walk over the verify bounds and check that they are\n satisfied. These bounds represent the \"maximal\" values that a region\n variable can take on, basically.\n \n-# The Region Hierarchy\n+## The Region Hierarchy\n \n-## Without closures\n+### Without closures\n \n Let's first consider the region hierarchy without thinking about\n closures, because they add a lot of complications. The region\n@@ -141,7 +87,7 @@ Within that, there are sublifetimes for the assignment pattern and\n also the expression `x + y`. The expression itself has sublifetimes\n for evaluating `x` and `y`.\n \n-## Function calls\n+#s## Function calls\n \n Function calls are a bit tricky. I will describe how we handle them\n *now* and then a bit about how we can improve them (Issue #6268).\n@@ -259,7 +205,7 @@ there is a reference created whose lifetime does not enclose\n the borrow expression, we must issue sufficient restrictions to ensure\n that the pointee remains valid.\n \n-## Modeling closures\n+### Modeling closures\n \n Integrating closures properly into the model is a bit of\n work-in-progress. In an ideal world, we would model closures as\n@@ -314,8 +260,3 @@ handling of closures, there are no known cases where this leads to a\n type-checking accepting incorrect code (though it sometimes rejects\n what might be considered correct code; see rust-lang/rust#22557), but\n it still doesn't feel like the right approach.\n-\n-### Skolemization\n-\n-For a discussion on skolemization and higher-ranked subtyping, please\n-see the module `middle::infer::higher_ranked::doc`.", "previous_filename": "src/librustc/infer/region_inference/README.md"}, {"sha": "41209487395785981d654d715a1d3fe4fb3cf9cb", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! This module provides linkage between libgraphviz traits and\n-//! `rustc::middle::typeck::infer::region_inference`, generating a\n+//! `rustc::middle::typeck::infer::region_constraints`, generating a\n //! rendering of the graph represented by the list of `Constraint`\n //! instances (which make up the edges of the graph), as well as the\n //! origin for each constraint (which are attached to the labels on\n@@ -25,7 +25,7 @@ use middle::free_region::RegionRelations;\n use middle::region;\n use super::Constraint;\n use infer::SubregionOrigin;\n-use infer::region_inference::RegionVarBindings;\n+use infer::region_constraints::RegionConstraintData;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n@@ -57,12 +57,13 @@ graphs will be printed.                                                     \\n\\\n }\n \n pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n-    region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+    region_data: &RegionConstraintData<'tcx>,\n     region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n {\n+    let tcx = region_rels.tcx;\n     let context = region_rels.context;\n \n-    if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n+    if !tcx.sess.opts.debugging_opts.print_region_graph {\n         return;\n     }\n \n@@ -112,12 +113,11 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    let constraints = &*region_vars.constraints.borrow();\n-    match dump_region_constraints_to(region_rels, constraints, &output_path) {\n+    match dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n-            region_vars.tcx.sess.err(&msg)\n+            tcx.sess.err(&msg)\n         }\n     }\n }\n@@ -212,13 +212,13 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n-        Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n+        Constraint::VarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n+        Constraint::RegSubVar(r_1, rv_2) =>\n             (Node::Region(*r_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n+        Constraint::VarSubReg(rv_1, r_2) =>\n             (Node::RegionVid(rv_1), Node::Region(*r_2)),\n-        Constraint::ConstrainRegSubReg(r_1, r_2) =>\n+        Constraint::RegSubReg(r_1, r_2) =>\n             (Node::Region(*r_1), Node::Region(*r_2)),\n     }\n }\n@@ -267,15 +267,15 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                                              map: &ConstraintMap<'tcx>,\n-                                              path: &str)\n-                                              -> io::Result<()> {\n-    debug!(\"dump_region_constraints map (len: {}) path: {}\",\n+fn dump_region_data_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                                       map: &ConstraintMap<'tcx>,\n+                                       path: &str)\n+                                       -> io::Result<()> {\n+    debug!(\"dump_region_data map (len: {}) path: {}\",\n            map.len(),\n            path);\n-    let g = ConstraintGraph::new(format!(\"region_constraints\"), region_rels, map);\n-    debug!(\"dump_region_constraints calling render\");\n+    let g = ConstraintGraph::new(format!(\"region_data\"), region_rels, map);\n+    debug!(\"dump_region_data calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();\n     File::create(path).and_then(|mut f| f.write_all(&v))", "previous_filename": "src/librustc/infer/region_inference/graphviz.rs"}, {"sha": "0692d284d7c16eb4f106397a18b670cfb4f3d22f", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,766 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The code to do lexical region resolution.\n+\n+use infer::SubregionOrigin;\n+use infer::RegionVariableOrigin;\n+use infer::region_constraints::Constraint;\n+use infer::region_constraints::GenericKind;\n+use infer::region_constraints::RegionConstraintData;\n+use infer::region_constraints::VarOrigins;\n+use infer::region_constraints::VerifyBound;\n+use middle::free_region::RegionRelations;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n+use std::fmt;\n+use std::u32;\n+use ty::{self, TyCtxt};\n+use ty::{Region, RegionVid};\n+use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n+\n+mod graphviz;\n+\n+/// This function performs lexical region resolution given a complete\n+/// set of constraints and variable origins. It performs a fixed-point\n+/// iteration to find region values which satisfy all constraints,\n+/// assuming such values can be found. It returns the final values of\n+/// all the variables as well as a set of errors that must be reported.\n+pub fn resolve<'tcx>(\n+    region_rels: &RegionRelations<'_, '_, 'tcx>,\n+    var_origins: VarOrigins,\n+    data: RegionConstraintData<'tcx>,\n+) -> (\n+    LexicalRegionResolutions<'tcx>,\n+    Vec<RegionResolutionError<'tcx>>,\n+) {\n+    debug!(\"RegionConstraintData: resolve_regions()\");\n+    let mut errors = vec![];\n+    let mut resolver = LexicalResolver {\n+        region_rels,\n+        var_origins,\n+        data,\n+    };\n+    let values = resolver.infer_variable_values(&mut errors);\n+    (values, errors)\n+}\n+\n+/// Contains the result of lexical region resolution. Offers methods\n+/// to lookup up the final value of a region variable.\n+pub struct LexicalRegionResolutions<'tcx> {\n+    values: IndexVec<RegionVid, VarValue<'tcx>>,\n+    error_region: ty::Region<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum VarValue<'tcx> {\n+    Value(Region<'tcx>),\n+    ErrorValue,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum RegionResolutionError<'tcx> {\n+    /// `ConcreteFailure(o, a, b)`:\n+    ///\n+    /// `o` requires that `a <= b`, but this does not hold\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n+\n+    /// `GenericBoundFailure(p, s, a)\n+    ///\n+    /// The parameter/associated-type `p` must be known to outlive the lifetime\n+    /// `a` (but none of the known bounds are sufficient).\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n+\n+    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n+    ///\n+    /// Could not infer a value for `v` because `sub_r <= v` (due to\n+    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n+    /// `sub_r <= sup_r` does not hold.\n+    SubSupConflict(\n+        RegionVariableOrigin,\n+        SubregionOrigin<'tcx>,\n+        Region<'tcx>,\n+        SubregionOrigin<'tcx>,\n+        Region<'tcx>,\n+    ),\n+}\n+\n+struct RegionAndOrigin<'tcx> {\n+    region: Region<'tcx>,\n+    origin: SubregionOrigin<'tcx>,\n+}\n+\n+type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n+\n+struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n+    var_origins: VarOrigins,\n+    data: RegionConstraintData<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n+    fn infer_variable_values(\n+        &mut self,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) -> LexicalRegionResolutions<'tcx> {\n+        let mut var_data = self.construct_var_data(self.region_rels.tcx);\n+\n+        // Dorky hack to cause `dump_constraints` to only get called\n+        // if debug mode is enabled:\n+        debug!(\n+            \"----() End constraint listing (context={:?}) {:?}---\",\n+            self.region_rels.context,\n+            self.dump_constraints(self.region_rels)\n+        );\n+        graphviz::maybe_print_constraints_for(&self.data, self.region_rels);\n+\n+        let graph = self.construct_graph();\n+        self.expand_givens(&graph);\n+        self.expansion(&mut var_data);\n+        self.collect_errors(&mut var_data, errors);\n+        self.collect_var_errors(&var_data, &graph, errors);\n+        var_data\n+    }\n+\n+    fn num_vars(&self) -> usize {\n+        self.var_origins.len()\n+    }\n+\n+    /// Initially, the value for all variables is set to `'empty`, the\n+    /// empty region. The `expansion` phase will grow this larger.\n+    fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n+        LexicalRegionResolutions {\n+            error_region: tcx.types.re_static,\n+            values: (0..self.num_vars())\n+                .map(|_| VarValue::Value(tcx.types.re_empty))\n+                .collect(),\n+        }\n+    }\n+\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'_, '_, 'tcx>) {\n+        debug!(\n+            \"----() Start constraint listing (context={:?}) ()----\",\n+            free_regions.context\n+        );\n+        for (idx, (constraint, _)) in self.data.constraints.iter().enumerate() {\n+            debug!(\"Constraint {} => {:?}\", idx, constraint);\n+        }\n+    }\n+\n+    fn expand_givens(&mut self, graph: &RegionGraph) {\n+        // Givens are a kind of horrible hack to account for\n+        // constraints like 'c <= '0 that are known to hold due to\n+        // closure signatures (see the comment above on the `givens`\n+        // field). They should go away. But until they do, the role\n+        // of this fn is to account for the transitive nature:\n+        //\n+        //     Given 'c <= '0\n+        //     and   '0 <= '1\n+        //     then  'c <= '1\n+\n+        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n+        for (r, vid) in seeds {\n+            // While all things transitively reachable in the graph\n+            // from the variable (`'0` in the example above).\n+            let seed_index = NodeIndex(vid.index as usize);\n+            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n+                let succ_index = succ_index.0;\n+\n+                // The first N nodes correspond to the region\n+                // variables. Other nodes correspond to constant\n+                // regions.\n+                if succ_index < self.num_vars() {\n+                    let succ_vid = RegionVid::new(succ_index);\n+\n+                    // Add `'c <= '1`.\n+                    self.data.givens.insert((r, succ_vid));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n+            debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n+            match *constraint {\n+                Constraint::RegSubVar(a_region, b_vid) => {\n+                    let b_data = var_values.value_mut(b_vid);\n+                    self.expand_node(a_region, b_vid, b_data)\n+                }\n+                Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n+                    VarValue::ErrorValue => false,\n+                    VarValue::Value(a_region) => {\n+                        let b_node = var_values.value_mut(b_vid);\n+                        self.expand_node(a_region, b_vid, b_node)\n+                    }\n+                },\n+                Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n+                    // These constraints are checked after expansion\n+                    // is done, in `collect_errors`.\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    fn expand_node(\n+        &self,\n+        a_region: Region<'tcx>,\n+        b_vid: RegionVid,\n+        b_data: &mut VarValue<'tcx>,\n+    ) -> bool {\n+        debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n+\n+        // Check if this relationship is implied by a given.\n+        match *a_region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n+            {\n+                debug!(\"given\");\n+                return false;\n+            },\n+            _ => {}\n+        }\n+\n+        match *b_data {\n+            VarValue::Value(cur_region) => {\n+                let lub = self.lub_concrete_regions(a_region, cur_region);\n+                if lub == cur_region {\n+                    return false;\n+                }\n+\n+                debug!(\n+                    \"Expanding value of {:?} from {:?} to {:?}\",\n+                    b_vid,\n+                    cur_region,\n+                    lub\n+                );\n+\n+                *b_data = VarValue::Value(lub);\n+                return true;\n+            }\n+\n+            VarValue::ErrorValue => {\n+                return false;\n+            }\n+        }\n+    }\n+\n+\n+    fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n+        let tcx = self.region_rels.tcx;\n+        match (a, b) {\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n+                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n+            }\n+\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            (&ReEmpty, r) | (r, &ReEmpty) => {\n+                r // everything lives longer than empty\n+            }\n+\n+            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n+                span_bug!(\n+                    self.var_origins[v_id].span(),\n+                    \"lub_concrete_regions invoked with non-concrete \\\n+                     regions: {:?}, {:?}\",\n+                    a,\n+                    b\n+                );\n+            }\n+\n+            (&ReEarlyBound(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(_)) => {\n+                // A \"free\" region can be interpreted as \"some region\n+                // at least as big as fr.scope\".  So, we can\n+                // reasonably compare free regions and scopes:\n+                let fr_scope = match (a, b) {\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n+                        .region_scope_tree\n+                        .early_free_scope(self.region_rels.tcx, br),\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n+                        .region_scope_tree\n+                        .free_scope(self.region_rels.tcx, fr),\n+                    _ => bug!(),\n+                };\n+                let r_id = self.region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(fr_scope, s_id);\n+                if r_id == fr_scope {\n+                    // if the free region's scope `fr.scope` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    match (a, b) {\n+                        (_, &ReScope(_)) => return a,\n+                        (&ReScope(_), _) => return b,\n+                        _ => bug!(),\n+                    }\n+                }\n+\n+                // otherwise, we don't know what the free region is,\n+                // so we must conservatively say the LUB is static:\n+                tcx.types.re_static\n+            }\n+\n+            (&ReScope(a_id), &ReScope(b_id)) => {\n+                // The region corresponding to an outer block is a\n+                // subtype of the region corresponding to an inner\n+                // block.\n+                let lub = self.region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(a_id, b_id);\n+                tcx.mk_region(ReScope(lub))\n+            }\n+\n+            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReEarlyBound(_)) |\n+            (&ReEarlyBound(_), &ReFree(_)) |\n+            (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n+\n+            // For these types, we cannot define any additional\n+            // relationship:\n+            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n+                a\n+            } else {\n+                tcx.types.re_static\n+            },\n+        }\n+    }\n+\n+    /// After expansion is complete, go and check upper bounds (i.e.,\n+    /// cases where the region cannot grow larger than a fixed point)\n+    /// and check that they are satisfied.\n+    fn collect_errors(\n+        &self,\n+        var_data: &mut LexicalRegionResolutions<'tcx>,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        for (constraint, origin) in &self.data.constraints {\n+            debug!(\n+                \"collect_errors: constraint={:?} origin={:?}\",\n+                constraint,\n+                origin\n+            );\n+            match *constraint {\n+                Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n+                    // Expansion will ensure that these constraints hold. Ignore.\n+                }\n+\n+                Constraint::RegSubReg(sub, sup) => {\n+                    if self.region_rels.is_subregion_of(sub, sup) {\n+                        continue;\n+                    }\n+\n+                    debug!(\n+                        \"collect_errors: region error at {:?}: \\\n+                         cannot verify that {:?} <= {:?}\",\n+                        origin,\n+                        sub,\n+                        sup\n+                    );\n+\n+                    errors.push(RegionResolutionError::ConcreteFailure(\n+                        (*origin).clone(),\n+                        sub,\n+                        sup,\n+                    ));\n+                }\n+\n+                Constraint::VarSubReg(a_vid, b_region) => {\n+                    let a_data = var_data.value_mut(a_vid);\n+                    debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data, b_region);\n+\n+                    let a_region = match *a_data {\n+                        VarValue::ErrorValue => continue,\n+                        VarValue::Value(a_region) => a_region,\n+                    };\n+\n+                    // Do not report these errors immediately:\n+                    // instead, set the variable value to error and\n+                    // collect them later.\n+                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n+                        debug!(\n+                            \"collect_errors: region error at {:?}: \\\n+                             cannot verify that {:?}={:?} <= {:?}\",\n+                            origin,\n+                            a_vid,\n+                            a_region,\n+                            b_region\n+                        );\n+                        *a_data = VarValue::ErrorValue;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for verify in &self.data.verifys {\n+            debug!(\"collect_errors: verify={:?}\", verify);\n+            let sub = var_data.normalize(verify.region);\n+\n+            // This was an inference variable which didn't get\n+            // constrained, therefore it can be assume to hold.\n+            if let ty::ReEmpty = *sub {\n+                continue;\n+            }\n+\n+            if self.bound_is_met(&verify.bound, var_data, sub) {\n+                continue;\n+            }\n+\n+            debug!(\n+                \"collect_errors: region error at {:?}: \\\n+                 cannot verify that {:?} <= {:?}\",\n+                verify.origin,\n+                verify.region,\n+                verify.bound\n+            );\n+\n+            errors.push(RegionResolutionError::GenericBoundFailure(\n+                verify.origin.clone(),\n+                verify.kind.clone(),\n+                sub,\n+            ));\n+        }\n+    }\n+\n+    /// Go over the variables that were declared to be error variables\n+    /// and create a `RegionResolutionError` for each of them.\n+    fn collect_var_errors(\n+        &self,\n+        var_data: &LexicalRegionResolutions<'tcx>,\n+        graph: &RegionGraph<'tcx>,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        debug!(\"collect_var_errors\");\n+\n+        // This is the best way that I have found to suppress\n+        // duplicate and related errors. Basically we keep a set of\n+        // flags for every node. Whenever an error occurs, we will\n+        // walk some portion of the graph looking to find pairs of\n+        // conflicting regions to report to the user. As we walk, we\n+        // trip the flags from false to true, and if we find that\n+        // we've already reported an error involving any particular\n+        // node we just stop and don't report the current error.  The\n+        // idea is to report errors that derive from independent\n+        // regions of the graph, but not those that derive from\n+        // overlapping locations.\n+        let mut dup_vec = vec![u32::MAX; self.num_vars()];\n+\n+        for (node_vid, value) in var_data.values.iter_enumerated() {\n+            match *value {\n+                VarValue::Value(_) => { /* Inference successful */ }\n+                VarValue::ErrorValue => {\n+                    /* Inference impossible, this value contains\n+                       inconsistent constraints.\n+\n+                       I think that in this case we should report an\n+                       error now---unlike the case above, we can't\n+                       wait to see whether the user needs the result\n+                       of this variable.  The reason is that the mere\n+                       existence of this variable implies that the\n+                       region graph is inconsistent, whether or not it\n+                       is used.\n+\n+                       For example, we may have created a region\n+                       variable that is the GLB of two other regions\n+                       which do not have a GLB.  Even if that variable\n+                       is not used, it implies that those two regions\n+                       *should* have a GLB.\n+\n+                       At least I think this is true. It may be that\n+                       the mere existence of a conflict in a region variable\n+                       that is not used is not a problem, so if this rule\n+                       starts to create problems we'll have to revisit\n+                       this portion of the code and think hard about it. =) */\n+                    self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn construct_graph(&self) -> RegionGraph<'tcx> {\n+        let num_vars = self.num_vars();\n+\n+        let mut graph = graph::Graph::new();\n+\n+        for _ in 0..num_vars {\n+            graph.add_node(());\n+        }\n+\n+        // Issue #30438: two distinct dummy nodes, one for incoming\n+        // edges (dummy_source) and another for outgoing edges\n+        // (dummy_sink). In `dummy -> a -> b -> dummy`, using one\n+        // dummy node leads one to think (erroneously) there exists a\n+        // path from `b` to `a`. Two dummy nodes sidesteps the issue.\n+        let dummy_source = graph.add_node(());\n+        let dummy_sink = graph.add_node(());\n+\n+        for (constraint, _) in &self.data.constraints {\n+            match *constraint {\n+                Constraint::VarSubVar(a_id, b_id) => {\n+                    graph.add_edge(\n+                        NodeIndex(a_id.index as usize),\n+                        NodeIndex(b_id.index as usize),\n+                        *constraint,\n+                    );\n+                }\n+                Constraint::RegSubVar(_, b_id) => {\n+                    graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n+                }\n+                Constraint::VarSubReg(a_id, _) => {\n+                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n+                }\n+                Constraint::RegSubReg(..) => {\n+                    // this would be an edge from `dummy_source` to\n+                    // `dummy_sink`; just ignore it.\n+                }\n+            }\n+        }\n+\n+        return graph;\n+    }\n+\n+    fn collect_error_for_expanding_node(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        dup_vec: &mut [u32],\n+        node_idx: RegionVid,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        // Errors in expanding nodes result from a lower-bound that is\n+        // not contained by an upper-bound.\n+        let (mut lower_bounds, lower_dup) =\n+            self.collect_concrete_regions(graph, node_idx, graph::INCOMING, dup_vec);\n+        let (mut upper_bounds, upper_dup) =\n+            self.collect_concrete_regions(graph, node_idx, graph::OUTGOING, dup_vec);\n+\n+        if lower_dup || upper_dup {\n+            return;\n+        }\n+\n+        // We place free regions first because we are special casing\n+        // SubSupConflict(ReFree, ReFree) when reporting error, and so\n+        // the user will more likely get a specific suggestion.\n+        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n+            match *x.region {\n+                ReEarlyBound(_) => 0,\n+                ReFree(_) => 1,\n+                _ => 2,\n+            }\n+        }\n+        lower_bounds.sort_by_key(region_order_key);\n+        upper_bounds.sort_by_key(region_order_key);\n+\n+        for lower_bound in &lower_bounds {\n+            for upper_bound in &upper_bounds {\n+                if !self.region_rels\n+                    .is_subregion_of(lower_bound.region, upper_bound.region)\n+                {\n+                    let origin = self.var_origins[node_idx].clone();\n+                    debug!(\n+                        \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n+                         sup: {:?}\",\n+                        origin,\n+                        node_idx,\n+                        lower_bound.region,\n+                        upper_bound.region\n+                    );\n+                    errors.push(RegionResolutionError::SubSupConflict(\n+                        origin,\n+                        lower_bound.origin.clone(),\n+                        lower_bound.region,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        span_bug!(\n+            self.var_origins[node_idx].span(),\n+            \"collect_error_for_expanding_node() could not find \\\n+             error for var {:?}, lower_bounds={:?}, \\\n+             upper_bounds={:?}\",\n+            node_idx,\n+            lower_bounds,\n+            upper_bounds\n+        );\n+    }\n+\n+    fn collect_concrete_regions(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        orig_node_idx: RegionVid,\n+        dir: Direction,\n+        dup_vec: &mut [u32],\n+    ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+        struct WalkState<'tcx> {\n+            set: FxHashSet<RegionVid>,\n+            stack: Vec<RegionVid>,\n+            result: Vec<RegionAndOrigin<'tcx>>,\n+            dup_found: bool,\n+        }\n+        let mut state = WalkState {\n+            set: FxHashSet(),\n+            stack: vec![orig_node_idx],\n+            result: Vec::new(),\n+            dup_found: false,\n+        };\n+        state.set.insert(orig_node_idx);\n+\n+        // to start off the process, walk the source node in the\n+        // direction specified\n+        process_edges(&self.data, &mut state, graph, orig_node_idx, dir);\n+\n+        while !state.stack.is_empty() {\n+            let node_idx = state.stack.pop().unwrap();\n+\n+            // check whether we've visited this node on some previous walk\n+            if dup_vec[node_idx.index as usize] == u32::MAX {\n+                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n+                state.dup_found = true;\n+            }\n+\n+            debug!(\n+                \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n+                orig_node_idx,\n+                node_idx\n+            );\n+\n+            process_edges(&self.data, &mut state, graph, node_idx, dir);\n+        }\n+\n+        let WalkState {\n+            result, dup_found, ..\n+        } = state;\n+        return (result, dup_found);\n+\n+        fn process_edges<'tcx>(\n+            this: &RegionConstraintData<'tcx>,\n+            state: &mut WalkState<'tcx>,\n+            graph: &RegionGraph<'tcx>,\n+            source_vid: RegionVid,\n+            dir: Direction,\n+        ) {\n+            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n+\n+            let source_node_index = NodeIndex(source_vid.index as usize);\n+            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n+                match edge.data {\n+                    Constraint::VarSubVar(from_vid, to_vid) => {\n+                        let opp_vid = if from_vid == source_vid {\n+                            to_vid\n+                        } else {\n+                            from_vid\n+                        };\n+                        if state.set.insert(opp_vid) {\n+                            state.stack.push(opp_vid);\n+                        }\n+                    }\n+\n+                    Constraint::RegSubVar(region, _) | Constraint::VarSubReg(_, region) => {\n+                        state.result.push(RegionAndOrigin {\n+                            region,\n+                            origin: this.constraints.get(&edge.data).unwrap().clone(),\n+                        });\n+                    }\n+\n+                    Constraint::RegSubReg(..) => panic!(\n+                        \"cannot reach reg-sub-reg edge in region inference \\\n+                         post-processing\"\n+                    ),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n+    where\n+        F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool,\n+    {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n+            for (constraint, origin) in &self.data.constraints {\n+                let edge_changed = body(constraint, origin);\n+                if edge_changed {\n+                    debug!(\"Updated due to constraint {:?}\", constraint);\n+                    changed = true;\n+                }\n+            }\n+        }\n+        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n+    }\n+\n+    fn bound_is_met(\n+        &self,\n+        bound: &VerifyBound<'tcx>,\n+        var_values: &LexicalRegionResolutions<'tcx>,\n+        min: ty::Region<'tcx>,\n+    ) -> bool {\n+        match bound {\n+            VerifyBound::AnyRegion(rs) => rs.iter()\n+                .map(|&r| var_values.normalize(r))\n+                .any(|r| self.region_rels.is_subregion_of(min, r)),\n+\n+            VerifyBound::AllRegions(rs) => rs.iter()\n+                .map(|&r| var_values.normalize(r))\n+                .all(|r| self.region_rels.is_subregion_of(min, r)),\n+\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| self.bound_is_met(b, var_values, min)),\n+\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| self.bound_is_met(b, var_values, min)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n+    }\n+}\n+\n+\n+impl<'tcx> LexicalRegionResolutions<'tcx> {\n+    fn normalize(&self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReVar(rid) => self.resolve_var(rid),\n+            _ => r,\n+        }\n+    }\n+\n+    fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n+        &self.values[rid]\n+    }\n+\n+    fn value_mut(&mut self, rid: RegionVid) -> &mut VarValue<'tcx> {\n+        &mut self.values[rid]\n+    }\n+\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n+        let result = match self.values[rid] {\n+            VarValue::Value(r) => r,\n+            VarValue::ErrorValue => self.error_region,\n+        };\n+        debug!(\"resolve_var({:?}) = {:?}\", rid, result);\n+        result\n+    }\n+}"}, {"sha": "4a2a7a6bdfeca944388582197e2bd10f7ffed28e", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))\n+        Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "f734ff84f639eadb2cca80f29dc4dbc1c2346178", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 197, "deletions": 38, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -16,7 +16,6 @@ pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n-pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n@@ -31,7 +30,7 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -41,7 +40,9 @@ use arena::DroplessArena;\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n-use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n+use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n+use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -54,13 +55,17 @@ mod glb;\n mod higher_ranked;\n pub mod lattice;\n mod lub;\n-pub mod region_inference;\n+pub mod region_constraints;\n+mod lexical_region_resolve;\n+mod outlives;\n pub mod resolve;\n mod freshen;\n mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+pub use self::outlives::env::OutlivesEnvironment;\n+\n #[must_use]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n@@ -98,8 +103,15 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Map from floating variable to the kind of float it represents\n     float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n-    // For region variables.\n-    region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n+    // Tracks the set of region variables and the constraints between\n+    // them.  This is initially `Some(_)` but when\n+    // `resolve_regions_and_report_errors` is invoked, this gets set\n+    // to `None` -- further attempts to perform unification etc may\n+    // fail if new region constraints would've been added.\n+    region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n+\n+    // Once region inference is done, the values for each variable.\n+    lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n@@ -135,6 +147,39 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n+\n+    // A set of constraints that regionck must validate. Each\n+    // constraint has the form `T:'a`, meaning \"some type `T` must\n+    // outlive the lifetime 'a\". These constraints derive from\n+    // instantiated type parameters. So if you had a struct defined\n+    // like\n+    //\n+    //     struct Foo<T:'static> { ... }\n+    //\n+    // then in some expression `let x = Foo { ... }` it will\n+    // instantiate the type parameter `T` with a fresh type `$0`. At\n+    // the same time, it will record a region obligation of\n+    // `$0:'static`. This will get checked later by regionck. (We\n+    // can't generally check these things right away because we have\n+    // to wait until types are resolved.)\n+    //\n+    // These are stored in a map keyed to the id of the innermost\n+    // enclosing fn body / static initializer expression. This is\n+    // because the location where the obligation was incurred can be\n+    // relevant with respect to which sublifetime assumptions are in\n+    // place. The reason that we store under the fn-id, and not\n+    // something more fine-grained, is so that it is easier for\n+    // regionck to be sure that it has found *all* the region\n+    // obligations (otherwise, it's easy to fail to walk to a\n+    // particular node-id).\n+    //\n+    // Before running `resolve_regions_and_report_errors`, the creator\n+    // of the inference context is expected to invoke\n+    // `process_region_obligations` (defined in `self::region_obligations`)\n+    // for each body-id in this map, which will process the\n+    // obligations within. This is expected to be done 'late enough'\n+    // that all type inference variables have been bound and so forth.\n+    region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -248,10 +293,6 @@ pub enum SubregionOrigin<'tcx> {\n         item_name: ast::Name,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n-\n-        // this is `Some(_)` if this error arises from the bug fix for\n-        // #18937. This is a temporary measure.\n-        lint_id: Option<ast::NodeId>,\n     },\n }\n \n@@ -280,7 +321,7 @@ pub enum LateBoundRegionConversionTime {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting` module for more details\n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n@@ -308,6 +349,20 @@ pub enum RegionVariableOrigin {\n     UpvarRegion(ty::UpvarId, Span),\n \n     BoundRegionInCoherence(ast::Name),\n+\n+    // This origin is used for the inference variables that we create\n+    // during NLL region processing.\n+    NLL(NLLRegionVariableOrigin),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum NLLRegionVariableOrigin {\n+    // During NLL region processing, we create variables for free\n+    // regions that we encounter in the function signature and\n+    // elsewhere. This origin indices we've got one of those.\n+    FreeRegion,\n+\n+    Inferred(::mir::visit::TyContext),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -317,6 +372,14 @@ pub enum FixupError {\n     UnresolvedTy(TyVid)\n }\n \n+/// See the `region_obligations` field for more information.\n+#[derive(Clone)]\n+pub struct RegionObligation<'tcx> {\n+    pub sub_region: ty::Region<'tcx>,\n+    pub sup_type: Ty<'tcx>,\n+    pub cause: ObligationCause<'tcx>,\n+}\n+\n impl fmt::Display for FixupError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::FixupError::*;\n@@ -379,13 +442,15 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n-            region_vars: RegionVarBindings::new(tcx),\n+            region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+            lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FxHashMap()),\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n+            region_obligations: RefCell::new(vec![]),\n         }))\n     }\n }\n@@ -412,7 +477,8 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n-    region_vars_snapshot: RegionSnapshot,\n+    region_constraints_snapshot: RegionSnapshot,\n+    region_obligations_snapshot: usize,\n     was_in_snapshot: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n@@ -720,7 +786,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_vars_snapshot: self.region_vars.start_snapshot(),\n+            region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n+            region_obligations_snapshot: self.region_obligations.borrow().len(),\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n@@ -736,7 +803,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot,\n+                               region_constraints_snapshot,\n+                               region_obligations_snapshot,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n@@ -754,8 +822,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.float_unification_table\n             .borrow_mut()\n             .rollback_to(float_snapshot);\n-        self.region_vars\n-            .rollback_to(region_vars_snapshot);\n+        self.region_obligations\n+            .borrow_mut()\n+            .truncate(region_obligations_snapshot);\n+        self.borrow_region_constraints()\n+            .rollback_to(region_constraints_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot) {\n@@ -764,7 +835,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot,\n+                               region_constraints_snapshot,\n+                               region_obligations_snapshot: _,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n@@ -782,8 +854,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.float_unification_table\n             .borrow_mut()\n             .commit(float_snapshot);\n-        self.region_vars\n-            .commit(region_vars_snapshot);\n+        self.borrow_region_constraints()\n+            .commit(region_constraints_snapshot);\n     }\n \n     /// Execute `f` and commit the bindings\n@@ -838,7 +910,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      sub: ty::Region<'tcx>,\n                      sup: ty::RegionVid)\n     {\n-        self.region_vars.add_given(sub, sup);\n+        self.borrow_region_constraints().add_given(sub, sup);\n     }\n \n     pub fn can_sub<T>(&self,\n@@ -878,7 +950,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        a: ty::Region<'tcx>,\n                        b: ty::Region<'tcx>) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.region_vars.make_subregion(origin, a, b);\n+        self.borrow_region_constraints().make_subregion(origin, a, b);\n     }\n \n     pub fn equality_predicate(&self,\n@@ -979,9 +1051,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .new_key(None)\n     }\n \n+    /// Create a fresh region variable with the next available index.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`: information about why we created this variable, for use\n+    ///   during diagnostics / error-reporting.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n                            -> ty::Region<'tcx> {\n-        self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n+        self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n+    }\n+\n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n+                               -> ty::Region<'tcx> {\n+        self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n     /// Create a region inference variable for the given\n@@ -1040,10 +1124,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region<'tcx> {\n-        self.region_vars.new_bound(debruijn)\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n@@ -1069,15 +1149,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tainted_by_errors_flag.set(true)\n     }\n \n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_type_vars_if_possible` as well as `fully_resolve`.\n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n                                              region_map: &region::ScopeTree,\n                                              free_regions: &FreeRegionMap<'tcx>) {\n-        let region_rels = RegionRelations::new(self.tcx,\n-                                               region_context,\n-                                               region_map,\n-                                               free_regions);\n-        let errors = self.region_vars.resolve_regions(&region_rels);\n+        assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                self.region_obligations.borrow());\n+\n+        let region_rels = &RegionRelations::new(self.tcx,\n+                                                region_context,\n+                                                region_map,\n+                                                free_regions);\n+        let (var_origins, data) = self.region_constraints.borrow_mut()\n+                                                         .take()\n+                                                         .expect(\"regions already resolved\")\n+                                                         .into_origins_and_data();\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(region_rels, var_origins, data);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n \n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n@@ -1089,6 +1185,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Obtains (and clears) the current set of region\n+    /// constraints. The inference context is still usable: further\n+    /// unifications will simply add new constraints.\n+    ///\n+    /// This method is not meant to be used with normal lexical region\n+    /// resolution. Rather, it is used in the NLL mode as a kind of\n+    /// interim hack: basically we run normal type-check and generate\n+    /// region constraints as normal, but then we take them and\n+    /// translate them into the form that the NLL solver\n+    /// understands. See the NLL module for mode details.\n+    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        self.borrow_region_constraints().take_and_reset_data()\n+    }\n+\n+    /// Takes ownership of the list of variable regions. This implies\n+    /// that all the region constriants have already been taken, and\n+    /// hence that `resolve_regions_and_report_errors` can never be\n+    /// called. This is used only during NLL processing to \"hand off\" ownership\n+    /// of the set of region vairables into the NLL region context.\n+    pub fn take_region_var_origins(&self) -> VarOrigins {\n+        let (var_origins, data) = self.region_constraints.borrow_mut()\n+                                                         .take()\n+                                                         .expect(\"regions already resolved\")\n+                                                         .into_origins_and_data();\n+        assert!(data.is_empty());\n+        var_origins\n+    }\n+\n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         self.resolve_type_vars_if_possible(&t).to_string()\n     }\n@@ -1301,7 +1425,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n \n-    /// See `verify_generic_bound` method in `region_inference`\n+    /// See `verify_generic_bound` method in `region_constraints`\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n@@ -1312,7 +1436,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                a,\n                bound);\n \n-        self.region_vars.verify_generic_bound(origin, kind, a, bound);\n+        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn type_moves_by_default(&self,\n@@ -1389,6 +1513,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.generator_sig(def_id)\n     }\n+\n+    /// Normalizes associated types in `value`, potentially returning\n+    /// new obligations that must further be processed.\n+    pub fn partially_normalize_associated_types_in<T>(&self,\n+                                                      span: Span,\n+                                                      body_id: ast::NodeId,\n+                                                      param_env: ty::ParamEnv<'tcx>,\n+                                                      value: &T)\n+                                                      -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, value);\n+        debug!(\"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value,\n+            obligations);\n+        InferOk { value, obligations }\n+    }\n+\n+    fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n+        RefMut::map(\n+            self.region_constraints.borrow_mut(),\n+            |c| c.as_mut().expect(\"region constraints already solved\"))\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n@@ -1466,14 +1617,12 @@ impl<'tcx> SubregionOrigin<'tcx> {\n \n             traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n                                                                        impl_item_def_id,\n-                                                                       trait_item_def_id,\n-                                                                       lint_id } =>\n+                                                                       trait_item_def_id, } =>\n                 SubregionOrigin::CompareImplMethodObligation {\n                     span: cause.span,\n                     item_name,\n                     impl_item_def_id,\n                     trait_item_def_id,\n-                    lint_id,\n                 },\n \n             _ => default(),\n@@ -1492,7 +1641,8 @@ impl RegionVariableOrigin {\n             EarlyBoundRegion(a, ..) => a,\n             LateBoundRegion(a, ..) => a,\n             BoundRegionInCoherence(_) => syntax_pos::DUMMY_SP,\n-            UpvarRegion(_, a) => a\n+            UpvarRegion(_, a) => a,\n+            NLL(..) => bug!(\"NLL variable used with `span`\"),\n         }\n     }\n }\n@@ -1533,3 +1683,12 @@ impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n         self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n+    }\n+}\n+"}, {"sha": "2099e923e0959fb23788649c4b63a10f1f014a35", "filename": "src/librustc/infer/outlives/env.rs", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,355 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::free_region::FreeRegionMap;\n+use infer::{InferCtxt, GenericKind};\n+use traits::FulfillmentContext;\n+use ty::{self, Ty, TypeFoldable};\n+use ty::outlives::Component;\n+use ty::wf;\n+\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+/// The `OutlivesEnvironment` collects information about what outlives\n+/// what in a given type-checking setting. For example, if we have a\n+/// where-clause like `where T: 'a` in scope, then the\n+/// `OutlivesEnvironment` would record that (in its\n+/// `region_bound_pairs` field). Similarly, it contains methods for\n+/// processing and adding implied bounds into the outlives\n+/// environment.\n+///\n+/// Other code at present does not typically take a\n+/// `&OutlivesEnvironment`, but rather takes some of its fields (e.g.,\n+/// `process_registered_region_obligations` wants the\n+/// region-bound-pairs). There is no mistaking it: the current setup\n+/// of tracking region information is quite scattered! The\n+/// `OutlivesEnvironment`, for example, needs to sometimes be combined\n+/// with the `middle::RegionRelations`, to yield a full picture of how\n+/// (lexical) lifetimes interact. However, I'm reluctant to do more\n+/// refactoring here, since the setup with NLL is quite different.\n+/// For example, NLL has no need of `RegionRelations`, and is solely\n+/// interested in the `OutlivesEnvironment`. -nmatsakis\n+#[derive(Clone)]\n+pub struct OutlivesEnvironment<'tcx> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    free_region_map: FreeRegionMap<'tcx>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+}\n+\n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n+    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n+        let mut free_region_map = FreeRegionMap::new();\n+        free_region_map.relate_free_regions_from_predicates(&param_env.caller_bounds);\n+\n+        OutlivesEnvironment {\n+            param_env,\n+            free_region_map,\n+            region_bound_pairs: vec![],\n+        }\n+    }\n+\n+    /// Borrows current value of the `free_region_map`.\n+    pub fn free_region_map(&self) -> &FreeRegionMap<'tcx> {\n+        &self.free_region_map\n+    }\n+\n+    /// Borrows current value of the `region_bound_pairs`.\n+    pub fn region_bound_pairs(&self) -> &[(ty::Region<'tcx>, GenericKind<'tcx>)] {\n+        &self.region_bound_pairs\n+    }\n+\n+    /// Returns ownership of the `free_region_map`.\n+    pub fn into_free_region_map(self) -> FreeRegionMap<'tcx> {\n+        self.free_region_map\n+    }\n+\n+    /// This is a hack to support the old-skool regionck, which\n+    /// processes region constraints from the main function and the\n+    /// closure together. In that context, when we enter a closure, we\n+    /// want to be able to \"save\" the state of the surrounding a\n+    /// function. We can then add implied bounds and the like from the\n+    /// closure arguments into the environment -- these should only\n+    /// apply in the closure body, so once we exit, we invoke\n+    /// `pop_snapshot_post_closure` to remove them.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// fn foo<T>() {\n+    ///    callback(for<'a> |x: &'a T| {\n+    ///         // ^^^^^^^ not legal syntax, but probably should be\n+    ///         // within this closure body, `T: 'a` holds\n+    ///    })\n+    /// }\n+    /// ```\n+    ///\n+    /// This \"containment\" of closure's effects only works so well. In\n+    /// particular, we (intentionally) leak relationships between free\n+    /// regions that are created by the closure's bounds. The case\n+    /// where this is useful is when you have (e.g.) a closure with a\n+    /// signature like `for<'a, 'b> fn(x: &'a &'b u32)` -- in this\n+    /// case, we want to keep the relationship `'b: 'a` in the\n+    /// free-region-map, so that later if we have to take `LUB('b,\n+    /// 'a)` we can get the result `'b`.\n+    ///\n+    /// I have opted to keep **all modifications** to the\n+    /// free-region-map, however, and not just those that concern free\n+    /// variables bound in the closure. The latter seems more correct,\n+    /// but it is not the existing behavior, and I could not find a\n+    /// case where the existing behavior went wrong. In any case, it\n+    /// seems like it'd be readily fixed if we wanted. There are\n+    /// similar leaks around givens that seem equally suspicious, to\n+    /// be honest. --nmatsakis\n+    pub fn push_snapshot_pre_closure(&self) -> usize {\n+        self.region_bound_pairs.len()\n+    }\n+\n+    /// See `push_snapshot_pre_closure`.\n+    pub fn pop_snapshot_post_closure(&mut self, len: usize) {\n+        self.region_bound_pairs.truncate(len);\n+    }\n+\n+    /// This method adds \"implied bounds\" into the outlives environment.\n+    /// Implied bounds are outlives relationships that we can deduce\n+    /// on the basis that certain types must be well-formed -- these are\n+    /// either the types that appear in the function signature or else\n+    /// the input types to an impl. For example, if you have a function\n+    /// like\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n+    /// ```\n+    ///\n+    /// we can assume in the caller's body that `'b: 'a` and that `T:\n+    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n+    /// add those assumptions into the outlives-environment.\n+    ///\n+    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+    pub fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: ast::NodeId,\n+        span: Span,\n+    ) {\n+        debug!(\"add_implied_bounds()\");\n+\n+        for &ty in fn_sig_tys {\n+            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            debug!(\"add_implied_bounds: ty = {}\", ty);\n+            let implied_bounds = self.implied_bounds(infcx, body_id, ty, span);\n+\n+            // But also record other relationships, such as `T:'x`,\n+            // that don't go into the free-region-map but which we use\n+            // here.\n+            for implication in implied_bounds {\n+                debug!(\"add_implied_bounds: implication={:?}\", implication);\n+                match implication {\n+                    ImpliedBound::RegionSubRegion(\n+                        r_a @ &ty::ReEarlyBound(_),\n+                        &ty::ReVar(vid_b),\n+                    ) |\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                        infcx.add_given(r_a, vid_b);\n+                    }\n+                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n+                        self.region_bound_pairs\n+                            .push((r_a, GenericKind::Param(param_b)));\n+                    }\n+                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n+                        self.region_bound_pairs\n+                            .push((r_a, GenericKind::Projection(projection_b)));\n+                    }\n+                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n+                        // In principle, we could record (and take\n+                        // advantage of) every relationship here, but\n+                        // we are also free not to -- it simply means\n+                        // strictly less that we can successfully type\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        self.free_region_map.relate_regions(r_a, r_b);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Compute the implied bounds that a callee/impl can assume based on\n+    /// the fact that caller/projector has ensured that `ty` is WF.  See\n+    /// the `ImpliedBound` type for more details.\n+    fn implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        let tcx = infcx.tcx;\n+\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        let mut fulfill_cx = FulfillmentContext::new();\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations =\n+                wf::obligations(infcx, self.param_env, body_id, ty, span).unwrap_or(vec![]);\n+\n+            // NB: All of these predicates *ought* to be easily proven\n+            // true. In fact, their correctness is (mostly) implied by\n+            // other parts of the program. However, in #42552, we had\n+            // an annoying scenario where:\n+            //\n+            // - Some `T::Foo` gets normalized, resulting in a\n+            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+            //   (not sure why it couldn't immediately get\n+            //   solved). This result of `_1` got cached.\n+            // - These obligations were dropped on the floor here,\n+            //   rather than being registered.\n+            // - Then later we would get a request to normalize\n+            //   `T::Foo` which would result in `_1` being used from\n+            //   the cache, but hence without the `T: Trait<Foo=_1>`\n+            //   constraint. As a result, `_1` never gets resolved,\n+            //   and we get an ICE (in dropck).\n+            //\n+            // Therefore, we register any predicates involving\n+            // inference variables. We restrict ourselves to those\n+            // involving inference variables both for efficiency and\n+            // to avoids duplicate errors that otherwise show up.\n+            fulfill_cx.register_predicate_obligations(\n+                infcx,\n+                obligations\n+                    .iter()\n+                    .filter(|o| o.predicate.has_infer_types())\n+                    .cloned());\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n+                            }\n+                        }\n+                    }\n+\n+                    ty::Predicate::TypeOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                                let components = tcx.outlives_components(ty_a);\n+                                self.implied_bounds_from_components(r_b, components)\n+                            }\n+                        }\n+                    }\n+                }\n+            }));\n+        }\n+\n+        // Ensure that those obligations that we had to solve\n+        // get solved *here*.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => (),\n+            Err(errors) => infcx.report_fulfillment_errors(&errors, None),\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(\n+        &self,\n+        sub_region: ty::Region<'tcx>,\n+        sup_components: Vec<Component<'tcx>>,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "0976c5f1f2fc48339973e5bfb4d0c709b9787de1", "filename": "src/librustc/infer/outlives/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod env;\n+mod obligations;"}, {"sha": "c7081e59ec36f5b3559bc28f0e6fc07735ec042f", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,623 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code that handles \"type-outlives\" constraints like `T: 'a`. This\n+//! is based on the `outlives_components` function defined on the tcx,\n+//! but it adds a bit of heuristics on top, in particular to deal with\n+//! associated types and projections.\n+//!\n+//! When we process a given `T: 'a` obligation, we may produce two\n+//! kinds of constraints for the region inferencer:\n+//!\n+//! - Relationships between inference variables and other regions.\n+//!   For example, if we have `&'?0 u32: 'a`, then we would produce\n+//!   a constraint that `'a <= '?0`.\n+//! - \"Verifys\" that must be checked after inferencing is done.\n+//!   For example, if we know that, for some type parameter `T`,\n+//!   `T: 'a + 'b`, and we have a requirement that `T: '?1`,\n+//!   then we add a \"verify\" that checks that `'?1 <= 'a || '?1 <= 'b`.\n+//!   - Note the difference with the previous case: here, the region\n+//!     variable must be less than something else, so this doesn't\n+//!     affect how inference works (it finds the smallest region that\n+//!     will do); it's just a post-condition that we have to check.\n+//!\n+//! **The key point is that once this function is done, we have\n+//! reduced all of our \"type-region outlives\" obligations into relationships\n+//! between individual regions.**\n+//!\n+//! One key input to this function is the set of \"region-bound pairs\".\n+//! These are basically the relationships between type parameters and\n+//! regions that are in scope at the point where the outlives\n+//! obligation was incurred. **When type-checking a function,\n+//! particularly in the face of closures, this is not known until\n+//! regionck runs!** This is because some of those bounds come\n+//! from things we have yet to infer.\n+//!\n+//! Consider:\n+//!\n+//! ```\n+//! fn bar<T>(a: T, b: impl for<'a> Fn(&'a T));\n+//! fn foo<T>(x: T) {\n+//!     bar(x, |y| { ... })\n+//!          // ^ closure arg\n+//! }\n+//! ```\n+//!\n+//! Here, the type of `y` may involve inference variables and the\n+//! like, and it may also contain implied bounds that are needed to\n+//! type-check the closure body (e.g., here it informs us that `T`\n+//! outlives the late-bound region `'a`).\n+//!\n+//! Note that by delaying the gathering of implied bounds until all\n+//! inference information is known, we may find relationships between\n+//! bound regions and other regions in the environment. For example,\n+//! when we first check a closure like the one expected as argument\n+//! to `foo`:\n+//!\n+//! ```\n+//! fn foo<U, F: for<'a> FnMut(&'a U)>(_f: F) {}\n+//! ```\n+//!\n+//! the type of the closure's first argument would be `&'a ?U`.  We\n+//! might later infer `?U` to something like `&'b u32`, which would\n+//! imply that `'b: 'a`.\n+\n+use hir::def_id::DefId;\n+use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use traits;\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::subst::{Subst, Substs};\n+use ty::outlives::Component;\n+use syntax::ast;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Registers that the given region obligation must be resolved\n+    /// from within the scope of `body_id`. These regions are enqueued\n+    /// and later processed by regionck, when full type information is\n+    /// available (see `region_obligations` field for more\n+    /// information).\n+    pub fn register_region_obligation(\n+        &self,\n+        body_id: ast::NodeId,\n+        obligation: RegionObligation<'tcx>,\n+    ) {\n+        self.region_obligations\n+            .borrow_mut()\n+            .push((body_id, obligation));\n+    }\n+\n+    /// Process the region obligations that must be proven (during\n+    /// `regionck`) for the given `body_id`, given information about\n+    /// the region bounds in scope and so forth. This function must be\n+    /// invoked for all relevant body-ids before region inference is\n+    /// done (or else an assert will fire).\n+    ///\n+    /// See the `region_obligations` field of `InferCtxt` for some\n+    /// comments about how this funtion fits into the overall expected\n+    /// flow of the the inferencer. The key point is that it is\n+    /// invoked after all type-inference variables have been bound --\n+    /// towards the end of regionck. This also ensures that the\n+    /// region-bound-pairs are available (see comments above regarding\n+    /// closures).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `region_bound_pairs`: the set of region bounds implied by\n+    ///   the parameters and where-clauses. In particular, each pair\n+    ///   `('a, K)` in this list tells us that the bounds in scope\n+    ///   indicate that `K: 'a`, where `K` is either a generic\n+    ///   parameter like `T` or a projection like `T::Item`.\n+    /// - `implicit_region_bound`: if some, this is a region bound\n+    ///   that is considered to hold for all type parameters (the\n+    ///   function body).\n+    /// - `param_env` is the parameter environment for the enclosing function.\n+    /// - `body_id` is the body-id whose region obligations are being\n+    ///   processed.\n+    ///\n+    /// # Returns\n+    ///\n+    /// This function may have to perform normalizations, and hence it\n+    /// returns an `InferOk` with subobligations that must be\n+    /// processed.\n+    pub fn process_registered_region_obligations(\n+        &self,\n+        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+    ) {\n+        assert!(\n+            !self.in_snapshot.get(),\n+            \"cannot process registered region obligations in a snapshot\"\n+        );\n+\n+        // pull out the region obligations with the given `body_id` (leaving the rest)\n+        let mut my_region_obligations = Vec::with_capacity(self.region_obligations.borrow().len());\n+        {\n+            let mut r_o = self.region_obligations.borrow_mut();\n+            for (_, obligation) in r_o.drain_filter(|(ro_body_id, _)| *ro_body_id == body_id) {\n+                my_region_obligations.push(obligation);\n+            }\n+        }\n+\n+        let outlives =\n+            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+\n+        for RegionObligation {\n+            sup_type,\n+            sub_region,\n+            cause,\n+        } in my_region_obligations\n+        {\n+            let origin = SubregionOrigin::from_obligation_cause(\n+                &cause,\n+                || infer::RelateParamBound(cause.span, sup_type),\n+            );\n+\n+            outlives.type_must_outlive(origin, sup_type, sub_region);\n+        }\n+    }\n+\n+    /// Processes a single ad-hoc region obligation that was not\n+    /// registered in advance.\n+    pub fn type_must_outlive(\n+        &self,\n+        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        let outlives =\n+            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+        outlives.type_must_outlive(origin, ty, region);\n+    }\n+\n+    /// Ignore the region obligations, not bothering to prove\n+    /// them. This function should not really exist; it is used to\n+    /// accommodate some older code for the time being.\n+    pub fn ignore_region_obligations(&self) {\n+        assert!(\n+            !self.in_snapshot.get(),\n+            \"cannot ignore registered region obligations in a snapshot\"\n+        );\n+\n+        self.region_obligations.borrow_mut().clear();\n+    }\n+}\n+\n+#[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)\n+struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    // See the comments on `process_registered_region_obligations` for the meaning\n+    // of these fields.\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        }\n+    }\n+\n+    /// Adds constraints to inference such that `T: 'a` holds (or\n+    /// reports an error if it cannot).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`, the reason we need this constraint\n+    /// - `ty`, the type `T`\n+    /// - `region`, the region `'a`\n+    fn type_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+\n+        debug!(\n+            \"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n+            ty,\n+            region,\n+            origin\n+        );\n+\n+        assert!(!ty.has_escaping_regions());\n+\n+        let components = self.tcx().outlives_components(ty);\n+        self.components_must_outlive(origin, components, region);\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn components_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        components: Vec<Component<'tcx>>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        for component in components {\n+            let origin = origin.clone();\n+            match component {\n+                Component::Region(region1) => {\n+                    self.infcx.sub_regions(origin, region, region1);\n+                }\n+                Component::Param(param_ty) => {\n+                    self.param_ty_must_outlive(origin, region, param_ty);\n+                }\n+                Component::Projection(projection_ty) => {\n+                    self.projection_must_outlive(origin, region, projection_ty);\n+                }\n+                Component::EscapingProjection(subcomponents) => {\n+                    self.components_must_outlive(origin, subcomponents, region);\n+                }\n+                Component::UnresolvedInferenceVariable(v) => {\n+                    // ignore this, we presume it will yield an error\n+                    // later, since if a type variable is not resolved by\n+                    // this point it never will be\n+                    self.infcx.tcx.sess.delay_span_bug(\n+                        origin.span(),\n+                        &format!(\"unresolved inference variable in outlives: {:?}\", v),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn param_ty_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        param_ty: ty::ParamTy,\n+    ) {\n+        debug!(\n+            \"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n+            region,\n+            param_ty,\n+            origin\n+        );\n+\n+        let verify_bound = self.param_bound(param_ty);\n+        let generic = GenericKind::Param(param_ty);\n+        self.infcx\n+            .verify_generic_bound(origin, generic, region, verify_bound);\n+    }\n+\n+    fn projection_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) {\n+        debug!(\n+            \"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n+            region,\n+            projection_ty,\n+            origin\n+        );\n+\n+        // This case is thorny for inference. The fundamental problem is\n+        // that there are many cases where we have choice, and inference\n+        // doesn't like choice (the current region inference in\n+        // particular). :) First off, we have to choose between using the\n+        // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n+        // OutlivesProjectionComponent rules, any one of which is\n+        // sufficient.  If there are no inference variables involved, it's\n+        // not hard to pick the right rule, but if there are, we're in a\n+        // bit of a catch 22: if we picked which rule we were going to\n+        // use, we could add constraints to the region inference graph\n+        // that make it apply, but if we don't add those constraints, the\n+        // rule might not apply (but another rule might). For now, we err\n+        // on the side of adding too few edges into the graph.\n+\n+        // Compute the bounds we can derive from the environment or trait\n+        // definition.  We know that the projection outlives all the\n+        // regions in this list.\n+        let env_bounds = self.projection_declared_bounds(projection_ty);\n+\n+        debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n+\n+        // If we know that the projection outlives 'static, then we're\n+        // done here.\n+        if env_bounds.contains(&&ty::ReStatic) {\n+            debug!(\"projection_must_outlive: 'static as declared bound\");\n+            return;\n+        }\n+\n+        // If declared bounds list is empty, the only applicable rule is\n+        // OutlivesProjectionComponent. If there are inference variables,\n+        // then, we can break down the outlives into more primitive\n+        // components without adding unnecessary edges.\n+        //\n+        // If there are *no* inference variables, however, we COULD do\n+        // this, but we choose not to, because the error messages are less\n+        // good. For example, a requirement like `T::Item: 'r` would be\n+        // translated to a requirement that `T: 'r`; when this is reported\n+        // to the user, it will thus say \"T: 'r must hold so that T::Item:\n+        // 'r holds\". But that makes it sound like the only way to fix\n+        // the problem is to add `T: 'r`, which isn't true. So, if there are no\n+        // inference variables, we use a verify constraint instead of adding\n+        // edges, which winds up enforcing the same condition.\n+        let needs_infer = projection_ty.needs_infer();\n+        if env_bounds.is_empty() && needs_infer {\n+            debug!(\"projection_must_outlive: no declared bounds\");\n+\n+            for component_ty in projection_ty.substs.types() {\n+                self.type_must_outlive(origin.clone(), component_ty, region);\n+            }\n+\n+            for r in projection_ty.substs.regions() {\n+                self.infcx.sub_regions(origin.clone(), region, r);\n+            }\n+\n+            return;\n+        }\n+\n+        // If we find that there is a unique declared bound `'b`, and this bound\n+        // appears in the trait reference, then the best action is to require that `'b:'r`,\n+        // so do that. This is best no matter what rule we use:\n+        //\n+        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n+        // the requirement that `'b:'r`\n+        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n+        // other conditions\n+        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n+            let unique_bound = env_bounds[0];\n+            debug!(\n+                \"projection_must_outlive: unique declared bound = {:?}\",\n+                unique_bound\n+            );\n+            if projection_ty\n+                .substs\n+                .regions()\n+                .any(|r| env_bounds.contains(&r))\n+            {\n+                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+                self.infcx.sub_regions(origin.clone(), region, unique_bound);\n+                return;\n+            }\n+        }\n+\n+        // Fallback to verifying after the fact that there exists a\n+        // declared bound, or that all the components appearing in the\n+        // projection outlive; in some cases, this may add insufficient\n+        // edges into the inference graph, leading to inference failures\n+        // even though a satisfactory solution exists.\n+        let verify_bound = self.projection_bound(env_bounds, projection_ty);\n+        let generic = GenericKind::Projection(projection_ty);\n+        self.infcx\n+            .verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+    }\n+\n+    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        match ty.sty {\n+            ty::TyParam(p) => self.param_bound(p),\n+            ty::TyProjection(data) => {\n+                let declared_bounds = self.projection_declared_bounds(data);\n+                self.projection_bound(declared_bounds, data)\n+            }\n+            _ => self.recursive_type_bound(ty),\n+        }\n+    }\n+\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+        debug!(\"param_bound(param_ty={:?})\", param_ty);\n+\n+        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n+\n+        // Add in the default bound of fn body that applies to all in\n+        // scope type parameters:\n+        param_bounds.extend(self.implicit_region_bound);\n+\n+        VerifyBound::AnyRegion(param_bounds)\n+    }\n+\n+    fn projection_declared_bounds(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        // First assemble bounds from where clauses and traits.\n+\n+        let mut declared_bounds =\n+            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n+\n+        declared_bounds\n+            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n+\n+        declared_bounds\n+    }\n+\n+    fn projection_bound(\n+        &self,\n+        declared_bounds: Vec<ty::Region<'tcx>>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> VerifyBound<'tcx> {\n+        debug!(\n+            \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n+            declared_bounds,\n+            projection_ty\n+        );\n+\n+        // see the extensive comment in projection_must_outlive\n+        let ty = self.infcx\n+            .tcx\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let recursive_bound = self.recursive_type_bound(ty);\n+\n+        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+    }\n+\n+    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = vec![];\n+\n+        for subty in ty.walk_shallow() {\n+            bounds.push(self.type_bound(subty));\n+        }\n+\n+        let mut regions = ty.regions();\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n+        bounds.push(VerifyBound::AllRegions(regions));\n+\n+        // remove bounds that must hold, since they are not interesting\n+        bounds.retain(|b| !b.must_hold());\n+\n+        if bounds.len() == 1 {\n+            bounds.pop().unwrap()\n+        } else {\n+            VerifyBound::AllBounds(bounds)\n+        }\n+    }\n+\n+    fn declared_generic_bounds_from_env(\n+        &self,\n+        generic: GenericKind<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // To start, collect bounds from user environment. Note that\n+        // parameter environments are already elaborated, so we don't\n+        // have to worry about that. Comparing using `==` is a bit\n+        // dubious for projections, but it will work for simple cases\n+        // like `T` and `T::Item`. It may not work as well for things\n+        // like `<T as Foo<'a>>::Item`.\n+        let generic_ty = generic.to_ty(tcx);\n+        let c_b = self.param_env.caller_bounds;\n+        let mut param_bounds = self.collect_outlives_from_predicate_list(generic_ty, c_b);\n+\n+        // Next, collect regions we scraped from the well-formedness\n+        // constraints in the fn signature. To do that, we walk the list\n+        // of known relations from the fn ctxt.\n+        //\n+        // This is crucial because otherwise code like this fails:\n+        //\n+        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+        //\n+        // The problem is that the type of `x` is `&'a A`. To be\n+        // well-formed, then, A must be lower-generic by `'a`, but we\n+        // don't know that this holds from first principles.\n+        for &(r, p) in self.region_bound_pairs {\n+            debug!(\"generic={:?} p={:?}\", generic, p);\n+            if generic == p {\n+                param_bounds.push(r);\n+            }\n+        }\n+\n+        param_bounds\n+    }\n+\n+    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n+    /// declared in the trait definition. For example, if the trait were\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// then this function would return `'x`. This is subject to the\n+    /// limitations around higher-ranked bounds described in\n+    /// `region_bounds_declared_on_associated_item`.\n+    fn declared_projection_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n+        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n+        for r in &mut bounds {\n+            *r = r.subst(self.tcx(), projection_ty.substs);\n+        }\n+        bounds\n+    }\n+\n+    /// Given the def-id of an associated item, returns any region\n+    /// bounds attached to that associated item from the trait definition.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// `'a`. You could then apply the substitutions from the\n+    /// projection to convert this into your namespace. This also\n+    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n+    /// the trait. In fact, it works by searching for just such a\n+    /// where-clause.\n+    ///\n+    /// It will not, however, work for higher-ranked bounds like:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a, 'b>\n+    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n+    /// {\n+    ///     type Bar;\n+    /// }\n+    /// ```\n+    ///\n+    /// This is for simplicity, and because we are not really smart\n+    /// enough to cope with such bounds anywhere.\n+    fn region_bounds_declared_on_associated_item(\n+        &self,\n+        assoc_item_def_id: DefId,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx();\n+        let assoc_item = tcx.associated_item(assoc_item_def_id);\n+        let trait_def_id = assoc_item.container.assert_trait();\n+        let trait_predicates = tcx.predicates_of(trait_def_id);\n+        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n+        self.collect_outlives_from_predicate_list(\n+            identity_proj,\n+            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n+        )\n+    }\n+\n+    /// Searches through a predicate list for a predicate `T: 'a`.\n+    ///\n+    /// Careful: does not elaborate predicates, and just uses `==`\n+    /// when comparing `ty` for equality, so `ty` must be something\n+    /// that does not involve inference variables and where you\n+    /// otherwise want a precise match.\n+    fn collect_outlives_from_predicate_list<I, P>(\n+        &self,\n+        ty: Ty<'tcx>,\n+        predicates: I,\n+    ) -> Vec<ty::Region<'tcx>>\n+    where\n+        I: IntoIterator<Item = P>,\n+        P: AsRef<ty::Predicate<'tcx>>,\n+    {\n+        predicates\n+            .into_iter()\n+            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| self.tcx().no_late_bound_regions(&p))\n+            .filter(|p| p.0 == ty)\n+            .map(|p| p.1)\n+            .collect()\n+    }\n+}"}, {"sha": "67ad08c753033554a18327bf3062001250ae5612", "filename": "src/librustc/infer/region_constraints/README.md", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,70 @@\n+# Region constraint collection\n+\n+## Terminology\n+\n+Note that we use the terms region and lifetime interchangeably.\n+\n+## Introduction\n+\n+As described in the [inference README](../README.md), and unlike\n+normal type inference, which is similar in spirit to H-M and thus\n+works progressively, the region type inference works by accumulating\n+constraints over the course of a function.  Finally, at the end of\n+processing a function, we process and solve the constraints all at\n+once.\n+\n+The constraints are always of one of three possible forms:\n+\n+- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n+  a subregion of Rj\n+- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n+  must not be a variable) must be a subregion of the variable Ri\n+- `ConstrainVarSubReg(Ri, R)` states the variable Ri shoudl be less\n+  than the concrete region R. This is kind of deprecated and ought to\n+  be replaced with a verify (they essentially play the same role).\n+\n+In addition to constraints, we also gather up a set of \"verifys\"\n+(what, you don't think Verify is a noun? Get used to it my\n+friend!). These represent relations that must hold but which don't\n+influence inference proper. These take the form of:\n+\n+- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n+  where Rj is not an inference variable (and Ri may or may not contain\n+  one). This doesn't influence inference because we will already have\n+  inferred Ri to be as small as possible, so then we just test whether\n+  that result was less than Rj or not.\n+- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n+  that the region R must satisfy the bound `Vb`. The bounds themselves\n+  may have structure like \"must outlive one of the following regions\"\n+  or \"must outlive ALL of the following regions. These bounds arise\n+  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n+  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n+  'a` *or* `'c: 'a`.\n+\n+## Building up the constraints\n+\n+Variables and constraints are created using the following methods:\n+\n+- `new_region_var()` creates a new, unconstrained region variable;\n+- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n+- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n+  the smallest region that is greater than both Ri and Rj\n+- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n+  the greatest region that is smaller than both Ri and Rj\n+\n+The actual region resolution algorithm is not entirely\n+obvious, though it is also not overly complex.\n+\n+## Snapshotting\n+\n+It is also permitted to try (and rollback) changes to the graph.  This\n+is done by invoking `start_snapshot()`, which returns a value.  Then\n+later you can call `rollback_to()` which undoes the work.\n+Alternatively, you can call `commit()` which ends all snapshots.\n+Snapshots can be recursive---so you can start a snapshot when another\n+is in progress, but only the root snapshot can \"commit\".\n+\n+## Skolemization\n+\n+For a discussion on skolemization and higher-ranked subtyping, please\n+see the module `middle::infer::higher_ranked::doc`."}, {"sha": "096037ebe880cae5a08fd106b71b372d278befd6", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,956 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See README.md\n+\n+use self::UndoLogEntry::*;\n+use self::CombineMapType::*;\n+\n+use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n+use super::unify_key;\n+\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::unify::{self, UnificationTable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::{Region, RegionVid};\n+use ty::ReStatic;\n+use ty::{BrFresh, ReLateBound, ReSkolemized, ReVar};\n+\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use std::mem;\n+use std::u32;\n+\n+mod taint;\n+\n+pub struct RegionConstraintCollector<'tcx> {\n+    /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n+    var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n+\n+    data: RegionConstraintData<'tcx>,\n+\n+    /// For a given pair of regions (R1, R2), maps to a region R3 that\n+    /// is designated as their LUB (edges R1 <= R3 and R2 <= R3\n+    /// exist). This prevents us from making many such regions.\n+    lubs: CombineMap<'tcx>,\n+\n+    /// For a given pair of regions (R1, R2), maps to a region R3 that\n+    /// is designated as their GLB (edges R3 <= R1 and R3 <= R2\n+    /// exist). This prevents us from making many such regions.\n+    glbs: CombineMap<'tcx>,\n+\n+    /// Number of skolemized variables currently active.\n+    skolemization_count: u32,\n+\n+    /// Global counter used during the GLB algorithm to create unique\n+    /// names for fresh bound regions\n+    bound_count: u32,\n+\n+    /// The undo log records actions that might later be undone.\n+    ///\n+    /// Note: when the undo_log is empty, we are not actively\n+    /// snapshotting. When the `start_snapshot()` method is called, we\n+    /// push an OpenSnapshot entry onto the list to indicate that we\n+    /// are now actively snapshotting. The reason for this is that\n+    /// otherwise we end up adding entries for things like the lower\n+    /// bound on a variable and so forth, which can never be rolled\n+    /// back.\n+    undo_log: Vec<UndoLogEntry<'tcx>>,\n+\n+    /// When we add a R1 == R2 constriant, we currently add (a) edges\n+    /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n+    /// table. You can then call `opportunistic_resolve_var` early\n+    /// which will map R1 and R2 to some common region (i.e., either\n+    /// R1 or R2). This is important when dropck and other such code\n+    /// is iterating to a fixed point, because otherwise we sometimes\n+    /// would wind up with a fresh stream of region variables that\n+    /// have been equated but appear distinct.\n+    unification_table: UnificationTable<ty::RegionVid>,\n+}\n+\n+pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n+\n+/// The full set of region constraints gathered up by the collector.\n+/// Describes constraints between the region variables and other\n+/// regions, as well as other conditions that must be verified, or\n+/// assumptions that can be made.\n+#[derive(Default)]\n+pub struct RegionConstraintData<'tcx> {\n+    /// Constraints of the form `A <= B`, where either `A` or `B` can\n+    /// be a region variable (or neither, as it happens).\n+    pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n+\n+    /// A \"verify\" is something that we need to verify after inference\n+    /// is done, but which does not directly affect inference in any\n+    /// way.\n+    ///\n+    /// An example is a `A <= B` where neither `A` nor `B` are\n+    /// inference variables.\n+    pub verifys: Vec<Verify<'tcx>>,\n+\n+    /// A \"given\" is a relationship that is known to hold. In\n+    /// particular, we often know from closure fn signatures that a\n+    /// particular free region must be a subregion of a region\n+    /// variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically\n+    /// we record the fact that `'a <= 'b` is implied by the fn\n+    /// signature, and then ignore the constraint when solving\n+    /// equations. This is a bit of a hack but seems to work.\n+    pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n+}\n+\n+/// A constraint that influences the inference process.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+pub enum Constraint<'tcx> {\n+    /// One region variable is subregion of another\n+    VarSubVar(RegionVid, RegionVid),\n+\n+    /// Concrete region is subregion of region variable\n+    RegSubVar(Region<'tcx>, RegionVid),\n+\n+    /// Region variable is subregion of concrete region. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n+    VarSubReg(RegionVid, Region<'tcx>),\n+\n+    /// A constraint where neither side is a variable. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n+    RegSubReg(Region<'tcx>, Region<'tcx>),\n+}\n+\n+/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// associated type) must outlive the region `R`. `T` is known to\n+/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// `i`. Inference variables may be involved (but this verification\n+/// step doesn't influence inference).\n+#[derive(Debug)]\n+pub struct Verify<'tcx> {\n+    pub kind: GenericKind<'tcx>,\n+    pub origin: SubregionOrigin<'tcx>,\n+    pub region: Region<'tcx>,\n+    pub bound: VerifyBound<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum GenericKind<'tcx> {\n+    Param(ty::ParamTy),\n+    Projection(ty::ProjectionTy<'tcx>),\n+}\n+\n+/// When we introduce a verification step, we wish to test that a\n+/// particular region (let's call it `'min`) meets some bound.\n+/// The bound is described the by the following grammar:\n+#[derive(Debug)]\n+pub enum VerifyBound<'tcx> {\n+    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive all\n+    /// regions in {R}, so if any of those outlives 'min, then the\n+    /// bound is met.\n+    AnyRegion(Vec<Region<'tcx>>),\n+\n+    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive some\n+    /// region in {R}, so if all of those outlives 'min, then the bound\n+    /// is met.\n+    AllRegions(Vec<Region<'tcx>>),\n+\n+    /// B = exists {B} --> 'min must meet some bound b in {B}\n+    AnyBound(Vec<VerifyBound<'tcx>>),\n+\n+    /// B = forall {B} --> 'min must meet all bounds b in {B}\n+    AllBounds(Vec<VerifyBound<'tcx>>),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct TwoRegions<'tcx> {\n+    a: Region<'tcx>,\n+    b: Region<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+enum UndoLogEntry<'tcx> {\n+    /// Pushed when we start a snapshot.\n+    OpenSnapshot,\n+\n+    /// Replaces an `OpenSnapshot` when a snapshot is committed, but\n+    /// that snapshot is not the root. If the root snapshot is\n+    /// unrolled, all nested snapshots must be committed.\n+    CommitedSnapshot,\n+\n+    /// We added `RegionVid`\n+    AddVar(RegionVid),\n+\n+    /// We added the given `constraint`\n+    AddConstraint(Constraint<'tcx>),\n+\n+    /// We added the given `verify`\n+    AddVerify(usize),\n+\n+    /// We added the given `given`\n+    AddGiven(Region<'tcx>, ty::RegionVid),\n+\n+    /// We added a GLB/LUB \"combination variable\"\n+    AddCombination(CombineMapType, TwoRegions<'tcx>),\n+\n+    /// During skolemization, we sometimes purge entries from the undo\n+    /// log in a kind of minisnapshot (unlike other snapshots, this\n+    /// purging actually takes place *on success*). In that case, we\n+    /// replace the corresponding entry with `Noop` so as to avoid the\n+    /// need to do a bunch of swapping. (We can't use `swap_remove` as\n+    /// the order of the vector is important.)\n+    Purged,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+enum CombineMapType {\n+    Lub,\n+    Glb,\n+}\n+\n+type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n+\n+pub struct RegionSnapshot {\n+    length: usize,\n+    region_snapshot: unify::Snapshot<ty::RegionVid>,\n+    skolemization_count: u32,\n+}\n+\n+/// When working with skolemized regions, we often wish to find all of\n+/// the regions that are either reachable from a skolemized region, or\n+/// which can reach a skolemized region, or both. We call such regions\n+/// *tained* regions.  This struct allows you to decide what set of\n+/// tainted regions you want.\n+#[derive(Debug)]\n+pub struct TaintDirections {\n+    incoming: bool,\n+    outgoing: bool,\n+}\n+\n+impl TaintDirections {\n+    pub fn incoming() -> Self {\n+        TaintDirections {\n+            incoming: true,\n+            outgoing: false,\n+        }\n+    }\n+\n+    pub fn outgoing() -> Self {\n+        TaintDirections {\n+            incoming: false,\n+            outgoing: true,\n+        }\n+    }\n+\n+    pub fn both() -> Self {\n+        TaintDirections {\n+            incoming: true,\n+            outgoing: true,\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionConstraintCollector<'tcx> {\n+    pub fn new() -> RegionConstraintCollector<'tcx> {\n+        RegionConstraintCollector {\n+            var_origins: VarOrigins::default(),\n+            data: RegionConstraintData::default(),\n+            lubs: FxHashMap(),\n+            glbs: FxHashMap(),\n+            skolemization_count: 0,\n+            bound_count: 0,\n+            undo_log: Vec::new(),\n+            unification_table: UnificationTable::new(),\n+        }\n+    }\n+\n+    pub fn var_origins(&self) -> &VarOrigins {\n+        &self.var_origins\n+    }\n+\n+    /// Once all the constraints have been gathered, extract out the final data.\n+    ///\n+    /// Not legal during a snapshot.\n+    pub fn into_origins_and_data(self) -> (VarOrigins, RegionConstraintData<'tcx>) {\n+        assert!(!self.in_snapshot());\n+        (self.var_origins, self.data)\n+    }\n+\n+    /// Takes (and clears) the current set of constraints. Note that\n+    /// the set of variables remains intact, but all relationships\n+    /// between them are reset.  This is used during NLL checking to\n+    /// grab the set of constraints that arose from a particular\n+    /// operation.\n+    ///\n+    /// We don't want to leak relationships between variables between\n+    /// points because just because (say) `r1 == r2` was true at some\n+    /// point P in the graph doesn't imply that it will be true at\n+    /// some other point Q, in NLL.\n+    ///\n+    /// Not legal during a snapshot.\n+    pub fn take_and_reset_data(&mut self) -> RegionConstraintData<'tcx> {\n+        assert!(!self.in_snapshot());\n+\n+        // If you add a new field to `RegionConstraintCollector`, you\n+        // should think carefully about whether it needs to be cleared\n+        // or updated in some way.\n+        let RegionConstraintCollector {\n+            var_origins,\n+            data,\n+            lubs,\n+            glbs,\n+            skolemization_count,\n+            bound_count: _,\n+            undo_log: _,\n+            unification_table,\n+        } = self;\n+\n+        assert_eq!(*skolemization_count, 0);\n+\n+        // Clear the tables of (lubs, glbs), so that we will create\n+        // fresh regions if we do a LUB operation. As it happens,\n+        // LUB/GLB are not performed by the MIR type-checker, which is\n+        // the one that uses this method, but it's good to be correct.\n+        lubs.clear();\n+        glbs.clear();\n+\n+        // Clear all unifications and recreate the variables a \"now\n+        // un-unified\" state. Note that when we unify `a` and `b`, we\n+        // also insert `a <= b` and a `b <= a` edges, so the\n+        // `RegionConstraintData` contains the relationship here.\n+        *unification_table = UnificationTable::new();\n+        for vid in var_origins.indices() {\n+            unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n+        }\n+\n+        mem::replace(data, RegionConstraintData::default())\n+    }\n+\n+    fn in_snapshot(&self) -> bool {\n+        !self.undo_log.is_empty()\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> RegionSnapshot {\n+        let length = self.undo_log.len();\n+        debug!(\"RegionConstraintCollector: start_snapshot({})\", length);\n+        self.undo_log.push(OpenSnapshot);\n+        RegionSnapshot {\n+            length,\n+            region_snapshot: self.unification_table.snapshot(),\n+            skolemization_count: self.skolemization_count,\n+        }\n+    }\n+\n+    pub fn commit(&mut self, snapshot: RegionSnapshot) {\n+        debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n+        assert!(self.undo_log.len() > snapshot.length);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+        assert!(\n+            self.skolemization_count == snapshot.skolemization_count,\n+            \"failed to pop skolemized regions: {} now vs {} at start\",\n+            self.skolemization_count,\n+            snapshot.skolemization_count\n+        );\n+\n+        if snapshot.length == 0 {\n+            self.undo_log.truncate(0);\n+        } else {\n+            (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n+        }\n+        self.unification_table.commit(snapshot.region_snapshot);\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n+        debug!(\"RegionConstraintCollector: rollback_to({:?})\", snapshot);\n+        assert!(self.undo_log.len() > snapshot.length);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+        while self.undo_log.len() > snapshot.length + 1 {\n+            let undo_entry = self.undo_log.pop().unwrap();\n+            self.rollback_undo_entry(undo_entry);\n+        }\n+        let c = self.undo_log.pop().unwrap();\n+        assert!(c == OpenSnapshot);\n+        self.skolemization_count = snapshot.skolemization_count;\n+        self.unification_table.rollback_to(snapshot.region_snapshot);\n+    }\n+\n+    fn rollback_undo_entry(&mut self, undo_entry: UndoLogEntry<'tcx>) {\n+        match undo_entry {\n+            OpenSnapshot => {\n+                panic!(\"Failure to observe stack discipline\");\n+            }\n+            Purged | CommitedSnapshot => {\n+                // nothing to do here\n+            }\n+            AddVar(vid) => {\n+                self.var_origins.pop().unwrap();\n+                assert_eq!(self.var_origins.len(), vid.index as usize);\n+            }\n+            AddConstraint(ref constraint) => {\n+                self.data.constraints.remove(constraint);\n+            }\n+            AddVerify(index) => {\n+                self.data.verifys.pop();\n+                assert_eq!(self.data.verifys.len(), index);\n+            }\n+            AddGiven(sub, sup) => {\n+                self.data.givens.remove(&(sub, sup));\n+            }\n+            AddCombination(Glb, ref regions) => {\n+                self.glbs.remove(regions);\n+            }\n+            AddCombination(Lub, ref regions) => {\n+                self.lubs.remove(regions);\n+            }\n+        }\n+    }\n+\n+    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n+        let vid = self.var_origins.push(origin.clone());\n+\n+        let u_vid = self.unification_table\n+            .new_key(unify_key::RegionVidKey { min_vid: vid });\n+        assert_eq!(vid, u_vid);\n+        if self.in_snapshot() {\n+            self.undo_log.push(AddVar(vid));\n+        }\n+        debug!(\n+            \"created new region variable {:?} with origin {:?}\",\n+            vid,\n+            origin\n+        );\n+        return vid;\n+    }\n+\n+    /// Returns the origin for the given variable.\n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_origins[vid].clone()\n+    }\n+\n+    /// Creates a new skolemized region. Skolemized regions are fresh\n+    /// regions used when performing higher-ranked computations. They\n+    /// must be used in a very particular way and are never supposed\n+    /// to \"escape\" out into error messages or the code at large.\n+    ///\n+    /// The idea is to always create a snapshot. Skolemized regions\n+    /// can be created in the context of this snapshot, but before the\n+    /// snapshot is committed or rolled back, they must be popped\n+    /// (using `pop_skolemized_regions`), so that their numbers can be\n+    /// recycled. Normally you don't have to think about this: you use\n+    /// the APIs in `higher_ranked/mod.rs`, such as\n+    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n+    /// guide you on this path (ensure that the `SkolemizationMap` is\n+    /// consumed and you are good).  There are also somewhat extensive\n+    /// comments in `higher_ranked/README.md`.\n+    ///\n+    /// The `snapshot` argument to this function is not really used;\n+    /// it's just there to make it explicit which snapshot bounds the\n+    /// skolemized region that results. It should always be the top-most snapshot.\n+    pub fn push_skolemized(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        br: ty::BoundRegion,\n+        snapshot: &RegionSnapshot,\n+    ) -> Region<'tcx> {\n+        assert!(self.in_snapshot());\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+\n+        let sc = self.skolemization_count;\n+        self.skolemization_count = sc + 1;\n+        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+    }\n+\n+    /// Removes all the edges to/from the skolemized regions that are\n+    /// in `skols`. This is used after a higher-ranked operation\n+    /// completes to remove all trace of the skolemized regions\n+    /// created in that time.\n+    pub fn pop_skolemized(\n+        &mut self,\n+        _tcx: TyCtxt<'_, '_, 'tcx>,\n+        skols: &FxHashSet<ty::Region<'tcx>>,\n+        snapshot: &RegionSnapshot,\n+    ) {\n+        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n+\n+        assert!(self.in_snapshot());\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+        assert!(\n+            self.skolemization_count as usize >= skols.len(),\n+            \"popping more skolemized variables than actually exist, \\\n+             sc now = {}, skols.len = {}\",\n+            self.skolemization_count,\n+            skols.len()\n+        );\n+\n+        let last_to_pop = self.skolemization_count;\n+        let first_to_pop = last_to_pop - (skols.len() as u32);\n+\n+        assert!(\n+            first_to_pop >= snapshot.skolemization_count,\n+            \"popping more regions than snapshot contains, \\\n+             sc now = {}, sc then = {}, skols.len = {}\",\n+            self.skolemization_count,\n+            snapshot.skolemization_count,\n+            skols.len()\n+        );\n+        debug_assert! {\n+            skols.iter()\n+                 .all(|&k| match *k {\n+                     ty::ReSkolemized(index, _) =>\n+                         index.index >= first_to_pop &&\n+                         index.index < last_to_pop,\n+                     _ =>\n+                         false\n+                 }),\n+            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n+            snapshot.skolemization_count,\n+            self.skolemization_count,\n+            skols\n+        }\n+\n+        let constraints_to_kill: Vec<usize> = self.undo_log\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n+            .map(|(index, _)| index)\n+            .collect();\n+\n+        for index in constraints_to_kill {\n+            let undo_entry = mem::replace(&mut self.undo_log[index], Purged);\n+            self.rollback_undo_entry(undo_entry);\n+        }\n+\n+        self.skolemization_count = snapshot.skolemization_count;\n+        return;\n+\n+        fn kill_constraint<'tcx>(\n+            skols: &FxHashSet<ty::Region<'tcx>>,\n+            undo_entry: &UndoLogEntry<'tcx>,\n+        ) -> bool {\n+            match undo_entry {\n+                &AddConstraint(Constraint::VarSubVar(..)) => false,\n+                &AddConstraint(Constraint::RegSubVar(a, _)) => skols.contains(&a),\n+                &AddConstraint(Constraint::VarSubReg(_, b)) => skols.contains(&b),\n+                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                    skols.contains(&a) || skols.contains(&b)\n+                }\n+                &AddGiven(..) => false,\n+                &AddVerify(_) => false,\n+                &AddCombination(_, ref two_regions) => {\n+                    skols.contains(&two_regions.a) || skols.contains(&two_regions.b)\n+                }\n+                &AddVar(..) | &OpenSnapshot | &Purged | &CommitedSnapshot => false,\n+            }\n+        }\n+    }\n+\n+    pub fn new_bound(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> Region<'tcx> {\n+        // Creates a fresh bound variable for use in GLB computations.\n+        // See discussion of GLB computation in the large comment at\n+        // the top of this file for more details.\n+        //\n+        // This computation is potentially wrong in the face of\n+        // rollover.  It's conceivable, if unlikely, that one might\n+        // wind up with accidental capture for nested functions in\n+        // that case, if the outer function had bound regions created\n+        // a very long time before and the inner function somehow\n+        // wound up rolling over such that supposedly fresh\n+        // identifiers were in fact shadowed. For now, we just assert\n+        // that there is no rollover -- eventually we should try to be\n+        // robust against this possibility, either by checking the set\n+        // of bound identifiers that appear in a given expression and\n+        // ensure that we generate one that is distinct, or by\n+        // changing the representation of bound regions in a fn\n+        // declaration\n+\n+        let sc = self.bound_count;\n+        self.bound_count = sc + 1;\n+\n+        if sc >= self.bound_count {\n+            bug!(\"rollover in RegionInference new_bound()\");\n+        }\n+\n+        tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n+    }\n+\n+    fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n+        // cannot add constraints once regions are resolved\n+        debug!(\n+            \"RegionConstraintCollector: add_constraint({:?})\",\n+            constraint\n+        );\n+\n+        // never overwrite an existing (constraint, origin) - only insert one if it isn't\n+        // present in the map yet. This prevents origins from outside the snapshot being\n+        // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n+        let in_snapshot = self.in_snapshot();\n+        let undo_log = &mut self.undo_log;\n+        self.data.constraints.entry(constraint).or_insert_with(|| {\n+            if in_snapshot {\n+                undo_log.push(AddConstraint(constraint));\n+            }\n+            origin\n+        });\n+    }\n+\n+    fn add_verify(&mut self, verify: Verify<'tcx>) {\n+        // cannot add verifys once regions are resolved\n+        debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n+\n+        // skip no-op cases known to be satisfied\n+        match verify.bound {\n+            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => {\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        let index = self.data.verifys.len();\n+        self.data.verifys.push(verify);\n+        if self.in_snapshot() {\n+            self.undo_log.push(AddVerify(index));\n+        }\n+    }\n+\n+    pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n+        // cannot add givens once regions are resolved\n+        if self.data.givens.insert((sub, sup)) {\n+            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n+\n+            if self.in_snapshot() {\n+                self.undo_log.push(AddGiven(sub, sup));\n+            }\n+        }\n+    }\n+\n+    pub fn make_eqregion(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) {\n+        if sub != sup {\n+            // Eventually, it would be nice to add direct support for\n+            // equating regions.\n+            self.make_subregion(origin.clone(), sub, sup);\n+            self.make_subregion(origin, sup, sub);\n+\n+            if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n+                self.unification_table.union(sub, sup);\n+            }\n+        }\n+    }\n+\n+    pub fn make_subregion(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) {\n+        // cannot add constraints once regions are resolved\n+        debug!(\n+            \"RegionConstraintCollector: make_subregion({:?}, {:?}) due to {:?}\",\n+            sub,\n+            sup,\n+            origin\n+        );\n+\n+        match (sub, sup) {\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) => {\n+                span_bug!(\n+                    origin.span(),\n+                    \"cannot relate bound region: {:?} <= {:?}\",\n+                    sub,\n+                    sup\n+                );\n+            }\n+            (_, &ReStatic) => {\n+                // all regions are subregions of static, so we can ignore this\n+            }\n+            (&ReVar(sub_id), &ReVar(sup_id)) => {\n+                self.add_constraint(Constraint::VarSubVar(sub_id, sup_id), origin);\n+            }\n+            (_, &ReVar(sup_id)) => {\n+                self.add_constraint(Constraint::RegSubVar(sub, sup_id), origin);\n+            }\n+            (&ReVar(sub_id), _) => {\n+                self.add_constraint(Constraint::VarSubReg(sub_id, sup), origin);\n+            }\n+            _ => {\n+                self.add_constraint(Constraint::RegSubReg(sub, sup), origin);\n+            }\n+        }\n+    }\n+\n+    /// See `Verify::VerifyGenericBound`\n+    pub fn verify_generic_bound(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        self.add_verify(Verify {\n+            kind,\n+            origin,\n+            region: sub,\n+            bound,\n+        });\n+    }\n+\n+    pub fn lub_regions(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        origin: SubregionOrigin<'tcx>,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n+        // cannot add constraints once regions are resolved\n+        debug!(\"RegionConstraintCollector: lub_regions({:?}, {:?})\", a, b);\n+        match (a, b) {\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            _ if a == b => {\n+                a // LUB(a,a) = a\n+            }\n+\n+            _ => self.combine_vars(tcx, Lub, a, b, origin.clone()),\n+        }\n+    }\n+\n+    pub fn glb_regions(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        origin: SubregionOrigin<'tcx>,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n+        // cannot add constraints once regions are resolved\n+        debug!(\"RegionConstraintCollector: glb_regions({:?}, {:?})\", a, b);\n+        match (a, b) {\n+            (&ReStatic, r) | (r, &ReStatic) => {\n+                r // static lives longer than everything else\n+            }\n+\n+            _ if a == b => {\n+                a // GLB(a,a) = a\n+            }\n+\n+            _ => self.combine_vars(tcx, Glb, a, b, origin.clone()),\n+        }\n+    }\n+\n+    pub fn opportunistic_resolve_var(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        rid: RegionVid,\n+    ) -> ty::Region<'tcx> {\n+        let vid = self.unification_table.find_value(rid).min_vid;\n+        tcx.mk_region(ty::ReVar(vid))\n+    }\n+\n+    fn combine_map(&mut self, t: CombineMapType) -> &mut CombineMap<'tcx> {\n+        match t {\n+            Glb => &mut self.glbs,\n+            Lub => &mut self.lubs,\n+        }\n+    }\n+\n+    fn combine_vars(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        t: CombineMapType,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+        origin: SubregionOrigin<'tcx>,\n+    ) -> Region<'tcx> {\n+        let vars = TwoRegions { a: a, b: b };\n+        if let Some(&c) = self.combine_map(t).get(&vars) {\n+            return tcx.mk_region(ReVar(c));\n+        }\n+        let c = self.new_region_var(MiscVariable(origin.span()));\n+        self.combine_map(t).insert(vars, c);\n+        if self.in_snapshot() {\n+            self.undo_log.push(AddCombination(t, vars));\n+        }\n+        let new_r = tcx.mk_region(ReVar(c));\n+        for &old_r in &[a, b] {\n+            match t {\n+                Glb => self.make_subregion(origin.clone(), new_r, old_r),\n+                Lub => self.make_subregion(origin.clone(), old_r, new_r),\n+            }\n+        }\n+        debug!(\"combine_vars() c={:?}\", c);\n+        new_r\n+    }\n+\n+    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n+        self.undo_log[mark.length..]\n+            .iter()\n+            .filter_map(|&elt| match elt {\n+                AddVar(vid) => Some(vid),\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+\n+    /// Computes all regions that have been related to `r0` since the\n+    /// mark `mark` was made---`r0` itself will be the first\n+    /// entry. The `directions` parameter controls what kind of\n+    /// relations are considered. For example, one can say that only\n+    /// \"incoming\" edges to `r0` are desired, in which case one will\n+    /// get the set of regions `{r|r <= r0}`. This is used when\n+    /// checking whether skolemized regions are being improperly\n+    /// related to other regions.\n+    pub fn tainted(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mark: &RegionSnapshot,\n+        r0: Region<'tcx>,\n+        directions: TaintDirections,\n+    ) -> FxHashSet<ty::Region<'tcx>> {\n+        debug!(\n+            \"tainted(mark={:?}, r0={:?}, directions={:?})\",\n+            mark,\n+            r0,\n+            directions\n+        );\n+\n+        // `result_set` acts as a worklist: we explore all outgoing\n+        // edges and add any new regions we find to result_set.  This\n+        // is not a terribly efficient implementation.\n+        let mut taint_set = taint::TaintSet::new(directions, r0);\n+        taint_set.fixed_point(tcx, &self.undo_log[mark.length..], &self.data.verifys);\n+        debug!(\"tainted: result={:?}\", taint_set);\n+        return taint_set.into_set();\n+    }\n+}\n+\n+impl fmt::Debug for RegionSnapshot {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(\n+            f,\n+            \"RegionSnapshot(length={},skolemization={})\",\n+            self.length,\n+            self.skolemization_count\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            GenericKind::Param(ref p) => write!(f, \"{}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            GenericKind::Param(ref p) => p.to_ty(tcx),\n+            GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n+    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n+                f(r);\n+            },\n+\n+            &VerifyBound::AnyBound(ref bs) | &VerifyBound::AllBounds(ref bs) => for b in bs {\n+                b.for_each_region(f);\n+            },\n+        }\n+    }\n+\n+    pub fn must_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n+            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+        }\n+    }\n+\n+    pub fn cannot_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n+            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+        }\n+    }\n+\n+    pub fn or(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n+        if self.must_hold() || vb.cannot_hold() {\n+            self\n+        } else if self.cannot_hold() || vb.must_hold() {\n+            vb\n+        } else {\n+            VerifyBound::AnyBound(vec![self, vb])\n+        }\n+    }\n+\n+    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n+        if self.must_hold() && vb.must_hold() {\n+            self\n+        } else if self.cannot_hold() && vb.cannot_hold() {\n+            self\n+        } else {\n+            VerifyBound::AllBounds(vec![self, vb])\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionConstraintData<'tcx> {\n+    /// True if this region constraint data contains no constraints.\n+    pub fn is_empty(&self) -> bool {\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = self;\n+        constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+    }\n+}"}, {"sha": "ee45f7bd82801afcebbb0298476458881b0c6a8d", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+#[derive(Debug)]\n+pub(super) struct TaintSet<'tcx> {\n+    directions: TaintDirections,\n+    regions: FxHashSet<ty::Region<'tcx>>\n+}\n+\n+impl<'tcx> TaintSet<'tcx> {\n+    pub(super) fn new(directions: TaintDirections,\n+                      initial_region: ty::Region<'tcx>)\n+                      -> Self {\n+        let mut regions = FxHashSet();\n+        regions.insert(initial_region);\n+        TaintSet { directions: directions, regions: regions }\n+    }\n+\n+    pub(super) fn fixed_point(&mut self,\n+                              tcx: TyCtxt<'_, '_, 'tcx>,\n+                              undo_log: &[UndoLogEntry<'tcx>],\n+                              verifys: &[Verify<'tcx>]) {\n+        let mut prev_len = 0;\n+        while prev_len < self.len() {\n+            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n+                   prev_len, self.len());\n+\n+            prev_len = self.len();\n+\n+            for undo_entry in undo_log {\n+                match undo_entry {\n+                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n+                        self.add_edge(tcx.mk_region(ReVar(a)),\n+                                      tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n+                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n+                    }\n+                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                        self.add_edge(a, b);\n+                    }\n+                    &AddGiven(a, b) => {\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddVerify(i) => {\n+                        verifys[i].bound.for_each_region(&mut |b| {\n+                            self.add_edge(verifys[i].region, b);\n+                        });\n+                    }\n+                    &Purged |\n+                    &AddCombination(..) |\n+                    &AddVar(..) |\n+                    &OpenSnapshot |\n+                    &CommitedSnapshot => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(super) fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n+        self.regions\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.regions.len()\n+    }\n+\n+    fn add_edge(&mut self,\n+                source: ty::Region<'tcx>,\n+                target: ty::Region<'tcx>) {\n+        if self.directions.incoming {\n+            if self.regions.contains(&target) {\n+                self.regions.insert(source);\n+            }\n+        }\n+\n+        if self.directions.outgoing {\n+            if self.regions.contains(&source) {\n+                self.regions.insert(target);\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "f5327fad312375160855c06850c2323341234cd8", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "removed", "additions": 0, "deletions": 1648, "changes": 1648, "blob_url": "https://github.com/rust-lang/rust/blob/58d8761ab3f2eda3536c0a8e81f2179655a6fb00/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d8761ab3f2eda3536c0a8e81f2179655a6fb00/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=58d8761ab3f2eda3536c0a8e81f2179655a6fb00", "patch": "@@ -1,1648 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! See README.md\n-\n-pub use self::Constraint::*;\n-pub use self::UndoLogEntry::*;\n-pub use self::CombineMapType::*;\n-pub use self::RegionResolutionError::*;\n-pub use self::VarValue::*;\n-\n-use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n-use super::unify_key;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n-use rustc_data_structures::unify::{self, UnificationTable};\n-use middle::free_region::RegionRelations;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{Region, RegionVid};\n-use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n-use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-\n-use std::collections::BTreeMap;\n-use std::cell::{Cell, RefCell};\n-use std::fmt;\n-use std::mem;\n-use std::u32;\n-\n-mod graphviz;\n-\n-/// A constraint that influences the inference process.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n-pub enum Constraint<'tcx> {\n-    /// One region variable is subregion of another\n-    ConstrainVarSubVar(RegionVid, RegionVid),\n-\n-    /// Concrete region is subregion of region variable\n-    ConstrainRegSubVar(Region<'tcx>, RegionVid),\n-\n-    /// Region variable is subregion of concrete region. This does not\n-    /// directly affect inference, but instead is checked after\n-    /// inference is complete.\n-    ConstrainVarSubReg(RegionVid, Region<'tcx>),\n-\n-    /// A constraint where neither side is a variable. This does not\n-    /// directly affect inference, but instead is checked after\n-    /// inference is complete.\n-    ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n-}\n-\n-/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-/// associated type) must outlive the region `R`. `T` is known to\n-/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-/// `i`. Inference variables may be involved (but this verification\n-/// step doesn't influence inference).\n-#[derive(Debug)]\n-pub struct Verify<'tcx> {\n-    kind: GenericKind<'tcx>,\n-    origin: SubregionOrigin<'tcx>,\n-    region: Region<'tcx>,\n-    bound: VerifyBound<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum GenericKind<'tcx> {\n-    Param(ty::ParamTy),\n-    Projection(ty::ProjectionTy<'tcx>),\n-}\n-\n-/// When we introduce a verification step, we wish to test that a\n-/// particular region (let's call it `'min`) meets some bound.\n-/// The bound is described the by the following grammar:\n-#[derive(Debug)]\n-pub enum VerifyBound<'tcx> {\n-    /// B = exists {R} --> some 'r in {R} must outlive 'min\n-    ///\n-    /// Put another way, the subject value is known to outlive all\n-    /// regions in {R}, so if any of those outlives 'min, then the\n-    /// bound is met.\n-    AnyRegion(Vec<Region<'tcx>>),\n-\n-    /// B = forall {R} --> all 'r in {R} must outlive 'min\n-    ///\n-    /// Put another way, the subject value is known to outlive some\n-    /// region in {R}, so if all of those outlives 'min, then the bound\n-    /// is met.\n-    AllRegions(Vec<Region<'tcx>>),\n-\n-    /// B = exists {B} --> 'min must meet some bound b in {B}\n-    AnyBound(Vec<VerifyBound<'tcx>>),\n-\n-    /// B = forall {B} --> 'min must meet all bounds b in {B}\n-    AllBounds(Vec<VerifyBound<'tcx>>),\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TwoRegions<'tcx> {\n-    a: Region<'tcx>,\n-    b: Region<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum UndoLogEntry<'tcx> {\n-    /// Pushed when we start a snapshot.\n-    OpenSnapshot,\n-\n-    /// Replaces an `OpenSnapshot` when a snapshot is committed, but\n-    /// that snapshot is not the root. If the root snapshot is\n-    /// unrolled, all nested snapshots must be committed.\n-    CommitedSnapshot,\n-\n-    /// We added `RegionVid`\n-    AddVar(RegionVid),\n-\n-    /// We added the given `constraint`\n-    AddConstraint(Constraint<'tcx>),\n-\n-    /// We added the given `verify`\n-    AddVerify(usize),\n-\n-    /// We added the given `given`\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n-    /// We added a GLB/LUB \"combination variable\"\n-    AddCombination(CombineMapType, TwoRegions<'tcx>),\n-\n-    /// During skolemization, we sometimes purge entries from the undo\n-    /// log in a kind of minisnapshot (unlike other snapshots, this\n-    /// purging actually takes place *on success*). In that case, we\n-    /// replace the corresponding entry with `Noop` so as to avoid the\n-    /// need to do a bunch of swapping. (We can't use `swap_remove` as\n-    /// the order of the vector is important.)\n-    Purged,\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum CombineMapType {\n-    Lub,\n-    Glb,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum RegionResolutionError<'tcx> {\n-    /// `ConcreteFailure(o, a, b)`:\n-    ///\n-    /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n-\n-    /// `GenericBoundFailure(p, s, a)\n-    ///\n-    /// The parameter/associated-type `p` must be known to outlive the lifetime\n-    /// `a` (but none of the known bounds are sufficient).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n-\n-    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n-    ///\n-    /// Could not infer a value for `v` because `sub_r <= v` (due to\n-    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n-    /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin<'tcx>,\n-                   Region<'tcx>,\n-                   SubregionOrigin<'tcx>,\n-                   Region<'tcx>),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n-    VariableFailure(RegionVariableOrigin),\n-}\n-\n-pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n-\n-pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n-\n-    /// Constraints of the form `A <= B` introduced by the region\n-    /// checker.  Here at least one of `A` and `B` must be a region\n-    /// variable.\n-    ///\n-    /// Using `BTreeMap` because the order in which we iterate over\n-    /// these constraints can affect the way we build the region graph,\n-    /// which in turn affects the way that region errors are reported,\n-    /// leading to small variations in error output across runs and\n-    /// platforms.\n-    constraints: RefCell<BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n-\n-    /// A \"verify\" is something that we need to verify after inference is\n-    /// done, but which does not directly affect inference in any way.\n-    ///\n-    /// An example is a `A <= B` where neither `A` nor `B` are\n-    /// inference variables.\n-    verifys: RefCell<Vec<Verify<'tcx>>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In particular,\n-    /// we often know from closure fn signatures that a particular free\n-    /// region must be a subregion of a region variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically we\n-    /// record the fact that `'a <= 'b` is implied by the fn signature,\n-    /// and then ignore the constraint when solving equations. This is\n-    /// a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n-\n-    lubs: RefCell<CombineMap<'tcx>>,\n-    glbs: RefCell<CombineMap<'tcx>>,\n-    skolemization_count: Cell<u32>,\n-    bound_count: Cell<u32>,\n-\n-    /// The undo log records actions that might later be undone.\n-    ///\n-    /// Note: when the undo_log is empty, we are not actively\n-    /// snapshotting. When the `start_snapshot()` method is called, we\n-    /// push an OpenSnapshot entry onto the list to indicate that we\n-    /// are now actively snapshotting. The reason for this is that\n-    /// otherwise we end up adding entries for things like the lower\n-    /// bound on a variable and so forth, which can never be rolled\n-    /// back.\n-    undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n-\n-    unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n-\n-    /// This contains the results of inference.  It begins as an empty\n-    /// option and only acquires a value after inference is complete.\n-    values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n-}\n-\n-pub struct RegionSnapshot {\n-    length: usize,\n-    region_snapshot: unify::Snapshot<ty::RegionVid>,\n-    skolemization_count: u32,\n-}\n-\n-/// When working with skolemized regions, we often wish to find all of\n-/// the regions that are either reachable from a skolemized region, or\n-/// which can reach a skolemized region, or both. We call such regions\n-/// *tained* regions.  This struct allows you to decide what set of\n-/// tainted regions you want.\n-#[derive(Debug)]\n-pub struct TaintDirections {\n-    incoming: bool,\n-    outgoing: bool,\n-}\n-\n-impl TaintDirections {\n-    pub fn incoming() -> Self {\n-        TaintDirections { incoming: true, outgoing: false }\n-    }\n-\n-    pub fn outgoing() -> Self {\n-        TaintDirections { incoming: false, outgoing: true }\n-    }\n-\n-    pub fn both() -> Self {\n-        TaintDirections { incoming: true, outgoing: true }\n-    }\n-}\n-\n-struct TaintSet<'tcx> {\n-    directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>\n-}\n-\n-impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n-    fn new(directions: TaintDirections,\n-           initial_region: ty::Region<'tcx>)\n-           -> Self {\n-        let mut regions = FxHashSet();\n-        regions.insert(initial_region);\n-        TaintSet { directions: directions, regions: regions }\n-    }\n-\n-    fn fixed_point(&mut self,\n-                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   undo_log: &[UndoLogEntry<'tcx>],\n-                   verifys: &[Verify<'tcx>]) {\n-        let mut prev_len = 0;\n-        while prev_len < self.len() {\n-            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n-                   prev_len, self.len());\n-\n-            prev_len = self.len();\n-\n-            for undo_entry in undo_log {\n-                match undo_entry {\n-                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)),\n-                                      tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n-                    }\n-                    &AddConstraint(ConstrainRegSubReg(a, b)) => {\n-                        self.add_edge(a, b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddVerify(i) => {\n-                        verifys[i].bound.for_each_region(&mut |b| {\n-                            self.add_edge(verifys[i].region, b);\n-                        });\n-                    }\n-                    &Purged |\n-                    &AddCombination(..) |\n-                    &AddVar(..) |\n-                    &OpenSnapshot |\n-                    &CommitedSnapshot => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n-        self.regions\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.regions.len()\n-    }\n-\n-    fn add_edge(&mut self,\n-                source: ty::Region<'tcx>,\n-                target: ty::Region<'tcx>) {\n-        if self.directions.incoming {\n-            if self.regions.contains(&target) {\n-                self.regions.insert(source);\n-            }\n-        }\n-\n-        if self.directions.outgoing {\n-            if self.regions.contains(&source) {\n-                self.regions.insert(target);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n-        RegionVarBindings {\n-            tcx,\n-            var_origins: RefCell::new(Vec::new()),\n-            values: RefCell::new(None),\n-            constraints: RefCell::new(BTreeMap::new()),\n-            verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FxHashSet()),\n-            lubs: RefCell::new(FxHashMap()),\n-            glbs: RefCell::new(FxHashMap()),\n-            skolemization_count: Cell::new(0),\n-            bound_count: Cell::new(0),\n-            undo_log: RefCell::new(Vec::new()),\n-            unification_table: RefCell::new(UnificationTable::new()),\n-        }\n-    }\n-\n-    fn in_snapshot(&self) -> bool {\n-        !self.undo_log.borrow().is_empty()\n-    }\n-\n-    pub fn start_snapshot(&self) -> RegionSnapshot {\n-        let length = self.undo_log.borrow().len();\n-        debug!(\"RegionVarBindings: start_snapshot({})\", length);\n-        self.undo_log.borrow_mut().push(OpenSnapshot);\n-        RegionSnapshot {\n-            length,\n-            region_snapshot: self.unification_table.borrow_mut().snapshot(),\n-            skolemization_count: self.skolemization_count.get(),\n-        }\n-    }\n-\n-    pub fn commit(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n-        assert!(self.undo_log.borrow().len() > snapshot.length);\n-        assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n-        assert!(self.skolemization_count.get() == snapshot.skolemization_count,\n-                \"failed to pop skolemized regions: {} now vs {} at start\",\n-                self.skolemization_count.get(),\n-                snapshot.skolemization_count);\n-\n-        let mut undo_log = self.undo_log.borrow_mut();\n-        if snapshot.length == 0 {\n-            undo_log.truncate(0);\n-        } else {\n-            (*undo_log)[snapshot.length] = CommitedSnapshot;\n-        }\n-        self.unification_table.borrow_mut().commit(snapshot.region_snapshot);\n-    }\n-\n-    pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: rollback_to({:?})\", snapshot);\n-        let mut undo_log = self.undo_log.borrow_mut();\n-        assert!(undo_log.len() > snapshot.length);\n-        assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n-        while undo_log.len() > snapshot.length + 1 {\n-            self.rollback_undo_entry(undo_log.pop().unwrap());\n-        }\n-        let c = undo_log.pop().unwrap();\n-        assert!(c == OpenSnapshot);\n-        self.skolemization_count.set(snapshot.skolemization_count);\n-        self.unification_table.borrow_mut()\n-            .rollback_to(snapshot.region_snapshot);\n-    }\n-\n-    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n-        match undo_entry {\n-            OpenSnapshot => {\n-                panic!(\"Failure to observe stack discipline\");\n-            }\n-            Purged | CommitedSnapshot => {\n-                // nothing to do here\n-            }\n-            AddVar(vid) => {\n-                let mut var_origins = self.var_origins.borrow_mut();\n-                var_origins.pop().unwrap();\n-                assert_eq!(var_origins.len(), vid.index as usize);\n-            }\n-            AddConstraint(ref constraint) => {\n-                self.constraints.borrow_mut().remove(constraint);\n-            }\n-            AddVerify(index) => {\n-                self.verifys.borrow_mut().pop();\n-                assert_eq!(self.verifys.borrow().len(), index);\n-            }\n-            AddGiven(sub, sup) => {\n-                self.givens.borrow_mut().remove(&(sub, sup));\n-            }\n-            AddCombination(Glb, ref regions) => {\n-                self.glbs.borrow_mut().remove(regions);\n-            }\n-            AddCombination(Lub, ref regions) => {\n-                self.lubs.borrow_mut().remove(regions);\n-            }\n-        }\n-    }\n-\n-    pub fn num_vars(&self) -> u32 {\n-        let len = self.var_origins.borrow().len();\n-        // enforce no overflow\n-        assert!(len as u32 as usize == len);\n-        len as u32\n-    }\n-\n-    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = RegionVid { index: self.num_vars() };\n-        self.var_origins.borrow_mut().push(origin.clone());\n-\n-        let u_vid = self.unification_table.borrow_mut().new_key(\n-            unify_key::RegionVidKey { min_vid: vid }\n-            );\n-        assert_eq!(vid, u_vid);\n-        if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddVar(vid));\n-        }\n-        debug!(\"created new region variable {:?} with origin {:?}\",\n-               vid,\n-               origin);\n-        return vid;\n-    }\n-\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins.borrow()[vid.index as usize].clone()\n-    }\n-\n-    /// Creates a new skolemized region. Skolemized regions are fresh\n-    /// regions used when performing higher-ranked computations. They\n-    /// must be used in a very particular way and are never supposed\n-    /// to \"escape\" out into error messages or the code at large.\n-    ///\n-    /// The idea is to always create a snapshot. Skolemized regions\n-    /// can be created in the context of this snapshot, but before the\n-    /// snapshot is committed or rolled back, they must be popped\n-    /// (using `pop_skolemized_regions`), so that their numbers can be\n-    /// recycled. Normally you don't have to think about this: you use\n-    /// the APIs in `higher_ranked/mod.rs`, such as\n-    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n-    /// guide you on this path (ensure that the `SkolemizationMap` is\n-    /// consumed and you are good).  There are also somewhat extensive\n-    /// comments in `higher_ranked/README.md`.\n-    ///\n-    /// The `snapshot` argument to this function is not really used;\n-    /// it's just there to make it explicit which snapshot bounds the\n-    /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n-                           -> Region<'tcx> {\n-        assert!(self.in_snapshot());\n-        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n-\n-        let sc = self.skolemization_count.get();\n-        self.skolemization_count.set(sc + 1);\n-        self.tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n-    }\n-\n-    /// Removes all the edges to/from the skolemized regions that are\n-    /// in `skols`. This is used after a higher-ranked operation\n-    /// completes to remove all trace of the skolemized regions\n-    /// created in that time.\n-    pub fn pop_skolemized(&self,\n-                          skols: &FxHashSet<ty::Region<'tcx>>,\n-                          snapshot: &RegionSnapshot) {\n-        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n-\n-        assert!(self.in_snapshot());\n-        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n-        assert!(self.skolemization_count.get() as usize >= skols.len(),\n-                \"popping more skolemized variables than actually exist, \\\n-                 sc now = {}, skols.len = {}\",\n-                self.skolemization_count.get(),\n-                skols.len());\n-\n-        let last_to_pop = self.skolemization_count.get();\n-        let first_to_pop = last_to_pop - (skols.len() as u32);\n-\n-        assert!(first_to_pop >= snapshot.skolemization_count,\n-                \"popping more regions than snapshot contains, \\\n-                 sc now = {}, sc then = {}, skols.len = {}\",\n-                self.skolemization_count.get(),\n-                snapshot.skolemization_count,\n-                skols.len());\n-        debug_assert! {\n-            skols.iter()\n-                 .all(|&k| match *k {\n-                     ty::ReSkolemized(index, _) =>\n-                         index.index >= first_to_pop &&\n-                         index.index < last_to_pop,\n-                     _ =>\n-                         false\n-                 }),\n-            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n-            snapshot.skolemization_count,\n-            self.skolemization_count.get(),\n-            skols\n-        }\n-\n-        let mut undo_log = self.undo_log.borrow_mut();\n-\n-        let constraints_to_kill: Vec<usize> =\n-            undo_log.iter()\n-                    .enumerate()\n-                    .rev()\n-                    .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n-                    .map(|(index, _)| index)\n-                    .collect();\n-\n-        for index in constraints_to_kill {\n-            let undo_entry = mem::replace(&mut undo_log[index], Purged);\n-            self.rollback_undo_entry(undo_entry);\n-        }\n-\n-        self.skolemization_count.set(snapshot.skolemization_count);\n-        return;\n-\n-        fn kill_constraint<'tcx>(skols: &FxHashSet<ty::Region<'tcx>>,\n-                                 undo_entry: &UndoLogEntry<'tcx>)\n-                                 -> bool {\n-            match undo_entry {\n-                &AddConstraint(ConstrainVarSubVar(..)) =>\n-                    false,\n-                &AddConstraint(ConstrainRegSubVar(a, _)) =>\n-                    skols.contains(&a),\n-                &AddConstraint(ConstrainVarSubReg(_, b)) =>\n-                    skols.contains(&b),\n-                &AddConstraint(ConstrainRegSubReg(a, b)) =>\n-                    skols.contains(&a) || skols.contains(&b),\n-                &AddGiven(..) =>\n-                    false,\n-                &AddVerify(_) =>\n-                    false,\n-                &AddCombination(_, ref two_regions) =>\n-                    skols.contains(&two_regions.a) ||\n-                    skols.contains(&two_regions.b),\n-                &AddVar(..) |\n-                &OpenSnapshot |\n-                &Purged |\n-                &CommitedSnapshot =>\n-                    false,\n-            }\n-        }\n-\n-    }\n-\n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region<'tcx> {\n-        // Creates a fresh bound variable for use in GLB computations.\n-        // See discussion of GLB computation in the large comment at\n-        // the top of this file for more details.\n-        //\n-        // This computation is potentially wrong in the face of\n-        // rollover.  It's conceivable, if unlikely, that one might\n-        // wind up with accidental capture for nested functions in\n-        // that case, if the outer function had bound regions created\n-        // a very long time before and the inner function somehow\n-        // wound up rolling over such that supposedly fresh\n-        // identifiers were in fact shadowed. For now, we just assert\n-        // that there is no rollover -- eventually we should try to be\n-        // robust against this possibility, either by checking the set\n-        // of bound identifiers that appear in a given expression and\n-        // ensure that we generate one that is distinct, or by\n-        // changing the representation of bound regions in a fn\n-        // declaration\n-\n-        let sc = self.bound_count.get();\n-        self.bound_count.set(sc + 1);\n-\n-        if sc >= self.bound_count.get() {\n-            bug!(\"rollover in RegionInference new_bound()\");\n-        }\n-\n-        self.tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n-    }\n-\n-    fn values_are_none(&self) -> bool {\n-        self.values.borrow().is_none()\n-    }\n-\n-    fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n-        // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n-\n-        // never overwrite an existing (constraint, origin) - only insert one if it isn't\n-        // present in the map yet. This prevents origins from outside the snapshot being\n-        // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n-        self.constraints.borrow_mut().entry(constraint).or_insert_with(|| {\n-            if self.in_snapshot() {\n-                self.undo_log.borrow_mut().push(AddConstraint(constraint));\n-            }\n-            origin\n-        });\n-    }\n-\n-    fn add_verify(&self, verify: Verify<'tcx>) {\n-        // cannot add verifys once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n-\n-        // skip no-op cases known to be satisfied\n-        match verify.bound {\n-            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => { return; }\n-            _ => { }\n-        }\n-\n-        let mut verifys = self.verifys.borrow_mut();\n-        let index = verifys.len();\n-        verifys.push(verify);\n-        if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddVerify(index));\n-        }\n-    }\n-\n-    pub fn add_given(&self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        let mut givens = self.givens.borrow_mut();\n-        if givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n-        }\n-    }\n-\n-    pub fn make_eqregion(&self,\n-                         origin: SubregionOrigin<'tcx>,\n-                         sub: Region<'tcx>,\n-                         sup: Region<'tcx>) {\n-        if sub != sup {\n-            // Eventually, it would be nice to add direct support for\n-            // equating regions.\n-            self.make_subregion(origin.clone(), sub, sup);\n-            self.make_subregion(origin, sup, sub);\n-\n-            if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n-                self.unification_table.borrow_mut().union(sub, sup);\n-            }\n-        }\n-    }\n-\n-    pub fn make_subregion(&self,\n-                          origin: SubregionOrigin<'tcx>,\n-                          sub: Region<'tcx>,\n-                          sup: Region<'tcx>) {\n-        // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        debug!(\"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n-               sub,\n-               sup,\n-               origin);\n-\n-        match (sub, sup) {\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) => {\n-                span_bug!(origin.span(),\n-                          \"cannot relate bound region: {:?} <= {:?}\",\n-                          sub,\n-                          sup);\n-            }\n-            (_, &ReStatic) => {\n-                // all regions are subregions of static, so we can ignore this\n-            }\n-            (&ReVar(sub_id), &ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n-            }\n-            (_, &ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainRegSubVar(sub, sup_id), origin);\n-            }\n-            (&ReVar(sub_id), _) => {\n-                self.add_constraint(ConstrainVarSubReg(sub_id, sup), origin);\n-            }\n-            _ => {\n-                self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n-            }\n-        }\n-    }\n-\n-    /// See `Verify::VerifyGenericBound`\n-    pub fn verify_generic_bound(&self,\n-                                origin: SubregionOrigin<'tcx>,\n-                                kind: GenericKind<'tcx>,\n-                                sub: Region<'tcx>,\n-                                bound: VerifyBound<'tcx>) {\n-        self.add_verify(Verify {\n-            kind,\n-            origin,\n-            region: sub,\n-            bound,\n-        });\n-    }\n-\n-    pub fn lub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region<'tcx>,\n-                       b: Region<'tcx>)\n-                       -> Region<'tcx> {\n-        // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            _ if a == b => {\n-                a // LUB(a,a) = a\n-            }\n-\n-            _ => {\n-                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n-                    this.make_subregion(origin.clone(), old_r, new_r)\n-                })\n-            }\n-        }\n-    }\n-\n-    pub fn glb_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region<'tcx>,\n-                       b: Region<'tcx>)\n-                       -> Region<'tcx> {\n-        // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n-        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (&ReStatic, r) | (r, &ReStatic) => {\n-                r // static lives longer than everything else\n-            }\n-\n-            _ if a == b => {\n-                a // GLB(a,a) = a\n-            }\n-\n-            _ => {\n-                self.combine_vars(Glb, a, b, origin.clone(), |this, old_r, new_r| {\n-                    this.make_subregion(origin.clone(), new_r, old_r)\n-                })\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        match *self.values.borrow() {\n-            None => {\n-                span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n-                          \"attempt to resolve region variable before values have \\\n-                           been computed!\")\n-            }\n-            Some(ref values) => {\n-                let r = lookup(self.tcx, values, rid);\n-                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n-                r\n-            }\n-        }\n-    }\n-\n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n-        self.tcx.mk_region(ty::ReVar(vid))\n-    }\n-\n-    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap<'tcx>> {\n-        match t {\n-            Glb => &self.glbs,\n-            Lub => &self.lubs,\n-        }\n-    }\n-\n-    pub fn combine_vars<F>(&self,\n-                           t: CombineMapType,\n-                           a: Region<'tcx>,\n-                           b: Region<'tcx>,\n-                           origin: SubregionOrigin<'tcx>,\n-                           mut relate: F)\n-                           -> Region<'tcx>\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>)\n-    {\n-        let vars = TwoRegions { a: a, b: b };\n-        if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n-            return self.tcx.mk_region(ReVar(c));\n-        }\n-        let c = self.new_region_var(MiscVariable(origin.span()));\n-        self.combine_map(t).borrow_mut().insert(vars, c);\n-        if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddCombination(t, vars));\n-        }\n-        relate(self, a, self.tcx.mk_region(ReVar(c)));\n-        relate(self, b, self.tcx.mk_region(ReVar(c)));\n-        debug!(\"combine_vars() c={:?}\", c);\n-        self.tcx.mk_region(ReVar(c))\n-    }\n-\n-    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n-        self.undo_log.borrow()[mark.length..]\n-            .iter()\n-            .filter_map(|&elt| {\n-                match elt {\n-                    AddVar(vid) => Some(vid),\n-                    _ => None,\n-                }\n-            })\n-            .collect()\n-    }\n-\n-    /// Computes all regions that have been related to `r0` since the\n-    /// mark `mark` was made---`r0` itself will be the first\n-    /// entry. The `directions` parameter controls what kind of\n-    /// relations are considered. For example, one can say that only\n-    /// \"incoming\" edges to `r0` are desired, in which case one will\n-    /// get the set of regions `{r|r <= r0}`. This is used when\n-    /// checking whether skolemized regions are being improperly\n-    /// related to other regions.\n-    pub fn tainted(&self,\n-                   mark: &RegionSnapshot,\n-                   r0: Region<'tcx>,\n-                   directions: TaintDirections)\n-                   -> FxHashSet<ty::Region<'tcx>> {\n-        debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n-               mark, r0, directions);\n-\n-        // `result_set` acts as a worklist: we explore all outgoing\n-        // edges and add any new regions we find to result_set.  This\n-        // is not a terribly efficient implementation.\n-        let mut taint_set = TaintSet::new(directions, r0);\n-        taint_set.fixed_point(self.tcx,\n-                              &self.undo_log.borrow()[mark.length..],\n-                              &self.verifys.borrow());\n-        debug!(\"tainted: result={:?}\", taint_set.regions);\n-        return taint_set.into_set();\n-    }\n-\n-    /// This function performs the actual region resolution.  It must be\n-    /// called after all constraints have been added.  It performs a\n-    /// fixed-point iteration to find region values which satisfy all\n-    /// constraints, assuming such values can be found; if they cannot,\n-    /// errors are reported.\n-    pub fn resolve_regions(&self,\n-                           region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n-                           -> Vec<RegionResolutionError<'tcx>> {\n-        debug!(\"RegionVarBindings: resolve_regions()\");\n-        let mut errors = vec![];\n-        let v = self.infer_variable_values(region_rels, &mut errors);\n-        *self.values.borrow_mut() = Some(v);\n-        errors\n-    }\n-\n-    fn lub_concrete_regions(&self,\n-                            region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                            a: Region<'tcx>,\n-                            b: Region<'tcx>)\n-                            -> Region<'tcx> {\n-        match (a, b) {\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) |\n-            (&ReErased, _) |\n-            (_, &ReErased) => {\n-                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n-            }\n-\n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n-            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n-                span_bug!((*self.var_origins.borrow())[v_id.index as usize].span(),\n-                          \"lub_concrete_regions invoked with non-concrete \\\n-                           regions: {:?}, {:?}\",\n-                          a,\n-                          b);\n-            }\n-\n-            (&ReEarlyBound(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        region_rels.region_scope_tree.early_free_scope(self.tcx, br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        region_rels.region_scope_tree.free_scope(self.tcx, fr)\n-                    }\n-                    _ => bug!()\n-                };\n-                let r_id = region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!()\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                self.tcx.types.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                self.tcx.mk_region(ReScope(lub))\n-            }\n-\n-            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReEarlyBound(_)) |\n-            (&ReEarlyBound(_), &ReFree(_)) |\n-            (&ReFree(_), &ReFree(_)) => {\n-                region_rels.lub_free_regions(a, b)\n-            }\n-\n-            // For these types, we cannot define any additional\n-            // relationship:\n-            (&ReSkolemized(..), _) |\n-            (_, &ReSkolemized(..)) => {\n-                if a == b {\n-                    a\n-                } else {\n-                    self.tcx.types.re_static\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum VarValue<'tcx> {\n-    Value(Region<'tcx>),\n-    ErrorValue,\n-}\n-\n-struct RegionAndOrigin<'tcx> {\n-    region: Region<'tcx>,\n-    origin: SubregionOrigin<'tcx>,\n-}\n-\n-type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n-\n-impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n-    fn infer_variable_values(&self,\n-                             region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                             -> Vec<VarValue<'tcx>> {\n-        let mut var_data = self.construct_var_data();\n-\n-        // Dorky hack to cause `dump_constraints` to only get called\n-        // if debug mode is enabled:\n-        debug!(\"----() End constraint listing (context={:?}) {:?}---\",\n-               region_rels.context,\n-               self.dump_constraints(region_rels));\n-        graphviz::maybe_print_constraints_for(self, region_rels);\n-\n-        let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n-        self.expansion(region_rels, &mut var_data);\n-        self.collect_errors(region_rels, &mut var_data, errors);\n-        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n-        var_data\n-    }\n-\n-    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n-        (0..self.num_vars() as usize)\n-            .map(|_| Value(self.tcx.types.re_empty))\n-            .collect()\n-    }\n-\n-    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n-        debug!(\"----() Start constraint listing (context={:?}) ()----\",\n-               free_regions.context);\n-        for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n-            debug!(\"Constraint {} => {:?}\", idx, constraint);\n-        }\n-    }\n-\n-    fn expand_givens(&self, graph: &RegionGraph) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let mut givens = self.givens.borrow_mut();\n-        let seeds: Vec<_> = givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            let seed_index = NodeIndex(vid.index as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0 as u32;\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid { index: succ_index };\n-                    givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn expansion(&self,\n-                 region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                 var_values: &mut [VarValue<'tcx>]) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n-            debug!(\"expansion: constraint={:?} origin={:?}\",\n-                   constraint, origin);\n-            match *constraint {\n-                ConstrainRegSubVar(a_region, b_vid) => {\n-                    let b_data = &mut var_values[b_vid.index as usize];\n-                    self.expand_node(region_rels, a_region, b_vid, b_data)\n-                }\n-                ConstrainVarSubVar(a_vid, b_vid) => {\n-                    match var_values[a_vid.index as usize] {\n-                        ErrorValue => false,\n-                        Value(a_region) => {\n-                            let b_node = &mut var_values[b_vid.index as usize];\n-                            self.expand_node(region_rels, a_region, b_vid, b_node)\n-                        }\n-                    }\n-                }\n-                ConstrainRegSubReg(..) |\n-                ConstrainVarSubReg(..) => {\n-                    // These constraints are checked after expansion\n-                    // is done, in `collect_errors`.\n-                    false\n-                }\n-            }\n-        })\n-    }\n-\n-    fn expand_node(&self,\n-                   region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                   a_region: Region<'tcx>,\n-                   b_vid: RegionVid,\n-                   b_data: &mut VarValue<'tcx>)\n-                   -> bool {\n-        debug!(\"expand_node({:?}, {:?} == {:?})\",\n-               a_region,\n-               b_vid,\n-               b_data);\n-\n-        // Check if this relationship is implied by a given.\n-        match *a_region {\n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(_) => {\n-                if self.givens.borrow().contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match *b_data {\n-            Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n-                if lub == cur_region {\n-                    return false;\n-                }\n-\n-                debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n-                       b_vid,\n-                       cur_region,\n-                       lub);\n-\n-                *b_data = Value(lub);\n-                return true;\n-            }\n-\n-            ErrorValue => {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    /// After expansion is complete, go and check upper bounds (i.e.,\n-    /// cases where the region cannot grow larger than a fixed point)\n-    /// and check that they are satisfied.\n-    fn collect_errors(&self,\n-                      region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                      var_data: &mut Vec<VarValue<'tcx>>,\n-                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        let constraints = self.constraints.borrow();\n-        for (constraint, origin) in constraints.iter() {\n-            debug!(\"collect_errors: constraint={:?} origin={:?}\",\n-                   constraint, origin);\n-            match *constraint {\n-                ConstrainRegSubVar(..) |\n-                ConstrainVarSubVar(..) => {\n-                    // Expansion will ensure that these constraints hold. Ignore.\n-                }\n-\n-                ConstrainRegSubReg(sub, sup) => {\n-                    if region_rels.is_subregion_of(sub, sup) {\n-                        continue;\n-                    }\n-\n-                    debug!(\"collect_errors: region error at {:?}: \\\n-                            cannot verify that {:?} <= {:?}\",\n-                           origin,\n-                           sub,\n-                           sup);\n-\n-                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n-                }\n-\n-                ConstrainVarSubReg(a_vid, b_region) => {\n-                    let a_data = &mut var_data[a_vid.index as usize];\n-                    debug!(\"contraction: {:?} == {:?}, {:?}\",\n-                           a_vid,\n-                           a_data,\n-                           b_region);\n-\n-                    let a_region = match *a_data {\n-                        ErrorValue => continue,\n-                        Value(a_region) => a_region,\n-                    };\n-\n-                    // Do not report these errors immediately:\n-                    // instead, set the variable value to error and\n-                    // collect them later.\n-                    if !region_rels.is_subregion_of(a_region, b_region) {\n-                        debug!(\"collect_errors: region error at {:?}: \\\n-                                cannot verify that {:?}={:?} <= {:?}\",\n-                               origin,\n-                               a_vid,\n-                               a_region,\n-                               b_region);\n-                        *a_data = ErrorValue;\n-                    }\n-                }\n-            }\n-        }\n-\n-        for verify in self.verifys.borrow().iter() {\n-            debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = normalize(self.tcx, var_data, verify.region);\n-\n-            // This was an inference variable which didn't get\n-            // constrained, therefore it can be assume to hold.\n-            if let ty::ReEmpty = *sub {\n-                continue;\n-            }\n-\n-            if verify.bound.is_met(region_rels, var_data, sub) {\n-                continue;\n-            }\n-\n-            debug!(\"collect_errors: region error at {:?}: \\\n-                    cannot verify that {:?} <= {:?}\",\n-                   verify.origin,\n-                   verify.region,\n-                   verify.bound);\n-\n-            errors.push(GenericBoundFailure(verify.origin.clone(),\n-                                            verify.kind.clone(),\n-                                            sub));\n-        }\n-    }\n-\n-    /// Go over the variables that were declared to be error variables\n-    /// and create a `RegionResolutionError` for each of them.\n-    fn collect_var_errors(&self,\n-                          region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                          var_data: &[VarValue<'tcx>],\n-                          graph: &RegionGraph<'tcx>,\n-                          errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        debug!(\"collect_var_errors\");\n-\n-        // This is the best way that I have found to suppress\n-        // duplicate and related errors. Basically we keep a set of\n-        // flags for every node. Whenever an error occurs, we will\n-        // walk some portion of the graph looking to find pairs of\n-        // conflicting regions to report to the user. As we walk, we\n-        // trip the flags from false to true, and if we find that\n-        // we've already reported an error involving any particular\n-        // node we just stop and don't report the current error.  The\n-        // idea is to report errors that derive from independent\n-        // regions of the graph, but not those that derive from\n-        // overlapping locations.\n-        let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n-\n-        for idx in 0..self.num_vars() as usize {\n-            match var_data[idx] {\n-                Value(_) => {\n-                    /* Inference successful */\n-                }\n-                ErrorValue => {\n-                    /* Inference impossible, this value contains\n-                       inconsistent constraints.\n-\n-                       I think that in this case we should report an\n-                       error now---unlike the case above, we can't\n-                       wait to see whether the user needs the result\n-                       of this variable.  The reason is that the mere\n-                       existence of this variable implies that the\n-                       region graph is inconsistent, whether or not it\n-                       is used.\n-\n-                       For example, we may have created a region\n-                       variable that is the GLB of two other regions\n-                       which do not have a GLB.  Even if that variable\n-                       is not used, it implies that those two regions\n-                       *should* have a GLB.\n-\n-                       At least I think this is true. It may be that\n-                       the mere existence of a conflict in a region variable\n-                       that is not used is not a problem, so if this rule\n-                       starts to create problems we'll have to revisit\n-                       this portion of the code and think hard about it. =) */\n-\n-                    let node_vid = RegionVid { index: idx as u32 };\n-                    self.collect_error_for_expanding_node(region_rels,\n-                                                          graph,\n-                                                          &mut dup_vec,\n-                                                          node_vid,\n-                                                          errors);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn construct_graph(&self) -> RegionGraph<'tcx> {\n-        let num_vars = self.num_vars();\n-\n-        let constraints = self.constraints.borrow();\n-\n-        let mut graph = graph::Graph::new();\n-\n-        for _ in 0..num_vars {\n-            graph.add_node(());\n-        }\n-\n-        // Issue #30438: two distinct dummy nodes, one for incoming\n-        // edges (dummy_source) and another for outgoing edges\n-        // (dummy_sink). In `dummy -> a -> b -> dummy`, using one\n-        // dummy node leads one to think (erroneously) there exists a\n-        // path from `b` to `a`. Two dummy nodes sidesteps the issue.\n-        let dummy_source = graph.add_node(());\n-        let dummy_sink = graph.add_node(());\n-\n-        for (constraint, _) in constraints.iter() {\n-            match *constraint {\n-                ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize),\n-                                   NodeIndex(b_id.index as usize),\n-                                   *constraint);\n-                }\n-                ConstrainRegSubVar(_, b_id) => {\n-                    graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n-                }\n-                ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n-                }\n-                ConstrainRegSubReg(..) => {\n-                    // this would be an edge from `dummy_source` to\n-                    // `dummy_sink`; just ignore it.\n-                }\n-            }\n-        }\n-\n-        return graph;\n-    }\n-\n-    fn collect_error_for_expanding_node(&self,\n-                                        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                                        graph: &RegionGraph<'tcx>,\n-                                        dup_vec: &mut [u32],\n-                                        node_idx: RegionVid,\n-                                        errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        // Errors in expanding nodes result from a lower-bound that is\n-        // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) = self.collect_concrete_regions(graph,\n-                                                                          node_idx,\n-                                                                          graph::INCOMING,\n-                                                                          dup_vec);\n-        let (mut upper_bounds, upper_dup) = self.collect_concrete_regions(graph,\n-                                                                          node_idx,\n-                                                                          graph::OUTGOING,\n-                                                                          dup_vec);\n-\n-        if lower_dup || upper_dup {\n-            return;\n-        }\n-\n-        // We place free regions first because we are special casing\n-        // SubSupConflict(ReFree, ReFree) when reporting error, and so\n-        // the user will more likely get a specific suggestion.\n-        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n-            match *x.region {\n-                ReEarlyBound(_) => 0,\n-                ReFree(_) => 1,\n-                _ => 2\n-            }\n-        }\n-        lower_bounds.sort_by_key(region_order_key);\n-        upper_bounds.sort_by_key(region_order_key);\n-\n-        for lower_bound in &lower_bounds {\n-            for upper_bound in &upper_bounds {\n-                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n-                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n-                    debug!(\"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n-                            sup: {:?}\",\n-                           origin,\n-                           node_idx,\n-                           lower_bound.region,\n-                           upper_bound.region);\n-                    errors.push(SubSupConflict(origin,\n-                                               lower_bound.origin.clone(),\n-                                               lower_bound.region,\n-                                               upper_bound.origin.clone(),\n-                                               upper_bound.region));\n-                    return;\n-                }\n-            }\n-        }\n-\n-        span_bug!((*self.var_origins.borrow())[node_idx.index as usize].span(),\n-                  \"collect_error_for_expanding_node() could not find \\\n-                   error for var {:?}, lower_bounds={:?}, \\\n-                   upper_bounds={:?}\",\n-                  node_idx,\n-                  lower_bounds,\n-                  upper_bounds);\n-    }\n-\n-    fn collect_concrete_regions(&self,\n-                                graph: &RegionGraph<'tcx>,\n-                                orig_node_idx: RegionVid,\n-                                dir: Direction,\n-                                dup_vec: &mut [u32])\n-                                -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n-        struct WalkState<'tcx> {\n-            set: FxHashSet<RegionVid>,\n-            stack: Vec<RegionVid>,\n-            result: Vec<RegionAndOrigin<'tcx>>,\n-            dup_found: bool,\n-        }\n-        let mut state = WalkState {\n-            set: FxHashSet(),\n-            stack: vec![orig_node_idx],\n-            result: Vec::new(),\n-            dup_found: false,\n-        };\n-        state.set.insert(orig_node_idx);\n-\n-        // to start off the process, walk the source node in the\n-        // direction specified\n-        process_edges(self, &mut state, graph, orig_node_idx, dir);\n-\n-        while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop().unwrap();\n-\n-            // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index as usize] == u32::MAX {\n-                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n-                state.dup_found = true;\n-            }\n-\n-            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                   orig_node_idx,\n-                   node_idx);\n-\n-            process_edges(self, &mut state, graph, node_idx, dir);\n-        }\n-\n-        let WalkState {result, dup_found, ..} = state;\n-        return (result, dup_found);\n-\n-        fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n-                                         state: &mut WalkState<'tcx>,\n-                                         graph: &RegionGraph<'tcx>,\n-                                         source_vid: RegionVid,\n-                                         dir: Direction) {\n-            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n-\n-            let source_node_index = NodeIndex(source_vid.index as usize);\n-            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n-                match edge.data {\n-                    ConstrainVarSubVar(from_vid, to_vid) => {\n-                        let opp_vid = if from_vid == source_vid {\n-                            to_vid\n-                        } else {\n-                            from_vid\n-                        };\n-                        if state.set.insert(opp_vid) {\n-                            state.stack.push(opp_vid);\n-                        }\n-                    }\n-\n-                    ConstrainRegSubVar(region, _) |\n-                    ConstrainVarSubReg(_, region) => {\n-                        state.result.push(RegionAndOrigin {\n-                            region,\n-                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n-                        });\n-                    }\n-\n-                    ConstrainRegSubReg(..) => {\n-                        panic!(\"cannot reach reg-sub-reg edge in region inference \\\n-                                post-processing\")\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool\n-    {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, origin) in self.constraints.borrow().iter() {\n-                let edge_changed = body(constraint, origin);\n-                if edge_changed {\n-                    debug!(\"Updated due to constraint {:?}\", constraint);\n-                    changed = true;\n-                }\n-            }\n-        }\n-        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n-    }\n-\n-}\n-\n-fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             values: &Vec<VarValue<'tcx>>,\n-                             r: ty::Region<'tcx>)\n-                             -> ty::Region<'tcx> {\n-    match *r {\n-        ty::ReVar(rid) => lookup(tcx, values, rid),\n-        _ => r,\n-    }\n-}\n-\n-fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                          values: &Vec<VarValue<'tcx>>,\n-                          rid: ty::RegionVid)\n-                          -> ty::Region<'tcx> {\n-    match values[rid.index as usize] {\n-        Value(r) => r,\n-        ErrorValue => tcx.types.re_static, // Previously reported error.\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n-    }\n-}\n-\n-impl fmt::Debug for RegionSnapshot {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionSnapshot(length={},skolemization={})\",\n-               self.length, self.skolemization_count)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n-            GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for GenericKind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            GenericKind::Param(ref p) => write!(f, \"{}\", p),\n-            GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n-        match self {\n-            &VerifyBound::AnyRegion(ref rs) |\n-            &VerifyBound::AllRegions(ref rs) => for &r in rs {\n-                f(r);\n-            },\n-\n-            &VerifyBound::AnyBound(ref bs) |\n-            &VerifyBound::AllBounds(ref bs) => for b in bs {\n-                b.for_each_region(f);\n-            },\n-        }\n-    }\n-\n-    pub fn must_hold(&self) -> bool {\n-        match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n-            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n-        }\n-    }\n-\n-    pub fn cannot_hold(&self) -> bool {\n-        match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n-        }\n-    }\n-\n-    pub fn or(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n-        if self.must_hold() || vb.cannot_hold() {\n-            self\n-        } else if self.cannot_hold() || vb.must_hold() {\n-            vb\n-        } else {\n-            VerifyBound::AnyBound(vec![self, vb])\n-        }\n-    }\n-\n-    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n-        if self.must_hold() && vb.must_hold() {\n-            self\n-        } else if self.cannot_hold() && vb.cannot_hold() {\n-            self\n-        } else {\n-            VerifyBound::AllBounds(vec![self, vb])\n-        }\n-    }\n-\n-    fn is_met(&self,\n-              region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-              var_values: &Vec<VarValue<'tcx>>,\n-              min: ty::Region<'tcx>)\n-              -> bool {\n-        let tcx = region_rels.tcx;\n-        match self {\n-            &VerifyBound::AnyRegion(ref rs) =>\n-                rs.iter()\n-                  .map(|&r| normalize(tcx, var_values, r))\n-                  .any(|r| region_rels.is_subregion_of(min, r)),\n-\n-            &VerifyBound::AllRegions(ref rs) =>\n-                rs.iter()\n-                  .map(|&r| normalize(tcx, var_values, r))\n-                  .all(|r| region_rels.is_subregion_of(min, r)),\n-\n-            &VerifyBound::AnyBound(ref bs) =>\n-                bs.iter()\n-                  .any(|b| b.is_met(region_rels, var_values, min)),\n-\n-            &VerifyBound::AllBounds(ref bs) =>\n-                bs.iter()\n-                  .all(|b| b.is_met(region_rels, var_values, min)),\n-        }\n-    }\n-}"}, {"sha": "5e70c0ce368fc667c6d1915d9b06eccef0c56cea", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -74,8 +74,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n-            _ => r,\n+            ty::ReVar(rid) =>\n+                self.infcx.borrow_region_constraints()\n+                          .opportunistic_resolve_var(self.tcx(), rid),\n+            _ =>\n+                r,\n         }\n     }\n }\n@@ -185,7 +188,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n+            ty::ReVar(rid) => self.infcx.lexical_region_resolutions\n+                                        .borrow()\n+                                        .as_ref()\n+                                        .expect(\"region resolution not performed\")\n+                                        .resolve_var(rid),\n             _ => r,\n         }\n     }"}, {"sha": "f891f692c7d8208a356ef698eb5ec0f5d4b2a0dd", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -137,7 +137,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n-        self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+        self.fields.infcx.borrow_region_constraints()\n+                         .make_subregion(origin, a, b);\n \n         Ok(a)\n     }"}, {"sha": "5e9019c92c5b73be37503504310f8b5eb5c04de6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -45,17 +45,21 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n #![feature(i128_type)]\n+#![feature(match_default_bindings)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(nonzero)]\n #![feature(quote)]\n+#![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n+#![feature(underscore_lifetimes)]\n #![feature(trace_macros)]\n #![feature(test)]\n #![feature(const_atomic_bool_new)]"}, {"sha": "75446586365dda63e200b1d3f50e52adc7b9b4be", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -161,12 +161,6 @@ declare_lint! {\n     \"patterns in functions without body were erroneously allowed\"\n }\n \n-declare_lint! {\n-    pub EXTRA_REQUIREMENT_IN_IMPL,\n-    Deny,\n-    \"detects extra requirements in impls that were erroneously allowed\"\n-}\n-\n declare_lint! {\n     pub LEGACY_DIRECTORY_OWNERSHIP,\n     Deny,\n@@ -254,7 +248,6 @@ impl LintPass for HardwiredLints {\n             RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n-            EXTRA_REQUIREMENT_IN_IMPL,\n             LEGACY_DIRECTORY_OWNERSHIP,\n             LEGACY_IMPORTS,\n             LEGACY_CONSTRUCTOR_VISIBILITY,"}, {"sha": "da505f167241b812e6acdad32e1fa528a1f123be", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     ///\n     /// if `r_a` represents `'a`, this function would return `{'b, 'c}`.\n     pub fn regions_that_outlive<'a, 'gcx>(&self, r_a: Region<'tcx>) -> Vec<&Region<'tcx>> {\n-        assert!(is_free(r_a));\n+        assert!(is_free(r_a) || *r_a == ty::ReStatic);\n         self.relation.greater_than(&r_a)\n     }\n }"}, {"sha": "d3aa80e5585e287410f3db4d9c860c7c7b81fa70", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -12,7 +12,7 @@\n //! the parent links in the region hierarchy.\n //!\n //! Most of the documentation on regions can be found in\n-//! `middle/infer/region_inference/README.md`\n+//! `middle/infer/region_constraints/README.md`\n \n use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -320,7 +320,7 @@ pub struct ScopeTree {\n     /// hierarchy based on their lexical mapping. This is used to\n     /// handle the relationships between regions in a fn and in a\n     /// closure defined by that fn. See the \"Modeling closures\"\n-    /// section of the README in infer::region_inference for\n+    /// section of the README in infer::region_constraints for\n     /// more details.\n     closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n \n@@ -407,7 +407,7 @@ pub struct Context {\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n     /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in infer::region_inference for more\n+    /// the README in infer::region_constraints for more\n     /// details.\n     root_id: Option<hir::ItemLocalId>,\n \n@@ -646,7 +646,7 @@ impl<'tcx> ScopeTree {\n             // different functions.  Compare those fn for lexical\n             // nesting. The reasoning behind this is subtle.  See the\n             // \"Modeling closures\" section of the README in\n-            // infer::region_inference for more details.\n+            // infer::region_constraints for more details.\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope.data(), b_root_scope.data()) {"}, {"sha": "bea273c84a92e20ab28b328119203a715880614b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -555,6 +555,15 @@ pub struct UpvarDecl {\n \n newtype_index!(BasicBlock { DEBUG_FORMAT = \"bb{}\" });\n \n+impl BasicBlock {\n+    pub fn start_location(self) -> Location {\n+        Location {\n+            block: self,\n+            statement_index: 0,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n@@ -638,7 +647,32 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>\n     },\n \n-    /// Drop the Lvalue and assign the new value over it\n+    /// Drop the Lvalue and assign the new value over it. This ensures\n+    /// that the assignment to LV occurs *even if* the destructor for\n+    /// lvalue unwinds. Its semantics are best explained by by the\n+    /// elaboration:\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   DropAndReplace(LV <- RV, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   Drop(LV, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // LV is now unitialized\n+    ///   LV <- RV\n+    /// }\n+    /// BB2 {\n+    ///   // LV is now unitialized -- its dtor panicked\n+    ///   LV <- RV\n+    /// }\n+    /// ```\n     DropAndReplace {\n         location: Lvalue<'tcx>,\n         value: Operand<'tcx>,"}, {"sha": "b09ab8da7c12def4176b708fe4877551ffcdca65", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -292,11 +292,10 @@ macro_rules! make_mir_visitor {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                let lookup = TyContext::SourceInfo(SourceInfo {\n+                self.visit_ty(&$($mutability)* mir.return_ty, TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n-                });\n-                self.visit_ty(&$($mutability)* mir.return_ty, lookup);\n+                }));\n \n                 for local in mir.local_decls.indices() {\n                     self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n@@ -811,7 +810,7 @@ make_mir_visitor!(MutVisitor,mut);\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting.\n@@ -821,9 +820,11 @@ pub enum TyContext {\n         source_info: SourceInfo,\n     },\n \n-    Location(Location),\n+    /// The return type of the function.\n+    ReturnTy(SourceInfo),\n \n-    SourceInfo(SourceInfo),\n+    /// A type found at some location.\n+    Location(Location),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "7c38cf75b8d5a4f6bd457b84027c4488d1edd86c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -33,7 +33,6 @@ use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use middle::const_val;\n-use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n use syntax::ast;\n use session::DiagnosticMessageId;\n@@ -481,30 +480,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                         item_name: ast::Name,\n                                         _impl_item_def_id: DefId,\n                                         trait_item_def_id: DefId,\n-                                        requirement: &fmt::Display,\n-                                        lint_id: Option<ast::NodeId>) // (*)\n+                                        requirement: &fmt::Display)\n                                         -> DiagnosticBuilder<'tcx>\n     {\n-        // (*) This parameter is temporary and used only for phasing\n-        // in the bug fix to #18937. If it is `Some`, it has a kind of\n-        // weird effect -- the diagnostic is reported as a lint, and\n-        // the builder which is returned is marked as canceled.\n-\n         let msg = \"impl has stricter requirements than trait\";\n-        let mut err = match lint_id {\n-            Some(node_id) => {\n-                self.tcx.struct_span_lint_node(EXTRA_REQUIREMENT_IN_IMPL,\n-                                               node_id,\n-                                               error_span,\n-                                               msg)\n-            }\n-            None => {\n-                struct_span_err!(self.tcx.sess,\n-                                 error_span,\n-                                 E0276,\n-                                 \"{}\", msg)\n-            }\n-        };\n+        let mut err = struct_span_err!(self.tcx.sess,\n+                                       error_span,\n+                                       E0276,\n+                                       \"{}\", msg);\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.codemap().def_span(trait_item_span);\n@@ -543,15 +526,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n                 if let ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name, impl_item_def_id, trait_item_def_id, lint_id\n+                    item_name, impl_item_def_id, trait_item_def_id,\n                 } = obligation.cause.code {\n                     self.report_extra_impl_obligation(\n                         span,\n                         item_name,\n                         impl_item_def_id,\n                         trait_item_def_id,\n-                        &format!(\"`{}`\", obligation.predicate),\n-                        lint_id)\n+                        &format!(\"`{}`\", obligation.predicate))\n                         .emit();\n                     return;\n                 }"}, {"sha": "297feead61760f6a734aed7b02fb406f6dac5ca3", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 22, "deletions": 94, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{InferCtxt, InferOk};\n+use infer::{RegionObligation, InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n-use syntax::ast;\n-use util::nodemap::NodeMap;\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n@@ -48,39 +46,6 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n-\n-    // A set of constraints that regionck must validate. Each\n-    // constraint has the form `T:'a`, meaning \"some type `T` must\n-    // outlive the lifetime 'a\". These constraints derive from\n-    // instantiated type parameters. So if you had a struct defined\n-    // like\n-    //\n-    //     struct Foo<T:'static> { ... }\n-    //\n-    // then in some expression `let x = Foo { ... }` it will\n-    // instantiate the type parameter `T` with a fresh type `$0`. At\n-    // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck. (We\n-    // can't generally check these things right away because we have\n-    // to wait until types are resolved.)\n-    //\n-    // These are stored in a map keyed to the id of the innermost\n-    // enclosing fn body / static initializer expression. This is\n-    // because the location where the obligation was incurred can be\n-    // relevant with respect to which sublifetime assumptions are in\n-    // place. The reason that we store under the fn-id, and not\n-    // something more fine-grained, is so that it is easier for\n-    // regionck to be sure that it has found *all* the region\n-    // obligations (otherwise, it's easy to fail to walk to a\n-    // particular node-id).\n-    region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-}\n-\n-#[derive(Clone)]\n-pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region<'tcx>,\n-    pub sup_type: Ty<'tcx>,\n-    pub cause: ObligationCause<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n@@ -94,7 +59,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            region_obligations: NodeMap(),\n         }\n     }\n \n@@ -157,14 +121,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_region_obligation(&mut self,\n-                                      t_a: Ty<'tcx>,\n-                                      r_b: ty::Region<'tcx>,\n-                                      cause: ObligationCause<'tcx>)\n-    {\n-        register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n-    }\n-\n     pub fn register_predicate_obligation(&mut self,\n                                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          obligation: PredicateObligation<'tcx>)\n@@ -183,26 +139,16 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations(&mut self,\n-                                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                          obligations: Vec<PredicateObligation<'tcx>>)\n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n     {\n         for obligation in obligations {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n     }\n \n-\n-    pub fn region_obligations(&self,\n-                              body_id: ast::NodeId)\n-                              -> &[RegionObligation<'tcx>]\n-    {\n-        match self.region_obligations.get(&body_id) {\n-            None => Default::default(),\n-            Some(vec) => vec,\n-        }\n-    }\n-\n     pub fn select_all_or_error(&mut self,\n                                infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                -> Result<(),Vec<FulfillmentError<'tcx>>>\n@@ -245,10 +191,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                region_obligations: &mut self.region_obligations,\n-            });\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n@@ -277,7 +220,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n-    region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -288,9 +230,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n     {\n-        process_predicate(self.selcx,\n-                          obligation,\n-                          self.region_obligations)\n+        process_predicate(self.selcx, obligation)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -329,8 +269,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Err` if the predicate does not hold\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -452,18 +391,26 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             let r_static = selcx.tcx().types.re_static;\n-                            register_region_obligation(t_a, r_static,\n-                                                       obligation.cause.clone(),\n-                                                       region_obligations);\n+                            selcx.infcx().register_region_obligation(\n+                                obligation.cause.body_id,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_static,\n+                                    cause: obligation.cause.clone(),\n+                                });\n                             Ok(Some(vec![]))\n                         }\n                     }\n                 }\n                 // If there aren't, register the obligation.\n                 Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    register_region_obligation(t_a, r_b,\n-                                               obligation.cause.clone(),\n-                                               region_obligations);\n+                    selcx.infcx().register_region_obligation(\n+                        obligation.cause.body_id,\n+                        RegionObligation {\n+                            sup_type: t_a,\n+                            sub_region: r_b,\n+                            cause: obligation.cause.clone()\n+                        });\n                     Ok(Some(vec![]))\n                 }\n             }\n@@ -566,25 +513,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     }\n }\n \n-\n-fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: ty::Region<'tcx>,\n-                                    cause: ObligationCause<'tcx>,\n-                                    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n-{\n-    let region_obligation = RegionObligation { sup_type: t_a,\n-                                               sub_region: r_b,\n-                                               cause: cause };\n-\n-    debug!(\"register_region_obligation({:?}, cause={:?})\",\n-           region_obligation, region_obligation.cause);\n-\n-    region_obligations.entry(region_obligation.cause.body_id)\n-                      .or_insert(vec![])\n-                      .push(region_obligation);\n-\n-}\n-\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n     -> FulfillmentError<'tcx>"}, {"sha": "55b1a913f0d1de6da737053e7b7edd95ff6ed97e", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::fulfill::FulfillmentContext;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n@@ -152,7 +152,6 @@ pub enum ObligationCauseCode<'tcx> {\n         item_name: ast::Name,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n-        lint_id: Option<ast::NodeId>,\n     },\n \n     /// Checking that this expression can be assigned where it needs to be\n@@ -537,6 +536,17 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let region_scope_tree = region::ScopeTree::default();\n         let free_regions = FreeRegionMap::new();\n+\n+        // FIXME. We should really... do something with these region\n+        // obligations. But this call just continues the older\n+        // behavior (i.e., doesn't cause any new bugs), and it would\n+        // take some further refactoring to actually solve them. In\n+        // particular, we would have to handle implied bounds\n+        // properly, and that code is currently largely confined to\n+        // regionck (though I made some efforts to extract it\n+        // out). -nmatsakis\n+        let _ = infcx.ignore_region_obligations();\n+\n         infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,"}, {"sha": "9231995018065fd941c0435976cd9579fa3a95d9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -26,13 +26,6 @@ impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n-    }\n-}\n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Obligation(predicate={:?},depth={})\",\n@@ -221,13 +214,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             }\n             super::CompareImplMethodObligation { item_name,\n                                                  impl_item_def_id,\n-                                                 trait_item_def_id,\n-                                                 lint_id } => {\n+                                                 trait_item_def_id } => {\n                 Some(super::CompareImplMethodObligation {\n                     item_name,\n                     impl_item_def_id,\n                     trait_item_def_id,\n-                    lint_id,\n                 })\n             }\n             super::ExprAssignable => Some(super::ExprAssignable),"}, {"sha": "a9efb042f3d8cf2aebd086981fe005197194661e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -144,6 +144,15 @@ pub enum AssociatedItemContainer {\n }\n \n impl AssociatedItemContainer {\n+    /// Asserts that this is the def-id of an associated item declared\n+    /// in a trait, and returns the trait def-id.\n+    pub fn assert_trait(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            _ => bug!(\"associated item has wrong container type: {:?}\", self)\n+        }\n+    }\n+\n     pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -895,6 +904,12 @@ pub enum Predicate<'tcx> {\n     ConstEvaluatable(DefId, &'tcx Substs<'tcx>),\n }\n \n+impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n+    fn as_ref(&self) -> &Predicate<'tcx> {\n+        self\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n@@ -1200,6 +1215,25 @@ impl<'tcx> Predicate<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        match *self {\n+            Predicate::TypeOutlives(data) => {\n+                Some(data)\n+            }\n+            Predicate::Trait(..) |\n+            Predicate::Projection(..) |\n+            Predicate::Equate(..) |\n+            Predicate::Subtype(..) |\n+            Predicate::RegionOutlives(..) |\n+            Predicate::WellFormed(..) |\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n+            Predicate::ConstEvaluatable(..) => {\n+                None\n+            }\n+        }\n+    }\n }\n \n /// Represents the bounds declared on a particular set of type"}, {"sha": "65406c3d16cc579abbd2b71d83f1961108c6288b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::DefId;\n \n use middle::const_val::ConstVal;\n use middle::region;\n+use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n@@ -898,6 +899,18 @@ pub struct RegionVid {\n     pub index: u32,\n }\n \n+// FIXME: We could convert this to use `newtype_index!`\n+impl Idx for RegionVid {\n+    fn new(value: usize) -> Self {\n+        assert!(value < ::std::u32::MAX as usize);\n+        RegionVid { index: value as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub struct SkolemizedRegionVid {\n     pub index: u32,\n@@ -1037,6 +1050,35 @@ impl RegionKind {\n \n         flags\n     }\n+\n+    /// Given an early-bound or free region, returns the def-id where it was bound.\n+    /// For example, consider the regions in this snippet of code:\n+    ///\n+    /// ```\n+    /// impl<'a> Foo {\n+    ///      ^^ -- early bound, declared on an impl\n+    ///\n+    ///     fn bar<'b, 'c>(x: &self, y: &'b u32, z: &'c u64) where 'static: 'c\n+    ///            ^^  ^^     ^ anonymous, late-bound\n+    ///            |   early-bound, appears in where-clauses\n+    ///            late-bound, appears only in fn args\n+    ///     {..}\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, `free_region_binding_scope('a)` would return the def-id\n+    /// of the impl, and for all the other highlighted regions, it\n+    /// would return the def-id of the function. In other cases (not shown), this\n+    /// function might return the def-id of a closure.\n+    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_, '_>) -> DefId {\n+        match self {\n+            ty::ReEarlyBound(br) => {\n+                tcx.parent_def_id(br.def_id).unwrap()\n+            }\n+            ty::ReFree(fr) => fr.scope,\n+            _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n+        }\n+    }\n }\n \n /// Type utilities"}, {"sha": "e2f50c8c8891b9cae470e6d1d60dae0d60584aa6", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -384,6 +384,11 @@ impl<I: Idx, T> IndexVec<I, T> {\n         idx\n     }\n \n+    #[inline]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.raw.pop()\n+    }\n+\n     #[inline]\n     pub fn len(&self) -> usize {\n         self.raw.len()\n@@ -411,7 +416,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn iter_enumerated(&self) -> Enumerated<I, slice::Iter<T>>\n+    pub fn iter_enumerated(&self) -> Enumerated<I, slice::Iter<'_, T>>\n     {\n         self.raw.iter().enumerate().map(IntoIdx { _marker: PhantomData })\n     }\n@@ -427,7 +432,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn iter_enumerated_mut(&mut self) -> Enumerated<I, slice::IterMut<T>>\n+    pub fn iter_enumerated_mut(&mut self) -> Enumerated<I, slice::IterMut<'_, T>>\n     {\n         self.raw.iter_mut().enumerate().map(IntoIdx { _marker: PhantomData })\n     }"}, {"sha": "8862ba3545eba2c5964529ec4c92085781a3ca4b", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -31,6 +31,7 @@\n #![feature(i128)]\n #![feature(conservative_impl_trait)]\n #![feature(specialization)]\n+#![feature(underscore_lifetimes)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "97c34a1c30275e12414b1f6b48b7d25d8dd272f6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -207,10 +207,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n             reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(EXTRA_REQUIREMENT_IN_IMPL),\n-            reference: \"issue #37166 <https://github.com/rust-lang/rust/issues/37166>\",\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n             reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n@@ -276,4 +272,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/36891\");\n     store.register_removed(\"lifetime_underscore\",\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/36892\");\n+    store.register_removed(\"extra_requirement_in_impl\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/37166\");\n }"}, {"sha": "f5f7b53a23577c3a545e7e8c4fa638cdd2d55ba0", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -112,7 +112,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let opt_regioncx = if !tcx.sess.opts.debugging_opts.nll {\n         None\n     } else {\n-        Some(nll::compute_regions(infcx, def_id, mir))\n+        Some(nll::compute_regions(infcx, def_id, param_env, mir))\n     };\n \n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n@@ -136,7 +136,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         node_id: id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n-        fake_infer_ctxt: &infcx,\n     };\n \n     let mut state = InProgress::new(flow_borrows,\n@@ -148,13 +147,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n #[allow(dead_code)]\n-pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'b Mir<'tcx>,\n+pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    mir: &'cx Mir<'tcx>,\n     node_id: ast::NodeId,\n-    move_data: &'b MoveData<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n+    move_data: &'cx MoveData<'tcx>,\n+    param_env: ParamEnv<'gcx>,\n }\n \n // (forced to be `pub` due to its use as an associated type below.)\n@@ -177,12 +175,10 @@ struct FlowInProgress<BD> where BD: BitDenotation {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'tcx>\n-    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n-{\n-    type FlowState = InProgress<'b, 'gcx, 'tcx>;\n+impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    type FlowState = InProgress<'cx, 'gcx, 'tcx>;\n \n-    fn mir(&self) -> &'b Mir<'tcx> { self.mir }\n+    fn mir(&self) -> &'cx Mir<'tcx> { self.mir }\n \n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n@@ -437,12 +433,12 @@ enum WriteKind {\n     Move,\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn access_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n \n         let (sd, rw) = kind;\n \n@@ -501,7 +497,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: ShallowOrDeep,\n                      mode: MutateMode,\n-                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n@@ -522,7 +518,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                       context: Context,\n                       (rvalue, span): (&Rvalue<'tcx>, Span),\n                       _location: Location,\n-                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n                 let access_kind = match bk {\n@@ -579,7 +575,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                        context: Context,\n                        consume_via_drop: ConsumeKind,\n                        (operand, span): (&Operand<'tcx>, Span),\n-                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                       flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         match *operand {\n             Operand::Consume(ref lvalue) => {\n                 self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n@@ -592,11 +588,22 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                       context: Context,\n                       consume_via_drop: ConsumeKind,\n                       lvalue_span: (&Lvalue<'tcx>, Span),\n-                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let lvalue = lvalue_span.0;\n+\n         let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        let moves_by_default =\n-            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n+\n+        // Erase the regions in type before checking whether it moves by\n+        // default. There are a few reasons to do this:\n+        //\n+        // - They should not affect the result.\n+        // - It avoids adding new region constraints into the surrounding context,\n+        //   which would trigger an ICE, since the infcx will have been \"frozen\" by\n+        //   the NLL region context.\n+        let gcx = self.tcx.global_tcx();\n+        let erased_ty = gcx.lift(&self.tcx.erase_regions(&ty)).unwrap();\n+        let moves_by_default = erased_ty.moves_by_default(gcx, self.param_env, DUMMY_SP);\n+\n         if moves_by_default {\n             // move of lvalue: check if this is move of already borrowed path\n             self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)), flow_state);\n@@ -619,11 +626,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(&mut self,\n                                                 context: Context,\n                                                 (lvalue, span): (&Lvalue<'tcx>, Span),\n-                                                flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                                                flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n@@ -674,7 +681,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                               context: Context,\n                               desired_action: &str,\n                               lvalue_span: (&Lvalue<'tcx>, Span),\n-                              flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                              flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path ... but is that what we want here?\n         let lvalue = self.base_path(lvalue_span.0);\n@@ -802,7 +809,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn check_if_assigned_path_is_moved(&mut self,\n                                        context: Context,\n                                        (lvalue, span): (&Lvalue<'tcx>, Span),\n-                                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n+                                       flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n         let mut lvalue = lvalue;\n         loop {\n@@ -1015,11 +1022,11 @@ enum NoMovePathFound {\n     ReachedStatic,\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n                                      access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n-                                     flow_state: &InProgress<'b, 'gcx, 'tcx>,\n+                                     flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n                                      mut op: F)\n         where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue<'tcx>) -> Control\n     {\n@@ -1119,11 +1126,11 @@ mod prefixes {\n     }\n \n \n-    pub(super) struct Prefixes<'c, 'gcx: 'tcx, 'tcx: 'c> {\n-        mir: &'c Mir<'tcx>,\n-        tcx: TyCtxt<'c, 'gcx, 'tcx>,\n+    pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+        mir: &'cx Mir<'tcx>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         kind: PrefixSet,\n-        next: Option<&'c Lvalue<'tcx>>,\n+        next: Option<&'cx Lvalue<'tcx>>,\n     }\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -1137,21 +1144,21 @@ mod prefixes {\n         Supporting,\n     }\n \n-    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         /// Returns an iterator over the prefixes of `lvalue`\n         /// (inclusive) from longest to smallest, potentially\n         /// terminating the iteration early based on `kind`.\n-        pub(super) fn prefixes<'d>(&self,\n-                                   lvalue: &'d Lvalue<'tcx>,\n-                                   kind: PrefixSet)\n-                                   -> Prefixes<'d, 'gcx, 'tcx> where 'b: 'd\n+        pub(super) fn prefixes(&self,\n+                               lvalue: &'cx Lvalue<'tcx>,\n+                               kind: PrefixSet)\n+                               -> Prefixes<'cx, 'gcx, 'tcx>\n         {\n             Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n         }\n     }\n \n-    impl<'c, 'gcx, 'tcx> Iterator for Prefixes<'c, 'gcx, 'tcx> {\n-        type Item = &'c Lvalue<'tcx>;\n+    impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n+        type Item = &'cx Lvalue<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n             let mut cursor = match self.next {\n                 None => return None,\n@@ -1244,7 +1251,7 @@ mod prefixes {\n     }\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: &str,\n@@ -1483,7 +1490,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // End-user visible description of `lvalue`\n     fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> String {\n         let mut buf = String::new();\n@@ -1641,7 +1648,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // FIXME (#16118): function intended to allow the borrow checker\n     // to be less precise in its handling of Box while still allowing\n     // moves out of a Box. They should be removed when/if we stop"}, {"sha": "2e4dddc212b31cc051f2c1fed63008146cca239f", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n pub use dataflow::indexes::BorrowIndex;\n use transform::nll::region_infer::RegionInferenceContext;\n-use transform::nll::ToRegionIndex;\n+use transform::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                            location: Location) {\n         if let Some(regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n-                let borrow_region = borrow_data.region.to_region_index();\n+                let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n                     // The region checker really considers the borrow\n                     // to start at the point **after** the location of"}, {"sha": "af309342dc522af1edc9b58d0cf0de0940e3d48c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n #![feature(i128_type)]\n+#![feature(match_default_bindings)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n #![feature(collection_placement)]"}, {"sha": "1f905d32f84e84b751ba6f773e7950f0fef2c116", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 17, "deletions": 54, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::mir::{BasicBlock, BorrowKind, Location, Lvalue, Mir, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Location, Lvalue, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Lvalue::Projection;\n use rustc::mir::{LvalueProjection, ProjectionElem};\n@@ -21,9 +21,8 @@ use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n \n-use super::subtype;\n use super::LivenessResults;\n-use super::ToRegionIndex;\n+use super::ToRegionVid;\n use super::region_infer::RegionInferenceContext;\n \n pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n@@ -102,7 +101,7 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         self.infcx\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n-                let vid = live_region.to_region_index();\n+                let vid = live_region.to_region_vid();\n                 self.regioncx.add_live_point(vid, location);\n             });\n     }\n@@ -179,29 +178,6 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         self.visit_mir(self.mir);\n     }\n \n-    fn add_borrow_constraint(\n-        &mut self,\n-        location: Location,\n-        destination_lv: &Lvalue<'tcx>,\n-        borrow_region: ty::Region<'tcx>,\n-        _borrow_kind: BorrowKind,\n-        _borrowed_lv: &Lvalue<'tcx>,\n-    ) {\n-        let tcx = self.infcx.tcx;\n-        let span = self.mir.source_info(location).span;\n-        let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n-\n-        let destination_region = match destination_ty.sty {\n-            ty::TyRef(r, _) => r,\n-            _ => bug!()\n-        };\n-\n-        self.regioncx.add_outlives(span,\n-                                   borrow_region.to_region_index(),\n-                                   destination_region.to_region_index(),\n-                                   location.successor_within_block());\n-    }\n-\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,\n@@ -227,8 +203,8 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n \n                     let span = self.mir.source_info(location).span;\n                     self.regioncx.add_outlives(span,\n-                                               base_region.to_region_index(),\n-                                               borrow_region.to_region_index(),\n+                                               base_region.to_region_vid(),\n+                                               borrow_region.to_region_vid(),\n                                                location.successor_within_block());\n                 }\n             }\n@@ -237,35 +213,22 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &Statement<'tcx>,\n-                       location: Location) {\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n \n-        debug!(\"visit_statement(statement={:?}, location={:?})\", statement, location);\n-\n-        // Look for a statement like:\n+        // Look for an rvalue like:\n         //\n-        //     D = & L\n+        //     & L\n         //\n-        // where D is the path to which we are assigning, and\n-        // L is the path that is borrowed.\n-        if let StatementKind::Assign(ref destination_lv, ref rv) = statement.kind {\n-            if let Rvalue::Ref(region, bk, ref borrowed_lv) = *rv {\n-                self.add_borrow_constraint(location, destination_lv, region, bk, borrowed_lv);\n-                self.add_reborrow_constraint(location, region, borrowed_lv);\n-            }\n-\n-            let tcx = self.infcx.tcx;\n-            let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n-            let rv_ty = rv.ty(self.mir, tcx);\n-\n-            let span = self.mir.source_info(location).span;\n-            for (a, b) in subtype::outlives_pairs(tcx, rv_ty, destination_ty) {\n-                self.regioncx.add_outlives(span, a, b, location.successor_within_block());\n-            }\n+        // where L is the path that is borrowed. In that case, we have\n+        // to add the reborrow constraints (which don't fall out\n+        // naturally from the type-checker).\n+        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n+            self.add_reborrow_constraint(location, region, borrowed_lv);\n         }\n \n-        self.super_statement(block, statement, location);\n+        self.super_rvalue(rvalue, location);\n     }\n }"}, {"sha": "92a8a714d525a09a369a08f55167c77879613f00", "filename": "src/librustc_mir/transform/nll/free_regions.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -25,17 +25,18 @@\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::ty;\n+use rustc::ty::{self, RegionVid};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n \n #[derive(Debug)]\n pub struct FreeRegions<'tcx> {\n     /// Given a free region defined on this function (either early- or\n-    /// late-bound), this maps it to its internal region index. The\n-    /// corresponding variable will be \"capped\" so that it cannot\n-    /// grow.\n-    pub indices: FxHashMap<ty::Region<'tcx>, usize>,\n+    /// late-bound), this maps it to its internal region index. When\n+    /// the region context is created, the first N variables will be\n+    /// created based on these indices.\n+    pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n \n     /// The map from the typeck tables telling us how to relate free regions.\n     pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n@@ -49,6 +50,9 @@ pub fn free_regions<'a, 'gcx, 'tcx>(\n \n     let mut indices = FxHashMap();\n \n+    // `'static` is always free.\n+    insert_free_region(&mut indices, infcx.tcx.types.re_static);\n+\n     // Extract the early regions.\n     let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n     for item_subst in item_substs {\n@@ -78,9 +82,9 @@ pub fn free_regions<'a, 'gcx, 'tcx>(\n }\n \n fn insert_free_region<'tcx>(\n-    free_regions: &mut FxHashMap<ty::Region<'tcx>, usize>,\n+    free_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n     region: ty::Region<'tcx>,\n ) {\n-    let len = free_regions.len();\n-    free_regions.entry(region).or_insert(len);\n+    let next = RegionVid::new(free_regions.len());\n+    free_regions.entry(region).or_insert(next);\n }"}, {"sha": "147f061ad113f52509fb0368bf5cda605473a545", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -11,19 +11,19 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n use rustc::infer::InferCtxt;\n-use rustc::ty::{self, RegionKind};\n+use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use std::collections::BTreeSet;\n use transform::MirSource;\n+use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+mod subtype_constraint_generation;\n mod free_regions;\n-mod subtype;\n \n pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n@@ -36,13 +36,24 @@ mod renumber;\n pub fn compute_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     def_id: DefId,\n+    param_env: ty::ParamEnv<'gcx>,\n     mir: &mut Mir<'tcx>,\n ) -> RegionInferenceContext<'tcx> {\n     // Compute named region information.\n     let free_regions = &free_regions::free_regions(infcx, def_id);\n \n     // Replace all regions with fresh inference variables.\n-    let num_region_variables = renumber::renumber_mir(infcx, free_regions, mir);\n+    renumber::renumber_mir(infcx, free_regions, mir);\n+\n+    // Run the MIR type-checker.\n+    let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+    let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n+\n+    // Create the region inference context, taking ownership of the region inference\n+    // data that was contained in `infcx`.\n+    let var_origins = infcx.take_region_var_origins();\n+    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, free_regions, mir, constraint_sets);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -63,11 +74,10 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n         ),\n     };\n \n-    // Create the region inference context, generate the constraints,\n-    // and then solve them.\n-    let mut regioncx = RegionInferenceContext::new(free_regions, num_region_variables, mir);\n-    let param_env = infcx.tcx.param_env(def_id);\n+    // Generate non-subtyping constraints.\n     constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, param_env, liveness);\n+\n+    // Solve the region constraints.\n     regioncx.solve(infcx, &mir);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -123,12 +133,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(\n-                    out,\n-                    \"| {:?}: {:?}\",\n-                    region,\n-                    regioncx.region_value(region)\n-                )?;\n+                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n             },\n \n             // Before each basic block, dump out the values\n@@ -152,23 +157,19 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     });\n }\n \n-newtype_index!(RegionIndex {\n-    DEBUG_FORMAT = \"'_#{}r\",\n-});\n-\n /// Right now, we piggy back on the `ReVar` to store our NLL inference\n-/// regions. These are indexed with `RegionIndex`. This method will\n-/// assert that the region is a `ReVar` and convert the internal index\n-/// into a `RegionIndex`. This is reasonable because in our MIR we\n-/// replace all free regions with inference variables.\n-pub trait ToRegionIndex {\n-    fn to_region_index(&self) -> RegionIndex;\n+/// regions. These are indexed with `RegionVid`. This method will\n+/// assert that the region is a `ReVar` and extract its interal index.\n+/// This is reasonable because in our MIR we replace all free regions\n+/// with inference variables.\n+pub trait ToRegionVid {\n+    fn to_region_vid(&self) -> RegionVid;\n }\n \n-impl ToRegionIndex for RegionKind {\n-    fn to_region_index(&self) -> RegionIndex {\n+impl ToRegionVid for RegionKind {\n+    fn to_region_vid(&self) -> RegionVid {\n         if let &ty::ReVar(vid) = self {\n-            RegionIndex::new(vid.index as usize)\n+            vid\n         } else {\n             bug!(\"region is not an ReVar: {:?}\", self)\n         }"}, {"sha": "1609c1236b0ca9b22fd90774dc40e261637a899d", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 100, "deletions": 57, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -8,41 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::RegionIndex;\n use super::free_regions::FreeRegions;\n use rustc::infer::InferCtxt;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::region_constraints::VarOrigins;\n use rustc::mir::{Location, Mir};\n-use rustc::ty;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc::ty::{self, RegionVid};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n use std::collections::BTreeSet;\n use std::fmt;\n use syntax_pos::Span;\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n-    /// variables are identified by their index (`RegionIndex`). The\n+    /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    definitions: IndexVec<RegionIndex, RegionDefinition<'tcx>>,\n-\n-    /// The indices of all \"free regions\" in scope. These are the\n-    /// lifetime parameters (anonymous and named) declared in the\n-    /// function signature:\n-    ///\n-    ///     fn foo<'a, 'b>(x: &Foo<'a, 'b>)\n-    ///            ^^  ^^     ^\n-    ///\n-    /// These indices will be from 0..N, as it happens, but we collect\n-    /// them into a vector for convenience.\n-    free_regions: Vec<RegionIndex>,\n+    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n }\n \n-#[derive(Default)]\n struct RegionDefinition<'tcx> {\n+    /// Why we created this variable. Mostly these will be\n+    /// `RegionVariableOrigin::NLL`, but some variables get created\n+    /// elsewhere in the code with other causes (e.g., instantiation\n+    /// late-bound-regions).\n+    origin: RegionVariableOrigin,\n+\n     /// If this is a free-region, then this is `Some(X)` where `X` is\n     /// the name of the region.\n     name: Option<ty::Region<'tcx>>,\n@@ -66,7 +62,7 @@ struct RegionDefinition<'tcx> {\n #[derive(Clone, Default, PartialEq, Eq)]\n struct Region {\n     points: BTreeSet<Location>,\n-    free_regions: BTreeSet<RegionIndex>,\n+    free_regions: BTreeSet<RegionVid>,\n }\n \n impl fmt::Debug for Region {\n@@ -84,7 +80,7 @@ impl Region {\n         self.points.insert(point)\n     }\n \n-    fn add_free_region(&mut self, region: RegionIndex) -> bool {\n+    fn add_free_region(&mut self, region: RegionVid) -> bool {\n         self.free_regions.insert(region)\n     }\n \n@@ -93,37 +89,41 @@ impl Region {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n-    /// Where did this constraint arise?\n-    span: Span,\n+    // NB. The ordering here is not significant for correctness, but\n+    // it is for convenience. Before we dump the constraints in the\n+    // debugging logs, we sort them, and we'd like the \"super region\"\n+    // to be first, etc. (In particular, span should remain last.)\n \n     /// The region SUP must outlive SUB...\n-    sup: RegionIndex,\n+    sup: RegionVid,\n \n     /// Region that must be outlived.\n-    sub: RegionIndex,\n+    sub: RegionVid,\n \n     /// At this location.\n     point: Location,\n+\n+    /// Where did this constraint arise?\n+    span: Span,\n }\n \n impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `free_regions`.\n-    pub fn new(\n-        free_regions: &FreeRegions<'tcx>,\n-        num_region_variables: usize,\n-        mir: &Mir<'tcx>,\n-    ) -> Self {\n+    pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n+        // Create a RegionDefinition for each inference variable.\n+        let definitions = var_origins\n+            .into_iter()\n+            .map(|origin| RegionDefinition::new(origin))\n+            .collect();\n+\n         let mut result = Self {\n-            definitions: (0..num_region_variables)\n-                .map(|_| RegionDefinition::default())\n-                .collect(),\n+            definitions: definitions,\n             constraints: Vec::new(),\n-            free_regions: Vec::new(),\n         };\n \n         result.init_free_regions(free_regions, mir);\n@@ -151,16 +151,18 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n     /// hence contains R0 and R1.\n     fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n-        let &FreeRegions {\n-            ref indices,\n-            ref free_region_map,\n+        let FreeRegions {\n+            indices,\n+            free_region_map,\n         } = free_regions;\n \n         // For each free region X:\n-        for (free_region, index) in indices {\n-            let variable = RegionIndex::new(*index);\n-\n-            self.free_regions.push(variable);\n+        for (free_region, &variable) in indices {\n+            // These should be free-region variables.\n+            assert!(match self.definitions[variable].origin {\n+                RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n+                _ => false,\n+            });\n \n             // Initialize the name and a few other details.\n             self.definitions[variable].name = Some(free_region);\n@@ -181,10 +183,19 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             // Add `end(X)` into the set for X.\n             self.definitions[variable].value.add_free_region(variable);\n \n+            // `'static` outlives all other free regions as well.\n+            if let ty::ReStatic = free_region {\n+                for &other_variable in indices.values() {\n+                    self.definitions[variable]\n+                        .value\n+                        .add_free_region(other_variable);\n+                }\n+            }\n+\n             // Go through each region Y that outlives X (i.e., where\n             // Y: X is true). Add `end(X)` into the set for `Y`.\n             for superregion in free_region_map.regions_that_outlive(&free_region) {\n-                let superregion_index = RegionIndex::new(indices[superregion]);\n+                let superregion_index = indices[superregion];\n                 self.definitions[superregion_index]\n                     .value\n                     .add_free_region(variable);\n@@ -200,24 +211,24 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Returns an iterator over all the region indices.\n-    pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n+    pub fn regions(&self) -> impl Iterator<Item = RegionVid> {\n         self.definitions.indices()\n     }\n \n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Until `solve()` executes, this value is not particularly meaningful.\n-    pub fn region_contains_point(&self, r: RegionIndex, p: Location) -> bool {\n+    pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n         self.definitions[r].value.contains_point(p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    pub(super) fn region_value(&self, r: RegionIndex) -> &fmt::Debug {\n+    pub(super) fn region_value(&self, r: RegionVid) -> &fmt::Debug {\n         &self.definitions[r].value\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n-    pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n         if !definition.constant {\n@@ -233,8 +244,8 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn add_outlives(\n         &mut self,\n         span: Span,\n-        sup: RegionIndex,\n-        sub: RegionIndex,\n+        sup: RegionVid,\n+        sub: RegionVid,\n         point: Location,\n     ) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n@@ -267,23 +278,28 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-    ) -> Vec<(RegionIndex, Span, RegionIndex)> {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) -> Vec<(RegionVid, Span, RegionVid)> {\n         let mut changed = true;\n         let mut dfs = Dfs::new(mir);\n         let mut error_regions = FxHashSet();\n         let mut errors = vec![];\n+\n+        debug!(\"propagate_constraints()\");\n+        debug!(\"propagate_constraints: constraints={:#?}\", {\n+            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            constraints.sort();\n+            constraints\n+        });\n+\n         while changed {\n             changed = false;\n             for constraint in &self.constraints {\n-                debug!(\"constraint: {:?}\", constraint);\n+                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n                 let sub = &self.definitions[constraint.sub].value.clone();\n                 let sup_def = &mut self.definitions[constraint.sup];\n \n-                debug!(\"    sub (before): {:?}\", sub);\n-                debug!(\"    sup (before): {:?}\", sup_def.value);\n+                debug!(\"propagate_constraints:    sub (before): {:?}\", sub);\n+                debug!(\"propagate_constraints:    sup (before): {:?}\", sup_def.value);\n \n                 if !sup_def.constant {\n                     // If this is not a constant, then grow the value as needed to\n@@ -293,8 +309,8 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n                         changed = true;\n                     }\n \n-                    debug!(\"    sup (after) : {:?}\", sup_def.value);\n-                    debug!(\"    changed     : {:?}\", changed);\n+                    debug!(\"propagate_constraints:    sup (after) : {:?}\", sup_def.value);\n+                    debug!(\"propagate_constraints:    changed     : {:?}\", changed);\n                 } else {\n                     // If this is a constant, check whether it *would\n                     // have* to grow in order for the constraint to be\n@@ -310,7 +326,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n                             .difference(&sup_def.value.free_regions)\n                             .next()\n                             .unwrap();\n-                        debug!(\"    new_region : {:?}\", new_region);\n+                        debug!(\"propagate_constraints:    new_region : {:?}\", new_region);\n                         if error_regions.insert(constraint.sup) {\n                             errors.push((constraint.sup, constraint.span, new_region));\n                         }\n@@ -398,3 +414,30 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n         changed\n     }\n }\n+\n+impl<'tcx> RegionDefinition<'tcx> {\n+    fn new(origin: RegionVariableOrigin) -> Self {\n+        // Create a new region definition. Note that, for free\n+        // regions, these fields get updated later in\n+        // `init_free_regions`.\n+        Self {\n+            origin,\n+            name: None,\n+            constant: false,\n+            value: Region::default(),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Constraint {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(\n+            formatter,\n+            \"({:?}: {:?} @ {:?}) due to {:?}\",\n+            self.sup,\n+            self.sub,\n+            self.point,\n+            self.span\n+        )\n+    }\n+}"}, {"sha": "1076b774de6578851392bdf8c386d19d30c1f65a", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "modified", "additions": 56, "deletions": 73, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{self, ClosureSubsts, RegionKind, RegionVid, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Local, Location, Mir, Rvalue, Statement, StatementKind};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, ClosureSubsts, RegionVid, Ty, TypeFoldable};\n+use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n-use rustc::infer::{self as rustc_infer, InferCtxt};\n-use syntax_pos::DUMMY_SP;\n-use std::collections::HashMap;\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n+use super::ToRegionVid;\n use super::free_regions::FreeRegions;\n \n /// Replaces all free regions appearing in the MIR with fresh\n@@ -25,50 +24,53 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     free_regions: &FreeRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n-) -> usize {\n+) {\n     // Create inference variables for each of the free regions\n     // declared on the function signature.\n     let free_region_inference_vars = (0..free_regions.indices.len())\n-        .map(|_| {\n-            infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        .map(RegionVid::new)\n+        .map(|vid_expected| {\n+            let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n+            assert_eq!(vid_expected, r.to_region_vid());\n+            r\n         })\n         .collect();\n \n+    debug!(\"renumber_mir()\");\n+    debug!(\"renumber_mir: free_regions={:#?}\", free_regions);\n+    debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n+\n     let mut visitor = NLLVisitor {\n         infcx,\n-        lookup_map: HashMap::new(),\n-        num_region_variables: free_regions.indices.len(),\n         free_regions,\n         free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n     visitor.visit_mir(mir);\n-    visitor.num_region_variables\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    lookup_map: HashMap<RegionVid, TyContext>,\n-    num_region_variables: usize,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     free_regions: &'a FreeRegions<'tcx>,\n-    free_region_inference_vars: Vec<ty::Region<'tcx>>,\n+    free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n     /// Replaces all regions appearing in `value` with fresh inference\n     /// variables. This is what we do for almost the entire MIR, with\n     /// the exception of the declared types of our arguments.\n-    fn renumber_regions<T>(&mut self, value: &T) -> T\n+    fn renumber_regions<T>(&mut self, ty_context: TyContext, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        debug!(\"renumber_regions(value={:?})\", value);\n+\n         self.infcx\n             .tcx\n             .fold_regions(value, &mut false, |_region, _depth| {\n-                self.num_region_variables += 1;\n-                self.infcx\n-                    .next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+                let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n+                self.infcx.next_nll_region_var(origin)\n             })\n     }\n \n@@ -78,6 +80,8 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        debug!(\"renumber_free_regions(value={:?})\", value);\n+\n         self.infcx\n             .tcx\n             .fold_regions(value, &mut false, |region, _depth| {\n@@ -86,26 +90,6 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn store_region(&mut self, region: &RegionKind, lookup: TyContext) {\n-        if let RegionKind::ReVar(rid) = *region {\n-            self.lookup_map.entry(rid).or_insert(lookup);\n-        }\n-    }\n-\n-    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, ty_context: TyContext) {\n-        for region in ty.regions() {\n-            self.store_region(region, ty_context);\n-        }\n-    }\n-\n-    fn store_kind_regions(&mut self, kind: &'tcx Kind, ty_context: TyContext) {\n-        if let Some(ty) = kind.as_type() {\n-            self.store_ty_regions(&ty, ty_context);\n-        } else if let Some(region) = kind.as_region() {\n-            self.store_region(region, ty_context);\n-        }\n-    }\n-\n     fn is_argument_or_return_slot(&self, local: Local) -> bool {\n         // The first argument is return slot, next N are arguments.\n         local.index() <= self.arg_count\n@@ -116,56 +100,55 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         let is_arg = match ty_context {\n             TyContext::LocalDecl { local, .. } => self.is_argument_or_return_slot(local),\n-            _ => false,\n+            TyContext::ReturnTy(..) => true,\n+            TyContext::Location(..) => false,\n         };\n+        debug!(\n+            \"visit_ty(ty={:?}, is_arg={:?}, ty_context={:?})\",\n+            ty,\n+            is_arg,\n+            ty_context\n+        );\n \n         let old_ty = *ty;\n         *ty = if is_arg {\n             self.renumber_free_regions(&old_ty)\n         } else {\n-            self.renumber_regions(&old_ty)\n+            self.renumber_regions(ty_context, &old_ty)\n         };\n-        self.store_ty_regions(ty, ty_context);\n+        debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{ *substs });\n+        debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n+\n         let ty_context = TyContext::Location(location);\n-        for kind in *substs {\n-            self.store_kind_regions(kind, ty_context);\n-        }\n+        *substs = self.renumber_regions(ty_context, &{ *substs });\n+\n+        debug!(\"visit_substs: substs={:?}\", substs);\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                let old_r = *r;\n-                *r = self.renumber_regions(&old_r);\n-                let ty_context = TyContext::Location(location);\n-                self.store_region(r, ty_context);\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n+        debug!(\"visit_region(region={:?}, location={:?})\", region, location);\n+\n+        let old_region = *region;\n+        let ty_context = TyContext::Location(location);\n+        *region = self.renumber_regions(ty_context, &old_region);\n+\n+        debug!(\"visit_region: region={:?}\", region);\n     }\n \n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(substs);\n+        debug!(\n+            \"visit_closure_substs(substs={:?}, location={:?})\",\n+            substs,\n+            location\n+        );\n+\n         let ty_context = TyContext::Location(location);\n-        for kind in substs.substs {\n-            self.store_kind_regions(kind, ty_context);\n-        }\n+        *substs = self.renumber_regions(ty_context, substs);\n+\n+        debug!(\"visit_closure_substs: substs={:?}\", substs);\n     }\n \n     fn visit_statement("}, {"sha": "953fc0eb733c2187159a690fde5025f9b7dfe5c7", "filename": "src/librustc_mir/transform/nll/subtype.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/58d8761ab3f2eda3536c0a8e81f2179655a6fb00/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d8761ab3f2eda3536c0a8e81f2179655a6fb00/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs?ref=58d8761ab3f2eda3536c0a8e81f2179655a6fb00", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::RegionIndex;\n-use transform::nll::ToRegionIndex;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-\n-pub fn outlives_pairs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      a: Ty<'tcx>,\n-                      b: Ty<'tcx>)\n-                      -> Vec<(RegionIndex, RegionIndex)>\n-{\n-    let mut subtype = Subtype::new(tcx);\n-    match subtype.relate(&a, &b) {\n-        Ok(_) => subtype.outlives_pairs,\n-\n-        Err(_) => bug!(\"Fail to relate a = {:?} and b = {:?}\", a, b)\n-    }\n-}\n-\n-struct Subtype<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    outlives_pairs: Vec<(RegionIndex, RegionIndex)>,\n-    ambient_variance: ty::Variance,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Subtype<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Subtype<'a, 'gcx, 'tcx> {\n-        Subtype {\n-            tcx,\n-            outlives_pairs: vec![],\n-            ambient_variance: ty::Covariant,\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Subtype<'a, 'gcx, 'tcx> {\n-    fn tag(&self) -> &'static str { \"Subtype\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n-    fn a_is_expected(&self) -> bool { true } // irrelevant\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n-                                             variance: ty::Variance,\n-                                             a: &T,\n-                                             b: &T)\n-                                             -> RelateResult<'tcx, T>\n-    {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        let result = self.relate(a, b);\n-        self.ambient_variance = old_ambient_variance;\n-        result\n-    }\n-\n-    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        relate::super_relate_tys(self, t, t2)\n-    }\n-\n-    fn regions(&mut self, r_a: ty::Region<'tcx>, r_b: ty::Region<'tcx>)\n-               -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        let a = r_a.to_region_index();\n-        let b = r_b.to_region_index();\n-\n-        match self.ambient_variance {\n-            ty::Covariant => {\n-                self.outlives_pairs.push((b, a));\n-            },\n-\n-            ty::Invariant => {\n-                self.outlives_pairs.push((a, b));\n-                self.outlives_pairs.push((b, a));\n-            },\n-\n-            ty::Contravariant => {\n-                self.outlives_pairs.push((a, b));\n-            },\n-\n-            ty::Bivariant => {},\n-        }\n-\n-        Ok(r_a)\n-    }\n-\n-    fn binders<T>(&mut self, _a: &ty::Binder<T>, _b: &ty::Binder<T>)\n-                  -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        unimplemented!();\n-    }\n-}"}, {"sha": "c1850c76541d78f75d4c1f6e06cf50ab6ab459f6", "filename": "src/librustc_mir/transform/nll/subtype_constraint_generation.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::Mir;\n+use rustc::infer::region_constraints::Constraint;\n+use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::ty;\n+use transform::type_check::MirTypeckRegionConstraints;\n+use transform::type_check::OutlivesSet;\n+\n+use super::free_regions::FreeRegions;\n+use super::region_infer::RegionInferenceContext;\n+\n+/// When the MIR type-checker executes, it validates all the types in\n+/// the MIR, and in the process generates a set of constraints that\n+/// must hold regarding the regions in the MIR, along with locations\n+/// *where* they must hold. This code takes those constriants and adds\n+/// them into the NLL `RegionInferenceContext`.\n+pub(super) fn generate<'tcx>(\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n+    free_regions: &FreeRegions<'tcx>,\n+    mir: &Mir<'tcx>,\n+    constraints: &MirTypeckRegionConstraints<'tcx>,\n+) {\n+    SubtypeConstraintGenerator {\n+        regioncx,\n+        free_regions,\n+        mir,\n+    }.generate(constraints);\n+}\n+\n+struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n+    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n+    free_regions: &'cx FreeRegions<'tcx>,\n+    mir: &'cx Mir<'tcx>,\n+}\n+\n+impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n+    fn generate(&mut self, constraints: &MirTypeckRegionConstraints<'tcx>) {\n+        let MirTypeckRegionConstraints {\n+            liveness_set,\n+            outlives_sets,\n+        } = constraints;\n+\n+        debug!(\n+            \"generate(liveness_set={} items, outlives_sets={} items)\",\n+            liveness_set.len(),\n+            outlives_sets.len()\n+        );\n+\n+        for (region, location) in liveness_set {\n+            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n+            let region_vid = self.to_region_vid(region);\n+            self.regioncx.add_live_point(region_vid, *location);\n+        }\n+\n+        for OutlivesSet { locations, data } in outlives_sets {\n+            debug!(\"generate: constraints at: {:#?}\", locations);\n+            let RegionConstraintData {\n+                constraints,\n+                verifys,\n+                givens,\n+            } = data;\n+\n+            for constraint in constraints.keys() {\n+                debug!(\"generate: constraint: {:?}\", constraint);\n+                let (a_vid, b_vid) = match constraint {\n+                    Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n+                    Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n+                    Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n+                    Constraint::RegSubReg(a_r, b_r) => {\n+                        (self.to_region_vid(a_r), self.to_region_vid(b_r))\n+                    }\n+                };\n+\n+                // We have the constraint that `a_vid <= b_vid`. Add\n+                // `b_vid: a_vid` to our region checker. Note that we\n+                // reverse direction, because `regioncx` talks about\n+                // \"outlives\" (`>=`) whereas the region constraints\n+                // talk about `<=`.\n+                let span = self.mir.source_info(locations.from_location).span;\n+                self.regioncx\n+                    .add_outlives(span, b_vid, a_vid, locations.at_location);\n+            }\n+\n+            assert!(verifys.is_empty(), \"verifys not yet implemented\");\n+            assert!(\n+                givens.is_empty(),\n+                \"MIR type-checker does not use givens (thank goodness)\"\n+            );\n+        }\n+    }\n+\n+    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        // Every region that we see in the constraints came from the\n+        // MIR or from the parameter environment. If the former, it\n+        // will be a region variable.  If the latter, it will be in\n+        // the set of free regions *somewhere*.\n+        if let ty::ReVar(vid) = r {\n+            *vid\n+        } else {\n+            self.free_regions.indices[&r]\n+        }\n+    }\n+}"}, {"sha": "837c3d42fe83701e5ee84e021af4e1c402dc6280", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 597, "deletions": 309, "changes": 906, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -11,8 +11,10 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n-use rustc::infer::{self, InferCtxt, InferOk};\n-use rustc::traits;\n+use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n+use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::traits::{self, FulfillmentContext};\n+use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n@@ -27,6 +29,34 @@ use transform::{MirPass, MirSource};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+/// Type checks the given `mir` in the context of the inference\n+/// context `infcx`. Returns any region constraints that have yet to\n+/// be proven.\n+///\n+/// This phase of type-check ought to be infallible -- this is because\n+/// the original, HIR-based type-check succeeded. So if any errors\n+/// occur here, we will get a `bug!` reported.\n+pub fn type_check<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'gcx>,\n+    mir: &Mir<'tcx>,\n+) -> MirTypeckRegionConstraints<'tcx> {\n+    let mut checker = TypeChecker::new(infcx, body_id, param_env);\n+    let errors_reported = {\n+        let mut verifier = TypeVerifier::new(&mut checker, mir);\n+        verifier.visit_mir(mir);\n+        verifier.errors_reported\n+    };\n+\n+    if !errors_reported {\n+        // if verifier failed, don't do further checks to avoid ICEs\n+        checker.typeck_mir(mir);\n+    }\n+\n+    checker.constraints\n+}\n+\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     tcx.sess.diagnostic().span_bug(span, msg);\n }\n@@ -51,20 +81,20 @@ macro_rules! span_mirbug_and_err {\n }\n \n enum FieldAccessError {\n-    OutOfRange { field_count: usize }\n+    OutOfRange { field_count: usize },\n }\n \n /// Verifies that MIR types are sane to not crash further checks.\n ///\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n-    errors_reported: bool\n+    errors_reported: bool,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n@@ -74,10 +104,12 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    _context: visit::LvalueContext,\n-                    location: Location) {\n+    fn visit_lvalue(\n+        &mut self,\n+        lvalue: &Lvalue<'tcx>,\n+        _context: visit::LvalueContext,\n+        location: Location,\n+    ) {\n         self.sanitize_lvalue(lvalue, location);\n     }\n \n@@ -116,7 +148,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             body_id: cx.body_id,\n             cx,\n             last_span: mir.span,\n-            errors_reported: false\n+            errors_reported: false,\n         }\n     }\n \n@@ -125,7 +157,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() || ty.has_escaping_regions() || ty.references_error() {\n+        if ty.has_escaping_regions() || ty.references_error() {\n             span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n         } else {\n             ty\n@@ -135,38 +167,49 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>, location: Location) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n-            Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n+            Lvalue::Local(index) => LvalueTy::Ty {\n+                ty: self.mir.local_decls[index].ty,\n+            },\n             Lvalue::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(lvalue, sty);\n                 let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(&ty);\n-                if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty) {\n+                let ty = self.cx.normalize(&ty, location);\n+                if let Err(terr) = self.cx\n+                    .eq_types(self.last_span, ty, sty, location.at_self())\n+                {\n                     span_mirbug!(\n-                        self, lvalue, \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty, sty, terr);\n+                        self,\n+                        lvalue,\n+                        \"bad static type ({:?}: {:?}): {:?}\",\n+                        ty,\n+                        sty,\n+                        terr\n+                    );\n                 }\n                 LvalueTy::Ty { ty: sty }\n-\n-            },\n+            }\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {\n                     if ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return LvalueTy::Ty { ty: self.tcx().types.err };\n+                        return LvalueTy::Ty {\n+                            ty: self.tcx().types.err,\n+                        };\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, lvalue, location)\n             }\n         }\n     }\n \n-    fn sanitize_projection(&mut self,\n-                           base: LvalueTy<'tcx>,\n-                           pi: &LvalueElem<'tcx>,\n-                           lvalue: &Lvalue<'tcx>,\n-                           _: Location)\n-                           -> LvalueTy<'tcx> {\n+    fn sanitize_projection(\n+        &mut self,\n+        base: LvalueTy<'tcx>,\n+        pi: &LvalueElem<'tcx>,\n+        lvalue: &Lvalue<'tcx>,\n+        location: Location,\n+    ) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n@@ -176,97 +219,104 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n                 LvalueTy::Ty {\n                     ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n-                        span_mirbug_and_err!(\n-                            self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n-                    })\n+                        span_mirbug_and_err!(self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n+                    }),\n                 }\n             }\n             ProjectionElem::Index(i) => {\n                 let index_ty = Lvalue::Local(i).ty(self.mir, tcx).to_ty(tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n+                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n                     }\n                 } else {\n                     LvalueTy::Ty {\n                         ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                            span_mirbug_and_err!(\n-                                self, lvalue, \"index of non-array {:?}\", base_ty)\n-                        })\n+                            span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                        }),\n                     }\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n                 LvalueTy::Ty {\n                     ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                        span_mirbug_and_err!(\n-                            self, lvalue, \"index of non-array {:?}\", base_ty)\n-                    })\n+                        span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                    }),\n                 }\n             }\n-            ProjectionElem::Subslice { from, to } => {\n-                LvalueTy::Ty {\n-                    ty: match base_ty.sty {\n-                        ty::TyArray(inner, size) => {\n-                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n-                            let min_size = (from as u64) + (to as u64);\n-                            if let Some(rest_size) = size.checked_sub(min_size) {\n-                                tcx.mk_array(inner, rest_size)\n-                            } else {\n-                                span_mirbug_and_err!(\n-                                    self, lvalue, \"taking too-small slice of {:?}\", base_ty)\n-                            }\n-                        }\n-                        ty::TySlice(..) => base_ty,\n-                        _ => {\n+            ProjectionElem::Subslice { from, to } => LvalueTy::Ty {\n+                ty: match base_ty.sty {\n+                    ty::TyArray(inner, size) => {\n+                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let min_size = (from as u64) + (to as u64);\n+                        if let Some(rest_size) = size.checked_sub(min_size) {\n+                            tcx.mk_array(inner, rest_size)\n+                        } else {\n                             span_mirbug_and_err!(\n-                                self, lvalue, \"slice of non-array {:?}\", base_ty)\n+                                self,\n+                                lvalue,\n+                                \"taking too-small slice of {:?}\",\n+                                base_ty\n+                            )\n                         }\n                     }\n-                }\n-            }\n-            ProjectionElem::Downcast(adt_def1, index) =>\n-                match base_ty.sty {\n-                    ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n-                        if index >= adt_def.variants.len() {\n-                            LvalueTy::Ty {\n-                                ty: span_mirbug_and_err!(\n-                                    self,\n-                                    lvalue,\n-                                    \"cast to variant #{:?} but enum only has {:?}\",\n-                                    index,\n-                                    adt_def.variants.len())\n-                            }\n-                        } else {\n-                            LvalueTy::Downcast {\n-                                adt_def,\n-                                substs,\n-                                variant_index: index\n-                            }\n+                    ty::TySlice(..) => base_ty,\n+                    _ => span_mirbug_and_err!(self, lvalue, \"slice of non-array {:?}\", base_ty),\n+                },\n+            },\n+            ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n+                ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+                    if index >= adt_def.variants.len() {\n+                        LvalueTy::Ty {\n+                            ty: span_mirbug_and_err!(\n+                                self,\n+                                lvalue,\n+                                \"cast to variant #{:?} but enum only has {:?}\",\n+                                index,\n+                                adt_def.variants.len()\n+                            ),\n+                        }\n+                    } else {\n+                        LvalueTy::Downcast {\n+                            adt_def,\n+                            substs,\n+                            variant_index: index,\n                         }\n                     }\n-                    _ => LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(\n-                            self, lvalue, \"can't downcast {:?} as {:?}\",\n-                            base_ty, adt_def1)\n-                    }\n+                }\n+                _ => LvalueTy::Ty {\n+                    ty: span_mirbug_and_err!(\n+                        self,\n+                        lvalue,\n+                        \"can't downcast {:?} as {:?}\",\n+                        base_ty,\n+                        adt_def1\n+                    ),\n                 },\n+            },\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(lvalue, fty);\n-                match self.field_ty(lvalue, base, field) {\n+                match self.field_ty(lvalue, base, field, location) {\n                     Ok(ty) => {\n-                        if let Err(terr) = self.cx.eq_types(span, ty, fty) {\n+                        if let Err(terr) = self.cx.eq_types(span, ty, fty, location.at_self()) {\n                             span_mirbug!(\n-                                self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n-                                ty, fty, terr);\n+                                self,\n+                                lvalue,\n+                                \"bad field access ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                fty,\n+                                terr\n+                            );\n                         }\n                     }\n-                    Err(FieldAccessError::OutOfRange { field_count }) => {\n-                        span_mirbug!(\n-                            self, lvalue, \"accessed field #{} but variant only has {}\",\n-                            field.index(), field_count)\n-                    }\n+                    Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n+                        self,\n+                        lvalue,\n+                        \"accessed field #{} but variant only has {}\",\n+                        field.index(),\n+                        field_count\n+                    ),\n                 }\n                 LvalueTy::Ty { ty: fty }\n             }\n@@ -278,28 +328,31 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.tcx().types.err\n     }\n \n-    fn field_ty(&mut self,\n-                parent: &fmt::Debug,\n-                base_ty: LvalueTy<'tcx>,\n-                field: Field)\n-                -> Result<Ty<'tcx>, FieldAccessError>\n-    {\n+    fn field_ty(\n+        &mut self,\n+        parent: &fmt::Debug,\n+        base_ty: LvalueTy<'tcx>,\n+        field: Field,\n+        location: Location,\n+    ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                (&adt_def.variants[variant_index], substs)\n-            }\n+            LvalueTy::Downcast {\n+                adt_def,\n+                substs,\n+                variant_index,\n+            } => (&adt_def.variants[variant_index], substs),\n             LvalueTy::Ty { ty } => match ty.sty {\n                 ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n-                        (&adt_def.variants[0], substs)\n-                    }\n+                    (&adt_def.variants[0], substs)\n+                }\n                 ty::TyClosure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.upvar_tys(def_id, tcx).count()\n-                        })\n+                            field_count: substs.upvar_tys(def_id, tcx).count(),\n+                        }),\n                     }\n                 }\n                 ty::TyGenerator(def_id, substs, _) => {\n@@ -311,114 +364,215 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     return match substs.field_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count() + 1\n-                        })\n-                    }\n+                            field_count: substs.field_tys(def_id, tcx).count() + 1,\n+                        }),\n+                    };\n                 }\n                 ty::TyTuple(tys, _) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: tys.len()\n-                        })\n+                            field_count: tys.len(),\n+                        }),\n                     }\n                 }\n-                _ => return Ok(span_mirbug_and_err!(\n-                    self, parent, \"can't project out of {:?}\", base_ty))\n-            }\n+                _ => {\n+                    return Ok(span_mirbug_and_err!(\n+                        self,\n+                        parent,\n+                        \"can't project out of {:?}\",\n+                        base_ty\n+                    ))\n+                }\n+            },\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n-            Ok(self.cx.normalize(&field.ty(tcx, substs)))\n+            Ok(self.cx.normalize(&field.ty(tcx, substs), location))\n         } else {\n-            Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n+            Err(FieldAccessError::OutOfRange {\n+                field_count: variant.fields.len(),\n+            })\n         }\n     }\n }\n \n-pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+/// The MIR type checker. Visits the MIR and enforces all the\n+/// constraints needed for it to be valid and well-typed. Along the\n+/// way, it accrues region constraints -- these can later be used by\n+/// NLL region checking.\n+pub struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n+    constraints: MirTypeckRegionConstraints<'tcx>,\n+}\n+\n+/// A collection of region constraints that must be satisfied for the\n+/// program to be considered well-typed.\n+#[derive(Default)]\n+pub struct MirTypeckRegionConstraints<'tcx> {\n+    /// In general, the type-checker is not responsible for enforcing\n+    /// liveness constraints; this job falls to the region inferencer,\n+    /// which performs a liveness analysis. However, in some limited\n+    /// cases, the MIR type-checker creates temporary regions that do\n+    /// not otherwise appear in the MIR -- in particular, the\n+    /// late-bound regions that it instantiates at call-sites -- and\n+    /// hence it must report on their liveness constraints.\n+    pub liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n+\n+    /// During the course of type-checking, we will accumulate region\n+    /// constraints due to performing subtyping operations or solving\n+    /// traits. These are accumulated into this vector for later use.\n+    pub outlives_sets: Vec<OutlivesSet<'tcx>>,\n+}\n+\n+/// Outlives relationships between regions and types created at a\n+/// particular point within the control-flow graph.\n+pub struct OutlivesSet<'tcx> {\n+    /// The locations associated with these constraints.\n+    pub locations: Locations,\n+\n+    /// Constraints generated. In terms of the NLL RFC, when you have\n+    /// a constraint `R1: R2 @ P`, the data in there specifies things\n+    /// like `R1: R2`.\n+    pub data: RegionConstraintData<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Locations {\n+    /// The location in the MIR that generated these constraints.\n+    /// This is intended for error reporting and diagnosis; the\n+    /// constraints may *take effect* at a distinct spot.\n+    pub from_location: Location,\n+\n+    /// The constraints must be met at this location. In terms of the\n+    /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n+    /// is the `P` value.\n+    pub at_location: Location,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-           body_id: ast::NodeId,\n-           param_env: ty::ParamEnv<'gcx>)\n-           -> Self {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'gcx>,\n+    ) -> Self {\n         TypeChecker {\n             infcx,\n-            fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP,\n             body_id,\n             param_env,\n             reported_errors: FxHashSet(),\n+            constraints: MirTypeckRegionConstraints::default(),\n         }\n     }\n \n     fn misc(&self, span: Span) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::misc(span, self.body_id)\n     }\n \n-    pub fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n-        for obligation in infer_ok.obligations {\n-            self.fulfillment_cx.register_predicate_obligation(self.infcx, obligation);\n+    fn fully_perform_op<OP, R>(\n+        &mut self,\n+        locations: Locations,\n+        op: OP,\n+    ) -> Result<R, TypeError<'tcx>>\n+    where\n+        OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n+    {\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n+        fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n+        if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {\n+            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n+        }\n+\n+        let data = self.infcx.take_and_reset_region_constraints();\n+        if !data.is_empty() {\n+            self.constraints\n+                .outlives_sets\n+                .push(OutlivesSet { locations, data });\n         }\n-        infer_ok.value\n+\n+        Ok(value)\n     }\n \n-    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n-                 -> infer::UnitResult<'tcx>\n-    {\n-        self.infcx.at(&self.misc(self.last_span), self.param_env)\n-                  .sup(sup, sub)\n-                  .map(|ok| self.register_infer_ok_obligations(ok))\n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+    ) -> UnitResult<'tcx> {\n+        self.fully_perform_op(locations, |this| {\n+            this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n+                .sup(sup, sub)\n+        })\n     }\n \n-    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n-                -> infer::UnitResult<'tcx>\n-    {\n-        self.infcx.at(&self.misc(span), self.param_env)\n-                  .eq(b, a)\n-                  .map(|ok| self.register_infer_ok_obligations(ok))\n+    fn eq_types(\n+        &mut self,\n+        _span: Span,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+    ) -> UnitResult<'tcx> {\n+        self.fully_perform_op(locations, |this| {\n+            this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n+                .eq(b, a)\n+        })\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>) {\n+    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n-                    span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n-                                 lv_ty, rv_ty, terr);\n+                if let Err(terr) =\n+                    self.sub_types(rv_ty, lv_ty, location.at_successor_within_block())\n+                {\n+                    span_mirbug!(\n+                        self,\n+                        stmt,\n+                        \"bad assignment ({:?} = {:?}): {:?}\",\n+                        lv_ty,\n+                        rv_ty,\n+                        terr\n+                    );\n                 }\n             }\n-            StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n+            StatementKind::SetDiscriminant {\n+                ref lvalue,\n+                variant_index,\n+            } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n                 let adt = match lvalue_type.sty {\n                     TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n-                        span_bug!(stmt.source_info.span,\n-                                  \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n-                                  lvalue,\n-                                  variant_index);\n+                        span_bug!(\n+                            stmt.source_info.span,\n+                            \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n+                            lvalue,\n+                            variant_index\n+                        );\n                     }\n                 };\n                 if variant_index >= adt.variants.len() {\n-                     span_bug!(stmt.source_info.span,\n-                               \"bad set discriminant ({:?} = {:?}): value of of range\",\n-                               lvalue,\n-                               variant_index);\n+                    span_bug!(\n+                        stmt.source_info.span,\n+                        \"bad set discriminant ({:?} = {:?}): value of of range\",\n+                        lvalue,\n+                        variant_index\n+                    );\n                 };\n             }\n             StatementKind::StorageLive(_) |\n@@ -430,9 +584,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_terminator(&mut self,\n-                        mir: &Mir<'tcx>,\n-                        term: &Terminator<'tcx>) {\n+    fn check_terminator(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        term_location: Location,\n+    ) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n@@ -446,33 +603,77 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // no checks needed for these\n             }\n \n-\n             TerminatorKind::DropAndReplace {\n                 ref location,\n                 ref value,\n-                ..\n+                target,\n+                unwind,\n             } => {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n-                    span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                                 lv_ty, rv_ty, terr);\n+\n+                let locations = Locations {\n+                    from_location: term_location,\n+                    at_location: target.start_location(),\n+                };\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                        lv_ty,\n+                        rv_ty,\n+                        terr\n+                    );\n+                }\n+\n+                // Subtle: this assignment occurs at the start of\n+                // *both* blocks, so we need to ensure that it holds\n+                // at both locations.\n+                if let Some(unwind) = unwind {\n+                    let locations = Locations {\n+                        from_location: term_location,\n+                        at_location: unwind.start_location(),\n+                    };\n+                    if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n+                        span_mirbug!(\n+                            self,\n+                            term,\n+                            \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                            lv_ty,\n+                            rv_ty,\n+                            terr\n+                        );\n+                    }\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt {\n+                ref discr,\n+                switch_ty,\n+                ..\n+            } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n-                    span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n-                                 switch_ty, discr_ty, terr);\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.at_self()) {\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"bad SwitchInt ({:?} on {:?}): {:?}\",\n+                        switch_ty,\n+                        discr_ty,\n+                        terr\n+                    );\n                 }\n-                if !switch_ty.is_integral() && !switch_ty.is_char() &&\n-                    !switch_ty.is_bool()\n-                {\n-                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\",switch_ty);\n+                if !switch_ty.is_integral() && !switch_ty.is_char() && !switch_ty.is_bool() {\n+                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\", switch_ty);\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n+            TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                ..\n+            } => {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n@@ -482,17 +683,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let sig = tcx.erase_late_bound_regions(&sig);\n-                let sig = self.normalize(&sig);\n-                self.check_call_dest(mir, term, &sig, destination);\n+                let (sig, map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    term.source_info.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    &sig,\n+                );\n+                let sig = self.normalize(&sig, term_location);\n+                self.check_call_dest(mir, term, &sig, destination, term_location);\n+\n+                // The ordinary liveness rules will ensure that all\n+                // regions in the type of the callee are live here. We\n+                // then further constrain the late-bound regions that\n+                // were instantiated at the call site to be live as\n+                // well. The resulting is that all the input (and\n+                // output) types in the signature must be live, since\n+                // all the inputs that fed into it were live.\n+                for &late_bound_region in map.values() {\n+                    self.constraints\n+                        .liveness_set\n+                        .push((late_bound_region, term_location));\n+                }\n \n                 if self.is_box_free(func) {\n-                    self.check_box_free_inputs(mir, term, &sig, args);\n+                    self.check_box_free_inputs(mir, term, &sig, args, term_location);\n                 } else {\n-                    self.check_call_inputs(mir, term, &sig, args);\n+                    self.check_call_inputs(mir, term, &sig, args, term_location);\n                 }\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert {\n+                ref cond, ref msg, ..\n+            } => {\n                 let cond_ty = cond.ty(mir, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n@@ -512,83 +732,112 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty) {\n-                            span_mirbug!(self,\n+                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.at_self()) {\n+                            span_mirbug!(\n+                                self,\n                                 term,\n                                 \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n                                 value_ty,\n                                 ty,\n-                                terr);\n+                                terr\n+                            );\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn check_call_dest(&mut self,\n-                       mir: &Mir<'tcx>,\n-                       term: &Terminator<'tcx>,\n-                       sig: &ty::FnSig<'tcx>,\n-                       destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n+    fn check_call_dest(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        destination: &Option<(Lvalue<'tcx>, BasicBlock)>,\n+        term_location: Location,\n+    ) {\n         let tcx = self.tcx();\n         match *destination {\n-            Some((ref dest, _)) => {\n+            Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(sig.output(), dest_ty) {\n-                    span_mirbug!(self, term,\n-                                 \"call dest mismatch ({:?} <- {:?}): {:?}\",\n-                                 dest_ty, sig.output(), terr);\n+                let locations = Locations {\n+                    from_location: term_location,\n+                    at_location: target_block.start_location(),\n+                };\n+                if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"call dest mismatch ({:?} <- {:?}): {:?}\",\n+                        dest_ty,\n+                        sig.output(),\n+                        terr\n+                    );\n                 }\n-            },\n+            }\n             None => {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 if !sig.output().is_never() {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n-            },\n+            }\n         }\n     }\n \n-    fn check_call_inputs(&mut self,\n-                         mir: &Mir<'tcx>,\n-                         term: &Terminator<'tcx>,\n-                         sig: &ty::FnSig<'tcx>,\n-                         args: &[Operand<'tcx>])\n-    {\n+    fn check_call_inputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        args: &[Operand<'tcx>],\n+        term_location: Location,\n+    ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if args.len() < sig.inputs().len() ||\n-           (args.len() > sig.inputs().len() && !sig.variadic) {\n+        if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n-                span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n-                             n, fn_arg, op_arg_ty, terr);\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.at_self()) {\n+                span_mirbug!(\n+                    self,\n+                    term,\n+                    \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n+                    n,\n+                    fn_arg,\n+                    op_arg_ty,\n+                    terr\n+                );\n             }\n         }\n     }\n \n     fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n         match operand {\n             &Operand::Constant(box Constant {\n-                literal: Literal::Value {\n-                    value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n-                }, ..\n-            }) => {\n-                Some(def_id) == self.tcx().lang_items().box_free_fn()\n-            }\n+                literal:\n+                    Literal::Value {\n+                        value:\n+                            &ty::Const {\n+                                val: ConstVal::Function(def_id, _),\n+                                ..\n+                            },\n+                        ..\n+                    },\n+                ..\n+            }) => Some(def_id) == self.tcx().lang_items().box_free_fn(),\n             _ => false,\n         }\n     }\n \n-    fn check_box_free_inputs(&mut self,\n-                             mir: &Mir<'tcx>,\n-                             term: &Terminator<'tcx>,\n-                             sig: &ty::FnSig<'tcx>,\n-                             args: &[Operand<'tcx>])\n-    {\n+    fn check_box_free_inputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        args: &[Operand<'tcx>],\n+        term_location: Location,\n+    ) {\n         debug!(\"check_box_free_inputs\");\n \n         // box_free takes a Box as a pointer. Allow for that.\n@@ -621,93 +870,108 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.sub_types(arg_ty, pointee_ty) {\n-            span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n-                         pointee_ty, arg_ty, terr);\n+        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, term_location.at_self()) {\n+            span_mirbug!(\n+                self,\n+                term,\n+                \"bad box_free arg ({:?} <- {:?}): {:?}\",\n+                pointee_ty,\n+                arg_ty,\n+                terr\n+            );\n         }\n     }\n \n-    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block: &BasicBlockData<'tcx>)\n-    {\n-        let is_cleanup = block.is_cleanup;\n-        self.last_span = block.terminator().source_info.span;\n-        match block.terminator().kind {\n-            TerminatorKind::Goto { target } =>\n-                self.assert_iscleanup(mir, block, target, is_cleanup),\n-            TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.assert_iscleanup(mir, block, *target, is_cleanup);\n-                }\n-            }\n-            TerminatorKind::Resume => {\n-                if !is_cleanup {\n-                    span_mirbug!(self, block, \"resume on non-cleanup block!\")\n-                }\n-            }\n-            TerminatorKind::Return => {\n-                if is_cleanup {\n-                    span_mirbug!(self, block, \"return on cleanup block\")\n-                }\n-            }\n-            TerminatorKind::GeneratorDrop { .. } => {\n-                if is_cleanup {\n-                    span_mirbug!(self, block, \"generator_drop in cleanup block\")\n-                }\n+    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>) {\n+        let is_cleanup = block_data.is_cleanup;\n+        self.last_span = block_data.terminator().source_info.span;\n+        match block_data.terminator().kind {\n+            TerminatorKind::Goto { target } => {\n+                self.assert_iscleanup(mir, block_data, target, is_cleanup)\n             }\n+            TerminatorKind::SwitchInt { ref targets, .. } => for target in targets {\n+                self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n+            },\n+            TerminatorKind::Resume => if !is_cleanup {\n+                span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n+            },\n+            TerminatorKind::Return => if is_cleanup {\n+                span_mirbug!(self, block_data, \"return on cleanup block\")\n+            },\n+            TerminatorKind::GeneratorDrop { .. } => if is_cleanup {\n+                span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n+            },\n             TerminatorKind::Yield { resume, drop, .. } => {\n                 if is_cleanup {\n-                    span_mirbug!(self, block, \"yield in cleanup block\")\n+                    span_mirbug!(self, block_data, \"yield in cleanup block\")\n                 }\n-                self.assert_iscleanup(mir, block, resume, is_cleanup);\n+                self.assert_iscleanup(mir, block_data, resume, is_cleanup);\n                 if let Some(drop) = drop {\n-                    self.assert_iscleanup(mir, block, drop, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, drop, is_cleanup);\n                 }\n             }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |\n-            TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n-                self.assert_iscleanup(mir, block, target, is_cleanup);\n+            TerminatorKind::Assert {\n+                target,\n+                cleanup: unwind,\n+                ..\n+            } => {\n+                self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n-                        span_mirbug!(self, block, \"unwind on cleanup block\")\n+                        span_mirbug!(self, block_data, \"unwind on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block, unwind, true);\n+                    self.assert_iscleanup(mir, block_data, unwind, true);\n                 }\n             }\n-            TerminatorKind::Call { ref destination, cleanup, .. } => {\n+            TerminatorKind::Call {\n+                ref destination,\n+                cleanup,\n+                ..\n+            } => {\n                 if let &Some((_, target)) = destination {\n-                    self.assert_iscleanup(mir, block, target, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 }\n                 if let Some(cleanup) = cleanup {\n                     if is_cleanup {\n-                        span_mirbug!(self, block, \"cleanup on cleanup block\")\n+                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block, cleanup, true);\n+                    self.assert_iscleanup(mir, block_data, cleanup, true);\n                 }\n             }\n-            TerminatorKind::FalseEdges { real_target, ref imaginary_targets } => {\n-                self.assert_iscleanup(mir, block, real_target, is_cleanup);\n+            TerminatorKind::FalseEdges {\n+                real_target,\n+                ref imaginary_targets,\n+            } => {\n+                self.assert_iscleanup(mir, block_data, real_target, is_cleanup);\n                 for target in imaginary_targets {\n-                    self.assert_iscleanup(mir, block, *target, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n                 }\n             }\n         }\n     }\n \n-    fn assert_iscleanup(&mut self,\n-                        mir: &Mir<'tcx>,\n-                        ctxt: &fmt::Debug,\n-                        bb: BasicBlock,\n-                        iscleanuppad: bool)\n-    {\n+    fn assert_iscleanup(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        ctxt: &fmt::Debug,\n+        bb: BasicBlock,\n+        iscleanuppad: bool,\n+    ) {\n         if mir[bb].is_cleanup != iscleanuppad {\n-            span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\",\n-                         bb, iscleanuppad);\n+            span_mirbug!(\n+                self,\n+                ctxt,\n+                \"cleanuppad mismatch: {:?} should be {:?}\",\n+                bb,\n+                iscleanuppad\n+            );\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Mir<'gcx>, local: Local, local_decl: &LocalDecl<'gcx>) {\n+    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -716,84 +980,81 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 //\n                 // Unbound parts of arguments were never required to be Sized\n                 // - maybe we should make that a warning.\n-                return\n+                return;\n             }\n             LocalKind::Var | LocalKind::Temp => {}\n         }\n \n         let span = local_decl.source_info.span;\n         let ty = local_decl.ty;\n-        if !ty.is_sized(self.tcx().global_tcx(), self.param_env, span) {\n+\n+        // Erase the regions from `ty` to get a global type.  The\n+        // `Sized` bound in no way depends on precise regions, so this\n+        // shouldn't affect `is_sized`.\n+        let gcx = self.tcx().global_tcx();\n+        let erased_ty = gcx.lift(&self.tcx().erase_regions(&ty)).unwrap();\n+        if !erased_ty.is_sized(gcx, self.param_env, span) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                span_err!(self.tcx().sess, span, E0161,\n-                          \"cannot move a value of type {0}: the size of {0} \\\n-                           cannot be statically determined\", ty);\n+                span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0161,\n+                    \"cannot move a value of type {0}: the size of {0} \\\n+                     cannot be statically determined\",\n+                    ty\n+                );\n             }\n         }\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'gcx>) {\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n         for (local, local_decl) in mir.local_decls.iter_enumerated() {\n             self.check_local(mir, local, local_decl);\n         }\n \n-        for block in mir.basic_blocks() {\n-            for stmt in &block.statements {\n+        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+            let mut location = Location {\n+                block,\n+                statement_index: 0,\n+            };\n+            for stmt in &block_data.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n                     self.last_span = stmt.source_info.span;\n                 }\n-                self.check_stmt(mir, stmt);\n+                self.check_stmt(mir, stmt, location);\n+                location.statement_index += 1;\n             }\n \n-            self.check_terminator(mir, block.terminator());\n-            self.check_iscleanup(mir, block);\n+            self.check_terminator(mir, block_data.terminator(), location);\n+            self.check_iscleanup(mir, block_data);\n         }\n     }\n \n-\n-    fn normalize<T>(&mut self, value: &T) -> T\n-        where T: fmt::Debug + TypeFoldable<'tcx>\n+    fn normalize<T>(&mut self, value: &T, location: Location) -> T\n+    where\n+        T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n-        let mut selcx = traits::SelectionContext::new(self.infcx);\n-        let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, self.param_env, cause, value);\n-\n-        debug!(\"normalize: value={:?} obligations={:?}\",\n-               value,\n-               obligations);\n-\n-        let fulfill_cx = &mut self.fulfillment_cx;\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(self.infcx, obligation);\n-        }\n-\n-        value\n-    }\n-\n-    fn verify_obligations(&mut self, mir: &Mir<'tcx>) {\n-        self.last_span = mir.span;\n-        if let Err(e) = self.fulfillment_cx.select_all_or_error(self.infcx) {\n-            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\",\n-                         e);\n-        }\n+        self.fully_perform_op(location.at_self(), |this| {\n+            let mut selcx = traits::SelectionContext::new(this.infcx);\n+            let cause = traits::ObligationCause::misc(this.last_span, ast::CRATE_NODE_ID);\n+            let traits::Normalized { value, obligations } =\n+                traits::normalize(&mut selcx, this.param_env, cause, value);\n+            Ok(InferOk { value, obligations })\n+        }).unwrap()\n     }\n }\n \n pub struct TypeckMir;\n \n impl MirPass for TypeckMir {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource,\n-                          mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         debug!(\"run_pass: {:?}\", def_id);\n@@ -805,17 +1066,44 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, id, param_env);\n-            {\n-                let mut verifier = TypeVerifier::new(&mut checker, mir);\n-                verifier.visit_mir(mir);\n-                if verifier.errors_reported {\n-                    // don't do further checks to avoid ICEs\n-                    return;\n-                }\n-            }\n-            checker.typeck_mir(mir);\n-            checker.verify_obligations(mir);\n+            let _region_constraint_sets = type_check(&infcx, id, param_env, mir);\n+\n+            // For verification purposes, we just ignore the resulting\n+            // region constraint sets. Not our problem. =)\n         });\n     }\n }\n+\n+trait AtLocation {\n+    /// Creates a `Locations` where `self` is both the from-location\n+    /// and the at-location. This means that any required region\n+    /// relationships must hold upon entering the statement/terminator\n+    /// indicated by `self`. This is typically used when processing\n+    /// \"inputs\" to the given location.\n+    fn at_self(self) -> Locations;\n+\n+    /// Creates a `Locations` where `self` is the from-location and\n+    /// its successor within the block is the at-location. This means\n+    /// that any required region relationships must hold only upon\n+    /// **exiting** the statement/terminator indicated by `self`. This\n+    /// is for example used when you have a `lv = rv` statement: it\n+    /// indicates that the `typeof(rv) <: typeof(lv)` as of the\n+    /// **next** statement.\n+    fn at_successor_within_block(self) -> Locations;\n+}\n+\n+impl AtLocation for Location {\n+    fn at_self(self) -> Locations {\n+        Locations {\n+            from_location: self,\n+            at_location: self,\n+        }\n+    }\n+\n+    fn at_successor_within_block(self) -> Locations {\n+        Locations {\n+            from_location: self,\n+            at_location: self.successor_within_block(),\n+        }\n+    }\n+}"}, {"sha": "e71f4fbef26539c28e0ddab2ee67b4cbb0d9b3a6", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -348,7 +348,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let indented_retptr = format!(\"{}let mut {:?}: {};\",\n                                   INDENT,\n                                   RETURN_POINTER,\n-                                  mir.return_ty);\n+                                  mir.local_decls[RETURN_POINTER].ty);\n     writeln!(w, \"{0:1$} // return pointer\",\n              indented_retptr,\n              ALIGN)?;"}, {"sha": "ea0fa945c378332ef314f03281ed94d4db5a0f49", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // 2. Things go horribly wrong if we use subtype. The reason for\n         // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_inference`, as well as the test\n+        // `givens` field in `region_constraints`, as well as the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n         // for details. Short version is that we must sometimes detect\n         // relationships between specific region variables and regions"}, {"sha": "24efb79170427b0ee0912525e371666d0a4bd588", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -10,8 +10,6 @@\n \n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n-use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::util::ExplicitSelf;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n@@ -38,8 +36,7 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_m_span: Span,\n                                      trait_m: &ty::AssociatedItem,\n                                      impl_trait_ref: ty::TraitRef<'tcx>,\n-                                     trait_item_span: Option<Span>,\n-                                     old_broken_mode: bool) {\n+                                     trait_item_span: Option<Span>) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n@@ -79,8 +76,7 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                              impl_m,\n                                                              impl_m_span,\n                                                              trait_m,\n-                                                             impl_trait_ref,\n-                                                             old_broken_mode) {\n+                                                             impl_trait_ref) {\n         return;\n     }\n }\n@@ -89,8 +85,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n                                           trait_m: &ty::AssociatedItem,\n-                                          impl_trait_ref: ty::TraitRef<'tcx>,\n-                                          old_broken_mode: bool)\n+                                          impl_trait_ref: ty::TraitRef<'tcx>)\n                                           -> Result<(), ErrorReported> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -106,7 +101,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             item_name: impl_m.name,\n             impl_item_def_id: impl_m.def_id,\n             trait_item_def_id: trait_m.def_id,\n-            lint_id: if !old_broken_mode { Some(impl_m_node_id) } else { None },\n         },\n     };\n \n@@ -342,22 +336,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        if old_broken_mode {\n-            // FIXME(#18937) -- this is how the code used to\n-            // work. This is buggy because the fulfillment cx creates\n-            // region obligations that get overlooked.  The right\n-            // thing to do is the code below. But we keep this old\n-            // pass around temporarily.\n-            let region_scope_tree = region::ScopeTree::default();\n-            let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n-            infcx.resolve_regions_and_report_errors(impl_m.def_id,\n-                                                    &region_scope_tree,\n-                                                    &free_regions);\n-        } else {\n-            let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n-            fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n-        }\n+        let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n+        fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n \n         Ok(())\n     })"}, {"sha": "b3a07027fb03223ed6ca536d6424869fb490ce02", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 38, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -137,7 +137,7 @@ mod autoderef;\n pub mod dropck;\n pub mod _match;\n pub mod writeback;\n-pub mod regionck;\n+mod regionck;\n pub mod coercion;\n pub mod demand;\n pub mod method;\n@@ -658,29 +658,10 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, param_env, value);\n+        let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n \n-    fn normalize_associated_types_in_as_infer_ok<T>(&self,\n-                                                    span: Span,\n-                                                    body_id: ast::NodeId,\n-                                                    param_env: ty::ParamEnv<'tcx>,\n-                                                    value: &T)\n-                                                    -> InferOk<'tcx, T>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value,\n-            obligations);\n-        InferOk { value, obligations }\n-    }\n-\n     /// Replace any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     fn liberate_late_bound_regions<T>(&self,\n@@ -1340,24 +1321,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 hir::ImplItemKind::Method(..) => {\n                     let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n-                        let err_count = tcx.sess.err_count();\n                         compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n-                                            trait_span,\n-                                            true); // start with old-broken-mode\n-                        if err_count == tcx.sess.err_count() {\n-                            // old broken mode did not report an error. Try with the new mode.\n-                            compare_impl_method(tcx,\n-                                                &ty_impl_item,\n-                                                impl_item.span,\n-                                                &ty_trait_item,\n-                                                impl_trait_ref,\n-                                                trait_span,\n-                                                false); // use the new mode\n-                        }\n+                                            trait_span);\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n@@ -1986,10 +1955,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in_as_infer_ok(span,\n-                                                           self.body_id,\n-                                                           self.param_env,\n-                                                           value)\n+        self.inh.partially_normalize_associated_types_in(span,\n+                                                         self.body_id,\n+                                                         self.param_env,\n+                                                         value)\n     }\n \n     pub fn require_type_meets(&self,"}, {"sha": "a17133d412c7a2b2f8b1f62fc4eedfd3a834d95e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 102, "deletions": 625, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -84,18 +84,14 @@\n \n use check::dropck;\n use check::FnCtxt;\n-use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n-use rustc::traits;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n+use rustc::ty::{self, Ty};\n+use rustc::infer::{self, OutlivesEnvironment};\n use rustc::ty::adjustment;\n-use rustc::ty::outlives::Component;\n-use rustc::ty::wf;\n \n use std::mem;\n use std::ops::Deref;\n@@ -117,7 +113,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject));\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(id),\n+                                      id,\n+                                      Subject(subject),\n+                                      self.param_env);\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         rcx.resolve_regions_and_report_errors();\n \n         assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n+        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n@@ -137,37 +137,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(subject));\n-        rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.param_env.caller_bounds);\n-        rcx.relate_free_regions(wf_tys, item_id, span);\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(item_id),\n+                                      item_id,\n+                                      Subject(subject),\n+                                      self.param_env);\n+        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.visit_region_obligations(item_id);\n         rcx.resolve_regions_and_report_errors();\n     }\n \n+    /// Region check a function body. Not invoked on closures, but\n+    /// only on the \"root\" fn item (in which closures may be\n+    /// embedded). Walks the function body and adds various add'l\n+    /// constraints that are needed for region inference. This is\n+    /// separated both to isolate \"pure\" region constraints from the\n+    /// rest of type check and because sometimes we need type\n+    /// inference to have completed before we can determine which\n+    /// constraints to add.\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(subject));\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(node_id),\n+                                      node_id,\n+                                      Subject(subject),\n+                                      self.param_env);\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n-        rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.param_env.caller_bounds);\n-\n         rcx.resolve_regions_and_report_errors();\n \n         // In this mode, we also copy the free-region-map into the\n         // tables of the enclosing fcx. In the other regionck modes\n         // (e.g., `regionck_item`), we don't have an enclosing tables.\n         assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n+        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n }\n \n@@ -177,11 +188,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-\n     pub region_scope_tree: Rc<region::ScopeTree>,\n \n-    free_region_map: FreeRegionMap<'tcx>,\n+    outlives_environment: OutlivesEnvironment<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n@@ -197,24 +206,6 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     type Target = FnCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -229,29 +220,22 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n+               Subject(subject): Subject,\n+               param_env: ty::ParamEnv<'tcx>)\n+               -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n             fcx,\n             region_scope_tree,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             call_site_scope: None,\n             subject_def_id: subject,\n-            region_bound_pairs: Vec::new(),\n-            free_region_map: FreeRegionMap::new(),\n+            outlives_environment,\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<region::Scope>)\n-                           -> Option<region::Scope> {\n-        mem::replace(&mut self.call_site_scope, call_site_scope)\n-    }\n-\n-    fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n-        mem::replace(&mut self.body_id, body_id)\n-    }\n-\n     fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.repeating_scope, scope)\n     }\n@@ -295,6 +279,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type(ty)\n     }\n \n+    /// This is the \"main\" function when region-checking a function item or a closure\n+    /// within a function item. It begins by updating various fields (e.g., `call_site_scope`\n+    /// and `outlives_environment`) to be appropriate to the function and then adds constraints\n+    /// derived from the function body.\n+    ///\n+    /// Note that it does **not** restore the state of the fields that\n+    /// it updates! This is intentional, since -- for the main\n+    /// function -- we wish to be able to read the final\n+    /// `outlives_environment` and other fields from the caller. For\n+    /// closures, however, we save and restore any \"scoped state\"\n+    /// before we invoke this function. (See `visit_fn` in the\n+    /// `intravisit::Visitor` impl below.)\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      body: &'gcx hir::Body,\n@@ -304,9 +300,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body(id={})\", id);\n \n         let body_id = body.id();\n+        self.body_id = body_id.node_id;\n \n         let call_site = region::Scope::CallSite(body.value.hir_id.local_id);\n-        let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n+        self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n             let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n@@ -318,8 +315,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let old_region_bounds_pairs_len = self.region_bound_pairs.len();\n-\n         // Collect the types from which we create inferred bounds.\n         // For the return type, if diverging, substitute `bool` just\n         // because it will have no effect.\n@@ -328,8 +323,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n-        let old_body_id = self.set_body_id(body_id.node_id);\n-        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n+        self.outlives_environment.add_implied_bounds(\n+            self.fcx,\n+            &fn_sig_tys[..],\n+            body_id.node_id,\n+            span);\n         self.link_fn_args(region::Scope::Node(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n@@ -342,11 +340,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n                                        body_hir_id,\n                                        call_site_region);\n-\n-        self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n-\n-        self.set_body_id(old_body_id);\n-        self.set_call_site_scope(old_call_site_scope);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -358,231 +351,17 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // obligations. So make sure we process those.\n         self.select_all_obligations_or_error();\n \n-        // Make a copy of the region obligations vec because we'll need\n-        // to be able to borrow the fulfillment-cx below when projecting.\n-        let region_obligations =\n-            self.fulfillment_cx\n-                .borrow()\n-                .region_obligations(node_id)\n-                .to_vec();\n-\n-        for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n-                   r_o, r_o.cause);\n-            let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = self.code_to_origin(&r_o.cause, sup_type);\n-            self.type_must_outlive(origin, sup_type, r_o.sub_region);\n-        }\n-\n-        // Processing the region obligations should not cause the list to grow further:\n-        assert_eq!(region_obligations.len(),\n-                   self.fulfillment_cx.borrow().region_obligations(node_id).len());\n-    }\n-\n-    fn code_to_origin(&self,\n-                      cause: &traits::ObligationCause<'tcx>,\n-                      sup_type: Ty<'tcx>)\n-                      -> SubregionOrigin<'tcx> {\n-        SubregionOrigin::from_obligation_cause(cause,\n-                                               || infer::RelateParamBound(cause.span, sup_type))\n-    }\n-\n-    /// This method populates the region map's `free_region_map`. It walks over the transformed\n-    /// argument and return types for each function just before we check the body of that function,\n-    /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n-    /// [usize]`.  We do not allow references to outlive the things they point at, so we can assume\n-    /// that `'a <= 'b`. This holds for both the argument and return types, basically because, on\n-    /// the caller side, the caller is responsible for checking that the type of every expression\n-    /// (including the actual values for the arguments, as well as the return type of the fn call)\n-    /// is well-formed.\n-    ///\n-    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n-    fn relate_free_regions(&mut self,\n-                           fn_sig_tys: &[Ty<'tcx>],\n-                           body_id: ast::NodeId,\n-                           span: Span) {\n-        debug!(\"relate_free_regions >>\");\n-\n-        for &ty in fn_sig_tys {\n-            let ty = self.resolve_type(ty);\n-            debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = self.implied_bounds(body_id, ty, span);\n-\n-            // But also record other relationships, such as `T:'x`,\n-            // that don't go into the free-region-map but which we use\n-            // here.\n-            for implication in implied_bounds {\n-                debug!(\"implication: {:?}\", implication);\n-                match implication {\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_),\n-                                                  &ty::ReVar(vid_b)) |\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_),\n-                                                  &ty::ReVar(vid_b)) => {\n-                        self.add_given(r_a, vid_b);\n-                    }\n-                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n-                        self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n-                    }\n-                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n-                        self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n-                    }\n-                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        self.free_region_map.relate_regions(r_a, r_b);\n-                    }\n-                }\n-            }\n-        }\n-\n-        debug!(\"<< relate_free_regions\");\n-    }\n-\n-    /// Compute the implied bounds that a callee/impl can assume based on\n-    /// the fact that caller/projector has ensured that `ty` is WF.  See\n-    /// the `ImpliedBound` type for more details.\n-    fn implied_bounds(&mut self, body_id: ast::NodeId, ty: Ty<'tcx>, span: Span)\n-                      -> Vec<ImpliedBound<'tcx>> {\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations =\n-                wf::obligations(self, self.fcx.param_env, body_id, ty, span)\n-                .unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            self.fcx.register_predicates(\n-                obligations.iter()\n-                           .filter(|o| o.predicate.has_infer_types())\n-                           .cloned());\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(\n-                obligations\n-                    .into_iter()\n-                    .flat_map(|obligation| {\n-                        assert!(!obligation.has_escaping_regions());\n-                        match obligation.predicate {\n-                            ty::Predicate::Trait(..) |\n-                            ty::Predicate::Equate(..) |\n-                            ty::Predicate::Subtype(..) |\n-                            ty::Predicate::Projection(..) |\n-                            ty::Predicate::ClosureKind(..) |\n-                            ty::Predicate::ObjectSafe(..) |\n-                            ty::Predicate::ConstEvaluatable(..) =>\n-                                vec![],\n-\n-                            ty::Predicate::WellFormed(subty) => {\n-                                wf_types.push(subty);\n-                                vec![]\n-                            }\n-\n-                            ty::Predicate::RegionOutlives(ref data) =>\n-                                match self.tcx.no_late_bound_regions(data) {\n-                                    None =>\n-                                        vec![],\n-                                    Some(ty::OutlivesPredicate(r_a, r_b)) =>\n-                                        vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n-                                },\n-\n-                            ty::Predicate::TypeOutlives(ref data) =>\n-                                match self.tcx.no_late_bound_regions(data) {\n-                                    None => vec![],\n-                                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                        let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n-                                        let components = self.tcx.outlives_components(ty_a);\n-                                        self.implied_bounds_from_components(r_b, components)\n-                                    }\n-                                },\n-                        }}));\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(&self,\n-                                      sub_region: ty::Region<'tcx>,\n-                                      sup_components: Vec<Component<'tcx>>)\n-                                      -> Vec<ImpliedBound<'tcx>>\n-    {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n-                }\n-            })\n-            .collect()\n+        self.infcx.process_registered_region_obligations(\n+            self.outlives_environment.region_bound_pairs(),\n+            self.implicit_region_bound,\n+            self.param_env,\n+            self.body_id);\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,\n-                                                   &self.free_region_map);\n+                                                   self.outlives_environment.free_region_map());\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n@@ -638,10 +417,28 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                b: hir::BodyId, span: Span, id: ast::NodeId) {\n-        let body = self.tcx.hir.body(b);\n-        self.visit_fn_body(id, body, span)\n+    fn visit_fn(&mut self,\n+                fk: intravisit::FnKind<'gcx>,\n+                _: &'gcx hir::FnDecl,\n+                body_id: hir::BodyId,\n+                span: Span,\n+                id: ast::NodeId) {\n+        assert!(match fk { intravisit::FnKind::Closure(..) => true, _ => false },\n+                \"visit_fn invoked for something other than a closure\");\n+\n+        // Save state of current function before invoking\n+        // `visit_fn_body`.  We will restore afterwards.\n+        let old_body_id = self.body_id;\n+        let old_call_site_scope = self.call_site_scope;\n+        let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n+\n+        let body = self.tcx.hir.body(body_id);\n+        self.visit_fn_body(id, body, span);\n+\n+        // Restore state from previous function.\n+        self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n+        self.call_site_scope = old_call_site_scope;\n+        self.body_id = old_body_id;\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -1137,6 +934,27 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n+    /// Adds constraints to inference such that `T: 'a` holds (or\n+    /// reports an error if it cannot).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`, the reason we need this constraint\n+    /// - `ty`, the type `T`\n+    /// - `region`, the region `'a`\n+    pub fn type_must_outlive(&self,\n+                             origin: infer::SubregionOrigin<'tcx>,\n+                             ty: Ty<'tcx>,\n+                             region: ty::Region<'tcx>)\n+    {\n+        self.infcx.type_must_outlive(self.outlives_environment.region_bound_pairs(),\n+                                     self.implicit_region_bound,\n+                                     self.param_env,\n+                                     origin,\n+                                     ty,\n+                                     region);\n+    }\n+\n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n     fn link_addr_of(&mut self, expr: &hir::Expr,\n@@ -1492,345 +1310,4 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n     }\n-\n-    /// Ensures that type is well-formed in `region`, which implies (among\n-    /// other things) that all borrowed data reachable via `ty` outlives\n-    /// `region`.\n-    pub fn type_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             ty: Ty<'tcx>,\n-                             region: ty::Region<'tcx>)\n-    {\n-        let ty = self.resolve_type(ty);\n-\n-        debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n-               ty,\n-               region,\n-               origin);\n-\n-        assert!(!ty.has_escaping_regions());\n-\n-        let components = self.tcx.outlives_components(ty);\n-        self.components_must_outlive(origin, components, region);\n-    }\n-\n-    fn components_must_outlive(&self,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               components: Vec<Component<'tcx>>,\n-                               region: ty::Region<'tcx>)\n-    {\n-        for component in components {\n-            let origin = origin.clone();\n-            match component {\n-                Component::Region(region1) => {\n-                    self.sub_regions(origin, region, region1);\n-                }\n-                Component::Param(param_ty) => {\n-                    self.param_ty_must_outlive(origin, region, param_ty);\n-                }\n-                Component::Projection(projection_ty) => {\n-                    self.projection_must_outlive(origin, region, projection_ty);\n-                }\n-                Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, subcomponents, region);\n-                }\n-                Component::UnresolvedInferenceVariable(v) => {\n-                    // ignore this, we presume it will yield an error\n-                    // later, since if a type variable is not resolved by\n-                    // this point it never will be\n-                    self.tcx.sess.delay_span_bug(\n-                        origin.span(),\n-                        &format!(\"unresolved inference variable in outlives: {:?}\", v));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn param_ty_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             region: ty::Region<'tcx>,\n-                             param_ty: ty::ParamTy) {\n-        debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n-               region, param_ty, origin);\n-\n-        let verify_bound = self.param_bound(param_ty);\n-        let generic = GenericKind::Param(param_ty);\n-        self.verify_generic_bound(origin, generic, region, verify_bound);\n-    }\n-\n-    fn projection_must_outlive(&self,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               region: ty::Region<'tcx>,\n-                               projection_ty: ty::ProjectionTy<'tcx>)\n-    {\n-        debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n-               region, projection_ty, origin);\n-\n-        // This case is thorny for inference. The fundamental problem is\n-        // that there are many cases where we have choice, and inference\n-        // doesn't like choice (the current region inference in\n-        // particular). :) First off, we have to choose between using the\n-        // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n-        // OutlivesProjectionComponent rules, any one of which is\n-        // sufficient.  If there are no inference variables involved, it's\n-        // not hard to pick the right rule, but if there are, we're in a\n-        // bit of a catch 22: if we picked which rule we were going to\n-        // use, we could add constraints to the region inference graph\n-        // that make it apply, but if we don't add those constraints, the\n-        // rule might not apply (but another rule might). For now, we err\n-        // on the side of adding too few edges into the graph.\n-\n-        // Compute the bounds we can derive from the environment or trait\n-        // definition.  We know that the projection outlives all the\n-        // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(origin.span(), projection_ty);\n-\n-        debug!(\"projection_must_outlive: env_bounds={:?}\",\n-               env_bounds);\n-\n-        // If we know that the projection outlives 'static, then we're\n-        // done here.\n-        if env_bounds.contains(&&ty::ReStatic) {\n-            debug!(\"projection_must_outlive: 'static as declared bound\");\n-            return;\n-        }\n-\n-        // If declared bounds list is empty, the only applicable rule is\n-        // OutlivesProjectionComponent. If there are inference variables,\n-        // then, we can break down the outlives into more primitive\n-        // components without adding unnecessary edges.\n-        //\n-        // If there are *no* inference variables, however, we COULD do\n-        // this, but we choose not to, because the error messages are less\n-        // good. For example, a requirement like `T::Item: 'r` would be\n-        // translated to a requirement that `T: 'r`; when this is reported\n-        // to the user, it will thus say \"T: 'r must hold so that T::Item:\n-        // 'r holds\". But that makes it sound like the only way to fix\n-        // the problem is to add `T: 'r`, which isn't true. So, if there are no\n-        // inference variables, we use a verify constraint instead of adding\n-        // edges, which winds up enforcing the same condition.\n-        let needs_infer = projection_ty.needs_infer();\n-        if env_bounds.is_empty() && needs_infer {\n-            debug!(\"projection_must_outlive: no declared bounds\");\n-\n-            for component_ty in projection_ty.substs.types() {\n-                self.type_must_outlive(origin.clone(), component_ty, region);\n-            }\n-\n-            for r in projection_ty.substs.regions() {\n-                self.sub_regions(origin.clone(), region, r);\n-            }\n-\n-            return;\n-        }\n-\n-        // If we find that there is a unique declared bound `'b`, and this bound\n-        // appears in the trait reference, then the best action is to require that `'b:'r`,\n-        // so do that. This is best no matter what rule we use:\n-        //\n-        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n-        // the requirement that `'b:'r`\n-        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n-        // other conditions\n-        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n-            let unique_bound = env_bounds[0];\n-            debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.substs.regions().any(|r| env_bounds.contains(&r)) {\n-                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.sub_regions(origin.clone(), region, unique_bound);\n-                return;\n-            }\n-        }\n-\n-        // Fallback to verifying after the fact that there exists a\n-        // declared bound, or that all the components appearing in the\n-        // projection outlive; in some cases, this may add insufficient\n-        // edges into the inference graph, leading to inference failures\n-        // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n-        let generic = GenericKind::Projection(projection_ty);\n-        self.verify_generic_bound(origin, generic.clone(), region, verify_bound);\n-    }\n-\n-    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n-            ty::TyParam(p) => {\n-                self.param_bound(p)\n-            }\n-            ty::TyProjection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(span, data);\n-                self.projection_bound(span, declared_bounds, data)\n-            }\n-            _ => {\n-                self.recursive_type_bound(span, ty)\n-            }\n-        }\n-    }\n-\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        debug!(\"param_bound(param_ty={:?})\",\n-               param_ty);\n-\n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n-\n-        // Add in the default bound of fn body that applies to all in\n-        // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n-\n-        VerifyBound::AnyRegion(param_bounds)\n-    }\n-\n-    fn projection_declared_bounds(&self,\n-                                  span: Span,\n-                                  projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<ty::Region<'tcx>>\n-    {\n-        // First assemble bounds from where clauses and traits.\n-\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n-\n-        declared_bounds.extend_from_slice(\n-            &self.declared_projection_bounds_from_trait(span, projection_ty));\n-\n-        declared_bounds\n-    }\n-\n-    fn projection_bound(&self,\n-                        span: Span,\n-                        declared_bounds: Vec<ty::Region<'tcx>>,\n-                        projection_ty: ty::ProjectionTy<'tcx>)\n-                        -> VerifyBound<'tcx> {\n-        debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-               declared_bounds, projection_ty);\n-\n-        // see the extensive comment in projection_must_outlive\n-        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(span, ty);\n-\n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n-    }\n-\n-    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = vec![];\n-\n-        for subty in ty.walk_shallow() {\n-            bounds.push(self.type_bound(span, subty));\n-        }\n-\n-        let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n-\n-        if bounds.len() == 1 {\n-            bounds.pop().unwrap()\n-        } else {\n-            VerifyBound::AllBounds(bounds)\n-        }\n-    }\n-\n-    fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<ty::Region<'tcx>>\n-    {\n-        let param_env = &self.param_env;\n-\n-        // To start, collect bounds from user:\n-        let mut param_bounds = self.tcx.required_region_bounds(generic.to_ty(self.tcx),\n-                                                               param_env.caller_bounds.to_vec());\n-\n-        // Next, collect regions we scraped from the well-formedness\n-        // constraints in the fn signature. To do that, we walk the list\n-        // of known relations from the fn ctxt.\n-        //\n-        // This is crucial because otherwise code like this fails:\n-        //\n-        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n-        //\n-        // The problem is that the type of `x` is `&'a A`. To be\n-        // well-formed, then, A must be lower-generic by `'a`, but we\n-        // don't know that this holds from first principles.\n-        for &(r, p) in &self.region_bound_pairs {\n-            debug!(\"generic={:?} p={:?}\",\n-                   generic,\n-                   p);\n-            if generic == p {\n-                param_bounds.push(r);\n-            }\n-        }\n-\n-        param_bounds\n-    }\n-\n-    fn declared_projection_bounds_from_trait(&self,\n-                                             span: Span,\n-                                             projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<ty::Region<'tcx>>\n-    {\n-        debug!(\"projection_bounds(projection_ty={:?})\",\n-               projection_ty);\n-        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-\n-        // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n-        // in looking for a trait definition like:\n-        //\n-        // ```\n-        // trait SomeTrait<'a> {\n-        //     type SomeType : 'a;\n-        // }\n-        // ```\n-        //\n-        // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.predicates_of(projection_ty.trait_ref(self.tcx).def_id);\n-        assert_eq!(trait_predicates.parent, None);\n-        let predicates = trait_predicates.predicates.as_slice().to_vec();\n-        traits::elaborate_predicates(self.tcx, predicates)\n-            .filter_map(|predicate| {\n-                // we're only interesting in `T : 'a` style predicates:\n-                let outlives = match predicate {\n-                    ty::Predicate::TypeOutlives(data) => data,\n-                    _ => { return None; }\n-                };\n-\n-                debug!(\"projection_bounds: outlives={:?} (1)\",\n-                       outlives);\n-\n-                // apply the substitutions (and normalize any projected types)\n-                let outlives = self.instantiate_type_scheme(span,\n-                                                            projection_ty.substs,\n-                                                            &outlives);\n-\n-                debug!(\"projection_bounds: outlives={:?} (2)\",\n-                       outlives);\n-\n-                let region_result = self.commit_if_ok(|_| {\n-                    let (outlives, _) =\n-                        self.replace_late_bound_regions_with_fresh_var(\n-                            span,\n-                            infer::AssocTypeProjection(projection_ty.item_def_id),\n-                            &outlives);\n-\n-                    debug!(\"projection_bounds: outlives={:?} (3)\",\n-                           outlives);\n-\n-                    // check whether this predicate applies to our current projection\n-                    let cause = self.fcx.misc(span);\n-                    match self.at(&cause, self.fcx.param_env).eq(outlives.0, ty) {\n-                        Ok(ok) => Ok((ok, outlives.1)),\n-                        Err(_) => Err(())\n-                    }\n-                }).map(|(ok, result)| {\n-                    self.register_infer_ok_obligations(ok);\n-                    result\n-                });\n-\n-                debug!(\"projection_bounds: region_result={:?}\",\n-                       region_result);\n-\n-                region_result.ok()\n-            })\n-            .collect()\n-    }\n }"}, {"sha": "014b8b14edb83942c1957c32c5a260c5fa878489", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -75,6 +75,7 @@ This API is completely unstable and subject to change.\n #![feature(advanced_slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n #![feature(conservative_impl_trait)]\n #![feature(match_default_bindings)]\n #![feature(never_type)]"}, {"sha": "f7f84e6452ddbc9fee4334c6fadbb726c0635fb5", "filename": "src/test/compile-fail/issue-18937.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -27,7 +27,6 @@ trait A<'a> {\n \n impl<'a> A<'a> for B {\n     fn foo<F>(&mut self, f: F) //~ ERROR impl has stricter\n-        //~^ WARNING future release\n         where F: fmt::Debug + 'static,\n     {\n         self.list.push(Box::new(f));"}, {"sha": "34d0482a623a9b6c7f03b5b4b9cc5e6fa6137e82", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -26,9 +26,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n-// | '_#0r: {bb0[0], bb0[1], '_#0r}\n-// | '_#1r: {bb0[0], bb0[1], '_#0r, '_#1r}\n-// | '_#2r: {bb0[0], bb0[1], '_#2r}\n-// ...\n-// fn use_x(_1: &'_#0r mut i32, _2: &'_#1r u32, _3: &'_#0r u32, _4: &'_#2r u32) -> bool {\n+// | '_#0r: {bb0[0], bb0[1], '_#0r, '_#1r, '_#2r, '_#3r}\n+// | '_#1r: {bb0[0], bb0[1], '_#1r}\n+// | '_#2r: {bb0[0], bb0[1], '_#1r, '_#2r}\n+// | '_#3r: {bb0[0], bb0[1], '_#3r}\n+// fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}, {"sha": "f51e839e4fc350ce11e942e17afe910bf6de5b86", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -28,12 +28,12 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r: {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#6r: {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n // ...\n-// | '_#7r: {bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#8r: {bb0[11], bb0[12], bb0[13], bb0[14]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n-// let _2: &'_#5r mut i32;\n+// let _2: &'_#6r mut i32;\n // ...\n-// let _4: &'_#7r mut i32;\n+// let _4: &'_#8r mut i32;\n // END rustc.main.nll.0.mir"}, {"sha": "ae059febc710956eb203dcd28afc7e43961743aa", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -31,15 +31,15 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#0r: {bb1[1], bb2[0], bb2[1]}\n // | '_#1r: {bb1[1], bb2[0], bb2[1]}\n+// | '_#2r: {bb1[1], bb2[0], bb2[1]}\n // ...\n-//             let _2: &'_#1r usize;\n+//             let _2: &'_#2r usize;\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb1: {\n //            | Live variables at bb1[0]: [_1, _3]\n-//        _2 = &'_#0r _1[_3];\n+//        _2 = &'_#1r _1[_3];\n //            | Live variables at bb1[1]: [_2]\n //        switchInt(const true) -> [0u8: bb3, otherwise: bb2];\n //    }"}, {"sha": "6d7aa0a26c8a8d129ee95fad87650238d61d7f3b", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -44,5 +44,5 @@ unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#4r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1]}\n+// | '_#5r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1]}\n // END rustc.main.nll.0.mir"}, {"sha": "2968ae7d485b1feb038dd8da7234e2c12e4f2f2c", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -46,5 +46,5 @@ impl<T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#4r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1], bb2[2], bb3[0], bb3[1], bb3[2], bb4[0], bb4[1], bb4[2], bb6[0], bb7[0], bb7[1], bb7[2], bb8[0]}\n+// | '_#5r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1], bb2[2], bb3[0], bb3[1], bb3[2], bb4[0], bb4[1], bb4[2], bb6[0], bb7[0], bb7[1], bb7[2], bb8[0]}\n // END rustc.main.nll.0.mir"}, {"sha": "736d2902ec63feea4d177d9a6c642f8cf9862abf", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -36,14 +36,14 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#0r: {bb1[1], bb2[0], bb2[1]}\n+// | '_#1r: {bb1[1], bb2[0], bb2[1]}\n // ...\n-// | '_#2r: {bb7[2], bb7[3], bb7[4]}\n-// | '_#3r: {bb1[1], bb2[0], bb2[1], bb7[2], bb7[3], bb7[4]}\n+// | '_#3r: {bb7[2], bb7[3], bb7[4]}\n+// | '_#4r: {bb1[1], bb2[0], bb2[1], bb7[2], bb7[3], bb7[4]}\n // ...\n-// let mut _2: &'_#3r usize;\n+// let mut _2: &'_#4r usize;\n // ...\n-// _2 = &'_#0r _1[_3];\n+// _2 = &'_#1r _1[_3];\n // ...\n-// _2 = &'_#2r (*_11);\n+// _2 = &'_#3r (*_11);\n // END rustc.main.nll.0.mir"}, {"sha": "fb178b46b470e18784f85d1ef42ef9df1f63344a", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -32,16 +32,16 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#0r: {bb1[1], bb1[2], bb1[3], bb1[4], bb1[5], bb1[6], bb2[0], bb2[1]}\n // | '_#1r: {bb1[1], bb1[2], bb1[3], bb1[4], bb1[5], bb1[6], bb2[0], bb2[1]}\n-// | '_#2r: {bb1[5], bb1[6], bb2[0], bb2[1]}\n+// | '_#2r: {bb1[1], bb1[2], bb1[3], bb1[4], bb1[5], bb1[6], bb2[0], bb2[1]}\n+// | '_#3r: {bb1[5], bb1[6], bb2[0], bb2[1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n-// let _2: &'_#1r usize;\n+// let _2: &'_#2r usize;\n // ...\n-// let _6: &'_#2r usize;\n+// let _6: &'_#3r usize;\n // ...\n-// _2 = &'_#0r _1[_3];\n+// _2 = &'_#1r _1[_3];\n // ...\n // _7 = _2;\n // ..."}, {"sha": "0e5cc574f002272aedc1fcfd21a0a81f30e89dee", "filename": "src/test/run-pass/implied-bounds-closure-arg-outlives.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to handle the relationships between free\n+// regions bound in a closure callback.\n+\n+#[derive(Copy, Clone)]\n+struct MyCx<'short, 'long: 'short> {\n+    short: &'short u32,\n+    long: &'long u32,\n+}\n+\n+impl<'short, 'long> MyCx<'short, 'long> {\n+    fn short(self) -> &'short u32 { self.short }\n+    fn long(self) -> &'long u32 { self.long }\n+    fn set_short(&mut self, v: &'short u32) { self.short = v; }\n+}\n+\n+fn with<F, R>(op: F) -> R\n+where\n+    F: for<'short, 'long> FnOnce(MyCx<'short, 'long>) -> R,\n+{\n+    op(MyCx {\n+        short: &22,\n+        long: &22,\n+    })\n+}\n+\n+fn main() {\n+    with(|mut cx| {\n+        // For this to type-check, we need to be able to deduce that\n+        // the lifetime of `l` can be `'short`, even though it has\n+        // input from `'long`.\n+        let l = if true { cx.long() } else { cx.short() };\n+        cx.set_short(l);\n+    });\n+}"}, {"sha": "3162ef54f39bcad6799c07ba4706b8de9589d067", "filename": "src/test/run-pass/regions-relate-bound-regions-on-closures-to-inference-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -42,7 +42,7 @@ impl<'a,'tcx> Foo<'a,'tcx> {\n             // inferring `'_2` to be `'static` in this case, because\n             // it is created outside the closure but then related to\n             // regions bound by the closure itself. See the\n-            // `region_inference.rs` file (and the `givens` field, in\n+            // `region_constraints.rs` file (and the `givens` field, in\n             // particular) for more details.\n             this.foo()\n         }))"}, {"sha": "f871f034a924d43f68c151c5ef43e8407b967591", "filename": "src/test/ui/compare-method/proj-outlives-region.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,15 +1,11 @@\n-error: impl has stricter requirements than trait\n+error[E0276]: impl has stricter requirements than trait\n   --> $DIR/proj-outlives-region.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;\n    |     --------------------- definition of `foo` from trait\n ...\n 19 |     fn foo() where U: 'a { } //~ ERROR E0276\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n-   |\n-   = note: #[deny(extra_requirement_in_impl)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #37166 <https://github.com/rust-lang/rust/issues/37166>\n \n error: aborting due to previous error\n "}, {"sha": "1df83c7fb0c3984fc46560b96036d89aaade0c2c", "filename": "src/test/ui/compare-method/region-unrelated.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,15 +1,11 @@\n-error: impl has stricter requirements than trait\n+error[E0276]: impl has stricter requirements than trait\n   --> $DIR/region-unrelated.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;\n    |     --------------------- definition of `foo` from trait\n ...\n 19 |     fn foo() where V: 'a { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `V: 'a`\n-   |\n-   = note: #[deny(extra_requirement_in_impl)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #37166 <https://github.com/rust-lang/rust/issues/37166>\n \n error: aborting due to previous error\n "}, {"sha": "5605206221a117e5e54573b629898cfd6bf46d6c", "filename": "src/test/ui/nll/get_default.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll -Zborrowck-mir\n+\n+struct Map {\n+}\n+\n+impl Map {\n+    fn get(&self) -> Option<&String> { None }\n+    fn set(&mut self, v: String) { }\n+}\n+\n+fn ok(map: &mut Map) -> &String {\n+    loop {\n+        match map.get() {\n+            Some(v) => {\n+                return v;\n+            }\n+            None => {\n+                map.set(String::new()); // Just AST errors here\n+            }\n+        }\n+    }\n+}\n+\n+fn err(map: &mut Map) -> &String {\n+    loop {\n+        match map.get() {\n+            Some(v) => {\n+                map.set(String::new()); // Both AST and MIR error here\n+                return v;\n+            }\n+            None => {\n+                map.set(String::new()); // Just AST errors here\n+            }\n+        }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "9586f426720349e373b6d5f85a4b303e839bd7df", "filename": "src/test/ui/nll/get_default.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -0,0 +1,47 @@\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:33:17\n+   |\n+28 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+33 |                 map.set(String::new()); // Just AST errors here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+37 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:43:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+42 |             Some(v) => {\n+43 |                 map.set(String::new()); // Both AST and MIR error here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+51 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:47:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+47 |                 map.set(String::new()); // Just AST errors here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+51 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `(*map)` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:43:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+42 |             Some(v) => {\n+43 |                 map.set(String::new()); // Both AST and MIR error here\n+   |                 ^^^ mutable borrow occurs here\n+\n+error: aborting due to 4 previous errors\n+"}]}