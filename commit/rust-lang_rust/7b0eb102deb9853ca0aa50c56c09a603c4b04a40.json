{"sha": "7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMGViMTAyZGViOTg1M2NhMGFhNTBjNTZjMDlhNjAzYzRiMDRhNDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-19T05:00:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T05:00:02Z"}, "message": "Rollup merge of #37230 - bluss:zip-specialization-for-map, r=alexcrichton\n\nExpand .zip() specialization to .map() and .cloned()\n\nImplement .zip() specialization for Map and Cloned.\n\nThe crucial thing for transparent specialization is that we want to\npreserve the potential side effects.\n\nThe simplest example is that in this code snippet:\n\n`(0..6).map(f).zip((0..4).map(g)).count()`\n\n`f` will be called five times, and `g` four times. The last time for `f`\nis when the other iterator is at its end, so this element is unused.\nThis side effect can be preserved without disturbing code generation for\nsimple uses of `.map()`.\n\nThe `Zip::next_back()` case is even more complicated, unfortunately.", "tree": {"sha": "54f6a6c58ae2e3081a133e54298c2cdc8e62991b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54f6a6c58ae2e3081a133e54298c2cdc8e62991b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "html_url": "https://github.com/rust-lang/rust/commit/7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beaa4c577963e4d1a401296b9e42067ff3890015", "url": "https://api.github.com/repos/rust-lang/rust/commits/beaa4c577963e4d1a401296b9e42067ff3890015", "html_url": "https://github.com/rust-lang/rust/commit/beaa4c577963e4d1a401296b9e42067ff3890015"}, {"sha": "ed5015939f02ce340bf3581c866f7b6ddabb6daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5015939f02ce340bf3581c866f7b6ddabb6daf", "html_url": "https://github.com/rust-lang/rust/commit/ed5015939f02ce340bf3581c866f7b6ddabb6daf"}], "stats": {"total": 187, "additions": 186, "deletions": 1}, "files": [{"sha": "9eeb2608071c2fd4bca9f43479e64b36f861f756", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "patch": "@@ -420,6 +420,18 @@ impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n     where I: FusedIterator<Item=&'a T>, T: Clone\n {}\n \n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        self.it.get_unchecked(i).clone()\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that repeats endlessly.\n ///\n /// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n@@ -773,6 +785,13 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n         } else {\n             None\n         }\n@@ -789,6 +808,23 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator\n     {\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n         if self.index < self.len {\n             self.len -= 1;\n             let i = self.len;\n@@ -814,6 +850,9 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n         (self.a.get_unchecked(i), self.b.get_unchecked(i))\n     }\n \n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -920,6 +959,18 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n+#[doc(hidden)]\n+unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+    where I: TrustedRandomAccess,\n+          F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        (self.f)(self.iter.get_unchecked(i))\n+    }\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n /// This `struct` is created by the [`filter()`] method on [`Iterator`]. See its\n@@ -1135,6 +1186,10 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n         (self.count + i, self.iter.get_unchecked(i))\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1764,6 +1819,10 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         self.iter.get_unchecked(i)\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "bc1aaa09f3dbd35d3f566c667dc896564b591ce5", "filename": "src/libcore/iter_private.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fiter_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fiter_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter_private.rs?ref=7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "patch": "@@ -14,12 +14,15 @@\n /// # Safety\n ///\n /// The iterator's .len() and size_hint() must be exact.\n+/// `.len()` must be cheap to call.\n ///\n /// .get_unchecked() must return distinct mutable references for distinct\n /// indices (if applicable), and must return a valid reference if index is in\n /// 0..self.len().\n #[doc(hidden)]\n pub unsafe trait TrustedRandomAccess : ExactSizeIterator {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+    /// Return `true` if getting an iterator element may have\n+    /// side effects. Remember to take inner iterators into account.\n+    fn may_have_side_effect() -> bool;\n }\n-"}, {"sha": "31be404ba905a1fcb580d0e219aa4528c7b96972", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "patch": "@@ -1968,11 +1968,13 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n         &*self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }\n \n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n         &mut *self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }"}, {"sha": "d0051c5165fe139253700b111cb7d8e64c506e8d", "filename": "src/test/codegen/zip.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Ftest%2Fcodegen%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Ftest%2Fcodegen%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fzip.rs?ref=7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "patch": "@@ -20,3 +20,12 @@ pub fn zip_copy(xs: &[u8], ys: &mut [u8]) {\n         *y = *x;\n     }\n }\n+\n+// CHECK-LABEL: @zip_copy_mapped\n+#[no_mangle]\n+pub fn zip_copy_mapped(xs: &[u8], ys: &mut [u8]) {\n+// CHECK: memcpy\n+    for (x, y) in xs.iter().map(|&x| x).zip(ys) {\n+        *y = x;\n+    }\n+}"}, {"sha": "b0503bc2048e7b626af1713c62d789fe778b4a5c", "filename": "src/test/run-pass/iter-zip.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Ftest%2Frun-pass%2Fiter-zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0eb102deb9853ca0aa50c56c09a603c4b04a40/src%2Ftest%2Frun-pass%2Fiter-zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-zip.rs?ref=7b0eb102deb9853ca0aa50c56c09a603c4b04a40", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that .zip() specialization preserves side effects\n+// in sideeffectful iterator adaptors.\n+\n+use std::cell::Cell;\n+\n+#[derive(Debug)]\n+struct CountClone(Cell<i32>);\n+\n+fn count_clone() -> CountClone { CountClone(Cell::new(0)) }\n+\n+impl PartialEq<i32> for CountClone {\n+    fn eq(&self, rhs: &i32) -> bool {\n+        self.0.get() == *rhs\n+    }\n+}\n+\n+impl Clone for CountClone {\n+    fn clone(&self) -> Self {\n+        let ret = CountClone(self.0.clone());\n+        let n = self.0.get();\n+        self.0.set(n + 1);\n+        ret\n+    }\n+}\n+\n+fn test_zip_cloned_sideffectful() {\n+    let xs = [count_clone(), count_clone(), count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n+    assert_eq!(&ys, &[1, 1][..]);\n+\n+    let xs = [count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone(), count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n+\n+    assert_eq!(&xs, &[1, 1][..]);\n+    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n+}\n+\n+fn test_zip_map_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+\n+    let mut xs = [0; 4];\n+    let mut ys = [0; 6];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n+}\n+\n+fn test_zip_map_rev_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n+    assert_eq!(&ys, &[0, 0, 0, 1]);\n+\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        (&mut it).take(5).count();\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+}\n+\n+fn test_zip_nested_sideffectful() {\n+    let mut xs = [0; 6];\n+    let ys = [0; 4];\n+\n+    {\n+        // test that it has the side effect nested inside enumerate\n+        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n+        it.count();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+}\n+\n+fn main() {\n+    test_zip_cloned_sideffectful();\n+    test_zip_map_sideffectful();\n+    test_zip_map_rev_sideffectful();\n+    test_zip_nested_sideffectful();\n+}"}]}