{"sha": "ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMjAyOWZjNjJkNzQ0ZTI1MmE1YTA3N2NlMGRmYmYyZDE2ODNkMjU=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-20T03:31:42Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-20T03:31:42Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "8b7a0aebcf10870fd331c8d76dc00f19091b2713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b7a0aebcf10870fd331c8d76dc00f19091b2713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "html_url": "https://github.com/rust-lang/rust/commit/ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2556400a5d4c9b56084332c29b6c91ac5cd3a9fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2556400a5d4c9b56084332c29b6c91ac5cd3a9fa", "html_url": "https://github.com/rust-lang/rust/commit/2556400a5d4c9b56084332c29b6c91ac5cd3a9fa"}, {"sha": "0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "html_url": "https://github.com/rust-lang/rust/commit/0bd2ce62b27e2b9a7dfe92fc23d9098854008089"}], "stats": {"total": 16626, "additions": 11984, "deletions": 4642}, "files": [{"sha": "a1bbb8a884fefb47fe534c17f724e516692c8679", "filename": ".travis.yml", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,33 +1,82 @@\n-language: generic\n+language: rust\n sudo: required\n+dist: trusty\n services:\n   - docker\n \n-# LLVM takes awhile to check out and otherwise we'll manage the submodules in\n-# our configure script, so disable auto submodule management.\n git:\n-  submodules: false\n   depth: 1\n+  submodules: false\n \n-before_install:\n-  - docker build -t rust -f src/etc/Dockerfile src/etc\n+matrix:\n+  include:\n+    # Linux builders, all docker images\n+    - env: IMAGE=arm-android\n+    - env: IMAGE=cross\n+    - env: IMAGE=i686-gnu\n+    - env: IMAGE=i686-gnu-nopt\n+    - env: IMAGE=x86_64-freebsd\n+    - env: IMAGE=x86_64-gnu\n+    - env: IMAGE=x86_64-gnu-cargotest\n+    - env: IMAGE=x86_64-gnu-debug\n+    - env: IMAGE=x86_64-gnu-nopt\n+    - env: IMAGE=x86_64-gnu-rustbuild\n+    - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-musl\n+\n+    # OSX builders\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=i686-apple-darwin\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=check\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --enable-rustbuild\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n+    - env: >\n+        RUST_CHECK_TARGET=\n+        RUST_CONFIGURE_ARGS=--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios\n+        SRC=.\n+      os: osx\n+      install: brew install ccache\n \n script:\n-  - docker run -v `pwd`:/build rust\n-    sh -c \"\n-      ./configure --enable-vendor --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n-      make tidy &&\n-      make check -j4\n-    \"\n+  - if [ -z \"$ALLOW_PR\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n+        echo skipping, not a full build;\n+    elif [ -z \"$ENABLE_AUTO\" ] then\n+        echo skipping, not quite ready yet\n+    elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+        git submodule update --init;\n+        src/ci/run.sh;\n+    else\n+        git submodule update --init;\n+        src/ci/docker/run.sh $IMAGE;\n+    fi\n \n-# Real testing happens on http://buildbot.rust-lang.org/\n-#\n-# See https://github.com/rust-lang/rust-buildbot\n-#     CONTRIBUTING.md#pull-requests\n+# Save tagged docker images we created and load them if they're available\n+before_cache:\n+  - docker history -q rust-ci |\n+    grep -v missing |\n+    xargs docker save |\n+    gzip -9 > $HOME/docker/rust-ci.tar.gz\n+before_install:\n+  - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n \n notifications:\n   email: false\n \n-branches:\n-  only:\n-    - master\n+cache:\n+  directories:\n+    - $HOME/docker\n+    - $HOME/.ccache\n+    - $HOME/.cargo"}, {"sha": "e468a86e7acc32762b5853aabe42301fb882e702", "filename": "RELEASES.md", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,3 +1,260 @@\n+Version 1.13.0 (2016-11-10)\n+===========================\n+\n+Language\n+--------\n+\n+* [Stabilize the `?` operator][36995]. `?` is a simple way to propagate\n+  errors, like the `try!` macro, described in [RFC 0243].\n+* [Stabilize macros in type position][36014]. Described in [RFC 873].\n+* [Stabilize attributes on statements][36995]. Described in [RFC 0016].\n+* [Fix `#[derive]` for empty tuple structs/variants][35728]\n+* [Fix lifetime rules for 'if' conditions][36029]\n+* [Avoid loading and parsing unconfigured non-inline modules][36482]\n+\n+Compiler\n+--------\n+\n+* [Add the `-C link-arg` argument][36574]\n+* [Remove the old AST-based backend from rustc_trans][35764]\n+* [Don't enable NEON by default on armv7 Linux][35814]\n+* [Fix debug line number info for macro expansions][35238]\n+* [Do not emit \"class method\" debuginfo for types that are not\n+  DICompositeType][36008]\n+* [Warn about multiple conflicting #[repr] hints][34623]\n+* [When sizing DST, don't double-count nested struct prefixes][36351]\n+* [Default RUST_MIN_STACK to 16MiB for now][36505]\n+* [Improve rlib metadata format][36551]. Reduces rlib size significantly.\n+* [Reject macros with empty repetitions to avoid infinite loop][36721]\n+* [Expand macros without recursing to avoid stack overflows][36214]\n+\n+Diagnostics\n+-----------\n+\n+* [Replace macro backtraces with labeled local uses][35702]\n+* [Improve error message for missplaced doc comments][33922]\n+* [Buffer unix and lock windows to prevent message interleaving][35975]\n+* [Update lifetime errors to specifically note temporaries][36171]\n+* [Special case a few colors for Windows][36178]\n+* [Suggest `use self` when such an import resolves][36289]\n+* [Be more specific when type parameter shadows primitive type][36338]\n+* Many minor improvements\n+\n+Compile-time Optimizations\n+--------------------------\n+\n+* [Compute and cache HIR hashes at beginning][35854]\n+* [Don't hash types in loan paths][36004]\n+* [Cache projections in trans][35761]\n+* [Optimize the parser's last token handling][36527]\n+* [Only instantiate #[inline] functions in codegen units referencing\n+  them][36524]. This leads to big improvements in cases where crates export\n+  define many inline functions without using them directly.\n+* [Lazily allocate TypedArena's first chunk][36592]\n+* [Don't allocate during default HashSet creation][36734]\n+\n+Stabilized APIs\n+---------------\n+\n+* [`checked_abs`]\n+* [`wrapping_abs`]\n+* [`overflowing_abs`]\n+* [`RefCell::try_borrow`]\n+* [`RefCell::try_borrow_mut`]\n+\n+Libraries\n+---------\n+\n+* [Add `assert_ne!` and `debug_assert_ne!`][35074]\n+* [Make `vec_deque::Drain`, `hash_map::Drain`, and `hash_set::Drain`\n+  covariant][35354]\n+* [Implement `AsRef<[T]>` for `std::slice::Iter`][35559]\n+* [Implement `Debug` for `std::vec::IntoIter`][35707]\n+* [`CString`: avoid excessive growth just to 0-terminate][35871]\n+* [Implement `CoerceUnsized` for `{Cell, RefCell, UnsafeCell}`][35627]\n+* [Use arc4rand on FreeBSD][35884]\n+* [memrchr: Correct aligned offset computation][35969]\n+* [Improve Demangling of Rust Symbols][36059]\n+* [Use monotonic time in condition variables][35048]\n+* [Implement `Debug` for `std::path::{Components,Iter}`][36101]\n+* [Implement conversion traits for `char`][35755]\n+* [Fix illegal instruction caused by overflow in channel cloning][36104]\n+* [Zero first byte of CString on drop][36264]\n+* [Inherit overflow checks for sum and product][36372]\n+* [Add missing Eq implementations][36423]\n+* [Implement `Debug` for `DirEntry`][36631]\n+* [When `getaddrinfo` returns `EAI_SYSTEM` retrieve actual error from\n+  `errno`][36754]\n+* [`SipHasher`] is deprecated. Use [`DefaultHasher`].\n+* [Implement more traits for `std::io::ErrorKind`][35911]\n+* [Optimize BinaryHeap bounds checking][36072]\n+* [Work around pointer aliasing issue in `Vec::extend_from_slice`,\n+  `extend_with_element`][36355]\n+* [Fix overflow checking in unsigned pow()][34942]\n+\n+Cargo\n+-----\n+\n+* This release includes security fixes to both curl and OpenSSL.\n+* [Fix transitive doctests when panic=abort][cargo/3021]\n+* [Add --all-features flag to cargo][cargo/3038]\n+* [Reject path-based dependencies in `cargo package`][cargo/3060]\n+* [Don't parse the home directory more than once][cargo/3078]\n+* [Don't try to generate Cargo.lock on empty workspaces][cargo/3092]\n+* [Update OpenSSL to 1.0.2j][cargo/3121]\n+* [Add license and license_file to cargo metadata output][cargo/3110]\n+* [Make crates-io registry URL optional in config; ignore all changes to\n+  source.crates-io][cargo/3089]\n+* [Don't download dependencies from other platforms][cargo/3123]\n+* [Build transitive dev-dependencies when needed][cargo/3125]\n+* [Add support for per-target rustflags in .cargo/config][cargo/3157]\n+* [Avoid updating registry when adding existing deps][cargo/3144]\n+* [Warn about path overrides that won't work][cargo/3136]\n+* [Use workspaces during `cargo install`][cargo/3146]\n+* [Leak mspdbsrv.exe processes on Windows][cargo/3162]\n+* [Add --message-format flag][cargo/3000]\n+* [Pass target environment for rustdoc][cargo/3205]\n+* [Use `CommandExt::exec` for `cargo run` on Unix][cargo/2818]\n+* [Update curl and curl-sys][cargo/3241]\n+* [Call rustdoc test with the correct cfg flags of a package][cargo/3242]\n+\n+Tooling\n+-------\n+\n+* [rustdoc: Add the `--sysroot` argument][36586]\n+* [rustdoc: Fix a couple of issues with the search results][35655]\n+* [rustdoc: remove the `!` from macro URLs and titles][35234]\n+* [gdb: Fix pretty-printing special-cased Rust types][35585]\n+* [rustdoc: Filter more incorrect methods inherited through Deref][36266]\n+\n+Misc\n+----\n+\n+* [Remove unmaintained style guide][35124]\n+* [Add s390x support][36369]\n+* [Initial work at Haiku OS support][36727]\n+* [Add mips-uclibc targets][35734]\n+* [Crate-ify compiler-rt into compiler-builtins][35021]\n+* [Add rustc version info (git hash + date) to dist tarball][36213]\n+* Many documentation improvements\n+\n+Compatibility Notes\n+-------------------\n+\n+* [`SipHasher`] is deprecated. Use [`DefaultHasher`].\n+* [Deny (by default) transmuting from fn item types to pointer-sized\n+  types][34923]. Continuing the long transition to zero-sized fn items,\n+  per [RFC 401].\n+* [Fix `#[derive]` for empty tuple structs/variants][35728].\n+  Part of [RFC 1506].\n+* [Issue deprecation warnings for safe accesses to extern statics][36173]\n+* [Fix lifetime rules for 'if' conditions][36029].\n+* [Inherit overflow checks for sum and product][36372].\n+* [Forbid user-defined macros named \"macro_rules\"][36730].\n+\n+[33922]: https://github.com/rust-lang/rust/pull/33922\n+[34623]: https://github.com/rust-lang/rust/pull/34623\n+[34923]: https://github.com/rust-lang/rust/pull/34923\n+[34942]: https://github.com/rust-lang/rust/pull/34942\n+[34982]: https://github.com/rust-lang/rust/pull/34982\n+[35021]: https://github.com/rust-lang/rust/pull/35021\n+[35048]: https://github.com/rust-lang/rust/pull/35048\n+[35074]: https://github.com/rust-lang/rust/pull/35074\n+[35124]: https://github.com/rust-lang/rust/pull/35124\n+[35234]: https://github.com/rust-lang/rust/pull/35234\n+[35238]: https://github.com/rust-lang/rust/pull/35238\n+[35354]: https://github.com/rust-lang/rust/pull/35354\n+[35559]: https://github.com/rust-lang/rust/pull/35559\n+[35585]: https://github.com/rust-lang/rust/pull/35585\n+[35627]: https://github.com/rust-lang/rust/pull/35627\n+[35655]: https://github.com/rust-lang/rust/pull/35655\n+[35702]: https://github.com/rust-lang/rust/pull/35702\n+[35707]: https://github.com/rust-lang/rust/pull/35707\n+[35728]: https://github.com/rust-lang/rust/pull/35728\n+[35734]: https://github.com/rust-lang/rust/pull/35734\n+[35755]: https://github.com/rust-lang/rust/pull/35755\n+[35761]: https://github.com/rust-lang/rust/pull/35761\n+[35764]: https://github.com/rust-lang/rust/pull/35764\n+[35814]: https://github.com/rust-lang/rust/pull/35814\n+[35854]: https://github.com/rust-lang/rust/pull/35854\n+[35871]: https://github.com/rust-lang/rust/pull/35871\n+[35884]: https://github.com/rust-lang/rust/pull/35884\n+[35911]: https://github.com/rust-lang/rust/pull/35911\n+[35969]: https://github.com/rust-lang/rust/pull/35969\n+[35975]: https://github.com/rust-lang/rust/pull/35975\n+[36004]: https://github.com/rust-lang/rust/pull/36004\n+[36008]: https://github.com/rust-lang/rust/pull/36008\n+[36014]: https://github.com/rust-lang/rust/pull/36014\n+[36029]: https://github.com/rust-lang/rust/pull/36029\n+[36059]: https://github.com/rust-lang/rust/pull/36059\n+[36072]: https://github.com/rust-lang/rust/pull/36072\n+[36101]: https://github.com/rust-lang/rust/pull/36101\n+[36104]: https://github.com/rust-lang/rust/pull/36104\n+[36171]: https://github.com/rust-lang/rust/pull/36171\n+[36173]: https://github.com/rust-lang/rust/pull/36173\n+[36178]: https://github.com/rust-lang/rust/pull/36178\n+[36213]: https://github.com/rust-lang/rust/pull/36213\n+[36214]: https://github.com/rust-lang/rust/pull/36214\n+[36264]: https://github.com/rust-lang/rust/pull/36264\n+[36266]: https://github.com/rust-lang/rust/pull/36266\n+[36289]: https://github.com/rust-lang/rust/pull/36289\n+[36338]: https://github.com/rust-lang/rust/pull/36338\n+[36351]: https://github.com/rust-lang/rust/pull/36351\n+[36355]: https://github.com/rust-lang/rust/pull/36355\n+[36369]: https://github.com/rust-lang/rust/pull/36369\n+[36372]: https://github.com/rust-lang/rust/pull/36372\n+[36423]: https://github.com/rust-lang/rust/pull/36423\n+[36482]: https://github.com/rust-lang/rust/pull/36482\n+[36505]: https://github.com/rust-lang/rust/pull/36505\n+[36524]: https://github.com/rust-lang/rust/pull/36524\n+[36527]: https://github.com/rust-lang/rust/pull/36527\n+[36551]: https://github.com/rust-lang/rust/pull/36551\n+[36574]: https://github.com/rust-lang/rust/pull/36574\n+[36586]: https://github.com/rust-lang/rust/pull/36586\n+[36592]: https://github.com/rust-lang/rust/pull/36592\n+[36631]: https://github.com/rust-lang/rust/pull/36631\n+[36639]: https://github.com/rust-lang/rust/pull/36639\n+[36721]: https://github.com/rust-lang/rust/pull/36721\n+[36727]: https://github.com/rust-lang/rust/pull/36727\n+[36730]: https://github.com/rust-lang/rust/pull/36730\n+[36734]: https://github.com/rust-lang/rust/pull/36734\n+[36754]: https://github.com/rust-lang/rust/pull/36754\n+[36995]: https://github.com/rust-lang/rust/pull/36995\n+[RFC 0016]: https://github.com/rust-lang/rfcs/blob/master/text/0016-more-attributes.md\n+[RFC 0243]: https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md\n+[RFC 1506]: https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md\n+[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+[RFC 873]: https://github.com/rust-lang/rfcs/blob/master/text/0873-type-macros.md\n+[cargo/2818]: https://github.com/rust-lang/cargo/pull/2818\n+[cargo/3000]: https://github.com/rust-lang/cargo/pull/3000\n+[cargo/3021]: https://github.com/rust-lang/cargo/pull/3021\n+[cargo/3038]: https://github.com/rust-lang/cargo/pull/3038\n+[cargo/3060]: https://github.com/rust-lang/cargo/pull/3060\n+[cargo/3078]: https://github.com/rust-lang/cargo/pull/3078\n+[cargo/3089]: https://github.com/rust-lang/cargo/pull/3089\n+[cargo/3092]: https://github.com/rust-lang/cargo/pull/3092\n+[cargo/3110]: https://github.com/rust-lang/cargo/pull/3110\n+[cargo/3121]: https://github.com/rust-lang/cargo/pull/3121\n+[cargo/3123]: https://github.com/rust-lang/cargo/pull/3123\n+[cargo/3125]: https://github.com/rust-lang/cargo/pull/3125\n+[cargo/3136]: https://github.com/rust-lang/cargo/pull/3136\n+[cargo/3144]: https://github.com/rust-lang/cargo/pull/3144\n+[cargo/3146]: https://github.com/rust-lang/cargo/pull/3146\n+[cargo/3157]: https://github.com/rust-lang/cargo/pull/3157\n+[cargo/3162]: https://github.com/rust-lang/cargo/pull/3162\n+[cargo/3205]: https://github.com/rust-lang/cargo/pull/3205\n+[cargo/3241]: https://github.com/rust-lang/cargo/pull/3241\n+[cargo/3242]: https://github.com/rust-lang/cargo/pull/3242\n+[rustup]: https://www.rustup.rs\n+[`checked_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.checked_abs\n+[`wrapping_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.wrapping_abs\n+[`overflowing_abs`]: https://doc.rust-lang.org/std/primitive.i32.html#method.overflowing_abs\n+[`RefCell::try_borrow`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow\n+[`RefCell::try_borrow_mut`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow_mut\n+[`SipHasher`]: https://doc.rust-lang.org/std/hash/struct.SipHasher.html\n+[`DefaultHasher`]: https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html\n+\n+\n Version 1.12.1 (2016-10-20)\n ===========================\n "}, {"sha": "133af075795c67981ff45e6241f455b7297302cf", "filename": "configure", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/configure", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -624,6 +624,7 @@ opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n+opt llvm-link-shared 0 \"prefer shared linking to LLVM (llvm-config --link-shared)\"\n opt rpath 1 \"build rpaths into rustc itself\"\n opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n # This is used by the automation to produce single-target nightlies\n@@ -642,6 +643,7 @@ opt_nosave optimize-cxx 1 \"build optimized C++ code\"\n opt_nosave optimize-llvm 1 \"build optimized LLVM\"\n opt_nosave llvm-assertions 0 \"build LLVM with assertions\"\n opt_nosave debug-assertions 0 \"build with debugging assertions\"\n+opt_nosave llvm-release-debuginfo 0 \"build LLVM with debugger metadata\"\n opt_nosave debuginfo 0 \"build with debugger metadata\"\n opt_nosave debuginfo-lines 0 \"build with line number debugger metadata\"\n opt_nosave debug-jemalloc 0 \"build jemalloc with --enable-debug --enable-fill\"\n@@ -778,6 +780,7 @@ if [ -n \"$CFG_DISABLE_OPTIMIZE_CXX\" ]; then putvar CFG_DISABLE_OPTIMIZE_CXX; fi\n if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then putvar CFG_DISABLE_OPTIMIZE_LLVM; fi\n if [ -n \"$CFG_ENABLE_LLVM_ASSERTIONS\" ]; then putvar CFG_ENABLE_LLVM_ASSERTIONS; fi\n if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTIONS; fi\n+if [ -n \"$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\" ]; then putvar CFG_ENABLE_LLVM_RELEASE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUGINFO_LINES\" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n@@ -852,6 +855,12 @@ probe_need CFG_CMAKE cmake\n # probe for it only in this case.\n if [ -n \"$CFG_ANTLR4\" ]\n then\n+   CFG_ANTLR4_JAR=\"\\\"$(find /usr/ -name antlr-complete.jar 2>/dev/null | head -n 1)\\\"\"\n+   if [ \"x\" -eq \"x$CFG_ANTLR4_JAR\" ]\n+   then\n+     CFG_ANTLR4_JAR=\"\\\"$(find ~ -name antlr-complete.jar 2>/dev/null | head -n 1)\\\"\"\n+   fi\n+   putvar CFG_ANTLR4_JAR      $CFG_ANTLR4_JAR\n    probe CFG_JAVAC            javac\n fi\n \n@@ -1772,6 +1781,8 @@ do\n \n     if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then\n         CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Debug\"\n+    elif [ -n \"$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\" ]; then\n+        CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=RelWithDebInfo\"\n     else\n         CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Release\"\n     fi\n@@ -1782,7 +1793,7 @@ do\n         CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_ENABLE_ASSERTIONS=ON\"\n     fi\n \n-    CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_TARGETS_TO_BUILD='X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend'\"\n+    CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_TARGETS_TO_BUILD='X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430'\"\n     CMAKE_ARGS=\"$CMAKE_ARGS -G '$CFG_CMAKE_GENERATOR'\"\n     CMAKE_ARGS=\"$CMAKE_ARGS $CFG_LLVM_SRC_DIR\"\n "}, {"sha": "98567a03c28a9804edb13c6448918dde719ccd89", "filename": "mk/cfg/armv5te-unknown-linux-gnueabi.mk", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv5te-unknown-linux-gnueabi.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,26 @@\n+# armv5-unknown-linux-gnueabi configuration\n+CROSS_PREFIX_armv5te-unknown-linux-gnueabi=arm-linux-gnueabi-\n+CC_armv5te-unknown-linux-gnueabi=gcc\n+CXX_armv5te-unknown-linux-gnueabi=g++\n+CPP_armv5te-unknown-linux-gnueabi=gcc -E\n+AR_armv5te-unknown-linux-gnueabi=ar\n+CFG_LIB_NAME_armv5te-unknown-linux-gnueabi=lib$(1).so\n+CFG_STATIC_LIB_NAME_armv5te-unknown-linux-gnueabi=lib$(1).a\n+CFG_LIB_GLOB_armv5te-unknown-linux-gnueabi=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_armv5te-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_armv5te-unknown-linux-gnueabi := -D__arm__ -mfloat-abi=soft  $(CFLAGS) -march=armv5te -marm\n+CFG_GCCISH_CFLAGS_armv5te-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfloat-abi=soft $(CFLAGS) -march=armv5te -marm\n+CFG_GCCISH_CXXFLAGS_armv5te-unknown-linux-gnueabi := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_armv5te-unknown-linux-gnueabi := -shared -fPIC -g\n+CFG_GCCISH_DEF_FLAG_armv5te-unknown-linux-gnueabi := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_armv5te-unknown-linux-gnueabi :=\n+CFG_INSTALL_NAME_ar,-unknown-linux-gnueabi =\n+CFG_EXE_SUFFIX_armv5te-unknown-linux-gnueabi :=\n+CFG_WINDOWSY_armv5te-unknown-linux-gnueabi :=\n+CFG_UNIXY_armv5te-unknown-linux-gnueabi := 1\n+CFG_LDPATH_armv5te-unknown-linux-gnueabi :=\n+CFG_RUN_armv5te-unknown-linux-gnueabi=$(2)\n+CFG_RUN_TARG_armv5te-unknown-linux-gnueabi=$(call CFG_RUN_armv5te-unknown-linux-gnueabi,,$(2))\n+RUSTC_FLAGS_armv5te-unknown-linux-gnueabi :=\n+RUSTC_CROSS_FLAGS_armv5te-unknown-linux-gnueabi :=\n+CFG_GNU_TRIPLE_armv5te-unknown-linux-gnueabi := armv5te-unknown-linux-gnueabi"}, {"sha": "7013d9f03f836c25e341b40622804577952dd021", "filename": "mk/clean.mk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -35,7 +35,7 @@ clean-all: clean clean-llvm\n \n clean-llvm: $(CLEAN_LLVM_RULES)\n \n-clean: clean-misc $(CLEAN_STAGE_RULES)\n+clean: clean-misc clean-grammar $(CLEAN_STAGE_RULES)\n \n clean-misc:\n \t@$(call E, cleaning)\n@@ -47,6 +47,9 @@ clean-misc:\n \t$(Q)rm -Rf dist/*\n \t$(Q)rm -Rf doc\n \n+clean-grammar:\n+\t@$(call E, cleaning grammar verification)\n+\t$(Q)rm -Rf grammar\n define CLEAN_GENERIC\n \n clean-generic-$(2)-$(1):"}, {"sha": "7ae5846c54b9965b8f26d6db7eca6d26bd0d8cdf", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -100,7 +100,7 @@ DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos rustc_data_structures\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log"}, {"sha": "1bd042adb218fdb958cc9a16bebd5f57e6ec1509", "filename": "mk/grammar.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -37,7 +37,7 @@ $(BG):\n \n $(BG)RustLexer.class: $(BG) $(SG)RustLexer.g4\n \t$(Q)$(CFG_ANTLR4) -o $(BG) $(SG)RustLexer.g4\n-\t$(Q)$(CFG_JAVAC) -d $(BG) $(BG)RustLexer.java\n+\t$(Q)$(CFG_JAVAC) -d $(BG) -classpath $(CFG_ANTLR4_JAR) $(BG)RustLexer.java\n \n check-build-lexer-verifier: $(BG)verify\n "}, {"sha": "76367e6f3a628c1d391b09d403dd17266987dc63", "filename": "mk/llvm.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -21,6 +21,8 @@ endif\n \n ifdef CFG_DISABLE_OPTIMIZE_LLVM\n LLVM_BUILD_CONFIG_MODE := Debug\n+else ifdef CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\n+LLVM_BUILD_CONFIG_MODE := RelWithDebInfo\n else\n LLVM_BUILD_CONFIG_MODE := Release\n endif"}, {"sha": "9936c5b59be5c4c8f26a817e72eba3e59b09a0cf", "filename": "mk/main.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.14.0\n+CFG_RELEASE_NUM=1.15.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n@@ -285,7 +285,7 @@ endif\n # LLVM macros\n ######################################################################\n \n-LLVM_OPTIONAL_COMPONENTS=x86 arm aarch64 mips powerpc pnacl systemz jsbackend\n+LLVM_OPTIONAL_COMPONENTS=x86 arm aarch64 mips powerpc pnacl systemz jsbackend msp430\n LLVM_REQUIRED_COMPONENTS=ipo bitreader bitwriter linker asmparser mcjit \\\n                 interpreter instrumentation\n "}, {"sha": "35ee7697a7a6974da5e9204d5a26933d0a5a2b35", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -697,6 +697,8 @@ CTEST_DEPS_ui_$(1)-T-$(2)-H-$(3) = $$(UI_TESTS)\n CTEST_DEPS_mir-opt_$(1)-T-$(2)-H-$(3) = $$(MIR_OPT_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n \t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n+\t\t$$(CSREQ$(1)_T_$(3)_H_$(3)) \\\n+\t\t$$(SREQ$(1)_T_$(3)_H_$(3)) \\\n \t\t$(S)src/etc/htmldocck.py\n \n endef"}, {"sha": "ab1c1c453dd23df68258c3b1da50fb72139167d1", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -409,7 +409,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n ]\n \n [[package]]\n@@ -520,6 +519,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -543,6 +543,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -621,6 +622,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "a3fabbb3e80941dad383635d58c3dba09f4b2c32", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -226,13 +226,16 @@ def cargo(self):\n         config = self.get_toml('cargo')\n         if config:\n             return config\n+        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n+        if config:\n+            return config + '/bin/cargo' + self.exe_suffix()\n         return os.path.join(self.bin_root(), \"bin/cargo\" + self.exe_suffix())\n \n     def rustc(self):\n         config = self.get_toml('rustc')\n         if config:\n             return config\n-        config = self.get_mk('CFG_LOCAL_RUST')\n+        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n         if config:\n             return config + '/bin/rustc' + self.exe_suffix()\n         return os.path.join(self.bin_root(), \"bin/rustc\" + self.exe_suffix())"}, {"sha": "ac6be2a870b0951973258d7e30c48870bb298ff4", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -130,17 +130,15 @@ pub fn compiletest(build: &Build,\n                              build.test_helpers_out(target).display()));\n     cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n-    // FIXME: CFG_PYTHON should probably be detected more robustly elsewhere\n-    let python_default = \"python\";\n-    cmd.arg(\"--docck-python\").arg(python_default);\n+    cmd.arg(\"--docck-python\").arg(build.python());\n \n     if build.config.build.ends_with(\"apple-darwin\") {\n         // Force /usr/bin/python on OSX for LLDB tests because we're loading the\n         // LLDB plugin's compiled module which only works with the system python\n         // (namely not Homebrew-installed python)\n         cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n     } else {\n-        cmd.arg(\"--lldb-python\").arg(python_default);\n+        cmd.arg(\"--lldb-python\").arg(build.python());\n     }\n \n     if let Some(ref gdb) = build.config.gdb {"}, {"sha": "236989dbcfeb50a4e610a3938ca8b3d1180d709d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -212,6 +212,9 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n         cargo.env(\"LLVM_STATIC_STDCPP\",\n                   compiler_file(build.cxx(target), \"libstdc++.a\"));\n     }\n+    if build.config.llvm_link_shared {\n+        cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+    }\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }"}, {"sha": "60f65f623006cac606deaba3b5042bd407b0ff4f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -50,8 +50,10 @@ pub struct Config {\n     // llvm codegen options\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n+    pub llvm_release_debuginfo: bool,\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n+    pub llvm_link_shared: bool,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n@@ -89,6 +91,7 @@ pub struct Config {\n     pub codegen_tests: bool,\n     pub nodejs: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n+    pub python: Option<PathBuf>,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -128,6 +131,8 @@ struct Build {\n     submodules: Option<bool>,\n     gdb: Option<String>,\n     vendor: Option<bool>,\n+    nodejs: Option<String>,\n+    python: Option<String>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -137,6 +142,7 @@ struct Llvm {\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n     optimize: Option<bool>,\n+    release_debuginfo: Option<bool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n }\n@@ -232,7 +238,9 @@ impl Config {\n         }\n         config.rustc = build.rustc.map(PathBuf::from);\n         config.cargo = build.cargo.map(PathBuf::from);\n+        config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n+        config.python = build.python.map(PathBuf::from);\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n@@ -243,6 +251,7 @@ impl Config {\n             set(&mut config.ninja, llvm.ninja);\n             set(&mut config.llvm_assertions, llvm.assertions);\n             set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n         }\n@@ -334,9 +343,11 @@ impl Config {\n                 (\"COMPILER_DOCS\", self.compiler_docs),\n                 (\"DOCS\", self.docs),\n                 (\"LLVM_ASSERTIONS\", self.llvm_assertions),\n+                (\"LLVM_RELEASE_DEBUGINFO\", self.llvm_release_debuginfo),\n                 (\"OPTIMIZE_LLVM\", self.llvm_optimize),\n                 (\"LLVM_VERSION_CHECK\", self.llvm_version_check),\n                 (\"LLVM_STATIC_STDCPP\", self.llvm_static_stdcpp),\n+                (\"LLVM_LINK_SHARED\", self.llvm_link_shared),\n                 (\"OPTIMIZE\", self.rust_optimize),\n                 (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n                 (\"DEBUGINFO\", self.rust_debuginfo),\n@@ -460,6 +471,10 @@ impl Config {\n                     self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));\n                     self.cargo = Some(push_exe_path(path, &[\"bin\", \"cargo\"]));\n                 }\n+                \"CFG_PYTHON\" if value.len() > 0 => {\n+                    let path = parse_configure_path(value);\n+                    self.python = Some(path);\n+                }\n                 _ => {}\n             }\n         }"}, {"sha": "b6774b3af20a52af1f3a0e279ad69cd80fbaf9da", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,6 +17,9 @@\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n \n+# Indicates whether an LLVM Release build should include debug info\n+#release-debuginfo = false\n+\n # Indicates whether the LLVM assertions are enabled or not\n #assertions = false\n \n@@ -79,9 +82,19 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n-# The path to (or name of) the GDB executable to use\n+# The path to (or name of) the GDB executable to use. This is only used for\n+# executing the debuginfo test suite.\n #gdb = \"gdb\"\n \n+# The node.js executable to use. Note that this is only used for the emscripten\n+# target when running tests, otherwise this can be omitted.\n+#nodejs = \"node\"\n+\n+# Python interpreter to use for various tasks throughout the build, notably\n+# rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n+# Note that Python 2 is currently required.\n+#python = \"python2.7\"\n+\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n "}, {"sha": "d603455122eb23c279136b37eec80e355b298a7d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -99,7 +99,7 @@ pub fn mingw(build: &Build, host: &str) {\n     // (which is what we want).\n     //\n     // FIXME: this script should be rewritten into Rust\n-    let mut cmd = Command::new(\"python\");\n+    let mut cmd = Command::new(build.python());\n     cmd.arg(build.src.join(\"src/etc/make-win-dist.py\"))\n        .arg(tmpdir(build))\n        .arg(&image)\n@@ -159,7 +159,7 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n     //\n     // FIXME: this script should be rewritten into Rust\n     if host.contains(\"pc-windows-gnu\") {\n-        let mut cmd = Command::new(\"python\");\n+        let mut cmd = Command::new(build.python());\n         cmd.arg(build.src.join(\"src/etc/make-win-dist.py\"))\n            .arg(&image)\n            .arg(tmpdir(build))"}, {"sha": "828e82d38321df60efe09df359dbd243e4f6f661", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -774,6 +774,11 @@ impl Build {\n             .or(self.config.musl_root.as_ref())\n             .map(|p| &**p)\n     }\n+\n+    /// Path to the python interpreter to use\n+    fn python(&self) -> &Path {\n+        self.config.python.as_ref().unwrap()\n+    }\n }\n \n impl<'a> Compiler<'a> {"}, {"sha": "1e73595ec998387d64014d21b08831bd77899399", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -57,6 +57,9 @@ else\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n endif\n tidy:\n-\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS) --stage 0\n+\n+check-stage2-android:\n+\t$(Q)$(BOOTSTRAP) --step check-target --target arm-linux-androideabi\n \n .PHONY: dist"}, {"sha": "96d1b695dd7075c77c124ba82ed4bdb0b02dc390", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -67,12 +67,20 @@ pub fn llvm(build: &Build, target: &str) {\n     if build.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n+\n+    let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n+        (false, _) => \"Debug\",\n+        (true, false) => \"Release\",\n+        (true, true) => \"RelWithDebInfo\",\n+    };\n+\n     cfg.target(target)\n        .host(&build.config.build)\n        .out_dir(&dst)\n-       .profile(if build.config.llvm_optimize {\"Release\"} else {\"Debug\"})\n+       .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-       .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend\")\n+       .define(\"LLVM_TARGETS_TO_BUILD\",\n+               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430\")\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")"}, {"sha": "47efa6952177cd82d2f010b28e6376d476f63004", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -79,17 +79,28 @@ pub fn check(build: &mut Build) {\n         break\n     }\n \n-    need_cmd(\"python\".as_ref());\n-\n-    // Look for the nodejs command, needed for emscripten testing\n-    if let Some(node) = have_cmd(\"node\".as_ref()) {\n-        build.config.nodejs = Some(node);\n-    } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n-        build.config.nodejs = Some(node);\n+    if build.config.python.is_none() {\n+        build.config.python = have_cmd(\"python2.7\".as_ref());\n+    }\n+    if build.config.python.is_none() {\n+        build.config.python = have_cmd(\"python2\".as_ref());\n+    }\n+    if build.config.python.is_none() {\n+        need_cmd(\"python\".as_ref());\n+        build.config.python = Some(\"python\".into());\n     }\n+    need_cmd(build.config.python.as_ref().unwrap().as_ref());\n+\n \n     if let Some(ref s) = build.config.nodejs {\n         need_cmd(s.as_ref());\n+    } else {\n+        // Look for the nodejs command, needed for emscripten testing\n+        if let Some(node) = have_cmd(\"node\".as_ref()) {\n+            build.config.nodejs = Some(node);\n+        } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n+            build.config.nodejs = Some(node);\n+        }\n     }\n \n     if let Some(ref gdb) = build.config.gdb {"}, {"sha": "56be2ccb235ad652281b16913d6f356141f08a8d", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -424,6 +424,7 @@ pub fn build_rules(build: &Build) -> Rules {\n          .host(true)\n          .run(move |_| dist::rust_src(build));\n     rules.dist(\"dist-docs\", \"src/doc\")\n+         .default(true)\n          .dep(|s| s.name(\"default:doc\"))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n     rules.dist(\"install\", \"src\")\n@@ -564,7 +565,8 @@ impl<'a> Rules<'a> {\n             for dep in rule.deps.iter() {\n                 let dep = dep(&self.sbuild.name(rule.name));\n                 if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n-                    continue }\n+                    continue\n+                }\n                 panic!(\"\\\n \n invalid rule dependency graph detected, was a rule added and maybe typo'd?\n@@ -685,8 +687,9 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n                     \"dist\" => Kind::Dist,\n                     kind => panic!(\"unknown kind: `{}`\", kind),\n                 };\n+                let host = self.build.config.host.iter().any(|h| h == dep.target);\n                 let rules = self.rules.values().filter(|r| r.default);\n-                for rule in rules.filter(|r| r.kind == kind) {\n+                for rule in rules.filter(|r| r.kind == kind && (!r.host || host)) {\n                     self.fill(dep.name(rule.name), order, added);\n                 }\n             } else {"}, {"sha": "c5b70c227c4080c5e2c7ab307f21668f75054eb5", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,46 @@\n+FROM ubuntu:16.04\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  unzip \\\n+  expect \\\n+  openjdk-9-jre \\\n+  sudo \\\n+  libstdc++6:i386\n+\n+WORKDIR /android/\n+ENV PATH=$PATH:/android/ndk-arm-9/bin:/android/sdk/tools:/android/sdk/platform-tools\n+\n+COPY install-ndk.sh install-sdk.sh accept-licenses.sh /android/\n+RUN sh /android/install-ndk.sh\n+RUN sh /android/install-sdk.sh\n+\n+COPY start-emulator.sh /android/\n+ENTRYPOINT [\"/android/start-emulator.sh\"]\n+\n+ENV TARGETS=arm-linux-androideabi\n+ENV TARGETS=$TARGETS,i686-linux-android\n+ENV TARGETS=$TARGETS,aarch64-linux-android\n+ENV TARGETS=$TARGETS,armv7-linux-androideabi\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=$TARGETS \\\n+      --arm-linux-androideabi-ndk=/android/ndk-arm-9 \\\n+      --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n+      --i686-linux-android-ndk=/android/ndk-x86-9 \\\n+      --aarch64-linux-android-ndk=/android/ndk-aarch64 \\\n+      --enable-rustbuild\n+ENV RUST_CHECK_TARGET check-stage2-android\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "8d8f60a5ec2604606571cdb6a7d231d5754aa38f", "filename": "src/ci/docker/arm-android/accept-licenses.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Faccept-licenses.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,15 @@\n+#!/usr/bin/expect -f\n+# ignore-license\n+\n+set timeout 1800\n+set cmd [lindex $argv 0]\n+set licenses [lindex $argv 1]\n+\n+spawn {*}$cmd\n+expect {\n+  \"Do you accept the license '*'*\" {\n+        exp_send \"y\\r\"\n+        exp_continue\n+  }\n+  eof\n+}"}, {"sha": "418ce69c5b1e5769e252034b918afa427dcfd2d6", "filename": "src/ci/docker/arm-android/install-ndk.sh", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,45 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+cpgdb() {\n+  cp android-ndk-r11c/prebuilt/linux-x86_64/bin/gdb /android/$1/bin/$2-gdb\n+  cp android-ndk-r11c/prebuilt/linux-x86_64/bin/gdb-orig /android/$1/bin/gdb-orig\n+  cp -r android-ndk-r11c/prebuilt/linux-x86_64/share /android/$1/share\n+}\n+\n+# Prep the Android NDK\n+#\n+# See https://github.com/servo/servo/wiki/Building-for-Android\n+curl -O https://dl.google.com/android/repository/android-ndk-r11c-linux-x86_64.zip\n+unzip -q android-ndk-r11c-linux-x86_64.zip\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-9 \\\n+        --toolchain=arm-linux-androideabi-4.9 \\\n+        --install-dir=/android/ndk-arm-9 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=arm\n+cpgdb ndk-arm-9 arm-linux-androideabi\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-21 \\\n+        --toolchain=aarch64-linux-android-4.9 \\\n+        --install-dir=/android/ndk-aarch64 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=arm64\n+bash android-ndk-r11c/build/tools/make-standalone-toolchain.sh \\\n+        --platform=android-9 \\\n+        --toolchain=x86-4.9 \\\n+        --install-dir=/android/ndk-x86-9 \\\n+        --ndk-dir=/android/android-ndk-r11c \\\n+        --arch=x86\n+\n+rm -rf ./android-ndk-r11c-linux-x86_64.zip ./android-ndk-r11c"}, {"sha": "2db1d46ba2273e89cfdb655ba59ef427ba0974ba", "filename": "src/ci/docker/arm-android/install-sdk.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Finstall-sdk.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+# Prep the SDK and emulator\n+#\n+# Note that the update process requires that we accept a bunch of licenses, and\n+# we can't just pipe `yes` into it for some reason, so we take the same strategy\n+# located in https://github.com/appunite/docker by just wrapping it in a script\n+# which apparently magically accepts the licenses.\n+\n+mkdir sdk\n+curl https://dl.google.com/android/android-sdk_r24.4-linux.tgz | \\\n+    tar xzf - -C sdk --strip-components=1\n+\n+filter=\"platform-tools,android-18\"\n+filter=\"$filter,sys-img-armeabi-v7a-android-18\"\n+\n+./accept-licenses.sh \"android - update sdk -a --no-ui --filter $filter\"\n+\n+echo \"no\" | android create avd \\\n+                --name arm-18 \\\n+                --target android-18 \\\n+                --abi armeabi-v7a"}, {"sha": "93f20b28b8689e4d37ce95bc648f174f8558353d", "filename": "src/ci/docker/arm-android/start-emulator.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+ANDROID_EMULATOR_FORCE_32BIT=true \\\n+  emulator @arm-18 -no-window -partition-size 2047 &\n+exec \"$@\""}, {"sha": "d8af878a95863f05dd32c5193f42ec3f37ef225b", "filename": "src/ci/docker/cross/Dockerfile", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,66 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gcc-aarch64-linux-gnu libc6-dev-arm64-cross \\\n+  gcc-arm-linux-gnueabi libc6-dev-armel-cross \\\n+  gcc-arm-linux-gnueabihf libc6-dev-armhf-cross \\\n+  gcc-mips-linux-gnu libc6-dev-mips-cross \\\n+  gcc-mipsel-linux-gnu libc6-dev-mipsel-cross \\\n+  gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \\\n+  gcc-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \\\n+  gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \\\n+  gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \\\n+  gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \\\n+  gcc-s390x-linux-gnu libc6-dev-s390x-cross\n+\n+ENV TARGETS=aarch64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,asmjs-unknown-emscripten\n+ENV TARGETS=$TARGETS,mips-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,mips64-unknown-linux-gnuabi64\n+ENV TARGETS=$TARGETS,mips64el-unknown-linux-gnuabi64\n+ENV TARGETS=$TARGETS,mipsel-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,powerpc64le-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,s390x-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n+\n+#ENV TARGETS=$TARGETS,mips-unknown-linux-musl\n+#ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n+#ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n+#ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n+#ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=$TARGETS \\\n+      --enable-rustbuild\n+ENV RUST_CHECK_TARGET \"\"\n+\n+ENV AR_s390x_unknown_linux_gnu=s390x-linux-gnu-ar \\\n+    CC_s390x_unknown_linux_gnu=s390x-linux-gnu-gcc \\\n+    AR_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-ar \\\n+    CC_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-gcc \\\n+    AR_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-ar \\\n+    CC_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-gcc \\\n+    AR_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-ar \\\n+    CC_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-gcc\n+\n+# FIXME(rust-lang/rust#36150): powerpc unfortunately aborts right now\n+ENV NO_LLVM_ASSERTIONS=1\n+\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "a9ef29daaf1a18cd0bd46bc2666d5bc6462c5319", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++-multilib \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d0ddde95b447364f241f3f22caeff6be833ea087", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++-multilib \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "c5b1d00fb7cc18420eddbd237b666d0f90ced724", "filename": "src/ci/docker/run.sh", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,42 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -e\n+\n+script=`cd $(dirname $0) && pwd`/`basename $0`\n+image=$1\n+\n+docker_dir=\"`dirname $script`\"\n+ci_dir=\"`dirname $docker_dir`\"\n+src_dir=\"`dirname $ci_dir`\"\n+root_dir=\"`dirname $src_dir`\"\n+\n+docker build \\\n+  --rm \\\n+  -t rust-ci \\\n+  \"`dirname \"$script\"`/$image\"\n+\n+mkdir -p $HOME/.ccache\n+mkdir -p $HOME/.cargo\n+\n+exec docker run \\\n+  --volume \"$root_dir:/checkout:ro\" \\\n+  --workdir /tmp/obj \\\n+  --env SRC=/checkout \\\n+  --env CCACHE_DIR=/ccache \\\n+  --volume \"$HOME/.ccache:/ccache\" \\\n+  --env CARGO_HOME=/cargo \\\n+  --env LOCAL_USER_ID=`id -u` \\\n+  --volume \"$HOME/.cargo:/cargo\" \\\n+  --interactive \\\n+  --tty \\\n+  rust-ci \\\n+  /checkout/src/ci/run.sh"}, {"sha": "dc16c39961c45e25af2d643f04e1831ce6ff05ae", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,29 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  bzip2 \\\n+  xz-utils \\\n+  wget\n+\n+COPY build-toolchain.sh /tmp/\n+RUN sh /tmp/build-toolchain.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n+    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc\n+\n+ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd --enable-rustbuild\n+ENV RUST_CHECK_TARGET \"\"\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d4bc886d50ea4952231782ff5835f634b9bebc6e", "filename": "src/ci/docker/x86_64-freebsd/build-toolchain.sh", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2Fbuild-toolchain.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,96 @@\n+#!/bin/bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+ARCH=x86_64\n+BINUTILS=2.25.1\n+GCC=5.3.0\n+\n+mkdir binutils\n+cd binutils\n+\n+# First up, build binutils\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+../binutils-$BINUTILS/configure \\\n+  --target=$ARCH-unknown-freebsd10\n+make -j10\n+make install\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download the FreeBSD libc and relevant header files\n+\n+mkdir freebsd\n+case \"$ARCH\" in\n+    x86_64)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/10.2-RELEASE/base.txz\n+        ;;\n+    i686)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/i386/10.2-RELEASE/base.txz\n+        ;;\n+esac\n+curl $URL | tar xJf - -C freebsd ./usr/include ./usr/lib ./lib\n+\n+dst=/usr/local/$ARCH-unknown-freebsd10\n+\n+cp -r freebsd/usr/include $dst/\n+cp freebsd/usr/lib/crt1.o $dst/lib\n+cp freebsd/usr/lib/Scrt1.o $dst/lib\n+cp freebsd/usr/lib/crti.o $dst/lib\n+cp freebsd/usr/lib/crtn.o $dst/lib\n+cp freebsd/usr/lib/libc.a $dst/lib\n+cp freebsd/usr/lib/libutil.a $dst/lib\n+cp freebsd/usr/lib/libutil_p.a $dst/lib\n+cp freebsd/usr/lib/libm.a $dst/lib\n+cp freebsd/usr/lib/librt.so.1 $dst/lib\n+cp freebsd/usr/lib/libexecinfo.so.1 $dst/lib\n+cp freebsd/lib/libc.so.7 $dst/lib\n+cp freebsd/lib/libm.so.5 $dst/lib\n+cp freebsd/lib/libutil.so.9 $dst/lib\n+cp freebsd/lib/libthr.so.3 $dst/lib/libpthread.so\n+\n+ln -s libc.so.7 $dst/lib/libc.so\n+ln -s libm.so.5 $dst/lib/libm.so\n+ln -s librt.so.1 $dst/lib/librt.so\n+ln -s libutil.so.9 $dst/lib/libutil.so\n+ln -s libexecinfo.so.1 $dst/lib/libexecinfo.so\n+rm -rf freebsd\n+\n+# Finally, download and build gcc to target FreeBSD\n+mkdir gcc\n+cd gcc\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n+./contrib/download_prerequisites\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+../gcc-$GCC/configure                            \\\n+  --enable-languages=c                           \\\n+  --target=$ARCH-unknown-freebsd10               \\\n+  --disable-multilib                             \\\n+  --disable-nls                                  \\\n+  --disable-libgomp                              \\\n+  --disable-libquadmath                          \\\n+  --disable-libssp                               \\\n+  --disable-libvtv                               \\\n+  --disable-libcilkrts                           \\\n+  --disable-libada                               \\\n+  --disable-libsanitizer                         \\\n+  --disable-libquadmath-support                  \\\n+  --disable-lto\n+make -j10\n+make install\n+cd ../..\n+rm -rf gcc"}, {"sha": "1db01f2b48d4691f3faee775c64fc1d0c38e9b33", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,20 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  libssl-dev \\\n+  sudo\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CHECK_TARGET check-cargotest\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "9e98215775e51719c37ca28901a0581c2975d48a", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-debug \\\n+      --enable-optimize\n+ENV RUST_CHECK_TARGET \"\"\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "ca06940ae5e2dc7c665b0f7b6ee779e84f868447", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python2.7-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb \\\n+  llvm-3.7-tools \\\n+  libedit-dev \\\n+  zlib1g-dev\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-rustbuild \\\n+      --llvm-root=/usr/lib/llvm-3.7\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "73a3e2c726cee601bfb2c16ab1fed5cd272d27bb", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "d4d0492e2a26049f5f0bb57d475a1ba859643410", "filename": "src/ci/docker/x86_64-gnu-rustbuild/Dockerfile", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-rustbuild%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,20 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python-minimal \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "f125693e7ae1a17468fa97e4e7a9eef1b0ae0c45", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,19 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  sudo \\\n+  gdb\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n+ENV RUST_CHECK_TARGET check\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "1afaef2e056781fa1b530a045622bd9683fe1b84", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,27 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  ccache \\\n+  xz-utils \\\n+  sudo \\\n+  gdb\n+\n+WORKDIR /build/\n+COPY build-musl.sh /build/\n+RUN sh /build/build-musl.sh && rm -rf /build\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --target=x86_64-unknown-linux-musl \\\n+      --musl-root=/musl-x86_64\n+ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n+\n+RUN mkdir /tmp/obj\n+RUN chmod 777 /tmp/obj"}, {"sha": "2bfbd646b75c8e050d934bd8bb06ed291ee7f9c8", "filename": "src/ci/docker/x86_64-musl/build-musl.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2Fbuild-musl.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+export CFLAGS=\"-fPIC\"\n+MUSL=musl-1.1.14\n+curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n+cd $MUSL\n+./configure --prefix=/musl-x86_64 --disable-shared\n+make -j10\n+make install\n+make clean\n+cd ..\n+\n+# To build MUSL we're going to need a libunwind lying around, so acquire that\n+# here and build it.\n+curl -L https://github.com/llvm-mirror/llvm/archive/release_37.tar.gz | tar xzf -\n+curl -L https://github.com/llvm-mirror/libunwind/archive/release_37.tar.gz | tar xzf -\n+mkdir libunwind-build\n+cd libunwind-build\n+cmake ../libunwind-release_37 -DLLVM_PATH=/build/llvm-release_37 \\\n+          -DLIBUNWIND_ENABLE_SHARED=0\n+make -j10\n+cp lib/libunwind.a /musl-x86_64/lib"}, {"sha": "da238dddecacb661e1f7f5426d2d91242c063e2c", "filename": "src/ci/run.sh", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,44 @@\n+#!/bin/sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -e\n+\n+if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n+  useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user\n+  export HOME=/home/user\n+  export LOCAL_USER_ID=\n+  exec sudo -E -u user env PATH=$PATH \"$0\"\n+fi\n+\n+if [ \"$NO_LLVM_ASSERTIONS\" = \"\" ]; then\n+  LLVM_ASSERTIONS=--enable-llvm-assertions\n+fi\n+\n+set -ex\n+\n+$SRC/configure \\\n+  --disable-manage-submodules \\\n+  --enable-debug-assertions \\\n+  --enable-quiet-tests \\\n+  --enable-ccache \\\n+  --enable-vendor \\\n+  $LLVM_ASSERTIONS \\\n+  $RUST_CONFIGURE_ARGS\n+\n+if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+    ncpus=$(sysctl -n hw.ncpu)\n+else\n+    ncpus=$(nproc)\n+fi\n+\n+make -j $ncpus tidy\n+make -j $ncpus\n+exec make $RUST_CHECK_TARGET -j $ncpus"}, {"sha": "3bc0272cab9fdcfc2ef4df9625ec3c9d5909db79", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1 +1 @@\n-Subproject commit ecd2b1f6d689d5afbf5debe8afb3739337323852\n+Subproject commit 3bc0272cab9fdcfc2ef4df9625ec3c9d5909db79"}, {"sha": "f416e600415bdab133619196950b73773af73d73", "filename": "src/doc/book/associated-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fassociated-types.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,7 +11,7 @@ this:\n trait Graph<N, E> {\n     fn has_edge(&self, &N, &N) -> bool;\n     fn edges(&self, &N) -> Vec<E>;\n-    // etc\n+    // Etc.\n }\n ```\n \n@@ -36,7 +36,7 @@ trait Graph {\n \n     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n     fn edges(&self, &Self::N) -> Vec<Self::E>;\n-    // etc\n+    // Etc.\n }\n ```\n "}, {"sha": "e054736eb30b63e8ec6ef09b0c101a441bbe5568", "filename": "src/doc/book/benchmark-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fbenchmark-tests.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -110,7 +110,7 @@ computation entirely. This could be done for the example above by adjusting the\n # struct X;\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n-    // note lack of `;` (could also use an explicit `return`).\n+    // Note lack of `;` (could also use an explicit `return`).\n     (0..1000).fold(0, |old, new| old ^ new)\n });\n ```"}, {"sha": "cbf65dfa9ba8c1b3e110835d27a787d0441ba628", "filename": "src/doc/book/box-syntax-and-patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -38,7 +38,7 @@ so as to avoid copying a large data structure. For example:\n struct BigStruct {\n     one: i32,\n     two: i32,\n-    // etc\n+    // Etc.\n     one_hundred: i32,\n }\n \n@@ -68,7 +68,7 @@ This is an antipattern in Rust. Instead, write this:\n struct BigStruct {\n     one: i32,\n     two: i32,\n-    // etc\n+    // Etc.\n     one_hundred: i32,\n }\n "}, {"sha": "296384ab6efd9507921cfa06e0e6ddc660e3e84a", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -106,7 +106,7 @@ from integers, and to cast between pointers to different types subject to\n some constraints. It is only unsafe to dereference the pointer:\n \n ```rust\n-let a = 300 as *const char; // a pointer to location 300\n+let a = 300 as *const char; // `a` is a pointer to location 300.\n let b = a as u32;\n ```\n \n@@ -135,14 +135,14 @@ cast four bytes into a `u32`:\n ```rust,ignore\n let a = [0u8, 0u8, 0u8, 0u8];\n \n-let b = a as u32; // four u8s makes a u32\n+let b = a as u32; // Four u8s makes a u32.\n ```\n \n This errors with:\n \n ```text\n error: non-scalar cast: `[u8; 4]` as `u32`\n-let b = a as u32; // four u8s makes a u32\n+let b = a as u32; // Four u8s makes a u32.\n         ^~~~~~~~\n ```\n \n@@ -170,7 +170,7 @@ fn main() {\n         let a = [0u8, 1u8, 0u8, 0u8];\n         let b = mem::transmute::<[u8; 4], u32>(a);\n         println!(\"{}\", b); // 256\n-        // or, more concisely:\n+        // Or, more concisely:\n         let c: u32 = mem::transmute(a);\n         println!(\"{}\", c); // 256\n     }"}, {"sha": "9dca3479d35e846e02965d8c2dec8f43166f1675", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -25,7 +25,7 @@ the following:\n ```rust\n let x = Box::new(1);\n let y = x;\n-// x no longer accessible here\n+// `x` is no longer accessible here.\n ```\n \n Here, the box was _moved_ into `y`. As `x` no longer owns it, the compiler will no longer allow the\n@@ -291,9 +291,9 @@ the inner data (mutably), and the lock will be released when the guard goes out\n ```rust,ignore\n {\n     let guard = mutex.lock();\n-    // guard dereferences mutably to the inner type\n+    // `guard` dereferences mutably to the inner type.\n     *guard += 1;\n-} // lock released when destructor runs\n+} // Lock is released when destructor runs.\n ```\n \n "}, {"sha": "a3c7333c6bec27af4444aaa784c78a9a4c96b5e2", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -116,7 +116,7 @@ let mut num = 5;\n {\n     let plus_num = |x: i32| x + num;\n \n-} // plus_num goes out of scope, borrow of num ends\n+} // `plus_num` goes out of scope; borrow of `num` ends.\n \n let y = &mut num;\n ```"}, {"sha": "8fa397cd9a666fa3d94092d674a94d98d5ee0f1f", "filename": "src/doc/book/comments.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcomments.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -10,7 +10,7 @@ and *doc comments*.\n ```rust\n // Line comments are anything after \u2018//\u2019 and extend to the end of the line.\n \n-let x = 5; // this is also a line comment.\n+let x = 5; // This is also a line comment.\n \n // If you have a long explanation for something, you can put line comments next\n // to each other. Put a space between the // and your comment so that it\u2019s"}, {"sha": "ff29358df9407e56c09469ba0606e5fc58539499", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -48,7 +48,7 @@ extern crate rustc_plugin;\n use syntax::parse::token;\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // trait for expr_usize\n+use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax::ext::quote::rt::Span;\n use rustc_plugin::Registry;\n "}, {"sha": "67d89d5484ca76a15c0c573910d3db82cc7d64ce", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -213,10 +213,10 @@ fn main() {\n     let mut data = Rc::new(vec![1, 2, 3]);\n \n     for i in 0..3 {\n-        // create a new owned reference\n+        // Create a new owned reference:\n         let data_ref = data.clone();\n \n-        // use it in a thread\n+        // Use it in a thread:\n         thread::spawn(move || {\n             data_ref[0] += i;\n         });\n@@ -390,8 +390,8 @@ use std::sync::mpsc;\n fn main() {\n     let data = Arc::new(Mutex::new(0));\n \n-    // `tx` is the \"transmitter\" or \"sender\"\n-    // `rx` is the \"receiver\"\n+    // `tx` is the \"transmitter\" or \"sender\".\n+    // `rx` is the \"receiver\".\n     let (tx, rx) = mpsc::channel();\n \n     for _ in 0..10 {"}, {"sha": "0e336635235b3ddef0251124790137d61026fa26", "filename": "src/doc/book/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcrates-and-modules.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -126,7 +126,7 @@ Instead of declaring a module like this:\n \n ```rust,ignore\n mod english {\n-    // contents of our module go here\n+    // Contents of our module go here.\n }\n ```\n "}, {"sha": "1996305f09e7311fe458ea45264d87c3466dcda7", "filename": "src/doc/book/custom-allocators.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcustom-allocators.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -41,7 +41,7 @@ which allocator is in use is done simply by linking to the desired allocator:\n extern crate alloc_system;\n \n fn main() {\n-    let a = Box::new(4); // allocates from the system allocator\n+    let a = Box::new(4); // Allocates from the system allocator.\n     println!(\"{}\", a);\n }\n ```\n@@ -57,7 +57,7 @@ uses jemalloc by default one would write:\n extern crate alloc_jemalloc;\n \n pub fn foo() {\n-    let a = Box::new(4); // allocates from jemalloc\n+    let a = Box::new(4); // Allocates from jemalloc.\n     println!(\"{}\", a);\n }\n # fn main() {}\n@@ -72,11 +72,11 @@ crate which implements the allocator API (e.g. the same as `alloc_system` or\n annotated version of `alloc_system`\n \n ```rust,no_run\n-# // only needed for rustdoc --test down below\n+# // Only needed for rustdoc --test down below.\n # #![feature(lang_items)]\n // The compiler needs to be instructed that this crate is an allocator in order\n // to realize that when this is linked in another allocator like jemalloc should\n-// not be linked in\n+// not be linked in.\n #![feature(allocator)]\n #![allocator]\n \n@@ -85,7 +85,7 @@ annotated version of `alloc_system`\n // however, can use all of libcore.\n #![no_std]\n \n-// Let's give a unique name to our custom allocator\n+// Let's give a unique name to our custom allocator:\n #![crate_name = \"my_allocator\"]\n #![crate_type = \"rlib\"]\n \n@@ -126,15 +126,15 @@ pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n #[no_mangle]\n pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,\n                                         _size: usize, _align: usize) -> usize {\n-    old_size // this api is not supported by libc\n+    old_size // This api is not supported by libc.\n }\n \n #[no_mangle]\n pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n     size\n }\n \n-# // only needed to get rustdoc to test this\n+# // Only needed to get rustdoc to test this:\n # fn main() {}\n # #[lang = \"panic_fmt\"] fn panic_fmt() {}\n # #[lang = \"eh_personality\"] fn eh_personality() {}\n@@ -149,7 +149,7 @@ After we compile this crate, it can be used as follows:\n extern crate my_allocator;\n \n fn main() {\n-    let a = Box::new(8); // allocates memory via our custom allocator crate\n+    let a = Box::new(8); // Allocates memory via our custom allocator crate.\n     println!(\"{}\", a);\n }\n ```"}, {"sha": "864cd282d93710ad94e59e6fac7e1d6fbb1ae1cd", "filename": "src/doc/book/deref-coercions.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fderef-coercions.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -33,13 +33,13 @@ automatically coerce to a `&T`. Here\u2019s an example:\n \n ```rust\n fn foo(s: &str) {\n-    // borrow a string for a second\n+    // Borrow a string for a second.\n }\n \n-// String implements Deref<Target=str>\n+// String implements Deref<Target=str>.\n let owned = \"Hello\".to_string();\n \n-// therefore, this works:\n+// Therefore, this works:\n foo(&owned);\n ```\n \n@@ -55,14 +55,14 @@ type implements `Deref<Target=T>`, so this works:\n use std::rc::Rc;\n \n fn foo(s: &str) {\n-    // borrow a string for a second\n+    // Borrow a string for a second.\n }\n \n-// String implements Deref<Target=str>\n+// String implements Deref<Target=str>.\n let owned = \"Hello\".to_string();\n let counted = Rc::new(owned);\n \n-// therefore, this works:\n+// Therefore, this works:\n foo(&counted);\n ```\n \n@@ -76,10 +76,10 @@ Another very common implementation provided by the standard library is:\n \n ```rust\n fn foo(s: &[i32]) {\n-    // borrow a slice for a second\n+    // Borrow a slice for a second.\n }\n \n-// Vec<T> implements Deref<Target=[T]>\n+// Vec<T> implements Deref<Target=[T]>.\n let owned = vec![1, 2, 3];\n \n foo(&owned);"}, {"sha": "f30a95b4e7890bd89e9e333408408eca52fe369e", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -28,7 +28,7 @@ code. You can use documentation comments for this purpose:\n /// let five = Rc::new(5);\n /// ```\n pub fn new(value: T) -> Rc<T> {\n-    // implementation goes here\n+    // Implementation goes here.\n }\n ```\n \n@@ -483,7 +483,7 @@ you have a module in `foo.rs`, you'll often open its code and see this:\n ```rust\n //! A module for using `foo`s.\n //!\n-//! The `foo` module contains a lot of useful functionality blah blah blah\n+//! The `foo` module contains a lot of useful functionality blah blah blah...\n ```\n \n ### Crate documentation"}, {"sha": "0b7ddcfbe8856e80178b49e2476f1c69bfb5977b", "filename": "src/doc/book/drop.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fdrop.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fdrop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdrop.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,9 +18,9 @@ impl Drop for HasDrop {\n fn main() {\n     let x = HasDrop;\n \n-    // do stuff\n+    // Do stuff.\n \n-} // x goes out of scope here\n+} // `x` goes out of scope here.\n ```\n \n When `x` goes out of scope at the end of `main()`, the code for `Drop` will"}, {"sha": "790d6ff85469f24a313bacf4bcd9b6e2f0b28896", "filename": "src/doc/book/enums.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fenums.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -51,7 +51,7 @@ possible variants:\n \n ```rust,ignore\n fn process_color_change(msg: Message) {\n-    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n+    let Message::ChangeColor(r, g, b) = msg; // This causes a compile-time error.\n }\n ```\n "}, {"sha": "0d9f49d66cbd8bac8ea1795792fc238abdf99561", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -65,7 +65,7 @@ and in most cases, the entire program aborts.) Here's an example:\n \n ```rust,should_panic\n // Guess a number between 1 and 10.\n-// If it matches the number we had in mind, return true. Else, return false.\n+// If it matches the number we had in mind, return `true`. Else, return `false`.\n fn guess(n: i32) -> bool {\n     if n < 1 || n > 10 {\n         panic!(\"Invalid number: {}\", n);\n@@ -350,7 +350,7 @@ fn file_path_ext_explicit(file_path: &str) -> Option<&str> {\n }\n \n fn file_name(file_path: &str) -> Option<&str> {\n-  // implementation elided\n+  // Implementation elided.\n   unimplemented!()\n }\n ```\n@@ -360,7 +360,7 @@ analysis, but its type doesn't quite fit...\n \n ```rust,ignore\n fn file_path_ext(file_path: &str) -> Option<&str> {\n-    file_name(file_path).map(|x| extension(x)) //Compilation error\n+    file_name(file_path).map(|x| extension(x)) // This causes a compilation error.\n }\n ```\n \n@@ -1235,11 +1235,11 @@ use std::fs;\n use std::io;\n use std::num;\n \n-// We have to jump through some hoops to actually get error values.\n+// We have to jump through some hoops to actually get error values:\n let io_err: io::Error = io::Error::last_os_error();\n let parse_err: num::ParseIntError = \"not a number\".parse::<i32>().unwrap_err();\n \n-// OK, here are the conversions.\n+// OK, here are the conversions:\n let err1: Box<Error> = From::from(io_err);\n let err2: Box<Error> = From::from(parse_err);\n ```\n@@ -1609,7 +1609,7 @@ fn main() {\n     let data_path = &matches.free[0];\n     let city: &str = &matches.free[1];\n \n-    // Do stuff with information\n+    // Do stuff with information.\n }\n ```\n \n@@ -1747,7 +1747,7 @@ simply ignoring that row.\n use std::path::Path;\n \n struct Row {\n-    // unchanged\n+    // This struct remains unchanged.\n }\n \n struct PopulationCount {\n@@ -1769,7 +1769,7 @@ fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n     for row in rdr.decode::<Row>() {\n         let row = row.unwrap();\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,\n@@ -1825,7 +1825,7 @@ Let's try it:\n ```rust,ignore\n use std::error::Error;\n \n-// The rest of the code before this is unchanged\n+// The rest of the code before this is unchanged.\n \n fn search<P: AsRef<Path>>\n          (file_path: P, city: &str)\n@@ -1836,7 +1836,7 @@ fn search<P: AsRef<Path>>\n     for row in rdr.decode::<Row>() {\n         let row = try!(row);\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,\n@@ -1957,7 +1957,7 @@ that it is generic on some type parameter `R` that satisfies\n ```rust,ignore\n use std::io;\n \n-// The rest of the code before this is unchanged\n+// The rest of the code before this is unchanged.\n \n fn search<P: AsRef<Path>>\n          (file_path: &Option<P>, city: &str)\n@@ -2070,7 +2070,7 @@ fn search<P: AsRef<Path>>\n     for row in rdr.decode::<Row>() {\n         let row = try!(row);\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,"}, {"sha": "7510cd0b3b591a3d2528fd8f0c46226d8b98aabc", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -95,7 +95,7 @@ internal details.\n \n Wrapping the functions which expect buffers involves using the `slice::raw` module to manipulate Rust\n vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The\n-length is number of elements currently contained, and the capacity is the total size in elements of\n+length is the number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n ```rust\n@@ -277,7 +277,7 @@ extern {\n fn main() {\n     unsafe {\n         register_callback(callback);\n-        trigger_callback(); // Triggers the callback\n+        trigger_callback(); // Triggers the callback.\n     }\n }\n ```\n@@ -294,7 +294,7 @@ int32_t register_callback(rust_callback callback) {\n }\n \n void trigger_callback() {\n-  cb(7); // Will call callback(7) in Rust\n+  cb(7); // Will call callback(7) in Rust.\n }\n ```\n \n@@ -320,13 +320,13 @@ Rust code:\n #[repr(C)]\n struct RustObject {\n     a: i32,\n-    // other members\n+    // Other members...\n }\n \n extern \"C\" fn callback(target: *mut RustObject, a: i32) {\n     println!(\"I'm called from C with value {0}\", a);\n     unsafe {\n-        // Update the value in RustObject with the value received from the callback\n+        // Update the value in RustObject with the value received from the callback:\n         (*target).a = a;\n     }\n }\n@@ -339,7 +339,7 @@ extern {\n }\n \n fn main() {\n-    // Create the object that will be referenced in the callback\n+    // Create the object that will be referenced in the callback:\n     let mut rust_object = Box::new(RustObject { a: 5 });\n \n     unsafe {\n@@ -363,7 +363,7 @@ int32_t register_callback(void* callback_target, rust_callback callback) {\n }\n \n void trigger_callback() {\n-  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n+  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust.\n }\n ```\n \n@@ -606,7 +606,7 @@ use libc::c_int;\n \n # #[cfg(hidden)]\n extern \"C\" {\n-    /// Register the callback.\n+    /// Registers the callback.\n     fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n }\n # unsafe fn register(_: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>,"}, {"sha": "b453936fe00d5f1a0183ae3034b6242595b276a7", "filename": "src/doc/book/functions.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ffunctions.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -135,7 +135,7 @@ In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n following will produce a compile-time error:\n \n ```rust,ignore\n-let x = (let y = 5); // expected identifier, found keyword `let`\n+let x = (let y = 5); // Expected identifier, found keyword `let`.\n ```\n \n The compiler is telling us here that it was expecting to see the beginning of\n@@ -151,7 +151,7 @@ other returned value would be too surprising:\n ```rust\n let mut y = 5;\n \n-let x = (y = 6);  // x has the value `()`, not `6`\n+let x = (y = 6);  // `x` has the value `()`, not `6`.\n ```\n \n The second kind of statement in Rust is the *expression statement*. Its\n@@ -183,7 +183,7 @@ But what about early returns? Rust does have a keyword for that, `return`:\n fn foo(x: i32) -> i32 {\n     return x;\n \n-    // we never run this code!\n+    // We never run this code!\n     x + 1\n }\n ```\n@@ -307,10 +307,10 @@ fn plus_one(i: i32) -> i32 {\n     i + 1\n }\n \n-// without type inference\n+// Without type inference:\n let f: fn(i32) -> i32 = plus_one;\n \n-// with type inference\n+// With type inference:\n let f = plus_one;\n ```\n "}, {"sha": "eafad6a05fc3d1275f68968a81b66b4917dd91f4", "filename": "src/doc/book/generics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgenerics.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -78,7 +78,7 @@ We can write functions that take generic types with a similar syntax:\n \n ```rust\n fn takes_anything<T>(x: T) {\n-    // do something with x\n+    // Do something with `x`.\n }\n ```\n "}, {"sha": "c854b7c373d20e144977972b1d7b94c10caa37c8", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -158,8 +158,8 @@ take a name on the left hand side of the assignment, it actually accepts a\n to use for now:\n \n ```rust\n-let foo = 5; // immutable.\n-let mut bar = 5; // mutable\n+let foo = 5; // `foo` is immutable.\n+let mut bar = 5; // `bar` is mutable.\n ```\n \n [immutable]: mutability.html"}, {"sha": "e531d5d7fc0ff7d3ffc35be49cca25bc4fa4045c", "filename": "src/doc/book/inline-assembly.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Finline-assembly.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -34,7 +34,7 @@ fn foo() {\n     }\n }\n \n-// other platforms\n+// Other platforms:\n #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n fn foo() { /* ... */ }\n \n@@ -130,7 +130,7 @@ stay valid.\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n-// Put the value 0x200 in eax\n+// Put the value 0x200 in eax:\n asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n # } }\n # #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]"}, {"sha": "6a08c1b6bb468a403514468d264ee5b4c5146692", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -32,7 +32,7 @@ pub struct Box<T>(*mut T);\n unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n-    // malloc failed\n+    // Check if `malloc` failed:\n     if p as usize == 0 {\n         abort();\n     }\n@@ -46,8 +46,8 @@ unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T>(ptr: *mut T) {\n-    deallocate(ptr as *mut u8, ::core::mem::size_of::<T>(), ::core::mem::align_of::<T>());\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    deallocate(ptr as *mut u8, ::core::mem::size_of_val(&*ptr), ::core::mem::align_of_val(&*ptr));\n }\n \n #[start]"}, {"sha": "397263c69733002afee50d718e039ae01b312b5e", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -54,13 +54,13 @@ dangling pointer or \u2018use after free\u2019, when the resource is memory. A small\n example of such a situation would be:\n \n ```rust,compile_fail\n-let r;              // Introduce reference: r\n+let r;              // Introduce reference: `r`.\n {\n-    let i = 1;      // Introduce scoped value: i\n-    r = &i;         // Store reference of i in r\n-}                   // i goes out of scope and is dropped.\n+    let i = 1;      // Introduce scoped value: `i`.\n+    r = &i;         // Store reference of `i` in `r`.\n+}                   // `i` goes out of scope and is dropped.\n \n-println!(\"{}\", r);  // r still refers to i\n+println!(\"{}\", r);  // `r` still refers to `i`.\n ```\n \n To fix this, we have to make sure that step four never happens after step\n@@ -81,9 +81,9 @@ let lang = \"en\";\n \n let v;\n {\n-    let p = format!(\"lang:{}=\", lang);  // -+ p goes into scope\n+    let p = format!(\"lang:{}=\", lang);  // -+ `p` comes into scope.\n     v = skip_prefix(line, p.as_str());  //  |\n-}                                       // -+ p goes out of scope\n+}                                       // -+ `p` goes out of scope.\n println!(\"{}\", v);\n ```\n \n@@ -191,7 +191,7 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n     let f = Foo { x: y };\n \n     println!(\"{}\", f.x);\n@@ -233,7 +233,7 @@ impl<'a> Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n     let f = Foo { x: y };\n \n     println!(\"x is: {}\", f.x());\n@@ -274,11 +274,11 @@ valid for. For example:\n \n ```rust\n fn main() {\n-    let y = &5;     // -+ y goes into scope\n+    let y = &5;     // -+ `y` comes into scope.\n                     //  |\n-    // stuff        //  |\n+    // Stuff...     //  |\n                     //  |\n-}                   // -+ y goes out of scope\n+}                   // -+ `y` goes out of scope.\n ```\n \n Adding in our `Foo`:\n@@ -289,11 +289,12 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n+    let y = &5;           // -+ `y` comes into scope.\n+    let f = Foo { x: y }; // -+ `f` comes into scope.\n                           //  |\n-}                         // -+ f and y go out of scope\n+    // Stuff...           //  |\n+                          //  |\n+}                         // -+ `f` and `y` go out of scope.\n ```\n \n Our `f` lives within the scope of `y`, so everything works. What if it didn\u2019t?\n@@ -305,16 +306,16 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let x;                    // -+ x goes into scope\n+    let x;                    // -+ `x` comes into scope.\n                               //  |\n     {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n+        let y = &5;           // ---+ `y` comes into scope.\n+        let f = Foo { x: y }; // ---+ `f` comes into scope.\n+        x = &f.x;             //  | | This causes an error.\n+    }                         // ---+ `f` and y go out of scope.\n                               //  |\n     println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n+}                             // -+ `x` goes out of scope.\n ```\n \n Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope"}, {"sha": "688e8c552653b8e156b646de4f6a982a337375ed", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -202,8 +202,8 @@ of the outer loops, you can use labels to specify which loop the `break` or\n ```rust\n 'outer: for x in 0..10 {\n     'inner: for y in 0..10 {\n-        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n-        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n+        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.\n+        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.\n         println!(\"x: {}, y: {}\", x, y);\n     }\n }"}, {"sha": "7f52b33948ee146ff5cd924374141e938d64ea0e", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -533,33 +533,33 @@ An example:\n ```rust\n macro_rules! m1 { () => (()) }\n \n-// visible here: m1\n+// Visible here: `m1`.\n \n mod foo {\n-    // visible here: m1\n+    // Visible here: `m1`.\n \n     #[macro_export]\n     macro_rules! m2 { () => (()) }\n \n-    // visible here: m1, m2\n+    // Visible here: `m1`, `m2`.\n }\n \n-// visible here: m1\n+// Visible here: `m1`.\n \n macro_rules! m3 { () => (()) }\n \n-// visible here: m1, m3\n+// Visible here: `m1`, `m3`.\n \n #[macro_use]\n mod bar {\n-    // visible here: m1, m3\n+    // Visible here: `m1`, `m3`.\n \n     macro_rules! m4 { () => (()) }\n \n-    // visible here: m1, m3, m4\n+    // Visible here: `m1`, `m3`, `m4`.\n }\n \n-// visible here: m1, m3, m4\n+// Visible here: `m1`, `m3`, `m4`.\n # fn main() { }\n ```\n \n@@ -644,7 +644,7 @@ macro_rules! bct {\n     (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n         => (bct!($($ps),*, 1, $p ; $($ds),*));\n \n-    // halt on empty data string\n+    // Halt on empty data string:\n     ( $($ps:tt),* ; )\n         => (());\n }\n@@ -694,7 +694,7 @@ Like this:\n assert!(true);\n assert_eq!(5, 3 + 2);\n \n-// nope :(\n+// Nope :(\n \n assert!(5 < 3);\n assert_eq!(5, 3);"}, {"sha": "18017cc4a5e54f83074d6e894a291cb7465f0971", "filename": "src/doc/book/mutability.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmutability.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -6,15 +6,15 @@ status:\n \n ```rust,ignore\n let x = 5;\n-x = 6; // error!\n+x = 6; // Error!\n ```\n \n We can introduce mutability with the `mut` keyword:\n \n ```rust\n let mut x = 5;\n \n-x = 6; // no problem!\n+x = 6; // No problem!\n ```\n \n This is a mutable [variable binding][vb]. When a binding is mutable, it means\n@@ -136,7 +136,7 @@ some fields mutable and some immutable:\n ```rust,ignore\n struct Point {\n     x: i32,\n-    mut y: i32, // nope\n+    mut y: i32, // Nope.\n }\n ```\n \n@@ -154,7 +154,7 @@ a.x = 10;\n \n let b = Point { x: 5, y: 6};\n \n-b.x = 10; // error: cannot assign to immutable field `b.x`\n+b.x = 10; // Error: cannot assign to immutable field `b.x`.\n ```\n \n [struct]: structs.html"}, {"sha": "a06de35c0ce69cfd4bf0c5e84392b3e73f39a1cf", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -41,10 +41,10 @@ in the same format as C:\n #![feature(start)]\n #![no_std]\n \n-// Pull in the system libc library for what crt0.o likely requires\n+// Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n \n-// Entry point for this program\n+// Entry point for this program.\n #[start]\n fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n@@ -84,10 +84,10 @@ compiler's name mangling too:\n #![no_std]\n #![no_main]\n \n-// Pull in the system libc library for what crt0.o likely requires\n+// Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n \n-// Entry point for this program\n+// Entry point for this program.\n #[no_mangle] // ensure that this symbol is called `main` in the output\n pub extern fn main(_argc: i32, _argv: *const *const u8) -> i32 {\n     0"}, {"sha": "78ff871046ef753e586883b60beef3b12c4fd2ae", "filename": "src/doc/book/operators-and-overloading.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Foperators-and-overloading.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -69,7 +69,7 @@ impl Add<i32> for Point {\n     type Output = f64;\n \n     fn add(self, rhs: i32) -> f64 {\n-        // add an i32 to a Point and get an f64\n+        // Add an i32 to a Point and get an f64.\n # 1.0\n     }\n }"}, {"sha": "11eda399adc9b9c4118c6fcad2583d066d42cd6f", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -107,7 +107,7 @@ try to use something after we\u2019ve passed it as an argument:\n \n ```rust,ignore\n fn take(v: Vec<i32>) {\n-    // what happens here isn\u2019t important.\n+    // What happens here isn\u2019t important.\n }\n \n let v = vec![1, 2, 3];\n@@ -264,9 +264,9 @@ Of course, if we had to hand ownership back with every function we wrote:\n \n ```rust\n fn foo(v: Vec<i32>) -> Vec<i32> {\n-    // do stuff with v\n+    // Do stuff with `v`.\n \n-    // hand back ownership\n+    // Hand back ownership.\n     v\n }\n ```\n@@ -275,9 +275,9 @@ This would get very tedious. It gets worse the more things we want to take owner\n \n ```rust\n fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // hand back ownership, and the result of our function\n+    // Hand back ownership, and the result of our function.\n     (v1, v2, 42)\n }\n "}, {"sha": "b50fa01b8e2be903b1f27b65319cfb6474f1fba8", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -163,7 +163,7 @@ ignore parts of a larger structure:\n \n ```rust\n fn coordinate() -> (i32, i32, i32) {\n-    // generate and return some sort of triple tuple\n+    // Generate and return some sort of triple tuple.\n # (1, 2, 3)\n }\n \n@@ -182,7 +182,7 @@ let tuple: (u32, String) = (5, String::from(\"five\"));\n // Here, tuple is moved, because the String moved:\n let (x, _s) = tuple;\n \n-// The next line would give \"error: use of partially moved value: `tuple`\"\n+// The next line would give \"error: use of partially moved value: `tuple`\".\n // println!(\"Tuple is: {:?}\", tuple);\n \n // However,"}, {"sha": "c4169d64ccc67885fb135cacbcbcf5ce69da3c3e", "filename": "src/doc/book/primitive-types.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fprimitive-types.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -54,9 +54,9 @@ bigger numbers.\n If a number literal has nothing to cause its type to be inferred, it defaults:\n \n ```rust\n-let x = 42; // x has type i32\n+let x = 42; // `x` has type `i32`.\n \n-let y = 1.0; // y has type f64\n+let y = 1.0; // `y` has type `f64`.\n ```\n \n Here\u2019s a list of the different numeric types, with links to their documentation\n@@ -177,8 +177,8 @@ length of the slice:\n \n ```rust\n let a = [0, 1, 2, 3, 4];\n-let complete = &a[..]; // A slice containing all of the elements in a\n-let middle = &a[1..4]; // A slice of a: only the elements 1, 2, and 3\n+let complete = &a[..]; // A slice containing all of the elements in `a`.\n+let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.\n ```\n \n Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n@@ -264,8 +264,8 @@ You can disambiguate a single-element tuple from a value in parentheses with a\n comma:\n \n ```rust\n-(0,); // single-element tuple\n-(0); // zero in parentheses\n+(0,); // A single-element tuple.\n+(0); // A zero in parentheses.\n ```\n \n ## Tuple Indexing"}, {"sha": "2386475d15ea3478bd1cf6de7a8ea233f3800a9f", "filename": "src/doc/book/raw-pointers.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fraw-pointers.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -101,11 +101,11 @@ programmer *must* guarantee this.\n The recommended method for the conversion is:\n \n ```rust\n-// explicit cast\n+// Explicit cast:\n let i: u32 = 1;\n let p_imm: *const u32 = &i as *const u32;\n \n-// implicit coercion\n+// Implicit coercion:\n let mut m: u32 = 2;\n let p_mut: *mut u32 = &mut m;\n "}, {"sha": "6c9c4fa7dd4b77a6de70fff639ce6cfb02a1616b", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -46,9 +46,9 @@ like this:\n \n ```rust\n fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // hand back ownership, and the result of our function\n+    // Hand back ownership, and the result of our function.\n     (v1, v2, 42)\n }\n \n@@ -63,9 +63,9 @@ the first step:\n \n ```rust\n fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // return the answer\n+    // Return the answer.\n     42\n }\n \n@@ -74,7 +74,7 @@ let v2 = vec![1, 2, 3];\n \n let answer = foo(&v1, &v2);\n \n-// we can use v1 and v2 here!\n+// We can use `v1` and `v2` here!\n ```\n \n A more concrete example:\n@@ -88,10 +88,10 @@ fn main() {\n     // Borrow two vectors and sum them.\n     // This kind of borrowing does not allow mutation through the borrowed reference.\n     fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n-        // do stuff with v1 and v2\n+        // Do stuff with `v1` and `v2`.\n         let s1 = sum_vec(v1);\n         let s2 = sum_vec(v2);\n-        // return the answer\n+        // Return the answer.\n         s1 + s2\n     }\n \n@@ -248,12 +248,12 @@ scopes look like this:\n fn main() {\n     let mut x = 5;\n \n-    let y = &mut x;    // -+ &mut borrow of x starts here\n+    let y = &mut x;    // -+ &mut borrow of `x` starts here.\n                        //  |\n     *y += 1;           //  |\n                        //  |\n-    println!(\"{}\", x); // -+ - try to borrow x here\n-}                      // -+ &mut borrow of x ends here\n+    println!(\"{}\", x); // -+ - Try to borrow `x` here.\n+}                      // -+ &mut borrow of `x` ends here.\n                        \n ```\n \n@@ -265,11 +265,11 @@ So when we add the curly braces:\n let mut x = 5;\n \n {\n-    let y = &mut x; // -+ &mut borrow starts here\n+    let y = &mut x; // -+ &mut borrow starts here.\n     *y += 1;        //  |\n-}                   // -+ ... and ends here\n+}                   // -+ ... and ends here.\n \n-println!(\"{}\", x);  // <- try to borrow x here\n+println!(\"{}\", x);  // <- Try to borrow `x` here.\n ```\n \n There\u2019s no problem. Our mutable borrow goes out of scope before we create an"}, {"sha": "6af15d8768363bd947d8f73b589dec852436fe77", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -83,10 +83,10 @@ converted using `&*`.\n ```rust,no_run\n use std::net::TcpStream;\n \n-TcpStream::connect(\"192.168.0.1:3000\"); // &str parameter\n+TcpStream::connect(\"192.168.0.1:3000\"); // Parameter is of type &str.\n \n let addr_string = \"192.168.0.1:3000\".to_string();\n-TcpStream::connect(&*addr_string); // convert addr_string to &str\n+TcpStream::connect(&*addr_string); // Convert `addr_string` to &str.\n ```\n \n Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n@@ -138,7 +138,7 @@ You can get something similar to an index like this:\n \n ```rust\n # let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n-let dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n+let dog = hachiko.chars().nth(1); // Kinda like `hachiko[1]`.\n ```\n \n This emphasizes that we have to walk from the beginning of the list of `chars`."}, {"sha": "cfd00cf997e0b7ce2922eec0ea4efddc52cc5496", "filename": "src/doc/book/structs.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstructs.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -82,9 +82,9 @@ fn main() {\n \n     point.x = 5;\n \n-    let point = point; // now immutable\n+    let point = point; // `point` is now immutable.\n \n-    point.y = 6; // this causes an error\n+    point.y = 6; // This causes an error.\n }\n ```\n \n@@ -234,10 +234,10 @@ rather than positions.\n You can define a `struct` with no members at all:\n \n ```rust\n-struct Electron {} // use empty braces...\n-struct Proton;     // ...or just a semicolon\n+struct Electron {} // Use empty braces...\n+struct Proton;     // ...or just a semicolon.\n \n-// whether you declared the struct with braces or not, do the same when creating one\n+// Whether you declared the struct with braces or not, do the same when creating one.\n let x = Electron {};\n let y = Proton;\n ```"}, {"sha": "14a05102b9a0346406cdd451c157ab879df9606f", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 135, "deletions": 32, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -23,7 +23,11 @@ $ cd adder\n Cargo will automatically generate a simple test when you make a new project.\n Here's the contents of `src/lib.rs`:\n \n-```rust\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[cfg(test)]\n mod tests {\n     #[test]\n@@ -32,17 +36,30 @@ mod tests {\n }\n ```\n \n+For now, let's remove the `mod` bit, and focus on just the function:\n+\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+#[test]\n+fn it_works() {\n+}\n+```\n+\n Note the `#[test]`. This attribute indicates that this is a test function. It\n currently has no body. That's good enough to pass! We can run the tests with\n `cargo test`:\n \n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.15 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -58,13 +75,15 @@ for the test we wrote, and another for documentation tests. We'll talk about\n those later. For now, see this line:\n \n ```text\n-test tests::it_works ... ok\n+test it_works ... ok\n ```\n \n Note the `it_works`. This comes from the name of our function:\n \n ```rust\n+# fn main() {\n fn it_works() {\n+}\n # }\n ```\n \n@@ -77,8 +96,11 @@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n So why does our do-nothing test pass? Any test which doesn't `panic!` passes,\n and any test that does `panic!` fails. Let's make our test fail:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n fn it_works() {\n     assert!(false);\n@@ -92,19 +114,21 @@ run our tests again:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... FAILED\n+test it_works ... FAILED\n \n failures:\n \n----- test::it_works stdout ----\n-        thread 'tests::it_works' panicked at 'assertion failed: false', src/lib.rs:5\n+---- it_works stdout ----\n+        thread 'it_works' panicked at 'assertion failed: false', src/lib.rs:5\n+note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n \n failures:\n-    tests::it_works\n+    it_works\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n@@ -114,7 +138,7 @@ error: test failed\n Rust indicates that our test failed:\n \n ```text\n-test tests::it_works ... FAILED\n+test it_works ... FAILED\n ```\n \n And that's reflected in the summary line:\n@@ -147,8 +171,11 @@ This is useful if you want to integrate `cargo test` into other tooling.\n \n We can invert our test's failure with another attribute: `should_panic`:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic]\n fn it_works() {\n@@ -161,10 +188,11 @@ This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -178,8 +206,11 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Rust provides another macro, `assert_eq!`, that compares two arguments for\n equality:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic]\n fn it_works() {\n@@ -193,10 +224,11 @@ passes:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n-test tests::it_works ... ok\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -213,8 +245,11 @@ parameter can be added to the `should_panic` attribute. The test harness will\n make sure that the failure message contains the provided text. A safer version\n of the example above would be:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n #[test]\n #[should_panic(expected = \"assertion failed\")]\n fn it_works() {\n@@ -225,7 +260,10 @@ fn it_works() {\n That's all there is to the basics! Let's write one 'real' test:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -244,8 +282,15 @@ some known arguments and compare it to the expected output.\n Sometimes a few specific tests can be very time-consuming to execute. These\n can be disabled by default by using the `ignore` attribute:\n \n-```rust\n-# fn main() {}\n+```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n+\n #[test]\n fn it_works() {\n     assert_eq!(4, add_two(2));\n@@ -254,7 +299,7 @@ fn it_works() {\n #[test]\n #[ignore]\n fn expensive_test() {\n-    // code that takes an hour to run\n+    // Code that takes an hour to run...\n }\n ```\n \n@@ -264,7 +309,8 @@ not:\n ```bash\n $ cargo test\n    Compiling adder v0.1.0 (file:///home/you/projects/adder)\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.20 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 2 tests\n test expensive_test ... ignored\n@@ -283,7 +329,8 @@ The expensive tests can be run explicitly using `cargo test -- --ignored`:\n \n ```bash\n $ cargo test -- --ignored\n-     Running target/debug/deps/adder-91b3e234d4ed382a\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n+     Running target/debug/deps/adder-941f01916ca4a642\n \n running 1 test\n test expensive_test ... ok\n@@ -310,7 +357,10 @@ was missing from our last example. Let's explain what this does.\n The idiomatic way of writing our example looks like this:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -339,7 +389,10 @@ a large module, and so this is a common use of globs. Let's change our\n `src/lib.rs` to make use of it:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -389,9 +442,14 @@ To write an integration test, let's make a `tests` directory and\n put a `tests/integration_test.rs` file inside with this as its contents:\n \n ```rust,ignore\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n+# // Sadly, this code will not work in play.rust-lang.org, because we have no\n+# // crate adder to import. You'll need to try this part on your own machine.\n extern crate adder;\n \n-# fn main() {}\n #[test]\n fn it_works() {\n     assert_eq!(4, adder::add_two(2));\n@@ -452,7 +510,10 @@ running examples in your documentation (**note:** this only works in library\n crates, not binary crates). Here's a fleshed-out `src/lib.rs` with examples:\n \n ```rust,ignore\n-# fn main() {}\n+# // The next line exists to trick play.rust-lang.org into running our code as a\n+# // test:\n+# // fn main\n+#\n //! The `adder` crate provides functions that add numbers to other numbers.\n //!\n //! # Examples\n@@ -525,3 +586,45 @@ you add more examples.\n \n We haven\u2019t covered all of the details with writing documentation tests. For more,\n please see the [Documentation chapter](documentation.html).\n+\n+# Testing and concurrency\n+\n+One thing that is important to note when writing tests are run concurrently\n+using threads. For this reason you should take care that your tests are written\n+in such a way as to not depend on each-other, or on any shared state. \"Shared\n+state\" can also include the environment, such as the current working directory,\n+or environment variables.\n+\n+If this is an issue it is possible to control this concurrency, either by\n+setting the environment variable `RUST_TEST_THREADS`, or by passing the argument\n+`--test-threads` to the tests:\n+\n+```bash\n+$ RUST_TEST_THREADS=1 cargo test   # Run tests with no concurrency\n+...\n+$ cargo test -- --test-threads=1   # Same as above\n+...\n+```\n+\n+# Test output\n+\n+By default Rust's test library captures and discards output to standard\n+out/error, e.g. output from `println!()`. This too can be controlled using the\n+environment or a switch:\n+\n+\n+```bash\n+$ RUST_TEST_NOCAPTURE=1 cargo test   # Preserve stdout/stderr\n+...\n+$ cargo test -- --nocapture          # Same as above\n+...\n+```\n+\n+However a better method avoiding capture is to use logging rather than raw\n+output. Rust has a [standard logging API][log], which provides a frontend to\n+multiple logging implementations. This can be used in conjunction with the\n+default [env_logger] to output any debugging information in a manner that can be\n+controlled at runtime.\n+\n+[log]: https://crates.io/crates/log\n+[env_logger]: https://crates.io/crates/env_logger"}, {"sha": "a0396a75fa26e6663e2e36a807aef1ef0f904c45", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -221,8 +221,8 @@ struct FooVtable {\n // u8:\n \n fn call_method_on_u8(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a u8\n+    // The compiler guarantees that this function is only called\n+    // with `x` pointing to a u8.\n     let byte: &u8 = unsafe { &*(x as *const u8) };\n \n     byte.method()\n@@ -233,24 +233,24 @@ static Foo_for_u8_vtable: FooVtable = FooVtable {\n     size: 1,\n     align: 1,\n \n-    // cast to a function pointer\n+    // Cast to a function pointer:\n     method: call_method_on_u8 as fn(*const ()) -> String,\n };\n \n \n // String:\n \n fn call_method_on_String(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a String\n+    // The compiler guarantees that this function is only called\n+    // with `x` pointing to a String.\n     let string: &String = unsafe { &*(x as *const String) };\n \n     string.method()\n }\n \n static Foo_for_String_vtable: FooVtable = FooVtable {\n     destructor: /* compiler magic */,\n-    // values for a 64-bit computer, halve them for 32-bit ones\n+    // Values for a 64-bit computer, halve them for 32-bit ones.\n     size: 24,\n     align: 8,\n \n@@ -278,17 +278,17 @@ let x: u8 = 1;\n \n // let b: &Foo = &a;\n let b = TraitObject {\n-    // store the data\n+    // Store the data:\n     data: &a,\n-    // store the methods\n+    // Store the methods:\n     vtable: &Foo_for_String_vtable\n };\n \n // let y: &Foo = x;\n let y = TraitObject {\n-    // store the data\n+    // Store the data:\n     data: &x,\n-    // store the methods\n+    // Store the methods:\n     vtable: &Foo_for_u8_vtable\n };\n "}, {"sha": "4747869b65c70f8ad4df4385a3238a685434e5d0", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -243,28 +243,22 @@ to know more about [operator traits][operators-and-overloading].\n # Rules for implementing traits\n \n So far, we\u2019ve only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement `HasArea`\n-for `i32`:\n+implement a trait for any type such as `f32`:\n \n ```rust\n-trait HasArea {\n-    fn area(&self) -> f64;\n+trait ApproxEqual {\n+    fn approx_equal(&self, other: &Self) -> bool;\n }\n-\n-impl HasArea for i32 {\n-    fn area(&self) -> f64 {\n-        println!(\"this is silly\");\n-\n-        *self as f64\n+impl ApproxEqual for f32 {\n+    fn approx_equal(&self, other: &Self) -> bool {\n+        // Appropriate for `self` and `other` being close to 1.0.\n+        (self - other).abs() <= ::std::f32::EPSILON\n     }\n }\n \n-5.area();\n+println!(\"{}\", 1.0.approx_equal(&1.00000001));\n ```\n \n-It is considered poor style to implement methods on such primitive types, even\n-though it is possible.\n-\n This may seem like the Wild West, but there are two restrictions around\n implementing traits that prevent this from getting out of hand. The first is\n that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n@@ -276,9 +270,9 @@ won\u2019t have its methods:\n \n ```rust,ignore\n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n-let buf = b\"whatever\"; // byte string literal. buf: &[u8; 8]\n+let buf = b\"whatever\"; // buf: &[u8; 8], a byte string literal.\n let result = f.write(buf);\n-# result.unwrap(); // ignore the error\n+# result.unwrap(); // Ignore the error.\n ```\n \n Here\u2019s the error:\n@@ -297,7 +291,7 @@ use std::io::Write;\n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n let buf = b\"whatever\";\n let result = f.write(buf);\n-# result.unwrap(); // ignore the error\n+# result.unwrap(); // Ignore the error.\n ```\n \n This will compile without error.\n@@ -419,14 +413,14 @@ impl ConvertTo<i64> for i32 {\n     fn convert(&self) -> i64 { *self as i64 }\n }\n \n-// can be called with T == i32\n+// Can be called with T == i32.\n fn normal<T: ConvertTo<i64>>(x: &T) -> i64 {\n     x.convert()\n }\n \n-// can be called with T == i64\n+// Can be called with T == i64.\n fn inverse<T>(x: i32) -> T\n-        // this is using ConvertTo as if it were \"ConvertTo<i64>\"\n+        // This is using ConvertTo as if it were \"ConvertTo<i64>\".\n         where i32: ConvertTo<T> {\n     x.convert()\n }\n@@ -476,15 +470,15 @@ impl Foo for OverrideDefault {\n \n     fn is_invalid(&self) -> bool {\n         println!(\"Called OverrideDefault.is_invalid!\");\n-        true // overrides the expected value of is_invalid()\n+        true // Overrides the expected value of `is_invalid()`.\n     }\n }\n \n let default = UseDefault;\n-assert!(!default.is_invalid()); // prints \"Called UseDefault.is_valid.\"\n+assert!(!default.is_invalid()); // Prints \"Called UseDefault.is_valid.\"\n \n let over = OverrideDefault;\n-assert!(over.is_invalid()); // prints \"Called OverrideDefault.is_invalid!\"\n+assert!(over.is_invalid()); // Prints \"Called OverrideDefault.is_invalid!\"\n ```\n \n # Inheritance"}, {"sha": "a272afa70bb1be3013a98d89123d725007e1ec4b", "filename": "src/doc/book/unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Funsafe.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -12,7 +12,7 @@ four contexts. The first one is to mark a function as unsafe:\n \n ```rust\n unsafe fn danger_will_robinson() {\n-    // scary stuff\n+    // Scary stuff...\n }\n ```\n \n@@ -23,7 +23,7 @@ The second use of `unsafe` is an unsafe block:\n \n ```rust\n unsafe {\n-    // scary stuff\n+    // Scary stuff...\n }\n ```\n "}, {"sha": "54316649c715f3169b7e533413df92fbd833c23b", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -194,7 +194,7 @@ fn main() {\n         let y: i32 = 3;\n         println!(\"The value of x is {} and value of y is {}\", x, y);\n     }\n-    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n }\n ```\n \n@@ -207,7 +207,7 @@ Instead we get this error:\n $ cargo build\n    Compiling hello v0.1.0 (file:///home/you/projects/hello_world)\n main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]\n-main.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+main.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n                                                                        ^\n note: in expansion of format_args!\n <std macros>:2:25: 2:56 note: expansion site\n@@ -229,13 +229,13 @@ scope will override the previous binding.\n ```rust\n let x: i32 = 8;\n {\n-    println!(\"{}\", x); // Prints \"8\"\n+    println!(\"{}\", x); // Prints \"8\".\n     let x = 12;\n-    println!(\"{}\", x); // Prints \"12\"\n+    println!(\"{}\", x); // Prints \"12\".\n }\n-println!(\"{}\", x); // Prints \"8\"\n+println!(\"{}\", x); // Prints \"8\".\n let x =  42;\n-println!(\"{}\", x); // Prints \"42\"\n+println!(\"{}\", x); // Prints \"42\".\n ```\n \n Shadowing and mutable bindings may appear as two sides of the same coin, but\n@@ -249,8 +249,8 @@ by any means.\n ```rust\n let mut x: i32 = 1;\n x = 7;\n-let x = x; // x is now immutable and is bound to 7\n+let x = x; // `x` is now immutable and is bound to `7`.\n \n let y = 4;\n-let y = \"I can also be bound to text!\"; // y is now of a different type\n+let y = \"I can also be bound to text!\"; // `y` is now of a different type.\n ```"}, {"sha": "b948a54f44a5b62b38f87cb61d16ab6f3e25df24", "filename": "src/doc/book/vectors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fdoc%2Fbook%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvectors.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,7 +17,7 @@ situation, this is just convention.)\n There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n ```rust\n-let v = vec![0; 10]; // ten zeroes\n+let v = vec![0; 10]; // A vector of ten zeroes.\n ```\n \n Vectors store their contents as contiguous arrays of `T` on the heap. This means\n@@ -46,10 +46,10 @@ let v = vec![1, 2, 3, 4, 5];\n let i: usize = 0;\n let j: i32 = 0;\n \n-// works\n+// Works:\n v[i];\n \n-// doesn\u2019t\n+// Doesn\u2019t:\n v[j];\n ```\n "}, {"sha": "cd2dd38de36aaeea4b042b5f833af0be63e30070", "filename": "src/grammar/README.md", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FREADME.md?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,14 +1,18 @@\n-Reference grammar.\n+# Reference grammar.\n \n Uses [antlr4](http://www.antlr.org/) and a custom Rust tool to compare\n-ASTs/token streams generated. You can use the `check-lexer` make target to\n+ASTs/token streams generated. You can use the `make check-lexer` target to\n run all of the available tests.\n \n-To use manually:\n+The build of the rust part is included with `make tidy` and can be run with `make check-build-lexer-verifier`.\n+\n+# Manual build\n+\n+To use manually, assuming antlr4 ist installed at `/usr/share/java/antlr-complete.jar`:\n \n ```\n antlr4 RustLexer.g4\n-javac *.java\n+javac -classpath /usr/share/java/antlr-complete.jar *.java\n rustc -O verify.rs\n for file in ../*/**.rs; do\n     echo $file;\n@@ -18,3 +22,12 @@ done\n \n Note That the `../*/**.rs` glob will match every `*.rs` file in the above\n directory and all of its recursive children. This is a zsh extension.\n+\n+\n+## Cleanup\n+\n+To cleanup you can use a command like this:\n+\n+```bash\n+rm -f verify *.class *.java *.tokens\n+```"}, {"sha": "70a8f6fca2e5c68c8fe6e043a2f76e4658e19b93", "filename": "src/grammar/check.sh", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -20,11 +20,11 @@ skipped=0\n check() {\n     grep --silent \"// ignore-lexer-test\" \"$1\";\n \n-    # if it's *not* found...\n+    # if it is *not* found...\n     if [ $? -eq 1 ]; then\n-        cd $2 # This `cd` is so java will pick up RustLexer.class. I couldn't\n+        cd $2 # This `cd` is so java will pick up RustLexer.class. I could not\n         # figure out how to wrangle the CLASSPATH, just adding build/grammar\n-        # didn't seem to have any effect.\n+        # did not seem to have any effect.\n         if $3 RustLexer tokens -tokens < $1 | $4 $1 $5; then\n             echo \"pass: $1\"\n             passed=`expr $passed + 1`"}, {"sha": "48be58f731cd7bef2a3e0dc703f9b5c634458dc5", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,6 +11,7 @@\n #![feature(plugin, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n \n #[macro_use]\n@@ -290,9 +291,10 @@ fn main() {\n \n     let options = config::basic_options();\n     let session = session::build_session(options, &DepGraph::new(false), None,\n-                                         syntax::diagnostics::registry::Registry::new(&[]),\n+                                         syntax::errors::registry::Registry::new(&[]),\n                                          Rc::new(DummyCrateStore));\n-    let filemap = session.parse_sess.codemap().new_filemap(String::from(\"<n/a>\"), code);\n+    let filemap = session.parse_sess.codemap()\n+                         .new_filemap(\"<n/a>\".to_string(), None, code);\n     let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n     let cm = session.codemap();\n "}, {"sha": "12809171b743899f909a67299c16102b1faa6116", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,7 +17,7 @@\n \n use core::{isize, usize};\n #[cfg(not(test))]\n-use core::intrinsics::{min_align_of, size_of};\n+use core::intrinsics::{min_align_of_val, size_of_val};\n \n #[allow(improper_ctypes)]\n extern \"C\" {\n@@ -152,11 +152,12 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n #[cfg(not(test))]\n #[lang = \"box_free\"]\n #[inline]\n-unsafe fn box_free<T>(ptr: *mut T) {\n-    let size = size_of::<T>();\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    let size = size_of_val(&*ptr);\n+    let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n-        deallocate(ptr as *mut u8, size, min_align_of::<T>());\n+        deallocate(ptr as *mut u8, size, align);\n     }\n }\n "}, {"sha": "24f8e3a2d918144a8cbda94dccfb1545ef292a95", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 72, "deletions": 50, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1499,26 +1499,7 @@ impl<T> ops::DerefMut for Vec<T> {\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n-        // Unroll the first iteration, as the vector is going to be\n-        // expanded on this iteration in every case when the iterable is not\n-        // empty, but the loop in extend_desugared() is not going to see the\n-        // vector being full in the few subsequent loop iterations.\n-        // So we get better branch prediction.\n-        let mut iterator = iter.into_iter();\n-        let mut vector = match iterator.next() {\n-            None => return Vec::new(),\n-            Some(element) => {\n-                let (lower, _) = iterator.size_hint();\n-                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n-                unsafe {\n-                    ptr::write(vector.get_unchecked_mut(0), element);\n-                    vector.set_len(1);\n-                }\n-                vector\n-            }\n-        };\n-        vector.extend_desugared(iterator);\n-        vector\n+        <Self as SpecExtend<_>>::from_iter(iter.into_iter())\n     }\n }\n \n@@ -1586,36 +1567,64 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        self.extend_desugared(iter.into_iter())\n+        self.spec_extend(iter.into_iter())\n     }\n }\n \n-trait IsTrustedLen : Iterator {\n-    fn trusted_len(&self) -> Option<usize> { None }\n+// Specialization trait used for Vec::from_iter and Vec::extend\n+trait SpecExtend<I> {\n+    fn from_iter(iter: I) -> Self;\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n+impl<I, T> SpecExtend<I> for Vec<T>\n+    where I: Iterator<Item=T>,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Unroll the first iteration, as the vector is going to be\n+        // expanded on this iteration in every case when the iterable is not\n+        // empty, but the loop in extend_desugared() is not going to see the\n+        // vector being full in the few subsequent loop iterations.\n+        // So we get better branch prediction.\n+        let mut vector = match iterator.next() {\n+            None => return Vec::new(),\n+            Some(element) => {\n+                let (lower, _) = iterator.size_hint();\n+                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n+                unsafe {\n+                    ptr::write(vector.get_unchecked_mut(0), element);\n+                    vector.set_len(1);\n+                }\n+                vector\n+            }\n+        };\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n }\n-impl<I> IsTrustedLen for I where I: Iterator { }\n \n-impl<I> IsTrustedLen for I where I: TrustedLen\n+impl<I, T> SpecExtend<I> for Vec<T>\n+    where I: TrustedLen<Item=T>,\n {\n-    fn trusted_len(&self) -> Option<usize> {\n-        let (low, high) = self.size_hint();\n+    fn from_iter(iterator: I) -> Self {\n+        let mut vector = Vec::new();\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+\n+    fn spec_extend(&mut self, iterator: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iterator.size_hint();\n         if let Some(high_value) = high {\n             debug_assert_eq!(low, high_value,\n                              \"TrustedLen iterator's size hint is not exact: {:?}\",\n                              (low, high));\n         }\n-        high\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n-        // This function should be the moral equivalent of:\n-        //\n-        //      for item in iterator {\n-        //          self.push(item);\n-        //      }\n-        if let Some(additional) = iterator.trusted_len() {\n+        if let Some(additional) = high {\n             self.reserve(additional);\n             unsafe {\n                 let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n@@ -1628,17 +1637,30 @@ impl<T> Vec<T> {\n                 }\n             }\n         } else {\n-            while let Some(element) = iterator.next() {\n-                let len = self.len();\n-                if len == self.capacity() {\n-                    let (lower, _) = iterator.size_hint();\n-                    self.reserve(lower.saturating_add(1));\n-                }\n-                unsafe {\n-                    ptr::write(self.get_unchecked_mut(len), element);\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    self.set_len(len + 1);\n-                }\n+            self.extend_desugared(iterator)\n+        }\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n+        // This is the case for a general iterator.\n+        //\n+        // This function should be the moral equivalent of:\n+        //\n+        //      for item in iterator {\n+        //          self.push(item);\n+        //      }\n+        while let Some(element) = iterator.next() {\n+            let len = self.len();\n+            if len == self.capacity() {\n+                let (lower, _) = iterator.size_hint();\n+                self.reserve(lower.saturating_add(1));\n+            }\n+            unsafe {\n+                ptr::write(self.get_unchecked_mut(len), element);\n+                // NB can't overflow since we would have had to alloc the address space\n+                self.set_len(len + 1);\n             }\n         }\n     }"}, {"sha": "9e91e390a5728b1b121ca35b6672a7158477b295", "filename": "src/libcompiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2FCargo.toml?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -7,6 +7,7 @@ version = \"0.0.0\"\n [lib]\n name = \"compiler_builtins\"\n path = \"lib.rs\"\n+test = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "3726eee9a93c6d5b6e33a73d6ae7a0444edd80ec", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -51,76 +51,472 @@ extern \"rust-intrinsic\" {\n     // NB: These intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n     pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as both the `success` and `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `success` and\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `failure` parameters. For example,\n+    /// [`AtomicBool::compare_exchange_weak`]\n+    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load<T>(src: *const T) -> T;\n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    /// Loads the current value of the pointer.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `load` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n     pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n     pub fn atomic_load_unordered<T>(src: *const T) -> T;\n \n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store<T>(dst: *mut T, val: T);\n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+    /// Stores the value at the specified memory location.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `store` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n     pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n     pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n \n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Stores the value at the specified memory location, returning the old value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `swap` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Add to the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_add` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Subtract from the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n     pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise and with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_and` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n     pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise nand with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n     pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise or with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_or` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n     pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n \n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n+    /// Bitwise xor with the current value, returning the previous value.\n+    /// The stabilized version of this intrinsic is available on the\n+    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n+    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n+    /// as the `order`. For example,\n+    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n     pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n@@ -631,8 +1027,12 @@ extern \"rust-intrinsic\" {\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer.\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Perform a volatile store to the `dst` pointer.\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n@@ -766,12 +1166,21 @@ extern \"rust-intrinsic\" {\n     pub fn bswap<T>(x: T) -> T;\n \n     /// Performs checked integer addition.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_add` method. For example,\n+    /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n     pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_sub` method. For example,\n+    /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n     pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `overflowing_mul` method. For example,\n+    /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -782,10 +1191,19 @@ extern \"rust-intrinsic\" {\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2^N, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',"}, {"sha": "e94582cda7c346e16d7aceb5d22c4a1faa381ab7", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -666,13 +666,17 @@ float_sum_product! { f32 f64 }\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n-/// to return `None` again. This trait is should be implemented by all iterators\n+/// to return [`None`] again. This trait is should be implemented by all iterators\n /// that behave this way because it allows for some significant optimizations.\n ///\n /// Note: In general, you should not use `FusedIterator` in generic bounds if\n-/// you need a fused iterator. Instead, you should just call `Iterator::fused()`\n-/// on the iterator. If the iterator is already fused, the additional `Fuse`\n+/// you need a fused iterator. Instead, you should just call [`Iterator::fuse()`]\n+/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n /// wrapper will be a no-op with no performance penalty.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`Iterator::fuse()`]: ../../std/iter/trait.Iterator.html#method.fuse\n+/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n #[unstable(feature = \"fused\", issue = \"35602\")]\n pub trait FusedIterator: Iterator {}\n \n@@ -682,16 +686,20 @@ impl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n /// An iterator that reports an accurate length using size_hint.\n ///\n /// The iterator reports a size hint where it is either exact\n-/// (lower bound is equal to upper bound), or the upper bound is `None`.\n-/// The upper bound must only be `None` if the actual iterator length is\n-/// larger than `usize::MAX`.\n+/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n+/// The upper bound must only be [`None`] if the actual iterator length is\n+/// larger than [`usize::MAX`].\n ///\n /// The iterator must produce exactly the number of elements it reported.\n ///\n /// # Safety\n ///\n /// This trait must only be implemented when the contract is upheld.\n-/// Consumers of this trait must inspect `.size_hint()`\u2019s upper bound.\n+/// Consumers of this trait must inspect [`.size_hint()`]\u2019s upper bound.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+/// [`.size_hint()`]: ../../std/iter/trait.Iterator.html#method.size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub unsafe trait TrustedLen : Iterator {}\n "}, {"sha": "b3f5363f5b15a970557923e79bfb82c9d5a3955e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -550,15 +550,15 @@ macro_rules! unimplemented {\n /// into libsyntax itself.\n ///\n /// For more information, see documentation for `std`'s macros.\n-#[cfg(dox)]\n-pub mod builtin {\n+mod builtin {\n     /// The core macro for formatted string creation & output.\n     ///\n     /// For more information, see the documentation for [`std::format_args!`].\n     ///\n     /// [`std::format_args!`]: ../std/macro.format_args.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! format_args { ($fmt:expr, $($args:tt)*) => ({\n         /* compiler built-in */\n     }) }\n@@ -570,6 +570,7 @@ pub mod builtin {\n     /// [`std::env!`]: ../std/macro.env.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Optionally inspect an environment variable at compile time.\n@@ -579,6 +580,7 @@ pub mod builtin {\n     /// [`std::option_env!`]: ../std/macro.option_env.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Concatenate identifiers into one identifier.\n@@ -588,6 +590,7 @@ pub mod builtin {\n     /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n     #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! concat_idents {\n         ($($e:ident),*) => ({ /* compiler built-in */ })\n     }\n@@ -599,6 +602,7 @@ pub mod builtin {\n     /// [`std::concat!`]: ../std/macro.concat.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the line number on which it was invoked.\n@@ -608,6 +612,7 @@ pub mod builtin {\n     /// [`std::line!`]: ../std/macro.line.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the column number on which it was invoked.\n@@ -617,6 +622,7 @@ pub mod builtin {\n     /// [`std::column!`]: ../std/macro.column.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the file name from which it was invoked.\n@@ -626,6 +632,7 @@ pub mod builtin {\n     /// [`std::file!`]: ../std/macro.file.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which stringifies its argument.\n@@ -635,6 +642,7 @@ pub mod builtin {\n     /// [`std::stringify!`]: ../std/macro.stringify.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n@@ -644,6 +652,7 @@ pub mod builtin {\n     /// [`std::include_str!`]: ../std/macro.include_str.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Includes a file as a reference to a byte array.\n@@ -653,6 +662,7 @@ pub mod builtin {\n     /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Expands to a string that represents the current module path.\n@@ -662,6 +672,7 @@ pub mod builtin {\n     /// [`std::module_path!`]: ../std/macro.module_path.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n     /// Boolean evaluation of configuration flags.\n@@ -671,6 +682,7 @@ pub mod builtin {\n     /// [`std::cfg!`]: ../std/macro.cfg.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Parse a file as an expression or an item according to the context.\n@@ -680,5 +692,6 @@ pub mod builtin {\n     /// [`std::include!`]: ../std/macro.include.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n+    #[cfg(dox)]\n     macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n }"}, {"sha": "9af10966eda4bc8e9bc81a5ab96955918e679886", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -26,15 +26,15 @@ use hash::Hasher;\n /// appropriate.\n ///\n /// An example of a non-`Send` type is the reference-counting pointer\n-/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// [`rc::Rc`][`Rc`]. If two threads attempt to clone [`Rc`]s that point to the same\n /// reference-counted value, they might try to update the reference count at the\n-/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic\n /// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n /// some overhead) and thus is `Send`.\n ///\n /// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n ///\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -183,20 +183,17 @@ pub trait Unsize<T: ?Sized> {\n /// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n /// `Copy` is not overloadable; it is always a simple bit-wise copy.\n ///\n-/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can\n /// provide any type-specific behavior necessary to duplicate values safely. For example,\n-/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n-/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n-/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]\n /// but not `Copy`.\n ///\n-/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n-/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation need only return `*self`\n /// (see the example above).\n ///\n-/// [clone]: ../clone/trait.Clone.html\n-/// [string]: ../../std/string/struct.String.html\n-///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n@@ -210,7 +207,7 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.\n /// By contrast, consider\n ///\n /// ```\n@@ -231,8 +228,8 @@ pub trait Unsize<T: ?Sized> {\n /// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n-/// buffer, leading to a double free.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the\n+/// [`String`]'s buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n@@ -255,6 +252,9 @@ pub trait Unsize<T: ?Sized> {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`Clone`]: ../clone/trait.Clone.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`i32`]: ../../std/primitive.i32.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -290,20 +290,20 @@ pub trait Copy : Clone {\n /// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n /// and [`cell::RefCell`][refcell]. These types allow for mutation of\n /// their contents even through an immutable, shared reference. For\n-/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n-/// only a shared reference `&Cell<T>`. The method performs no\n-/// synchronization, thus `Cell` cannot be `Sync`.\n+/// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n+/// only a shared reference [`&Cell<T>`][cell]. The method performs no\n+/// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n ///\n /// Another example of a non-`Sync` type is the reference-counting\n-/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n-/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n+/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n+/// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n /// Rust provides [atomic data types], as well as explicit locking via\n /// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n /// ensure that any mutation cannot cause data races, hence the types\n /// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n-/// analogue of `Rc`.\n+/// analogue of [`Rc`][rc].\n ///\n /// Any types with interior mutability must also use the\n /// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which"}, {"sha": "209107ef92ceb824f67ae3dea053c3f2503b3922", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -337,7 +337,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous, and should not be done lightly. Deeply\n+/// **This is incredibly dangerous and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n /// This is useful for [FFI] functions and initializing arrays sometimes,\n@@ -352,24 +352,18 @@ pub unsafe fn zeroed<T>() -> T {\n /// a boolean, your program may take one, both, or neither of the branches.\n ///\n /// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n /// value and its fields if you try to overwrite it in a normal manner. The only way\n /// to safely initialize an uninitialized value is with [`ptr::write`][write],\n /// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If the value does implement `Drop`, it must be initialized before\n+/// If the value does implement [`Drop`], it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n-/// [write]: ../ptr/fn.write.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [drop]: ../ops/trait.Drop.html\n-///\n /// # Examples\n ///\n-/// Here's how to safely initialize an array of `Vec`s.\n+/// Here's how to safely initialize an array of [`Vec`]s.\n ///\n /// ```\n /// use std::mem;\n@@ -410,15 +404,24 @@ pub unsafe fn zeroed<T>() -> T {\n /// ```\n ///\n /// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n-/// value that is only `Clone`, so the following is semantically equivalent and\n+/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n+/// value that is only [`Clone`], so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n ///\n /// ```\n /// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n /// println!(\"{:?}\", &data[0]);\n /// ```\n+///\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n@@ -492,7 +495,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n /// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n /// `self`, allowing it to be returned:\n ///\n@@ -507,6 +510,8 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///     }\n /// }\n /// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n@@ -571,8 +576,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n-/// release a `RefCell` borrow:\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -588,7 +593,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop`.\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -602,6 +607,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"x: {}, y: {}\", x, y.0); // still available\n /// ```\n ///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }"}, {"sha": "55d55079ddc1bc0f8d834ce31957f698c4986856", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -13,11 +13,6 @@\n use cmp::*;\n use cmp::Ordering::*;\n \n-// FIXME(#19630) Remove this work-around\n-macro_rules! e {\n-    ($e:expr) => { $e }\n-}\n-\n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n     ($(\n@@ -29,19 +24,19 @@ macro_rules! tuple_impls {\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n-                    ($(e!(self.$idx.clone()),)+)\n+                    ($(self.$idx.clone(),)+)\n                 }\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n-                    e!($(self.$idx == other.$idx)&&+)\n+                    $(self.$idx == other.$idx)&&+\n                 }\n                 #[inline]\n                 fn ne(&self, other: &($($T,)+)) -> bool {\n-                    e!($(self.$idx != other.$idx)||+)\n+                    $(self.$idx != other.$idx)||+\n                 }\n             }\n "}, {"sha": "b179a16e55e5885b6bdb07caa70ef9b044ca2786", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -139,7 +139,7 @@ pub struct Parser<'a> {\n     input: &'a str,\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<string::String>,\n+    pub errors: Vec<(string::String, Option<string::String>)>,\n     /// Current position of implicit positional argument pointer\n     curarg: usize,\n }\n@@ -165,7 +165,9 @@ impl<'a> Iterator for Parser<'a> {\n                     if self.consume('}') {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n-                        self.err(\"unmatched `}` found\");\n+                        self.err_with_note(\"unmatched `}` found\",\n+                                           \"if you intended to print `}`, \\\n+                                           you can escape it using `}}`\");\n                         None\n                     }\n                 }\n@@ -192,7 +194,14 @@ impl<'a> Parser<'a> {\n     /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n     fn err(&mut self, msg: &str) {\n-        self.errors.push(msg.to_owned());\n+        self.errors.push((msg.to_owned(), None));\n+    }\n+\n+    /// Notifies of an error. The message doesn't actually need to be of type\n+    /// String, but I think it does when this eventually uses conditions so it\n+    /// might as well start using it now.\n+    fn err_with_note(&mut self, msg: &str, note: &str) {\n+        self.errors.push((msg.to_owned(), Some(note.to_owned())));\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n@@ -222,7 +231,13 @@ impl<'a> Parser<'a> {\n                 self.err(&format!(\"expected `{:?}`, found `{:?}`\", c, maybe));\n             }\n         } else {\n-            self.err(&format!(\"expected `{:?}` but string was terminated\", c));\n+            let msg = &format!(\"expected `{:?}` but string was terminated\", c);\n+            if c == '}' {\n+                self.err_with_note(msg,\n+                                   \"if you intended to print `{`, you can escape it using `{{`\");\n+            } else {\n+                self.err(msg);\n+            }\n         }\n     }\n "}, {"sha": "6e8c1b490ccbe5e84d248bab883515bc85394b5f", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1 +1 @@\n-Subproject commit 7d9b71f0971f8fa196d864d7071f216a59036d6e\n+Subproject commit 6e8c1b490ccbe5e84d248bab883515bc85394b5f"}, {"sha": "50dfe9d22f12fa110f3a22d5056016e1960e3913", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -112,15 +112,15 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// switched to `Map(key)`. Therefore, if `op` makes use of any\n     /// HIR nodes or shared state accessed through its closure\n     /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_scheme_of_item` in `collect`,\n+    /// state. As an example, see `type_of_item` in `collect`,\n     /// which looks something like this:\n     ///\n     /// ```\n-    /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n+    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n     ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n-    ///     ccx.tcx.tcache.memoized(item_def_id, || {\n+    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_scheme_of_item(ccx, item)\n+    ///         compute_type_of_item(ccx, item)\n     ///     });\n     /// }\n     /// ```"}, {"sha": "e365cea6d0e5ea8e553fbff25c72efff2bfb1333", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -25,5 +25,5 @@ pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n-pub use self::visit::visit_all_items_in_krate;\n+pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "600732fc6f70b3e602d570ef5c9fb80d374a089a", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -10,31 +10,30 @@\n \n use hir;\n use hir::def_id::DefId;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use ty::TyCtxt;\n \n use super::dep_node::DepNode;\n \n-\n /// Visit all the items in the krate in some order. When visiting a\n /// particular item, first create a dep-node by calling `dep_node_fn`\n /// and push that onto the dep-graph stack of tasks, and also create a\n /// read edge from the corresponding AST node. This is used in\n /// compiler passes to automatically record the item that they are\n /// working on.\n-pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                mut dep_node_fn: F,\n-                                                visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                     mut dep_node_fn: F,\n+                                                     visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n {\n     struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n         tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n         dep_node_fn: &'visit mut F,\n         visitor: &'visit mut V\n     }\n \n-    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+    impl<'visit, 'tcx, F, V> ItemLikeVisitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n     {\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n@@ -46,6 +45,17 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n         }\n+\n+        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n+            let impl_item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(impl_item_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n+            debug!(\"Started task {:?}\", task_id);\n+            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n+            self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n+            self.visitor.visit_impl_item(i);\n+            debug!(\"Ended task {:?}\", task_id);\n+        }\n     }\n \n     let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n@@ -54,5 +64,5 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         dep_node_fn: &mut dep_node_fn,\n         visitor: visitor\n     };\n-    krate.visit_all_items(&mut tracking_visitor)\n+    krate.visit_all_item_likes(&mut tracking_visitor)\n }"}, {"sha": "feefc43f4013e682af3628f86cb1353ae81f0397", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -106,7 +106,7 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name, // The name of the target.\n     pub def: Def, // The definition of the target."}, {"sha": "4cfa889ec561676f7e1156bd7c55cb4afd51827a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 110, "deletions": 14, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,7 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! HIR walker. Each overridden visit method has full control over what\n+//! HIR walker for walking the contents of nodes.\n+//!\n+//! **For an overview of the visitor strategy, see the docs on the\n+//! `super::itemlikevisit::ItemLikeVisitor` trait.**\n+//!\n+//! If you have decided to use this visitor, here are some general\n+//! notes on how to do it:\n+//!\n+//! Each overridden visit method has full control over what\n //! happens with its node, it can do its own traversal of the node's children,\n //! call `intravisit::walk_*` to apply the default traversal algorithm, or prevent\n //! deeper traversal by doing nothing.\n@@ -30,6 +38,8 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::map::Map;\n+use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n use std::u32;\n@@ -76,22 +86,70 @@ pub trait Visitor<'v> : Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n-    /// Invoked when a nested item is encountered. By default, does\n-    /// nothing. If you want a deep walk, you need to override to\n-    /// fetch the item contents. But most of the time, it is easier\n-    /// (and better) to invoke `Crate::visit_all_items`, which visits\n-    /// all items in the crate in some order (but doesn't respect\n-    /// nesting).\n+    /// The default versions of the `visit_nested_XXX` routines invoke\n+    /// this method to get a map to use; if they get back `None`, they\n+    /// just skip nested things. Otherwise, they will lookup the\n+    /// nested item-like things in the map and visit it. So the best\n+    /// way to implement a nested visitor is to override this method\n+    /// to return a `Map`; one advantage of this is that if we add\n+    /// more types of nested things in the future, they will\n+    /// automatically work.\n+    ///\n+    /// **If for some reason you want the nested behavior, but don't\n+    /// have a `Map` are your disposal:** then you should override the\n+    /// `visit_nested_XXX` methods, and override this method to\n+    /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n+    /// added in the future, we will see the panic in your code and\n+    /// fix it appropriately.\n+    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n+        None\n+    }\n+\n+    /// Invoked when a nested item is encountered. By default does\n+    /// nothing unless you override `nested_visit_map` to return\n+    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// don't want to override this method** -- instead, override\n+    /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n+    /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n+    /// reason to override this method is if you want a nested pattern\n+    /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.expect_item(id.id));\n+        if let Some(item) = opt_item {\n+            self.visit_item(item);\n+        }\n     }\n \n-    /// Visit the top-level item and (optionally) nested items. See\n+    /// Like `visit_nested_item()`, but for impl items. See\n+    /// `visit_nested_item()` for advice on when to override this\n+    /// method.\n+    #[allow(unused_variables)]\n+    fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.impl_item(id));\n+        if let Some(item) = opt_item {\n+            self.visit_impl_item(item);\n+        }\n+    }\n+\n+    /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n     }\n \n+    /// When invoking `visit_all_item_likes()`, you need to supply an\n+    /// item-like visitor.  This method converts a \"intra-visit\"\n+    /// visitor into an item-like visitor that walks the entire tree.\n+    /// If you use this, you probably don't want to process the\n+    /// contents of nested item-like things, since the outer loop will\n+    /// visit them as well.\n+    fn as_deep_visitor<'s>(&'s mut self) -> DeepVisitor<'s, Self> {\n+        DeepVisitor::new(self)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n \n     fn visit_id(&mut self, _node_id: NodeId) {\n@@ -147,6 +205,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n         walk_impl_item(self, ii)\n     }\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n+        walk_impl_item_ref(self, ii)\n+    }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n         walk_trait_ref(self, t)\n     }\n@@ -206,6 +267,12 @@ pub trait Visitor<'v> : Sized {\n     fn visit_vis(&mut self, vis: &'v Visibility) {\n         walk_vis(self, vis)\n     }\n+    fn visit_associated_item_kind(&mut self, kind: &'v AssociatedItemKind) {\n+        walk_associated_item_kind(self, kind);\n+    }\n+    fn visit_defaultness(&mut self, defaultness: &'v Defaultness) {\n+        walk_defaultness(self, defaultness);\n+    }\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n@@ -341,12 +408,14 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item, impl_items);\n+            for impl_item_ref in impl_item_refs {\n+                visitor.visit_impl_item_ref(impl_item_ref);\n+            }\n         }\n         ItemStruct(ref struct_definition, ref generics) |\n         ItemUnion(ref struct_definition, ref generics) => {\n@@ -677,10 +746,14 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    visitor.visit_vis(&impl_item.vis);\n-    visitor.visit_name(impl_item.span, impl_item.name);\n-    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n-    match impl_item.node {\n+    // NB: Deliberately force a compilation error if/when new fields are added.\n+    let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n+\n+    visitor.visit_name(span, name);\n+    visitor.visit_vis(vis);\n+    visitor.visit_defaultness(defaultness);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match *node {\n         ImplItemKind::Const(ref ty, ref expr) => {\n             visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n@@ -703,6 +776,17 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n+    // NB: Deliberately force a compilation error if/when new fields are added.\n+    let ImplItemRef { id, name, ref kind, span, ref vis, ref defaultness } = *impl_item_ref;\n+    visitor.visit_nested_impl_item(id);\n+    visitor.visit_name(span, name);\n+    visitor.visit_associated_item_kind(kind);\n+    visitor.visit_vis(vis);\n+    visitor.visit_defaultness(defaultness);\n+}\n+\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n     visitor.visit_id(struct_definition.id());\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n@@ -872,6 +956,18 @@ pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n     }\n }\n \n+pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssociatedItemKind) {\n+    // No visitable content here: this fn exists so you can call it if\n+    // the right thing to do, should content be added in the future,\n+    // would be to walk it.\n+}\n+\n+pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n+    // No visitable content here: this fn exists so you can call it if\n+    // the right thing to do, should content be added in the future,\n+    // would be to walk it.\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n pub struct IdRange {\n     pub min: NodeId,"}, {"sha": "1e373441e9e85251d1ca4c4aa97a1b343f83c6da", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{Item, ImplItem};\n+use super::intravisit::Visitor;\n+\n+/// The \"item-like visitor\" visitor defines only the top-level methods\n+/// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n+/// this trait is the right one to implement will depend on the\n+/// overall pattern you need. Here are the three available patterns,\n+/// in roughly the order of desirability:\n+///\n+/// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n+///    - Example: find all items with a `#[foo]` attribute on them.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.visit_all_item_likes_in_krate()`.\n+///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n+///    - Pro: Integrates well into dependency tracking.\n+///    - Con: Don't get information about nesting\n+///    - Con: Don't have methods for specific bits of HIR, like \"on\n+///      every expr, do this\".\n+/// 2. **Deep visit**: Want to scan for specific kinds of HIR nodes within\n+///    an item, but don't care about how item-like things are nested\n+///    within one another.\n+///    - Example: Examine each expression to look for its type and do some check or other.\n+///    - How: Implement `intravisit::Visitor` and use\n+///      `tcx.visit_all_item_likes_in_krate(visitor.as_deep_visitor())`. Within\n+///      your `intravisit::Visitor` impl, implement methods like\n+///      `visit_expr()`; don't forget to invoke\n+///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n+///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+///    - Pro: Integrates well into dependency tracking.\n+///    - Con: Don't get information about nesting between items\n+/// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n+///    item-like things.\n+///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n+///      impl into scope while visiting the impl-items, and then back out again.\n+///    - How: Implement `intravisit::Visitor` and override the `visit_nested_foo()` foo methods\n+///      as needed. Walk your crate with `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n+///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+///    - Pro: Preserves nesting information\n+///    - Con: Does not integrate well into dependency tracking.\n+///\n+/// Note: the methods of `ItemLikeVisitor` intentionally have no\n+/// defaults, so that as we expand the list of item-like things, we\n+/// revisit the various visitors to see if they need to change. This\n+/// is harder to do with `intravisit::Visitor`, so when you add a new\n+/// `visit_nested_foo()` method, it is recommended that you search for\n+/// existing `fn visit_nested` methods to see where changes are\n+/// needed.\n+pub trait ItemLikeVisitor<'hir> {\n+    fn visit_item(&mut self, item: &'hir Item);\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem);\n+}\n+\n+pub struct DeepVisitor<'v, V: 'v> {\n+    visitor: &'v mut V,\n+}\n+\n+impl<'v, 'hir, V> DeepVisitor<'v, V>\n+    where V: Visitor<'hir> + 'v\n+{\n+    pub fn new(base: &'v mut V) -> Self {\n+        DeepVisitor { visitor: base }\n+    }\n+}\n+\n+impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n+    where V: Visitor<'hir>\n+{\n+    fn visit_item(&mut self, item: &'hir Item) {\n+        self.visitor.visit_item(item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem) {\n+        self.visitor.visit_impl_item(impl_item);\n+    }\n+}"}, {"sha": "05c4ae521803aa36f1425fff099ed21c2ce8193f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -105,6 +105,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n+            impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n@@ -113,12 +114,20 @@ impl<'a> LoweringContext<'a> {\n                 self.items.insert(item.id, self.lctx.lower_item(item));\n                 visit::walk_item(self, item);\n             }\n+\n+            fn visit_impl_item(&mut self, item: &ImplItem) {\n+                let id = self.lctx.lower_impl_item_ref(item).id;\n+                self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n+                visit::walk_impl_item(self, item);\n+            }\n         }\n \n-        let items = {\n-            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(), lctx: self };\n+        let (items, impl_items) = {\n+            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(),\n+                                                 impl_items: BTreeMap::new(),\n+                                                 lctx: self };\n             visit::walk_crate(&mut item_lowerer, c);\n-            item_lowerer.items\n+            (item_lowerer.items, item_lowerer.impl_items)\n         };\n \n         hir::Crate {\n@@ -127,6 +136,7 @@ impl<'a> LoweringContext<'a> {\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,\n+            impl_items: impl_items,\n         }\n     }\n \n@@ -631,7 +641,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n-                                               .map(|item| self.lower_impl_item(item))\n+                                               .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n@@ -689,7 +699,7 @@ impl<'a> LoweringContext<'a> {\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis),\n-                defaultness: this.lower_defaultness(i.defaultness),\n+                defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n@@ -705,6 +715,28 @@ impl<'a> LoweringContext<'a> {\n                 span: i.span,\n             }\n         })\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { node_id: i.id },\n+            name: i.ident.name,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            kind: match i.node {\n+                ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n+                ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n+                ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n+                    has_self: sig.decl.get_self().is_some(),\n+                },\n+                ImplItemKind::Macro(..) => unimplemented!(),\n+            },\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n \n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n@@ -1620,10 +1652,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_defaultness(&mut self, d: Defaultness) -> hir::Defaultness {\n+    fn lower_defaultness(&mut self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n         match d {\n-            Defaultness::Default => hir::Defaultness::Default,\n-            Defaultness::Final => hir::Defaultness::Final,\n+            Defaultness::Default => hir::Defaultness::Default { has_value: has_value },\n+            Defaultness::Final => {\n+                assert!(has_value);\n+                hir::Defaultness::Final\n+            }\n         }\n     }\n "}, {"sha": "51a378a08336e93c22a4a2d5e2a10bc4589818f8", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -92,13 +92,22 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n+\n+    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n+\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n         if !self.ignore_nested_items {\n             self.visit_item(self.krate.item(item.id))\n         }\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n+        self.visit_impl_item(self.krate.impl_item(item_id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "06cfc8aee8c9d382b69c04d3f2b7f197e540bce9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -254,9 +254,14 @@ impl<'ast> Map<'ast> {\n                         return DepNode::Hir(def_id);\n                     }\n \n+                    EntryImplItem(..) => {\n+                        let def_id = self.local_def_id(id);\n+                        assert!(!self.is_inlined_def_id(def_id));\n+                        return DepNode::Hir(def_id);\n+                    }\n+\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n-                    EntryImplItem(p, _) |\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n@@ -378,6 +383,14 @@ impl<'ast> Map<'ast> {\n         self.forest.krate()\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n+        self.read(id.node_id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.impl_item(id)\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "9f5ff6914b0cc0b2b29b5064db5943bd4ca5588a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -68,6 +68,7 @@ pub mod check_attr;\n pub mod def;\n pub mod def_id;\n pub mod intravisit;\n+pub mod itemlikevisit;\n pub mod lowering;\n pub mod map;\n pub mod pat_util;\n@@ -423,13 +424,19 @@ pub struct Crate {\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n     pub items: BTreeMap<NodeId, Item>,\n+\n+    pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n }\n \n impl Crate {\n     pub fn item(&self, id: NodeId) -> &Item {\n         &self.items[&id]\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem {\n+        &self.impl_items[&id]\n+    }\n+\n     /// Visits all items in the crate in some determinstic (but\n     /// unspecified) order. If you just need to process every item,\n     /// but don't care about nesting, this method is the best choice.\n@@ -438,12 +445,16 @@ impl Crate {\n     /// follows lexical scoping rules -- then you want a different\n     /// approach. You should override `visit_nested_item` in your\n     /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_items<'hir, V>(&'hir self, visitor: &mut V)\n-        where V: intravisit::Visitor<'hir>\n+    pub fn visit_all_item_likes<'hir, V>(&'hir self, visitor: &mut V)\n+        where V: itemlikevisit::ItemLikeVisitor<'hir>\n     {\n         for (_, item) in &self.items {\n             visitor.visit_item(item);\n         }\n+\n+        for (_, impl_item) in &self.impl_items {\n+            visitor.visit_impl_item(impl_item);\n+        }\n     }\n }\n \n@@ -1041,6 +1052,14 @@ pub enum TraitItem_ {\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemId {\n+    pub node_id: NodeId,\n+}\n+\n /// Represents anything within an `impl` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n@@ -1240,17 +1259,27 @@ pub enum Constness {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Defaultness {\n-    Default,\n+    Default { has_value: bool },\n     Final,\n }\n \n impl Defaultness {\n+    pub fn has_value(&self) -> bool {\n+        match *self {\n+            Defaultness::Default { has_value, .. } => has_value,\n+            Defaultness::Final => true,\n+        }\n+    }\n+\n     pub fn is_final(&self) -> bool {\n         *self == Defaultness::Final\n     }\n \n     pub fn is_default(&self) -> bool {\n-        *self == Defaultness::Default\n+        match *self {\n+            Defaultness::Default { .. } => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -1527,7 +1556,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             HirVec<ImplItem>),\n+             HirVec<ImplItemRef>),\n }\n \n impl Item_ {\n@@ -1551,6 +1580,29 @@ impl Item_ {\n     }\n }\n \n+/// A reference from an impl to one of its associated items. This\n+/// contains the item's id, naturally, but also the item's name and\n+/// some other high-level details (like whether it is an associated\n+/// type or method, and whether it is public). This allows other\n+/// passes to find the impl they want without loading the id (which\n+/// means fewer edges in the incremental compilation graph).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemRef {\n+    pub id: ImplItemId,\n+    pub name: Name,\n+    pub kind: AssociatedItemKind,\n+    pub span: Span,\n+    pub vis: Visibility,\n+    pub defaultness: Defaultness,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum AssociatedItemKind {\n+    Const,\n+    Method { has_self: bool },\n+    Type,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,"}, {"sha": "807bbec3b58888e36f0037d8df436ded6db16063", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n-                    self.print_impl_item(impl_item)?;\n+                    self.print_impl_item_ref(impl_item)?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -1020,14 +1020,25 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n+    pub fn print_impl_item_ref(&mut self, item_ref: &hir::ImplItemRef) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            // skip nested items if krate context was not provided\n+            let item = &krate.impl_item(item_ref.id);\n+            self.print_impl_item(item)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo)?;\n         self.print_outer_attributes(&ii.attrs)?;\n \n-        if let hir::Defaultness::Default = ii.defaultness {\n-            self.word_nbsp(\"default\")?;\n+        match ii.defaultness {\n+            hir::Defaultness::Default { .. } => self.word_nbsp(\"default\")?,\n+            hir::Defaultness::Final => (),\n         }\n \n         match ii.node {"}, {"sha": "5d33d6e6d2e71ee443d443188eea09c08995aa99", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -184,7 +184,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         // We use SmallVector here instead of Vec because this code is hot and\n         // it's rare that the stack length exceeds 1.\n-        let mut stack = SmallVector::zero();\n+        let mut stack = SmallVector::new();\n         stack.push((a_ty, dir, b_vid));\n         loop {\n             // For each turn of the loop, we extract a tuple\n@@ -274,7 +274,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n-            span: self.trace.origin.span(),\n+            span: self.trace.cause.span,\n             for_vid: for_vid,\n             make_region_vars: make_region_vars,\n             cycle_detected: false"}, {"sha": "58caac4034e34a1144e70ec4e06c08e645c5cb75", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 81, "deletions": 31, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -80,8 +80,9 @@ use hir::print as pprust;\n use lint;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use infer::{self, TypeOrigin};\n+use infer;\n use middle::region;\n+use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n@@ -524,10 +525,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn note_error_origin(&self,\n                          err: &mut DiagnosticBuilder<'tcx>,\n-                         origin: &TypeOrigin)\n+                         cause: &ObligationCause<'tcx>)\n     {\n-        match origin {\n-            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+        match cause.code {\n+            ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar {..} => {\n                     err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n                 }\n@@ -541,7 +542,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn note_type_err(&self,\n                          diag: &mut DiagnosticBuilder<'tcx>,\n-                         origin: TypeOrigin,\n+                         cause: &ObligationCause<'tcx>,\n                          secondary_span: Option<(Span, String)>,\n                          values: Option<ValuePairs<'tcx>>,\n                          terr: &TypeError<'tcx>)\n@@ -558,7 +559,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let span = origin.span();\n+        let span = cause.span;\n \n         if let Some((expected, found)) = expected_found {\n             let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n@@ -588,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             diag.span_label(sp, &msg);\n         }\n \n-        self.note_error_origin(diag, &origin);\n+        self.note_error_origin(diag, &cause);\n         self.check_and_note_conflicting_crates(diag, terr, span);\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n@@ -598,17 +599,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          terr: &TypeError<'tcx>)\n                                          -> DiagnosticBuilder<'tcx>\n     {\n-        let span = trace.origin.span();\n-        let failure_str = trace.origin.as_failure_str();\n-        let mut diag = match trace.origin {\n-            TypeOrigin::IfExpressionWithNoElse(_) => {\n+        let span = trace.cause.span;\n+        let failure_str = trace.cause.as_failure_str();\n+        let mut diag = match trace.cause.code {\n+            ObligationCauseCode::IfExpressionWithNoElse => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n             },\n             _ => {\n                 struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str)\n             },\n         };\n-        self.note_type_err(&mut diag, trace.origin, None, Some(trace.values), terr);\n+        self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr);\n         diag\n     }\n \n@@ -1052,21 +1053,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n                             Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n-                        },\n-                        _ => None\n+                        }\n+                        _ => None,\n                     }\n                 }\n                 ast_map::NodeImplItem(item) => {\n-                    match item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => {\n-                            Some((&sig.decl,\n-                                  &sig.generics,\n-                                  sig.unsafety,\n-                                  sig.constness,\n-                                  item.name,\n-                                  item.span))\n+                    let id = self.tcx.map.get_parent(item.id);\n+                    if let Some(ast_map::NodeItem(parent_scope)) = self.tcx.map.find(id) {\n+                        if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n+                            // this impl scope implements a trait, do not recomend\n+                            // using explicit lifetimes (#37363)\n+                            return;\n                         }\n-                        _ => None,\n+                    }\n+                    if let hir::ImplItemKind::Method(ref sig, _) = item.node {\n+                        Some((&sig.decl,\n+                              &sig.generics,\n+                              sig.unsafety,\n+                              sig.constness,\n+                              item.name,\n+                              item.span))\n+                    } else {\n+                        None\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n@@ -1079,12 +1087,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   item.name,\n                                   item.span))\n                         }\n-                        _ => None\n+                        _ => None,\n                     }\n                 }\n-                _ => None\n+                _ => None,\n             },\n-            None => None\n+            None => None,\n         };\n         let (fn_decl, generics, unsafety, constness, name, span)\n                                     = node_inner.expect(\"expect item fn\");\n@@ -1436,7 +1444,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n-                            let generics = self.tcx.lookup_generics(did);\n+                            let generics = self.tcx.item_generics(did);\n \n                             let expected =\n                                 generics.regions.len() as u32;\n@@ -1688,18 +1696,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n                     // FIXME: do we want a \"the\" here?\n                     err.span_note(\n-                        trace.origin.span(),\n+                        trace.cause.span,\n                         &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.origin.as_requirement_str(), expected, found));\n+                                 trace.cause.as_requirement_str(), expected, found));\n                 } else {\n                     // FIXME: this really should be handled at some earlier stage. Our\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n                     err.span_note(\n-                        trace.origin.span(),\n+                        trace.cause.span,\n                         &format!(\"...so that {}\",\n-                                 trace.origin.as_requirement_str()));\n+                                 trace.cause.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1954,3 +1962,45 @@ fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n                     span: syntax_pos::DUMMY_SP,\n                     name: name }\n }\n+\n+impl<'tcx> ObligationCause<'tcx> {\n+    fn as_failure_str(&self) -> &'static str {\n+        use traits::ObligationCauseCode::*;\n+        match self.code {\n+            CompareImplMethodObligation { .. } => \"method not compatible with trait\",\n+            MatchExpressionArm { source, .. } => match source {\n+                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n+                _ => \"match arms have incompatible types\",\n+            },\n+            IfExpression => \"if and else have incompatible types\",\n+            IfExpressionWithNoElse => \"if may be missing an else clause\",\n+            EquatePredicate => \"equality predicate not satisfied\",\n+            MainFunctionType => \"main function has wrong type\",\n+            StartFunctionType => \"start function has wrong type\",\n+            IntrinsicType => \"intrinsic has wrong type\",\n+            MethodReceiver => \"mismatched method receiver\",\n+            _ => \"mismatched types\",\n+        }\n+    }\n+\n+    fn as_requirement_str(&self) -> &'static str {\n+        use traits::ObligationCauseCode::*;\n+        match self.code {\n+            CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n+            ExprAssignable => \"expression is assignable\",\n+            MatchExpressionArm { source, .. } => match source {\n+                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have compatible types\",\n+                _ => \"match arms have compatible types\",\n+            },\n+            IfExpression => \"if and else have compatible types\",\n+            IfExpressionWithNoElse => \"if missing an else returns ()\",\n+            EquatePredicate => \"equality where clause is satisfied\",\n+            MainFunctionType => \"`main` function has the correct type\",\n+            StartFunctionType => \"`start` function has the correct type\",\n+            IntrinsicType => \"intrinsic has the correct type\",\n+            MethodReceiver => \"method receiver has the correct type\",\n+            _ => \"types are compatible\",\n+        }\n+    }\n+}\n+"}, {"sha": "806b94486615fcd7d313796effbeeeab0ce3663f", "filename": "src/librustc/infer/fudge.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+\n+use super::InferCtxt;\n+use super::RegionVariableOrigin;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// This rather funky routine is used while processing expected\n+    /// types. What happens here is that we want to propagate a\n+    /// coercion through the return type of a fn to its\n+    /// argument. Consider the type of `Option::Some`, which is\n+    /// basically `for<T> fn(T) -> Option<T>`. So if we have an\n+    /// expression `Some(&[1, 2, 3])`, and that has the expected type\n+    /// `Option<&[u32]>`, we would like to type check `&[1, 2, 3]`\n+    /// with the expectation of `&[u32]`. This will cause us to coerce\n+    /// from `&[u32; 3]` to `&[u32]` and make the users life more\n+    /// pleasant.\n+    ///\n+    /// The way we do this is using `fudge_regions_if_ok`. What the\n+    /// routine actually does is to start a snapshot and execute the\n+    /// closure `f`. In our example above, what this closure will do\n+    /// is to unify the expectation (`Option<&[u32]>`) with the actual\n+    /// return type (`Option<?T>`, where `?T` represents the variable\n+    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n+    /// input type (`?T`) is then returned by `f()`.\n+    ///\n+    /// At this point, `fudge_regions_if_ok` will normalize all type\n+    /// variables, converting `?T` to `&?a [u32]` and end the\n+    /// snapshot.  The problem is that we can't just return this type\n+    /// out, because it references the region variable `?a`, and that\n+    /// region variable was popped when we popped the snapshot.\n+    ///\n+    /// So what we do is to keep a list (`region_vars`, in the code below)\n+    /// of region variables created during the snapshot (here, `?a`). We\n+    /// fold the return value and replace any such regions with a *new*\n+    /// region variable (e.g., `?b`) and return the result (`&?b [u32]`).\n+    /// This can then be used as the expectation for the fn argument.\n+    ///\n+    /// The important point here is that, for soundness purposes, the\n+    /// regions in question are not particularly important. We will\n+    /// use the expected types to guide coercions, but we will still\n+    /// type-check the resulting types from those coercions against\n+    /// the actual types (`?T`, `Option<?T`) -- and remember that\n+    /// after the snapshot is popped, the variable `?T` is no longer\n+    /// unified.\n+    ///\n+    /// Assumptions:\n+    /// - no new type variables are created during `f()` (asserted\n+    ///   below); this simplifies our logic since we don't have to\n+    ///   check for escaping type variables\n+    pub fn fudge_regions_if_ok<T, E, F>(&self,\n+                                        origin: &RegionVariableOrigin,\n+                                        f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>,\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (region_vars, value) = self.probe(|snapshot| {\n+            let vars_at_start = self.type_variables.borrow().num_vars();\n+\n+            match f() {\n+                Ok(value) => {\n+                    let value = self.resolve_type_vars_if_possible(&value);\n+\n+                    // At this point, `value` could in principle refer\n+                    // to regions that have been created during the\n+                    // snapshot (we assert below that `f()` does not\n+                    // create any new type variables, so there\n+                    // shouldn't be any of those). Once we exit\n+                    // `probe()`, those are going to be popped, so we\n+                    // will have to eliminate any references to them.\n+\n+                    assert_eq!(self.type_variables.borrow().num_vars(), vars_at_start,\n+                               \"type variables were created during fudge_regions_if_ok\");\n+                    let region_vars =\n+                        self.region_vars.vars_created_since_snapshot(\n+                            &snapshot.region_vars_snapshot);\n+\n+                    Ok((region_vars, value))\n+                }\n+                Err(e) => Err(e),\n+            }\n+        })?;\n+\n+        // At this point, we need to replace any of the now-popped\n+        // region variables that appear in `value` with a fresh region\n+        // variable. We can't do this during the probe because they\n+        // would just get popped then too. =)\n+\n+        // Micro-optimization: if no variables have been created, then\n+        // `value` can't refer to any of them. =) So we can just return it.\n+        if region_vars.is_empty() {\n+            return Ok(value);\n+        }\n+\n+        let mut fudger = RegionFudger {\n+            infcx: self,\n+            region_vars: &region_vars,\n+            origin: origin\n+        };\n+\n+        Ok(value.fold_with(&mut fudger))\n+    }\n+}\n+\n+pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    region_vars: &'a Vec<ty::RegionVid>,\n+    origin: &'a RegionVariableOrigin,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(v) if self.region_vars.contains(&v) => {\n+                self.infcx.next_region_var(self.origin.clone())\n+            }\n+            _ => {\n+                r\n+            }\n+        }\n+    }\n+}"}, {"sha": "08e522f5fd6ee4a39599f905b1f2874c74fa6575", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n \n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let (a_with_fresh, a_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, a);\n@@ -247,7 +247,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n@@ -325,10 +325,10 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(), HigherRankedType, a);\n+                    self.trace.cause.span, HigherRankedType, a);\n             let (b_with_fresh, b_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(), HigherRankedType, b);\n+                    self.trace.cause.span, HigherRankedType, b);\n             let a_vars = var_ids(self, &a_map);\n             let b_vars = var_ids(self, &b_map);\n \n@@ -341,7 +341,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n@@ -463,7 +463,7 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n            ty::ReVar(r) => { r }\n            _ => {\n                span_bug!(\n-                   fields.trace.origin.span(),\n+                   fields.trace.cause.span,\n                    \"found non-region-vid: {:?}\",\n                    r);\n            }"}, {"sha": "6ae104d79122bce0aab12d0a22d68c0917ac56fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 34, "deletions": 198, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -32,7 +32,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::{self, PredicateObligations, Reveal};\n+use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n@@ -50,6 +50,7 @@ mod bivariate;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n@@ -172,90 +173,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n /// region that each late-bound region was replaced with.\n pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n-/// Why did we require that the two types be related?\n-///\n-/// See `error_reporting.rs` for more details\n-#[derive(Clone, Copy, Debug)]\n-pub enum TypeOrigin {\n-    // Not yet categorized in a better way\n-    Misc(Span),\n-\n-    // Checking that method of impl is compatible with trait\n-    MethodCompatCheck(Span),\n-\n-    // Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n-    ExprAssignable(Span),\n-\n-    // Relating trait type parameters to those found in impl etc\n-    RelateOutputImplTypes(Span),\n-\n-    // Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Span, Span, hir::MatchSource),\n-\n-    // Computing common supertype in an if expression\n-    IfExpression(Span),\n-\n-    // Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse(Span),\n-\n-    // `where a == b`\n-    EquatePredicate(Span),\n-\n-    // `main` has wrong type\n-    MainFunctionType(Span),\n-\n-    // `start` has wrong type\n-    StartFunctionType(Span),\n-\n-    // intrinsic has wrong type\n-    IntrinsicType(Span),\n-\n-    // method receiver\n-    MethodReceiver(Span),\n-}\n-\n-impl TypeOrigin {\n-    fn as_failure_str(&self) -> &'static str {\n-        match self {\n-            &TypeOrigin::Misc(_) |\n-            &TypeOrigin::RelateOutputImplTypes(_) |\n-            &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n-            &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n-            &TypeOrigin::MatchExpressionArm(.., source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n-                _ => \"match arms have incompatible types\",\n-            },\n-            &TypeOrigin::IfExpression(_) => \"if and else have incompatible types\",\n-            &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n-            &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n-            &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n-            &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n-            &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n-            &TypeOrigin::MethodReceiver(_) => \"mismatched method receiver\",\n-        }\n-    }\n-\n-    fn as_requirement_str(&self) -> &'static str {\n-        match self {\n-            &TypeOrigin::Misc(_) => \"types are compatible\",\n-            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n-            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n-            &TypeOrigin::RelateOutputImplTypes(_) => {\n-                \"trait type parameters matches those specified on the impl\"\n-            }\n-            &TypeOrigin::MatchExpressionArm(..) => \"match arms have compatible types\",\n-            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n-            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n-            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n-            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n-            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n-            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n-            &TypeOrigin::MethodReceiver(_) => \"method receiver has the correct type\",\n-        }\n-    }\n-}\n-\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n@@ -270,7 +187,7 @@ pub enum ValuePairs<'tcx> {\n /// See `error_reporting.rs` for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n-    origin: TypeOrigin,\n+    cause: ObligationCause<'tcx>,\n     values: ValuePairs<'tcx>,\n }\n \n@@ -986,49 +903,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit only the region bindings if successful.\n-    /// The function f must be very careful not to leak any non-region\n-    /// variables that get created.\n-    pub fn commit_regions_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n-    {\n-        debug!(\"commit_regions_if_ok()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_vars_snapshot,\n-                               obligations_in_snapshot } = self.start_snapshot();\n-\n-        let r = self.commit_if_ok(|_| f());\n-\n-        debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n-\n-        assert!(!self.obligations_in_snapshot.get());\n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n-\n-        // Roll back any non-region bindings - they should be resolved\n-        // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n-        self.projection_cache\n-            .borrow_mut()\n-            .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .rollback_to(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .rollback_to(float_snapshot);\n-\n-        // Commit region vars that may escape through resolved types.\n-        self.region_vars\n-            .commit(region_vars_snapshot);\n-\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,\n@@ -1049,14 +923,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n-                     origin: TypeOrigin,\n+                     cause: &ObligationCause<'tcx>,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n+            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n@@ -1067,7 +941,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          -> UnitResult<'tcx>\n     {\n         self.probe(|_| {\n-            let origin = TypeOrigin::Misc(syntax_pos::DUMMY_SP);\n+            let origin = &ObligationCause::dummy();\n             let trace = TypeTrace::types(origin, true, a, b);\n             self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n                 // FIXME(#32730) propagate obligations\n@@ -1078,28 +952,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n-                    origin: TypeOrigin,\n+                    cause: &ObligationCause<'tcx>,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n+            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n     pub fn eq_trait_refs(&self,\n                           a_is_expected: bool,\n-                          origin: TypeOrigin,\n+                          cause: &ObligationCause<'tcx>,\n                           a: ty::TraitRef<'tcx>,\n                           b: ty::TraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n-                origin: origin,\n+                cause: cause.clone(),\n                 values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n@@ -1108,30 +982,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn eq_impl_headers(&self,\n                            a_is_expected: bool,\n-                           origin: TypeOrigin,\n+                           cause: &ObligationCause<'tcx>,\n                            a: &ty::ImplHeader<'tcx>,\n                            b: &ty::ImplHeader<'tcx>)\n                            -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n         match (a.trait_ref, b.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, origin, a_ref, b_ref),\n-            (None, None) => self.eq_types(a_is_expected, origin, a.self_ty, b.self_ty),\n+            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, cause, a_ref, b_ref),\n+            (None, None) => self.eq_types(a_is_expected, cause, a.self_ty, b.self_ty),\n             _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n         }\n     }\n \n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n-                               origin: TypeOrigin,\n+                               cause: ObligationCause<'tcx>,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n-                origin: origin,\n+                cause: cause,\n                 values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n@@ -1147,16 +1021,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn equality_predicate(&self,\n-                              span: Span,\n+                              cause: &ObligationCause<'tcx>,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = TypeOrigin::EquatePredicate(span);\n-            let eqty_ok = self.eq_types(false, origin, a, b)?;\n-            self.leak_check(false, span, &skol_map, snapshot)?;\n+            let cause_span = cause.span;\n+            let eqty_ok = self.eq_types(false, cause, a, b)?;\n+            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(eqty_ok.unit())\n         })\n@@ -1193,10 +1067,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n-        (0..n).map(|_i| self.next_ty_var()).collect()\n-    }\n-\n     pub fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table\n             .borrow_mut()\n@@ -1490,26 +1360,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   origin: TypeOrigin,\n+                                   cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n                                    err: TypeError<'tcx>) {\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(ExpectedFound {\n-                expected: expected,\n-                found: actual\n-            })\n-        };\n+        let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err).emit();\n     }\n \n     pub fn report_conflicting_default_types(&self,\n                                             span: Span,\n+                                            body_id: ast::NodeId,\n                                             expected: type_variable::Default<'tcx>,\n                                             actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(span),\n+            cause: ObligationCause::misc(span, body_id),\n             values: Types(ExpectedFound {\n                 expected: expected.ty,\n                 found: actual.ty\n@@ -1554,15 +1419,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n     /// details.\n     pub fn match_poly_projection_predicate(&self,\n-                                           origin: TypeOrigin,\n+                                           cause: ObligationCause<'tcx>,\n                                            match_a: ty::PolyProjectionPredicate<'tcx>,\n                                            match_b: ty::TraitRef<'tcx>)\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n-        let span = origin.span();\n+        let span = cause.span;\n         let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n         let trace = TypeTrace {\n-            origin: origin,\n+            cause: cause,\n             values: TraitRefs(ExpectedFound::new(true, match_trait_ref, match_b))\n         };\n \n@@ -1700,7 +1565,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let InferTables::Local(tables) = self.tables {\n             if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n-                return ty.subst(self.tcx, substs.func_substs);\n+                return ty.subst(self.tcx, substs.substs);\n             }\n         }\n \n@@ -1711,23 +1576,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n-        self.origin.span()\n+        self.cause.span\n     }\n \n-    pub fn types(origin: TypeOrigin,\n+    pub fn types(cause: &ObligationCause<'tcx>,\n                  a_is_expected: bool,\n                  a: Ty<'tcx>,\n                  b: Ty<'tcx>)\n                  -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: origin,\n+            cause: cause.clone(),\n             values: Types(ExpectedFound::new(a_is_expected, a, b))\n         }\n     }\n \n     pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: TypeOrigin::Misc(syntax_pos::DUMMY_SP),\n+            cause: ObligationCause::dummy(),\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n@@ -1738,26 +1603,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n \n impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeTrace({:?})\", self.origin)\n-    }\n-}\n-\n-impl TypeOrigin {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TypeOrigin::MethodCompatCheck(span) => span,\n-            TypeOrigin::ExprAssignable(span) => span,\n-            TypeOrigin::Misc(span) => span,\n-            TypeOrigin::RelateOutputImplTypes(span) => span,\n-            TypeOrigin::MatchExpressionArm(match_span, ..) => match_span,\n-            TypeOrigin::IfExpression(span) => span,\n-            TypeOrigin::IfExpressionWithNoElse(span) => span,\n-            TypeOrigin::EquatePredicate(span) => span,\n-            TypeOrigin::MainFunctionType(span) => span,\n-            TypeOrigin::StartFunctionType(span) => span,\n-            TypeOrigin::IntrinsicType(span) => span,\n-            TypeOrigin::MethodReceiver(span) => span,\n-        }\n+        write!(f, \"TypeTrace({:?})\", self.cause)\n     }\n }\n \n@@ -1834,16 +1680,6 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for TypeOrigin {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        self.clone()\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n@@ -1871,12 +1707,12 @@ impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         TypeTrace {\n-            origin: self.origin.fold_with(folder),\n+            cause: self.cause.fold_with(folder),\n             values: self.values.fold_with(folder)\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.origin.visit_with(visitor) || self.values.visit_with(visitor)\n+        self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n     }\n }"}, {"sha": "dae30ea97c80d5169e57498f7706f2c6144f35c4", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::CombineFields;\n use super::SubregionOrigin;\n+use super::combine::CombineFields;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use ty::{self, Ty, TyCtxt};\n@@ -111,11 +111,13 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n+\n         // FIXME -- we have more fine-grained information available\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+\n         Ok(a)\n     }\n "}, {"sha": "804765ec8811e52171ce8e6e3207c9d291f44269", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -184,6 +184,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         v\n     }\n \n+    pub fn num_vars(&self) -> usize {\n+        self.values.len()\n+    }\n+\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.eq_relations.find(vid)\n     }"}, {"sha": "8c0d70c6d602b731b054452e74799357bb3a8887", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -40,6 +40,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(unboxed_closures)]\n #![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "a490b58964a71f04c67a589e018ff61faf7bd0d4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -106,7 +106,7 @@ pub trait IntoEarlyLint {\n     fn into_early_lint(self, id: LintId) -> EarlyLint;\n }\n \n-impl<'a> IntoEarlyLint for (Span, &'a str) {\n+impl<'a, S: Into<MultiSpan>> IntoEarlyLint for (S, &'a str) {\n     fn into_early_lint(self, id: LintId) -> EarlyLint {\n         let (span, msg) = self;\n         let mut diagnostic = Diagnostic::new(errors::Level::Warning, msg);\n@@ -530,7 +530,10 @@ pub trait LintContext: Sized {\n         })\n     }\n \n-    fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n+    fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n+                                           lint: &'static Lint,\n+                                           span: Option<S>,\n+                                           msg: &str) {\n         let (level, src) = match self.level_src(lint) {\n             None => return,\n             Some(pair) => pair,\n@@ -553,7 +556,7 @@ pub trait LintContext: Sized {\n     }\n \n     /// Emit a lint at the appropriate level, for a particular span.\n-    fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+    fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n@@ -601,7 +604,7 @@ pub trait LintContext: Sized {\n \n     /// Emit a lint at the appropriate level, with no associated span.\n     fn lint(&self, lint: &'static Lint, msg: &str) {\n-        self.lookup_and_emit(lint, None, msg);\n+        self.lookup_and_emit(lint, None as Option<Span>, msg);\n     }\n \n     /// Merge the lints specified by any lint attributes into the\n@@ -789,16 +792,15 @@ impl<'a> LintContext for EarlyContext<'a> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, it: &hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n             cx.visit_ids(|v| v.visit_item(it));\n@@ -807,27 +809,27 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, late_passes, it);\n             hir_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, late_passes, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         run_lints!(self, check_pat, late_passes, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt) {\n         // statement attributes are actually just attributes on one of\n         // - item\n         // - local\n@@ -837,40 +839,43 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         hir_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &hir::VariantData,\n+                        s: &'tcx hir::VariantData,\n                         name: ast::Name,\n-                        g: &hir::Generics,\n+                        g: &'tcx hir::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, late_passes, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, late_passes, s, name, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(&s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, late_passes, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         run_lints!(self, check_ty, late_passes, t);\n         hir_visit::walk_ty(self, t);\n     }\n@@ -879,45 +884,45 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_name, late_passes, sp, name);\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, late_passes, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n         run_lints!(self, check_mod_post, late_passes, m, s, n);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         run_lints!(self, check_block, late_passes, b);\n         hir_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, late_passes, b);\n     }\n \n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         run_lints!(self, check_arm, late_passes, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &hir::Decl) {\n+    fn visit_decl(&mut self, d: &'tcx hir::Decl) {\n         run_lints!(self, check_decl, late_passes, d);\n         hir_visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &hir::Expr) {\n+    fn visit_expr_post(&mut self, e: &'tcx hir::Expr) {\n         run_lints!(self, check_expr_post, late_passes, e);\n     }\n \n-    fn visit_generics(&mut self, g: &hir::Generics) {\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, late_passes, trait_item);\n             cx.visit_ids(|v| hir_visit::walk_trait_item(v, trait_item));\n@@ -926,7 +931,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, late_passes, impl_item);\n             cx.visit_ids(|v| hir_visit::walk_impl_item(v, impl_item));\n@@ -935,20 +940,20 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lt: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n         run_lints!(self, check_lifetime, late_passes, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &'tcx hir::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n-    fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         run_lints!(self, check_path_list_item, late_passes, item);\n         hir_visit::walk_path_list_item(self, prefix, item);\n     }\n@@ -1113,7 +1118,6 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n \n // Output any lints that were previously added to the session.\n impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n-\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);"}, {"sha": "f61978271e7f6c34e1bb095e9e8dca16c0c23ffb", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -89,6 +89,13 @@ pub enum NativeLibraryKind {\n     NativeUnknown,   // default way to specify a dynamic library\n }\n \n+#[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n+pub struct NativeLibrary {\n+    pub kind: NativeLibraryKind,\n+    pub name: String,\n+    pub cfg: Option<P<ast::MetaItem>>,\n+}\n+\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n@@ -204,7 +211,7 @@ pub trait CrateStore<'tcx> {\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n     fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n@@ -231,7 +238,7 @@ pub trait CrateStore<'tcx> {\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n-    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n+    fn used_libraries(&self) -> Vec<NativeLibrary>;\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n@@ -377,7 +384,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n         { bug!(\"native_libraries\") }\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n@@ -412,7 +419,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n+    fn used_libraries(&self) -> Vec<NativeLibrary> {\n+        vec![]\n+    }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions"}, {"sha": "991398813752f8a5991536259f804b0d1a8f0749", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,6 +16,7 @@ use dep_graph::DepNode;\n use hir::map as ast_map;\n use hir::{self, pat_util, PatKind};\n use hir::intravisit::{self, Visitor};\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n use middle::privacy;\n use ty::{self, TyCtxt};\n@@ -329,11 +330,12 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder {\n-    worklist: Vec<ast::NodeId>\n+struct LifeSeeder<'k> {\n+    worklist: Vec<ast::NodeId>,\n+    krate: &'k hir::Crate,\n }\n \n-impl<'v> Visitor<'v> for LifeSeeder {\n+impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n         if allow_dead_code {\n@@ -357,17 +359,22 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n-                        self.worklist.push(impl_item.id);\n+                        self.worklist.push(impl_item_ref.id.node_id);\n                     }\n                 }\n             }\n             _ => ()\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &hir::ImplItem) {\n+        // ignore: we are handling this in `visit_item` above\n+    }\n }\n \n fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -386,9 +393,10 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Seed implemented trait items\n     let mut life_seeder = LifeSeeder {\n-        worklist: worklist\n+        worklist: worklist,\n+        krate: krate,\n     };\n-    krate.visit_all_items(&mut life_seeder);\n+    krate.visit_all_item_likes(&mut life_seeder);\n \n     return life_seeder.worklist;\n }\n@@ -433,7 +441,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.tables().node_id_to_type(field.id);\n+        let field_type = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n@@ -503,17 +511,16 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// Walk nested items in place so that we don't report dead-code\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n                 item.id,\n@@ -527,7 +534,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_variant(&mut self, variant: &hir::Variant, g: &hir::Generics, id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     variant: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n         if self.should_warn_about_variant(&variant.node) {\n             self.warn_dead_code(variant.node.data.id(), variant.span,\n                                 variant.node.name, \"variant\");\n@@ -536,14 +546,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_struct_field(&mut self, field: &hir::StructField) {\n+    fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n             self.warn_dead_code(field.id, field.span,\n                                 field.name, \"field\");\n@@ -552,7 +562,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         intravisit::walk_struct_field(self, field);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n@@ -573,7 +583,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n \n     // Overwrite so that we don't warn the trait item itself.\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {"}, {"sha": "25fe407271bc02c08e0ee9323faee8cfcc61a6f6", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -235,5 +235,5 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }"}, {"sha": "9dd54457a3499b442952af6a82939692b10b9584", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,8 +17,8 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn};\n-use hir::intravisit::Visitor;\n+use hir::{Item, ItemFn, ImplItem};\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,\n@@ -39,13 +39,17 @@ struct EntryContext<'a, 'tcx: 'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for EntryContext<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         let def_id = self.map.local_def_id(item.id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n+        // entry fn is never an impl item\n+    }\n }\n \n pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n@@ -74,7 +78,7 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n         non_main_fns: Vec::new(),\n     };\n \n-    ast_map.krate().visit_all_items(&mut ctxt);\n+    ast_map.krate().visit_all_item_likes(&mut ctxt);\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "cf08b59312d50a55d38f8e8fc401a70334799b73", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx: tcx\n     };\n-    tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n+    tcx.visit_all_item_likes_in_krate(DepNode::IntrinsicCheck, &mut visitor.as_deep_visitor());\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n@@ -51,7 +51,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n+        let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };"}, {"sha": "9b4b1396669a3a6ab5242977b2bed3d74bddc788", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -149,7 +149,7 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n     item_refs: FxHashMap<&'static str, usize>,\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n+impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n@@ -164,6 +164,10 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // at present, lang items are always items, not impl items\n+    }\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n@@ -219,7 +223,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n-        krate.visit_all_items(self);\n+        krate.visit_all_item_likes(self);\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "d381188d56b542de5cb8e146264623835b8cec28", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -112,7 +112,7 @@ use self::VarKind::*;\n use dep_graph::DepNode;\n use hir::def::*;\n use hir::pat_util;\n-use ty::{self, Ty, TyCtxt, ParameterEnvironment};\n+use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n use lint;\n@@ -196,7 +196,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n-    tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n+    tcx.map.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -1440,28 +1440,30 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n-        match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n-                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ => fn_ty.fn_ret()\n-        }\n-    }\n-\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n-                 _fk: FnKind,\n+                 fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &hir::Expr)\n     {\n+        let fn_ty = if let FnKind::Closure(_) = fk {\n+            self.ir.tcx.tables().node_id_to_type(id)\n+        } else {\n+            self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id))\n+        };\n+        let fn_ret = match fn_ty.sty {\n+            ty::TyClosure(closure_def_id, substs) =>\n+                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n+            _ => fn_ty.fn_ret()\n+        };\n+\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n-                &self.fn_ret(id));\n+                &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);"}, {"sha": "fedf8c2ec7472cd57ef6823627c509e52c0ad8a0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -945,9 +945,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 let ref_ty = self.overloaded_method_return_ty(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n-                // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n-                let self_ty = method_ty.fn_sig().input(0);\n-                (self.tcx().no_late_bound_regions(&self_ty).unwrap(),\n+                (ref_ty.builtin_deref(false, ty::NoPreference).unwrap().ty,\n                  ElementKind::OtherElement)\n             }\n             None => {"}, {"sha": "ac614494355a26c37277ebc4f7e1a8aca87d1c4d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -29,6 +29,7 @@ use syntax::ast;\n use syntax::attr;\n use hir;\n use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n // Returns true if the given set of generics implies that the item it's\n@@ -324,17 +325,21 @@ struct CollectPrivateImplItemsVisitor<'a> {\n     worklist: &'a mut Vec<ast::NodeId>,\n }\n \n-impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n+impl<'a, 'v> ItemLikeVisitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(_), _, ref impl_items) = item.node {\n+        if let hir::ItemImpl(.., Some(_), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n-                for impl_item in impl_items {\n-                    self.worklist.push(impl_item.id);\n+                for impl_item_ref in impl_item_refs {\n+                    self.worklist.push(impl_item_ref.id.node_id);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // processed in visit_item above\n+    }\n }\n \n pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -364,7 +369,7 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             access_levels: access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n-        tcx.map.krate().visit_all_items(&mut collect_private_impl_items);\n+        tcx.map.krate().visit_all_item_likes(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "5f9a6b283c6a06c42c921b9d8afd951851dc752a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1235,7 +1235,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n             },\n             terminating_scopes: NodeSet()\n         };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n     }\n     return maps;\n }"}, {"sha": "f682dfbf1be9526550bed9b052bb611d154549be", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -119,22 +119,29 @@ pub fn krate(sess: &Session,\n         late_bound: NodeMap(),\n     };\n     sess.track_errors(|| {\n-        krate.visit_all_items(&mut LifetimeContext {\n+        intravisit::walk_crate(&mut LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: &ROOT_SCOPE,\n             def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n-        });\n+        }, krate);\n     })?;\n     Ok(map)\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        assert!(self.labels_in_fn.is_empty());\n+impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+    // Override the nested functions -- lifetimes follow lexical scope,\n+    // so it's convenient to walk the tree in lexical order.\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.hir_map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        // Save labels for nested items.\n+        let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n@@ -175,10 +182,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         });\n \n         // Done traversing the item; remove any labels it created\n-        self.labels_in_fn.truncate(0);\n+        self.labels_in_fn = saved_labels_in_fn;\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         // Items save/restore the set of labels. This way inner items\n         // can freely reuse names, be they loop labels or lifetimes.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -201,8 +208,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -227,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n                 self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n@@ -257,7 +264,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         // We reset the labels on every trait item, so that different\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -274,15 +281,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -331,8 +338,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &hir::PolyTraitRef,\n-                            _modifier: &hir::TraitBoundModifier) {\n+                            trait_ref: &'tcx hir::PolyTraitRef,\n+                            _modifier: &'tcx hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n@@ -490,13 +497,12 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn<'b>(&mut self,\n-                                 fk: FnKind,\n-                                 fd: &hir::FnDecl,\n-                                 fb: &'b hir::Expr,\n-                                 _span: Span,\n-                                 fn_id: ast::NodeId) {\n-\n+    fn add_scope_and_walk_fn(&mut self,\n+                             fk: FnKind<'tcx>,\n+                             fd: &'tcx hir::FnDecl,\n+                             fb: &'tcx hir::Expr,\n+                             _span: Span,\n+                             fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 intravisit::walk_fn_decl(self, fd);\n@@ -519,8 +525,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                   |_old_scope, this| this.visit_expr(fb))\n     }\n \n+    // FIXME(#37666) this works around a limitation in the region inferencer\n+    fn hack<F>(&mut self, f: F) where\n+        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+    {\n+        f(self)\n+    }\n+\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: FnOnce(Scope, &mut LifetimeContext),\n+        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -557,10 +570,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n-                           decl: &hir::FnDecl,\n-                           generics: &hir::Generics,\n+                           decl: &'tcx hir::FnDecl,\n+                           generics: &'tcx hir::Generics,\n                            walk: F) where\n-        F: FnOnce(&mut LifetimeContext),\n+        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n         let fn_def_id = self.hir_map.local_def_id(fn_id);\n         insert_late_bound_lifetimes(self.map,\n@@ -590,11 +603,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let this = self;\n-        this.with(EarlyScope(&early, start as u32, this.scope), move |old_scope, this| {\n+        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                walk(this);\n+                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n             });\n         });\n     }"}, {"sha": "7e4efc7ddca06382c7c25e482399dbd661f542fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n-        where F: FnOnce(&mut Annotator)\n+        where F: FnOnce(&mut Self)\n     {\n         if self.index.staged_api[&LOCAL_CRATE] && self.tcx.sess.features.borrow().staged_api {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n@@ -234,16 +234,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n         match i.node {\n@@ -272,13 +271,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let kind = if self.in_trait_impl {\n             AnnotationKind::Prohibited\n         } else {\n@@ -289,25 +288,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n             intravisit::walk_variant(v, var, g, item_id);\n         })\n     }\n \n-    fn visit_struct_field(&mut self, s: &StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         self.annotate(s.id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n         self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         if md.imported_from.is_none() {\n             self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n         }\n@@ -444,16 +443,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n@@ -464,31 +462,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_expr(self, ex);\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_pat(self, pat)\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let old_skip_count = self.in_skip_block;\n         match b.rules {\n             hir::BlockCheckMode::PushUnstableBlock => {\n@@ -527,9 +525,10 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n+        hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for impl_item in impl_items {\n+            for impl_item_ref in impl_item_refs {\n+                let impl_item = tcx.map.impl_item(impl_item_ref.id);\n                 let item = tcx.associated_items(trait_did)\n                     .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {"}, {"sha": "12d32bf31b13dee60224341e288a6652bd5c35f8", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -50,7 +50,7 @@ pub fn check_crate(krate: &hir::Crate,\n \n     {\n         let mut cx = Context { sess: sess, items: items };\n-        krate.visit_all_items(&mut cx);\n+        krate.visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n     verify(sess, items);\n }"}, {"sha": "b3cec6ec8ff3fa2b39a0b78f609af910e6697078", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -923,7 +923,7 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n                         write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::Subslice { from, to } if to == 0 =>\n-                        write!(fmt, \"{:?}[{:?}:\", data.base, from),\n+                        write!(fmt, \"{:?}[{:?}:]\", data.base, from),\n                     ProjectionElem::Subslice { from, to } if from == 0 =>\n                         write!(fmt, \"{:?}[:-{:?}]\", data.base, to),\n                     ProjectionElem::Subslice { from, to } =>"}, {"sha": "73ea84e94aec50c323428cc63e07da23daa08603", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> Lvalue<'tcx> {\n             Lvalue::Local(index) =>\n                 LvalueTy::Ty { ty: mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: tcx.item_type(def_id) },\n             Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -188,7 +188,7 @@ impl<'tcx> Rvalue<'tcx> {\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n+                        Some(tcx.item_type(def.did).subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n                         Some(tcx.mk_closure_from_closure_substs(did, substs))"}, {"sha": "9becbd99eb33a2a6fb56bf01c4822d7d735c57a6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -258,14 +258,15 @@ impl Session {\n     pub fn unimpl(&self, msg: &str) -> ! {\n         self.diagnostic().unimpl(msg)\n     }\n-    pub fn add_lint(&self,\n-                    lint: &'static lint::Lint,\n-                    id: ast::NodeId,\n-                    sp: Span,\n-                    msg: String)\n+    pub fn add_lint<S: Into<MultiSpan>>(&self,\n+                                        lint: &'static lint::Lint,\n+                                        id: ast::NodeId,\n+                                        sp: S,\n+                                        msg: String)\n     {\n         self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n     }\n+\n     pub fn add_lint_diagnostic<M>(&self,\n                                   lint: &'static lint::Lint,\n                                   id: ast::NodeId,"}, {"sha": "2e06e83f8489ca4ded13fd450d139b05dd100ebd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -14,8 +14,8 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n-use infer::{InferCtxt, InferOk, TypeOrigin};\n-use syntax_pos::DUMMY_SP;\n+\n+use infer::{InferCtxt, InferOk};\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n@@ -55,8 +55,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    match selcx.infcx().eq_impl_headers(true, TypeOrigin::Misc(DUMMY_SP), &a_impl_header,\n-                                                                          &b_impl_header) {\n+    match selcx.infcx().eq_impl_headers(true,\n+                                        &ObligationCause::dummy(),\n+                                        &a_impl_header,\n+                                        &b_impl_header) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());"}, {"sha": "e0a397ad28fbd28f6946efa405907bef712c11df", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -26,7 +26,7 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{self, InferCtxt};\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n@@ -100,7 +100,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.probe(|_| {\n-            let origin = TypeOrigin::Misc(obligation.cause.span);\n             let err_buf;\n             let mut err = &error.err;\n             let mut values = None;\n@@ -121,9 +120,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.clone(),\n                     0\n                 );\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 if let Err(error) = self.eq_types(\n-                    false, origin,\n+                    false, &obligation.cause,\n                     data.ty, normalized.value\n                 ) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n@@ -136,10 +134,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             let mut diag = struct_span_err!(\n-                self.tcx.sess, origin.span(), E0271,\n+                self.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`\", predicate\n             );\n-            self.note_type_err(&mut diag, origin, None, values, err);\n+            self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n             self.note_obligation_cause(&mut diag, obligation);\n             diag.emit();\n         });\n@@ -529,7 +527,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.equality_predicate(span,\n+                            let err = self.equality_predicate(&obligation.cause,\n                                                               &predicate).err().unwrap();\n                             struct_span_err!(self.tcx.sess, span, E0278,\n                                 \"the requirement `{}` is not satisfied (`{}`)\",\n@@ -851,7 +849,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let tcx = self.tcx;\n         match *cause_code {\n-            ObligationCauseCode::MiscObligation => { }\n+            ObligationCauseCode::ExprAssignable |\n+            ObligationCauseCode::MatchExpressionArm { .. } |\n+            ObligationCauseCode::IfExpression |\n+            ObligationCauseCode::IfExpressionWithNoElse |\n+            ObligationCauseCode::EquatePredicate |\n+            ObligationCauseCode::MainFunctionType |\n+            ObligationCauseCode::StartFunctionType |\n+            ObligationCauseCode::IntrinsicType |\n+            ObligationCauseCode::MethodReceiver |\n+            ObligationCauseCode::MiscObligation => {\n+            }\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "f406580286da9a5c7555d9c2709c69589c6cf77b", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -154,9 +154,13 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n     pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                       -> Option<Vec<PredicateObligation<'tcx>>> {\n         if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n+            let ty = if def_id.is_local() {\n+                tcx.item_types.borrow().get(&def_id).cloned()\n+            } else {\n+                Some(tcx.item_type(def_id))\n+            };\n             // We can resolve the `impl Trait` to its concrete type.\n-            if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n-                let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n+            if let Some(concrete_ty) = ty.subst(tcx, substs) {\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n                     substs: tcx.mk_substs_trait(concrete_ty, &[])\n@@ -515,11 +519,9 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(InferOk { obligations, .. }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                    Ok(Some(Vec::new()))\n+            match selcx.infcx().equality_predicate(&obligation.cause, binder) {\n+                Ok(InferOk { obligations, value: () }) => {\n+                    Ok(Some(obligations))\n                 },\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }"}, {"sha": "a5fdaed9712573d51c48879ceae8b0780864ce05", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -15,6 +15,7 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use hir;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n@@ -148,6 +149,35 @@ pub enum ObligationCauseCode<'tcx> {\n         trait_item_def_id: DefId,\n         lint_id: Option<ast::NodeId>,\n     },\n+\n+    // Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    // Computing common supertype in the arms of a match expression\n+    MatchExpressionArm { arm_span: Span,\n+                         source: hir::MatchSource },\n+\n+    // Computing common supertype in an if expression\n+    IfExpression,\n+\n+    // Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    // `where a == b`\n+    EquatePredicate,\n+\n+    // `main` has wrong type\n+    MainFunctionType,\n+\n+    // `start` has wrong type\n+    StartFunctionType,\n+\n+    // intrinsic has wrong type\n+    IntrinsicType,\n+\n+    // method receiver\n+    MethodReceiver,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -603,7 +633,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n+            let predicates = tcx.item_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;"}, {"sha": "0681be129b67e9cbd3983ad8202065c2365fa566", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let trait_def = self.lookup_trait_def(trait_def_id);\n         let trait_ref = trait_def.trait_ref.clone();\n         let trait_ref = trait_ref.to_poly_trait_ref();\n-        let predicates = self.lookup_super_predicates(trait_def_id);\n+        let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n             .into_iter()\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n         let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = self.lookup_predicates(def_id);\n+        let predicates = self.item_predicates(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n+        let ref sig = self.item_type(method.def_id).fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.lookup_generics(method.def_id).types.is_empty() {\n+        if !self.item_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "a2d45fa271499a02405732e49f83f364c8fb2b5b", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -24,7 +24,7 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::{InferOk, TypeOrigin};\n+use infer::InferOk;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::parse::token;\n use syntax::ast;\n@@ -209,11 +209,8 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    match infcx.eq_types(true, origin, normalized_ty, obligation.predicate.ty) {\n-        Ok(InferOk { obligations: inferred_obligations, .. }) => {\n-            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n-            assert!(inferred_obligations.is_empty());\n+    match infcx.eq_types(true, &obligation.cause, normalized_ty, obligation.predicate.ty) {\n+        Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n         },\n@@ -311,7 +308,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in trans.\n                 if self.selcx.projection_mode() == Reveal::All {\n-                    let generic_ty = self.tcx().lookup_item_type(def_id).ty;\n+                    let generic_ty = self.tcx().item_type(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                     self.fold_ty(concrete_ty)\n                 } else {\n@@ -809,7 +806,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n+    let trait_predicates = selcx.tcx().item_predicates(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n@@ -840,18 +837,18 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n \n                 let is_match = same_name && infcx.probe(|_| {\n-                    let origin = TypeOrigin::Misc(obligation.cause.span);\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     let obligation_poly_trait_ref =\n                         obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n-                                              origin,\n+                                              obligation.cause.clone(),\n                                               data_poly_trait_ref,\n                                               obligation_poly_trait_ref)\n-                        // FIXME(#32730) once obligations are propagated from unification in\n-                        // inference, drop this assertion\n-                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+                        .map(|InferOk { obligations: _, value: () }| {\n+                            // FIXME(#32730) -- do we need to take obligations\n+                            // into account in any way? At the moment, no.\n+                        })\n                         .is_ok()\n                 });\n \n@@ -943,7 +940,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                         // an error when we confirm the candidate\n                         // (which will ultimately lead to `normalize_to_error`\n                         // being invoked).\n-                        node_item.item.has_value\n+                        node_item.item.defaultness.has_value()\n                     } else {\n                         node_item.item.defaultness.is_default()\n                     };\n@@ -1007,8 +1004,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     // types, which appear not to unify -- so the\n                     // overlap check succeeds, when it should\n                     // fail.\n-                    bug!(\"Tried to project an inherited associated type during \\\n-                          coherence checking, which is currently not supported.\");\n+                    span_bug!(obligation.cause.span,\n+                              \"Tried to project an inherited associated type during \\\n+                               coherence checking, which is currently not supported.\");\n                 };\n                 candidate_set.vec.extend(new_candidate);\n             }\n@@ -1153,12 +1151,11 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n \n         // select those with a relevant trait-ref\n         let mut env_predicates = env_predicates.filter(|data| {\n-            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let data_poly_trait_ref = data.to_poly_trait_ref();\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n             selcx.infcx().probe(|_| {\n                 selcx.infcx().sub_poly_trait_refs(false,\n-                                                  origin,\n+                                                  obligation.cause.clone(),\n                                                   data_poly_trait_ref,\n                                                   obligation_poly_trait_ref).is_ok()\n             })\n@@ -1187,12 +1184,10 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    // FIXME(#32730) drop this assertion once obligations are propagated from inference (fn pointer\n-    // vtable nested obligations ONLY come from unification in inference)\n-    assert!(fn_pointer_vtable.nested.is_empty());\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+        .with_addl_obligations(fn_pointer_vtable.nested)\n }\n \n fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n@@ -1265,12 +1260,10 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+    let cause = obligation.cause.clone();\n     let trait_ref = obligation.predicate.trait_ref;\n-    match infcx.match_poly_projection_predicate(origin, poly_projection, trait_ref) {\n+    match infcx.match_poly_projection_predicate(cause, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n-            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n-            assert!(obligations.is_empty());\n             Progress {\n                 ty: ty_match.value,\n                 obligations: obligations,\n@@ -1303,7 +1296,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     match assoc_ty {\n         Some(node_item) => {\n-            let ty = if !node_item.item.has_value {\n+            let ty = if !node_item.item.defaultness.has_value() {\n                 // This means that the impl is missing a definition for the\n                 // associated type. This error will be reported by the type\n                 // checker method `check_impl_items_against_trait`, so here we\n@@ -1313,7 +1306,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n             } else {\n-                tcx.lookup_item_type(node_item.item.def_id).ty\n+                tcx.item_type(node_item.item.def_id)\n             };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {"}, {"sha": "c25e7ee344f6eb38cebcf3d24a173f9f6d47e89c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -35,7 +35,7 @@ use super::util;\n \n use hir::def_id::DefId;\n use infer;\n-use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeFreshener};\n use ty::subst::{Kind, Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n@@ -418,9 +418,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             None => Ok(None),\n             Some(candidate) => {\n                 let mut candidate = self.confirm_candidate(obligation, candidate)?;\n-                // FIXME(#32730) remove this assertion once inferred obligations are propagated\n-                // from inference\n-                assert!(self.inferred_obligations.len() == 0);\n                 let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n                 candidate.nested_obligations_mut().extend(inferred_obligations);\n                 Ok(Some(candidate))\n@@ -521,7 +518,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.equality_predicate(obligation.cause.span, p) {\n+                match self.infcx.equality_predicate(&obligation.cause, p) {\n                     Ok(InferOk { obligations, .. }) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -1200,7 +1197,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id={:?}, substs={:?}\",\n                def_id, substs);\n \n-        let item_predicates = self.tcx().lookup_predicates(def_id);\n+        let item_predicates = self.tcx().item_predicates(def_id);\n         let bounds = item_predicates.instantiate(self.tcx(), substs);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n@@ -1247,9 +1244,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+        let cause = obligation.cause.clone();\n         match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n+                                             cause,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n@@ -1912,16 +1909,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 tys.to_vec()\n             }\n \n-            ty::TyClosure(_, ref substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME(#27086). We are invariant w/r/t our\n-                // substs.func_substs, but we don't see them as\n+                // func_substs, but we don't see them as\n                 // constituent types; this seems RIGHT but also like\n                 // something that a normal type couldn't simulate. Is\n                 // this just a gap with the way that PhantomData and\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                substs.upvar_tys.to_vec()\n+                substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n@@ -2439,16 +2436,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// selection of the impl. Therefore, if there is a mismatch, we\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n-                               obligation_cause: ObligationCause,\n+                               obligation_cause: ObligationCause<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n-\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx.sub_poly_trait_refs(false,\n-                                       origin,\n+                                       obligation_cause.clone(),\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n@@ -2482,9 +2477,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     builtin_bounds: data_b.builtin_bounds,\n                     projection_bounds: data_a.projection_bounds.clone(),\n                 });\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, new_trait, target)\n+                    self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2553,9 +2547,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, a, b)\n+                    self.infcx.sub_types(false, &obligation.cause, a, b)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2617,9 +2610,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, new_struct, target)\n+                    self.infcx.sub_types(false, &obligation.cause, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2705,10 +2697,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                impl_trait_ref,\n                skol_obligation_trait_ref);\n \n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         let InferOk { obligations, .. } =\n             self.infcx.eq_trait_refs(false,\n-                                     origin,\n+                                     &obligation.cause,\n                                      impl_trait_ref.value.clone(),\n                                      skol_obligation_trait_ref)\n             .map_err(|e| {\n@@ -2780,9 +2771,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligation,\n                poly_trait_ref);\n \n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         self.infcx.sub_poly_trait_refs(false,\n-                                       origin,\n+                                       obligation.cause.clone(),\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n@@ -2884,7 +2874,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.lookup_predicates(def_id);\n+        let predicates = tcx.item_predicates(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,"}, {"sha": "870494363c85a8371385495c39c34d487fee04ec", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -22,7 +22,7 @@ use super::util::impl_trait_ref_and_oblig;\n \n use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, TypeOrigin};\n+use infer::{InferCtxt, InferOk};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n@@ -223,8 +223,10 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                                    target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.eq_trait_refs(true, TypeOrigin::Misc(DUMMY_SP), source_trait_ref,\n-                                                                target_trait_ref) {\n+    match infcx.eq_trait_refs(true,\n+                              &ObligationCause::dummy(),\n+                              source_trait_ref,\n+                              target_trait_ref) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty())"}, {"sha": "d03ba5b0a31f1314e979b1c824638c9a1430538f", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -213,6 +213,34 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                     lint_id: lint_id,\n                 })\n             }\n+            super::ExprAssignable => {\n+                Some(super::ExprAssignable)\n+            }\n+            super::MatchExpressionArm { arm_span, source } => {\n+                Some(super::MatchExpressionArm { arm_span: arm_span,\n+                                                 source: source })\n+            }\n+            super::IfExpression => {\n+                Some(super::IfExpression)\n+            }\n+            super::IfExpressionWithNoElse => {\n+                Some(super::IfExpressionWithNoElse)\n+            }\n+            super::EquatePredicate => {\n+                Some(super::EquatePredicate)\n+            }\n+            super::MainFunctionType => {\n+                Some(super::MainFunctionType)\n+            }\n+            super::StartFunctionType => {\n+                Some(super::StartFunctionType)\n+            }\n+            super::IntrinsicType => {\n+                Some(super::IntrinsicType)\n+            }\n+            super::MethodReceiver => {\n+                Some(super::MethodReceiver)\n+            }\n         }\n     }\n }\n@@ -461,6 +489,15 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n+            super::ExprAssignable |\n+            super::MatchExpressionArm { arm_span: _, source: _ } |\n+            super::IfExpression |\n+            super::IfExpressionWithNoElse |\n+            super::EquatePredicate |\n+            super::MainFunctionType |\n+            super::StartFunctionType |\n+            super::IntrinsicType |\n+            super::MethodReceiver |\n             super::MiscObligation |\n             super::SliceOrArrayElem |\n             super::TupleElem |\n@@ -497,6 +534,15 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n+            super::ExprAssignable |\n+            super::MatchExpressionArm { arm_span: _, source: _ } |\n+            super::IfExpression |\n+            super::IfExpressionWithNoElse |\n+            super::EquatePredicate |\n+            super::MainFunctionType |\n+            super::StartFunctionType |\n+            super::IntrinsicType |\n+            super::MethodReceiver |\n             super::MiscObligation |\n             super::SliceOrArrayElem |\n             super::TupleElem |"}, {"sha": "b94597d475927e61bc36adca97d867fea11da994", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -128,7 +128,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = tcx.lookup_super_predicates(data.def_id());\n+                let predicates = tcx.item_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -295,7 +295,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = self.tcx.lookup_super_predicates(def_id);\n+        let predicates = self.tcx.item_super_predicates(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -362,7 +362,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n+    let predicates = selcx.tcx().item_predicates(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, ObligationCause::dummy(), &predicates);"}, {"sha": "9f80c2487fb2cca52651b36a9d0acad719e0f3ff", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -98,10 +98,11 @@ impl TypeContents {\n         TC::OwnsOwned | (*self & TC::OwnsAll)\n     }\n \n-    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n-        F: FnMut(&T) -> TypeContents,\n+    pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n+        I: IntoIterator<Item=T>,\n+        F: FnMut(T) -> TypeContents,\n     {\n-        v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n+        v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n \n     pub fn has_dtor(&self) -> bool {\n@@ -215,8 +216,10 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 }\n                 ty::TyStr => TC::None,\n \n-                ty::TyClosure(_, ref substs) => {\n-                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(tcx, &ty, cache))\n+                ty::TyClosure(def_id, ref substs) => {\n+                    TypeContents::union(\n+                        substs.upvar_tys(def_id, tcx),\n+                        |ty| tc_ty(tcx, &ty, cache))\n                 }\n \n                 ty::TyTuple(ref tys) => {"}, {"sha": "45450456e8a6583e1b9e93861df9b1c627ce6103", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -444,7 +444,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub maybe_unused_trait_imports: NodeSet,\n \n     // Records the type of every item.\n-    pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n+    pub item_types: RefCell<DepTrackingMap<maps::Types<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -665,10 +665,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n-        self.tables.borrow_mut().node_types.insert(id, ty);\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n                           -> &'gcx ty::Generics<'gcx> {\n         self.global_interners.arenas.generics.alloc(generics)\n@@ -815,7 +811,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n-            tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n             associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -1450,12 +1446,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n-                      substs: &'tcx Substs<'tcx>,\n-                      tys: &[Ty<'tcx>])\n+                      substs: &'tcx Substs<'tcx>)\n                       -> Ty<'tcx> {\n         self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n-            func_substs: substs,\n-            upvar_tys: self.intern_type_list(tys)\n+            substs: substs\n         })\n     }\n \n@@ -1578,4 +1572,3 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n         Ok(f(&iter.collect::<Result<AccumulateVec<[_; 8]>, _>>()?))\n     }\n }\n-"}, {"sha": "2c09b89beb2322a8f972235f0b9835fca6addff7", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -88,8 +88,7 @@ impl FlagComputation {\n             &ty::TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                self.add_substs(&substs.func_substs);\n-                self.add_tys(&substs.upvar_tys);\n+                self.add_substs(&substs.substs);\n             }\n \n             &ty::TyInfer(infer) => {"}, {"sha": "8222583d9a7da8162e232ac5e269d05033fe3ce5", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.lookup_item_type(impl_def_id).ty;\n+        let self_ty = self.item_type(impl_def_id);\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),"}, {"sha": "5ee1c3678d675df1aba5a4567112dd7a986b40ee", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -631,7 +631,9 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             // Perhaps one of the upvars of this closure is non-zero\n             // Let's recurse and find out!\n-            (_, &ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. })) |\n+            (_, &ty::TyClosure(def_id, ref substs)) => {\n+                Struct::non_zero_field_path(infcx, substs.upvar_tys(def_id, tcx))\n+            }\n             // Can we use one of the fields in this tuple?\n             (_, &ty::TyTuple(tys)) => {\n                 Struct::non_zero_field_path(infcx, tys.iter().cloned())\n@@ -961,7 +963,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // Tuples and closures.\n-            ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+            ty::TyClosure(def_id, ref substs) => {\n+                let mut st = Struct::new(dl, false);\n+                let tys = substs.upvar_tys(def_id, tcx);\n+                st.extend(dl, tys.map(|ty| ty.layout(infcx)), ty)?;\n+                Univariant { variant: st, non_zero: false }\n+            }\n+\n             ty::TyTuple(tys) => {\n                 let mut st = Struct::new(dl, false);\n                 st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;"}, {"sha": "bf0445858794e3ec2f4fd0a09d3afc805d484af1", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -33,7 +33,7 @@ macro_rules! dep_map_ty {\n }\n \n dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n-dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n+dep_map_ty! { Types: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }"}, {"sha": "f5c23401a4e679785a31547ba91d9f9c3f4ffcba", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 127, "deletions": 143, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -50,7 +50,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use hir;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds};\n@@ -169,9 +169,9 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n-            self_ty: tcx.lookup_item_type(impl_def_id).ty,\n+            self_ty: tcx.item_type(impl_def_id),\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id).predicates\n+            predicates: tcx.item_predicates(impl_def_id).predicates\n         }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n@@ -189,7 +189,6 @@ pub struct AssociatedItem {\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n-    pub has_value: bool,\n     pub container: AssociatedItemContainer,\n \n     /// Whether this is a method with an explicit self\n@@ -708,7 +707,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n                         substs: &Substs<'tcx>) {\n         if let Some(def_id) = self.parent {\n-            tcx.lookup_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n+            tcx.item_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n@@ -1301,31 +1300,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-/// A \"type scheme\", in ML terminology, is a type combined with some\n-/// set of generic types that the type is, well, generic over. In Rust\n-/// terms, it is the \"type\" of a fn item or struct -- this type will\n-/// include various generic parameters that must be substituted when\n-/// the item/struct is referenced. That is called converting the type\n-/// scheme to a monotype.\n-///\n-/// - `generics`: the set of type parameters and their bounds\n-/// - `ty`: the base types, which may reference the parameters defined\n-///   in `generics`\n-///\n-/// Note that TypeSchemes are also sometimes called \"polytypes\" (and\n-/// in fact this struct used to carry that name, so you may find some\n-/// stray references in a comment or something). We try to reserve the\n-/// \"poly\" prefix to refer to higher-ranked things, as in\n-/// `PolyTraitRef`.\n-///\n-/// Note that each item also comes with predicates, see\n-/// `lookup_predicates`.\n-#[derive(Clone, Debug)]\n-pub struct TypeScheme<'tcx> {\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub ty: Ty<'tcx>,\n-}\n-\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n@@ -1359,8 +1333,6 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n-    /// The field's DefId. NOTE: the fields of tuple-like enum variants\n-    /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n@@ -1541,14 +1513,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         &self.variants[0]\n     }\n \n-    #[inline]\n-    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeScheme<'gcx> {\n-        tcx.lookup_item_type(self.did)\n-    }\n-\n     #[inline]\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n-        tcx.lookup_predicates(self.did)\n+        tcx.item_predicates(self.did)\n     }\n \n     /// Returns an iterator over all fields contained\n@@ -1784,7 +1751,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = tcx.lookup_predicates(self.did).predicates;\n+                let predicates = tcx.item_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n                     vec![]\n                 } else {\n@@ -1963,7 +1930,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.types`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2104,7 +2071,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n         self.associated_items(id)\n-            .filter(|item| item.kind == AssociatedKind::Method && item.has_value)\n+            .filter(|item| item.kind == AssociatedKind::Method && item.defaultness.has_value())\n             .collect()\n     }\n \n@@ -2145,69 +2112,109 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                            .expect(\"missing AssociatedItem in metadata\");\n             }\n \n+            // When the user asks for a given associated item, we\n+            // always go ahead and convert all the associated items in\n+            // the container. Note that we are also careful only to\n+            // ever register a read on the *container* of the assoc\n+            // item, not the assoc item itself. This prevents changes\n+            // in the details of an item (for example, the type to\n+            // which an associated type is bound) from contaminating\n+            // those tasks that just need to scan the names of items\n+            // and so forth.\n+\n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let parent_id = self.map.get_parent(id);\n             let parent_def_id = self.map.local_def_id(parent_id);\n-            match self.map.get(id) {\n-                ast_map::NodeTraitItem(trait_item) => {\n-                    let (kind, has_self, has_value) = match trait_item.node {\n-                        hir::MethodTraitItem(ref sig, ref body) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n-                             body.is_some())\n-                        }\n-                        hir::ConstTraitItem(_, ref value) => {\n-                            (AssociatedKind::Const, false, value.is_some())\n-                        }\n-                        hir::TypeTraitItem(_, ref ty) => {\n-                            (AssociatedKind::Type, false, ty.is_some())\n-                        }\n-                    };\n-\n-                    AssociatedItem {\n-                        name: trait_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n-                        defaultness: hir::Defaultness::Default,\n-                        has_value: has_value,\n-                        def_id: def_id,\n-                        container: TraitContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+            let parent_item = self.map.expect_item(parent_id);\n+            match parent_item.node {\n+                hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n+                    for impl_item_ref in impl_item_refs {\n+                        let assoc_item =\n+                            self.associated_item_from_impl_item_ref(parent_def_id,\n+                                                                    impl_trait_ref.is_some(),\n+                                                                    impl_item_ref);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                ast_map::NodeImplItem(impl_item) => {\n-                    let (kind, has_self) = match impl_item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n-                        }\n-                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n-                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n-                    };\n-\n-                    // Trait impl items are always public.\n-                    let public = hir::Public;\n-                    let parent_item = self.map.expect_item(parent_id);\n-                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n-                        &public\n-                    } else {\n-                        &impl_item.vis\n-                    };\n-\n-                    AssociatedItem {\n-                        name: impl_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(vis, id, self),\n-                        defaultness: impl_item.defaultness,\n-                        has_value: true,\n-                        def_id: def_id,\n-                        container: ImplContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    for trait_item in trait_items {\n+                        let assoc_item =\n+                            self.associated_item_from_trait_item_ref(parent_def_id, trait_item);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+\n+                ref r => {\n+                    panic!(\"unexpected container of associated items: {:?}\", r)\n+                }\n             }\n+\n+            // memoize wants us to return something, so return\n+            // the one we generated for this def-id\n+            *self.associated_items.borrow().get(&def_id).unwrap()\n         })\n     }\n \n+    fn associated_item_from_trait_item_ref(self,\n+                                           parent_def_id: DefId,\n+                                           trait_item: &hir::TraitItem)\n+                                           -> AssociatedItem {\n+        let def_id = self.map.local_def_id(trait_item.id);\n+\n+        let (kind, has_self, has_value) = match trait_item.node {\n+            hir::MethodTraitItem(ref sig, ref body) => {\n+                (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                 body.is_some())\n+            }\n+            hir::ConstTraitItem(_, ref value) => {\n+                (AssociatedKind::Const, false, value.is_some())\n+            }\n+            hir::TypeTraitItem(_, ref ty) => {\n+                (AssociatedKind::Type, false, ty.is_some())\n+            }\n+        };\n+\n+        AssociatedItem {\n+            name: trait_item.name,\n+            kind: kind,\n+            vis: Visibility::from_hir(&hir::Inherited, trait_item.id, self),\n+            defaultness: hir::Defaultness::Default { has_value: has_value },\n+            def_id: def_id,\n+            container: TraitContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n+    fn associated_item_from_impl_item_ref(self,\n+                                          parent_def_id: DefId,\n+                                          from_trait_impl: bool,\n+                                          impl_item_ref: &hir::ImplItemRef)\n+                                          -> AssociatedItem {\n+        let def_id = self.map.local_def_id(impl_item_ref.id.node_id);\n+        let (kind, has_self) = match impl_item_ref.kind {\n+            hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                (ty::AssociatedKind::Method, has_self)\n+            }\n+            hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n+        };\n+\n+        // Trait impl items are always public.\n+        let public = hir::Public;\n+        let vis = if from_trait_impl { &public } else { &impl_item_ref.vis };\n+\n+        ty::AssociatedItem {\n+            name: impl_item_ref.name,\n+            kind: kind,\n+            vis: ty::Visibility::from_hir(vis, impl_item_ref.id.node_id, self),\n+            defaultness: impl_item_ref.defaultness,\n+            def_id: def_id,\n+            container: ImplContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n         self.associated_item_def_ids.memoize(def_id, || {\n             if !def_id.is_local() {\n@@ -2216,19 +2223,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let item = self.map.expect_item(id);\n-            match item.node {\n+            let vec: Vec<_> = match item.node {\n                 hir::ItemTrait(.., ref trait_items) => {\n-                    Rc::new(trait_items.iter().map(|trait_item| {\n-                        self.map.local_def_id(trait_item.id)\n-                    }).collect())\n+                    trait_items.iter()\n+                               .map(|trait_item| trait_item.id)\n+                               .map(|id| self.map.local_def_id(id))\n+                               .collect()\n                 }\n-                hir::ItemImpl(.., ref impl_items) => {\n-                    Rc::new(impl_items.iter().map(|impl_item| {\n-                        self.map.local_def_id(impl_item.id)\n-                    }).collect())\n+                hir::ItemImpl(.., ref impl_item_refs) => {\n+                    impl_item_refs.iter()\n+                                  .map(|impl_item_ref| impl_item_ref.id)\n+                                  .map(|id| self.map.local_def_id(id.node_id))\n+                                  .collect()\n                 }\n                 _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n-            }\n+            };\n+            Rc::new(vec)\n         })\n     }\n \n@@ -2351,38 +2361,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Register a given item type\n-    pub fn register_item_type(self, did: DefId, scheme: TypeScheme<'gcx>) {\n-        self.tcache.borrow_mut().insert(did, scheme.ty);\n-        self.generics.borrow_mut().insert(did, scheme.generics);\n-    }\n-\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n-        let ty = lookup_locally_or_in_crate_store(\n-            \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self.global_tcx(), did));\n-\n-        TypeScheme {\n-            ty: ty,\n-            generics: self.lookup_generics(did)\n-        }\n-    }\n-\n-    pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n-        if did.krate != LOCAL_CRATE {\n-            return Some(self.lookup_item_type(did));\n-        }\n-\n-        if let Some(ty) = self.tcache.borrow().get(&did).cloned() {\n-            Some(TypeScheme {\n-                ty: ty,\n-                generics: self.lookup_generics(did)\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"item_types\", did, &self.item_types,\n+            || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n@@ -2411,21 +2395,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of an item, returns its generics.\n-    pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n+    pub fn item_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n             || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n             || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n@@ -2602,12 +2586,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n         if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n-            return ty.subst(self, substs.func_substs);\n+            return ty.subst(self, substs.substs);\n         }\n \n         let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n         self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n-        ty.subst(self, substs.func_substs)\n+        ty.subst(self, substs.substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2718,7 +2702,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.lookup_predicates(def_id);\n+        let generic_predicates = tcx.item_predicates(def_id);\n         let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates;\n@@ -2753,12 +2737,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn visit_all_items_in_krate<V,F>(self,\n-                                         dep_node_fn: F,\n-                                         visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'gcx>\n+    pub fn visit_all_item_likes_in_krate<V,F>(self,\n+                                              dep_node_fn: F,\n+                                              visitor: &mut V)\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'gcx>\n     {\n-        dep_graph::visit_all_items_in_krate(self.global_tcx(), dep_node_fn, visitor);\n+        dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "e3d13f593954f6ee8ba39356cecdda23e22d5e1c", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // in the `subtys` iterator (e.g., when encountering a\n         // projection).\n         match ty.sty {\n-            ty::TyClosure(_, ref substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME(#27086). We do not accumulate from substs, since they\n                 // don't represent reachable data. This means that, in\n                 // practice, some of the lifetime parameters might not\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // what func/type parameters are used and unused,\n                 // taking into consideration UFCS and so forth.\n \n-                for &upvar_ty in substs.upvar_tys {\n+                for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n             }"}, {"sha": "2a01bad33c52e398a7a49b349cfaeb99e5c810a4", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -534,13 +534,8 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n                            -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n-        assert_eq!(a.upvar_tys.len(), b.upvar_tys.len());\n-        Ok(ty::ClosureSubsts {\n-            func_substs: substs,\n-            upvar_tys: relation.tcx().mk_type_list(\n-                a.upvar_tys.iter().zip(b.upvar_tys).map(|(a, b)| relation.relate(a, b)))?\n-        })\n+        let substs = relate_substs(relation, None, a.substs, b.substs)?;\n+        Ok(ty::ClosureSubsts { substs: substs })\n     }\n }\n "}, {"sha": "e73be23a42c76d068416337e3ef2cd89e8d0f8b3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -198,11 +198,8 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.func_substs, self.upvar_tys)).map(|(substs, upvar_tys)| {\n-            ty::ClosureSubsts {\n-                func_substs: substs,\n-                upvar_tys: upvar_tys\n-            }\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::ClosureSubsts { substs: substs }\n         })\n     }\n }\n@@ -482,7 +479,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever => self.sty.clone(),\n+            ty::TyParam(..) | ty::TyNever => return self\n         };\n         folder.tcx().mk_ty(sty)\n     }\n@@ -654,13 +651,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {\n-            func_substs: self.func_substs.fold_with(folder),\n-            upvar_tys: self.upvar_tys.fold_with(folder),\n+            substs: self.substs.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.func_substs.visit_with(visitor) || self.upvar_tys.visit_with(visitor)\n+        self.substs.visit_with(visitor)\n     }\n }\n "}, {"sha": "56466d596829804ecb89bc77c2355979b0a2d13e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,6 +11,7 @@\n //! This module contains TypeVariants and its major components\n \n use hir::def_id::DefId;\n+\n use middle::region;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -164,7 +165,7 @@ pub enum TypeVariants<'tcx> {\n     /// Anonymized (`impl Trait`) type found in a return type.\n     /// The DefId comes from the `impl Trait` ast::Ty node, and the\n     /// substitutions are for the generics of the function in question.\n-    /// After typeck, the concrete type can be found in the `tcache` map.\n+    /// After typeck, the concrete type can be found in the `types` map.\n     TyAnon(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n@@ -254,15 +255,23 @@ pub enum TypeVariants<'tcx> {\n /// handle). Plus it fixes an ICE. :P\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n-    /// Lifetime and type parameters from the enclosing function.\n+    /// Lifetime and type parameters from the enclosing function,\n+    /// concatenated with the types of the upvars.\n+    ///\n     /// These are separated out because trans wants to pass them around\n     /// when monomorphizing.\n-    pub func_substs: &'tcx Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n \n-    /// The types of the upvars. The list parallels the freevars and\n-    /// `upvar_borrows` lists. These are kept distinct so that we can\n-    /// easily index into them.\n-    pub upvar_tys: &'tcx Slice<Ty<'tcx>>\n+impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n+    #[inline]\n+    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'acx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let generics = tcx.item_generics(def_id);\n+        self.substs[self.substs.len()-generics.own_count()..].iter().map(\n+            |t| t.as_type().expect(\"unexpected region in upvars\"))\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -556,7 +565,7 @@ pub struct DebruijnIndex {\n ///\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are 2 kind of\n-/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// bound regions: early-bound, which are bound in an item's Generics,\n /// and are substituted by a Substs,  and late-bound, which are part of\n /// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n@@ -1234,7 +1243,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions().collect()\n+                substs.substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n                 data.trait_ref.substs.regions().collect()"}, {"sha": "41fcb09fb2dc7ef2c3eb324e7679900b1122d0fd", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -177,12 +177,28 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n-        let defs = tcx.lookup_generics(def_id);\n+        let defs = tcx.item_generics(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n         tcx.intern_substs(&substs)\n     }\n \n+    pub fn extend_to<FR, FT>(&self,\n+                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             def_id: DefId,\n+                             mut mk_region: FR,\n+                             mut mk_type: FT)\n+                             -> &'tcx Substs<'tcx>\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx>\n+    {\n+        let defs = tcx.item_generics(def_id);\n+        let mut result = Vec::with_capacity(defs.count());\n+        result.extend(self[..].iter().cloned());\n+        Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n+        tcx.intern_substs(&result)\n+    }\n+\n     fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n@@ -192,10 +208,18 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n-            let parent_defs = tcx.lookup_generics(def_id);\n+            let parent_defs = tcx.item_generics(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n+        Substs::fill_single(substs, defs, mk_region, mk_type)\n+    }\n \n+    fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+                           defs: &ty::Generics<'tcx>,\n+                           mk_region: &mut FR,\n+                           mk_type: &mut FT)\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n@@ -271,9 +295,14 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n-        let defs = tcx.lookup_generics(source_ancestor);\n+        let defs = tcx.item_generics(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n+\n+    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics<'tcx>)\n+                       -> &'tcx Substs<'tcx> {\n+        tcx.mk_substs(self.iter().take(generics.count()).cloned())\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n@@ -519,7 +548,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        trait_id: DefId,\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n-        let defs = tcx.lookup_generics(trait_id);\n+        let defs = tcx.item_generics(trait_id);\n \n         ty::TraitRef {\n             def_id: trait_id,"}, {"sha": "fd81065e61d499f3590272c152ac8f5ad7dbec44", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,7 +18,7 @@ use std::cell::{Cell, RefCell};\n use hir;\n use util::nodemap::FxHashMap;\n \n-/// As `TypeScheme` but for a trait ref.\n+/// A trait's definition with type information.\n pub struct TraitDef<'tcx> {\n     pub unsafety: hir::Unsafety,\n "}, {"sha": "7d3e380a3b59076ef5a10bb7a841336171f62a35", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,6 +11,7 @@\n //! misc. type-system utilities too small to deserve their own file\n \n use hir::def_id::DefId;\n+use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n use hir::pat_util;\n@@ -390,6 +391,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n         return !self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\");\n     }\n+\n+    pub fn closure_base_def_id(&self, def_id: DefId) -> DefId {\n+        let mut def_id = def_id;\n+        while self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n+            def_id = self.parent_def_id(def_id).unwrap_or_else(|| {\n+                bug!(\"closure {:?} has no parent\", def_id);\n+            });\n+        }\n+        def_id\n+    }\n }\n \n /// When hashing a type this ends up affecting properties like symbol names. We"}, {"sha": "a6ecfd2fb70668405327f35d7ba2eb6064bc7d35", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -97,8 +97,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {\n-            stack.extend(substs.func_substs.types().rev());\n-            stack.extend(substs.upvar_tys.iter().cloned().rev());\n+            stack.extend(substs.substs.types().rev());\n         }\n         ty::TyTuple(ts) => {\n             stack.extend(ts.iter().cloned().rev());"}, {"sha": "74c6d7d334c357747c062e027a135683fc1b46d5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {\n         let predicates =\n-            self.infcx.tcx.lookup_predicates(def_id)\n+            self.infcx.tcx.item_predicates(def_id)\n                           .instantiate(self.infcx.tcx, substs);\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates"}, {"sha": "a63c7ba6a25ce9fd093ac59754e692372e2c66c9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -105,7 +105,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                 }\n             }\n         }\n-        let mut generics = tcx.lookup_generics(item_def_id);\n+        let mut generics = tcx.item_generics(item_def_id);\n         let mut path_def_id = did;\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n@@ -115,7 +115,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             // Methods.\n             assert!(is_value_path);\n             child_types = generics.types.len();\n-            generics = tcx.lookup_generics(def_id);\n+            generics = tcx.item_generics(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n@@ -865,7 +865,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n-                          !tcx.tcache.borrow().contains_key(&def.did) {\n+                          !tcx.item_types.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n                         parameterized(f, substs, def.did, &[])\n@@ -878,7 +878,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let item_predicates = tcx.lookup_predicates(def_id);\n+                    let item_predicates = tcx.item_predicates(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n                         tcx.intern_substs(&[])\n                     });\n@@ -907,13 +907,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             }\n             TyStr => write!(f, \"str\"),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                let upvar_tys = substs.upvar_tys(did, tcx);\n                 write!(f, \"[closure\")?;\n \n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                             let def_id = freevar.def.def_id();\n                             let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n                             write!(f,\n@@ -930,7 +931,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     // visible in trans bug reports, I imagine.\n                     write!(f, \"@{:?}\", did)?;\n                     let mut sep = \" \";\n-                    for (index, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n                         write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n                         sep = \", \";\n                     }"}, {"sha": "37216e20762d4970754319718206dcb94899f2b1", "filename": "src/librustc_back/target/armv5te_unknown_linux_gnueabi.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_base::opts();\n+    Ok(Target {\n+        llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+\n+        options: TargetOptions {\n+            features: \"+soft-float\".to_string(),\n+            // No atomic instructions on ARMv5\n+            max_atomic_width: Some(0),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        }\n+    })\n+}\n+"}, {"sha": "18cca425a32c8c43452f34f304d3c8cc5cf4bbf3", "filename": "src/librustc_back/target/linux_musl_base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n     // Make sure that the linker/gcc really don't pull in anything, including\n     // default objects, libs, etc.\n     base.pre_link_args.push(\"-nostdlib\".to_string());\n-    base.pre_link_args.push(\"-static\".to_string());\n \n     // At least when this was tested, the linker would not add the\n     // `GNU_EH_FRAME` program header to executables generated, which is required\n@@ -67,5 +66,8 @@ pub fn opts() -> TargetOptions {\n     base.has_rpath = false;\n     base.position_independent_executables = false;\n \n+    // These targets statically link libc by default\n+    base.crt_static_default = true;\n+\n     base\n }"}, {"sha": "f195ccb3f42928f91473db3ae4131c219a105953", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -145,6 +145,7 @@ supported_targets! {\n     (\"arm-unknown-linux-gnueabihf\", arm_unknown_linux_gnueabihf),\n     (\"arm-unknown-linux-musleabi\", arm_unknown_linux_musleabi),\n     (\"arm-unknown-linux-musleabihf\", arm_unknown_linux_musleabihf),\n+    (\"armv5te-unknown-linux-gnueabi\", armv5te_unknown_linux_gnueabi),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n@@ -358,6 +359,11 @@ pub struct TargetOptions {\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n \n+    // LLVM can't produce object files for this target. Instead, we'll make LLVM\n+    // emit assembly and then use `gcc` to turn that assembly into an object\n+    // file\n+    pub no_integrated_as: bool,\n+\n     /// Don't use this field; instead use the `.max_atomic_width()` method.\n     pub max_atomic_width: Option<u64>,\n \n@@ -367,6 +373,9 @@ pub struct TargetOptions {\n     /// A blacklist of ABIs unsupported by the current target. Note that generic\n     /// ABIs are considered to be supported on all platforms and cannot be blacklisted.\n     pub abi_blacklist: Vec<Abi>,\n+\n+    /// Whether or not the CRT is statically linked by default.\n+    pub crt_static_default: bool,\n }\n \n impl Default for TargetOptions {\n@@ -415,9 +424,11 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n+            no_integrated_as: false,\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n+            crt_static_default: false,\n         }\n     }\n }\n@@ -575,8 +586,10 @@ impl Target {\n         key!(exe_allocation_crate);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n+        key!(no_integrated_as, bool);\n         key!(max_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n+        key!(crt_static_default, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -734,8 +747,10 @@ impl ToJson for Target {\n         target_option_val!(exe_allocation_crate);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n+        target_option_val!(no_integrated_as);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n+        target_option_val!(crt_static_default);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "8461f6d061a5577f7505369459cbc7f16b5aa754", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -88,7 +88,7 @@ pub trait MirWithFlowState<'tcx> {\n }\n \n impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where 'a, 'tcx: 'a, BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n+    where 'tcx: 'a, BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n {\n     type BD = BD;\n     fn node_id(&self) -> NodeId { self.node_id }"}, {"sha": "cdb19d164bf290d94432f7ec9e278121a39a3944", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -709,9 +709,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty::TyAdt(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n             }\n-            ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n-                upvar_tys: tys, ..\n-            }) => {\n+            ty::TyClosure(def_id, substs) => {\n+                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n+                self.open_drop_for_tuple(c, &tys)\n+            }\n+            ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(c, tys)\n             }\n             ty::TyBox(ty) => {\n@@ -858,7 +860,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n+        let fty = tcx.item_type(free_func).subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {\n             statements: statements,"}, {"sha": "5e54e333bb90ce469a431a8bf659388c6aa2a03a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -110,7 +110,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         }\n     };\n \n-    tcx.visit_all_items_in_krate(DepNode::BorrowCheck, &mut bccx);\n+    tcx.visit_all_item_likes_in_krate(DepNode::BorrowCheck, &mut bccx.as_deep_visitor());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n@@ -993,27 +993,34 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let Categorization::Local(local_id) = err.cmt.cat {\n                             let span = self.tcx.map.span(local_id);\n                             if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                                if snippet.starts_with(\"ref \") {\n-                                    db.span_label(span,\n-                                        &format!(\"use `{}` here to make mutable\",\n-                                            snippet.replace(\"ref \", \"ref mut \")));\n-                                } else if snippet != \"self\" {\n-                                    db.span_label(span,\n-                                        &format!(\"use `mut {}` here to make mutable\", snippet));\n+                                if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n+                                    db.span_label(error_span, &format!(\"cannot reborrow mutably\"));\n+                                    db.span_label(error_span, &format!(\"try removing `&mut` here\"));\n+                                } else {\n+                                    if snippet.starts_with(\"ref \") {\n+                                        db.span_label(span,\n+                                            &format!(\"use `{}` here to make mutable\",\n+                                                snippet.replace(\"ref \", \"ref mut \")));\n+                                    } else if snippet != \"self\" {\n+                                        db.span_label(span,\n+                                            &format!(\"use `mut {}` here to make mutable\", snippet));\n+                                    }\n+                                    db.span_label(error_span, &format!(\"cannot borrow mutably\"));\n                                 }\n+                            } else {\n+                                db.span_label(error_span, &format!(\"cannot borrow mutably\"));\n                             }\n-                            db.span_label(error_span, &format!(\"cannot borrow mutably\"));\n                         }\n                     }\n                 }\n             }\n \n             err_out_of_scope(super_scope, sub_scope, cause) => {\n-                let (value_kind, value_msg, is_temporary) = match err.cmt.cat {\n+                let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(_) =>\n-                        (\"temporary value\", \"temporary value created here\", true),\n+                        (\"temporary value\", \"temporary value created here\"),\n                     _ =>\n-                        (\"borrowed value\", \"does not live long enough\", false)\n+                        (\"borrowed value\", \"borrow occurs here\")\n                 };\n \n                 let is_closure = match cause {\n@@ -1026,14 +1033,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             Some(primary) => {\n                                 db.span = MultiSpan::from_span(s);\n                                 db.span_label(primary, &format!(\"capture occurs here\"));\n-                                db.span_label(s, &value_msg);\n+                                db.span_label(s, &\"does not live long enough\");\n                                 true\n                             }\n                             None => false\n                         }\n                     }\n                     _ => {\n-                        db.span_label(error_span, &value_msg);\n+                        db.span_label(error_span, &\"does not live long enough\");\n                         false\n                     }\n                 };\n@@ -1043,11 +1050,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 match (sub_span, super_span) {\n                     (Some(s1), Some(s2)) if s1 == s2 => {\n-                        if !is_temporary && !is_closure {\n+                        if !is_closure {\n                             db.span = MultiSpan::from_span(s1);\n-                            db.span_label(error_span, &format!(\"borrow occurs here\"));\n+                            db.span_label(error_span, &value_msg);\n                             let msg = match opt_loan_path(&err.cmt) {\n-                                None => \"borrowed value\".to_string(),\n+                                None => value_kind.to_string(),\n                                 Some(lp) => {\n                                     format!(\"`{}`\", self.loan_path_to_string(&lp))\n                                 }\n@@ -1060,17 +1067,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         db.note(\"values in a scope are dropped in the opposite order \\\n                                 they are created\");\n                     }\n-                    (Some(s1), Some(s2)) if !is_temporary && !is_closure => {\n+                    (Some(s1), Some(s2)) if !is_closure => {\n                         db.span = MultiSpan::from_span(s2);\n-                        db.span_label(error_span, &format!(\"borrow occurs here\"));\n+                        db.span_label(error_span, &value_msg);\n                         let msg = match opt_loan_path(&err.cmt) {\n-                            None => \"borrowed value\".to_string(),\n+                            None => value_kind.to_string(),\n                             Some(lp) => {\n                                 format!(\"`{}`\", self.loan_path_to_string(&lp))\n                             }\n                         };\n-                        db.span_label(s2,\n-                                      &format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s2, &format!(\"{} dropped here while still borrowed\", msg));\n                         db.span_label(s1, &format!(\"{} needs to live until here\", value_kind));\n                     }\n                     _ => {"}, {"sha": "f63a27e0d7563fd5df3af52c4d8000f7de7c1c48", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -78,7 +78,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut OuterVisitor { tcx: tcx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::MatchCheck,\n+                                      &mut OuterVisitor { tcx: tcx }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "83b0d9dec6d904c087a7f16ec18404a6006b267d", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -40,7 +40,9 @@ Ensure the ordering of the match arm is correct and remove any superfluous\n arms.\n \"##,\n \n-/*E0002: r##\"\n+E0002: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n This error indicates that an empty match expression is invalid because the type\n it is matching on is non-empty (there exist values of this type). In safe code\n it is impossible to create an instance of an empty type, so empty match\n@@ -68,10 +70,11 @@ fn foo(x: Option<String>) {\n     }\n }\n ```\n-\"##,*/\n+\"##,\n \n+E0003: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n \n-/*E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. So, the following will not compile:\n \n@@ -98,7 +101,6 @@ match number {\n }\n ```\n \"##,\n-*/\n \n E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for"}, {"sha": "937cb3f600746cc7ace32a3cce6c5546858fa489", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 152, "deletions": 6, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,22 +11,68 @@\n //! A vector type intended to be used for collecting from iterators onto the stack.\n //!\n //! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n-//! used to store the values on the heap. This type does not support re-allocating onto the heap,\n-//! and there is no way to push more elements onto the existing storage.\n+//! used to store the values on the heap.\n //!\n //! The N above is determined by Array's implementor, by way of an associatated constant.\n \n-use std::ops::Deref;\n-use std::iter::{IntoIterator, FromIterator};\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{self, IntoIterator, FromIterator};\n+use std::slice;\n+use std::vec;\n \n-use array_vec::{Array, ArrayVec};\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n-#[derive(Debug)]\n+use array_vec::{self, Array, ArrayVec};\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n pub enum AccumulateVec<A: Array> {\n     Array(ArrayVec<A>),\n     Heap(Vec<A::Element>)\n }\n \n+impl<A> Clone for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => AccumulateVec::Array(arr.clone()),\n+            AccumulateVec::Heap(ref vec) => AccumulateVec::Heap(vec.clone()),\n+        }\n+    }\n+}\n+\n+impl<A: Array> AccumulateVec<A> {\n+    pub fn new() -> AccumulateVec<A> {\n+        AccumulateVec::Array(ArrayVec::new())\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        iter::once(el).collect()\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(iter: I) -> Self {\n+        iter.into_iter().collect()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            AccumulateVec::Array(ref arr) => arr.len(),\n+            AccumulateVec::Heap(ref vec) => vec.len(),\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        match *self {\n+            AccumulateVec::Array(ref mut arr) => arr.pop(),\n+            AccumulateVec::Heap(ref mut vec) => vec.pop(),\n+        }\n+    }\n+}\n+\n impl<A: Array> Deref for AccumulateVec<A> {\n     type Target = [A::Element];\n     fn deref(&self) -> &Self::Target {\n@@ -37,6 +83,15 @@ impl<A: Array> Deref for AccumulateVec<A> {\n     }\n }\n \n+impl<A: Array> DerefMut for AccumulateVec<A> {\n+    fn deref_mut(&mut self) -> &mut [A::Element] {\n+        match *self {\n+            AccumulateVec::Array(ref mut v) => &mut v[..],\n+            AccumulateVec::Heap(ref mut v) => &mut v[..],\n+        }\n+    }\n+}\n+\n impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     fn from_iter<I>(iter: I) -> AccumulateVec<A> where I: IntoIterator<Item=A::Element> {\n         let iter = iter.into_iter();\n@@ -50,3 +105,94 @@ impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n     }\n }\n \n+pub struct IntoIter<A: Array> {\n+    repr: IntoIterRepr<A>,\n+}\n+\n+enum IntoIterRepr<A: Array> {\n+    Array(array_vec::Iter<A>),\n+    Heap(vec::IntoIter<A::Element>),\n+}\n+\n+impl<A: Array> Iterator for IntoIter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        match self.repr {\n+            IntoIterRepr::Array(ref mut arr) => arr.next(),\n+            IntoIterRepr::Heap(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self.repr {\n+            IntoIterRepr::Array(ref iter) => iter.size_hint(),\n+            IntoIterRepr::Heap(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for AccumulateVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        IntoIter {\n+            repr: match self {\n+                AccumulateVec::Array(arr) => IntoIterRepr::Array(arr.into_iter()),\n+                AccumulateVec::Heap(vec) => IntoIterRepr::Heap(vec.into_iter()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a AccumulateVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut AccumulateVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<A: Array> From<Vec<A::Element>> for AccumulateVec<A> {\n+    fn from(v: Vec<A::Element>) -> AccumulateVec<A> {\n+        AccumulateVec::many(v)\n+    }\n+}\n+\n+impl<A: Array> Default for AccumulateVec<A> {\n+    fn default() -> AccumulateVec<A> {\n+        AccumulateVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for AccumulateVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<AccumulateVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            Ok(try!((0..len).map(|i| d.read_seq_elt(i, |d| Decodable::decode(d))).collect()))\n+        })\n+    }\n+}\n+"}, {"sha": "631cf2cfcf6db1fdc63a2d666f340af980ef0312", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 139, "deletions": 10, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -9,22 +9,28 @@\n // except according to those terms.\n \n //! A stack-allocated vector, allowing storage of N elements on the stack.\n-//!\n-//! Currently, only the N = 8 case is supported (due to Array only being impl-ed for [T; 8]).\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::drop_in_place;\n-use std::ops::{Deref, DerefMut};\n+use std::ptr::{self, drop_in_place};\n+use std::ops::{Deref, DerefMut, Range};\n+use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n+use std::mem;\n \n pub unsafe trait Array {\n     type Element;\n     type PartialStorage: Default + Unsize<[ManuallyDrop<Self::Element>]>;\n     const LEN: usize;\n }\n \n+unsafe impl<T> Array for [T; 1] {\n+    type Element = T;\n+    type PartialStorage = [ManuallyDrop<T>; 1];\n+    const LEN: usize = 1;\n+}\n+\n unsafe impl<T> Array for [T; 8] {\n     type Element = T;\n     type PartialStorage = [ManuallyDrop<T>; 8];\n@@ -36,13 +42,74 @@ pub struct ArrayVec<A: Array> {\n     values: A::PartialStorage\n }\n \n+impl<A> Hash for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Hash {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        (&self[..]).hash(state);\n+    }\n+}\n+\n+impl<A: Array> PartialEq for ArrayVec<A> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+}\n+\n+impl<A: Array> Eq for ArrayVec<A> {}\n+\n+impl<A> Clone for ArrayVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        let mut v = ArrayVec::new();\n+        v.extend(self.iter().cloned());\n+        v\n+    }\n+}\n+\n impl<A: Array> ArrayVec<A> {\n     pub fn new() -> Self {\n         ArrayVec {\n             count: 0,\n             values: Default::default(),\n         }\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.count\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        self.count = len;\n+    }\n+\n+    /// Panics when the stack vector is full.\n+    pub fn push(&mut self, el: A::Element) {\n+        let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+        arr[self.count] = ManuallyDrop { value: el };\n+        self.count += 1;\n+    }\n+\n+    pub fn pop(&mut self) -> Option<A::Element> {\n+        if self.count > 0 {\n+            let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+            self.count -= 1;\n+            unsafe {\n+                let value = ptr::read(&arr[self.count]);\n+                Some(value.value)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<A> Default for ArrayVec<A>\n+    where A: Array {\n+    fn default() -> Self {\n+        ArrayVec::new()\n+    }\n }\n \n impl<A> fmt::Debug for ArrayVec<A>\n@@ -81,15 +148,69 @@ impl<A: Array> Drop for ArrayVec<A> {\n impl<A: Array> Extend<A::Element> for ArrayVec<A> {\n     fn extend<I>(&mut self, iter: I) where I: IntoIterator<Item=A::Element> {\n         for el in iter {\n-            unsafe {\n-                let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-                arr[self.count].value = el;\n-            }\n-            self.count += 1;\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+pub struct Iter<A: Array> {\n+    indices: Range<usize>,\n+    store: A::PartialStorage,\n+}\n+\n+impl<A: Array> Drop for Iter<A> {\n+    fn drop(&mut self) {\n+        for _ in self {}\n+    }\n+}\n+\n+impl<A: Array> Iterator for Iter<A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        let arr = &self.store as &[ManuallyDrop<_>];\n+        unsafe {\n+            self.indices.next().map(|i| ptr::read(&arr[i]).value)\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.indices.size_hint()\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for ArrayVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = Iter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        let store = unsafe {\n+            ptr::read(&self.values)\n+        };\n+        let indices = 0..self.count;\n+        mem::forget(self);\n+        Iter {\n+            indices: indices,\n+            store: store,\n         }\n     }\n }\n \n+impl<'a, A: Array> IntoIterator for &'a ArrayVec<A> {\n+    type Item = &'a A::Element;\n+    type IntoIter = slice::Iter<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n+    type Item = &'a mut A::Element;\n+    type IntoIter = slice::IterMut<'a, A::Element>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.iter_mut()\n+    }\n+}\n+\n // FIXME: This should use repr(transparent) from rust-lang/rfcs#1758.\n #[allow(unions_with_drop_fields)]\n pub union ManuallyDrop<T> {\n@@ -98,9 +219,17 @@ pub union ManuallyDrop<T> {\n     empty: (),\n }\n \n+impl<T> ManuallyDrop<T> {\n+    fn new() -> ManuallyDrop<T> {\n+        ManuallyDrop {\n+            empty: ()\n+        }\n+    }\n+}\n+\n impl<T> Default for ManuallyDrop<T> {\n     fn default() -> Self {\n-        ManuallyDrop { empty: () }\n+        ManuallyDrop::new()\n     }\n }\n "}, {"sha": "bf3e682f86f699e0e55a4d1e4dca1eff71c30d1a", "filename": "src/librustc_data_structures/base_n.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Convert unsigned integers into a string representation with some base.\n+/// Bases up to and including 36 can be used for case-insensitive things.\n+\n+use std::str;\n+\n+pub const MAX_BASE: u64 = 64;\n+const BASE_64: &'static [u8; MAX_BASE as usize] =\n+    b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n+\n+#[inline]\n+pub fn push_str(mut n: u64, base: u64, output: &mut String) {\n+    debug_assert!(base >= 2 && base <= MAX_BASE);\n+    let mut s = [0u8; 64];\n+    let mut index = 0;\n+\n+    loop {\n+        s[index] = BASE_64[(n % base) as usize];\n+        index += 1;\n+        n /= base;\n+\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    &mut s[0..index].reverse();\n+    output.push_str(str::from_utf8(&s[0..index]).unwrap());\n+}\n+\n+#[inline]\n+pub fn encode(n: u64, base: u64) -> String {\n+    let mut s = String::with_capacity(13);\n+    push_str(n, base, &mut s);\n+    s\n+}\n+\n+#[test]\n+fn test_encode() {\n+    fn test(n: u64, base: u64) {\n+        assert_eq!(Ok(n), u64::from_str_radix(&encode(n, base)[..], base as u32));\n+    }\n+\n+    for base in 2..37 {\n+        test(0, base);\n+        test(1, base);\n+        test(35, base);\n+        test(36, base);\n+        test(37, base);\n+        test(u64::max_value(), base);\n+\n+        for i in 0 .. 1_000 {\n+            test(i * 983, base);\n+        }\n+    }\n+}"}, {"sha": "f94ed6b7209462dd0d7343492d2de705a9fc358a", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -231,18 +231,30 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n \n     // # Iterating over nodes, edges\n \n+    pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n+        EnumeratedNodes {\n+            iter: self.nodes.iter().enumerate()\n+        }\n+    }\n+\n+    pub fn enumerated_edges(&self) -> EnumeratedEdges<E> {\n+        EnumeratedEdges {\n+            iter: self.edges.iter().enumerate()\n+        }\n+    }\n+\n     pub fn each_node<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(NodeIndex, &'a Node<N>) -> bool\n     {\n         //! Iterates over all edges defined in the graph.\n-        self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n+        self.enumerated_nodes().all(|(node_idx, node)| f(node_idx, node))\n     }\n \n     pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(EdgeIndex, &'a Edge<E>) -> bool\n     {\n         //! Iterates over all edges defined in the graph\n-        self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n+        self.enumerated_edges().all(|(edge_idx, edge)| f(edge_idx, edge))\n     }\n \n     pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n@@ -270,14 +282,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    // # Fixed-point iteration\n-    //\n-    // A common use for graphs in our compiler is to perform\n-    // fixed-point iteration. In this case, each edge represents a\n-    // constraint, and the nodes themselves are associated with\n-    // variables or other bitsets. This method facilitates such a\n-    // computation.\n-\n+    /// A common use for graphs in our compiler is to perform\n+    /// fixed-point iteration. In this case, each edge represents a\n+    /// constraint, and the nodes themselves are associated with\n+    /// variables or other bitsets. This method facilitates such a\n+    /// computation.\n     pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n         where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n     {\n@@ -286,8 +295,8 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            for (i, edge) in self.edges.iter().enumerate() {\n-                changed |= op(iteration, EdgeIndex(i), edge);\n+            for (edge_index, edge) in self.enumerated_edges() {\n+                changed |= op(iteration, edge_index, edge);\n             }\n         }\n     }\n@@ -298,10 +307,67 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n                               -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n+\n+    /// Whether or not a node can be reached from itself.\n+    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n+        // This is similar to depth traversal below, but we\n+        // can't use that, because depth traversal doesn't show\n+        // the starting node a second time.\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![starting_node_index];\n+\n+        while let Some(current_node_index) = stack.pop() {\n+            visited.insert(current_node_index.0);\n+\n+            // Directionality doesn't change the answer,\n+            // so just use outgoing edges.\n+            for (_, edge) in self.outgoing_edges(current_node_index) {\n+                let target_node_index = edge.target();\n+\n+                if target_node_index == starting_node_index {\n+                    return true;\n+                }\n+\n+                if !visited.contains(target_node_index.0) {\n+                    stack.push(target_node_index);\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n }\n \n // # Iterators\n \n+pub struct EnumeratedNodes<'g, N>\n+    where N: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Node<N>>>\n+}\n+\n+impl<'g, N: Debug> Iterator for EnumeratedNodes<'g, N> {\n+    type Item = (NodeIndex, &'g Node<N>);\n+\n+    fn next(&mut self) -> Option<(NodeIndex, &'g Node<N>)> {\n+        self.iter.next().map(|(idx, n)| (NodeIndex(idx), n))\n+    }\n+}\n+\n+pub struct EnumeratedEdges<'g, E>\n+    where E: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Edge<E>>>\n+}\n+\n+impl<'g, E: Debug> Iterator for EnumeratedEdges<'g, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        self.iter.next().map(|(idx, e)| (EdgeIndex(idx), e))\n+    }\n+}\n+\n pub struct AdjacentEdges<'g, N, E>\n     where N: 'g,\n           E: 'g\n@@ -336,7 +402,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentTargets<'g, N: 'g, E: 'g>\n+pub struct AdjacentTargets<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -351,7 +417,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentTargets<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentSources<'g, N: 'g, E: 'g>\n+pub struct AdjacentSources<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -366,7 +432,10 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentSources<'g, N, E> {\n     }\n }\n \n-pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n+pub struct DepthFirstTraversal<'g, N, E>\n+    where N: 'g,\n+          E: 'g\n+{\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n     visited: BitVector,"}, {"sha": "a87410e6e1c8ce398d1f56c6ea61d4f81ba9d22f", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -20,10 +20,13 @@ fn create_graph() -> TestGraph {\n \n     // Create a simple graph\n     //\n-    //    A -+> B --> C\n-    //       |  |     ^\n-    //       |  v     |\n-    //       F  D --> E\n+    //          F\n+    //          |\n+    //          V\n+    //    A --> B --> C\n+    //          |     ^\n+    //          v     |\n+    //          D --> E\n \n     let a = graph.add_node(\"A\");\n     let b = graph.add_node(\"B\");\n@@ -42,6 +45,29 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n+fn create_graph_with_cycle() -> TestGraph {\n+    let mut graph = Graph::new();\n+\n+    // Create a graph with a cycle.\n+    //\n+    //    A --> B <-- +\n+    //          |     |\n+    //          v     |\n+    //          C --> D\n+\n+    let a = graph.add_node(\"A\");\n+    let b = graph.add_node(\"B\");\n+    let c = graph.add_node(\"C\");\n+    let d = graph.add_node(\"D\");\n+\n+    graph.add_edge(a, b, \"AB\");\n+    graph.add_edge(b, c, \"BC\");\n+    graph.add_edge(c, d, \"CD\");\n+    graph.add_edge(d, b, \"DB\");\n+\n+    return graph;\n+}\n+\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -139,3 +165,15 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n+\n+#[test]\n+fn is_node_cyclic_a() {\n+    let graph = create_graph_with_cycle();\n+    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n+}\n+\n+#[test]\n+fn is_node_cyclic_b() {\n+    let graph = create_graph_with_cycle();\n+    assert!(graph.is_node_cyclic(NodeIndex(1)));\n+}"}, {"sha": "de13b9bf4be10c909c7b864ccf9c39cab94741b7", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -46,6 +46,8 @@ extern crate libc;\n \n pub mod array_vec;\n pub mod accumulate_vec;\n+pub mod small_vec;\n+pub mod base_n;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;"}, {"sha": "565a3c443a34ab0581c33bdb6cd1045c33c0d24f", "filename": "src/librustc_data_structures/small_vec.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A vector type intended to be used for collecting from iterators onto the stack.\n+//!\n+//! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n+//! used to store the values on the heap. SmallVec is similar to AccumulateVec, but adds\n+//! the ability to push elements.\n+//!\n+//! The N above is determined by Array's implementor, by way of an associatated constant.\n+\n+use std::ops::{Deref, DerefMut};\n+use std::iter::{IntoIterator, FromIterator};\n+use std::fmt::{self, Debug};\n+use std::mem;\n+use std::ptr;\n+\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+\n+use accumulate_vec::{IntoIter, AccumulateVec};\n+use array_vec::Array;\n+\n+pub struct SmallVec<A: Array>(AccumulateVec<A>);\n+\n+impl<A> Clone for SmallVec<A>\n+    where A: Array,\n+          A::Element: Clone {\n+    fn clone(&self) -> Self {\n+        SmallVec(self.0.clone())\n+    }\n+}\n+\n+impl<A> Debug for SmallVec<A>\n+    where A: Array + Debug,\n+          A::Element: Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SmallVec\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<A: Array> SmallVec<A> {\n+    pub fn new() -> Self {\n+        SmallVec(AccumulateVec::new())\n+    }\n+\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let mut vec = SmallVec::new();\n+        vec.reserve(cap);\n+        vec\n+    }\n+\n+    pub fn one(el: A::Element) -> Self {\n+        SmallVec(AccumulateVec::one(el))\n+    }\n+\n+    pub fn many<I: IntoIterator<Item=A::Element>>(els: I) -> Self {\n+        SmallVec(AccumulateVec::many(els))\n+    }\n+\n+    pub fn expect_one(self, err: &'static str) -> A::Element {\n+        assert!(self.len() == 1, err);\n+        match self.0 {\n+            AccumulateVec::Array(arr) => arr.into_iter().next().unwrap(),\n+            AccumulateVec::Heap(vec) => vec.into_iter().next().unwrap(),\n+        }\n+    }\n+\n+    /// Will reallocate onto the heap if needed.\n+    pub fn push(&mut self, el: A::Element) {\n+        self.reserve(1);\n+        match self.0 {\n+            AccumulateVec::Array(ref mut array) => array.push(el),\n+            AccumulateVec::Heap(ref mut vec) => vec.push(el),\n+        }\n+    }\n+\n+    pub fn reserve(&mut self, n: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(_) => {\n+                if self.len() + n > A::LEN {\n+                    let len = self.len();\n+                    let array = mem::replace(&mut self.0,\n+                            AccumulateVec::Heap(Vec::with_capacity(len + n)));\n+                    if let AccumulateVec::Array(array) = array {\n+                        match self.0 {\n+                            AccumulateVec::Heap(ref mut vec) => vec.extend(array),\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                }\n+            }\n+            AccumulateVec::Heap(ref mut vec) => vec.reserve(n)\n+        }\n+    }\n+\n+    pub unsafe fn set_len(&mut self, len: usize) {\n+        match self.0 {\n+            AccumulateVec::Array(ref mut arr) => arr.set_len(len),\n+            AccumulateVec::Heap(ref mut vec) => vec.set_len(len),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, element: A::Element) {\n+        let len = self.len();\n+\n+        // Reserve space for shifting elements to the right\n+        self.reserve(1);\n+\n+        assert!(index <= len);\n+\n+        unsafe {\n+            // infallible\n+            // The spot to put the new value\n+            {\n+                let p = self.as_mut_ptr().offset(index as isize);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy(p, p.offset(1), len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                ptr::write(p, element);\n+            }\n+            self.set_len(len + 1);\n+        }\n+    }\n+}\n+\n+impl<A: Array> Deref for SmallVec<A> {\n+    type Target = AccumulateVec<A>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<A: Array> DerefMut for SmallVec<A> {\n+    fn deref_mut(&mut self) -> &mut AccumulateVec<A> {\n+        &mut self.0\n+    }\n+}\n+\n+impl<A: Array> FromIterator<A::Element> for SmallVec<A> {\n+    fn from_iter<I>(iter: I) -> Self where I: IntoIterator<Item=A::Element> {\n+        SmallVec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<A: Array> Extend<A::Element> for SmallVec<A> {\n+    fn extend<I: IntoIterator<Item=A::Element>>(&mut self, iter: I) {\n+        let iter = iter.into_iter();\n+        self.reserve(iter.size_hint().0);\n+        for el in iter {\n+            self.push(el);\n+        }\n+    }\n+}\n+\n+impl<A: Array> IntoIterator for SmallVec<A> {\n+    type Item = A::Element;\n+    type IntoIter = IntoIter<A>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.into_iter()\n+    }\n+}\n+\n+impl<A: Array> Default for SmallVec<A> {\n+    fn default() -> SmallVec<A> {\n+        SmallVec::new()\n+    }\n+}\n+\n+impl<A> Encodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Encodable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<A> Decodable for SmallVec<A>\n+    where A: Array,\n+          A::Element: Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let mut vec = SmallVec::with_capacity(len);\n+            for i in 0..len {\n+                vec.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(vec)\n+        })\n+    }\n+}"}, {"sha": "4db620b2bec3b1ec507be9519bcf13e70ae1a09f", "filename": "src/librustc_driver/derive_registrar.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Map;\n use rustc::hir;\n use syntax::ast;\n@@ -20,18 +20,22 @@ pub fn find(hir_map: &Map) -> Option<ast::NodeId> {\n     let krate = hir_map.krate();\n \n     let mut finder = Finder { registrar: None };\n-    krate.visit_all_items(&mut finder);\n+    krate.visit_all_item_likes(&mut finder);\n     finder.registrar\n }\n \n struct Finder {\n     registrar: Option<ast::NodeId>,\n }\n \n-impl<'v> Visitor<'v> for Finder {\n+impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if attr::contains_name(&item.attrs, \"rustc_derive_registrar\") {\n             self.registrar = Some(item.id);\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n+"}, {"sha": "6a3a1bbb55ca2bea035f80100b11d81736d281fa", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -709,10 +709,12 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             let crate_types = sess.crate_types.borrow();\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateTypeProcMacro);\n+            let is_test_crate = sess.opts.test;\n             syntax_ext::proc_macro_registrar::modify(&sess.parse_sess,\n                                                      &mut resolver,\n                                                      krate,\n                                                      is_proc_macro_crate,\n+                                                     is_test_crate,\n                                                      num_crate_types,\n                                                      sess.diagnostic(),\n                                                      &sess.features.borrow())\n@@ -755,8 +757,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n          || ast_validation::check_crate(sess, &krate));\n \n     time(sess.time_passes(), \"name resolution\", || -> CompileResult {\n-        resolver.resolve_imports();\n-\n         // Since import resolution will eventually happen in expansion,\n         // don't perform `after_expand` until after import resolution.\n         after_expand(&krate)?;\n@@ -1056,14 +1056,29 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n-    if sess.opts.cg.no_integrated_as {\n+    if sess.opts.cg.no_integrated_as ||\n+        (sess.target.target.options.no_integrated_as &&\n+         (outputs.outputs.contains_key(&OutputType::Object) ||\n+          outputs.outputs.contains_key(&OutputType::Exe)))\n+    {\n         let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n              || write::run_passes(sess, trans, &output_types, outputs));\n \n         write::run_assembler(sess, outputs);\n \n+        // HACK the linker expects the object file to be named foo.0.o but\n+        // `run_assembler` produces an object named just foo.o. Rename it if we\n+        // are going to build an executable\n+        if sess.opts.output_types.contains_key(&OutputType::Exe) {\n+            let f = outputs.path(OutputType::Object);\n+            fs::copy(&f,\n+                     f.with_file_name(format!(\"{}.0.o\",\n+                                              f.file_stem().unwrap().to_string_lossy()))).unwrap();\n+            fs::remove_file(f).unwrap();\n+        }\n+\n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n             fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();"}, {"sha": "57a9edc5c586b532081f0eba7c3c34c9d8224982", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -12,6 +12,7 @@ use syntax::{ast, attr};\n use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n+use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::intern_and_get_ident as intern;\n use libc::c_char;\n@@ -47,4 +48,32 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n             cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n         }\n     }\n+\n+    let requested_features = sess.opts.cg.target_feature.split(',');\n+    let unstable_options = sess.opts.debugging_opts.unstable_options;\n+    let is_nightly = UnstableFeatures::from_environment().is_nightly_build();\n+    let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n+    let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n+\n+    // If the target we're compiling for requests a static crt by default,\n+    // then see if the `-crt-static` feature was passed to disable that.\n+    // Otherwise if we don't have a static crt by default then see if the\n+    // `+crt-static` feature was passed.\n+    let crt_static = if sess.target.target.options.crt_static_default {\n+        !found_negative\n+    } else {\n+        found_positive\n+    };\n+\n+    // If we switched from the default then that's only allowed on nightly, so\n+    // gate that here.\n+    if (found_positive || found_negative) && (!is_nightly || !unstable_options) {\n+        sess.fatal(\"specifying the `crt-static` target feature is only allowed \\\n+                    on the nightly channel with `-Z unstable-options` passed \\\n+                    as well\");\n+    }\n+\n+    if crt_static {\n+        cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(\"crt-static\")));\n+    }\n }"}, {"sha": "782c74c8c78c75b17c294458f33ae2a9caace1e9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -21,9 +21,9 @@ use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n-use rustc::traits::Reveal;\n+use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n+use rustc::infer::{self, InferOk, InferResult};\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n@@ -36,7 +36,6 @@ use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n@@ -245,7 +244,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.sub_types(true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n+        match self.infcx.sub_types(true, &ObligationCause::dummy(), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }"}, {"sha": "998cbae2cce150b94bace00a20f21653a69520c1", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -51,7 +51,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use graphviz::IntoCow;\n use std::env;\n use std::fs::File;\n@@ -81,7 +81,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.map.krate().attrs);\n-        tcx.map.krate().visit_all_items(&mut visitor);\n+        tcx.map.krate().visit_all_item_likes(&mut visitor);\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -167,10 +167,14 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n     }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.process_attrs(impl_item.id, &impl_item.attrs);\n+    }\n }\n \n fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "f98e698a1c9d416b740457a4cfb8f0150977c0da", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -34,6 +34,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::Visitor;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n@@ -45,6 +46,7 @@ use self::caching_codemap_view::CachingCodemapView;\n use self::hasher::IchHasher;\n use ich::Fingerprint;\n \n+\n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n@@ -87,7 +89,12 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n     type Output = Fingerprint;\n \n     fn index(&self, index: &'a DepNode<DefId>) -> &Fingerprint {\n-        &self.hashes[index]\n+        match self.hashes.get(index) {\n+            Some(fingerprint) => fingerprint,\n+            None => {\n+                bug!(\"Could not find ICH for {:?}\", index);\n+            }\n+        }\n     }\n }\n \n@@ -107,7 +114,12 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n         visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n                                  |v| visit::walk_crate(v, krate));\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+\n+        for macro_def in krate.exported_macros.iter() {\n+            visitor.calculate_node_id(macro_def.id,\n+                                      |v| v.visit_macro_def(macro_def));\n+        }\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n@@ -199,12 +211,17 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> visit::Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.calculate_node_id(item.id, |v| v.visit_item(item));\n         visit::walk_item(self, item);\n     }\n \n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n+        visit::walk_impl_item(self, impl_item);\n+    }\n+\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         self.calculate_node_id(item.id, |v| v.visit_foreign_item(item));\n         visit::walk_foreign_item(self, item);"}, {"sha": "a1ece48462b14fad8ae288dc67d3628580899c1f", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 153, "deletions": 11, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n use self::SawItemComponent::*;\n@@ -24,6 +19,7 @@ use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n+use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::{Def, PathResolution};\n@@ -199,6 +195,8 @@ enum SawAbiComponent<'a> {\n     SawExpr(SawExprComponent<'a>),\n     SawStmt,\n     SawVis,\n+    SawAssociatedItemKind(hir::AssociatedItemKind),\n+    SawDefaultness(hir::Defaultness),\n     SawWherePredicate,\n     SawTyParamBound,\n     SawPolyTraitRef,\n@@ -499,10 +497,6 @@ macro_rules! hash_span {\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn visit_nested_item(&mut self, _: ItemId) {\n-        // Each item is hashed independently; ignore nested items.\n-    }\n-\n     fn visit_variant_data(&mut self,\n                           s: &'tcx VariantData,\n                           name: Name,\n@@ -697,6 +691,18 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_vis(self, v)\n     }\n \n+    fn visit_associated_item_kind(&mut self, kind: &'tcx AssociatedItemKind) {\n+        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n+        SawAssociatedItemKind(*kind).hash(self.st);\n+        visit::walk_associated_item_kind(self, kind);\n+    }\n+\n+    fn visit_defaultness(&mut self, defaultness: &'tcx Defaultness) {\n+        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n+        SawDefaultness(*defaultness).hash(self.st);\n+        visit::walk_defaultness(self, defaultness);\n+    }\n+\n     fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n         debug!(\"visit_where_predicate: st={:?}\", self.st);\n         SawWherePredicate.hash(self.st);\n@@ -759,9 +765,10 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_macro_def: st={:?}\", self.st);\n         SawMacroDef.hash(self.st);\n         hash_attrs!(self, &macro_def.attrs);\n+        for tt in &macro_def.body {\n+            self.hash_token_tree(tt);\n+        }\n         visit::walk_macro_def(self, macro_def)\n-        // FIXME(mw): We should hash the body of the macro too but we don't\n-        //            have a stable way of doing so yet.\n     }\n }\n \n@@ -931,4 +938,139 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             self.overflow_checks_enabled = true;\n         }\n     }\n+\n+    fn hash_token_tree(&mut self, tt: &tokenstream::TokenTree) {\n+        self.hash_discriminant(tt);\n+        match *tt {\n+            tokenstream::TokenTree::Token(span, ref token) => {\n+                hash_span!(self, span);\n+                self.hash_token(token, span);\n+            }\n+            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+                hash_span!(self, span);\n+                let tokenstream::Delimited {\n+                    ref delim,\n+                    open_span,\n+                    ref tts,\n+                    close_span,\n+                } = **delimited;\n+\n+                delim.hash(self.st);\n+                hash_span!(self, open_span);\n+                tts.len().hash(self.st);\n+                for sub_tt in tts {\n+                    self.hash_token_tree(sub_tt);\n+                }\n+                hash_span!(self, close_span);\n+            }\n+            tokenstream::TokenTree::Sequence(span, ref sequence_repetition) => {\n+                hash_span!(self, span);\n+                let tokenstream::SequenceRepetition {\n+                    ref tts,\n+                    ref separator,\n+                    op,\n+                    num_captures,\n+                } = **sequence_repetition;\n+\n+                tts.len().hash(self.st);\n+                for sub_tt in tts {\n+                    self.hash_token_tree(sub_tt);\n+                }\n+                self.hash_discriminant(separator);\n+                if let Some(ref separator) = *separator {\n+                    self.hash_token(separator, span);\n+                }\n+                op.hash(self.st);\n+                num_captures.hash(self.st);\n+            }\n+        }\n+    }\n+\n+    fn hash_token(&mut self,\n+                  token: &token::Token,\n+                  error_reporting_span: Span) {\n+        self.hash_discriminant(token);\n+        match *token {\n+            token::Token::Eq |\n+            token::Token::Lt |\n+            token::Token::Le |\n+            token::Token::EqEq |\n+            token::Token::Ne |\n+            token::Token::Ge |\n+            token::Token::Gt |\n+            token::Token::AndAnd |\n+            token::Token::OrOr |\n+            token::Token::Not |\n+            token::Token::Tilde |\n+            token::Token::At |\n+            token::Token::Dot |\n+            token::Token::DotDot |\n+            token::Token::DotDotDot |\n+            token::Token::Comma |\n+            token::Token::Semi |\n+            token::Token::Colon |\n+            token::Token::ModSep |\n+            token::Token::RArrow |\n+            token::Token::LArrow |\n+            token::Token::FatArrow |\n+            token::Token::Pound |\n+            token::Token::Dollar |\n+            token::Token::Question |\n+            token::Token::Underscore |\n+            token::Token::Whitespace |\n+            token::Token::Comment |\n+            token::Token::Eof => {}\n+\n+            token::Token::BinOp(bin_op_token) |\n+            token::Token::BinOpEq(bin_op_token) => bin_op_token.hash(self.st),\n+\n+            token::Token::OpenDelim(delim_token) |\n+            token::Token::CloseDelim(delim_token) => delim_token.hash(self.st),\n+\n+            token::Token::Literal(ref lit, ref opt_name) => {\n+                self.hash_discriminant(lit);\n+                match *lit {\n+                    token::Lit::Byte(val) |\n+                    token::Lit::Char(val) |\n+                    token::Lit::Integer(val) |\n+                    token::Lit::Float(val) |\n+                    token::Lit::Str_(val) |\n+                    token::Lit::ByteStr(val) => val.as_str().hash(self.st),\n+                    token::Lit::StrRaw(val, n) |\n+                    token::Lit::ByteStrRaw(val, n) => {\n+                        val.as_str().hash(self.st);\n+                        n.hash(self.st);\n+                    }\n+                };\n+                opt_name.map(ast::Name::as_str).hash(self.st);\n+            }\n+\n+            token::Token::Ident(ident) |\n+            token::Token::Lifetime(ident) |\n+            token::Token::SubstNt(ident) => ident.name.as_str().hash(self.st),\n+            token::Token::MatchNt(ident1, ident2) => {\n+                ident1.name.as_str().hash(self.st);\n+                ident2.name.as_str().hash(self.st);\n+            }\n+\n+            token::Token::Interpolated(ref non_terminal) => {\n+                // FIXME(mw): This could be implemented properly. It's just a\n+                //            lot of work, since we would need to hash the AST\n+                //            in a stable way, in addition to the HIR.\n+                //            Since this is hardly used anywhere, just emit a\n+                //            warning for now.\n+                if self.tcx.sess.opts.debugging_opts.incremental.is_some() {\n+                    let msg = format!(\"Quasi-quoting might make incremental \\\n+                                       compilation very inefficient: {:?}\",\n+                                      non_terminal);\n+                    self.tcx.sess.span_warn(error_reporting_span, &msg[..]);\n+                }\n+\n+                non_terminal.hash(self.st);\n+            }\n+\n+            token::Token::DocComment(val) |\n+            token::Token::Shebang(val) => val.as_str().hash(self.st),\n+        }\n+    }\n }"}, {"sha": "0cd1c88fb877bb7e007444b2e63cd0d3c4da0344", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -45,7 +45,7 @@ use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::parse::token::InternedString;\n@@ -74,7 +74,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.map.krate();\n-    krate.visit_all_items(&mut DirtyCleanVisitor {\n+    krate.visit_all_item_likes(&mut DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n         dirty_inputs: dirty_inputs,\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n@@ -184,6 +184,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -195,7 +198,7 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     tcx.dep_graph.with_ignore(||{\n         let krate = tcx.map.krate();\n-        krate.visit_all_items(&mut DirtyCleanMetadataVisitor {\n+        krate.visit_all_item_likes(&mut DirtyCleanMetadataVisitor {\n             tcx: tcx,\n             prev_metadata_hashes: prev_metadata_hashes,\n             current_metadata_hashes: current_metadata_hashes,\n@@ -209,7 +212,7 @@ pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n }\n \n-impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n \n@@ -225,6 +228,9 @@ impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "2572a9c1d78f6ea91e8d0d909de15022aff01e84", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -119,7 +119,7 @@ use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n-use rustc_data_structures::flock;\n+use rustc_data_structures::{flock, base_n};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use std::ffi::OsString;\n@@ -135,6 +135,12 @@ const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n \n+// We encode integers using the following base, so they are shorter than decimal\n+// or hexadecimal numbers (we want short file and directory names). Since these\n+// numbers will be used in file names, we choose an encoding that is not\n+// case-sensitive (as opposed to base64, for example).\n+const INT_ENCODE_BASE: u64 = 36;\n+\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n@@ -195,6 +201,19 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     debug!(\"crate-dir: {}\", crate_dir.display());\n     try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n+    // Hack: canonicalize the path *after creating the directory*\n+    // because, on windows, long paths can cause problems;\n+    // canonicalization inserts this weird prefix that makes windows\n+    // tolerate long paths.\n+    let crate_dir = match crate_dir.canonicalize() {\n+        Ok(v) => v,\n+        Err(err) => {\n+            tcx.sess.err(&format!(\"incremental compilation: error canonicalizing path `{}`: {}\",\n+                                  crate_dir.display(), err));\n+            return Err(());\n+        }\n+    };\n+\n     let mut source_directories_already_tried = FxHashSet();\n \n     loop {\n@@ -327,7 +346,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n     let mut new_sub_dir_name = String::from(&old_sub_dir_name[.. dash_indices[2] + 1]);\n \n     // Append the svh\n-    new_sub_dir_name.push_str(&encode_base_36(svh.as_u64()));\n+    base_n::push_str(svh.as_u64(), INT_ENCODE_BASE, &mut new_sub_dir_name);\n \n     // Create the full path\n     let new_path = incr_comp_session_dir.parent().unwrap().join(new_sub_dir_name);\n@@ -433,7 +452,8 @@ fn generate_session_dir_path(crate_dir: &Path) -> PathBuf {\n \n     let directory_name = format!(\"s-{}-{}-working\",\n                                   timestamp,\n-                                  encode_base_36(random_number as u64));\n+                                  base_n::encode(random_number as u64,\n+                                                 INT_ENCODE_BASE));\n     debug!(\"generate_session_dir_path: directory_name = {}\", directory_name);\n     let directory_path = crate_dir.join(directory_name);\n     debug!(\"generate_session_dir_path: directory_path = {}\", directory_path.display());\n@@ -562,27 +582,11 @@ fn extract_timestamp_from_session_dir(directory_name: &str)\n     string_to_timestamp(&directory_name[dash_indices[0]+1 .. dash_indices[1]])\n }\n \n-const BASE_36: &'static [u8] = b\"0123456789abcdefghijklmnopqrstuvwxyz\";\n-\n-fn encode_base_36(mut n: u64) -> String {\n-    let mut s = Vec::with_capacity(13);\n-    loop {\n-        s.push(BASE_36[(n % 36) as usize]);\n-        n /= 36;\n-\n-        if n == 0 {\n-            break;\n-        }\n-    }\n-    s.reverse();\n-    String::from_utf8(s).unwrap()\n-}\n-\n fn timestamp_to_string(timestamp: SystemTime) -> String {\n     let duration = timestamp.duration_since(UNIX_EPOCH).unwrap();\n     let micros = duration.as_secs() * 1_000_000 +\n                 (duration.subsec_nanos() as u64) / 1000;\n-    encode_base_36(micros)\n+    base_n::encode(micros, INT_ENCODE_BASE)\n }\n \n fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n@@ -629,7 +633,7 @@ pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf>\n     };\n \n     let target_svh = tcx.sess.cstore.crate_hash(cnum);\n-    let target_svh = encode_base_36(target_svh.as_u64());\n+    let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n \n     let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {\n         e.ok().map(|e| e.file_name().to_string_lossy().into_owned())\n@@ -677,7 +681,9 @@ fn crate_path(sess: &Session,\n     let mut hasher = DefaultHasher::new();\n     crate_disambiguator.hash(&mut hasher);\n \n-    let crate_name = format!(\"{}-{}\", crate_name, encode_base_36(hasher.finish()));\n+    let crate_name = format!(\"{}-{}\",\n+                             crate_name,\n+                             base_n::encode(hasher.finish(), INT_ENCODE_BASE));\n     incr_dir.join(crate_name)\n }\n \n@@ -1049,21 +1055,3 @@ fn test_find_metadata_hashes_iter()\n         None\n     );\n }\n-\n-#[test]\n-fn test_encode_base_36() {\n-    fn test(n: u64) {\n-        assert_eq!(Ok(n), u64::from_str_radix(&encode_base_36(n)[..], 36));\n-    }\n-\n-    test(0);\n-    test(1);\n-    test(35);\n-    test(36);\n-    test(37);\n-    test(u64::max_value());\n-\n-    for i in 0 .. 1_000 {\n-        test(i * 983);\n-    }\n-}"}, {"sha": "51ffb1ebc8e99ae1d687fa5c8cfe99e1b1198890", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -118,19 +118,20 @@ impl LateLintPass for BoxPointers {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+                let def_id = cx.tcx.map.local_def_id(it.id);\n+                self.check_heap_type(cx, it.span, cx.tcx.item_type(def_id))\n             }\n-            _ => (),\n+            _ => ()\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    self.check_heap_type(cx,\n-                                         struct_field.span,\n-                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n+                    let def_id = cx.tcx.map.local_def_id(struct_field.id);\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         cx.tcx.item_type(def_id));\n                 }\n             }\n             _ => (),\n@@ -386,16 +387,16 @@ impl LateLintPass for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_items) => {\n+            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n                             if item.vis == hir::Visibility::Inherited {\n-                                for itm in impl_items {\n-                                    self.private_traits.insert(itm.id);\n+                                for impl_item_ref in impl_item_refs {\n+                                    self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }\n                             }\n                         }\n@@ -585,11 +586,9 @@ impl LateLintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n-                        if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n-                            impls.insert(node_id);\n-                        }\n+                if let Some(ty_def) = cx.tcx.item_type(d).ty_to_def_id() {\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                        impls.insert(node_id);\n                     }\n                 }\n             });\n@@ -1225,7 +1224,7 @@ impl LateLintPass for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.lookup_item_type(def_id).ty.sty {\n+            match cx.tcx.item_type(def_id).sty {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n@@ -1282,7 +1281,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.item_type(ctx.tcx.map.local_def_id(field.id));\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "4155d3e67a26deef03b823810001c13df12d81d4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -675,8 +675,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        let sig = scheme.ty.fn_sig();\n+        let sig = self.cx.tcx.item_type(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (&input_ty, input_hir) in sig.inputs.iter().zip(&decl.inputs) {\n@@ -693,8 +692,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, scheme.ty);\n+        let ty = self.cx.tcx.item_type(def_id);\n+        self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n }\n \n@@ -740,11 +739,12 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.tables().node_id_to_type(it.id);\n+                let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx)\n-                        .unwrap_or_else(|e| bug!(\"failed to get layout for `{}`: {}\", t, e))\n+                    ty.layout(&infcx).unwrap_or_else(|e| {\n+                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n+                    })\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {"}, {"sha": "88f8c0553adca4ead988b7914ec7e8b425436c3b", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -12,9 +12,6 @@ crate-type = [\"dylib\"]\n [features]\n static-libstdcpp = []\n \n-[dependencies]\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n-\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n gcc = \"0.3.27\""}, {"sha": "50bc3e7b6243f8d8743cb0da1a07398724b918e2", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,6 +17,35 @@ use std::path::{PathBuf, Path};\n \n use build_helper::output;\n \n+fn detect_llvm_link(llvm_config: &Path) -> (&'static str, Option<&'static str>) {\n+    let mut version_cmd = Command::new(llvm_config);\n+    version_cmd.arg(\"--version\");\n+    let version_output = output(&mut version_cmd);\n+    let mut parts = version_output.split('.').take(2)\n+        .filter_map(|s| s.parse::<u32>().ok());\n+    if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n+        if major > 3 || (major == 3 && minor >= 9) {\n+            // Force the link mode we want, preferring static by default, but\n+            // possibly overridden by `configure --enable-llvm-link-shared`.\n+            if env::var_os(\"LLVM_LINK_SHARED\").is_some() {\n+                return (\"dylib\", Some(\"--link-shared\"));\n+            } else {\n+                return (\"static\", Some(\"--link-static\"));\n+            }\n+        } else if major == 3 && minor == 8 {\n+            // Find out LLVM's default linking mode.\n+            let mut mode_cmd = Command::new(llvm_config);\n+            mode_cmd.arg(\"--shared-mode\");\n+            if output(&mut mode_cmd).trim() == \"shared\" {\n+                return (\"dylib\", None);\n+            } else {\n+                return (\"static\", None);\n+            }\n+        }\n+    }\n+    (\"static\", None)\n+}\n+\n fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n \n@@ -66,7 +95,7 @@ fn main() {\n     let is_crossed = target != host;\n \n     let optional_components =\n-        [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\"];\n+        [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses.\n@@ -116,29 +145,26 @@ fn main() {\n         cfg.flag(\"-DLLVM_RUSTLLVM\");\n     }\n \n+    println!(\"cargo:rerun-if-changed=../rustllvm/PassWrapper.cpp\");\n+    println!(\"cargo:rerun-if-changed=../rustllvm/RustWrapper.cpp\");\n+    println!(\"cargo:rerun-if-changed=../rustllvm/ArchiveWrapper.cpp\");\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .cpp(true)\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"librustllvm.a\");\n \n+    let (llvm_kind, llvm_link_arg) = detect_llvm_link(&llvm_config);\n+\n     // Link in all LLVM libraries, if we're uwring the \"wrong\" llvm-config then\n     // we don't pick up system libs because unfortunately they're for the host\n     // of llvm-config, not the target that we're attempting to link.\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--libs\");\n \n-    // Force static linking with \"--link-static\" if available.\n-    let mut version_cmd = Command::new(&llvm_config);\n-    version_cmd.arg(\"--version\");\n-    let version_output = output(&mut version_cmd);\n-    let mut parts = version_output.split('.');\n-    if let (Some(major), Some(minor)) = (parts.next().and_then(|s| s.parse::<u32>().ok()),\n-                                         parts.next().and_then(|s| s.parse::<u32>().ok())) {\n-        if major > 3 || (major == 3 && minor >= 9) {\n-            cmd.arg(\"--link-static\");\n-        }\n+    if let Some(link_arg) = llvm_link_arg {\n+        cmd.arg(link_arg);\n     }\n \n     if !is_crossed {\n@@ -174,7 +200,7 @@ fn main() {\n         }\n \n         let kind = if name.starts_with(\"LLVM\") {\n-            \"static\"\n+            llvm_kind\n         } else {\n             \"dylib\"\n         };"}, {"sha": "ebd75be7bba0bb0cf192c955ca66c11e2eedb212", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 49, "deletions": 65, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -41,6 +41,7 @@ pub enum CallConv {\n     ColdCallConv = 9,\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n+    ArmAapcsCallConv = 67,\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,\n@@ -82,59 +83,31 @@ pub enum DLLStorageClass {\n     DllExport = 2, // Function to be accessible from DLL.\n }\n \n-bitflags! {\n-    #[derive(Default, Debug)]\n-    flags Attribute : u64 {\n-        const ZExt            = 1 << 0,\n-        const SExt            = 1 << 1,\n-        const NoReturn        = 1 << 2,\n-        const InReg           = 1 << 3,\n-        const StructRet       = 1 << 4,\n-        const NoUnwind        = 1 << 5,\n-        const NoAlias         = 1 << 6,\n-        const ByVal           = 1 << 7,\n-        const Nest            = 1 << 8,\n-        const ReadNone        = 1 << 9,\n-        const ReadOnly        = 1 << 10,\n-        const NoInline        = 1 << 11,\n-        const AlwaysInline    = 1 << 12,\n-        const OptimizeForSize = 1 << 13,\n-        const StackProtect    = 1 << 14,\n-        const StackProtectReq = 1 << 15,\n-        const NoCapture       = 1 << 21,\n-        const NoRedZone       = 1 << 22,\n-        const NoImplicitFloat = 1 << 23,\n-        const Naked           = 1 << 24,\n-        const InlineHint      = 1 << 25,\n-        const ReturnsTwice    = 1 << 29,\n-        const UWTable         = 1 << 30,\n-        const NonLazyBind     = 1 << 31,\n-\n-        // Some of these are missing from the LLVM C API, the rest are\n-        // present, but commented out, and preceded by the following warning:\n-        // FIXME: These attributes are currently not included in the C API as\n-        // a temporary measure until the API/ABI impact to the C API is understood\n-        // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32,\n-        const MinSize         = 1 << 33,\n-        const NoDuplicate     = 1 << 34,\n-        const StackProtectStrong = 1 << 35,\n-        const SanitizeThread  = 1 << 36,\n-        const SanitizeMemory  = 1 << 37,\n-        const NoBuiltin       = 1 << 38,\n-        const Returned        = 1 << 39,\n-        const Cold            = 1 << 40,\n-        const Builtin         = 1 << 41,\n-        const OptimizeNone    = 1 << 42,\n-        const InAlloca        = 1 << 43,\n-        const NonNull         = 1 << 44,\n-        const JumpTable       = 1 << 45,\n-        const Convergent      = 1 << 46,\n-        const SafeStack       = 1 << 47,\n-        const NoRecurse       = 1 << 48,\n-        const InaccessibleMemOnly         = 1 << 49,\n-        const InaccessibleMemOrArgMemOnly = 1 << 50,\n-    }\n+/// Matches LLVMRustAttribute in rustllvm.h\n+/// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n+/// though it is not ABI compatible (since it's a C++ enum)\n+#[repr(C)]\n+#[derive(Copy, Clone, Debug)]\n+pub enum Attribute {\n+    AlwaysInline    = 0,\n+    ByVal           = 1,\n+    Cold            = 2,\n+    InlineHint      = 3,\n+    MinSize         = 4,\n+    Naked           = 5,\n+    NoAlias         = 6,\n+    NoCapture       = 7,\n+    NoInline        = 8,\n+    NonNull         = 9,\n+    NoRedZone       = 10,\n+    NoReturn        = 11,\n+    NoUnwind        = 12,\n+    OptimizeForSize = 13,\n+    ReadOnly        = 14,\n+    SExt            = 15,\n+    StructRet       = 16,\n+    UWTable         = 17,\n+    ZExt            = 18,\n }\n \n /// LLVMIntPredicate\n@@ -422,10 +395,21 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Attribute_opaque {}\n+pub type AttributeRef = *mut Attribute_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n \n+/// LLVMVisibility\n+#[repr(C)]\n+pub enum Visibility {\n+    Default,\n+    Hidden,\n+    Protected,\n+}\n+\n pub mod debuginfo {\n     pub use self::DIDescriptorFlags::*;\n     use super::MetadataRef;\n@@ -521,6 +505,9 @@ extern \"C\" {\n     /// See llvm::LLVMType::getContext.\n     pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n+    /// See llvm::Value::getContext\n+    pub fn LLVMRustGetValueContext(V: ValueRef) -> ContextRef;\n+\n     // Operations on integer types\n     pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n@@ -746,8 +733,8 @@ extern \"C\" {\n     pub fn LLVMRustSetLinkage(Global: ValueRef, RustLinkage: Linkage);\n     pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n     pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub fn LLVMGetVisibility(Global: ValueRef) -> Visibility;\n+    pub fn LLVMSetVisibility(Global: ValueRef, Viz: Visibility);\n     pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n     pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n     pub fn LLVMSetDLLStorageClass(V: ValueRef, C: DLLStorageClass);\n@@ -783,6 +770,8 @@ extern \"C\" {\n                         Name: *const c_char)\n                         -> ValueRef;\n \n+    pub fn LLVMRustCreateAttribute(C: ContextRef, kind: Attribute, val: u64) -> AttributeRef;\n+\n     // Operations on functions\n     pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n     pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n@@ -801,16 +790,12 @@ extern \"C\" {\n     pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n     pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);\n-    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n                                               index: c_uint,\n                                               Name: *const c_char,\n                                               Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: u64);\n-    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n \n     // Operations on parameters\n     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n@@ -821,9 +806,8 @@ extern \"C\" {\n     pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n     pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n     pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, attr: AttributeRef);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, attr: AttributeRef);\n     pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     // Operations on basic blocks\n@@ -867,7 +851,7 @@ extern \"C\" {\n     pub fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint, align: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, Val: u64);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: AttributeRef);\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n \n     // Operations on call instructions (only)"}, {"sha": "c81d3b48aa969b1f62598ec91d5a1b10e5092996", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -29,12 +29,8 @@\n #![feature(staged_api)]\n #![feature(linked_from)]\n #![feature(concat_idents)]\n-#![cfg_attr(not(stage0), feature(rustc_private))]\n \n extern crate libc;\n-#[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n \n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n@@ -68,54 +64,6 @@ impl LLVMRustResult {\n     }\n }\n \n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct Attributes {\n-    regular: Attribute,\n-    dereferenceable_bytes: u64,\n-}\n-\n-impl Attributes {\n-    pub fn set(&mut self, attr: Attribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n-    }\n-\n-    pub fn unset(&mut self, attr: Attribute) -> &mut Self {\n-        self.regular = self.regular - attr;\n-        self\n-    }\n-\n-    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n-        self.dereferenceable_bytes = bytes;\n-        self\n-    }\n-\n-    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n-        self.dereferenceable_bytes = 0;\n-        self\n-    }\n-\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe {\n-            self.regular.apply_llfn(idx, llfn);\n-            if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableAttr(llfn, idx.as_uint(), self.dereferenceable_bytes);\n-            }\n-        }\n-    }\n-\n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe {\n-            self.regular.apply_callsite(idx, callsite);\n-            if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableCallSiteAttr(callsite,\n-                                                       idx.as_uint(),\n-                                                       self.dereferenceable_bytes);\n-            }\n-        }\n-    }\n-}\n-\n pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n                                   idx: AttributePlace,\n                                   attr: &'static str,\n@@ -140,7 +88,7 @@ impl AttributePlace {\n         AttributePlace::Argument(0)\n     }\n \n-    fn as_uint(self) -> c_uint {\n+    pub fn as_uint(self) -> c_uint {\n         match self {\n             AttributePlace::Function => !0,\n             AttributePlace::Argument(i) => i,\n@@ -228,16 +176,20 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n }\n \n impl Attribute {\n+    fn as_object(&self, value: ValueRef) -> AttributeRef {\n+        unsafe { LLVMRustCreateAttribute(LLVMRustGetValueContext(value), *self, 0) }\n+    }\n+\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.as_object(llfn)) }\n     }\n \n     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.as_object(callsite)) }\n     }\n \n     pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.as_object(llfn)) }\n     }\n \n     pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {\n@@ -413,6 +365,11 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeJSBackendTargetInfo,\n                  LLVMInitializeJSBackendTarget,\n                  LLVMInitializeJSBackendTargetMC);\n+    init_target!(llvm_component = \"msp430\",\n+                 LLVMInitializeMSP430TargetInfo,\n+                 LLVMInitializeMSP430Target,\n+                 LLVMInitializeMSP430TargetMC,\n+                 LLVMInitializeMSP430AsmPrinter);\n }\n \n pub fn last_error() -> Option<String> {"}, {"sha": "e2fa535bb44a0162d120def300be20e038f3c822", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -133,15 +133,18 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n     };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n-    tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n+    let ty = tcx.item_type(orig_did);\n+    let generics = tcx.item_generics(orig_did);\n+    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n+    tcx.generics.borrow_mut().insert(inlined_did, generics);\n \n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::Def(def) => {\n                 tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n             TableEntry::NodeType(ty) => {\n-                tcx.node_type_insert(id, ty);\n+                tcx.tables.borrow_mut().node_types.insert(id, ty);\n             }\n             TableEntry::ItemSubsts(item_substs) => {\n                 tcx.tables.borrow_mut().item_substs.insert(id, item_substs);"}, {"sha": "5384535024e537f23e8c3ec1d119389be26a0f57", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -23,6 +23,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -35,6 +36,7 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n+use syntax::feature_gate::{self, GateIssue};\n use syntax::parse::token::{InternedString, intern};\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n@@ -77,9 +79,8 @@ struct ExternCrateInfo {\n fn register_native_lib(sess: &Session,\n                        cstore: &CStore,\n                        span: Option<Span>,\n-                       name: String,\n-                       kind: cstore::NativeLibraryKind) {\n-    if name.is_empty() {\n+                       lib: NativeLibrary) {\n+    if lib.name.is_empty() {\n         match span {\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n@@ -94,17 +95,21 @@ fn register_native_lib(sess: &Session,\n         return\n     }\n     let is_osx = sess.target.target.options.is_like_osx;\n-    if kind == cstore::NativeFramework && !is_osx {\n+    if lib.kind == cstore::NativeFramework && !is_osx {\n         let msg = \"native frameworks are only available on OSX targets\";\n         match span {\n-            Some(span) => {\n-                span_err!(sess, span, E0455,\n-                          \"{}\", msg)\n-            }\n+            Some(span) => span_err!(sess, span, E0455, \"{}\", msg),\n             None => sess.err(msg),\n         }\n     }\n-    cstore.add_used_library(name, kind);\n+    if lib.cfg.is_some() && !sess.features.borrow().link_cfg {\n+        feature_gate::emit_feature_err(&sess.parse_sess,\n+                                       \"link_cfg\",\n+                                       span.unwrap(),\n+                                       GateIssue::Language,\n+                                       \"is feature gated\");\n+    }\n+    cstore.add_used_library(lib);\n }\n \n // Extra info about a crate loaded for plugins or exported macros.\n@@ -313,11 +318,11 @@ impl<'a> CrateLoader<'a> {\n                      name: &str,\n                      hash: Option<&Svh>,\n                      span: Span,\n-                     kind: PathKind,\n+                     path_kind: PathKind,\n                      mut dep_kind: DepKind)\n                      -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n-        let result = if let Some(cnum) = self.existing_match(name, hash, kind) {\n+        let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             LoadResult::Previous(cnum)\n         } else {\n             info!(\"falling back to a load\");\n@@ -327,7 +332,7 @@ impl<'a> CrateLoader<'a> {\n                 ident: ident,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n-                filesearch: self.sess.target_filesearch(kind),\n+                filesearch: self.sess.target_filesearch(path_kind),\n                 target: &self.sess.target.target,\n                 triple: &self.sess.opts.target_triple,\n                 root: root,\n@@ -345,7 +350,7 @@ impl<'a> CrateLoader<'a> {\n                 let mut proc_macro_locator = locator::Context {\n                     target: &self.sess.host,\n                     triple: config::host_triple(),\n-                    filesearch: self.sess.host_filesearch(PathKind::Crate),\n+                    filesearch: self.sess.host_filesearch(path_kind),\n                     rejected_via_hash: vec![],\n                     rejected_via_triple: vec![],\n                     rejected_via_kind: vec![],\n@@ -635,9 +640,9 @@ impl<'a> CrateLoader<'a> {\n \n     fn register_statically_included_foreign_items(&mut self) {\n         let libs = self.cstore.get_used_libraries();\n-        for (lib, list) in self.foreign_item_map.iter() {\n-            let is_static = libs.borrow().iter().any(|&(ref name, kind)| {\n-                lib == name && kind == cstore::NativeStatic\n+        for (foreign_lib, list) in self.foreign_item_map.iter() {\n+            let is_static = libs.borrow().iter().any(|lib| {\n+                *foreign_lib == lib.name && lib.kind == cstore::NativeStatic\n             });\n             if is_static {\n                 for id in list {\n@@ -898,7 +903,18 @@ impl<'a> CrateLoader<'a> {\n                     InternedString::new(\"foo\")\n                 }\n             };\n-            register_native_lib(self.sess, self.cstore, Some(m.span), n.to_string(), kind);\n+            let cfg = items.iter().find(|k| {\n+                k.check_name(\"cfg\")\n+            }).and_then(|a| a.meta_item_list());\n+            let cfg = cfg.map(|list| {\n+                list[0].meta_item().unwrap().clone()\n+            });\n+            let lib = NativeLibrary {\n+                name: n.to_string(),\n+                kind: kind,\n+                cfg: cfg,\n+            };\n+            register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n         }\n \n         // Finally, process the #[linked_from = \"...\"] attribute\n@@ -924,7 +940,12 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         }\n \n         for &(ref name, kind) in &self.sess.opts.libs {\n-            register_native_lib(self.sess, self.cstore, None, name.clone(), kind);\n+            let lib = NativeLibrary {\n+                name: name.clone(),\n+                kind: kind,\n+                cfg: None,\n+            };\n+            register_native_lib(self.sess, self.cstore, None, lib);\n         }\n         self.register_statically_included_foreign_items();\n     }"}, {"sha": "37853b7473a6500d05e3e42b7f346fdf5b574d33", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -31,7 +31,7 @@ use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n \n-pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n+pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n \n@@ -97,7 +97,7 @@ pub struct CStore {\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n+    used_libraries: RefCell<Vec<NativeLibrary>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n     pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n@@ -212,12 +212,12 @@ impl CStore {\n         libs\n     }\n \n-    pub fn add_used_library(&self, lib: String, kind: NativeLibraryKind) {\n-        assert!(!lib.is_empty());\n-        self.used_libraries.borrow_mut().push((lib, kind));\n+    pub fn add_used_library(&self, lib: NativeLibrary) {\n+        assert!(!lib.name.is_empty());\n+        self.used_libraries.borrow_mut().push(lib);\n     }\n \n-    pub fn get_used_libraries<'a>(&'a self) -> &'a RefCell<Vec<(String, NativeLibraryKind)>> {\n+    pub fn get_used_libraries(&self) -> &RefCell<Vec<NativeLibrary>> {\n         &self.used_libraries\n     }\n "}, {"sha": "2018d829597d43bb280799594efe1343a737f07e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -14,7 +14,7 @@ use locator;\n use schema;\n \n use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n-use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference, LoadedMacro};\n+use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n@@ -295,7 +295,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n     {\n         self.get_crate_data(cnum).get_native_libraries()\n     }\n@@ -356,7 +356,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n-            return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize()].1.clone());\n+            return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize() - 1].1.clone());\n         }\n \n         let (name, def) = data.get_macro(id.index);\n@@ -524,7 +524,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>\n+    fn used_libraries(&self) -> Vec<NativeLibrary>\n     {\n         self.get_used_libraries().borrow().clone()\n     }"}, {"sha": "3af9d291ae55a4056c2d153eae2195d7bef5b92c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,7 +11,7 @@\n // Decoding metadata from a single crate's metadata\n \n use astencode::decode_inlined_item;\n-use cstore::{self, CrateMetadata, MetadataBlob, NativeLibraryKind};\n+use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use index::Index;\n use schema::*;\n \n@@ -23,7 +23,7 @@ use rustc::hir::intravisit::IdRange;\n \n use rustc::middle::cstore::{DepKind, InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -513,7 +513,14 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        self.entry(index).kind.to_def(self.local_def_id(index))\n+        if self.proc_macros.is_some() {\n+            Some(match index {\n+                CRATE_DEF_INDEX => Def::Mod(self.local_def_id(index)),\n+                _ => Def::Macro(self.local_def_id(index)),\n+            })\n+        } else {\n+            self.entry(index).kind.to_def(self.local_def_id(index))\n+        }\n     }\n \n     pub fn get_trait_def(&self,\n@@ -527,7 +534,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::TraitDef::new(data.unsafety,\n                           data.paren_sugar,\n-                          tcx.lookup_generics(self.local_def_id(item_id)),\n+                          tcx.item_generics(self.local_def_id(item_id)),\n                           data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n@@ -643,15 +650,24 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n-        self.entry(id).stability.map(|stab| stab.decode(self))\n+        match self.proc_macros {\n+            Some(_) if id != CRATE_DEF_INDEX => None,\n+            _ => self.entry(id).stability.map(|stab| stab.decode(self)),\n+        }\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.entry(id).deprecation.map(|depr| depr.decode(self))\n+        match self.proc_macros {\n+            Some(_) if id != CRATE_DEF_INDEX => None,\n+            _ => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n+        }\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n-        self.entry(id).visibility\n+        match self.proc_macros {\n+            Some(_) => ty::Visibility::Public,\n+            _ => self.entry(id).visibility,\n+        }\n     }\n \n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n@@ -692,11 +708,11 @@ impl<'a, 'tcx> CrateMetadata {\n         where F: FnMut(def::Export)\n     {\n         if let Some(ref proc_macros) = self.proc_macros {\n-            for (id, &(name, _)) in proc_macros.iter().enumerate() {\n-                callback(def::Export {\n-                    name: name,\n-                    def: Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id), }),\n-                })\n+            if id == CRATE_DEF_INDEX {\n+                for (id, &(name, _)) in proc_macros.iter().enumerate() {\n+                    let def = Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id + 1) });\n+                    callback(def::Export { name: name, def: def });\n+                }\n             }\n             return\n         }\n@@ -834,7 +850,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Const,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n-                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n                     method_has_self_argument: false\n@@ -848,7 +863,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Method,\n                     vis: item.visibility,\n                     defaultness: data.container.defaultness(),\n-                    has_value: data.container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n                     method_has_self_argument: data.has_self\n@@ -861,7 +875,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Type,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n-                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n                     method_has_self_argument: false\n@@ -894,6 +907,9 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n+        if self.proc_macros.is_some() && node_id != CRATE_DEF_INDEX {\n+            return Vec::new();\n+        }\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -980,7 +996,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self) -> Vec<(NativeLibraryKind, String)> {\n+    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n         self.root.native_libraries.decode(self).collect()\n     }\n "}, {"sha": "3ab542442a1fbe4fbf1eca6b4d224f6f3e956462", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -13,7 +13,7 @@ use index::Index;\n use schema::*;\n \n use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n-use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n+use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::middle::dependency_format::Linkage;\n@@ -38,6 +38,7 @@ use syntax;\n use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n \n@@ -246,7 +247,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_item_type(def_id).ty)\n+        self.lazy(&tcx.item_type(def_id))\n     }\n \n     /// Encode data for the given variant of the given ADT. The\n@@ -444,12 +445,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.lookup_generics(def_id))\n+        self.lazy(tcx.item_generics(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_predicates(def_id))\n+        self.lazy(&tcx.item_predicates(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -459,10 +460,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let ast_item = tcx.map.expect_trait_item(node_id);\n         let trait_item = tcx.associated_item(def_id);\n \n-        let container = if trait_item.has_value {\n-            AssociatedContainer::TraitWithDefault\n-        } else {\n-            AssociatedContainer::TraitRequired\n+        let container = match trait_item.defaultness {\n+            hir::Defaultness::Default { has_value: true } =>\n+                AssociatedContainer::TraitWithDefault,\n+            hir::Defaultness::Default { has_value: false } =>\n+                AssociatedContainer::TraitRequired,\n+            hir::Defaultness::Final =>\n+                span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n         let kind = match trait_item.kind {\n@@ -500,7 +504,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     Some(self.encode_item_type(def_id))\n                 }\n                 ty::AssociatedKind::Type => {\n-                    if trait_item.has_value {\n+                    if trait_item.defaultness.has_value() {\n                         Some(self.encode_item_type(def_id))\n                     } else {\n                         None\n@@ -529,8 +533,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let impl_def_id = impl_item.container.id();\n \n         let container = match impl_item.defaultness {\n-            hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n+            hir::Defaultness::Default { has_value: true } => AssociatedContainer::ImplDefault,\n             hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n+            hir::Defaultness::Default { has_value: false } =>\n+                span_bug!(ast_item.span, \"impl items always have values (currently)\"),\n         };\n \n         let kind = match impl_item.kind {\n@@ -556,7 +562,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n-            let generics = self.tcx.lookup_generics(def_id);\n+            let generics = self.tcx.item_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n@@ -717,7 +723,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n                     trait_ref: self.lazy(&trait_def.trait_ref),\n-                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id)),\n+                    super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))\n@@ -1056,10 +1062,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             stability: None,\n             deprecation: None,\n \n-            ty: None,\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n-            generics: None,\n+            generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n \n             ast: None,\n@@ -1074,7 +1080,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                      EncodeContext::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n             visitor.visit_macro_def(macro_def);\n         }\n@@ -1134,14 +1140,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n          self.lazy_seq_ref(&tcx.lang_items.missing))\n     }\n \n-    fn encode_native_libraries(&mut self) -> LazySeq<(NativeLibraryKind, String)> {\n+    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n         let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries.into_iter().filter_map(|(lib, kind)| {\n-            match kind {\n-                cstore::NativeStatic => None, // these libraries are not propagated\n-                cstore::NativeFramework | cstore::NativeUnknown => Some((kind, lib)),\n-            }\n-        }))\n+        self.lazy_seq(used_libraries)\n     }\n \n     fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n@@ -1164,7 +1165,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n     impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemImpl(..) = item.node {\n             let impl_id = self.tcx.map.local_def_id(item.id);\n@@ -1176,6 +1177,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -1185,7 +1190,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             tcx: self.tcx,\n             impls: FxHashMap(),\n         };\n-        self.tcx.map.krate().visit_all_items(&mut visitor);\n+        self.tcx.map.krate().visit_all_item_likes(&mut visitor);\n \n         let all_impls: Vec<_> = visitor.impls\n             .into_iter()"}, {"sha": "b677a63edc06458c6e50247dd22281535175dfd2", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -217,7 +217,7 @@ use creader::Library;\n use schema::{METADATA_HEADER, rustc_version};\n \n use rustc::hir::svh::Svh;\n-use rustc::session::Session;\n+use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n@@ -355,6 +355,11 @@ impl<'a> Context<'a> {\n                                            \"can't find crate for `{}`{}\",\n                                            self.ident,\n                                            add);\n+\n+            if (self.ident == \"std\" || self.ident == \"core\")\n+                && self.triple != config::host_triple() {\n+                err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n+            }\n             err.span_label(self.span, &format!(\"can't find crate\"));\n             err\n         };"}, {"sha": "32c8c5e2ee87996536b634662fd3c1ce209fbe76", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -14,7 +14,7 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n-use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibraryKind};\n+use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n@@ -175,7 +175,7 @@ pub struct CrateRoot {\n     pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n     pub lang_items: LazySeq<(DefIndex, usize)>,\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n+    pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub impls: LazySeq<TraitImpls>,\n     pub reachable_ids: LazySeq<DefIndex>,\n@@ -310,21 +310,16 @@ impl AssociatedContainer {\n         }\n     }\n \n-    pub fn has_value(&self) -> bool {\n-        match *self {\n-            AssociatedContainer::TraitRequired => false,\n-\n-            AssociatedContainer::TraitWithDefault |\n-            AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => true,\n-        }\n-    }\n-\n     pub fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n-            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitRequired => hir::Defaultness::Default {\n+                has_value: false,\n+            },\n+\n             AssociatedContainer::TraitWithDefault |\n-            AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n+            AssociatedContainer::ImplDefault => hir::Defaultness::Default {\n+                has_value: true,\n+            },\n \n             AssociatedContainer::ImplFinal => hir::Defaultness::Final,\n         }"}, {"sha": "2c7b47c7669993ff03dbe84e57a05e71bc4c47c9", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let tcx = this.hir.tcx();\n \n                         // Enter the remainder scope, i.e. the bindings' destruction scope.\n-                        this.push_scope(remainder_scope, block);\n+                        this.push_scope(remainder_scope);\n                         let_extent_stack.push(remainder_scope);\n \n                         // Declare the bindings, which may create a visibility scope."}, {"sha": "71e97e4bfe0d3596bbf8b34db481592cc42b08ae", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -40,11 +40,6 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn current_location(&mut self, block: BasicBlock) -> Location {\n-        let index = self.block_data(block).statements.len();\n-        Location { block: block, statement_index: index }\n-    }\n-\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        source_info: SourceInfo,"}, {"sha": "458a952543e4008090c0375df9ec54bd58275f72", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 18, "deletions": 52, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -36,13 +36,6 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n-    ///  for each scope, a span of blocks that defines it;\n-    ///  we track these for use in region and borrow checking,\n-    ///  but these are liable to get out of date once optimization\n-    ///  begins. They are also hopefully temporary, and will be\n-    ///  no longer needed when we adopt graph-based regions.\n-    scope_auxiliary: IndexVec<ScopeId, ScopeAuxiliary>,\n-\n     /// the current set of loops; see the `scope` module for more\n     /// details\n     loop_scopes: Vec<scope::LoopScope>,\n@@ -82,30 +75,6 @@ impl Idx for ScopeId {\n     }\n }\n \n-/// For each scope, we track the extent (from the HIR) and a\n-/// single-entry-multiple-exit subgraph that contains all the\n-/// statements/terminators within it.\n-///\n-/// This information is separated out from the main `ScopeData`\n-/// because it is short-lived. First, the extent contains node-ids,\n-/// so it cannot be saved and re-loaded. Second, any optimization will mess up\n-/// the dominator/postdominator information.\n-///\n-/// The intention is basically to use this information to do\n-/// regionck/borrowck and then throw it away once we are done.\n-pub struct ScopeAuxiliary {\n-    /// extent of this scope from the MIR.\n-    pub extent: CodeExtent,\n-\n-    /// \"entry point\": dominator of all nodes in the scope\n-    pub dom: Location,\n-\n-    /// \"exit points\": mutual postdominators of all nodes in the scope\n-    pub postdoms: Vec<Location>,\n-}\n-\n-pub type ScopeAuxiliaryVec = IndexVec<ScopeId, ScopeAuxiliary>;\n-\n ///////////////////////////////////////////////////////////////////////////\n /// The `BlockAnd` \"monad\" packages up the new basic block along with a\n /// produced value (sometimes just unit, of course). The `unpack!`\n@@ -155,9 +124,10 @@ macro_rules! unpack {\n pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n+                                       abi: Abi,\n                                        return_ty: Ty<'gcx>,\n                                        ast_body: &'gcx hir::Expr)\n-                                       -> (Mir<'tcx>, ScopeAuxiliaryVec)\n+                                       -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let arguments: Vec<_> = arguments.collect();\n@@ -191,12 +161,9 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.tables().node_id_to_type(fn_id).sty {\n-        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n-            // RustCall pseudo-ABI untuples the last argument.\n-            spread_arg = Some(Local::new(arguments.len()));\n-        }\n-        _ => {}\n+    if abi == Abi::RustCall {\n+        // RustCall pseudo-ABI untuples the last argument.\n+        spread_arg = Some(Local::new(arguments.len()));\n     }\n \n     // Gather the upvars of a closure, if any.\n@@ -223,15 +190,15 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         }).collect()\n     });\n \n-    let (mut mir, aux) = builder.finish(upvar_decls, return_ty);\n+    let mut mir = builder.finish(upvar_decls, return_ty);\n     mir.spread_arg = spread_arg;\n-    (mir, aux)\n+    mir\n }\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        item_id: ast::NodeId,\n                                        ast_expr: &'tcx hir::Expr)\n-                                       -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+                                       -> Mir<'tcx> {\n     let tcx = hir.tcx();\n     let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n@@ -271,7 +238,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n-            scope_auxiliary: IndexVec::new(),\n             loop_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty), 1),\n             var_indices: NodeMap(),\n@@ -290,22 +256,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n               return_ty: Ty<'tcx>)\n-              -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+              -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n                 span_bug!(self.fn_span, \"no terminator on block {:?}\", index);\n             }\n         }\n \n-        (Mir::new(self.cfg.basic_blocks,\n-                  self.visibility_scopes,\n-                  IndexVec::new(),\n-                  return_ty,\n-                  self.local_decls,\n-                  self.arg_count,\n-                  upvar_decls,\n-                  self.fn_span\n-        ), self.scope_auxiliary)\n+        Mir::new(self.cfg.basic_blocks,\n+                 self.visibility_scopes,\n+                 IndexVec::new(),\n+                 return_ty,\n+                 self.local_decls,\n+                 self.arg_count,\n+                 upvar_decls,\n+                 self.fn_span\n+        )\n     }\n \n     fn args_and_body(&mut self,"}, {"sha": "4d9b6c0e05a4250345e82fc8277f8b2b863a642b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -86,7 +86,7 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::{Kind, Subst};\n@@ -97,14 +97,10 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::fx::FxHashMap;\n \n pub struct Scope<'tcx> {\n-    /// the scope-id within the scope_auxiliary\n-    id: ScopeId,\n-\n     /// The visibility scope this scope was created in.\n     visibility_scope: VisibilityScope,\n \n-    /// the extent of this scope within source code; also stored in\n-    /// `ScopeAuxiliary`, but kept here for convenience\n+    /// the extent of this scope within source code.\n     extent: CodeExtent,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n@@ -276,7 +272,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent, block);\n+        self.push_scope(extent);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n@@ -287,24 +283,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n+    pub fn push_scope(&mut self, extent: CodeExtent) {\n         debug!(\"push_scope({:?})\", extent);\n-        let id = ScopeId::new(self.scope_auxiliary.len());\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n-            id: id,\n             visibility_scope: vis_scope,\n             extent: extent,\n             needs_cleanup: false,\n             drops: vec![],\n             free: None,\n             cached_exits: FxHashMap()\n         });\n-        self.scope_auxiliary.push(ScopeAuxiliary {\n-            extent: extent,\n-            dom: self.cfg.current_location(entry),\n-            postdoms: vec![]\n-        });\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n@@ -325,9 +314,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                           &self.scopes,\n                                           block,\n                                           self.arg_count));\n-        self.scope_auxiliary[scope.id]\n-            .postdoms\n-            .push(self.cfg.current_location(block));\n         block.unit()\n     }\n \n@@ -375,9 +361,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.terminate(block, scope.source_info(span), free);\n                 block = next;\n             }\n-            self.scope_auxiliary[scope.id]\n-                .postdoms\n-                .push(self.cfg.current_location(block));\n         }\n         }\n         let scope = &self.scopes[len - scope_count];\n@@ -806,7 +789,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,\n-            ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n+            ty: tcx.item_type(free_func).subst(tcx, substs),\n             literal: Literal::Item {\n                 def_id: free_func,\n                 substs: substs"}, {"sha": "24c1ca574a01baf6731adc2fefcb8cdf700a52a7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -521,8 +521,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n                 freevars.iter()\n-                    .enumerate()\n-                    .map(|(i, fv)| capture_freevar(cx, expr, fv, substs.upvar_tys[i]))\n+                    .zip(substs.upvar_tys(def_id, cx.tcx))\n+                    .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n                     .collect()\n             });\n             ExprKind::Closure {"}, {"sha": "038300068fce1c6d402362f0da189d992e2083f1", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -149,8 +149,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n-                let method_ty = self.tcx.lookup_item_type(item.def_id);\n-                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                let method_ty = self.tcx.item_type(item.def_id);\n+                let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty, Literal::Item {\n                     def_id: item.def_id,\n                     substs: substs,"}, {"sha": "992c0e9b5fc85739931bfbfc4bf3d1959f0eed75", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -31,15 +31,16 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::Mir, &mut BuildMir {\n+    tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut BuildMir {\n         tcx: tcx\n-    });\n+    }.as_deep_visitor());\n }\n \n /// A pass to lift all the types and substitutions in a Mir\n@@ -102,11 +103,11 @@ impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n \n impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n     fn build<F>(&'tcx mut self, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n+        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> Mir<'tcx>\n     {\n         let (src, def_id) = (self.src, self.def_id);\n         self.infcx.enter(|infcx| {\n-            let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, src));\n+            let mut mir = f(Cx::new(&infcx, src));\n \n             // Convert the Mir to global types.\n             let tcx = infcx.tcx.global_tcx();\n@@ -119,7 +120,7 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n                 mem::transmute::<Mir, Mir<'gcx>>(mir)\n             };\n \n-            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n+            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n             let mir = tcx.alloc_mir(mir);\n             assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n@@ -221,10 +222,11 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             }\n         };\n \n-        let implicit_argument = if let FnKind::Closure(..) = fk {\n-            Some((closure_self_ty(self.tcx, id, body.id), None))\n+        let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body.id), None)))\n         } else {\n-            None\n+            let def_id = self.tcx.map.local_def_id(id);\n+            (self.tcx.item_type(def_id).fn_abi(), None)\n         };\n \n         let explicit_arguments =\n@@ -237,7 +239,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, fn_sig.output, body)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output, body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body, span, id);"}, {"sha": "e7188d536980fccde9dd1d76342a0aaa8761e9a8", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 7, "deletions": 51, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n@@ -43,8 +42,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n                           src: MirSource,\n-                          mir: &Mir<'tcx>,\n-                          auxiliary: Option<&ScopeAuxiliaryVec>) {\n+                          mir: &Mir<'tcx>) {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return,\n         Some(ref filters) => filters,\n@@ -81,7 +79,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, src, mir, &mut file, auxiliary)?;\n+        write_mir_fn(tcx, src, mir, &mut file)?;\n         Ok(())\n     });\n }\n@@ -106,52 +104,24 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n \n         let id = tcx.map.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n-        write_mir_fn(tcx, src, mir, w, None)?;\n+        write_mir_fn(tcx, src, mir, w)?;\n \n         for (i, mir) in mir.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n-            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w, None)?;\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w)?;\n         }\n     }\n     Ok(())\n }\n \n-enum Annotation {\n-    EnterScope(ScopeId),\n-    ExitScope(ScopeId),\n-}\n-\n-fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n-                                -> FxHashMap<Location, Vec<Annotation>>\n-{\n-    // compute scope/entry exit annotations\n-    let mut annotations = FxHashMap();\n-    if let Some(auxiliary) = auxiliary {\n-        for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n-            annotations.entry(auxiliary.dom)\n-                       .or_insert(vec![])\n-                       .push(Annotation::EnterScope(scope_id));\n-\n-            for &loc in &auxiliary.postdoms {\n-                annotations.entry(loc)\n-                           .or_insert(vec![])\n-                           .push(Annotation::ExitScope(scope_id));\n-            }\n-        }\n-    }\n-    return annotations;\n-}\n-\n pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               src: MirSource,\n                               mir: &Mir<'tcx>,\n-                              w: &mut Write,\n-                              auxiliary: Option<&ScopeAuxiliaryVec>)\n+                              w: &mut Write)\n                               -> io::Result<()> {\n-    let annotations = scope_entry_exit_annotations(auxiliary);\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        write_basic_block(tcx, block, mir, w, &annotations)?;\n+        write_basic_block(tcx, block, mir, w)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n@@ -165,8 +135,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n-                     w: &mut Write,\n-                     annotations: &FxHashMap<Location, Vec<Annotation>>)\n+                     w: &mut Write)\n                      -> io::Result<()> {\n     let data = &mir[block];\n \n@@ -176,19 +145,6 @@ fn write_basic_block(tcx: TyCtxt,\n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n-        if let Some(ref annotations) = annotations.get(&current_location) {\n-            for annotation in annotations.iter() {\n-                match *annotation {\n-                    Annotation::EnterScope(id) =>\n-                        writeln!(w, \"{0}{0}// Enter Scope({1})\",\n-                                 INDENT, id.index())?,\n-                    Annotation::ExitScope(id) =>\n-                        writeln!(w, \"{0}{0}// Exit Scope({1})\",\n-                                 INDENT, id.index())?,\n-                }\n-            }\n-        }\n-\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,"}, {"sha": "035f33de91aa5d15dca3bcc9048046bc5d20918c", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -64,8 +64,7 @@ impl<'tcx> MirPassHook<'tcx> for DumpMir {\n                 is_after: is_after\n             },\n             src,\n-            mir,\n-            None\n+            mir\n         );\n     }\n }"}, {"sha": "4ff2beb3fdb77a519333e37ad13827572b347bb0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -277,8 +277,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             .and_then(|impl_node_id| self.tcx.map.find(impl_node_id))\n                             .map(|node| {\n                                 if let hir_map::NodeItem(item) = node {\n-                                    if let hir::ItemImpl(_, _, _, _, _, ref methods) = item.node {\n-                                        span = methods.first().map(|method| method.span);\n+                                    if let hir::ItemImpl(.., ref impl_item_refs) = item.node {\n+                                        span = impl_item_refs.first()\n+                                                             .map(|iiref| {\n+                                                                 self.tcx.map.impl_item(iiref.id)\n+                                                                             .span\n+                                                             });\n                                     }\n                                 }\n                             });"}, {"sha": "0ceed274b6da656f089e6c3d1d357acfbdf62f73", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         match *lvalue {\n             Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: self.tcx().item_type(def_id) },\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {\n@@ -274,9 +274,15 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }\n-                ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n-                    upvar_tys: tys, ..\n-                }) => {\n+                ty::TyClosure(def_id, substs) => {\n+                    return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: substs.upvar_tys(def_id, tcx).count()\n+                        })\n+                    }\n+                }\n+                ty::TyTuple(tys) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n@@ -300,32 +306,43 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n-    last_span: Span\n+    last_span: Span,\n+    body_id: ast::NodeId,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, body_id: ast::NodeId) -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n-            last_span: DUMMY_SP\n+            last_span: DUMMY_SP,\n+            body_id: body_id,\n+        }\n+    }\n+\n+    fn misc(&self, span: Span) -> traits::ObligationCause<'tcx> {\n+        traits::ObligationCause::misc(span, self.body_id)\n+    }\n+\n+    pub fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n+        for obligation in infer_ok.obligations {\n+            self.fulfillment_cx.register_predicate_obligation(self.infcx, obligation);\n         }\n+        infer_ok.value\n     }\n \n-    fn sub_types(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+    fn sub_types(&mut self, sup: Ty<'tcx>, sub: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, infer::TypeOrigin::Misc(span), sup, sub)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+        self.infcx.sub_types(false, &self.misc(self.last_span), sup, sub)\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n-    fn eq_types(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.eq_types(false, infer::TypeOrigin::Misc(span), a, b)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+        self.infcx.eq_types(false, &self.misc(span), a, b)\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -340,7 +357,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n+                    if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n@@ -401,7 +418,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             } => {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n@@ -418,7 +435,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, discr_ty, switch_ty) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n@@ -480,7 +497,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_call_dest(&self,\n+    fn check_call_dest(&mut self,\n                        mir: &Mir<'tcx>,\n                        term: &Terminator<'tcx>,\n                        sig: &ty::FnSig<'tcx>,\n@@ -489,7 +506,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, sig.output, dest_ty) {\n+                if let Err(terr) = self.sub_types(sig.output, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, sig.output, terr);\n@@ -504,7 +521,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_call_inputs(&self,\n+    fn check_call_inputs(&mut self,\n                          mir: &Mir<'tcx>,\n                          term: &Terminator<'tcx>,\n                          sig: &ty::FnSig<'tcx>,\n@@ -517,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -535,7 +552,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_box_free_inputs(&self,\n+    fn check_box_free_inputs(&mut self,\n                              mir: &Mir<'tcx>,\n                              term: &Terminator<'tcx>,\n                              sig: &ty::FnSig<'tcx>,\n@@ -572,7 +589,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.sub_types(self.last_span, arg_ty, pointee_ty) {\n+        if let Err(terr) = self.sub_types(arg_ty, pointee_ty) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }\n@@ -709,7 +726,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n         tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx);\n+            let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "5df8accd8cef13d024cf039be3a2b176e578c785", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -644,13 +644,13 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::CheckConst,\n-                                 &mut CheckCrateVisitor {\n-                                     tcx: tcx,\n-                                     mode: Mode::Var,\n-                                     qualif: ConstQualif::NOT_CONST,\n-                                     rvalue_borrows: NodeMap(),\n-                                 });\n+    tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n+                                      &mut CheckCrateVisitor {\n+                                          tcx: tcx,\n+                                          mode: Mode::Var,\n+                                          qualif: ConstQualif::NOT_CONST,\n+                                          rvalue_borrows: NodeMap(),\n+                                      }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "3bdaf276b40cef489bc43a4514b63f07847186e6", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -106,12 +106,20 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n \n     fn visit_nested_item(&mut self, id: hir::ItemId) {\n         let nested_item = self.krate.unwrap().item(id.id);\n         self.visit_item(nested_item)\n     }\n \n+    fn visit_nested_impl_item(&mut self, impl_item_id: hir::ImplItemId) {\n+        let nested_impl_item = self.krate.unwrap().impl_item(impl_item_id);\n+        self.visit_impl_item(nested_impl_item)\n+    }\n+\n     fn visit_item(&mut self, i: &'v hir::Item) {\n         self.record(\"Item\", Id::Node(i.id), i);\n         hir_visit::walk_item(self, i)"}, {"sha": "724100e02237f74304c0f79ab1188df519e37b58", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -33,17 +33,21 @@ struct CheckLoopVisitor<'a> {\n pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n-    krate.visit_all_items(&mut CheckLoopVisitor {\n+    krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n         cx: Normal,\n-    });\n+    }.as_deep_visitor());\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n+    fn visit_impl_item(&mut self, i: &hir::ImplItem) {\n+        self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n+    }\n+\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {"}, {"sha": "7386be2528c9b4524c2309454d76517bfd94cefc", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,20 +18,20 @@ use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::traits::Reveal;\n \n use rustc::hir;\n-use rustc::hir::intravisit;\n+use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n use syntax_pos::Span;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n-    tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n+    tcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor());\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,"}, {"sha": "5f76f865c4acaa9f42fcf042a0ca1ee414d8dcd1", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -100,7 +100,8 @@ pub fn check_crate<'ast>(sess: &Session,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n     sess.track_errors(|| {\n-        ast_map.krate().visit_all_items(&mut visitor);\n+        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n+        ast_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n     })\n }\n "}, {"sha": "75046f6aeb8742fd581b3f669bcdb30ffeb98126", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,14 +16,14 @@ use errors;\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n-impl<'v> Visitor<'v> for RegistrarFinder {\n+impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemFn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n@@ -32,6 +32,9 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n@@ -42,7 +45,7 @@ pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n     let krate = hir_map.krate();\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n-    krate.visit_all_items(&mut finder);\n+    krate.visit_all_item_likes(&mut finder);\n \n     match finder.registrars.len() {\n         0 => None,"}, {"sha": "b116408269e4dd10a3236b75ace6d4e961698295", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -31,6 +31,7 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n@@ -115,15 +116,14 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n             hir::ItemImpl(.., None, ref ty, _) => {\n@@ -158,15 +158,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     if impl_item.vis == hir::Public {\n                         self.update(impl_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     self.update(impl_item.id, item_level);\n                 }\n             }\n@@ -249,11 +251,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach().visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if self.get(impl_item.id).is_some() {\n+                    for impl_item_ref in impl_item_refs {\n+                        if self.get(impl_item_ref.id.node_id).is_some() {\n+                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                             self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n@@ -269,7 +272,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_block(&mut self, b: &'v hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let orig_level = replace(&mut self.prev_level, None);\n \n         // Blocks can have public items, for example impls, but they always\n@@ -280,7 +283,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n@@ -296,14 +299,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         intravisit::walk_mod(self, m, id);\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         self.update(md.id, Some(AccessLevel::Public));\n     }\n }\n \n impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &hir::Item, path: &hir::Path) {\n+    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, path: &'tcx hir::Path) {\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n             // See `fn is_public_type_alias` for details\n             self.visit_ty(ty);\n@@ -317,8 +320,14 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        // when we visit an impl, its methods and items are part of its \"interface\"\n+        let impl_item = self.ev.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n@@ -350,7 +359,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n         intravisit::walk_ty(self, ty);\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n         let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n@@ -412,21 +421,20 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n@@ -486,7 +494,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &hir::Pat) {\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n         // checking privacy. If you can name the type then you can pass it to an\n@@ -522,7 +530,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         self.in_foreign = true;\n         intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n@@ -616,15 +624,14 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n             // to check internals.\n@@ -649,7 +656,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_items) => {\n+            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -694,16 +701,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 // are private (because `T` won't be visible externally).\n                 let trait_or_some_public_method =\n                     trait_ref.is_some() ||\n-                    impl_items.iter()\n-                              .any(|impl_item| {\n-                                  match impl_item.node {\n-                                      hir::ImplItemKind::Const(..) |\n-                                      hir::ImplItemKind::Method(..) => {\n-                                          self.access_levels.is_reachable(impl_item.id)\n-                                      }\n-                                      hir::ImplItemKind::Type(_) => false,\n-                                  }\n-                              });\n+                    impl_item_refs.iter()\n+                                 .any(|impl_item_ref| {\n+                                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                                     match impl_item.node {\n+                                         hir::ImplItemKind::Const(..) |\n+                                         hir::ImplItemKind::Method(..) => {\n+                                             self.access_levels.is_reachable(impl_item.id)\n+                                         }\n+                                         hir::ImplItemKind::Type(_) => false,\n+                                     }\n+                                 });\n \n                 if !self_contains_private &&\n                         not_private_trait &&\n@@ -713,12 +721,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n                     match *trait_ref {\n                         None => {\n-                            for impl_item in impl_items {\n+                            for impl_item_ref in impl_item_refs {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -750,7 +759,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for impl_item in impl_items {\n+                            for impl_item_ref in impl_item_refs {\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -761,7 +771,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item in impl_items {\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, &impl_item.vis) {\n@@ -805,7 +816,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             for bound in ty_param.bounds.iter() {\n                 self.check_ty_param_bound(bound)\n@@ -826,13 +837,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         if self.access_levels.is_reachable(item.id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         if let hir::TyPath(..) = t.node {\n             if self.path_is_private_type(t.id) {\n                 self.old_error_set.insert(t.id);\n@@ -841,15 +852,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         if self.access_levels.is_reachable(v.node.data.id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         if s.vis == hir::Public || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n@@ -859,8 +873,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_block(&mut self, _: &'tcx hir::Block) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -1039,7 +1053,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let min = |vis1: ty::Visibility, vis2| {\n             if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n@@ -1085,12 +1099,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_refs) => {\n                 let ty_vis = self.ty_visibility(ty);\n                 check.required_visibility = ty_vis;\n                 check.visit_generics(generics);\n \n-                for impl_item in impl_items {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n@@ -1099,16 +1114,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_refs) => {\n                 let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n                 check.required_visibility = vis;\n                 check.visit_generics(generics);\n-                for impl_item in impl_items {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     check.visit_impl_item(impl_item);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1161,7 +1181,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx: tcx,\n             old_error_set: &visitor.old_error_set,\n         };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor);\n     }\n \n     visitor.access_levels"}, {"sha": "627c72ff8c92572c9169f57423c7eca9387c4fbc", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 92, "deletions": 60, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -15,7 +15,7 @@\n \n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use ResolveResult::Success;\n@@ -37,6 +37,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -45,15 +46,25 @@ use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, Span, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding { kind: NameBindingKind::Module(self.0), span: self.1, vis: self.2 }\n+        NameBinding {\n+            kind: NameBindingKind::Module(self.0),\n+            vis: self.1,\n+            span: self.2,\n+            expansion: self.3,\n+        }\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding { kind: NameBindingKind::Def(self.0), span: self.1, vis: self.2 }\n+        NameBinding {\n+            kind: NameBindingKind::Def(self.0),\n+            vis: self.1,\n+            span: self.2,\n+            expansion: self.3,\n+        }\n     }\n }\n \n@@ -147,9 +158,14 @@ impl<'b> Resolver<'b> {\n                                 .emit();\n                         }\n \n-                        let subclass = ImportDirectiveSubclass::single(binding.name, source.name);\n-                        let span = view_path.span;\n-                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n+                        let subclass = SingleImport {\n+                            target: binding.name,\n+                            source: source.name,\n+                            result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                        };\n+                        self.add_import_directive(\n+                            module_path, subclass, view_path.span, item.id, vis, expansion,\n+                        );\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -195,18 +211,25 @@ impl<'b> Resolver<'b> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            let (span, id) = (source_item.span, source_item.node.id);\n-                            self.add_import_directive(module_path, subclass, span, id, vis);\n+                            let subclass = SingleImport {\n+                                target: rename,\n+                                source: name,\n+                                result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                            };\n+                            let id = source_item.node.id;\n+                            self.add_import_directive(\n+                                module_path, subclass, source_item.span, id, vis, expansion,\n+                            );\n                         }\n                     }\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport {\n                             is_prelude: is_prelude,\n                             max_vis: Cell::new(ty::Visibility::PrivateExternal),\n                         };\n-                        let span = view_path.span;\n-                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n+                        self.add_import_directive(\n+                            module_path, subclass, view_path.span, item.id, vis, expansion,\n+                        );\n                     }\n                 }\n             }\n@@ -217,7 +240,7 @@ impl<'b> Resolver<'b> {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n                 let module = self.get_extern_crate_root(crate_id);\n-                let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                let binding = (module, ty::Visibility::Public, sp, expansion).to_name_binding();\n                 let binding = self.arenas.alloc_name_binding(binding);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     id: item.id,\n@@ -227,6 +250,7 @@ impl<'b> Resolver<'b> {\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n+                    expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n                 self.define(parent, name, TypeNS, imported_binding);\n@@ -245,7 +269,7 @@ impl<'b> Resolver<'b> {\n                     normal_ancestor_id: Some(item.id),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n \n                 // Descend into the module.\n@@ -258,45 +282,45 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n-                    self.build_reduced_graph_for_variant(variant, module, vis);\n+                    self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n                 }\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, sp, vis));\n+                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -310,7 +334,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -329,7 +353,7 @@ impl<'b> Resolver<'b> {\n                 // Add all the items within to a new module.\n                 let module =\n                     self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -341,37 +365,38 @@ impl<'b> Resolver<'b> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        parent: Module<'b>,\n-                                       vis: ty::Visibility) {\n+                                       vis: ty::Visibility,\n+                                       expansion: Mark) {\n         let name = variant.node.name.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, variant.span, vis));\n+        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, variant.span, vis));\n+        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = foreign_item.ident.name;\n+        let name = item.ident.name;\n \n-        let def = match foreign_item.node {\n+        let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                Def::Fn(self.definitions.local_def_id(foreign_item.id))\n+                Def::Fn(self.definitions.local_def_id(item.id))\n             }\n             ForeignItemKind::Static(_, m) => {\n-                Def::Static(self.definitions.local_def_id(foreign_item.id), m)\n+                Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n-        let vis = self.resolve_visibility(&foreign_item.vis);\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, vis));\n+        let vis = self.resolve_visibility(&item.vis);\n+        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -390,8 +415,7 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>,\n-                                                  child: Export) {\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n         let name = child.name;\n         let def = child.def;\n         let def_id = def.def_id();\n@@ -404,24 +428,24 @@ impl<'b> Resolver<'b> {\n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n@@ -433,27 +457,27 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -479,9 +503,11 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n-    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n-        let def_id = match def {\n-            Def::Macro(def_id) => def_id,\n+    pub fn get_macro(&mut self, binding: &'b NameBinding<'b>) -> Rc<SyntaxExtension> {\n+        let def_id = match binding.kind {\n+            NameBindingKind::Def(Def::Macro(def_id)) => def_id,\n+            NameBindingKind::Import { binding, .. } => return self.get_macro(binding),\n+            NameBindingKind::Ambiguity { b1, .. } => return self.get_macro(b1),\n             _ => panic!(\"Expected Def::Macro(..)\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -518,10 +544,14 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n-    fn legacy_import_macro(&mut self, name: Name, def: Def, span: Span, allow_shadowing: bool) {\n-        self.used_crates.insert(def.def_id().krate);\n+    fn legacy_import_macro(&mut self,\n+                           name: Name,\n+                           binding: &'b NameBinding<'b>,\n+                           span: Span,\n+                           allow_shadowing: bool) {\n+        self.used_crates.insert(binding.def().def_id().krate);\n         self.macro_names.insert(name);\n-        if self.builtin_macros.insert(name, def.def_id()).is_some() && !allow_shadowing {\n+        if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n@@ -548,21 +578,21 @@ impl<'b> Resolver<'b> {\n \n         if let Some(span) = legacy_imports.import_all {\n             module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+                self.legacy_import_macro(name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n                 if let Success(binding) = result {\n-                    self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+                    self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n                     span_err!(self.session, span, E0469, \"imported macro not found\");\n                 }\n             }\n         }\n         for (name, span) in legacy_imports.reexports {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n             if let Success(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -638,7 +668,9 @@ pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        let mark = Mark::from_placeholder_id(id);\n+        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n+        let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n         invocation.legacy_scope.set(self.legacy_scope);\n         invocation\n@@ -691,7 +723,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item);\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n@@ -728,7 +760,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, item.span, vis));\n+        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "492c5e695bbbb5a39740dfa64f69fe4ccb351ebf", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -22,16 +22,18 @@\n use std::ops::{Deref, DerefMut};\n \n use Resolver;\n-use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n+use rustc::util::nodemap::NodeMap;\n use syntax::ast::{self, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n \n \n struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n+    /// All the (so far) unused imports, grouped path list\n+    unused_imports: NodeMap<NodeMap<Span>>,\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n@@ -52,23 +54,22 @@ impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n-    fn check_import(&mut self, id: ast::NodeId, span: Span) {\n-        if !self.used_imports.contains(&(id, TypeNS)) &&\n-           !self.used_imports.contains(&(id, ValueNS)) {\n+    fn check_import(&mut self, item_id: ast::NodeId, id: ast::NodeId, span: Span) {\n+        let mut used = false;\n+        self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        if !used {\n             if self.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;\n             }\n-            let msg = if let Ok(snippet) = self.session.codemap().span_to_snippet(span) {\n-                format!(\"unused import: `{}`\", snippet)\n-            } else {\n-                \"unused import\".to_string()\n-            };\n-            self.session.add_lint(lint::builtin::UNUSED_IMPORTS, id, span, msg);\n+            self.unused_imports.entry(item_id).or_insert_with(NodeMap).insert(id, span);\n         } else {\n             // This trait import is definitely used, in a way other than\n             // method resolution.\n             self.maybe_unused_trait_imports.remove(&id);\n+            if let Some(i) = self.unused_imports.get_mut(&item_id) {\n+                i.remove(&id);\n+            }\n         }\n     }\n }\n@@ -98,16 +99,16 @@ impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n             ast::ItemKind::Use(ref p) => {\n                 match p.node {\n                     ViewPathSimple(..) => {\n-                        self.check_import(item.id, p.span)\n+                        self.check_import(item.id, item.id, p.span)\n                     }\n \n                     ViewPathList(_, ref list) => {\n                         for i in list {\n-                            self.check_import(i.node.id, i.span);\n+                            self.check_import(item.id, i.node.id, i.span);\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.check_import(item.id, p.span)\n+                        self.check_import(item.id, item.id, p.span);\n                     }\n                 }\n             }\n@@ -117,6 +118,35 @@ impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n }\n \n pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n-    let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n+    let mut visitor = UnusedImportCheckVisitor {\n+        resolver: resolver,\n+        unused_imports: NodeMap(),\n+    };\n     visit::walk_crate(&mut visitor, krate);\n+\n+    for (id, spans) in &visitor.unused_imports {\n+        let len = spans.len();\n+        let mut spans = spans.values().map(|s| *s).collect::<Vec<Span>>();\n+        spans.sort();\n+        let ms = MultiSpan::from_spans(spans.clone());\n+        let mut span_snippets = spans.iter()\n+            .filter_map(|s| {\n+                match visitor.session.codemap().span_to_snippet(*s) {\n+                    Ok(s) => Some(format!(\"`{}`\", s)),\n+                    _ => None,\n+                }\n+            }).collect::<Vec<String>>();\n+        span_snippets.sort();\n+        let msg = format!(\"unused import{}{}\",\n+                          if len > 1 { \"s\" } else { \"\" },\n+                          if span_snippets.len() > 0 {\n+                              format!(\": {}\", span_snippets.join(\", \"))\n+                          } else {\n+                              String::new()\n+                          });\n+        visitor.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n+                                 *id,\n+                                 ms,\n+                                 msg);\n+    }\n }"}, {"sha": "a3a60e4f6d7548abe5d2f6787ba0bab13437a381", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 144, "deletions": 101, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -76,7 +76,7 @@ use std::fmt;\n use std::mem::replace;\n use std::rc::Rc;\n \n-use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution};\n+use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -536,6 +536,34 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+#[derive(Clone, Default, Debug)]\n+pub struct PerNS<T> {\n+    value_ns: T,\n+    type_ns: T,\n+    macro_ns: Option<T>,\n+}\n+\n+impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n+    type Output = T;\n+    fn index(&self, ns: Namespace) -> &T {\n+        match ns {\n+            ValueNS => &self.value_ns,\n+            TypeNS => &self.type_ns,\n+            MacroNS => self.macro_ns.as_ref().unwrap(),\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut T {\n+        match ns {\n+            ValueNS => &mut self.value_ns,\n+            TypeNS => &mut self.type_ns,\n+            MacroNS => self.macro_ns.as_mut().unwrap(),\n+        }\n+    }\n+}\n+\n impl<'a> Visitor for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n@@ -612,7 +640,7 @@ impl<'a> Visitor for Resolver<'a> {\n         };\n \n         // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n+        self.ribs[ValueNS].push(Rib::new(rib_kind));\n \n         // Create a label rib for the function.\n         self.label_ribs.push(Rib::new(rib_kind));\n@@ -642,28 +670,20 @@ impl<'a> Visitor for Resolver<'a> {\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n }\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n     Success(T), // Successfully resolved the import.\n }\n \n impl<T> ResolveResult<T> {\n-    fn and_then<U, F: FnOnce(T) -> ResolveResult<U>>(self, f: F) -> ResolveResult<U> {\n-        match self {\n-            Failed(msg) => Failed(msg),\n-            Indeterminate => Indeterminate,\n-            Success(t) => f(t),\n-        }\n-    }\n-\n     fn success(self) -> Option<T> {\n         match self {\n             Success(t) => Some(t),\n@@ -798,6 +818,10 @@ pub struct ModuleS<'a> {\n     normal_ancestor_id: Option<NodeId>,\n \n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+\n+    // Macro invocations that can expand into items in this module.\n+    unresolved_invocations: RefCell<FxHashSet<Mark>>,\n \n     no_implicit_prelude: bool,\n \n@@ -822,6 +846,8 @@ impl<'a> ModuleS<'a> {\n             kind: kind,\n             normal_ancestor_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n+            legacy_macro_resolutions: RefCell::new(Vec::new()),\n+            unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -877,6 +903,7 @@ impl<'a> fmt::Debug for ModuleS<'a> {\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n+    expansion: Mark,\n     span: Span,\n     vis: ty::Visibility,\n }\n@@ -911,6 +938,7 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n struct AmbiguityError<'a> {\n     span: Span,\n     name: Name,\n+    lexical: bool,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n }\n@@ -969,7 +997,7 @@ impl<'a> NameBinding<'a> {\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { directive, .. } => directive.is_glob(),\n-            NameBindingKind::Ambiguity { .. } => true,\n+            NameBindingKind::Ambiguity { b1, .. } => b1.is_glob_import(),\n             _ => false,\n         }\n     }\n@@ -1044,12 +1072,9 @@ pub struct Resolver<'a> {\n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The current set of local scopes, for values.\n+    // The current set of local scopes for types and values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: Vec<Rib<'a>>,\n-\n-    // The current set of local scopes, for types.\n-    type_ribs: Vec<Rib<'a>>,\n+    ribs: PerNS<Vec<Rib<'a>>>,\n \n     // The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a>>,\n@@ -1107,17 +1132,21 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n+    use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, DefId>,\n+    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_exports: Vec<Export>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n+\n+    // Avoid duplicated errors for \"name already defined\".\n+    name_already_seen: FxHashMap<Name, Span>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1265,8 +1294,11 @@ impl<'a> Resolver<'a> {\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n-            value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n-            type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: None,\n+            },\n             label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n@@ -1297,10 +1329,12 @@ impl<'a> Resolver<'a> {\n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n+                expansion: Mark::root(),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n+            use_extern_macros: session.features.borrow().use_extern_macros,\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n@@ -1310,6 +1344,7 @@ impl<'a> Resolver<'a> {\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n             invocations: invocations,\n+            name_already_seen: FxHashMap(),\n         }\n     }\n \n@@ -1325,8 +1360,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> {\n+        PerNS {\n+            type_ns: f(self, TypeNS),\n+            value_ns: f(self, ValueNS),\n+            macro_ns: match self.use_extern_macros {\n+                true => Some(f(self, MacroNS)),\n+                false => None,\n+            },\n+        }\n+    }\n+\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n+        ImportResolver { resolver: self }.finalize_imports();\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n \n@@ -1343,14 +1390,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n-        match ns {\n-            ValueNS => &mut self.value_ribs,\n-            TypeNS => &mut self.type_ribs,\n-            MacroNS => panic!(\"The macro namespace has no ribs\"),\n-        }\n-    }\n-\n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n@@ -1367,8 +1406,9 @@ impl<'a> Resolver<'a> {\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n-                let ambiguity_error = AmbiguityError { span: span, name: name, b1: b1, b2: b2 };\n-                self.ambiguity_errors.push(ambiguity_error);\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    span: span, name: name, lexical: false, b1: b1, b2: b2,\n+                });\n                 true\n             }\n             _ => false\n@@ -1402,7 +1442,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n                     search_parent_externals(this, needle, parent)\n@@ -1420,7 +1460,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1566,18 +1606,18 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Walk backwards up the ribs in scope.\n-        for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n+        for i in (0 .. self.ribs[ns].len()).rev() {\n+            if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n                     def: def,\n                 }));\n             }\n \n-            if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n+            if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n+                let item = self.resolve_name_in_module(module, name, ns, true, false, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1586,14 +1626,14 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n                 }\n             }\n \n-            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+            if let MacroDefinition(mac) = self.ribs[ns][i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 let (source_ctxt, source_macro) = ident.ctxt.source();\n@@ -1678,14 +1718,15 @@ impl<'a> Resolver<'a> {\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.current_module, module);\n-            self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n+            self.finalize_current_module_macro_resolutions();\n             f(self);\n \n             self.current_module = orig_module;\n-            self.value_ribs.pop();\n-            self.type_ribs.pop();\n+            self.ribs[ValueNS].pop();\n+            self.ribs[TypeNS].pop();\n         } else {\n             f(self);\n         }\n@@ -1860,7 +1901,7 @@ impl<'a> Resolver<'a> {\n                     function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n-                self.type_ribs.push(function_type_rib);\n+                self.ribs[TypeNS].push(function_type_rib);\n             }\n \n             NoTypeParameters => {\n@@ -1871,7 +1912,7 @@ impl<'a> Resolver<'a> {\n         f(self);\n \n         if let HasTypeParameters(..) = type_parameters {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n     }\n \n@@ -1886,11 +1927,11 @@ impl<'a> Resolver<'a> {\n     fn with_constant_rib<F>(&mut self, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        self.value_ribs.push(Rib::new(ConstantItemRibKind));\n-        self.type_ribs.push(Rib::new(ConstantItemRibKind));\n+        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n+        self.ribs[TypeNS].push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        self.type_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -2000,9 +2041,9 @@ impl<'a> Resolver<'a> {\n \n         // plain insert (no renaming, types are not currently hygienic....)\n         self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n-        self.type_ribs.push(self_type_rib);\n+        self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n-        self.type_ribs.pop();\n+        self.ribs[TypeNS].pop();\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2156,7 +2197,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.value_ribs.push(Rib::new(NormalRibKind));\n+        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n@@ -2170,7 +2211,7 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n \n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2182,19 +2223,20 @@ impl<'a> Resolver<'a> {\n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.current_module = anonymous_module;\n+            self.finalize_current_module_macro_resolutions();\n         } else {\n-            self.value_ribs.push(Rib::new(NormalRibKind));\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n             if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n                 num_macro_definition_ribs += marks.len() as u32;\n                 for mark in marks {\n-                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n                 }\n             }\n@@ -2205,12 +2247,12 @@ impl<'a> Resolver<'a> {\n         // Move back up.\n         self.current_module = orig_module;\n         for _ in 0 .. num_macro_definition_ribs {\n-            self.value_ribs.pop();\n+            self.ribs[ValueNS].pop();\n             self.label_ribs.pop();\n         }\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n         if let Some(_) = anonymous_module {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -2329,7 +2371,7 @@ impl<'a> Resolver<'a> {\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n+                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2339,7 +2381,7 @@ impl<'a> Resolver<'a> {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n                     bindings.insert(ident.node, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n             }\n         }\n@@ -2623,9 +2665,8 @@ impl<'a> Resolver<'a> {\n     // Resolve a local definition, potentially adjusting for closures.\n     fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Option<Def> {\n         let ribs = match local_def.ribs {\n-            Some((TypeNS, i)) => &self.type_ribs[i + 1..],\n-            Some((ValueNS, i)) => &self.value_ribs[i + 1..],\n-            _ => &[] as &[_],\n+            Some((ns, i)) => &self.ribs[ns][i + 1..],\n+            None => &[] as &[_],\n         };\n         let mut def = local_def.def;\n         match def {\n@@ -2719,23 +2760,19 @@ impl<'a> Resolver<'a> {\n         let module_path =\n             segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n-        let containing_module;\n-        match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n+        let module = match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 return Err(true);\n             }\n             Indeterminate => return Err(false),\n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2747,10 +2784,9 @@ impl<'a> Resolver<'a> {\n         where T: Named,\n     {\n         let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n-        let root_module = self.graph_root;\n+        let root = self.graph_root;\n \n-        let containing_module;\n-        match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n+        let module = match self.resolve_module_path_from_root(root, &module_path, 0, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -2760,14 +2796,11 @@ impl<'a> Resolver<'a> {\n \n             Indeterminate => return Err(false),\n \n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2787,22 +2820,20 @@ impl<'a> Resolver<'a> {\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n         self.with_empty_ribs(|this| {\n-            this.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            this.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n             f(this)\n         })\n     }\n \n     fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n-        let value_ribs = replace(&mut self.value_ribs, Vec::new());\n-        let type_ribs = replace(&mut self.type_ribs, Vec::new());\n+        let ribs = replace(&mut self.ribs, PerNS::<Vec<Rib>>::default());\n         let label_ribs = replace(&mut self.label_ribs, Vec::new());\n \n         let result = f(self);\n-        self.value_ribs = value_ribs;\n-        self.type_ribs = type_ribs;\n+        self.ribs = ribs;\n         self.label_ribs = label_ribs;\n         result\n     }\n@@ -2854,7 +2885,7 @@ impl<'a> Resolver<'a> {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n-        let names = self.value_ribs\n+        let names = self.ribs[ValueNS]\n                     .iter()\n                     .rev()\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n@@ -2957,7 +2988,7 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             let mut method_scope = false;\n                             let mut is_static = false;\n-                            self.value_ribs.iter().rev().all(|rib| {\n+                            self.ribs[ValueNS].iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n                                     MethodRibKind(is_static_) => {\n                                         is_static = is_static_;\n@@ -3068,10 +3099,10 @@ impl<'a> Resolver<'a> {\n             ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n                 self.visit_expr(subexpression);\n \n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n \n                 optional_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n@@ -3085,22 +3116,22 @@ impl<'a> Resolver<'a> {\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::Field(ref subexpression, _) => {\n@@ -3350,14 +3381,18 @@ impl<'a> Resolver<'a> {\n         self.report_shadowing_errors();\n         let mut reported_spans = FxHashSet();\n \n-        for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n+        for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n             let msg1 = format!(\"`{}` could resolve to the name imported here\", name);\n             let msg2 = format!(\"`{}` could also resolve to the name imported here\", name);\n             self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n                 .span_note(b1.span, &msg1)\n                 .span_note(b2.span, &msg2)\n-                .note(&format!(\"Consider adding an explicit import of `{}` to disambiguate\", name))\n+                .note(&if lexical || !b1.is_glob_import() {\n+                    \"macro-expanded macro imports do not shadow\".to_owned()\n+                } else {\n+                    format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n+                })\n                 .emit();\n         }\n \n@@ -3380,12 +3415,12 @@ impl<'a> Resolver<'a> {\n \n     fn report_shadowing_errors(&mut self) {\n         for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n-            self.resolve_macro_name(scope, name);\n+            self.resolve_legacy_scope(scope, name, true);\n         }\n \n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n+            if self.resolve_legacy_scope(binding.parent, binding.name, false).is_some() &&\n                reported_errors.insert((binding.name, binding.span)) {\n                 let msg = format!(\"`{}` is already in scope\", binding.name);\n                 self.session.struct_span_err(binding.span, &msg)\n@@ -3396,7 +3431,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn report_conflict(&self,\n+    fn report_conflict(&mut self,\n                        parent: Module,\n                        name: Name,\n                        ns: Namespace,\n@@ -3420,6 +3455,13 @@ impl<'a> Resolver<'a> {\n         };\n \n         let span = binding.span;\n+\n+        if let Some(s) = self.name_already_seen.get(&name) {\n+            if s == &span {\n+                return;\n+            }\n+        }\n+\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n@@ -3472,6 +3514,7 @@ impl<'a> Resolver<'a> {\n             err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();\n+        self.name_already_seen.insert(name, span);\n     }\n }\n "}, {"sha": "524d491a464e2525e178cb531e830edd5befa535", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 142, "deletions": 31, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Module, ModuleKind, Resolver};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n+use Namespace::{self, MacroNS};\n+use ResolveResult::{Success, Indeterminate, Failed};\n use build_reduced_graph::BuildReducedGraphVisitor;\n+use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n@@ -27,7 +31,7 @@ use syntax::parse::token::intern;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n@@ -83,6 +87,11 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+pub enum MacroBinding<'a> {\n+    Legacy(&'a LegacyBinding<'a>),\n+    Modern(&'a NameBinding<'a>),\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -131,12 +140,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.collect_def_ids(invocation, expansion);\n \n         self.current_module = invocation.module.get();\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             legacy_scope: LegacyScope::Invocation(invocation),\n             expansion: mark,\n         };\n         expansion.visit_with(&mut visitor);\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -177,18 +188,28 @@ impl<'a> base::Resolver for Resolver<'a> {\n             index: DefIndex::new(self.macro_map.len()),\n         };\n         self.macro_map.insert(def_id, ext);\n-        self.builtin_macros.insert(ident.name, def_id);\n+        let binding = self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Def(Def::Macro(def_id)),\n+            span: DUMMY_SP,\n+            vis: ty::Visibility::PrivateExternal,\n+            expansion: Mark::root(),\n+        });\n+        self.builtin_macros.insert(ident.name, binding);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n         self.macros_at_scope.insert(id, macros);\n     }\n \n+    fn resolve_imports(&mut self) {\n+        ImportResolver { resolver: self }.resolve_imports()\n+    }\n+\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.builtin_macros.get(&name) {\n-                Some(&def_id) => match *self.get_macro(Def::Macro(def_id)) {\n+            match self.builtin_macros.get(&name).cloned() {\n+                Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -212,25 +233,81 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n-        self.resolve_macro_name(invocation.legacy_scope.get(), name).ok_or_else(|| {\n-            if force {\n-                let msg = format!(\"macro undefined: '{}!'\", name);\n-                let mut err = self.session.struct_span_err(path.span, &msg);\n-                self.suggest_macro_name(&name.as_str(), &mut err);\n-                err.emit();\n-                Determinacy::Determined\n-            } else {\n-                Determinacy::Undetermined\n-            }\n-        })\n+\n+        self.current_module = invocation.module.get();\n+        let result = match self.resolve_legacy_scope(invocation.legacy_scope.get(), name, false) {\n+            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n+            Some(MacroBinding::Modern(binding)) => Ok(self.get_macro(binding)),\n+            None => match self.resolve_in_item_lexical_scope(name, MacroNS, None) {\n+                Some(binding) => Ok(self.get_macro(binding)),\n+                None => return Err(if force {\n+                    let msg = format!(\"macro undefined: '{}!'\", name);\n+                    let mut err = self.session.struct_span_err(path.span, &msg);\n+                    self.suggest_macro_name(&name.as_str(), &mut err);\n+                    err.emit();\n+                    Determinacy::Determined\n+                } else {\n+                    Determinacy::Undetermined\n+                }),\n+            },\n+        };\n+\n+        if self.use_extern_macros {\n+            self.current_module.legacy_macro_resolutions.borrow_mut()\n+                .push((scope, name, path.span));\n+        }\n+        result\n     }\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, mut scope: LegacyScope<'a>, name: ast::Name)\n-                              -> Option<Rc<SyntaxExtension>> {\n+    // Resolve the name in the module's lexical scope, excluding non-items.\n+    fn resolve_in_item_lexical_scope(&mut self,\n+                                     name: Name,\n+                                     ns: Namespace,\n+                                     record_used: Option<Span>)\n+                                     -> Option<&'a NameBinding<'a>> {\n+        let mut module = self.current_module;\n+        let mut potential_expanded_shadower = None;\n+        loop {\n+            // Since expanded macros may not shadow the lexical scope (enforced below),\n+            // we can ignore unresolved invocations (indicated by the penultimate argument).\n+            match self.resolve_name_in_module(module, name, ns, true, true, record_used) {\n+                Success(binding) => {\n+                    let span = match record_used {\n+                        Some(span) => span,\n+                        None => return Some(binding),\n+                    };\n+                    if let Some(shadower) = potential_expanded_shadower {\n+                        self.ambiguity_errors.push(AmbiguityError {\n+                            span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                        });\n+                        return Some(shadower);\n+                    } else if binding.expansion == Mark::root() {\n+                        return Some(binding);\n+                    } else {\n+                        potential_expanded_shadower = Some(binding);\n+                    }\n+                },\n+                Indeterminate => return None,\n+                Failed(..) => {}\n+            }\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => module = module.parent.unwrap(),\n+                ModuleKind::Def(..) => return potential_expanded_shadower,\n+            }\n+        }\n+    }\n+\n+    pub fn resolve_legacy_scope(&mut self,\n+                                mut scope: LegacyScope<'a>,\n+                                name: Name,\n+                                record_used: bool)\n+                                -> Option<MacroBinding<'a>> {\n         let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n+        let mut binding = None;\n         loop {\n             scope = match scope {\n                 LegacyScope::Empty => break,\n@@ -249,25 +326,59 @@ impl<'a> Resolver<'a> {\n                     relative_depth = relative_depth.saturating_sub(1);\n                     invocation.legacy_scope.get()\n                 }\n-                LegacyScope::Binding(binding) => {\n-                    if binding.name == name {\n-                        if let Some(scope) = possible_time_travel {\n-                            // Check for disallowed shadowing later\n-                            self.lexical_macro_resolutions.push((name, scope));\n-                        } else if relative_depth > 0 {\n-                            self.disallowed_shadowing.push(binding);\n+                LegacyScope::Binding(potential_binding) => {\n+                    if potential_binding.name == name {\n+                        if (!self.use_extern_macros || record_used) && relative_depth > 0 {\n+                            self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        return Some(binding.ext.clone());\n+                        binding = Some(potential_binding);\n+                        break\n                     }\n-                    binding.parent\n+                    potential_binding.parent\n                 }\n             };\n         }\n \n-        if let Some(scope) = possible_time_travel {\n-            self.lexical_macro_resolutions.push((name, scope));\n+        let binding = match binding {\n+            Some(binding) => MacroBinding::Legacy(binding),\n+            None => match self.builtin_macros.get(&name).cloned() {\n+                Some(binding) => MacroBinding::Modern(binding),\n+                None => return None,\n+            },\n+        };\n+\n+        if !self.use_extern_macros {\n+            if let Some(scope) = possible_time_travel {\n+                // Check for disallowed shadowing later\n+                self.lexical_macro_resolutions.push((name, scope));\n+            }\n+        }\n+\n+        Some(binding)\n+    }\n+\n+    pub fn finalize_current_module_macro_resolutions(&mut self) {\n+        let module = self.current_module;\n+        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+            let legacy_scope = self.invocations[&mark].legacy_scope.get();\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n+            let resolution = self.resolve_in_item_lexical_scope(name, MacroNS, Some(span));\n+            let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n+                (Some(legacy_resolution), Some(resolution)) => (legacy_resolution, resolution),\n+                _ => continue,\n+            };\n+            let (legacy_span, participle) = match legacy_resolution {\n+                MacroBinding::Modern(binding) if binding.def() == resolution.def() => continue,\n+                MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n+                MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+            };\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+                .span_note(legacy_span, &msg1)\n+                .span_note(resolution.span, &msg2)\n+                .emit();\n         }\n-        self.builtin_macros.get(&name).cloned().map(|def_id| self.get_macro(Def::Macro(def_id)))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "d0ce1acaadf62128434b5b2f2469f981eec80977", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 161, "deletions": 184, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -10,8 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use Module;\n-use Namespace::{self, TypeNS, ValueNS};\n+use {Module, PerNS};\n+use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n@@ -26,26 +26,20 @@ use rustc::hir::def::*;\n \n use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n+use syntax::ext::hygiene::Mark;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n use std::mem;\n \n-impl<'a> Resolver<'a> {\n-    pub fn resolve_imports(&mut self) {\n-        ImportResolver { resolver: self }.resolve_imports();\n-    }\n-}\n-\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n         target: Name,\n         source: Name,\n-        value_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n-        type_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n+        result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n         is_prelude: bool,\n@@ -55,17 +49,6 @@ pub enum ImportDirectiveSubclass<'a> {\n     ExternCrate,\n }\n \n-impl<'a> ImportDirectiveSubclass<'a> {\n-    pub fn single(target: Name, source: Name) -> Self {\n-        SingleImport {\n-            target: target,\n-            source: source,\n-            type_result: Cell::new(Err(Undetermined)),\n-            value_result: Cell::new(Err(Undetermined)),\n-        }\n-    }\n-}\n-\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n@@ -76,6 +59,7 @@ pub struct ImportDirective<'a> {\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n     pub vis: Cell<ty::Visibility>,\n+    pub expansion: Mark,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -158,6 +142,7 @@ impl<'a> Resolver<'a> {\n                                   name: Name,\n                                   ns: Namespace,\n                                   allow_private_imports: bool,\n+                                  ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n         self.populate_module_if_necessary(module);\n@@ -191,66 +176,65 @@ impl<'a> Resolver<'a> {\n             return resolution.binding.map(Success).unwrap_or(Failed(None));\n         }\n \n-        // If the resolution doesn't depend on glob definability, check privacy and return.\n-        if let Some(result) = self.try_result(&resolution, ns) {\n-            return result.and_then(|binding| {\n-                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n-                   binding.is_extern_crate() { // c.f. issue #37020\n-                    Success(binding)\n-                } else {\n-                    Failed(None)\n-                }\n-            });\n-        }\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            let usable =\n+                this.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n+                binding.is_extern_crate(); // c.f. issue #37020\n+            if usable { Success(binding) } else { Failed(None) }\n+        };\n \n-        // Check if the globs are determined\n-        for directive in module.globs.borrow().iter() {\n-            if self.is_accessible(directive.vis.get()) {\n-                if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, true, None);\n-                    if let Indeterminate = result {\n-                        return Indeterminate;\n-                    }\n-                } else {\n-                    return Indeterminate;\n-                }\n+        // Items and single imports are not shadowable.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n             }\n         }\n \n-        Failed(None)\n-    }\n-\n-    // Returns Some(the resolution of the name), or None if the resolution depends\n-    // on whether more globs can define the name.\n-    fn try_result(&mut self, resolution: &NameResolution<'a>, ns: Namespace)\n-                  -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match resolution.binding {\n-            Some(binding) if !binding.is_glob_import() =>\n-                return Some(Success(binding)), // Items and single imports are not shadowable.\n-            _ => {}\n-        };\n-\n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::AtLeastOne => return Indeterminate,\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n                 let module = match directive.imported_module.get() {\n                     Some(module) => module,\n-                    None => return Some(Indeterminate),\n+                    None => return Indeterminate,\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, true, None) {\n+                match self.resolve_name_in_module(module, name, ns, true, false, None) {\n                     Failed(_) => {}\n-                    _ => return Some(Indeterminate),\n+                    _ => return Indeterminate,\n                 }\n             }\n             SingleImports::MaybeOne(_) | SingleImports::None => {},\n         }\n \n-        resolution.binding.map(Success)\n+        let no_unresolved_invocations =\n+            ignore_unresolved_invocations || module.unresolved_invocations.borrow().is_empty();\n+        match resolution.binding {\n+            // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n+            Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n+                return check_usable(self, binding),\n+            None if no_unresolved_invocations => {}\n+            _ => return Indeterminate,\n+        }\n+\n+        // Check if the globs are determined\n+        for directive in module.globs.borrow().iter() {\n+            if self.is_accessible(directive.vis.get()) {\n+                if let Some(module) = directive.imported_module.get() {\n+                    let result = self.resolve_name_in_module(module, name, ns, true, false, None);\n+                    if let Indeterminate = result {\n+                        return Indeterminate;\n+                    }\n+                } else {\n+                    return Indeterminate;\n+                }\n+            }\n+        }\n+\n+        Failed(None)\n     }\n \n     // Add an import directive to the current module.\n@@ -259,7 +243,8 @@ impl<'a> Resolver<'a> {\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n-                                vis: ty::Visibility) {\n+                                vis: ty::Visibility,\n+                                expansion: Mark) {\n         let current_module = self.current_module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent: current_module,\n@@ -269,15 +254,16 @@ impl<'a> Resolver<'a> {\n             span: span,\n             id: id,\n             vis: Cell::new(vis),\n+            expansion: expansion,\n         });\n \n         self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n-                for &ns in &[ValueNS, TypeNS] {\n-                    let mut resolution = self.resolution(current_module, target, ns).borrow_mut();\n+                self.per_ns(|this, ns| {\n+                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n                     resolution.single_imports.add_directive(directive);\n-                }\n+                });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n@@ -312,6 +298,7 @@ impl<'a> Resolver<'a> {\n             },\n             span: directive.span,\n             vis: vis,\n+            expansion: directive.expansion,\n         }\n     }\n \n@@ -324,28 +311,26 @@ impl<'a> Resolver<'a> {\n         self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    if !this.new_import_semantics || !old_binding.is_glob_import() {\n+                    if !this.new_import_semantics {\n                         resolution.duplicate_globs.push(binding);\n+                    } else if !old_binding.is_glob_import() &&\n+                              !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                     } else if binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.arenas.alloc_name_binding(NameBinding {\n-                            kind: NameBindingKind::Ambiguity {\n-                                b1: old_binding,\n-                                b2: binding,\n-                            },\n-                            vis: if old_binding.vis.is_at_least(binding.vis, this) {\n-                                old_binding.vis\n-                            } else {\n-                                binding.vis\n-                            },\n-                            span: old_binding.span,\n-                        }));\n+                        resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n                 } else if old_binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(old_binding);\n-                    resolution.binding = Some(binding);\n+                    if !this.new_import_semantics {\n+                        resolution.duplicate_globs.push(old_binding);\n+                        resolution.binding = Some(binding);\n+                    } else if ns == MacroNS && binding.expansion != Mark::root() &&\n+                              binding.def() != old_binding.def() {\n+                        resolution.binding = Some(this.ambiguity(binding, old_binding));\n+                    } else {\n+                        resolution.binding = Some(binding);\n+                    }\n                 } else {\n                     return Err(old_binding);\n                 }\n@@ -357,6 +342,16 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    pub fn ambiguity(&mut self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+                 -> &'a NameBinding<'a> {\n+        self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Ambiguity { b1: b1, b2: b2 },\n+            vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n+            span: b1.span,\n+            expansion: Mark::root(),\n+        })\n+    }\n+\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n@@ -393,10 +388,22 @@ impl<'a> Resolver<'a> {\n \n         t\n     }\n+\n+    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n+    // failed resolution\n+    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n+        if let SingleImport { target, .. } = directive.subclass {\n+            let dummy_binding = self.dummy_binding;\n+            let dummy_binding = self.import(dummy_binding, directive);\n+            self.per_ns(|this, ns| {\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+            });\n+        }\n+    }\n }\n \n-struct ImportResolver<'a, 'b: 'a> {\n-    resolver: &'a mut Resolver<'b>,\n+pub struct ImportResolver<'a, 'b: 'a> {\n+    pub resolver: &'a mut Resolver<'b>,\n }\n \n impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> {\n@@ -429,28 +436,21 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    fn resolve_imports(&mut self) {\n-        let mut i = 0;\n+    pub fn resolve_imports(&mut self) {\n         let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-\n         while self.indeterminate_imports.len() < prev_num_indeterminates {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n-            debug!(\"(resolving imports) iteration {}, {} imports left\", i, prev_num_indeterminates);\n-\n-            let mut imports = Vec::new();\n-            ::std::mem::swap(&mut imports, &mut self.indeterminate_imports);\n-\n-            for import in imports {\n+            for import in mem::replace(&mut self.indeterminate_imports, Vec::new()) {\n                 match self.resolve_import(&import) {\n                     Failed(_) => self.determined_imports.push(import),\n                     Indeterminate => self.indeterminate_imports.push(import),\n                     Success(()) => self.determined_imports.push(import),\n                 }\n             }\n-\n-            i += 1;\n         }\n+    }\n \n+    pub fn finalize_imports(&mut self) {\n         for module in self.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n@@ -484,17 +484,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n-    // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'b ImportDirective<'b>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n-            let _ = self.try_define(directive.parent, target, ValueNS, dummy_binding.clone());\n-            let _ = self.try_define(directive.parent, target, TypeNS, dummy_binding);\n-        }\n-    }\n-\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -526,9 +515,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, target, ref value_result, ref type_result } =>\n-                (source, target, value_result, type_result),\n+        let (source, target, result) = match directive.subclass {\n+            SingleImport { source, target, ref result } => (source, target, result),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n@@ -537,46 +525,45 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Err(Undetermined) = result.get() {\n-                result.set({\n-                    match self.resolve_name_in_module(module, source, ns, false, None) {\n+        self.per_ns(|this, ns| {\n+            if let Err(Undetermined) = result[ns].get() {\n+                result[ns].set({\n+                    match this.resolve_name_in_module(module, source, ns, false, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n                     }\n                 });\n             } else {\n-                continue\n+                return\n             };\n \n-            match result.get() {\n+            match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    self.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n-                    struct_span_err!(self.session, directive.span, E0253, \"{}\", &msg)\n+                    struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n                         .span_label(directive.span, &format!(\"cannot be imported directly\"))\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(directive);\n-                    return Success(());\n+                    this.import_dummy_binding(directive);\n                 }\n                 Ok(binding) => {\n-                    let imported_binding = self.import(binding, directive);\n-                    let conflict = self.try_define(directive.parent, target, ns, imported_binding);\n+                    let imported_binding = this.import(binding, directive);\n+                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &self.import(binding, directive);\n-                        self.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        let binding = &this.import(binding, directive);\n+                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n                     }\n                 }\n             }\n-        }\n+        });\n \n         if indeterminate { Indeterminate } else { Success(()) }\n     }\n@@ -604,9 +591,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             },\n         };\n \n-        let (name, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, ref value_result, ref type_result, .. } =>\n-                (source, value_result.get(), type_result.get()),\n+        let (name, result) = match directive.subclass {\n+            SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n                 let msg = \"Cannot glob-import a module into itself.\".into();\n@@ -624,21 +610,27 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Ok(binding) = result {\n-                if self.record_use(name, ns, binding, directive.span) {\n-                    self.resolution(module, name, ns).borrow_mut().binding =\n-                        Some(self.dummy_binding);\n+        let mut all_ns_err = true;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n+                all_ns_err = false;\n+                if this.record_use(name, ns, binding, directive.span) {\n+                    this.resolution(module, name, ns).borrow_mut().binding =\n+                        Some(this.dummy_binding);\n                 }\n             }\n-        }\n+        });\n \n-        if value_result.is_err() && type_result.is_err() {\n-            let (value_result, type_result);\n-            value_result = self.resolve_name_in_module(module, name, ValueNS, false, Some(span));\n-            type_result = self.resolve_name_in_module(module, name, TypeNS, false, Some(span));\n+        if all_ns_err {\n+            let mut all_ns_failed = true;\n+            self.per_ns(|this, ns| {\n+                match this.resolve_name_in_module(module, name, ns, false, false, Some(span)) {\n+                    Success(_) => all_ns_failed = false,\n+                    _ => {}\n+                }\n+            });\n \n-            return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n+            return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n                     if *n == name { return None; } // Never suggest the same name\n@@ -666,64 +658,49 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n-        let session = self.session;\n-        let reexport_error = || {\n-            let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n-            let note_msg =\n-                format!(\"consider marking `{}` as `pub` in the imported module\", name);\n-            struct_span_err!(session, directive.span, E0364, \"{}\", &msg)\n-                .span_note(directive.span, &note_msg)\n-                .emit();\n-        };\n-\n-        let extern_crate_lint = || {\n-            let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                               (error E0364), consider declaring with `pub`\",\n-                               name);\n-            session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n-        };\n-\n-        match (value_result, type_result) {\n-            // All namespaces must be re-exported with extra visibility for an error to occur.\n-            (Ok(value_binding), Ok(type_binding)) => {\n+        let mut reexport_error = None;\n+        let mut any_successful_reexport = false;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n                 let vis = directive.vis.get();\n-                if !value_binding.pseudo_vis().is_at_least(vis, self) &&\n-                   !type_binding.pseudo_vis().is_at_least(vis, self) {\n-                    reexport_error();\n-                } else if type_binding.is_extern_crate() &&\n-                          !type_binding.vis.is_at_least(vis, self) {\n-                    extern_crate_lint();\n-                }\n-            }\n-\n-            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                reexport_error();\n-            }\n-\n-            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                if binding.is_extern_crate() {\n-                    extern_crate_lint();\n+                if !binding.pseudo_vis().is_at_least(vis, this) {\n+                    reexport_error = Some((ns, binding));\n                 } else {\n-                    struct_span_err!(self.session, directive.span, E0365,\n-                                     \"`{}` is private, and cannot be reexported\", name)\n-                        .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n-                        .emit();\n+                    any_successful_reexport = true;\n                 }\n             }\n+        });\n \n-            _ => {}\n+        // All namespaces must be re-exported with extra visibility for an error to occur.\n+        if !any_successful_reexport {\n+            let (ns, binding) = reexport_error.unwrap();\n+            if ns == TypeNS && binding.is_extern_crate() {\n+                let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                   (error E0364), consider declaring with `pub`\",\n+                                   name);\n+                self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n+            } else if ns == TypeNS {\n+                struct_span_err!(self.session, directive.span, E0365,\n+                                 \"`{}` is private, and cannot be reexported\", name)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                    .emit();\n+            } else {\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let note_msg =\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n+                    .span_note(directive.span, &note_msg)\n+                    .emit();\n+            }\n         }\n \n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.ok().map(NameBinding::def) {\n-            Some(def) => def,\n-            None => value_result.ok().map(NameBinding::def).unwrap(),\n-        };\n-        let path_resolution = PathResolution::new(def);\n-        self.def_map.insert(directive.id, path_resolution);\n+        self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n+            this.def_map.entry(directive.id).or_insert(PathResolution::new(binding.def()));\n+        });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());"}, {"sha": "778f0184141651061552c44dbe7e0d655d84962f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -286,7 +286,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n+            let def_id = self.tcx.map.local_def_id(field.id);\n+            let typ = self.tcx.item_type(def_id).to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n@@ -535,7 +536,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx.associated_items(ti.container.id())\n-                        .find(|item| item.name == ti.name && item.has_value)\n+                        .find(|item| item.name == ti.name && item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "9ec764b82f869bf1c9c90795b717dd8303e9a024", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -177,25 +177,44 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     // Return the span for the last ident before a `<` and outside any\n-    // brackets, or the last span.\n+    // angle brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n         let mut result = None;\n+\n+        // We keep track of the following two counts - the depth of nesting of\n+        // angle brackets, and the depth of nesting of square brackets. For the\n+        // angle bracket count, we only count tokens which occur outside of any\n+        // square brackets (i.e. bracket_count == 0). The intutition here is\n+        // that we want to count angle brackets in the type, but not any which\n+        // could be in expression context (because these could mean 'less than',\n+        // etc.).\n+        let mut angle_count = 0;\n         let mut bracket_count = 0;\n         loop {\n             let next = toks.real_token();\n \n-            if (next.tok == token::Lt || next.tok == token::Colon) && bracket_count == 0 &&\n+            if (next.tok == token::Lt || next.tok == token::Colon) &&\n+               angle_count == 0 &&\n+               bracket_count == 0 &&\n                prev.tok.is_ident() {\n                 result = Some(prev.sp);\n             }\n \n+            if bracket_count == 0 {\n+                angle_count += match prev.tok {\n+                    token::Lt => 1,\n+                    token::Gt => -1,\n+                    token::BinOp(token::Shl) => 2,\n+                    token::BinOp(token::Shr) => -2,\n+                    _ => 0,\n+                };\n+            }\n+\n             bracket_count += match prev.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shl) => 2,\n-                token::BinOp(token::Shr) => -2,\n+                token::OpenDelim(token::Bracket) => 1,\n+                token::CloseDelim(token::Bracket) => -1,\n                 _ => 0,\n             };\n \n@@ -204,7 +223,7 @@ impl<'a> SpanUtils<'a> {\n             }\n             prev = next;\n         }\n-        if bracket_count != 0 {\n+        if angle_count != 0 || bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             span_bug!(span,\n                       \"Mis-counted brackets when breaking path? Parsing '{}' \\\n@@ -213,7 +232,7 @@ impl<'a> SpanUtils<'a> {\n                       loc.file.name,\n                       loc.line);\n         }\n-        if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n+        if result.is_none() && prev.tok.is_ident() && angle_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n         }\n         self.make_sub_span(span, result)\n@@ -222,19 +241,20 @@ impl<'a> SpanUtils<'a> {\n     // Reparse span and return an owned vector of sub spans of the first limit\n     // identifier tokens in the given nesting level.\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of brackets: [Foo]\n-    // Nesting = 1: idents within one level of brackets: [Bar, Bar]\n+    // Nesting = 0: all idents outside of angle brackets: [Foo]\n+    // Nesting = 1: idents within one level of angle brackets: [Bar, Bar]\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec![];\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n+        let mut angle_count: isize = 0;\n         let mut bracket_count: isize = 0;\n         let mut found_ufcs_sep = false;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n-                if bracket_count != 0 {\n+                if angle_count != 0 || bracket_count != 0 {\n                     if generated_code(span) {\n                         return vec![];\n                     }\n@@ -252,6 +272,14 @@ impl<'a> SpanUtils<'a> {\n                 return result;\n             }\n             bracket_count += match ts.tok {\n+                token::OpenDelim(token::Bracket) => 1,\n+                token::CloseDelim(token::Bracket) => -1,\n+                _ => 0,\n+            };\n+            if bracket_count > 0 {\n+                continue;\n+            }\n+            angle_count += match ts.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n                 token::BinOp(token::Shl) => 2,\n@@ -269,11 +297,11 @@ impl<'a> SpanUtils<'a> {\n             // path, trying to pull out the non-nested idents (e.g., avoiding 'a\n             // in `<A as B<'a>>::C`). So we end up with a span for `B>::C` from\n             // the start of the first ident to the end of the path.\n-            if !found_ufcs_sep && bracket_count == -1 {\n+            if !found_ufcs_sep && angle_count == -1 {\n                 found_ufcs_sep = true;\n-                bracket_count += 1;\n+                angle_count += 1;\n             }\n-            if ts.tok.is_ident() && bracket_count == nesting {\n+            if ts.tok.is_ident() && angle_count == nesting {\n                 result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n             }\n         }"}, {"sha": "796a80d0809441044c6d7ecf9c455166560da55e", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,6 +16,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "07f53466b4975e1769fc0a01beacfd5c0c9caff6", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 108, "deletions": 19, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector};\n+use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n use build::AllocaFcx;\n use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n@@ -24,6 +24,7 @@ use cabi_s390x;\n use cabi_mips;\n use cabi_mips64;\n use cabi_asmjs;\n+use cabi_msp430;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -49,6 +50,93 @@ enum ArgKind {\n     Ignore,\n }\n \n+// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n+// of this module\n+pub use self::attr_impl::ArgAttribute;\n+\n+#[allow(non_upper_case_globals)]\n+mod attr_impl {\n+    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n+    bitflags! {\n+        #[derive(Default, Debug)]\n+        flags ArgAttribute : u8 {\n+            const ByVal     = 1 << 0,\n+            const NoAlias   = 1 << 1,\n+            const NoCapture = 1 << 2,\n+            const NonNull   = 1 << 3,\n+            const ReadOnly  = 1 << 4,\n+            const SExt      = 1 << 5,\n+            const StructRet = 1 << 6,\n+            const ZExt      = 1 << 7,\n+        }\n+    }\n+}\n+\n+macro_rules! for_each_kind {\n+    ($flags: ident, $f: ident, $($kind: ident),+) => ({\n+        $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+\n+    })\n+}\n+\n+impl ArgAttribute {\n+    fn for_each_kind<F>(&self, mut f: F) where F: FnMut(llvm::Attribute) {\n+        for_each_kind!(self, f,\n+                       ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt)\n+    }\n+}\n+\n+/// A compact representation of LLVM attributes (at least those relevant for this module)\n+/// that can be manipulated without interacting with LLVM's Attribute machinery.\n+#[derive(Copy, Clone, Debug, Default)]\n+pub struct ArgAttributes {\n+    regular: ArgAttribute,\n+    dereferenceable_bytes: u64,\n+}\n+\n+impl ArgAttributes {\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n+    }\n+\n+    pub fn unset(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular - attr;\n+        self\n+    }\n+\n+    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n+        self.dereferenceable_bytes = bytes;\n+        self\n+    }\n+\n+    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n+        self.dereferenceable_bytes = 0;\n+        self\n+    }\n+\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            if self.dereferenceable_bytes != 0 {\n+                llvm::LLVMRustAddDereferenceableAttr(llfn,\n+                                                     idx.as_uint(),\n+                                                     self.dereferenceable_bytes);\n+            }\n+        }\n+    }\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe {\n+            self.regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            if self.dereferenceable_bytes != 0 {\n+                llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n+                                                             idx.as_uint(),\n+                                                             self.dereferenceable_bytes);\n+            }\n+        }\n+    }\n+}\n+\n /// Information about how a specific C type\n /// should be passed to or returned from a function\n ///\n@@ -80,7 +168,7 @@ pub struct ArgType {\n     /// Dummy argument, which is emitted before the real argument\n     pub pad: Option<Type>,\n     /// LLVM attributes of argument\n-    pub attrs: llvm::Attributes\n+    pub attrs: ArgAttributes\n }\n \n impl ArgType {\n@@ -92,23 +180,23 @@ impl ArgType {\n             signedness: None,\n             cast: None,\n             pad: None,\n-            attrs: llvm::Attributes::default()\n+            attrs: ArgAttributes::default()\n         }\n     }\n \n     pub fn make_indirect(&mut self, ccx: &CrateContext) {\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n-        self.attrs = llvm::Attributes::default();\n+        self.attrs = ArgAttributes::default();\n \n         let llarg_sz = llsize_of_alloc(ccx, self.ty);\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n-        self.attrs.set(llvm::Attribute::NoAlias)\n-                  .set(llvm::Attribute::NoCapture)\n+        self.attrs.set(ArgAttribute::NoAlias)\n+                  .set(ArgAttribute::NoCapture)\n                   .set_dereferenceable(llarg_sz);\n \n         self.kind = ArgKind::Indirect;\n@@ -124,9 +212,9 @@ impl ArgType {\n         if let Some(signed) = self.signedness {\n             if self.ty.int_width() < bits {\n                 self.attrs.set(if signed {\n-                    llvm::Attribute::SExt\n+                    ArgAttribute::SExt\n                 } else {\n-                    llvm::Attribute::ZExt\n+                    ArgAttribute::ZExt\n                 });\n             }\n         }\n@@ -273,10 +361,10 @@ impl FnType {\n             C => llvm::CCallConv,\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n+            Aapcs => llvm::ArmAapcsCallConv,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,\n-            Aapcs => llvm::CCallConv,\n         };\n \n         let mut inputs = &sig.inputs[..];\n@@ -314,7 +402,7 @@ impl FnType {\n             if ty.is_bool() {\n                 let llty = Type::i1(ccx);\n                 let mut arg = ArgType::new(llty, llty);\n-                arg.attrs.set(llvm::Attribute::ZExt);\n+                arg.attrs.set(ArgAttribute::ZExt);\n                 arg\n             } else {\n                 let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n@@ -349,7 +437,7 @@ impl FnType {\n             if let ty::TyBox(_) = ret_ty.sty {\n                 // `Box` pointer return values never alias because ownership\n                 // is transferred\n-                ret.attrs.set(llvm::Attribute::NoAlias);\n+                ret.attrs.set(ArgAttribute::NoAlias);\n             }\n \n             // We can also mark the return value as `dereferenceable` in certain cases\n@@ -371,7 +459,7 @@ impl FnType {\n         let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n             // `Box` pointer parameters never alias because ownership is transferred\n             ty::TyBox(inner) => {\n-                arg.attrs.set(llvm::Attribute::NoAlias);\n+                arg.attrs.set(ArgAttribute::NoAlias);\n                 Some(inner)\n             }\n \n@@ -386,18 +474,18 @@ impl FnType {\n                 let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n \n                 if mt.mutbl != hir::MutMutable && !interior_unsafe {\n-                    arg.attrs.set(llvm::Attribute::NoAlias);\n+                    arg.attrs.set(ArgAttribute::NoAlias);\n                 }\n \n                 if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n-                    arg.attrs.set(llvm::Attribute::ReadOnly);\n+                    arg.attrs.set(ArgAttribute::ReadOnly);\n                 }\n \n                 // When a reference in an argument has no named lifetime, it's\n                 // impossible for that reference to escape this function\n                 // (returned or stored beyond the call by a closure).\n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    arg.attrs.set(llvm::Attribute::NoCapture);\n+                    arg.attrs.set(ArgAttribute::NoCapture);\n                 }\n \n                 Some(mt.ty)\n@@ -417,9 +505,9 @@ impl FnType {\n                 let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n \n                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n-                    data.attrs.set(llvm::Attribute::NonNull);\n+                    data.attrs.set(ArgAttribute::NonNull);\n                     if ccx.tcx().struct_tail(inner).is_trait() {\n-                        info.attrs.set(llvm::Attribute::NonNull);\n+                        info.attrs.set(ArgAttribute::NonNull);\n                     }\n                 }\n                 args.push(data);\n@@ -490,7 +578,7 @@ impl FnType {\n                 fixup(arg);\n             }\n             if self.ret.is_indirect() {\n-                self.ret.attrs.set(llvm::Attribute::StructRet);\n+                self.ret.attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n         }\n@@ -520,11 +608,12 @@ impl FnType {\n             \"s390x\" => cabi_s390x::compute_abi_info(ccx, self),\n             \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n+            \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n         if self.ret.is_indirect() {\n-            self.ret.attrs.set(llvm::Attribute::StructRet);\n+            self.ret.attrs.set(ArgAttribute::StructRet);\n         }\n     }\n "}, {"sha": "c3340281d073254a08a9420dc5e34df0191e23cd", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -108,9 +108,9 @@ fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n             }).collect::<Vec<_>>()\n         },\n         ty::TyTuple(fields) => fields.to_vec(),\n-        ty::TyClosure(_, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n-            substs.upvar_tys.to_vec()\n+            substs.upvar_tys(def_id, cx.tcx()).collect()\n         },\n         _ => bug!(\"{} is not a type that can have fields.\", t)\n     }\n@@ -245,8 +245,6 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // So we start with the discriminant, pad it up to the alignment with\n             // more of its own type, then use alignment-sized ints to get the rest\n             // of the size.\n-            //\n-            // FIXME #10604: this breaks when vector types are present.\n             let size = size.bytes();\n             let align = align.abi();\n             let discr_ty = Type::from_integer(cx, discr);"}, {"sha": "f1e90419a49e2070508781b2f55821458598f295", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -24,10 +24,9 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n         Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n         Never  => Attribute::NoInline.apply_llfn(Function, val),\n         None   => {\n-            let attr = Attribute::InlineHint |\n-                       Attribute::AlwaysInline |\n-                       Attribute::NoInline;\n-            attr.unapply_llfn(Function, val)\n+            Attribute::InlineHint.unapply_llfn(Function, val);\n+            Attribute::AlwaysInline.unapply_llfn(Function, val);\n+            Attribute::NoInline.unapply_llfn(Function, val);\n         },\n     };\n }"}, {"sha": "df8dd7750ae0ca69a7bffb994c91be56acf36097", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -145,8 +145,11 @@ impl<'a> ArchiveBuilder<'a> {\n     ///\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool)\n-                    -> io::Result<()> {\n+    pub fn add_rlib(&mut self,\n+                    rlib: &Path,\n+                    name: &str,\n+                    lto: bool,\n+                    skip_objects: bool) -> io::Result<()> {\n         // Ignoring obj file starting with the crate name\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n@@ -159,9 +162,23 @@ impl<'a> ArchiveBuilder<'a> {\n             self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, move |fname: &str| {\n-            let skip_obj = lto && fname.starts_with(&obj_start)\n-                && fname.ends_with(\".o\");\n-            skip_obj || fname.ends_with(bc_ext) || fname == metadata_filename\n+            if fname.ends_with(bc_ext) || fname == metadata_filename {\n+                return true\n+            }\n+\n+            // Don't include Rust objects if LTO is enabled\n+            if lto && fname.starts_with(&obj_start) && fname.ends_with(\".o\") {\n+                return true\n+            }\n+\n+            // Otherwise if this is *not* a rust object and we're skipping\n+            // objects then skip this file\n+            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                return true\n+            }\n+\n+            // ok, don't skip this\n+            return false\n         })\n     }\n "}, {"sha": "95d63311ee6e47aade6099c70b2d95d1e96adce0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 109, "deletions": 45, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -19,7 +19,7 @@ use session::config::{OutputFilenames, Input, OutputType};\n use session::filesearch;\n use session::search_paths::PathKind;\n use session::Session;\n-use middle::cstore::{self, LinkMeta};\n+use middle::cstore::{self, LinkMeta, NativeLibrary};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -43,6 +43,7 @@ use std::process::Command;\n use std::str;\n use flate;\n use syntax::ast;\n+use syntax::attr;\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n@@ -406,12 +407,29 @@ fn link_rlib<'a>(sess: &'a Session,\n         ab.add_file(obj);\n     }\n \n-    for (l, kind) in sess.cstore.used_libraries() {\n-        match kind {\n-            NativeLibraryKind::NativeStatic => ab.add_native_library(&l),\n+    // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n+    // we may not be configured to actually include a static library if we're\n+    // adding it here. That's because later when we consume this rlib we'll\n+    // decide whether we actually needed the static library or not.\n+    //\n+    // To do this \"correctly\" we'd need to keep track of which libraries added\n+    // which object files to the archive. We don't do that here, however. The\n+    // #[link(cfg(..))] feature is unstable, though, and only intended to get\n+    // liblibc working. In that sense the check below just indicates that if\n+    // there are any libraries we want to omit object files for at link time we\n+    // just exclude all custom object files.\n+    //\n+    // Eventually if we want to stabilize or flesh out the #[link(cfg(..))]\n+    // feature then we'll need to figure out how to record what objects were\n+    // loaded from the libraries found here and then encode that into the\n+    // metadata of the rlib we're generating somehow.\n+    for lib in sess.cstore.used_libraries() {\n+        match lib.kind {\n+            NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeFramework |\n-            NativeLibraryKind::NativeUnknown => {}\n+            NativeLibraryKind::NativeUnknown => continue,\n         }\n+        ab.add_native_library(&lib.name);\n     }\n \n     // After adding all files to the archive, we need to update the\n@@ -578,10 +596,28 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n \n     each_linked_rlib(sess, &mut |cnum, path| {\n         let name = sess.cstore.crate_name(cnum);\n-        ab.add_rlib(path, &name, sess.lto()).unwrap();\n-\n         let native_libs = sess.cstore.native_libraries(cnum);\n-        all_native_libs.extend(native_libs);\n+\n+        // Here when we include the rlib into our staticlib we need to make a\n+        // decision whether to include the extra object files along the way.\n+        // These extra object files come from statically included native\n+        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n+        //\n+        // This unstable feature, though, only needs liblibc to work. The only\n+        // use case there is where musl is statically included in liblibc.rlib,\n+        // so if we don't want the included version we just need to skip it. As\n+        // a result the logic here is that if *any* linked library is cfg'd away\n+        // we just skip all object files.\n+        //\n+        // Clearly this is not sufficient for a general purpose feature, and\n+        // we'd want to read from the library's metadata to determine which\n+        // object files come from where and selectively skip them.\n+        let skip_object_files = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+        ab.add_rlib(path, &name, sess.lto(), skip_object_files).unwrap();\n+\n+        all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n \n     ab.update_symbols();\n@@ -594,13 +630,14 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n                                  platforms, and so may need to be preserved\");\n     }\n \n-    for &(kind, ref lib) in &all_native_libs {\n-        let name = match kind {\n-            NativeLibraryKind::NativeStatic => \"static library\",\n+    for lib in all_native_libs.iter().filter(|l| relevant_lib(sess, l)) {\n+        let name = match lib.kind {\n             NativeLibraryKind::NativeUnknown => \"library\",\n             NativeLibraryKind::NativeFramework => \"framework\",\n+            // These are included, no need to print them\n+            NativeLibraryKind::NativeStatic => continue,\n         };\n-        sess.note_without_error(&format!(\"{}: {}\", name, *lib));\n+        sess.note_without_error(&format!(\"{}: {}\", name, lib.name));\n     }\n }\n \n@@ -876,14 +913,12 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         }\n     });\n \n-    let libs = sess.cstore.used_libraries();\n-\n-    let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n-        if kind == NativeLibraryKind::NativeStatic {Some(l)} else {None}\n-    });\n-    let others = libs.iter().filter(|&&(_, kind)| {\n-        kind != NativeLibraryKind::NativeStatic\n+    let pair = sess.cstore.used_libraries().into_iter().filter(|l| {\n+        relevant_lib(sess, l)\n+    }).partition(|lib| {\n+        lib.kind == NativeLibraryKind::NativeStatic\n     });\n+    let (staticlibs, others): (Vec<_>, Vec<_>) = pair;\n \n     // Some platforms take hints about whether a library is static or dynamic.\n     // For those that support this, we ensure we pass the option if the library\n@@ -899,15 +934,15 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         // don't otherwise explicitly reference them. This can occur for\n         // libraries which are just providing bindings, libraries with generic\n         // functions, etc.\n-        cmd.link_whole_staticlib(l, &search_path);\n+        cmd.link_whole_staticlib(&l.name, &search_path);\n     }\n \n     cmd.hint_dynamic();\n \n-    for &(ref l, kind) in others {\n-        match kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(l),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(l),\n+    for lib in others {\n+        match lib.kind {\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n             NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n@@ -1017,7 +1052,16 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                         cnum: CrateNum) {\n         let src = sess.cstore.used_crate_source(cnum);\n         let cratepath = &src.rlib.unwrap().0;\n-        if !sess.lto() && crate_type != config::CrateTypeDylib {\n+\n+        // See the comment above in `link_staticlib` and `link_rlib` for why if\n+        // there's a static library that's not relevant we skip all object\n+        // files.\n+        let native_libs = sess.cstore.native_libraries(cnum);\n+        let skip_native = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+\n+        if !sess.lto() && crate_type != config::CrateTypeDylib && !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n             return\n         }\n@@ -1029,33 +1073,42 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         time(sess.time_passes(), &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n-            archive.remove_file(sess.cstore.metadata_filename());\n             archive.update_symbols();\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(\"bytecode.deflate\") {\n+                if f.ends_with(\"bytecode.deflate\") ||\n+                   f == sess.cstore.metadata_filename() {\n                     archive.remove_file(&f);\n                     continue\n                 }\n+\n                 let canonical = f.replace(\"-\", \"_\");\n                 let canonical_name = name.replace(\"-\", \"_\");\n \n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) && {\n+                        let num = &f[name.len()..f.len() - 2];\n+                        num.len() > 0 && num[1..].parse::<u32>().is_ok()\n+                    };\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n                 // If we're performing LTO and this is a rust-generated object\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                if sess.lto() &&\n-                   !sess.cstore.is_no_builtins(cnum) &&\n-                   canonical.starts_with(&canonical_name) &&\n-                   canonical.ends_with(\".o\") {\n-                    let num = &f[name.len()..f.len() - 2];\n-                    if num.len() > 0 && num[1..].parse::<u32>().is_ok() {\n-                        archive.remove_file(&f);\n-                        continue\n-                    }\n+                let skip_because_lto = sess.lto() && is_rust_object &&\n+                                        !sess.cstore.is_no_builtins(cnum);\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    archive.remove_file(&f);\n+                } else {\n+                    any_objects = true;\n                 }\n-                any_objects = true;\n             }\n \n             if !any_objects {\n@@ -1127,15 +1180,26 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n     // the paths.\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n     for (cnum, _) in crates {\n-        let libs = sess.cstore.native_libraries(cnum);\n-        for &(kind, ref lib) in &libs {\n-            match kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(lib),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(lib),\n-                NativeLibraryKind::NativeStatic => {\n-                    bug!(\"statics shouldn't be propagated\");\n-                }\n+        for lib in sess.cstore.native_libraries(cnum) {\n+            if !relevant_lib(sess, &lib) {\n+                continue\n+            }\n+            match lib.kind {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+\n+                // ignore statically included native libraries here as we've\n+                // already included them when we included the rust library\n+                // previously\n+                NativeLibraryKind::NativeStatic => {}\n             }\n         }\n     }\n }\n+\n+fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}"}, {"sha": "0ad663f05b48b12c577810baff255a011bebeaf0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n             match key.disambiguated_data.data {\n                 DefPathData::TypeNs(_) |\n                 DefPathData::ValueNs(_) => {\n-                    instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n+                    instance_ty = scx.tcx().item_type(ty_def_id);\n                     break;\n                 }\n                 _ => {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n \n         // Erase regions because they may not be deterministic when hashed\n         // and should not matter anyhow.\n-        let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n+        let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n         let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n "}, {"sha": "01eea08c50bc589dab4d36dba16eefc5e715c08e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -147,7 +147,16 @@ impl Emitter for SharedEmitter {\n // arise as some of intrinsics are converted into function calls\n // and nobody provides implementations those functions\n fn target_feature(sess: &Session) -> String {\n-    format!(\"{},{}\", sess.target.target.options.features, sess.opts.cg.target_feature)\n+    let rustc_features = [\n+        \"crt-static\",\n+    ];\n+    let requested_features = sess.opts.cg.target_feature.split(',');\n+    let llvm_features = requested_features.filter(|f| {\n+        !rustc_features.iter().any(|s| f.contains(s))\n+    });\n+    format!(\"{},{}\",\n+            sess.target.target.options.features,\n+            llvm_features.collect::<Vec<_>>().join(\",\"))\n }\n \n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {"}, {"sha": "0c0b7fbf4afeab483d41a26f8697cfc352741945", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -74,7 +74,7 @@ use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_map::SymbolMap;\n use symbol_names_test;\n-use trans_item::TransItem;\n+use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -1003,34 +1003,49 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     }\n }\n \n-/// Builds an LLVM function out of a source function.\n-///\n-/// If the function closes over its environment a closure will be returned.\n-pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               llfndecl: ValueRef,\n-                               instance: Instance<'tcx>,\n-                               sig: &ty::FnSig<'tcx>,\n-                               abi: Abi) {\n-    ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n-\n-    let _icx = push_ctxt(\"trans_closure\");\n-    if !ccx.sess().no_landing_pads() {\n-        attributes::emit_uwtable(llfndecl, true);\n-    }\n+pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = if ccx.sess().trans_stats() {\n+        let mut instance_name = String::new();\n+        DefPathBasedNames::new(ccx.tcx(), true, true)\n+            .push_def_path(instance.def, &mut instance_name);\n+        Some(StatRecorder::new(ccx, instance_name))\n+    } else {\n+        None\n+    };\n \n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds.\n-    info!(\"trans_closure(..., {})\", instance);\n+    info!(\"trans_instance({})\", instance);\n+\n+    let _icx = push_ctxt(\"trans_instance\");\n+\n+    let fn_ty = ccx.tcx().item_type(instance.def);\n+    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n+\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n+        Some(&val) => val,\n+        None => bug!(\"Instance `{:?}` not already declared\", instance)\n+    };\n \n-    let fn_ty = FnType::new(ccx, abi, sig, &[]);\n+    ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n+\n+    if !ccx.sess().no_landing_pads() {\n+        attributes::emit_uwtable(lldecl, true);\n+    }\n+\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx,\n-                               llfndecl,\n+                               lldecl,\n                                fn_ty,\n-                               Some((instance, sig, abi)),\n+                               Some((instance, &sig, abi)),\n                                &arena);\n \n     if fcx.mir.is_none() {\n@@ -1040,26 +1055,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     mir::trans_mir(&fcx);\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n-    debug!(\"trans_instance(instance={:?})\", instance);\n-    let _icx = push_ctxt(\"trans_instance\");\n-\n-    let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n-    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n-\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_ty.fn_sig());\n-    let abi = fn_ty.fn_abi();\n-\n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n-        Some(&val) => val,\n-        None => bug!(\"Instance `{:?}` not already declared\", instance)\n-    };\n-\n-    trans_closure(ccx, lldecl, instance, &sig, abi);\n-}\n-\n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n@@ -1068,7 +1063,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n     attributes::set_frame_pointer_elimination(ccx, llfndecl);\n \n-    let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n@@ -1514,7 +1509,7 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let generics = tcx.lookup_generics(def_id);\n+                let generics = tcx.item_generics(def_id);\n                 let attributes = tcx.get_attrs(def_id);\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated\n@@ -1719,7 +1714,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let applicable = match sess.cstore.describe_def(def_id) {\n                 Some(Def::Static(..)) => true,\n                 Some(Def::Fn(_)) => {\n-                    shared_ccx.tcx().lookup_generics(def_id).types.is_empty()\n+                    shared_ccx.tcx().item_generics(def_id).types.is_empty()\n                 }\n                 _ => false\n             };"}, {"sha": "f410627400c34ec4c2b1018d4188cdb3da48c941", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Struct, Array, Attribute};\n-use abi::{FnType, ArgType};\n+use llvm::{Struct, Array};\n+use abi::{FnType, ArgType, ArgAttribute};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n@@ -39,7 +39,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if arg.ty.is_aggregate() {\n         arg.make_indirect(ccx);\n-        arg.attrs.set(Attribute::ByVal);\n+        arg.attrs.set(ArgAttribute::ByVal);\n     }\n }\n "}, {"sha": "aa90bb7ab753ad706b7f437f035bed2f1274fe7a", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: MSP430 Embedded Application Binary Interface\n+// http://www.ti.com/lit/an/slaa534/slaa534.pdf\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 2)\n+}\n+\n+// 3.5 Structures or Unions Passed and Returned by Reference\n+//\n+// \"Structures (including classes) and unions larger than 32 bits are passed and\n+// returned by reference. To pass a structure or union by reference, the caller\n+// places its address in the appropriate location: either in a register or on\n+// the stack, according to its position in the argument list. (..)\"\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(16);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(16);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "5377b49a2b441c8bf787e9627e686949cf9d9a21", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::*;\n-use abi::FnType;\n+use abi::{ArgAttribute, FnType};\n use type_::Type;\n use super::common::*;\n use super::machine::*;\n@@ -45,7 +45,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         if arg.is_ignore() { continue; }\n         if arg.ty.kind() == Struct {\n             arg.make_indirect(ccx);\n-            arg.attrs.set(Attribute::ByVal);\n+            arg.attrs.set(ArgAttribute::ByVal);\n         } else {\n             arg.extend_integer_width_to(32);\n         }"}, {"sha": "7f2fdbf000b651fd62acfab2cb256881e55375a5", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -15,8 +15,8 @@\n use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n-use llvm::{Struct, Array, Attribute, Vector};\n-use abi::{self, ArgType, FnType};\n+use llvm::{Struct, Array, Vector};\n+use abi::{self, ArgType, ArgAttribute, FnType};\n use context::CrateContext;\n use type_::Type;\n \n@@ -334,7 +334,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n                     arg: &mut ArgType,\n                     is_mem_cls: F,\n-                    ind_attr: Option<Attribute>)\n+                    ind_attr: Option<ArgAttribute>)\n         where F: FnOnce(&[RegClass]) -> bool\n     {\n         if !arg.ty.is_reg_ty() {\n@@ -384,7 +384,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 sse_regs -= needed_sse;\n             }\n             in_mem\n-        }, Some(Attribute::ByVal));\n+        }, Some(ArgAttribute::ByVal));\n \n         // An integer, pointer, double or float parameter\n         // thus the above closure passed to `x86_64_ty` won't"}, {"sha": "df56e27128c7ec65d01f303c0b936f1f27249a6f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 175, "deletions": 15, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -26,11 +26,11 @@ use attributes;\n use base;\n use base::*;\n use build::*;\n-use closure;\n use common::{self, Block, Result, CrateContext, FunctionContext, SharedCrateContext};\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n+use value::Value;\n use meth;\n use monomorphize::{self, Instance};\n use trans_item::TransItem;\n@@ -147,11 +147,12 @@ impl<'tcx> Callee<'tcx> {\n                 // after passing through fulfill_obligation\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let instance = Instance::new(def_id, substs);\n-                let llfn = closure::trans_closure_method(ccx,\n-                                                         vtable_closure.closure_def_id,\n-                                                         vtable_closure.substs,\n-                                                         instance,\n-                                                         trait_closure_kind);\n+                let llfn = trans_closure_method(\n+                    ccx,\n+                    vtable_closure.closure_def_id,\n+                    vtable_closure.substs,\n+                    instance,\n+                    trait_closure_kind);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n@@ -246,10 +247,174 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n-    let ty = shared.tcx().lookup_item_type(def_id).ty;\n+    let ty = shared.tcx().item_type(def_id);\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n+\n+fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                  def_id: DefId,\n+                                  substs: ty::ClosureSubsts<'tcx>,\n+                                  method_instance: Instance<'tcx>,\n+                                  trait_closure_kind: ty::ClosureKind)\n+                                  -> ValueRef\n+{\n+    // If this is a closure, redirect to it.\n+    let (llfn, _) = get_fn(ccx, def_id, substs.substs);\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n+\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, llfn={:?})\",\n+           llfn_closure_kind, trait_closure_kind, Value(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, def_id, substs, method_instance, llfn)\n+        }\n+        _ => {\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    method_instance: Instance<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n+        return llfn;\n+    }\n+\n+    debug!(\"trans_fn_once_adapter_shim(def_id={:?}, substs={:?}, llreffn={:?})\",\n+           def_id, substs, Value(llreffn));\n+\n+    let tcx = ccx.tcx();\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let closure_ty = tcx.mk_closure_from_closure_substs(def_id, substs);\n+    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = tcx.closure_type(def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: sig.clone()\n+    }));\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n+           llref_fn_ty);\n+\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, Abi::RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+\n+    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: ty::Binder(sig)\n+    }));\n+\n+    // Create the by-value helper.\n+    let function_name = method_instance.symbol_name(ccx.shared());\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n+    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n+\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n+\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+\n+    let mut llargs = get_params(fcx.llfn);\n+    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &fcx.fn_ty.args[0];\n+    let llenv = if env_arg.is_indirect() {\n+        llargs[self_idx]\n+    } else {\n+        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n+        let mut llarg_idx = self_idx;\n+        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n+        scratch\n+    };\n+\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n+    // For zero-sized closures that means sneaking in a new argument.\n+    if env_arg.is_ignore() {\n+        if self_idx > 0 {\n+            self_idx -= 1;\n+            llargs[self_idx] = llenv;\n+        } else {\n+            llargs.insert(0, llenv);\n+        }\n+    } else {\n+        llargs[self_idx] = llenv;\n+    }\n+\n+    let dest = fcx.llretslotptr.get();\n+\n+    let callee = Callee {\n+        data: Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n+\n+    // Call the by-ref closure body with `self` in a cleanup scope,\n+    // to drop `self` when the body returns, or in case it unwinds.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n+\n+    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n+\n+    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n+\n+    fcx.finish(bcx, DebugLoc::None);\n+\n+    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n+\n+    lloncefn\n+}\n+\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///\n@@ -400,7 +565,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);\n-    let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let item_ty = ccx.tcx().item_type(def_id);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &item_ty);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n@@ -435,13 +600,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let fn_ptr_ty = match fn_ty.sty {\n-        ty::TyFnDef(.., fty) => {\n-            // Create a fn pointer with the substituted signature.\n-            tcx.mk_fn_ptr(fty)\n-        }\n-        _ => bug!(\"expected fn item type, found {}\", fn_ty)\n-    };\n+    // Create a fn pointer with the substituted signature.\n+    let fn_ptr_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(common::ty_fn_ty(ccx, fn_ty).into_owned()));\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {"}, {"sha": "a1d645fb993b01987d86ff513ab30608610808b1", "filename": "src/librustc_trans/closure.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/2556400a5d4c9b56084332c29b6c91ac5cd3a9fa/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2556400a5d4c9b56084332c29b6c91ac5cd3a9fa/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=2556400a5d4c9b56084332c29b6c91ac5cd3a9fa", "patch": "@@ -1,319 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use arena::TypedArena;\n-use llvm::{self, ValueRef, get_params};\n-use rustc::hir::def_id::DefId;\n-use abi::{Abi, FnType};\n-use attributes;\n-use base::*;\n-use callee::{self, Callee};\n-use common::*;\n-use debuginfo::{DebugLoc};\n-use declare;\n-use monomorphize::{Instance};\n-use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt};\n-\n-use rustc::hir;\n-\n-fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           closure_id: DefId,\n-                           fn_ty: Ty<'tcx>)\n-                           -> Ty<'tcx> {\n-    match tcx.closure_kind(closure_id) {\n-        ty::ClosureKind::Fn => {\n-            tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnMut => {\n-            tcx.mk_mut_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnOnce => fn_ty,\n-    }\n-}\n-\n-/// Returns the LLVM function declaration for a closure, creating it if\n-/// necessary. If the ID does not correspond to a closure ID, returns None.\n-fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               closure_id: DefId,\n-                                               substs: ty::ClosureSubsts<'tcx>)\n-                                               -> ValueRef {\n-    // Normalize type so differences in regions and typedefs don't cause\n-    // duplicate declarations\n-    let tcx = ccx.tcx();\n-    let substs = tcx.erase_regions(&substs);\n-    let instance = Instance::new(closure_id, substs.func_substs);\n-\n-    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               instance, Value(llfn));\n-        return llfn;\n-    }\n-\n-    let symbol = instance.symbol_name(ccx.shared());\n-\n-    // Compute the rust-call form of the closure call method.\n-    let sig = &tcx.closure_type(closure_id, substs).sig;\n-    let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, substs);\n-    let function_type = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Normal,\n-        abi: Abi::RustCall,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        })\n-    }));\n-    let llfn = declare::declare_fn(ccx, &symbol, function_type);\n-\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n-            closure {:?}: {:?}\",\n-           instance, Value(llfn));\n-\n-    // NOTE: We do *not* store llfn in the ccx.instances() map here,\n-    //       that is only done, when the closures body is translated.\n-\n-    llfn\n-}\n-\n-pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            closure_def_id: DefId,\n-                                            closure_substs: ty::ClosureSubsts<'tcx>) {\n-    // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n-    // defid of the closure in its original crate, whereas `id` will be the id of the local\n-    // inlined copy.\n-    debug!(\"trans_closure_body_via_mir(closure_def_id={:?}, closure_substs={:?})\",\n-           closure_def_id, closure_substs);\n-\n-    let tcx = ccx.tcx();\n-    let _icx = push_ctxt(\"closure::trans_closure_expr\");\n-\n-    let param_substs = closure_substs.func_substs;\n-    let instance = Instance::new(closure_def_id, param_substs);\n-\n-    // If we have not done so yet, translate this closure's body\n-    if  !ccx.instances().borrow().contains_key(&instance) {\n-        let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-\n-        unsafe {\n-            if ccx.sess().target.target.options.allows_weak_linkage {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::WeakODRLinkage);\n-                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-            } else {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage);\n-            }\n-        }\n-\n-        // set an inline hint for all closures\n-        attributes::inline(llfn, attributes::InlineAttr::Hint);\n-\n-        // Get the type of this closure. Use the current `param_substs` as\n-        // the closure substitutions. This makes sense because the closure\n-        // takes the same set of type arguments as the enclosing fn, and\n-        // this function (`trans_closure`) is invoked at the point\n-        // of the closure expression.\n-\n-        let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n-        let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-\n-        let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                              closure_substs);\n-        let sig = ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        };\n-\n-        trans_closure(ccx,\n-                      llfn,\n-                      Instance::new(closure_def_id, param_substs),\n-                      &sig,\n-                      Abi::RustCall);\n-\n-        ccx.instances().borrow_mut().insert(instance, llfn);\n-    }\n-}\n-\n-pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                      closure_def_id: DefId,\n-                                      substs: ty::ClosureSubsts<'tcx>,\n-                                      method_instance: Instance<'tcx>,\n-                                      trait_closure_kind: ty::ClosureKind)\n-                                      -> ValueRef\n-{\n-    // If this is a closure, redirect to it.\n-    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n-\n-    // If weak linkage is not allowed, we have to make sure that a local,\n-    // private copy of the closure is available in this codegen unit\n-    if !ccx.sess().target.target.options.allows_weak_linkage &&\n-       !ccx.sess().opts.single_codegen_unit() {\n-\n-        trans_closure_body_via_mir(ccx, closure_def_id, substs);\n-    }\n-\n-    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n-    // then adapt the self type\n-    let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n-\n-    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-\n-    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, llfn={:?})\",\n-           llfn_closure_kind, trait_closure_kind, Value(llfn));\n-\n-    match (llfn_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, method_instance, llfn)\n-        }\n-        _ => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n-        }\n-    }\n-}\n-\n-fn trans_fn_once_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    method_instance: Instance<'tcx>,\n-    llreffn: ValueRef)\n-    -> ValueRef\n-{\n-    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n-        return llfn;\n-    }\n-\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n-           closure_def_id, substs, Value(llreffn));\n-\n-    let tcx = ccx.tcx();\n-\n-    // Find a version of the closure type. Substitute static for the\n-    // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, substs);\n-    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n-\n-    // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } =\n-        tcx.closure_type(closure_def_id, substs);\n-    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n-    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig.clone()\n-    }));\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n-           llref_fn_ty);\n-\n-\n-    // Make a version of the closure type with the same arguments, but\n-    // with argument #0 being by value.\n-    assert_eq!(abi, Abi::RustCall);\n-    sig.0.inputs[0] = closure_ty;\n-\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n-    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: ty::Binder(sig)\n-    }));\n-\n-    // Create the by-value helper.\n-    let function_name = method_instance.symbol_name(ccx.shared());\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n-\n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n-\n-\n-    // the first argument (`self`) will be the (by value) closure env.\n-\n-    let mut llargs = get_params(fcx.llfn);\n-    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &fcx.fn_ty.args[0];\n-    let llenv = if env_arg.is_indirect() {\n-        llargs[self_idx]\n-    } else {\n-        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n-        let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n-        scratch\n-    };\n-\n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n-    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n-    // For zero-sized closures that means sneaking in a new argument.\n-    if env_arg.is_ignore() {\n-        if self_idx > 0 {\n-            self_idx -= 1;\n-            llargs[self_idx] = llenv;\n-        } else {\n-            llargs.insert(0, llenv);\n-        }\n-    } else {\n-        llargs[self_idx] = llenv;\n-    }\n-\n-    let dest = fcx.llretslotptr.get();\n-\n-    let callee = Callee {\n-        data: callee::Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n-    // Call the by-ref closure body with `self` in a cleanup scope,\n-    // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n-\n-    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n-\n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n-\n-    fcx.finish(bcx, DebugLoc::None);\n-\n-    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n-\n-    lloncefn\n-}"}, {"sha": "5902b0b1ce0755ec463354d90e634ef69fd4cc91", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -189,7 +189,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc::hir;\n-use rustc::hir::intravisit as hir_visit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -213,7 +213,7 @@ use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, type_to_string, def_id_to_string};\n+use trans_item::{TransItem, DefPathBasedNames};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n@@ -306,10 +306,9 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             scx: scx,\n             mode: mode,\n             output: &mut roots,\n-            enclosing_item: None,\n         };\n \n-        scx.tcx().map.krate().visit_all_items(&mut visitor);\n+        scx.tcx().map.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     roots\n@@ -337,7 +336,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n-            let ty = scx.tcx().lookup_item_type(def_id).ty;\n+            let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n@@ -446,24 +445,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n-                                                               ref substs), _) => {\n-                let mir = self.scx.tcx().item_mir(def_id);\n-\n-                let concrete_substs = monomorphize::apply_param_substs(self.scx,\n-                                                                       self.param_substs,\n-                                                                       &substs.func_substs);\n-                let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n-\n-                let visitor = MirNeighborCollector {\n-                    scx: self.scx,\n-                    mir: &mir,\n-                    output: self.output,\n-                    param_substs: concrete_substs\n-                };\n-\n-                visit_mir_and_promoted(visitor, &mir);\n-            }\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n@@ -618,7 +599,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n-            match tcx.lookup_item_type(def_id).ty.sty {\n+            match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n@@ -797,8 +778,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::TyClosure(_, substs) => {\n-            for upvar_ty in substs.upvar_tys {\n+        ty::TyClosure(def_id, substs) => {\n+            for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n                 let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n                 if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n@@ -888,10 +869,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         traits::VtableImpl(impl_data) => {\n             Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n         }\n-        // If we have a closure or a function pointer, we will also encounter\n-        // the concrete closure/function somewhere else (during closure or fn\n-        // pointer construction). That's where we track those things.\n-        traits::VtableClosure(..) |\n+        traits::VtableClosure(closure_data) => {\n+            Some((closure_data.closure_def_id, closure_data.substs.substs))\n+        }\n+        // Trait object and function pointer shims are always\n+        // instantiated in-place, and as they are just an ABI-adjusting\n+        // indirect call they do not have any dependencies.\n         traits::VtableFnPointer(..) |\n         traits::VtableObject(..) => {\n             None\n@@ -1046,14 +1029,10 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     scx: &'b SharedCrateContext<'a, 'tcx>,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n-    enclosing_item: Option<&'tcx hir::Item>,\n }\n \n-impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n+impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        let old_enclosing_item = self.enclosing_item;\n-        self.enclosing_item = Some(item);\n-\n         match item.node {\n             hir::ItemExternCrate(..) |\n             hir::ItemUse(..)         |\n@@ -1077,13 +1056,12 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = self.scx.tcx().tables().node_types[&item.id];\n-\n                     if self.mode == TransItemCollectionMode::Eager {\n+                        let def_id = self.scx.tcx().map.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.scx.tcx(),\n-                                                self.scx.tcx().map.local_def_id(item.id)));\n+                               def_id_to_string(self.scx.tcx(), def_id));\n \n+                        let ty = self.scx.tcx().item_type(def_id);\n                         let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n@@ -1111,9 +1089,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n         }\n-\n-        hir_visit::walk_item(self, item);\n-        self.enclosing_item = old_enclosing_item;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n@@ -1148,8 +1123,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n             _ => { /* Nothing to do here */ }\n         }\n-\n-        hir_visit::walk_impl_item(self, ii)\n     }\n }\n \n@@ -1162,7 +1135,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                       _,\n                       ref generics,\n                       ..,\n-                      ref items) => {\n+                      ref impl_item_refs) => {\n             if generics.is_type_parameterized() {\n                 return\n             }\n@@ -1174,15 +1147,16 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FxHashSet<_> = items.iter()\n-                                                            .map(|item| item.name)\n-                                                            .collect();\n+                let overridden_methods: FxHashSet<_> =\n+                    impl_item_refs.iter()\n+                                  .map(|iiref| iiref.name)\n+                                  .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;\n                     }\n \n-                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n+                    if !tcx.item_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n \n@@ -1201,7 +1175,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                                                                callee_substs,\n                                                                &impl_data);\n \n-                    let predicates = tcx.lookup_predicates(def_id).predicates\n+                    let predicates = tcx.item_predicates(def_id).predicates\n                                         .subst(tcx, substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n@@ -1251,3 +1225,21 @@ fn visit_mir_and_promoted<'tcx, V: MirVisitor<'tcx>>(mut visitor: V, mir: &mir::\n         visitor.visit_mir(promoted);\n     }\n }\n+\n+fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> String {\n+    let mut output = String::new();\n+    let printer = DefPathBasedNames::new(tcx, false, false);\n+    printer.push_def_path(def_id, &mut output);\n+    output\n+}\n+\n+fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            ty: ty::Ty<'tcx>)\n+                            -> String {\n+    let mut output = String::new();\n+    let printer = DefPathBasedNames::new(tcx, false, false);\n+    printer.push_type_name(ty, &mut output);\n+    output\n+}"}, {"sha": "df70a6e81166b8113d9b4a0b15785c6a3b90a6d9", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,6 +18,7 @@ use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n use rustc::infer::TransNormalize;\n use rustc::mir::Mir;\n use rustc::util::common::MemoizationMap;\n@@ -44,6 +45,8 @@ use rustc::hir;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n+use std::borrow::Cow;\n+use std::iter;\n use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n@@ -109,7 +112,16 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n             Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n                   monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n         }\n-        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+        ty::TyClosure(def_id, substs) => {\n+            let mut tys = substs.upvar_tys(def_id, ccx.tcx());\n+            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n+                if tys.next().is_some() {\n+                    None\n+                } else {\n+                    Some([first_ty, second_ty])\n+                }\n+            }))\n+        }\n         ty::TyTuple(tys) => {\n             if tys.len() != 2 {\n                 return None;\n@@ -815,7 +827,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n+    C_named_struct(cx.str_slice_type(), &[cs, C_uint(cx, len)])\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -1060,3 +1072,36 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n+\n+pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          ty: Ty<'tcx>)\n+                          -> Cow<'tcx, ty::BareFnTy<'tcx>>\n+{\n+    match ty.sty {\n+        ty::TyFnDef(_, _, fty) => Cow::Borrowed(fty),\n+        // Shims currently have type TyFnPtr. Not sure this should remain.\n+        ty::TyFnPtr(fty) => Cow::Borrowed(fty),\n+        ty::TyClosure(def_id, substs) => {\n+            let tcx = ccx.tcx();\n+            let ty::ClosureTy { unsafety, abi, sig } = tcx.closure_type(def_id, substs);\n+\n+            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+            let env_ty = match tcx.closure_kind(def_id) {\n+                ty::ClosureKind::Fn => tcx.mk_imm_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnMut => tcx.mk_mut_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnOnce => ty,\n+            };\n+\n+            let sig = sig.map_bound(|sig| ty::FnSig {\n+                inputs: iter::once(env_ty).chain(sig.inputs).collect(),\n+                ..sig\n+            });\n+            Cow::Owned(ty::BareFnTy { unsafety: unsafety, abi: abi, sig: sig })\n+        }\n+        _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n+    }\n+}\n+\n+pub fn is_closure(tcx: TyCtxt, def_id: DefId) -> bool {\n+    tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n+}"}, {"sha": "670a84565fafbc31f442a58a28ef17ef5b8c3bcb", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -84,7 +84,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ty = ccx.tcx().item_type(def_id);\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -226,7 +226,7 @@ pub fn trans_static(ccx: &CrateContext,\n             v\n         };\n \n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "7657fc7d1c8b007cbdfdb14f130bfec6ca4f951a", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -25,7 +25,8 @@ use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n use trans_item::TransItem;\n-use type_::{Type, TypeNames};\n+use type_::Type;\n+use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n@@ -87,7 +88,6 @@ pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     previous_work_product: Option<WorkProduct>,\n-    tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n@@ -137,6 +137,7 @@ pub struct LocalCrateContext<'tcx> {\n     type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n+    str_slice_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n@@ -611,7 +612,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llcx: llcx,\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n-                tn: TypeNames::new(),\n                 needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n                 fn_pointer_shims: RefCell::new(FxHashMap()),\n                 drop_glues: RefCell::new(FxHashMap()),\n@@ -631,6 +631,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n+                str_slice_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n@@ -662,7 +663,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n \n             local_ccx.int_type = int_type;\n             local_ccx.opaque_vec_type = opaque_vec_type;\n-            local_ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n+            local_ccx.str_slice_type = str_slice_ty;\n \n             if shared.tcx.sess.count_llvm_insns() {\n                 base::init_insn_ctxt()\n@@ -700,22 +701,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local_ccxs[self.index]\n     }\n \n-    /// Get a (possibly) different `CrateContext` from the same\n-    /// `SharedCrateContext`.\n-    pub fn rotate(&'b self) -> CrateContext<'b, 'tcx> {\n-        let (_, index) =\n-            self.local_ccxs\n-                .iter()\n-                .zip(0..self.local_ccxs.len())\n-                .min_by_key(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n-                .unwrap();\n-        CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: &self.local_ccxs[..],\n-        }\n-    }\n-\n     /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n     /// the `SharedCrateContext`.  The iterator produces `(ccx, is_origin)`\n     /// pairs, where `is_origin` is `true` if `ccx` is `self` and `false`\n@@ -778,10 +763,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn tn<'a>(&'a self) -> &'a TypeNames {\n-        &self.local().tn\n-    }\n-\n     pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n         &self.shared.export_map\n     }\n@@ -885,6 +866,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().opaque_vec_type\n     }\n \n+    pub fn str_slice_type(&self) -> Type {\n+        self.local().str_slice_type\n+    }\n+\n     pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().closure_vals\n     }\n@@ -975,7 +960,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().local_gen_sym_counter.set(idx + 1);\n         // Include a '.' character, so there can be no accidental conflicts with\n         // user defined names\n-        format!(\"{}.{}\", prefix, idx)\n+        let mut name = String::with_capacity(prefix.len() + 6);\n+        name.push_str(prefix);\n+        name.push_str(\".\");\n+        base_n::push_str(idx as u64, base_n::MAX_BASE, &mut name);\n+        name\n     }\n }\n "}, {"sha": "5b9ef78ddc22e86f0dd4abc5e112b74fa820415b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -574,10 +574,11 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(_, ref substs) => {\n+        ty::TyClosure(def_id, substs) => {\n+            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx()).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &substs.upvar_tys,\n+                                   &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n@@ -1765,7 +1766,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.item_type(node_def_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "482275d298bc0e14c309f097669851dbec423b81", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -25,7 +25,6 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n                       FlagPrototyped};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n@@ -248,21 +247,19 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let mut fn_def_id = instance.def;\n-    let mut def_key = cx.tcx().def_key(fn_def_id);\n+    let def_key = cx.tcx().def_key(instance.def);\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n-    while def_key.disambiguated_data.data == DefPathData::ClosureExpr {\n-        fn_def_id.index = def_key.parent.expect(\"closure without a parent?\");\n-        def_key = cx.tcx().def_key(fn_def_id);\n-    }\n+\n+    let fn_def_id = cx.tcx().closure_base_def_id(instance.def);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().lookup_generics(fn_def_id);\n+    let generics = cx.tcx().item_generics(fn_def_id);\n+    let substs = instance.substs.truncate_to(cx.tcx(), generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n-                                                      instance.substs,\n+                                                      substs,\n                                                       file_metadata,\n                                                       &mut name);\n \n@@ -397,7 +394,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           generics: &ty::Generics<'tcx>)\n                                           -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().lookup_generics(def_id))\n+            get_type_parameter_names(cx, cx.tcx().item_generics(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n@@ -412,7 +409,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = cx.tcx().item_type(impl_def_id);\n                 let impl_self_ty = cx.tcx().erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(cx.shared(),\n                                                                     instance.substs,"}, {"sha": "7d6a672077a07c888fe4456224b9e25334a12f0c", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -19,14 +19,17 @@\n //!   interested in defining the ValueRef they return.\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n+\n use llvm::{self, ValueRef};\n use llvm::AttributePlace::Function;\n use rustc::ty;\n use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n+use common;\n use type_::Type;\n use value::Value;\n+use syntax::attr;\n \n use std::ffi::CString;\n \n@@ -69,6 +72,16 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n+    // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+    // compiler-rt, then we want to implicitly compile everything with hidden\n+    // visibility as we're going to link this object all over the place but\n+    // don't want the symbols to get exported.\n+    if attr::contains_name(ccx.tcx().map.krate_attrs(), \"compiler_builtins\") {\n+        unsafe {\n+            llvm::LLVMSetVisibility(llfn, llvm::Visibility::Hidden);\n+        }\n+    }\n+\n     match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n             llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n@@ -103,8 +116,8 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let abi = fn_type.fn_abi();\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_type.fn_sig());\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_type);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(ccx, abi, &sig, &[]);"}, {"sha": "d6d4d33923f1a91fb4529461eb54996c693bd2af", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -531,8 +531,8 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let mut cx = cx;\n     match t.sty {\n-        ty::TyClosure(_, ref substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+        ty::TyClosure(def_id, substs) => {\n+            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n                 let llupvar = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n                 cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n             }"}, {"sha": "d0cb302e1ab1fdb48bc649b77ecc436880289792", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -23,6 +23,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n@@ -55,6 +56,9 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+#[macro_use]\n+#[no_link]\n+extern crate rustc_bitflags;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -101,6 +105,7 @@ mod cabi_arm;\n mod cabi_asmjs;\n mod cabi_mips;\n mod cabi_mips64;\n+mod cabi_msp430;\n mod cabi_powerpc;\n mod cabi_powerpc64;\n mod cabi_s390x;\n@@ -109,7 +114,6 @@ mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n mod cleanup;\n-mod closure;\n mod collector;\n mod common;\n mod consts;"}, {"sha": "bca81fa36458f4726c2041d696148e1ed811e6fe", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -553,14 +553,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                // FIXME Shouldn't need to manually trigger closure instantiations.\n-                if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                    use closure;\n-                    closure::trans_closure_body_via_mir(self.ccx,\n-                                                        def_id,\n-                                                        self.monomorphize(&substs));\n-                }\n-\n                 match *kind {\n                     mir::AggregateKind::Array => {\n                         self.const_array(dest_ty, &fields)"}, {"sha": "12b17c26cbc41dbec9d3eb7a4b27bb67531b9fc6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -470,8 +470,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             } else {\n                 (arg_ty, false)\n             };\n-            let upvar_tys = if let ty::TyClosure(_, ref substs) = closure_ty.sty {\n-                &substs.upvar_tys[..]\n+            let upvar_tys = if let ty::TyClosure(def_id, substs) = closure_ty.sty {\n+                substs.upvar_tys(def_id, tcx)\n             } else {\n                 bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n             };"}, {"sha": "15cbbc720d6d40989d5adb7abdd1b70d77d2941f", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -133,15 +133,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     },\n                     _ => {\n-                        // FIXME Shouldn't need to manually trigger closure instantiations.\n-                        if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                            use closure;\n-\n-                            closure::trans_closure_body_via_mir(bcx.ccx(),\n-                                                                def_id,\n-                                                                bcx.monomorphize(&substs));\n-                        }\n-\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -729,11 +720,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n \n     let new_sty = match ty.sty {\n         TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"16\" => TyInt(I16),\n             \"32\" => TyInt(I32),\n             \"64\" => TyInt(I64),\n             _ => panic!(\"unsupported target word size\")\n         },\n         TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"16\" => TyUint(U16),\n             \"32\" => TyUint(U32),\n             \"64\" => TyUint(U64),\n             _ => panic!(\"unsupported target word size\")"}, {"sha": "09a1cbd319ac454455f037f6d99c95ecac6b31ed", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -495,7 +495,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = tcx.lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = tcx.item_type(impl_def_id);\n                 let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(scx,\n                                                                     instance.substs,"}, {"sha": "aa23a1817227657f8e71aad3d0051ca8ae4c8082", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -35,7 +35,8 @@ pub fn report_symbol_names(scx: &SharedCrateContext) {\n \n     let _ignore = tcx.dep_graph.in_ignore();\n     let mut visitor = SymbolNamesTest { scx: scx };\n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n+    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {"}, {"sha": "7fa59127704dc2c7e59504ff7eb6986f6605ef01", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 204, "deletions": 182, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,6 +18,7 @@ use attributes;\n use base;\n use consts;\n use context::{CrateContext, SharedCrateContext};\n+use common;\n use declare;\n use glue::DropGlueKind;\n use llvm;\n@@ -34,6 +35,7 @@ use type_of;\n use glue;\n use abi::{Abi, FnType};\n use back::symbol_names;\n+use std::fmt::Write;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n@@ -131,7 +133,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().map.local_def_id(node_id);\n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -153,7 +155,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+        let item_ty = ccx.tcx().item_type(instance.def);\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n         let mono_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &item_ty);\n \n@@ -166,6 +168,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n+        if let ty::TyClosure(..) = mono_ty.sty {\n+            // set an inline hint for all closures\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+        }\n+\n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n         ccx.instances().borrow_mut().insert(instance, lldecl);\n@@ -239,6 +246,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(ref instance) => {\n                 !instance.def.is_local() ||\n                 instance.substs.types().next().is_some() ||\n+                common::is_closure(tcx, instance.def) ||\n                 attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n             }\n             TransItem::DropGlue(..) => true,\n@@ -302,7 +310,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n                     DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n                 };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                let printer = DefPathBasedNames::new(tcx, false, false);\n+                printer.push_type_name(dg.ty(), &mut s);\n                 s\n             }\n             TransItem::Fn(instance) => {\n@@ -321,7 +330,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                                         -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n+            let printer = DefPathBasedNames::new(tcx, false, false);\n+            printer.push_instance_as_string(instance, &mut result);\n             result\n         }\n     }\n@@ -362,207 +372,219 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: Ty<'tcx>,\n-                                       output: &mut String) {\n-    match t.sty {\n-        ty::TyBool              => output.push_str(\"bool\"),\n-        ty::TyChar              => output.push_str(\"char\"),\n-        ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyNever             => output.push_str(\"!\"),\n-        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyAdt(adt_def, substs) => {\n-            push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, substs, &[], output);\n-        },\n-        ty::TyTuple(component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_unique_type_name(tcx, component_type, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push('>');\n-        },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n-            }\n+pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    omit_disambiguators: bool,\n+    omit_local_crate_name: bool,\n+}\n \n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n+impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               omit_disambiguators: bool,\n+               omit_local_crate_name: bool)\n+               -> Self {\n+        DefPathBasedNames {\n+            tcx: tcx,\n+            omit_disambiguators: omit_disambiguators,\n+            omit_local_crate_name: omit_local_crate_name,\n+        }\n+    }\n \n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyArray(inner_type, len) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push_str(&format!(\"; {}\", len));\n-            output.push(']');\n-        },\n-        ty::TySlice(inner_type) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push(']');\n-        },\n-        ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.def_id(), output);\n-            push_type_params(tcx,\n-                             trait_data.principal.skip_binder().substs,\n-                             &trait_data.projection_bounds,\n-                             output);\n-        },\n-        ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n+    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n+        match t.sty {\n+            ty::TyBool              => output.push_str(\"bool\"),\n+            ty::TyChar              => output.push_str(\"char\"),\n+            ty::TyStr               => output.push_str(\"str\"),\n+            ty::TyNever             => output.push_str(\"!\"),\n+            ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+            ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+            ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+            ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+            ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+            ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+            ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+            ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+            ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+            ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::TyAdt(adt_def, substs) => {\n+                self.push_def_path(adt_def.did, output);\n+                self.push_type_params(substs, &[], output);\n+            },\n+            ty::TyTuple(component_types) => {\n+                output.push('(');\n+                for &component_type in component_types {\n+                    self.push_type_name(component_type, output);\n+                    output.push_str(\", \");\n+                }\n+                if !component_types.is_empty() {\n+                    output.pop();\n+                    output.pop();\n+                }\n+                output.push(')');\n+            },\n+            ty::TyBox(inner_type) => {\n+                output.push_str(\"Box<\");\n+                self.push_type_name(inner_type, output);\n+                output.push('>');\n+            },\n+            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+                output.push('*');\n+                match mutbl {\n+                    hir::MutImmutable => output.push_str(\"const \"),\n+                    hir::MutMutable => output.push_str(\"mut \"),\n+                }\n \n-            if abi != ::abi::Abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+                output.push('&');\n+                if mutbl == hir::MutMutable {\n+                    output.push_str(\"mut \");\n+                }\n \n-            output.push_str(\"fn(\");\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyArray(inner_type, len) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                write!(output, \"; {}\", len).unwrap();\n+                output.push(']');\n+            },\n+            ty::TySlice(inner_type) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                output.push(']');\n+            },\n+            ty::TyTrait(ref trait_data) => {\n+                self.push_def_path(trait_data.principal.def_id(), output);\n+                self.push_type_params(trait_data.principal.skip_binder().substs,\n+                                      &trait_data.projection_bounds,\n+                                      output);\n+            },\n+            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+                if unsafety == hir::Unsafety::Unsafe {\n+                    output.push_str(\"unsafe \");\n+                }\n \n-            let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(tcx, parameter_type, output);\n-                    output.push_str(\", \");\n+                if abi != ::abi::Abi::Rust {\n+                    output.push_str(\"extern \\\"\");\n+                    output.push_str(abi.name());\n+                    output.push_str(\"\\\" \");\n                 }\n-                output.pop();\n-                output.pop();\n-            }\n \n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n+                output.push_str(\"fn(\");\n+\n+                let ty::FnSig {\n+                    inputs: sig_inputs,\n+                    output: sig_output,\n+                    variadic: sig_variadic\n+                } = self.tcx.erase_late_bound_regions_and_normalize(sig);\n+\n+                if !sig_inputs.is_empty() {\n+                    for &parameter_type in &sig_inputs {\n+                        self.push_type_name(parameter_type, output);\n+                        output.push_str(\", \");\n+                    }\n+                    output.pop();\n+                    output.pop();\n+                }\n+\n+                if sig_variadic {\n+                    if !sig_inputs.is_empty() {\n+                        output.push_str(\", ...\");\n+                    } else {\n+                        output.push_str(\"...\");\n+                    }\n                 }\n-            }\n \n-            output.push(')');\n+                output.push(')');\n \n-            if !sig.output.is_nil() {\n-                output.push_str(\" -> \");\n-                push_unique_type_name(tcx, sig.output, output);\n+                if !sig_output.is_nil() {\n+                    output.push_str(\" -> \");\n+                    self.push_type_name(sig_output, output);\n+                }\n+            },\n+            ty::TyClosure(def_id, ref closure_substs) => {\n+                self.push_def_path(def_id, output);\n+                let generics = self.tcx.item_generics(self.tcx.closure_base_def_id(def_id));\n+                let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n+                self.push_type_params(substs, &[], output);\n+            }\n+            ty::TyError |\n+            ty::TyInfer(_) |\n+            ty::TyProjection(..) |\n+            ty::TyParam(_) |\n+            ty::TyAnon(..) => {\n+                bug!(\"DefPathBasedNames: Trying to create type name for \\\n+                                         unexpected type: {:?}\", t);\n             }\n-        },\n-        ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(tcx, def_id, output);\n-            output.push_str(\"{\");\n-            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n-            output.push_str(\"}\");\n-            push_type_params(tcx, closure_substs.func_substs, &[], output);\n-        }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyParam(_) |\n-        ty::TyAnon(..) => {\n-            bug!(\"debuginfo: Trying to create type name for \\\n-                  unexpected type: {:?}\", t);\n         }\n     }\n-}\n \n-fn push_item_name(tcx: TyCtxt,\n-                  def_id: DefId,\n-                  output: &mut String) {\n-    let def_path = tcx.def_path(def_id);\n+    pub fn push_def_path(&self,\n+                         def_id: DefId,\n+                         output: &mut String) {\n+        let def_path = self.tcx.def_path(def_id);\n \n-    // some_crate::\n-    output.push_str(&tcx.crate_name(def_path.krate));\n-    output.push_str(\"::\");\n-\n-    // foo::bar::ItemName::\n-    for part in tcx.def_path(def_id).data {\n-        output.push_str(&format!(\"{}[{}]::\",\n-                        part.data.as_interned_str(),\n-                        part.disambiguator));\n-    }\n+        // some_crate::\n+        if !(self.omit_local_crate_name && def_id.is_local()) {\n+            output.push_str(&self.tcx.crate_name(def_path.krate));\n+            output.push_str(\"::\");\n+        }\n \n-    // remove final \"::\"\n-    output.pop();\n-    output.pop();\n-}\n+        // foo::bar::ItemName::\n+        for part in self.tcx.def_path(def_id).data {\n+            if self.omit_disambiguators {\n+                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+            } else {\n+                write!(output, \"{}[{}]::\",\n+                       part.data.as_interned_str(),\n+                       part.disambiguator).unwrap();\n+            }\n+        }\n \n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              substs: &Substs<'tcx>,\n-                              projections: &[ty::PolyExistentialProjection<'tcx>],\n-                              output: &mut String) {\n-    if substs.types().next().is_none() && projections.is_empty() {\n-        return;\n+        // remove final \"::\"\n+        output.pop();\n+        output.pop();\n     }\n \n-    output.push('<');\n-\n-    for type_parameter in substs.types() {\n-        push_unique_type_name(tcx, type_parameter, output);\n-        output.push_str(\", \");\n-    }\n+    pub fn push_type_params(&self,\n+                            substs: &Substs<'tcx>,\n+                            projections: &[ty::PolyExistentialProjection<'tcx>],\n+                            output: &mut String) {\n+        if substs.types().next().is_none() && projections.is_empty() {\n+            return;\n+        }\n \n-    for projection in projections {\n-        let projection = projection.skip_binder();\n-        let name = &projection.item_name.as_str();\n-        output.push_str(name);\n-        output.push_str(\"=\");\n-        push_unique_type_name(tcx, projection.ty, output);\n-        output.push_str(\", \");\n-    }\n+        output.push('<');\n \n-    output.pop();\n-    output.pop();\n+        for type_parameter in substs.types() {\n+            self.push_type_name(type_parameter, output);\n+            output.push_str(\", \");\n+        }\n \n-    output.push('>');\n-}\n+        for projection in projections {\n+            let projection = projection.skip_binder();\n+            let name = &projection.item_name.as_str();\n+            output.push_str(name);\n+            output.push_str(\"=\");\n+            self.push_type_name(projection.ty, output);\n+            output.push_str(\", \");\n+        }\n \n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, instance.substs, &[], output);\n-}\n+        output.pop();\n+        output.pop();\n \n-pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n-    let mut output = String::new();\n-    push_item_name(tcx, def_id, &mut output);\n-    output\n-}\n+        output.push('>');\n+    }\n \n-pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty: Ty<'tcx>)\n-                                -> String {\n-    let mut output = String::new();\n-    push_unique_type_name(tcx, ty, &mut output);\n-    output\n+    pub fn push_instance_as_string(&self,\n+                                   instance: Instance<'tcx>,\n+                                   output: &mut String) {\n+        self.push_def_path(instance.def, output);\n+        self.push_type_params(instance.substs, &[], output);\n+    }\n }"}, {"sha": "2b2776acab869fde07e9b802f4d9cb587f4d9420", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -15,7 +15,6 @@ use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n-use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use rustc::ty::layout;\n@@ -24,7 +23,6 @@ use std::ffi::CString;\n use std::fmt;\n use std::mem;\n use std::ptr;\n-use std::cell::RefCell;\n \n use libc::c_uint;\n \n@@ -321,26 +319,3 @@ impl Type {\n         }\n     }\n }\n-\n-/* Memory-managed object interface to type handles. */\n-\n-pub struct TypeNames {\n-    named_types: RefCell<FxHashMap<String, TypeRef>>,\n-}\n-\n-impl TypeNames {\n-    pub fn new() -> TypeNames {\n-        TypeNames {\n-            named_types: RefCell::new(FxHashMap())\n-        }\n-    }\n-\n-    pub fn associate_type(&self, s: &str, t: &Type) {\n-        assert!(self.named_types.borrow_mut().insert(s.to_string(),\n-                                                     t.to_ref()).is_none());\n-    }\n-\n-    pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().get(s).map(|x| Type::from_ref(*x))\n-    }\n-}"}, {"sha": "16d4f97200cb2147ad07734f45ee6cfc266d4f52", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -10,14 +10,12 @@\n \n #![allow(non_camel_case_types)]\n \n-use rustc::hir::def_id::DefId;\n use abi::FnType;\n use adt;\n use common::*;\n use machine;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Substs;\n-\n+use trans_item::DefPathBasedNames;\n use type_::Type;\n \n use syntax::ast;\n@@ -238,7 +236,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               if let ty::TyStr = ty.sty {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n-                  cx.tn().find_type(\"str_slice\").unwrap()\n+                  cx.str_slice_type()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n                   let info_ty = unsized_info_ty(cx, ty);\n@@ -282,12 +280,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let n = t.simd_size(cx.tcx()) as u64;\n           Type::vector(&llet, n)\n       }\n-      ty::TyAdt(def, substs) => {\n+      ty::TyAdt(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n-          let name = llvm_type_name(cx, def.did, substs);\n+          let name = llvm_type_name(cx, t);\n           adt::incomplete_type_of(cx, t, &name[..])\n       }\n \n@@ -319,21 +317,9 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     layout.align(&cx.tcx().data_layout).abi() as machine::llalign\n }\n \n-fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                            did: DefId,\n-                            substs: &Substs<'tcx>)\n-                            -> String {\n-    let base = cx.tcx().item_path_str(did);\n-    let strings: Vec<String> = substs.types().map(|t| t.to_string()).collect();\n-    let tstr = if strings.is_empty() {\n-        base\n-    } else {\n-        format!(\"{}<{}>\", base, strings.join(\", \"))\n-    };\n-\n-    if did.is_local() {\n-        tstr\n-    } else {\n-        format!(\"{}.{}\", did.krate, tstr)\n-    }\n+fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {\n+    let mut name = String::with_capacity(32);\n+    let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n+    printer.push_type_name(ty, &mut name);\n+    name\n }"}, {"sha": "f08d26373e50e979ef977f2c2346a77275eda918", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -18,6 +18,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "9bde6b0c4d9953b85263998507ca9e3709217266", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,12 +16,12 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type_scheme()`\n-//! function triggers a recursive call to `type_scheme_of_item()`\n+//! `AstConv` instance; in this phase, the `get_item_type()`\n+//! function triggers a recursive call to `type_of_item()`\n //! (note that `ast_ty_to_ty()` will detect recursive types and report\n //! an error).  In the check phase, when the FnCtxt is used as the\n-//! `AstConv`, `get_item_type_scheme()` just looks up the item type in\n-//! `tcx.tcache` (using `ty::lookup_item_type`).\n+//! `AstConv`, `get_item_type()` just looks up the item type in\n+//! `tcx.types` (using `TyCtxt::item_type`).\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required\n@@ -85,11 +85,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_generics(&self, span: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n \n-    /// Identify the type scheme for an item with a type, like a type\n-    /// alias, fn, or struct. This allows you to figure out the set of\n-    /// type parameters defined on the item.\n-    fn get_item_type_scheme(&self, span: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n+    /// Identify the type for an item, like a type alias, fn, or struct.\n+    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>;\n \n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n@@ -938,8 +935,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let decl_ty = match self.get_item_type_scheme(span, did) {\n-            Ok(type_scheme) => type_scheme.ty,\n+        let decl_ty = match self.get_item_type(span, did) {\n+            Ok(ty) => ty,\n             Err(ErrorReported) => {\n                 return tcx.types.err;\n             }\n@@ -1521,8 +1518,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 tcx.prohibit_type_params(base_segments);\n-                let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.tables().node_id_to_type(impl_id);\n+                let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {\n@@ -2152,27 +2148,32 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n             \"expected\"\n         };\n         let arguments_plural = if required == 1 { \"\" } else { \"s\" };\n-        struct_span_err!(tcx.sess, span, E0243, \"wrong number of type arguments\")\n-            .span_label(\n-                span,\n-                &format!(\"{} {} type argument{}, found {}\",\n-                         expected, required, arguments_plural, supplied)\n-            )\n+\n+        struct_span_err!(tcx.sess, span, E0243,\n+                \"wrong number of type arguments: {} {}, found {}\",\n+                expected, required, supplied)\n+            .span_label(span,\n+                &format!(\"{} {} type argument{}\",\n+                    expected,\n+                    required,\n+                    arguments_plural))\n             .emit();\n     } else if supplied > accepted {\n-        let expected = if required == 0 {\n-            \"expected no\".to_string()\n-        } else if required < accepted {\n+        let expected = if required < accepted {\n             format!(\"expected at most {}\", accepted)\n         } else {\n             format!(\"expected {}\", accepted)\n         };\n         let arguments_plural = if accepted == 1 { \"\" } else { \"s\" };\n \n-        struct_span_err!(tcx.sess, span, E0244, \"wrong number of type arguments\")\n+        struct_span_err!(tcx.sess, span, E0244,\n+                \"wrong number of type arguments: {}, found {}\",\n+                expected, supplied)\n             .span_label(\n                 span,\n-                &format!(\"{} type argument{}, found {}\", expected, arguments_plural, supplied)\n+                &format!(\"{} type argument{}\",\n+                    if accepted == 0 { \"expected no\" } else { &expected },\n+                    arguments_plural)\n             )\n             .emit();\n     }"}, {"sha": "556d1f84fccdc2ff5276139d1c12c3b3d2ef9718", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,7 +11,8 @@\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer;\n+use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n use util::nodemap::FxHashMap;\n@@ -450,25 +451,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => false\n             };\n \n-            let origin = if is_if_let_fallback {\n-                TypeOrigin::IfExpressionWithNoElse(expr.span)\n+            let cause = if is_if_let_fallback {\n+                self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse)\n             } else {\n-                TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+                self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                    arm_span: arm.body.span,\n+                    source: match_src\n+                })\n             };\n \n             let result = if is_if_let_fallback {\n-                self.eq_types(true, origin, arm_ty, result_ty)\n-                    .map(|InferOk { obligations, .. }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                self.eq_types(true, &cause, arm_ty, result_ty)\n+                    .map(|infer_ok| {\n+                        self.register_infer_ok_obligations(infer_ok);\n                         arm_ty\n                     })\n             } else if i == 0 {\n                 // Special-case the first arm, as it has no \"previous expressions\".\n                 self.try_coerce(&arm.body, arm_ty, coerce_first)\n             } else {\n                 let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body, arm_ty)\n+                self.try_find_coercion_lub(&cause, prev_arms, result_ty, &arm.body, arm_ty)\n             };\n \n             result_ty = match result {\n@@ -479,7 +482,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         (result_ty, arm_ty)\n                     };\n-                    self.report_mismatched_types(origin, expected, found, e);\n+                    self.report_mismatched_types(&cause, expected, found, e);\n                     self.tcx.types.err\n                 }\n             };"}, {"sha": "4edf0011cb39044d8ed60620ab41a82967879095", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -105,7 +105,6 @@ enum CastError {\n     NeedViaPtr,\n     NeedViaThinPtr,\n     NeedViaInt,\n-    NeedViaUsize,\n     NonScalar,\n }\n \n@@ -139,26 +138,39 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n         match e {\n-            CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |\n-            CastError::NeedViaInt |\n-            CastError::NeedViaUsize => {\n+            CastError::NeedViaPtr => {\n+                let mut err = fcx.type_error_struct(self.span,\n+                                                    |actual| {\n+                                                        format!(\"casting `{}` as `{}` is invalid\",\n+                                                                actual,\n+                                                                fcx.ty_to_string(self.cast_ty))\n+                                                    },\n+                                                    self.expr_ty);\n+                if self.cast_ty.is_uint() {\n+                    err.help(&format!(\"cast through {} first\",\n+                                      match e {\n+                                          CastError::NeedViaPtr => \"a raw pointer\",\n+                                          CastError::NeedViaThinPtr => \"a thin pointer\",\n+                                          _ => bug!(),\n+                                      }));\n+                }\n+                err.emit();\n+            }\n+            CastError::NeedViaInt => {\n                 fcx.type_error_struct(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-                    .help(&format!(\"cast through {} first\",\n-                                   match e {\n-                                       CastError::NeedViaPtr => \"a raw pointer\",\n-                                       CastError::NeedViaThinPtr => \"a thin pointer\",\n-                                       CastError::NeedViaInt => \"an integer\",\n-                                       CastError::NeedViaUsize => \"a usize\",\n-                                       _ => bug!(),\n-                                   }))\n-                    .emit();\n+                                      |actual| {\n+                                          format!(\"casting `{}` as `{}` is invalid\",\n+                                                  actual,\n+                                                  fcx.ty_to_string(self.cast_ty))\n+                                      },\n+                                      self.expr_ty)\n+                   .help(&format!(\"cast through {} first\",\n+                                  match e {\n+                                      CastError::NeedViaInt => \"an integer\",\n+                                      _ => bug!(),\n+                                  }))\n+                   .emit();\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n@@ -366,21 +378,23 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Int(Bool), Float) |\n             (Int(CEnum), Float) |\n             (Int(Char), Float) => Err(CastError::NeedViaInt),\n+\n             (Int(Bool), Ptr(_)) |\n             (Int(CEnum), Ptr(_)) |\n-            (Int(Char), Ptr(_)) => Err(CastError::NeedViaUsize),\n+            (Int(Char), Ptr(_)) |\n+            (Ptr(_), Float) |\n+            (FnPtr, Float) |\n+            (Float, Ptr(_)) => Err(CastError::IllegalCast),\n \n             // ptr -> *\n             (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n             (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n-            (Ptr(_), Float) | (FnPtr, Float) => Err(CastError::NeedViaUsize),\n             (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n             (RPtr(_), Int(_)) |\n             (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n             // * -> ptr\n             (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n-            (Float, Ptr(_)) => Err(CastError::NeedViaUsize),\n             (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n \n             // prim -> prim\n@@ -391,7 +405,6 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Int(_), Int(_)) | (Int(_), Float) | (Float, Int(_)) | (Float, Float) => {\n                 Ok(CastKind::NumericCast)\n             }\n-\n         }\n     }\n "}, {"sha": "75287d4064ae1df607a970ce8a9d1c12292e8df7", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -47,12 +47,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      body: &'gcx hir::Expr,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n-        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n-\n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n                opt_kind,\n                expected_sig);\n \n+        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n         let mut fn_ty = AstConv::ty_of_closure(self,\n                                                hir::Unsafety::Normal,\n                                                decl,\n@@ -62,16 +61,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n-        let upvar_tys = self.next_ty_vars(num_upvars);\n-\n-        debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n-               expr.id,\n-               upvar_tys);\n-\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n-                                               self.parameter_environment.free_substs,\n-                                               &upvar_tys);\n+            self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n+                |_, _| span_bug!(expr.span, \"closure has region param\"),\n+                |_, _| self.infcx.next_ty_var()\n+            )\n+        );\n+\n+        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         let fn_sig = self.tcx\n             .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),"}, {"sha": "718c273785ae91f84c94d7e1a035d5a25db9cec8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -63,8 +63,8 @@\n use check::FnCtxt;\n \n use rustc::hir;\n-use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::infer::{Coercion, InferOk, TypeTrace};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n@@ -78,7 +78,7 @@ use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    origin: TypeOrigin,\n+    cause: ObligationCause<'tcx>,\n     use_lub: bool,\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n@@ -104,30 +104,25 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n }\n \n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, origin: TypeOrigin) -> Self {\n+    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n         Coerce {\n             fcx: fcx,\n-            origin: origin,\n+            cause: cause,\n             use_lub: false,\n             unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(self.origin, false, a, b);\n+            let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n-                    .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n-                        value\n-                    })\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n             } else {\n                 self.sub(false, trace, &a, &b)\n                     .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                        self.fcx.register_predicates(obligations);\n                         value\n                     })\n             }\n@@ -238,7 +233,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             _ => return self.unify_and_identity(a, b),\n         };\n \n-        let span = self.origin.span();\n+        let span = self.cause.span;\n \n         let mut first_error = None;\n         let mut r_borrow_var = None;\n@@ -430,7 +425,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n-                let coercion = Coercion(self.origin.span());\n+                let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n             }\n@@ -449,7 +444,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let mut leftover_predicates = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n-        let cause = ObligationCause::misc(self.origin.span(), self.body_id);\n+        let cause = ObligationCause::misc(self.cause.span, self.body_id);\n         queue.push_back(self.tcx\n             .predicate_for_trait_def(cause, coerce_unsized_did, 0, source, &[target]));\n \n@@ -635,7 +630,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n-        let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n+        let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n+        let mut coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n             let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n@@ -655,7 +651,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\").\n     pub fn try_find_coercion_lub<'b, E, I>(&self,\n-                                           origin: TypeOrigin,\n+                                           cause: &ObligationCause<'tcx>,\n                                            exprs: E,\n                                            prev_ty: Ty<'tcx>,\n                                            new: &'b hir::Expr,\n@@ -669,29 +665,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n-        let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n+        let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         match (&prev_ty.sty, &new_ty.sty) {\n             (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n                 let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n-                    .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n-                        value\n-                    })?;\n+                              .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n                 if a_def_id == b_def_id {\n                     // Same function, maybe the parameters match.\n                     let substs = self.commit_if_ok(|_| {\n                         self.lub(true, trace.clone(), &a_substs, &b_substs)\n-                            .map(|InferOk { value, obligations }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                value\n-                            })\n+                            .map(|ok| self.register_infer_ok_obligations(ok))\n                     });\n \n                     if let Ok(substs) = substs {\n@@ -715,7 +703,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let mut coerce = Coerce::new(self, origin);\n+        let mut coerce = Coerce::new(self, cause.clone());\n         coerce.use_lub = true;\n \n         // First try to coerce the new expression to the type of the previous ones,\n@@ -760,11 +748,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if !noop {\n                 return self.commit_if_ok(|_| {\n                     self.lub(true, trace.clone(), &prev_ty, &new_ty)\n-                        .map(|InferOk { value, obligations }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            value\n-                        })\n+                        .map(|ok| self.register_infer_ok_obligations(ok))\n                 });\n             }\n         }\n@@ -777,11 +761,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     self.commit_if_ok(|_| {\n                         self.lub(true, trace, &prev_ty, &new_ty)\n-                            .map(|InferOk { value, obligations }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                value\n-                            })\n+                            .map(|ok| self.register_infer_ok_obligations(ok))\n                     })\n                 }\n             }"}, {"sha": "2602ff05badd44e0a4d6bcc5389e6245235ae21e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n@@ -95,6 +95,17 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n+    let cause = ObligationCause {\n+        span: impl_m_span,\n+        body_id: impl_m_body_id,\n+        code: ObligationCauseCode::CompareImplMethodObligation {\n+            item_name: impl_m.name,\n+            impl_item_def_id: impl_m.def_id,\n+            trait_item_def_id: trait_m.def_id,\n+            lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n+        },\n+    };\n+\n     // This code is best explained by example. Consider a trait:\n     //\n     //     trait Trait<'t,T> {\n@@ -174,10 +185,10 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n-    let impl_m_predicates = tcx.lookup_predicates(impl_m.def_id);\n-    let trait_m_predicates = tcx.lookup_predicates(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n+    let impl_m_predicates = tcx.item_predicates(impl_m.def_id);\n+    let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n \n     // Check region bounds.\n     check_region_bounds_on_impl_method(ccx,\n@@ -193,7 +204,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.lookup_predicates(impl_m_predicates.parent.unwrap());\n+    let impl_predicates = tcx.item_predicates(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -235,20 +246,9 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n-            let cause = traits::ObligationCause {\n-                span: impl_m_span,\n-                body_id: impl_m_body_id,\n-                code: traits::ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name: impl_m.name,\n-                    impl_item_def_id: impl_m.def_id,\n-                    trait_item_def_id: trait_m.def_id,\n-                    lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n-                },\n-            };\n-\n             fulfillment_cx.borrow_mut().register_predicate_obligation(\n                 &infcx,\n-                traits::Obligation::new(cause, predicate));\n+                traits::Obligation::new(cause.clone(), predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -266,10 +266,9 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n-        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n         let m_fty = |method: &ty::AssociatedItem| {\n-            match tcx.lookup_item_type(method.def_id).ty.sty {\n+            match tcx.item_type(method.def_id).sty {\n                 ty::TyFnDef(_, _, f) => f,\n                 _ => bug!()\n             }\n@@ -315,7 +314,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.sub_types(false, origin, impl_fty, trait_fty)\n+        let sub_result = infcx.sub_types(false, &cause, impl_fty, trait_fty)\n             .map(|InferOk { obligations, .. }| {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n@@ -328,22 +327,25 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(&infcx,\n                                                                                     &terr,\n-                                                                                    origin,\n+                                                                                    &cause,\n                                                                                     impl_m,\n                                                                                     impl_sig,\n                                                                                     trait_m,\n                                                                                     trait_sig);\n \n-            let origin = TypeOrigin::MethodCompatCheck(impl_err_span);\n+            let cause = ObligationCause {\n+                span: impl_err_span,\n+                ..cause.clone()\n+            };\n \n             let mut diag = struct_span_err!(tcx.sess,\n-                                            origin.span(),\n+                                            cause.span,\n                                             E0053,\n                                             \"method `{}` has an incompatible type for trait\",\n                                             trait_m.name);\n \n             infcx.note_type_err(&mut diag,\n-                                origin,\n+                                &cause,\n                                 trait_err_span.map(|sp| (sp, format!(\"type in trait\"))),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_fty,\n@@ -429,7 +431,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      terr: &TypeError,\n-                                                     origin: TypeOrigin,\n+                                                     cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,\n                                                      trait_m: &ty::AssociatedItem,\n@@ -478,9 +480,9 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                    }\n                                }\n                            })\n-                           .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                           .unwrap_or((cause.span, tcx.map.span_if_local(trait_m.def_id)))\n             } else {\n-                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n@@ -499,25 +501,25 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n                          .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                             match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n+                             match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n                              }\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n+                             if infcx.sub_types(false, &cause, impl_sig.output, trait_sig.output)\n                                      .is_err() {\n                                          (impl_m_output.span(), Some(trait_m_output.span()))\n                                      } else {\n-                                         (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                                         (cause.span, tcx.map.span_if_local(trait_m.def_id))\n                                      }\n                          })\n             } else {\n-                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }\n         }\n-        _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n+        _ => (cause.span, tcx.map.span_if_local(trait_m.def_id)),\n     }\n }\n \n@@ -542,7 +544,7 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = tcx.item_type(method.def_id);\n         let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n@@ -601,8 +603,8 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n     let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n@@ -672,7 +674,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n     let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.lookup_item_type(method.def_id).ty.sty {\n+        match tcx.item_type(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         }\n@@ -785,9 +787,9 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.lookup_item_type(impl_c.def_id).ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.lookup_item_type(trait_c.def_id).ty.subst(tcx, trait_to_skol_substs);\n-        let mut origin = TypeOrigin::Misc(impl_c_span);\n+        let impl_ty = tcx.item_type(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n+        let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n         let err = infcx.commit_if_ok(|_| {\n             // There is no \"body\" here, so just pass dummy id.\n@@ -807,11 +809,12 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            infcx.sub_types(false, origin, impl_ty, trait_ty)\n-                .map(|InferOk { obligations, .. }| {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty())\n-                })\n+            infcx.sub_types(false, &cause, impl_ty, trait_ty)\n+                 .map(|InferOk { obligations, value: () }| {\n+                     for obligation in obligations {\n+                         fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                     }\n+                 })\n         });\n \n         if let Err(terr) = err {\n@@ -821,12 +824,12 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             // Locate the Span containing just the type of the offending impl\n             match tcx.map.expect_impl_item(impl_c_node_id).node {\n-                ImplItemKind::Const(ref ty, _) => origin = TypeOrigin::Misc(ty.span),\n+                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n \n             let mut diag = struct_span_err!(tcx.sess,\n-                                            origin.span(),\n+                                            cause.span,\n                                             E0326,\n                                             \"implemented const `{}` has an incompatible type for \\\n                                              trait\",\n@@ -840,7 +843,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             };\n \n             infcx.note_type_err(&mut diag,\n-                                origin,\n+                                &cause,\n                                 Some((trait_c_span, format!(\"type in trait\"))),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_ty,"}, {"sha": "ef1c08bdab549e3b82a7c02237249c6ce4717b80", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -11,7 +11,8 @@\n \n use check::FnCtxt;\n use rustc::ty::Ty;\n-use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::infer::{InferOk};\n+use rustc::traits::ObligationCause;\n \n use syntax_pos::Span;\n use rustc::hir;\n@@ -20,34 +21,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let origin = TypeOrigin::Misc(sp);\n-        match self.sub_types(false, origin, actual, expected) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+        let cause = self.misc(sp);\n+        match self.sub_types(false, &cause, actual, expected) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             },\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, actual, e);\n+                self.report_mismatched_types(&cause, expected, actual, e);\n             }\n         }\n     }\n \n     pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        self.demand_eqtype_with_origin(TypeOrigin::Misc(sp), expected, actual);\n+        self.demand_eqtype_with_origin(&self.misc(sp), expected, actual);\n     }\n \n     pub fn demand_eqtype_with_origin(&self,\n-                                     origin: TypeOrigin,\n+                                     cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n                                      actual: Ty<'tcx>)\n     {\n-        match self.eq_types(false, origin, actual, expected) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+        match self.eq_types(false, cause, actual, expected) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             },\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, actual, e);\n+                self.report_mismatched_types(cause, expected, actual, e);\n             }\n         }\n     }\n@@ -56,9 +55,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n-            let origin = TypeOrigin::Misc(expr.span);\n+            let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            self.report_mismatched_types(origin, expected, expr_ty, e);\n+            self.report_mismatched_types(&cause, expected, expr_ty, e);\n         }\n     }\n }"}, {"sha": "8868d1e54f4b9661362b845c5d769e4734b8de1e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::{self, InferOk};\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, Reveal};\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n@@ -41,8 +41,8 @@ use syntax_pos::{self, Span};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n-    let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n+    let dtor_self_type = ccx.tcx.item_type(drop_impl_did);\n+    let dtor_predicates = ccx.tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n@@ -85,16 +85,16 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        let named_type = tcx.lookup_item_type(self_type_did).ty;\n+        let named_type = tcx.item_type(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n         let fresh_impl_substs =\n             infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n-        match infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n-                             named_type, fresh_impl_self_ty) {\n+        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n+        match infcx.eq_types(true, cause, named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n@@ -177,7 +177,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = tcx.lookup_predicates(self_type_did);\n+    let generic_assumptions = tcx.item_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n@@ -482,8 +482,14 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyTuple(tys) |\n-        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) => {\n+        ty::TyClosure(def_id, substs) => {\n+            for ty in substs.upvar_tys(def_id, tcx) {\n+                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n+            }\n+            Ok(())\n+        }\n+\n+        ty::TyTuple(tys) => {\n             for ty in tys {\n                 iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n             }\n@@ -570,30 +576,30 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n // Constructs new Ty just like the type defined by `adt_def` coupled\n // with `substs`, except each type and lifetime parameter marked as\n-// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// `#[may_dangle]` in the Drop impl (identified by `impl_def_id`) is\n // respectively mapped to `()` or `'static`.\n //\n // For example: If the `adt_def` maps to:\n //\n //   enum Foo<'a, X, Y> { ... }\n //\n-// and the `impl_id` maps to:\n+// and the `impl_def_id` maps to:\n //\n //   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n //\n // then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   adt_def: ty::AdtDef<'tcx>,\n-                                  impl_id: DefId,\n+                                  impl_def_id: DefId,\n                                   substs: &Substs<'tcx>)\n                                   -> Ty<'tcx> {\n     // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n-    let impl_bindings = tcx.lookup_generics(impl_id);\n+    let impl_bindings = tcx.item_generics(impl_def_id);\n \n     // Get Substs attached to Self on `impl Drop`; process in parallel\n     // with `substs`, replacing dangling entries as appropriate.\n     let self_substs = {\n-        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        let impl_self_ty: Ty<'tcx> = tcx.item_type(impl_def_id);\n         if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n             assert_eq!(adt_def, self_adt_def);\n             self_substs\n@@ -648,5 +654,5 @@ fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             t\n         });\n \n-    return tcx.mk_adt(adt_def, &substs);\n+    tcx.mk_adt(adt_def, &substs)\n }"}, {"sha": "77106b8b0c3a14dd26b4da1f19cd81b65597d63e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -12,7 +12,7 @@\n //! intrinsics that the compiler exposes.\n \n use intrinsics;\n-use rustc::infer::TypeOrigin;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n@@ -34,7 +34,6 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n-    let i_ty = tcx.lookup_item_type(def_id);\n \n     let substs = Substs::for_item(tcx, def_id,\n                                   |_, _| tcx.mk_region(ty::ReErased),\n@@ -49,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             variadic: false,\n         }),\n     }));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, ref generics) => generics.span,\n@@ -64,8 +63,10 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .emit();\n     } else {\n         require_same_types(ccx,\n-                           TypeOrigin::IntrinsicType(it.span),\n-                           i_ty.ty,\n+                           &ObligationCause::new(it.span,\n+                                                 it.id,\n+                                                 ObligationCauseCode::IntrinsicType),\n+                           tcx.item_type(def_id),\n                            fty);\n     }\n }\n@@ -330,8 +331,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let def_id = tcx.map.local_def_id(it.id);\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -374,7 +375,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let sig = tcx.item_type(def_id).fn_sig();\n+                    let sig = tcx.no_late_bound_regions(sig).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "54e93978b798d9885e59890965047da326f8ab9c", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,7 +17,7 @@ use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n use rustc::hir;\n \n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method_generics = self.tcx.lookup_generics(pick.item.def_id);\n+        let method_generics = self.tcx.item_generics(pick.item.def_id);\n         let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n@@ -330,10 +330,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.sub_types(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+        match self.sub_types(false, &self.misc(self.span), self_ty, method_self_ty) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             }\n             Err(_) => {\n                 span_bug!(self.span,\n@@ -359,14 +358,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let def_id = pick.item.def_id;\n-        let method_predicates = self.tcx.lookup_predicates(def_id)\n+        let method_predicates = self.tcx.item_predicates(def_id)\n                                     .instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let fty = match self.tcx.lookup_item_type(def_id).ty.sty {\n+        let fty = match self.tcx.item_type(def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         };"}, {"sha": "66a532fd76acff445794decf6c7f29441e58e102", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n         let def_id = method_item.def_id;\n-        let generics = tcx.lookup_generics(def_id);\n+        let generics = tcx.item_generics(def_id);\n         assert_eq!(generics.types.len(), 0);\n         assert_eq!(generics.regions.len(), 0);\n \n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.lookup_item_type(def_id).ty;\n+        let original_method_ty = tcx.item_type(def_id);\n         let fty = match original_method_ty.sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()"}, {"sha": "545d4e788524f6317a07daae465436ca5fb74328", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,13 +16,13 @@ use super::suggest;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n+use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits;\n+use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer::{InferOk, TypeOrigin};\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use rustc::hir;\n use std::mem;\n use std::ops::Deref;\n@@ -672,9 +672,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let impl_type = self.tcx.lookup_item_type(impl_def_id);\n+        let impl_type = self.tcx.item_type(impl_def_id);\n         let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx, impl_type.ty, false) {\n+            match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n                 Some(simplified_type) => simplified_type,\n                 None => {\n                     return true;\n@@ -771,7 +771,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    def_id,\n                    substs);\n \n-            let trait_predicates = self.tcx.lookup_predicates(def_id);\n+            let trait_predicates = self.tcx.item_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -1032,10 +1032,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             // First check that the self type can be related.\n             match self.sub_types(false,\n-                                 TypeOrigin::Misc(DUMMY_SP),\n+                                 &ObligationCause::dummy(),\n                                  self_ty,\n                                  probe.xform_self_ty) {\n-                Ok(InferOk { obligations, .. }) => {\n+                Ok(InferOk { obligations, value: () }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty())\n                 }\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.lookup_predicates(impl_def_id);\n+            let impl_bounds = self.tcx.item_predicates(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n@@ -1171,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.lookup_item_type(method).ty.fn_sig().input(0);\n+        let self_ty = self.tcx.item_type(method).fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,\n@@ -1184,7 +1184,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        let generics = self.tcx.lookup_generics(method);\n+        let generics = self.tcx.item_generics(method);\n         assert_eq!(substs.types().count(), generics.parent_types as usize);\n         assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n@@ -1218,7 +1218,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+        let impl_ty = self.tcx.item_type(impl_def_id);\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,"}, {"sha": "4ae15740cf2a66a66a3065a5b9b99a994cbc28f5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let limit = if candidates.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                err.help(&format!(\"candidate #{}: `use {}`\",\n+                err.help(&format!(\"candidate #{}: `use {};`\",\n                                   i + 1,\n                                   self.tcx.item_path_str(*trait_did)));\n             }\n@@ -439,7 +439,7 @@ impl Ord for TraitInfo {\n /// Retrieve all traits in this crate and any dependent crates.\n pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     if ccx.all_traits.borrow().is_none() {\n-        use rustc::hir::intravisit;\n+        use rustc::hir::itemlikevisit;\n \n         let mut traits = vec![];\n \n@@ -450,7 +450,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v, 'a, 'tcx> intravisit::Visitor<'v> for Visitor<'a, 'tcx> {\n+        impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n@@ -460,8 +460,11 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                     _ => {}\n                 }\n             }\n+\n+            fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+            }\n         }\n-        ccx.tcx.map.krate().visit_all_items(&mut Visitor {\n+        ccx.tcx.map.krate().visit_all_item_likes(&mut Visitor {\n             map: &ccx.tcx.map,\n             traits: &mut traits,\n         });"}, {"sha": "f08178e49fb2e835eb12768c32ec484ffa076e35", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 136, "deletions": 113, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -86,9 +86,10 @@ use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n-use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n+                   TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n@@ -120,6 +121,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n@@ -524,30 +526,35 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_body(self.ccx, i);\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &'tcx hir::ImplItem) {\n+        // done as part of `visit_item` above\n+    }\n }\n \n pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-        ccx.tcx.visit_all_items_in_krate(DepNode::WfCheck, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n     })\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemType, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n+                                              &mut visit.as_deep_visitor());\n     })\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemBody, &mut visit);\n \n         // Process deferred obligations, now that all functions\n         // bodies have been fully inferred.\n@@ -597,7 +604,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &'tcx hir::Expr,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n+    let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n@@ -780,15 +787,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    check_representable(ccx.tcx, span, def_id);\n \n-    if ccx.tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n-        check_simd(ccx.tcx, span, id);\n+    if ccx.tcx.lookup_simd(def_id) {\n+        check_simd(ccx.tcx, span, def_id);\n     }\n }\n \n fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    check_representable(ccx.tcx, span, ccx.tcx.map.local_def_id(id));\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n@@ -807,15 +815,15 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n-                                             impl_items);\n+                                             impl_item_refs);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n           }\n@@ -831,7 +839,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n+        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let pty_ty = ccx.tcx.item_type(def_id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -847,8 +856,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n-                if !pty.generics.types.is_empty() {\n+                let generics = ccx.tcx.item_generics(ccx.tcx.map.local_def_id(item.id));\n+                if !generics.types.is_empty() {\n                     let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     span_help!(&mut err, item.span,\n@@ -876,10 +885,11 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, .., ref body) => {\n         check_bare_fn(ccx, &decl, &body, it.id, it.span);\n       }\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_refs) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        for impl_item in impl_items {\n+        for impl_item_ref in impl_item_refs {\n+            let impl_item = ccx.tcx.map.impl_item(impl_item_ref.id);\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n@@ -917,7 +927,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = ccx.tcx.lookup_generics(def_id);\n+    let generics = ccx.tcx.item_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -1016,7 +1026,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_items: &[hir::ImplItem]) {\n+                                            impl_item_refs: &[hir::ImplItemRef]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -1027,9 +1037,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n+    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.map.impl_item(iiref.id));\n+\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items {\n+    for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| ac.name == ty_impl_item.name);\n@@ -1098,7 +1110,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     if ty_trait_item.kind == ty::AssociatedKind::Type {\n-                        if ty_trait_item.has_value {\n+                        if ty_trait_item.defaultness.has_value() {\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n@@ -1132,7 +1144,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .unwrap_or(false);\n \n         if !is_implemented {\n-            if !trait_item.has_value {\n+            if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n                 invalidated_items.push(trait_item.name);\n@@ -1143,12 +1155,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let signature = |item: &ty::AssociatedItem| {\n         match item.kind {\n             ty::AssociatedKind::Method => {\n-                format!(\"{}\", tcx.lookup_item_type(item.def_id).ty.fn_sig().0)\n+                format!(\"{}\", tcx.item_type(item.def_id).fn_sig().0)\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", item.name.to_string(),\n-                        tcx.lookup_item_type(item.def_id).ty)\n+                format!(\"const {}: {:?};\", item.name.to_string(), tcx.item_type(item.def_id))\n             }\n         }\n     };\n@@ -1218,7 +1229,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                          expr: &'tcx hir::Expr,\n                          id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n     check_const_with_type(ccx, expr, decl_ty, id);\n }\n \n@@ -1227,9 +1238,9 @@ fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// pointer, which would mean their size is unbounded.\n fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n-                                 item_id: ast::NodeId)\n+                                 item_def_id: DefId)\n                                  -> bool {\n-    let rty = tcx.tables().node_id_to_type(item_id);\n+    let rty = tcx.item_type(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1238,7 +1249,6 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            let item_def_id = tcx.map.local_def_id(item_id);\n             tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n             return false\n         }\n@@ -1247,8 +1257,8 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return true\n }\n \n-pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.tables().node_id_to_type(id);\n+pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    let t = tcx.item_type(def_id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1328,7 +1338,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         disr_vals.push(current_disr_val);\n     }\n \n-    check_representable(ccx.tcx, sp, id);\n+    check_representable(ccx.tcx, sp, def_id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -1341,13 +1351,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn get_generics(&self, _: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_generics(id))\n+        Ok(self.tcx().item_generics(id))\n     }\n \n-    fn get_item_type_scheme(&self, _: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    fn get_item_type(&self, _: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_item_type(id))\n+        Ok(self.tcx().item_type(id))\n     }\n \n     fn get_trait_def(&self, _: Span, id: DefId)\n@@ -1521,6 +1530,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn cause(&self,\n+                 span: Span,\n+                 code: ObligationCauseCode<'tcx>)\n+                 -> ObligationCause<'tcx> {\n+        ObligationCause::new(span, self.body_id, code)\n+    }\n+\n+    pub fn misc(&self, span: Span) -> ObligationCause<'tcx> {\n+        self.cause(span, ObligationCauseCode::MiscObligation)\n+    }\n+\n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_type_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n@@ -1662,7 +1682,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// generic type scheme.\n     fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx> {\n-        let bounds = self.tcx.lookup_predicates(def_id);\n+        let bounds = self.tcx.item_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result.predicates);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -1687,7 +1707,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty_var = self.next_ty_var();\n                 self.anon_types.borrow_mut().insert(def_id, ty_var);\n \n-                let item_predicates = self.tcx.lookup_predicates(def_id);\n+                let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n                 let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n@@ -1786,6 +1806,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .register_predicate_obligation(self, obligation);\n     }\n \n+    pub fn register_predicates(&self,\n+                               obligations: Vec<traits::PredicateObligation<'tcx>>)\n+    {\n+        for obligation in obligations {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        self.register_predicates(infer_ok.obligations);\n+        infer_ok.value\n+    }\n+\n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n@@ -2096,15 +2129,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n                                     match self.eq_types(false,\n-                                            TypeOrigin::Misc(default.origin_span),\n-                                            ty, default.ty) {\n-                                        Ok(InferOk { obligations, .. }) => {\n-                                            // FIXME(#32730) propagate obligations\n-                                            assert!(obligations.is_empty())\n-                                        },\n-                                        Err(_) => {\n-                                            conflicts.push((*ty, default));\n-                                        }\n+                                                        &self.misc(default.origin_span),\n+                                                        ty,\n+                                                        default.ty) {\n+                                        Ok(ok) => self.register_infer_ok_obligations(ok),\n+                                        Err(_) => conflicts.push((*ty, default)),\n                                     }\n                                 }\n                             }\n@@ -2146,6 +2175,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     self.report_conflicting_default_types(\n                         first_default.origin_span,\n+                        self.body_id,\n                         first_default,\n                         second_default)\n                 }\n@@ -2194,10 +2224,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n                             match self.eq_types(false,\n-                                    TypeOrigin::Misc(default.origin_span),\n-                                    ty, default.ty) {\n-                                // FIXME(#32730) propagate obligations\n-                                Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                                                &self.misc(default.origin_span),\n+                                                ty,\n+                                                default.ty) {\n+                                Ok(ok) => self.register_infer_ok_obligations(ok),\n                                 Err(_) => {\n                                     result = Some(default);\n                                 }\n@@ -2742,11 +2772,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let ity = self.tcx.lookup_item_type(did);\n+        let ity = self.tcx.item_type(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n         let substs = self.fresh_substs_for_item(span, did);\n-        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n+        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n@@ -2760,18 +2790,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   formal_args: &[Ty<'tcx>])\n                                   -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            self.commit_regions_if_ok(|| {\n+            self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n-                let origin = TypeOrigin::Misc(call_span);\n-                let ures = self.sub_types(false, origin, formal_ret, ret_ty);\n+                let origin = self.misc(call_span);\n+                let ures = self.sub_types(false, &origin, formal_ret, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n-                    // FIXME(#32730) propagate obligations\n-                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Ok(ok) => self.register_infer_ok_obligations(ok),\n                     Err(e) => return Err(e),\n                 }\n \n@@ -2852,16 +2881,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n \n         let unit = self.tcx.mk_nil();\n-        let (origin, expected, found, result) =\n+        let (cause, expected_ty, found_ty, result);\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n+            cause = self.cause(sp, ObligationCauseCode::IfExpression);\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n-            let origin = TypeOrigin::IfExpression(sp);\n-            let result = if let Some(ref then) = then_blk.expr {\n-                let res = self.try_find_coercion_lub(origin, || Some(&**then),\n+            expected_ty = then_ty;\n+            found_ty = else_ty;\n+            result = if let Some(ref then) = then_blk.expr {\n+                let res = self.try_find_coercion_lub(&cause, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n \n                 // In case we did perform an adjustment, we have to update\n@@ -2876,33 +2907,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 res\n             } else {\n                 self.commit_if_ok(|_| {\n-                    let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n+                    let trace = TypeTrace::types(&cause, true, then_ty, else_ty);\n                     self.lub(true, trace, &then_ty, &else_ty)\n-                        .map(|InferOk { value, obligations }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            value\n-                        })\n+                        .map(|ok| self.register_infer_ok_obligations(ok))\n                 })\n             };\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n-\n-            (origin, then_ty, else_ty, result)\n         } else {\n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n \n-            let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n-            (origin, unit, then_ty,\n-             self.eq_types(true, origin, unit, then_ty)\n-                 .map(|InferOk { obligations, .. }| {\n-                     // FIXME(#32730) propagate obligations\n-                     assert!(obligations.is_empty());\n-                     unit\n-                 }))\n-        };\n+            cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n+            expected_ty = unit;\n+            found_ty = then_ty;\n+            result = self.eq_types(true, &cause, unit, then_ty)\n+                         .map(|ok| {\n+                             self.register_infer_ok_obligations(ok);\n+                             unit\n+                         });\n+        }\n \n         match result {\n             Ok(ty) => {\n@@ -2913,7 +2938,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, found, e);\n+                self.report_mismatched_types(&cause, expected_ty, found_ty, e);\n                 self.tcx.types.err\n             }\n         }\n@@ -3564,17 +3589,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let Some(ref e) = *expr_opt {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n             } else {\n-                let eq_result = self.eq_types(false,\n-                                              TypeOrigin::Misc(expr.span),\n-                                              self.ret_ty,\n-                                              tcx.mk_nil())\n-                    // FIXME(#32730) propagate obligations\n-                    .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n-                if eq_result.is_err() {\n-                    struct_span_err!(tcx.sess, expr.span, E0069,\n-                             \"`return;` in a function whose return type is not `()`\")\n-                        .span_label(expr.span, &format!(\"return type is not ()\"))\n-                        .emit();\n+                match self.eq_types(false,\n+                                    &self.misc(expr.span),\n+                                    self.ret_ty,\n+                                    tcx.mk_nil())\n+                {\n+                    Ok(ok) => self.register_infer_ok_obligations(ok),\n+                    Err(_) => {\n+                        struct_span_err!(tcx.sess, expr.span, E0069,\n+                                         \"`return;` in a function whose return type is not `()`\")\n+                            .span_label(expr.span, &format!(\"return type is not ()\"))\n+                            .emit();\n+                    }\n                 }\n             }\n             tcx.types.never\n@@ -3695,20 +3721,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             for (i, e) in args.iter().enumerate() {\n                 let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                let origin = TypeOrigin::Misc(e.span);\n+                let cause = self.misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n                 let result = if i == 0 {\n                     self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n                     let prev_elems = || args[..i].iter().map(|e| &**e);\n-                    self.try_find_coercion_lub(origin, prev_elems, unified, e, e_ty)\n+                    self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n                 };\n \n                 match result {\n                     Ok(ty) => unified = ty,\n                     Err(e) => {\n-                        self.report_mismatched_types(origin, unified, e_ty, e);\n+                        self.report_mismatched_types(&cause, unified, e_ty, e);\n                     }\n                 }\n             }\n@@ -4064,9 +4090,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // We're not diverging and there's an expected type, which,\n                 // in case it's not `()`, could result in an error higher-up.\n                 // We have a chance to error here early and be more helpful.\n-                let origin = TypeOrigin::Misc(blk.span);\n-                let trace = TypeTrace::types(origin, false, ty, ety);\n-                match self.sub_types(false, origin, ty, ety) {\n+                let cause = self.misc(blk.span);\n+                let trace = TypeTrace::types(&cause, false, ty, ety);\n+                match self.sub_types(false, &cause, ty, ety) {\n                     Ok(InferOk { obligations, .. }) => {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -4184,11 +4210,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.lookup_generics(def_id);\n+                let mut generics = self.tcx.item_generics(def_id);\n                 if let Some(def_id) = generics.parent {\n                     // Variant and struct constructors use the\n                     // generics of their parent type definition.\n-                    generics = self.tcx.lookup_generics(def_id);\n+                    generics = self.tcx.item_generics(def_id);\n                 }\n                 type_segment = Some((segments.last().unwrap(), generics));\n             }\n@@ -4198,7 +4224,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n                 fn_segment = Some((segments.last().unwrap(),\n-                                   self.tcx.lookup_generics(def_id)));\n+                                   self.tcx.item_generics(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4212,9 +4238,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n-                let generics = self.tcx.lookup_generics(def_id);\n+                let generics = self.tcx.item_generics(def_id);\n                 if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.lookup_generics(generics.parent.unwrap());\n+                    let parent_generics = self.tcx.item_generics(generics.parent.unwrap());\n                     type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n@@ -4344,9 +4370,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let ty = self.tcx.item_type(def.def_id());\n         assert!(!substs.has_escaping_regions());\n-        assert!(!scheme.ty.has_escaping_regions());\n+        assert!(!ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n@@ -4357,21 +4383,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n \n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n+            let ty = self.tcx.item_type(impl_def_id);\n \n-            let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n-            match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n-                Ok(InferOk { obligations, .. }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                }\n+            let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n+            match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {\n+                Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     span_bug!(span,\n                         \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\","}, {"sha": "a280001d5e99d24f511781532dfb8948bf5293e4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -91,7 +91,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1149,7 +1149,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     autoderefs: usize,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n-        debug!(\"link_autoref(autoref={:?})\", autoref);\n+        debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n@@ -1729,7 +1729,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // ```\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+        let trait_predicates = self.tcx.item_predicates(projection_ty.trait_ref.def_id);\n         assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)\n@@ -1762,10 +1762,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                            outlives);\n \n                     // check whether this predicate applies to our current projection\n-                    match self.eq_types(false, TypeOrigin::Misc(span), ty, outlives.0) {\n-                        Ok(InferOk { obligations, .. }) => {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n+                    let cause = self.fcx.misc(span);\n+                    match self.eq_types(false, &cause, ty, outlives.0) {\n+                        Ok(ok) => {\n+                            self.register_infer_ok_obligations(ok);\n                             Ok(outlives.1)\n                         }\n                         Err(_) => { Err(()) }"}, {"sha": "1ea47107c3b18cc9f88e974d5c62f29512d173a3", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -183,8 +183,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let closure_substs = match self.fcx.node_ty(id).sty {\n-            ty::TyClosure(_, ref substs) => substs,\n+        let (def_id, closure_substs) = match self.fcx.node_ty(id).sty {\n+            ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n@@ -197,7 +197,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         let final_upvar_tys = self.final_upvar_tys(id);\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n                id, closure_substs, final_upvar_tys);\n-        for (&upvar_ty, final_upvar_ty) in closure_substs.upvar_tys.iter().zip(final_upvar_tys) {\n+        for (upvar_ty, final_upvar_ty) in\n+            closure_substs.upvar_tys(def_id, self.fcx.tcx).zip(final_upvar_tys)\n+        {\n             self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n "}, {"sha": "1ad81660f836a40b84b46bd6296ed7a226672dbb", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -15,8 +15,7 @@ use CrateCtxt;\n \n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n-use rustc::infer::TypeOrigin;\n-use rustc::traits;\n+use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n@@ -29,15 +28,15 @@ use rustc::hir;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    code: traits::ObligationCauseCode<'tcx>,\n+    code: ObligationCauseCode<'tcx>,\n }\n \n /// Helper type of a temporary returned by .for_item(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    code: traits::ObligationCauseCode<'gcx>,\n+    code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n     span: Span\n }\n@@ -67,7 +66,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                -> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         CheckTypeWellFormedVisitor {\n             ccx: ccx,\n-            code: traits::ObligationCauseCode::MiscObligation\n+            code: ObligationCauseCode::MiscObligation\n         }\n     }\n \n@@ -179,18 +178,18 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.lookup_item_type(def_id).ty)\n+                                              fcx.tcx.item_type(def_id))\n             };\n \n             match item.kind {\n                 ty::AssociatedKind::Const => {\n-                    let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let ty = fcx.tcx.item_type(item.def_id);\n                     let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n-                    let method_ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n                     let fty = match method_ty.sty {\n@@ -204,8 +203,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                                free_id_outlive, self_ty);\n                 }\n                 ty::AssociatedKind::Type => {\n-                    if item.has_value {\n-                        let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    if item.defaultness.has_value() {\n+                        let ty = fcx.tcx.item_type(item.def_id);\n                         let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n@@ -276,7 +275,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx().lookup_predicates(trait_def_id);\n+        let predicates = self.tcx().item_predicates(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -353,8 +352,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.map.local_def_id(item.id);\n-            let type_scheme = fcx.tcx.lookup_item_type(def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n+            let ty = fcx.tcx.item_type(def_id);\n+            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n@@ -378,11 +377,11 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n+            let ty = fcx.tcx.item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n                                                           .free_substs,\n-                                                      &type_scheme.ty);\n+                                                      &ty);\n \n             fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n \n@@ -417,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.item_type(item_def_id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -426,7 +425,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n+            fcx.impl_implied_bounds(item_def_id, item.span)\n         });\n     }\n \n@@ -492,7 +491,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let span = method_sig.decl.inputs[0].pat.span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let method_ty = fcx.tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = fcx.tcx.item_type(method.def_id);\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n@@ -515,21 +514,21 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n-        let origin = TypeOrigin::MethodReceiver(span);\n-        fcx.demand_eqtype_with_origin(origin, rcvr_ty, self_arg_ty);\n+        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n+        fcx.demand_eqtype_with_origin(&cause, rcvr_ty, self_arg_ty);\n     }\n \n     fn check_variances_for_type_defn(&self,\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().tables().node_id_to_type(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n+        let ty = self.tcx().item_type(item_def_id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n \n-        let item_def_id = self.tcx().map.local_def_id(item.id);\n-        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let ty_predicates = self.tcx().item_predicates(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -583,8 +582,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n-    let generics = tcx.lookup_generics(def_id);\n-    let parent = tcx.lookup_generics(generics.parent.unwrap());\n+    let generics = tcx.item_generics(def_id);\n+    let parent = tcx.item_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()\n                                        .map(|tp| (tp.name, tp.def_id))\n@@ -654,7 +653,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,\n@@ -683,7 +682,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n-                let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+                let self_ty = self.tcx.item_type(impl_def_id);\n                 let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n                 vec![self_ty]\n             }"}, {"sha": "979ce82ff4ecd27524f9a3ed8a3801aabe994bf7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -20,8 +20,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::DefIdMap;\n-use write_substs_to_tcx;\n-use write_ty_to_tcx;\n \n use std::cell::Cell;\n \n@@ -67,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types(item_id);\n+        wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n     }\n }\n@@ -133,6 +131,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n+    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+        assert!(!ty.needs_infer());\n+        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+    }\n+\n     // Hacky hack: During type-checking, we treat *all* operators\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n@@ -241,15 +245,15 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        write_ty_to_tcx(self.fcx.ccx, l.id, var_ty);\n+        self.write_ty_to_tcx(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyArray(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n-                write_ty_to_tcx(self.fcx.ccx, count_expr.id, self.tcx().types.usize);\n+                self.write_ty_to_tcx(count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -302,13 +306,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&self, item_id: ast::NodeId) {\n+    fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        let item_def_id = self.fcx.tcx.map.local_def_id(item_id);\n-\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(def_id);\n@@ -349,10 +351,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.register_item_type(def_id, ty::TypeScheme {\n-                ty: outside_ty,\n-                generics: gcx.lookup_generics(item_def_id)\n-            });\n+            gcx.item_types.borrow_mut().insert(def_id, outside_ty);\n         }\n     }\n \n@@ -363,13 +362,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        write_ty_to_tcx(self.fcx.ccx, id, n_ty);\n+        self.write_ty_to_tcx(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n-            write_substs_to_tcx(self.fcx.ccx, id,\n-                                self.resolve(item_substs, reason));\n+            let item_substs = self.resolve(item_substs, reason);\n+            if !item_substs.is_noop() {\n+                debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n+                assert!(!item_substs.substs.needs_infer());\n+                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+            }\n         });\n     }\n "}, {"sha": "b4a10c52270e2f9f5560ec8e02e1a1668dcfa1d0", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if item.vis == hir::Public || item.span == DUMMY_SP {\n             return;\n@@ -58,10 +58,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n     let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    tcx.map.krate().visit_all_item_likes(&mut visitor);\n }"}, {"sha": "2663739e36b289462876c1d6d072aa63218c3d5a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -19,7 +19,7 @@ use hir::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n@@ -30,11 +30,11 @@ use rustc::ty::{TyProjection, TyAnon};\n use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use rustc::infer::{self, InferCtxt, TypeOrigin};\n+use rustc::infer::{self, InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n@@ -51,12 +51,15 @@ struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n@@ -87,8 +90,9 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_items_in_krate(DepNode::CoherenceCheckImpl,\n-                                                        &mut CoherenceCheckVisitor { cc: self });\n+        self.crate_context.tcx.visit_all_item_likes_in_krate(\n+            DepNode::CoherenceCheckImpl,\n+            &mut CoherenceCheckVisitor { cc: self });\n \n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n@@ -106,7 +110,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n-        let self_type = tcx.lookup_item_type(impl_did);\n+        let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -129,14 +133,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         } else {\n             // Skip inherent impls where the self type is an error\n             // type. This occurs with e.g. resolve failures (#30589).\n-            if self_type.ty.references_error() {\n+            if self_type.references_error() {\n                 return;\n             }\n \n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type.ty) {\n+            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type) {\n                 self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n@@ -175,8 +179,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n-            match self_type.ty.sty {\n+            let self_type = tcx.item_type(impl_did);\n+            match self_type.sty {\n                 ty::TyAdt(type_def, _) => {\n                     type_def.set_destructor(method_def_id);\n                 }\n@@ -232,13 +236,13 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n+            let self_type = tcx.item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n             let span = tcx.map.span(impl_node_id);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n+            let self_type = self_type.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n             debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n@@ -326,7 +330,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let source = tcx.lookup_item_type(impl_did).ty;\n+            let source = tcx.item_type(impl_did);\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n@@ -344,12 +348,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                    target);\n \n             tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-                let origin = TypeOrigin::Misc(span);\n+                let cause = ObligationCause::misc(span, impl_node_id);\n                 let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n                                    mt_b: ty::TypeAndMut<'gcx>,\n                                    mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n                     if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(origin,\n+                        infcx.report_mismatched_types(&cause,\n                                                       mk_ptr(mt_b.ty),\n                                                       target,\n                                                       ty::error::TypeError::Mutability);\n@@ -397,7 +401,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                                 }\n \n                                 // Ignore fields that aren't significantly changed\n-                                if let Ok(ok) = infcx.sub_types(false, origin, b, a) {\n+                                if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n                                     if ok.obligations.is_empty() {\n                                         return None;\n                                     }"}, {"sha": "a507077bef77e21eb27b11619cc8d5d40ee625a3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -17,12 +17,12 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n-    tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx: 'cx> {\n@@ -81,7 +81,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let self_ty = self.tcx.lookup_item_type(def_id).ty;\n+                let self_ty = self.tcx.item_type(def_id);\n                 match self_ty.sty {\n                     ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);\n@@ -380,8 +380,12 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n     }\n+\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "e5be7f63067a886231cff304d6556557ca230161", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -14,11 +14,11 @@\n \n use hir::def_id::DefId;\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use util::nodemap::DefIdMap;\n use lint;\n \n@@ -30,7 +30,7 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n-    tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n struct OverlapChecker<'cx, 'tcx: 'cx> {\n@@ -97,7 +97,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemEnum(..) |\n@@ -134,6 +134,12 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n \n+                if trait_ref.references_error() {\n+                    debug!(\"coherence: skipping impl {:?} with error {:?}\",\n+                           impl_def_id, trait_ref);\n+                    return\n+                }\n+\n                 let _task =\n                     self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n@@ -199,4 +205,7 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "6d5de8f250655e614603578355481a5ed210bc34", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -12,12 +12,12 @@\n //! crate or pertains to a type defined in this crate.\n \n use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut orphan = UnsafetyChecker { tcx: tcx };\n-    tcx.map.krate().visit_all_items(&mut orphan);\n+    let mut unsafety = UnsafetyChecker { tcx: tcx };\n+    tcx.map.krate().visit_all_item_likes(&mut unsafety);\n }\n \n struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n@@ -94,7 +94,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n@@ -106,4 +106,7 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "535b6bcdcba177dff99ac1d7429bbbcc54cbfaf9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "22be4491273ef751ecdfd351bef02aa3e317ed80", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "f5432c6e0fcd736c3ccc0141a97148b61b528171", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "9f5b73d9b30752ed45f31aead3cda46a24e9958b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "a1ee69791169e818c03abe7ab1d4ef7721d56e38", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "8a0c1c68322d078c9b135610d7898745c0a1756b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "0a3238480d9080efaf2821bf4623890f5140d448", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "185f897c1baa1cfb82226cb4d59e3abe8204e382", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "a141d0e4788dd845509131780a6d83a9c268ff38", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "19e084905aa92a03f0804fc93a6a7b0aac1238e3", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "eef530081abe358b00ec2da39f707682f4fc76f1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "44dadc4367b52cf411720b5bbd5514eb3445055d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 117, "deletions": 88, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "5ffab949d019c38afde76552f7d07b9e5d2bd861", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "7ee184c089ca44503437dc98102b555962bdffcc", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "3af7c20c1336e91f1941e0ceb50c449b246822ff", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "939fd6ccfc88e0e6f337d4fe04a4cc03d867f31e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "cd7a50d07e268e4ec03d5e882b2b7f846ccc8542", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "7b7be6e2eeeb3628c61afe8c5f70da74612c1e2a", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 142, "deletions": 5, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "159aa997b27285cc8e407df79d382752eee23e84", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "8bf9bbb13208b43f464aacea1cf9b4a9d5bf3913", "filename": "src/libstd/path.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}]}