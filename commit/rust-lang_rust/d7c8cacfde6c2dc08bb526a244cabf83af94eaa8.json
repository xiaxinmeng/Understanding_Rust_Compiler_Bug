{"sha": "d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YzhjYWNmZGU2YzJkYzA4YmI1MjZhMjQ0Y2FiZjgzYWY5NGVhYTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-13T22:59:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-14T19:24:09Z"}, "message": "rustc: Extract native function generation into trans::native", "tree": {"sha": "bf49e4a84e00cb66f003c4a0036bbaa503f7f648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf49e4a84e00cb66f003c4a0036bbaa503f7f648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "html_url": "https://github.com/rust-lang/rust/commit/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cc1e31f74e2714c10ca06daa7a446a32fda6b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc1e31f74e2714c10ca06daa7a446a32fda6b2a", "html_url": "https://github.com/rust-lang/rust/commit/4cc1e31f74e2714c10ca06daa7a446a32fda6b2a"}], "stats": {"total": 377, "additions": 194, "deletions": 183}, "files": [{"sha": "2750a345ae01b768948b520b7b24c971072bcc0e", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 183, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "patch": "@@ -4458,180 +4458,6 @@ fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     }\n }\n \n-type c_stack_tys = {\n-    arg_tys: [TypeRef],\n-    ret_ty: TypeRef,\n-    ret_def: bool,\n-    base_fn_ty: TypeRef,\n-    bundle_ty: TypeRef,\n-    shim_fn_ty: TypeRef\n-};\n-\n-fn c_stack_tys(ccx: @crate_ctxt,\n-               id: ast::node_id) -> @c_stack_tys {\n-    alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n-      ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n-        let llargtys = type_of_explicit_args(ccx, arg_tys);\n-        let llretty = type_of(ccx, ret_ty);\n-        let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n-        ret @{\n-            arg_tys: llargtys,\n-            ret_ty: llretty,\n-            ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n-            base_fn_ty: T_fn(llargtys, llretty),\n-            bundle_ty: bundle_ty,\n-            shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n-        };\n-      }\n-      _ {\n-          // Precondition?\n-          ccx.tcx.sess.bug(\"c_stack_tys called on non-function type\");\n-      }\n-    }\n-}\n-\n-// For each native function F, we generate a wrapper function W and a shim\n-// function S that all work together.  The wrapper function W is the function\n-// that other rust code actually invokes.  Its job is to marshall the\n-// arguments into a struct.  It then uses a small bit of assembly to switch\n-// over to the C stack and invoke the shim function.  The shim function S then\n-// unpacks the arguments from the struct and invokes the actual function F\n-// according to its specified calling convention.\n-//\n-// Example: Given a native c-stack function F(x: X, y: Y) -> Z,\n-// we generate a wrapper function W that looks like:\n-//\n-//    void W(Z* dest, void *env, X x, Y y) {\n-//        struct { X x; Y y; Z *z; } args = { x, y, z };\n-//        call_on_c_stack_shim(S, &args);\n-//    }\n-//\n-// The shim function S then looks something like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         *args->z = F(args->x, args->y);\n-//     }\n-//\n-// However, if the return type of F is dynamically sized or of aggregate type,\n-// the shim function looks like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         F(args->z, args->x, args->y);\n-//     }\n-//\n-// Note: on i386, the layout of the args struct is generally the same as the\n-// desired layout of the arguments on the C stack.  Therefore, we could use\n-// upcall_alloc_c_stack() to allocate the `args` structure and switch the\n-// stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n-// function itself is unnecessary). We used to do this, in fact, and will\n-// perhaps do so in the future.\n-fn trans_native_mod(ccx: @crate_ctxt,\n-                    native_mod: ast::native_mod, abi: ast::native_abi) {\n-    fn build_shim_fn(ccx: @crate_ctxt,\n-                     native_item: @ast::native_item,\n-                     tys: @c_stack_tys,\n-                     cc: lib::llvm::CallConv) -> ValueRef {\n-        let lname = link_name(native_item);\n-\n-        // Declare the \"prototype\" for the base function F:\n-        let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n-\n-        // Create the shim function:\n-        let shim_name = lname + \"__c_stack_shim\";\n-        let llshimfn = decl_internal_cdecl_fn(\n-            ccx.llmod, shim_name, tys.shim_fn_ty);\n-\n-        // Declare the body of the shim function:\n-        let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n-        let bcx = new_top_block_ctxt(fcx, none);\n-        let lltop = bcx.llbb;\n-        let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n-        let i = 0u, n = tys.arg_tys.len();\n-        let llargvals = [];\n-        while i < n {\n-            let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n-            llargvals += [llargval];\n-            i += 1u;\n-        }\n-\n-        // Create the call itself and store the return value:\n-        let llretval = CallWithConv(bcx, llbasefn,\n-                                    llargvals, cc); // r\n-        if tys.ret_def {\n-            // R** llretptr = &args->r;\n-            let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n-            // R* llretloc = *llretptr; /* (args->r) */\n-            let llretloc = Load(bcx, llretptr);\n-            // *args->r = r;\n-            Store(bcx, llretval, llretloc);\n-        }\n-\n-        // Finish up:\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n-\n-        ret llshimfn;\n-    }\n-\n-    fn build_wrap_fn(ccx: @crate_ctxt,\n-                     tys: @c_stack_tys,\n-                     num_tps: uint,\n-                     llshimfn: ValueRef,\n-                     llwrapfn: ValueRef) {\n-        let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n-        let bcx = new_top_block_ctxt(fcx, none);\n-        let lltop = bcx.llbb;\n-\n-        // Allocate the struct and write the arguments into it.\n-        let llargbundle = alloca(bcx, tys.bundle_ty);\n-        let i = 0u, n = tys.arg_tys.len();\n-        let implicit_args = 2u + num_tps; // ret + env\n-        while i < n {\n-            let llargval = llvm::LLVMGetParam(llwrapfn,\n-                                              (i + implicit_args) as c_uint);\n-            store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n-            i += 1u;\n-        }\n-        let llretptr = llvm::LLVMGetParam(llwrapfn, 0 as c_uint);\n-        store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n-\n-        // Create call itself.\n-        let call_shim_on_c_stack = ccx.upcalls.call_shim_on_c_stack;\n-        let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n-        let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n-        Call(bcx, call_shim_on_c_stack, [llrawargbundle, llshimfnptr]);\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n-    }\n-\n-    let cc = lib::llvm::CCallConv;\n-    alt abi {\n-      ast::native_abi_rust_intrinsic { ret; }\n-      ast::native_abi_cdecl { cc = lib::llvm::CCallConv; }\n-      ast::native_abi_stdcall { cc = lib::llvm::X86StdcallCallConv; }\n-    }\n-\n-    for native_item in native_mod.items {\n-      alt native_item.node {\n-        ast::native_item_fn(fn_decl, tps) {\n-          let id = native_item.id;\n-          let tys = c_stack_tys(ccx, id);\n-          alt ccx.item_ids.find(id) {\n-            some(llwrapfn) {\n-              let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n-              build_wrap_fn(ccx, tys, tps.len(), llshimfn, llwrapfn);\n-            }\n-            none {\n-              ccx.sess.span_fatal(\n-                  native_item.span,\n-                  \"unbound function item in trans_native_mod\");\n-            }\n-          }\n-        }\n-      }\n-    }\n-}\n-\n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let path = alt ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) { p }\n@@ -4690,7 +4516,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n           either::right(abi_) { abi_ }\n           either::left(msg) { ccx.sess.span_fatal(item.span, msg) }\n         };\n-        trans_native_mod(ccx, native_mod, abi);\n+        native::trans_native_mod(ccx, native_mod, abi);\n       }\n       _ {/* fall through */ }\n     }\n@@ -4837,13 +4663,6 @@ fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-fn link_name(i: @ast::native_item) -> str {\n-    alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n-      none { ret i.ident; }\n-      option::some(ln) { ret ln; }\n-    }\n-}\n-\n fn collect_native_item(ccx: @crate_ctxt,\n                        abi: @mutable option<ast::native_abi>,\n                        i: @ast::native_item) {\n@@ -4872,7 +4691,7 @@ fn collect_native_item(ccx: @crate_ctxt,\n             let fn_type = type_of_fn_from_ty(\n                 ccx, node_type,\n                 vec::map(tps, {|p| param_bounds(ccx, p)}));\n-            let ri_name = \"rust_intrinsic_\" + link_name(i);\n+            let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n             let llnativefn = get_extern_fn(\n                 ccx.externs, ccx.llmod, ri_name,\n                 lib::llvm::CCallConv, fn_type);"}, {"sha": "67d320fa6681ecc2e88c7134afef368e5e5bad69", "filename": "src/comp/middle/trans/native.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "patch": "@@ -0,0 +1,191 @@\n+import driver::session::session;\n+import ctypes::c_uint;\n+import front::attr;\n+import lib::llvm::{ llvm, TypeRef, ValueRef };\n+import syntax::ast;\n+import common::*;\n+import build::*;\n+import base::*;\n+\n+export link_name, trans_native_mod;\n+\n+fn link_name(i: @ast::native_item) -> str {\n+    alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n+      none { ret i.ident; }\n+      option::some(ln) { ret ln; }\n+    }\n+}\n+\n+type c_stack_tys = {\n+    arg_tys: [TypeRef],\n+    ret_ty: TypeRef,\n+    ret_def: bool,\n+    base_fn_ty: TypeRef,\n+    bundle_ty: TypeRef,\n+    shim_fn_ty: TypeRef\n+};\n+\n+fn c_stack_tys(ccx: @crate_ctxt,\n+               id: ast::node_id) -> @c_stack_tys {\n+    alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n+      ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n+        let llargtys = type_of_explicit_args(ccx, arg_tys);\n+        let llretty = type_of(ccx, ret_ty);\n+        let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n+        ret @{\n+            arg_tys: llargtys,\n+            ret_ty: llretty,\n+            ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n+            base_fn_ty: T_fn(llargtys, llretty),\n+            bundle_ty: bundle_ty,\n+            shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n+        };\n+      }\n+      _ {\n+          // Precondition?\n+          ccx.tcx.sess.bug(\"c_stack_tys called on non-function type\");\n+      }\n+    }\n+}\n+\n+// For each native function F, we generate a wrapper function W and a shim\n+// function S that all work together.  The wrapper function W is the function\n+// that other rust code actually invokes.  Its job is to marshall the\n+// arguments into a struct.  It then uses a small bit of assembly to switch\n+// over to the C stack and invoke the shim function.  The shim function S then\n+// unpacks the arguments from the struct and invokes the actual function F\n+// according to its specified calling convention.\n+//\n+// Example: Given a native c-stack function F(x: X, y: Y) -> Z,\n+// we generate a wrapper function W that looks like:\n+//\n+//    void W(Z* dest, void *env, X x, Y y) {\n+//        struct { X x; Y y; Z *z; } args = { x, y, z };\n+//        call_on_c_stack_shim(S, &args);\n+//    }\n+//\n+// The shim function S then looks something like:\n+//\n+//     void S(struct { X x; Y y; Z *z; } *args) {\n+//         *args->z = F(args->x, args->y);\n+//     }\n+//\n+// However, if the return type of F is dynamically sized or of aggregate type,\n+// the shim function looks like:\n+//\n+//     void S(struct { X x; Y y; Z *z; } *args) {\n+//         F(args->z, args->x, args->y);\n+//     }\n+//\n+// Note: on i386, the layout of the args struct is generally the same as the\n+// desired layout of the arguments on the C stack.  Therefore, we could use\n+// upcall_alloc_c_stack() to allocate the `args` structure and switch the\n+// stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n+// function itself is unnecessary). We used to do this, in fact, and will\n+// perhaps do so in the future.\n+fn trans_native_mod(ccx: @crate_ctxt,\n+                    native_mod: ast::native_mod, abi: ast::native_abi) {\n+    fn build_shim_fn(ccx: @crate_ctxt,\n+                     native_item: @ast::native_item,\n+                     tys: @c_stack_tys,\n+                     cc: lib::llvm::CallConv) -> ValueRef {\n+        let lname = link_name(native_item);\n+\n+        // Declare the \"prototype\" for the base function F:\n+        let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n+\n+        // Create the shim function:\n+        let shim_name = lname + \"__c_stack_shim\";\n+        let llshimfn = decl_internal_cdecl_fn(\n+            ccx.llmod, shim_name, tys.shim_fn_ty);\n+\n+        // Declare the body of the shim function:\n+        let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n+        let bcx = new_top_block_ctxt(fcx, none);\n+        let lltop = bcx.llbb;\n+        let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n+        let i = 0u, n = vec::len(tys.arg_tys);\n+        let llargvals = [];\n+        while i < n {\n+            let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n+            llargvals += [llargval];\n+            i += 1u;\n+        }\n+\n+        // Create the call itself and store the return value:\n+        let llretval = CallWithConv(bcx, llbasefn,\n+                                    llargvals, cc); // r\n+        if tys.ret_def {\n+            // R** llretptr = &args->r;\n+            let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+            // R* llretloc = *llretptr; /* (args->r) */\n+            let llretloc = Load(bcx, llretptr);\n+            // *args->r = r;\n+            Store(bcx, llretval, llretloc);\n+        }\n+\n+        // Finish up:\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+\n+        ret llshimfn;\n+    }\n+\n+    fn build_wrap_fn(ccx: @crate_ctxt,\n+                     tys: @c_stack_tys,\n+                     num_tps: uint,\n+                     llshimfn: ValueRef,\n+                     llwrapfn: ValueRef) {\n+        let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n+        let bcx = new_top_block_ctxt(fcx, none);\n+        let lltop = bcx.llbb;\n+\n+        // Allocate the struct and write the arguments into it.\n+        let llargbundle = alloca(bcx, tys.bundle_ty);\n+        let i = 0u, n = vec::len(tys.arg_tys);\n+        let implicit_args = 2u + num_tps; // ret + env\n+        while i < n {\n+            let llargval = llvm::LLVMGetParam(llwrapfn,\n+                                              (i + implicit_args) as c_uint);\n+            store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n+            i += 1u;\n+        }\n+        let llretptr = llvm::LLVMGetParam(llwrapfn, 0 as c_uint);\n+        store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+\n+        // Create call itself.\n+        let call_shim_on_c_stack = ccx.upcalls.call_shim_on_c_stack;\n+        let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n+        let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n+        Call(bcx, call_shim_on_c_stack, [llrawargbundle, llshimfnptr]);\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+    }\n+\n+    let cc = lib::llvm::CCallConv;\n+    alt abi {\n+      ast::native_abi_rust_intrinsic { ret; }\n+      ast::native_abi_cdecl { cc = lib::llvm::CCallConv; }\n+      ast::native_abi_stdcall { cc = lib::llvm::X86StdcallCallConv; }\n+    }\n+\n+    for native_item in native_mod.items {\n+      alt native_item.node {\n+        ast::native_item_fn(fn_decl, tps) {\n+          let id = native_item.id;\n+          let tys = c_stack_tys(ccx, id);\n+          alt ccx.item_ids.find(id) {\n+            some(llwrapfn) {\n+              let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n+              build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n+            }\n+            none {\n+              ccx.sess.span_fatal(\n+                  native_item.span,\n+                  \"unbound function item in trans_native_mod\");\n+            }\n+          }\n+        }\n+      }\n+    }\n+}"}, {"sha": "ea65b970e3bbb8ff419d35bca8a5b1b72452a969", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d7c8cacfde6c2dc08bb526a244cabf83af94eaa8/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=d7c8cacfde6c2dc08bb526a244cabf83af94eaa8", "patch": "@@ -23,6 +23,7 @@ mod middle {\n         mod closure;\n         mod tvec;\n         mod impl;\n+        mod native;\n     }\n     mod ty;\n     mod ast_map;"}]}