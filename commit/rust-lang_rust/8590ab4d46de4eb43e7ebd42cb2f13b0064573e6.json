{"sha": "8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTBhYjRkNDZkZTRlYjQzZTdlYmQ0MmNiMmYxM2IwMDY0NTczZTY=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-19T04:48:35Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-31T18:55:45Z"}, "message": "More progress towards sort_by_key_reverse lint", "tree": {"sha": "8eeccfb1fe0848c8e1eef90531a7baf117126f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eeccfb1fe0848c8e1eef90531a7baf117126f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "html_url": "https://github.com/rust-lang/rust/commit/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24847ea53e332853597aca2c7dfe48a9f3be1de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/24847ea53e332853597aca2c7dfe48a9f3be1de8", "html_url": "https://github.com/rust-lang/rust/commit/24847ea53e332853597aca2c7dfe48a9f3be1de8"}], "stats": {"total": 168, "additions": 149, "deletions": 19}, "files": [{"sha": "e7a4c1ecaa954feff52fb6556126ff206b6cd098", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "patch": "@@ -998,6 +998,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n     store.register_late_pass(|| box redundant_clone::RedundantClone);\n     store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n+    store.register_late_pass(|| box sort_by_key_reverse::SortByKeyReverse);\n     store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n     store.register_late_pass(|| box missing_const_for_fn::MissingConstForFn);"}, {"sha": "d70391999a023cc0d78604236b707ae26fcacd39", "filename": "clippy_lints/src/sort_by_key_reverse.rs", "status": "modified", "additions": 113, "deletions": 18, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs?ref=8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "patch": "@@ -1,11 +1,12 @@\n-use crate::utils::{match_type, span_lint_and_sugg};\n+use crate::utils;\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_lint::{LateLintPass, LateContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_hir::*;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -40,18 +41,122 @@ struct LintTrigger {\n     unstable: bool,\n }\n \n+/// Detect if the two expressions are mirrored (identical, except one\n+/// contains a and the other replaces it with b)\n+fn mirrored_exprs(cx: &LateContext<'_, '_>, a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident: &Ident) -> bool {\n+    match (&a_expr.kind, &b_expr.kind) {\n+        // Two boxes with mirrored contents\n+        (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        // Two arrays with mirrored contents\n+        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs))\n+            => left_exprs.iter().zip(right_exprs.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // The two exprs are function calls.\n+        // Check to see that the function itself and its arguments are mirrored\n+        (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args))\n+            => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // The two exprs are method calls.\n+        // Check to see that the function is the same and the arguments are mirrored\n+        // This is enough because the receiver of the method is listed in the arguments\n+        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args))\n+            => left_segment.ident == right_segment.ident\n+                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // Two tuples with mirrored contents\n+        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs))\n+            => left_exprs.iter().zip(right_exprs.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // Two binary ops, which are the same operation and which have mirrored arguments\n+        (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right))\n+            => left_op.node == right_op.node\n+                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident),\n+        // Two unary ops, which are the same operation and which have the same argument\n+        (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr))\n+            => left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        // The two exprs are literals of some kind\n+        (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n+        (ExprKind::Cast(left_expr, _), ExprKind::Cast(right_expr, _))\n+            => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::DropTemps(left), ExprKind::DropTemps(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::Block(left, _), ExprKind::Block(right, _)) => mirrored_blocks(cx, left, a_ident, right, b_ident),\n+        (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident))\n+            => left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident),\n+        // The two exprs are `a` and `b`, directly\n+        (ExprKind::Path(QPath::Resolved(_, Path { segments: &[PathSegment { ident: left_ident, .. }], ..  },)),\n+         ExprKind::Path(QPath::Resolved(_, Path { segments: &[PathSegment { ident: right_ident, .. }], ..  },)),\n+        ) => &left_ident == a_ident && &right_ident == b_ident,\n+        // The two exprs are Paths to the same name (which is neither a nor b)\n+        (ExprKind::Path(QPath::Resolved(_, Path { segments: left_segments, .. })),\n+         ExprKind::Path(QPath::Resolved(_, Path { segments: right_segments, .. })))\n+            => left_segments.iter().zip(right_segments.iter()).all(|(left, right)| left.ident == right.ident)\n+                && left_segments.iter().all(|seg| &seg.ident != a_ident && &seg.ident != b_ident),\n+        // Matching expressions, but one or both is borrowed\n+        (ExprKind::AddrOf(left_kind, Mutability::Not, left_expr), ExprKind::AddrOf(right_kind, Mutability::Not, right_expr))\n+            => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr))\n+            => mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _)\n+            => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        // _ => false,\n+        (left, right) => {\n+            println!(\"{:?}\\n{:?}\", left, right);\n+            false\n+        },\n+    }\n+}\n+\n+/// Detect if the two blocks are mirrored (identical, except one\n+/// contains a and the other replaces it with b)\n+fn mirrored_blocks(cx: &LateContext<'_, '_>, a_block: &Block<'_>, a_ident: &Ident, b_block: &Block<'_>, b_ident: &Ident) -> bool {\n+    match (a_block, b_block) {\n+        (Block { stmts: left_stmts, expr: left_expr, .. },\n+         Block { stmts: right_stmts, expr: right_expr, .. })\n+            => left_stmts.iter().zip(right_stmts.iter()).all(|(left, right)| match (&left.kind, &right.kind) {\n+                (StmtKind::Expr(left_expr), StmtKind::Expr(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+                (StmtKind::Semi(left_expr), StmtKind::Semi(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+                (StmtKind::Item(left_item), StmtKind::Item(right_item)) => left_item.id == right_item.id,\n+                (StmtKind::Local(left), StmtKind::Local(right)) => mirrored_locals(cx, left, a_ident, right, b_ident),\n+                _ => false,\n+            }) && match (left_expr, right_expr) {\n+                (None, None) => true,\n+                (Some(left), Some(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+                _ => false,\n+            },\n+    }\n+}\n+\n+/// Check that the two \"Local\"s (let statements) are equal\n+fn mirrored_locals(cx: &LateContext<'_, '_>, a_local: &Local<'_>, a_ident: &Ident, b_local: &Local<'_>, b_ident: &Ident) -> bool {\n+    match (a_local, b_local) {\n+        (Local { pat: left_pat, init: left_expr, .. }, Local { pat: right_pat, init: right_expr, .. })\n+            => match (left_expr, right_expr) {\n+                (None, None) => true,\n+                (Some(left), Some(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+                _ => false,\n+            },\n+    }\n+}\n+\n fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n         if let ExprKind::MethodCall(name_ident, _, args) = &expr.kind;\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n-        if let [vec, Expr { kind: ExprKind::Closure(_, closure_decl, closure_body_id, _, _), .. }] = args;\n-        if closure_decl.inputs.len() == 2;\n-        if match_type(cx, &cx.tables.expr_ty(vec), &paths::VEC);\n+        if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n+        if utils::match_type(cx, &cx.tables.expr_ty(vec), &paths::VEC);\n+        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let &[\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, a_ident, _), .. }, ..},\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, b_ident, _), .. }, .. }\n+        ] = &closure_body.params;\n+        if let ExprKind::MethodCall(method_path, _, [ref b_expr, ref a_expr]) = &closure_body.value.kind;\n+        if method_path.ident.name.to_ident_string() == \"cmp\";\n+        if mirrored_exprs(&cx, &a_expr, &a_ident, &b_expr, &b_ident);\n         then {\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n-            Some(LintTrigger { vec_name, unstable, closure_arg: \"e\".to_string(), closure_reverse_body: \"e\".to_string() })\n+            let closure_arg = a_ident.name.to_ident_string();\n+            let closure_reverse_body = Sugg::hir(cx, &a_expr, \"..\").to_string();\n+            Some(LintTrigger { vec_name, unstable, closure_arg, closure_reverse_body })\n         } else {\n             None\n         }\n@@ -60,18 +165,8 @@ fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger>\n \n impl LateLintPass<'_, '_> for SortByKeyReverse {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n-        println!(\"{:?}\", expr);\n-        span_lint_and_sugg(\n-            cx,\n-            SORT_BY_KEY_REVERSE,\n-            expr.span,\n-            \"use Vec::sort_by_key here instead\",\n-            \"try\",\n-            String::from(\"being a better person\"),\n-            Applicability::MachineApplicable,\n-        );\n         if let Some(trigger) = detect_lint(cx, expr) {\n-            span_lint_and_sugg(\n+            utils::span_lint_and_sugg(\n                 cx,\n                 SORT_BY_KEY_REVERSE,\n                 expr.span,"}, {"sha": "4b18a073e1add83f7f1191d321ae35fe22e4b46f", "filename": "tests/ui/sort_by_key_reverse.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.fixed?ref=8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+#![warn(clippy::sort_by_key_reverse)]\n+\n+fn main() {\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n+    vec.sort_by_key(|a| Reverse(a));\n+    vec.sort_by_key(|a| Reverse(&(a+5).abs()));\n+    vec.sort_by_key(|a| Reverse(&-a));\n+}"}, {"sha": "f4fb70b7b1dcbb069bdb89b12e59991c489f643b", "filename": "tests/ui/sort_by_key_reverse.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.rs?ref=8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "patch": "@@ -1,6 +1,9 @@\n+// run-rustfix\n #![warn(clippy::sort_by_key_reverse)]\n \n fn main() {\n-    let mut vec = vec![3, 6, 1, 2, 5];\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     vec.sort_by(|a, b| b.cmp(a));\n+    vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n+    vec.sort_by(|a, b| (-b).cmp(&-a));\n }"}, {"sha": "36a28c04b1c55fb66000ff85563e79a36f46d4a0", "filename": "tests/ui/sort_by_key_reverse.stderr", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6/tests%2Fui%2Fsort_by_key_reverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.stderr?ref=8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "patch": "@@ -0,0 +1,22 @@\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/sort_by_key_reverse.rs:6:5\n+   |\n+LL |     vec.sort_by(|a, b| b.cmp(a));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(a))`\n+   |\n+   = note: `-D clippy::sort-by-key-reverse` implied by `-D warnings`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/sort_by_key_reverse.rs:7:5\n+   |\n+LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(&(a+5).abs()))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/sort_by_key_reverse.rs:8:5\n+   |\n+LL |     vec.sort_by(|a, b| (-b).cmp(&-a));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(&-a))`\n+\n+error: aborting due to 3 previous errors\n+"}]}