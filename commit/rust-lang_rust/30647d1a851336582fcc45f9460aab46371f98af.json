{"sha": "30647d1a851336582fcc45f9460aab46371f98af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNjQ3ZDFhODUxMzM2NTgyZmNjNDVmOTQ2MGFhYjQ2MzcxZjk4YWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T03:45:41Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T03:45:41Z"}, "message": "syntax: put helpers of `parse_self_param` in the method.", "tree": {"sha": "55f6d1c18f5bd0e833bd8223501ce8aec7ec4718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55f6d1c18f5bd0e833bd8223501ce8aec7ec4718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30647d1a851336582fcc45f9460aab46371f98af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30647d1a851336582fcc45f9460aab46371f98af", "html_url": "https://github.com/rust-lang/rust/commit/30647d1a851336582fcc45f9460aab46371f98af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30647d1a851336582fcc45f9460aab46371f98af/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df298b49f2eeb8497805359e360232c4b1030f51", "url": "https://api.github.com/repos/rust-lang/rust/commits/df298b49f2eeb8497805359e360232c4b1030f51", "html_url": "https://github.com/rust-lang/rust/commit/df298b49f2eeb8497805359e360232c4b1030f51"}], "stats": {"total": 115, "additions": 57, "deletions": 58}, "files": [{"sha": "a4420e4a0f394338415c5a7efc60cb5ff040d400", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/30647d1a851336582fcc45f9460aab46371f98af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30647d1a851336582fcc45f9460aab46371f98af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=30647d1a851336582fcc45f9460aab46371f98af", "patch": "@@ -1268,27 +1268,71 @@ impl<'a> Parser<'a> {\n     ///\n     /// See `parse_self_param_with_attrs` to collect attributes.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n+        // Extract an identifier *after* having confirmed that the token is one.\n+        let expect_self_ident = |this: &mut Self| {\n+            match this.token.kind {\n+                // Preserve hygienic context.\n+                token::Ident(name, _) => {\n+                    let span = this.token.span;\n+                    this.bump();\n+                    Ident::new(name, span)\n+                }\n+                _ => unreachable!(),\n+            }\n+        };\n+        // Is `self` `n` tokens ahead?\n+        let is_isolated_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::SelfLower])\n+            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n+        };\n+        // Is `mut self` `n` tokens ahead?\n+        let is_isolated_mut_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::Mut])\n+            && is_isolated_self(this, n + 1)\n+        };\n+        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+        let parse_self_possibly_typed = |this: &mut Self, m| {\n+            let eself_ident = expect_self_ident(this);\n+            let eself_hi = this.prev_span;\n+            let eself = if this.eat(&token::Colon) {\n+                SelfKind::Explicit(this.parse_ty()?, m)\n+            } else {\n+                SelfKind::Value(m)\n+            };\n+            Ok((eself, eself_ident, eself_hi))\n+        };\n+        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+        let recover_self_ptr = |this: &mut Self| {\n+            let msg = \"cannot pass `self` by raw pointer\";\n+            let span = this.token.span;\n+            this.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .emit();\n+\n+            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n+        };\n+\n         // Parse optional `self` parameter of a method.\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.token.span;\n         let (eself, eself_ident, eself_hi) = match self.token.kind {\n             token::BinOp(token::And) => {\n-                let eself = if self.is_isolated_self(1) {\n+                let eself = if is_isolated_self(self, 1) {\n                     // `&self`\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.is_isolated_mut_self(1) {\n+                } else if is_isolated_mut_self(self, 1) {\n                     // `&mut self`\n                     self.bump();\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Mutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && self.is_isolated_self(2) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n                     // `&'lt self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && self.is_isolated_mut_self(2) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n                     // `&'lt mut self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n@@ -1298,30 +1342,30 @@ impl<'a> Parser<'a> {\n                     // `&not_self`\n                     return Ok(None);\n                 };\n-                (eself, self.expect_self_ident(), self.prev_span)\n+                (eself, expect_self_ident(self), self.prev_span)\n             }\n             // `*self`\n-            token::BinOp(token::Star) if self.is_isolated_self(1) => {\n+            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n                 self.bump();\n-                self.recover_self_ptr()?\n+                recover_self_ptr(self)?\n             }\n             // `*mut self` and `*const self`\n             token::BinOp(token::Star) if\n                 self.look_ahead(1, |t| t.is_mutability())\n-                && self.is_isolated_self(2) =>\n+                && is_isolated_self(self, 2) =>\n             {\n                 self.bump();\n                 self.bump();\n-                self.recover_self_ptr()?\n+                recover_self_ptr(self)?\n             }\n             // `self` and `self: TYPE`\n-            token::Ident(..) if self.is_isolated_self(0) => {\n-                self.parse_self_possibly_typed(Mutability::Immutable)?\n+            token::Ident(..) if is_isolated_self(self, 0) => {\n+                parse_self_possibly_typed(self, Mutability::Immutable)?\n             }\n             // `mut self` and `mut self: TYPE`\n-            token::Ident(..) if self.is_isolated_mut_self(0) => {\n+            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n                 self.bump();\n-                self.parse_self_possibly_typed(Mutability::Mutable)?\n+                parse_self_possibly_typed(self, Mutability::Mutable)?\n             }\n             _ => return Ok(None),\n         };\n@@ -1345,51 +1389,6 @@ impl<'a> Parser<'a> {\n         self.look_ahead(offset + 1, |t| t == &token::Colon)\n     }\n \n-    fn is_isolated_self(&self, n: usize) -> bool {\n-        self.is_keyword_ahead(n, &[kw::SelfLower])\n-        && self.look_ahead(n + 1, |t| t != &token::ModSep)\n-    }\n-\n-    fn is_isolated_mut_self(&self, n: usize) -> bool {\n-        self.is_keyword_ahead(n, &[kw::Mut])\n-        && self.is_isolated_self(n + 1)\n-    }\n-\n-    fn expect_self_ident(&mut self) -> Ident {\n-        match self.token.kind {\n-            // Preserve hygienic context.\n-            token::Ident(name, _) => {\n-                let span = self.token.span;\n-                self.bump();\n-                Ident::new(name, span)\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    /// Recover for the grammar `*self`, `*const self`, and `*mut self`.\n-    fn recover_self_ptr(&mut self) -> PResult<'a, (ast::SelfKind, Ident, Span)> {\n-        let msg = \"cannot pass `self` by raw pointer\";\n-        let span = self.token.span;\n-        self.struct_span_err(span, msg)\n-            .span_label(span, msg)\n-            .emit();\n-\n-        Ok((SelfKind::Value(Mutability::Immutable), self.expect_self_ident(), self.prev_span))\n-    }\n-\n-    /// Parse `self` or `self: TYPE`. We already know the current token is `self`.\n-    fn parse_self_possibly_typed(&mut self, m: Mutability) -> PResult<'a, (SelfKind, Ident, Span)> {\n-        let eself_ident = self.expect_self_ident();\n-        let eself_hi = self.prev_span;\n-        let eself = if self.eat(&token::Colon) {\n-            SelfKind::Explicit(self.parse_ty()?, m)\n-        } else {\n-            SelfKind::Value(m)\n-        };\n-        Ok((eself, eself_ident, eself_hi))\n-    }\n-\n     fn is_crate_vis(&self) -> bool {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }"}]}