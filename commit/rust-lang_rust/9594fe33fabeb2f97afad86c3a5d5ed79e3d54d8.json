{"sha": "9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1OTRmZTMzZmFiZWIyZjk3YWZhZDg2YzNhNWQ1ZWQ3OWUzZDU0ZDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-13T09:09:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-13T09:09:46Z"}, "message": "Merge #4083\n\n4083: Smol documentation for ast nodes r=matklad a=Veetaha\n\nThere is a tremendous amount of TODOs to clarify the topics I am not certain about.\r\nPlease @matklad, @edwin0cheng review carefully, I even left some mentions of your names in todos to put your attention where you most probably can give comments.\r\n\r\nIn order to simplify the review, I separated the codegen (i.e. changes in `ast/generated/nodes.rs`) from `ast_src` changes (they in fact just duplicate one another) into two commits.\r\n\r\nAlso, I had to hack a little bit to let the docs be generated as doc comments and not as doc attributes because it's easier to read them this way and IIRC we don't support hints for `#[doc = \"\"]` attributes for now...\r\n\r\nCloses #3682 \n\nCo-authored-by: veetaha <veetaha2@gmail.com>", "tree": {"sha": "85c8c2cb648a8fafc4fe7f098527c9b728821bbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c8c2cb648a8fafc4fe7f098527c9b728821bbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeu7laCRBK7hj4Ov3rIwAAdHIIAGGIYIGkpoYV2myLviCCSM+z\n8C2K4KzoxNJUYAD243+Puh0RRmi6NOfr5jWbtnbgumI/ceBNwl/x0LUDQ/ad2Gt4\noyMccCUP2VU0BLiBPWpTtKBJVB4rbBClisZpwUC/goPr2yrq1kncmQtHnTiRbd9M\n7PFhdiu4JXVtAow9hNqk87SJz8395J1t1iLFJUB7vLJtSkohgKovd+5xou73oWqk\ncbvK6YaXUx0RoPXon+3Shd3m3juAKtOYaw4RKkn++XJC61pclZ4uGzIcAow0uncI\nf6+C1WpE1rH6rdkGDNYvxbDuQUa2njAWDBIiBwES3rUWB2ImnMzNeV0nLLSUlZE=\n=tJ3Z\n-----END PGP SIGNATURE-----\n", "payload": "tree 85c8c2cb648a8fafc4fe7f098527c9b728821bbc\nparent f4aec8a22e401fe8441470cf5c9ab37988486219\nparent b22cf23ad1355af5b039f6da19aa69f57ed47b97\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589360986 +0000\ncommitter GitHub <noreply@github.com> 1589360986 +0000\n\nMerge #4083\n\n4083: Smol documentation for ast nodes r=matklad a=Veetaha\n\nThere is a tremendous amount of TODOs to clarify the topics I am not certain about.\r\nPlease @matklad, @edwin0cheng review carefully, I even left some mentions of your names in todos to put your attention where you most probably can give comments.\r\n\r\nIn order to simplify the review, I separated the codegen (i.e. changes in `ast/generated/nodes.rs`) from `ast_src` changes (they in fact just duplicate one another) into two commits.\r\n\r\nAlso, I had to hack a little bit to let the docs be generated as doc comments and not as doc attributes because it's easier to read them this way and IIRC we don't support hints for `#[doc = \"\"]` attributes for now...\r\n\r\nCloses #3682 \n\nCo-authored-by: veetaha <veetaha2@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "html_url": "https://github.com/rust-lang/rust/commit/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4aec8a22e401fe8441470cf5c9ab37988486219", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4aec8a22e401fe8441470cf5c9ab37988486219", "html_url": "https://github.com/rust-lang/rust/commit/f4aec8a22e401fe8441470cf5c9ab37988486219"}, {"sha": "b22cf23ad1355af5b039f6da19aa69f57ed47b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/b22cf23ad1355af5b039f6da19aa69f57ed47b97", "html_url": "https://github.com/rust-lang/rust/commit/b22cf23ad1355af5b039f6da19aa69f57ed47b97"}], "stats": {"total": 3030, "additions": 2877, "deletions": 153}, "files": [{"sha": "cf6067e57c42497c626e7eacbf31dda4a15381a9", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1366, "deletions": 138, "changes": 1504, "blob_url": "https://github.com/rust-lang/rust/blob/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "patch": "@@ -5,7 +5,9 @@ use crate::{\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n-\n+/// The entire Rust source file. Includes all top-level inner attributes and module items.\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/crates-and-source-files.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n@@ -16,7 +18,28 @@ impl ast::DocCommentsOwner for SourceFile {}\n impl SourceFile {\n     pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }\n }\n-\n+/// Function definition either with body or not.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub extern \"C\" fn foo<T>(#[attr] Patern {p}: Pattern) -> u32\n+///     where\n+///         T: Debug\n+///     {\n+///         42\n+///     }\n+/// \u2771\n+///\n+/// extern \"C\" {\n+///     \u2770 fn fn_decl(also_variadic_ffi: u32, ...) -> u32; \u2771\n+/// }\n+/// ```\n+///\n+/// - [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n+/// - [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -38,7 +61,13 @@ impl FnDef {\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Return type annotation.\n+///\n+/// ```\n+/// fn foo(a: u32) \u2770 -> Option<u32> \u2771 { Some(a) }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n     pub(crate) syntax: SyntaxNode,\n@@ -47,7 +76,26 @@ impl RetType {\n     pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Struct definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     struct Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         pub a: u32,\n+///         b: T,\n+///     }\n+/// \u2771\n+///\n+/// \u2770 struct Foo; \u2771\n+/// \u2770 struct Foo<T>(#[attr] T) where T: Debug; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StructDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -62,7 +110,23 @@ impl StructDef {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Union definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub union Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         a: T,\n+///         b: u32,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/unions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -78,7 +142,19 @@ impl UnionDef {\n         support::child(&self.syntax)\n     }\n }\n-\n+/// Record field definition list including enclosing curly braces.\n+///\n+/// ```\n+/// struct Foo // same for union\n+/// \u2770\n+///     {\n+///         a: u32,\n+///         b: bool,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -88,7 +164,22 @@ impl RecordFieldDefList {\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record field definition including its attributes and doc comments.\n+///\n+/// ` ``\n+/// same for union\n+/// struct Foo {\n+///      \u2770\n+///          /// Docs\n+///          #[attr]\n+///          pub a: u32\n+///      \u2771\n+///\n+///      \u2770 b: bool \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -99,7 +190,13 @@ impl ast::AttrsOwner for RecordFieldDef {}\n impl ast::DocCommentsOwner for RecordFieldDef {}\n impl ast::TypeAscriptionOwner for RecordFieldDef {}\n impl RecordFieldDef {}\n-\n+/// Tuple field definition list including enclosing parens.\n+///\n+/// ```\n+/// struct Foo \u2770 (u32, String, Vec<u32>) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -109,7 +206,13 @@ impl TupleFieldDefList {\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Tuple field definition including its attributes.\n+///\n+/// ```\n+/// struct Foo(\u2770 #[attr] u32 \u2771);\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -119,7 +222,29 @@ impl ast::AttrsOwner for TupleFieldDef {}\n impl TupleFieldDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Enum definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub enum Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         Bar,\n+///         Baz(#[attr] u32),\n+///         Bruh {\n+///             a: u32,\n+///             /// Docs\n+///             #[attr]\n+///             b: T,\n+///         }\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -133,7 +258,22 @@ impl EnumDef {\n     pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n-\n+/// Enum variant definition list including enclosing curly braces.\n+///\n+/// ```\n+/// enum Foo\n+/// \u2770\n+///     {\n+///         Bar,\n+///         Baz(u32),\n+///         Bruh {\n+///             a: u32\n+///         }\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariantList {\n     pub(crate) syntax: SyntaxNode,\n@@ -143,7 +283,21 @@ impl EnumVariantList {\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Enum variant definition including its attributes and discriminant value definition.\n+///\n+/// ```\n+/// enum Foo {\n+///     \u2770\n+///         /// Docs\n+///         #[attr]\n+///         Bar\n+///     \u2771\n+///\n+///     // same for tuple and record variants\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n     pub(crate) syntax: SyntaxNode,\n@@ -157,7 +311,20 @@ impl EnumVariant {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Trait definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub unsafe trait Foo<T>: Debug where T: Debug {\n+///         // ...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/traits.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -174,7 +341,27 @@ impl TraitDef {\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n-\n+/// Module definition either with body or not.\n+/// Includes all of its inner and outer attributes, module items, doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub mod foo;\n+/// \u2771\n+///\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub mod bar {\n+///        //! Inner docs\n+///        #![inner_attr]\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/modules.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) syntax: SyntaxNode,\n@@ -188,7 +375,28 @@ impl Module {\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Item defintion list.\n+/// This is used for both top-level items and impl block items.\n+///\n+/// ```\n+/// \u2770\n+///     fn foo {}\n+///     struct Bar;\n+///     enum Baz;\n+///     trait Bruh;\n+///     const BRUUH: u32 = 42;\n+/// \u2771\n+///\n+/// impl Foo\n+/// \u2770\n+///     {\n+///         fn bar() {}\n+///         const BAZ: u32 = 42;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -199,7 +407,18 @@ impl ItemList {\n     pub fn assoc_items(&self) -> AstChildren<AssocItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Constant variable definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub const FOO: u32 = 42;\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/constant-items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -217,7 +436,18 @@ impl ConstDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Static variable definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub static mut FOO: u32 = 42;\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/static-items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -235,7 +465,24 @@ impl StaticDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Type alias definition.\n+/// Includes associated type clauses with type bounds.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub type Foo<T> where T: Debug = T;\n+/// \u2771\n+///\n+/// trait Bar {\n+///     \u2770 type Baz: Debug; \u2771\n+///     \u2770 type Bruh = String; \u2771\n+///     \u2770 type Bruuh: Debug = u32; \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/type-aliases.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -253,7 +500,20 @@ impl TypeAliasDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Inherent and trait impl definition.\n+/// Includes all of its inner and outer attributes.\n+///\n+/// ```\n+/// \u2770\n+///     #[attr]\n+///     unsafe impl<T> const !Foo for Bar where T: Debug {\n+///         #![inner_attr]\n+///         // ...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/implementations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -270,7 +530,16 @@ impl ImplDef {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n-\n+/// Parenthesized type reference.\n+/// Note: parens are only used for grouping, this is not a tuple type.\n+///\n+/// ```\n+/// // This is effectively just `u32`.\n+/// // Single-item tuple must be defined with a trailing comma: `(u32,)`\n+/// type Foo = \u2770 (u32) \u2771;\n+///\n+/// let bar: &'static \u2770 (dyn Debug) \u2771 = \"bruh\";\n+/// ```\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n@@ -280,7 +549,13 @@ impl ParenType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Unnamed tuple type.\n+///\n+/// ```\n+/// let foo: \u2770 (u32, bool) \u2771 = (42, true);\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/tuple.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n@@ -290,23 +565,50 @@ impl TupleType {\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// The never type (i.e. the exclamation point).\n+///\n+/// ```\n+/// type T = \u2770 ! \u2771;\n+///\n+/// fn no_return() -> \u2770 ! \u2771 {\n+///     loop {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/never.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl NeverType {\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n-\n+/// Path to a type.\n+/// Includes single identifier type names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// type Foo = \u2770 String \u2771;\n+/// type Bar = \u2770 std::vec::Vec<T> \u2771;\n+/// type Baz = \u2770 ::bruh::<Bruuh as Iterator>::Item \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathType {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Raw pointer type.\n+///\n+/// ```\n+/// type Foo = \u2770 *const u32 \u2771;\n+/// type Bar = \u2770 *mut u32 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -317,7 +619,13 @@ impl PointerType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Array type.\n+///\n+/// ```\n+/// type Foo = \u2770 [u32; 24 - 3] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/array.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n@@ -329,7 +637,13 @@ impl ArrayType {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Slice type.\n+///\n+/// ```\n+/// type Foo = \u2770 [u8] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/slice.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -339,7 +653,13 @@ impl SliceType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Reference type.\n+///\n+/// ```\n+/// type Foo = \u2770 &'static str \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/pointer.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -352,15 +672,29 @@ impl ReferenceType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Placeholder type (i.e. the underscore).\n+///\n+/// ```\n+/// let foo: \u2770 _ \u2771 = 42_u32;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/inferred.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PlaceholderType {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n-\n+/// Function pointer type (not to be confused with `Fn*` family of traits).\n+///\n+/// ```\n+/// type Foo = \u2770 async fn(#[attr] u32, named: bool) -> u32 \u2771;\n+///\n+/// type Bar = \u2770 extern \"C\" fn(variadic: u32, #[attr] ...) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/function-pointer.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -372,7 +706,13 @@ impl FnPointerType {\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n-\n+/// Higher order type.\n+///\n+/// ```\n+/// type Foo = \u2770 for<'a> fn(&'a str) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/nomicon/hrtb.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n@@ -382,7 +722,13 @@ impl ForType {\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Opaque `impl Trait` type.\n+///\n+/// ```\n+/// fn foo(bar: \u2770 impl Debug + Eq \u2771) {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/impl-trait.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -391,7 +737,13 @@ impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n }\n-\n+/// Trait object type.\n+///\n+/// ```\n+/// type Foo = \u2770 dyn Debug \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/trait-object.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -400,7 +752,13 @@ impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n     pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n }\n-\n+/// Tuple literal.\n+///\n+/// ```\n+/// \u2770 (42, true) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/tuple-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -411,7 +769,15 @@ impl TupleExpr {\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Array literal.\n+///\n+/// ```\n+/// \u2770 [#![inner_attr] true, false, true] \u2771;\n+///\n+/// \u2770 [\"baz\"; 24] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -423,7 +789,14 @@ impl ArrayExpr {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Parenthesized expression.\n+/// Note: parens are only used for grouping, this is not a tuple literal.\n+///\n+/// ```\n+/// \u2770 (#![inner_attr] 2 + 2) \u2771 * 2;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -434,15 +807,37 @@ impl ParenExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Path to a symbol in expression context.\n+/// Includes single identifier variable names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// \u2770 Some::<i32> \u2771;\n+/// \u2770 foo \u2771 + 42;\n+/// \u2770 Vec::<i32>::push \u2771;\n+/// \u2770 <[i32]>::reverse \u2771;\n+/// \u2770 <String as std::borrow::Borrow<str>>::borrow \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/path-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Anonymous callable object literal a.k.a. closure, lambda or functor.\n+///\n+/// ```\n+/// \u2770 || 42 \u2771;\n+/// \u2770 |a: u32| val + 1 \u2771;\n+/// \u2770 async |#[attr] Pattern(_): Pattern| { bar } \u2771;\n+/// \u2770 move || baz \u2771;\n+/// \u2770 || -> u32 { closure_with_ret_type_annotation_requires_block_expr } \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/closure-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LambdaExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -456,7 +851,25 @@ impl LambdaExpr {\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// If expression. Includes both regular `if` and `if let` forms.\n+/// Beware that `else if` is a special case syntax sugar, because in general\n+/// there has to be block expression after `else`.\n+///\n+/// ```\n+/// \u2770 if bool_cond { 42 } \u2771\n+/// \u2770 if bool_cond { 42 } else { 24 } \u2771\n+/// \u2770 if bool_cond { 42 } else if bool_cond2 { 42 } \u2771\n+///\n+/// \u2770\n+///     if let Pattern(foo) = bar {\n+///         foo\n+///     } else {\n+///         panic!();\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -466,7 +879,17 @@ impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n-\n+/// Unconditional loop expression.\n+///\n+/// ```\n+/// \u2770\n+///     loop {\n+///         // yeah, it's that simple...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -476,7 +899,20 @@ impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n     pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n-\n+/// Block expression with an optional prefix (label, try ketword,\n+/// unsafe keyword, async keyword...).\n+///\n+/// ```\n+/// \u2770\n+///     'label: try {\n+///         None?\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// - [try block](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)\n+/// - [unsafe block](https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks)\n+/// - [async block](https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EffectExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -489,7 +925,19 @@ impl EffectExpr {\n     pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n-\n+/// For loop expression.\n+/// Note: record struct literals are not valid as iterable expression\n+/// due to ambiguity.\n+///\n+/// ```\n+/// \u2770\n+/// for i in (0..4) {\n+///     dbg!(i);\n+/// }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -502,7 +950,22 @@ impl ForExpr {\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// While loop expression. Includes both regular `while` and `while let` forms.\n+///\n+/// ```\n+/// \u2770\n+///     while bool_cond {\n+///         42;\n+///     }\n+/// \u2771\n+/// \u2770\n+///     while let Pattern(foo) = bar {\n+///         bar += 1;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -513,7 +976,22 @@ impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n-\n+/// Continue expression.\n+///\n+/// ```\n+/// while bool_cond {\n+///     \u2770 continue \u2771;\n+/// }\n+///\n+/// 'outer: loop {\n+///     loop {\n+///         \u2770 continue 'outer \u2771;\n+///     }\n+/// }\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -527,7 +1005,25 @@ impl ContinueExpr {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Break expression.\n+///\n+/// ```\n+/// while bool_cond {\n+///     \u2770 break \u2771;\n+/// }\n+/// 'outer: loop {\n+///     for foo in bar {\n+///         \u2770 break 'outer \u2771;\n+///     }\n+/// }\n+/// 'outer: loop {\n+///     loop {\n+///         \u2770 break 'outer 42 \u2771;\n+///     }\n+/// }\n+/// ```\n+///\n+/// [Refernce](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -540,7 +1036,20 @@ impl BreakExpr {\n     }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Label.\n+///\n+/// ```\n+/// \u2770 'outer: \u2771 loop {}\n+///\n+/// let foo = \u2770 'bar: \u2771 loop {}\n+///\n+/// \u2770 'baz: \u2771 {\n+///     break 'baz;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html?highlight=label#loop-labels)\n+/// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n@@ -550,7 +1059,21 @@ impl Label {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Block expression. Includes unsafe blocks and block labels.\n+///\n+/// ```\n+///     let foo = \u2770\n+///         {\n+///             #![inner_attr]\n+///             \u2770 { } \u2771\n+///\n+///             \u2770 'label: { break 'label } \u2771\n+///         }\n+///     \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n+/// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -563,7 +1086,17 @@ impl BlockExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Return expression.\n+///\n+/// ```\n+/// || \u2770 return 42 \u2771;\n+///\n+/// fn bar() {\n+///     \u2770 return \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/return-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -572,7 +1105,16 @@ impl ast::AttrsOwner for ReturnExpr {}\n impl ReturnExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Call expression (not to be confused with method call expression, it is\n+/// a separate ast node).\n+///\n+/// ```\n+/// \u2770 foo() \u2771;\n+/// \u2770 &str::len(\"bar\") \u2771;\n+/// \u2770 <&str as PartialEq<&str>>::eq(&\"\", &\"\") \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -581,7 +1123,16 @@ impl ast::ArgListOwner for CallExpr {}\n impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Method call expression.\n+///\n+/// ```\n+/// \u2770 receiver_expr.method() \u2771;\n+/// \u2770 receiver_expr.method::<T>(42, true) \u2771;\n+///\n+/// \u2770 \u2770 \u2770 foo.bar() \u2771 .baz() \u2771 .bruh() \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MethodCallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -594,7 +1145,13 @@ impl MethodCallExpr {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n-\n+/// Index expression a.k.a. subscript operator call.\n+///\n+/// ```\n+/// \u2770 foo[42] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -604,7 +1161,15 @@ impl IndexExpr {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Field access expression.\n+///\n+/// ```\n+/// \u2770 expr.bar \u2771;\n+///\n+/// \u2770 \u2770 \u2770 foo.bar \u2771 .baz \u2771 .bruh \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/field-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -615,7 +1180,13 @@ impl FieldExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n-\n+/// Await operator call expression.\n+///\n+/// ```\n+/// \u2770 expr.await \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/await-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -626,7 +1197,13 @@ impl AwaitExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n-\n+/// The question mark operator call.\n+///\n+/// ```\n+/// \u2770 expr? \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -636,7 +1213,13 @@ impl TryExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n-\n+/// Type cast expression.\n+///\n+/// ```\n+/// \u2770 expr as T \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -647,7 +1230,14 @@ impl CastExpr {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Borrow operator call.\n+///\n+/// ```\n+/// \u2770 &foo \u2771;\n+/// \u2770 &mut bar \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -659,7 +1249,15 @@ impl RefExpr {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Prefix operator call. This is either `!` or `*` or `-`.\n+///\n+/// ```\n+/// \u2770 !foo \u2771;\n+/// \u2770 *bar \u2771;\n+/// \u2770 -42 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -668,7 +1266,13 @@ impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Box operator call.\n+///\n+/// ```\n+/// \u2770 box 42 \u2771;\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0809-box-and-in-for-stdlib.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -678,27 +1282,69 @@ impl BoxExpr {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Range operator call.\n+///\n+/// ```\n+/// \u2770 0..42 \u2771;\n+/// \u2770 ..42 \u2771;\n+/// \u2770 0.. \u2771;\n+/// \u2770 .. \u2771;\n+/// \u2770 0..=42 \u2771;\n+/// \u2770 ..=42 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/range-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::AttrsOwner for RangeExpr {}\n impl RangeExpr {}\n-\n+/// Binary operator call.\n+/// Includes all arithmetic, logic, bitwise and assignment operators.\n+///\n+/// ```\n+/// \u2770 2 + \u2770 2 * 2 \u2771 \u2771;\n+/// \u2770 \u2770 true && false \u2771 || true \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::AttrsOwner for BinExpr {}\n impl BinExpr {}\n-\n+/// [Raw] string, [raw] byte string, char, byte, integer, float or bool literal.\n+///\n+/// ```\n+/// \u2770 \"str\" \u2771;\n+/// \u2770 br##\"raw byte str\"## \u2771;\n+/// \u2770 'c' \u2771;\n+/// \u2770 b'c' \u2771;\n+/// \u2770 42 \u2771;\n+/// \u2770 1e9 \u2771;\n+/// \u2770 true \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/literal-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Literal {}\n-\n+/// Match expression.\n+///\n+/// ```\n+/// \u2770\n+///     match expr {\n+///         Pat1 => {}\n+///         Pat2(_) => 42,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -709,7 +1355,20 @@ impl MatchExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n-\n+/// Match arm list part of match expression. Includes its inner attributes.\n+///\n+/// ```\n+/// match expr\n+/// \u2770\n+///     {\n+///         #![inner_attr]\n+///         Pat1 => {}\n+///         Pat2(_) => 42,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n@@ -720,7 +1379,16 @@ impl MatchArmList {\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Match arm.\n+/// Note: record struct literals are not valid as target match expression\n+/// due to ambiguity.\n+/// ```\n+/// match expr {\n+///     \u2770 #[attr] Pattern(it) if bool_cond => it \u2771,\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n@@ -732,7 +1400,15 @@ impl MatchArm {\n     pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Match guard.\n+///\n+/// ```\n+/// match expr {\n+///     Pattern(it) \u2770 if bool_cond \u2771 => it,\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n@@ -741,7 +1417,21 @@ impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Record literal expression. The same syntax is used for structs,\n+/// unions and record enum variants.\n+///\n+/// ```\n+/// \u2770\n+///     foo::Bar {\n+///         #![inner_attr]\n+///         baz: 42,\n+///         bruh: true,\n+///         ..spread\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordLit {\n     pub(crate) syntax: SyntaxNode,\n@@ -750,7 +1440,16 @@ impl RecordLit {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn record_field_list(&self) -> Option<RecordFieldList> { support::child(&self.syntax) }\n }\n-\n+/// Record field list including enclosing curly braces.\n+///\n+/// foo::Bar \u2770\n+///     {\n+///         baz: 42,\n+///         ..spread\n+///     }\n+/// \u2771\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -762,7 +1461,15 @@ impl RecordFieldList {\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record field.\n+///\n+/// ```\n+/// foo::Bar {\n+///     \u2770 #[attr] baz: 42 \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n     pub(crate) syntax: SyntaxNode,\n@@ -773,15 +1480,28 @@ impl RecordField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Disjunction of patterns.\n+///\n+/// ```\n+/// let \u2770 Foo(it) | Bar(it) | Baz(it) \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl OrPat {\n     pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n }\n-\n+/// Parenthesized pattern.\n+/// Note: parens are only used for grouping, this is not a tuple pattern.\n+///\n+/// ```\n+/// if let \u2770 &(0..=42) \u2771 = foo {}\n+/// ```\n+///\n+/// https://doc.rust-lang.org/reference/patterns.html#grouped-patterns\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -791,7 +1511,16 @@ impl ParenPat {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Reference pattern.\n+/// Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns.\n+///\n+/// ```\n+/// let \u2770 &mut foo \u2771 = bar;\n+///\n+/// let \u2770 & \u2770 &mut \u2770 &_ \u2771 \u2771 \u2771 = baz;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#reference-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -801,7 +1530,13 @@ impl RefPat {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Box pattern.\n+///\n+/// ```\n+/// let \u2770 box foo \u2771 = box 42;\n+/// ```\n+///\n+/// [Unstable book](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -810,7 +1545,16 @@ impl BoxPat {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Bind pattern.\n+///\n+/// ```\n+/// match foo {\n+///     Some(\u2770 ref mut bar \u2771) => {}\n+///     \u2770 baz @ None \u2771 => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#identifier-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BindPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -823,31 +1567,60 @@ impl BindPat {\n     pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Placeholder pattern a.k.a. the wildcard pattern or the underscore.\n+///\n+/// ```\n+/// let \u2770 _ \u2771 = foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PlaceholderPat {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n-\n+/// Rest-of-the record/tuple pattern.\n+/// Note: this is not the unbonded range pattern (even more: it doesn't exist).\n+///\n+/// ```\n+/// let Foo { bar, \u2770 .. \u2771 } = baz;\n+/// let (\u2770 .. \u2771, bruh) = (42, 24, 42);\n+/// let Bruuh(\u2770 .. \u2771) = bruuuh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl DotDotPat {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n-\n+/// Path pattern.\n+/// Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`).\n+///\n+/// ```\n+/// let \u2770 foo::bar::Baz \u2771 { .. } = bruh;\n+/// if let \u2770 CONST \u2771 = 42 {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#path-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Slice pattern.\n+///\n+/// ```\n+/// let \u2770 [foo, bar, baz] \u2771 = [1, 2, 3];\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#slice-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SlicePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -857,29 +1630,61 @@ impl SlicePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Range pattern.\n+///\n+/// ```\n+/// match foo {\n+///     \u2770 0..42 \u2771 => {}\n+///     \u2770 0..=42 \u2771 => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#range-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl RangePat {}\n-\n+/// Literal pattern.\n+/// Includes only bool, number, char, and string literals.\n+///\n+/// ```\n+/// match foo {\n+///     Number(\u2770 42 \u2771) => {}\n+///     String(\u2770 \"42\" \u2771) => {}\n+///     Bool(\u2770 true \u2771) => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#literal-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LiteralPat {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n-\n+/// Macro invocation in pattern position.\n+///\n+/// ```\n+/// let \u2770 foo!(my custom syntax) \u2771 = baz;\n+///\n+/// ```\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html#macro-invocation)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl MacroPat {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n-\n+/// Record literal pattern.\n+///\n+/// ```\n+/// let \u2770 foo::Bar { baz, .. } \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -890,7 +1695,13 @@ impl RecordPat {\n     }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Record literal's field patterns list including enclosing curly braces.\n+///\n+/// ```\n+/// let foo::Bar \u2770 { baz, bind @ bruh, .. } \u2771 = bruuh;\n+/// ``\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPatList {\n     pub(crate) syntax: SyntaxNode,\n@@ -905,7 +1716,15 @@ impl RecordFieldPatList {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record literal's field pattern.\n+/// Note: record literal can also match tuple structs.\n+///\n+/// ```\n+/// let Foo { \u2770 bar: _ \u2771 } = baz;\n+/// let TupleStruct { \u2770 0: _ \u2771 } = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -916,7 +1735,13 @@ impl RecordFieldPat {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Tuple struct literal pattern.\n+///\n+/// ```\n+/// let \u2770 foo::Bar(baz, bruh) \u2771 = bruuh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleStructPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -927,7 +1752,14 @@ impl TupleStructPat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Tuple pattern.\n+/// Note: this doesn't include tuple structs (see `TupleStructPat`)\n+///\n+/// ```\n+/// let \u2770 (foo, bar, .., baz) \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -937,7 +1769,17 @@ impl TuplePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Visibility.\n+///\n+/// ```\n+/// \u2770 pub mod \u2771 foo;\n+/// \u2770 pub(crate) \u2771 struct Bar;\n+/// \u2770 pub(self) \u2771 enum Baz {}\n+/// \u2770 pub(super) \u2771 fn bruh() {}\n+/// \u2770 pub(in bruuh::bruuuh) \u2771 type T = u64;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n     pub(crate) syntax: SyntaxNode,\n@@ -948,21 +1790,71 @@ impl Visibility {\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n     pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n }\n-\n+/// Single identifier.\n+/// Note(@matklad): `Name` is for things that install a new name into the scope,\n+/// `NameRef` is a usage of a name. Most of the time, this definition/reference\n+/// distinction can be determined purely syntactically, ie in\n+/// ```\n+/// fn foo() { foo() }\n+/// ```\n+/// the first foo is `Name`, the second one is `NameRef`.\n+/// The notable exception are patterns, where in\n+/// ``\n+/// let x = 92\n+/// ```\n+/// `x` can be semantically either a name or a name ref, depeding on\n+/// wether there's an `x` constant in scope.\n+/// We use `Name` for patterns, and disambiguate semantically (see `NameClass` in ide_db).\n+///\n+/// ```\n+/// let \u2770 foo \u2771 = bar;\n+/// struct \u2770 Baz \u2771;\n+/// fn \u2770 bruh \u2771() {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Name {\n     pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n }\n-\n+/// Reference to a name.\n+/// See the explanation on the difference between `Name` and `NameRef`\n+/// in `Name` ast node docs.\n+///\n+/// ```\n+/// let foo = \u2770 bar \u2771(\u2770 Baz(\u2770 bruh \u2771) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n     pub(crate) syntax: SyntaxNode,\n }\n impl NameRef {}\n-\n+/// Macro call.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     macro_rules! foo {   // macro rules is also a macro call\n+///         ($bar: tt) => {}\n+///     }\n+/// \u2771\n+///\n+/// // semicolon is a part of `MacroCall` when it is used in item positions\n+/// \u2770 foo!(); \u2771\n+///\n+/// fn main() {\n+///     \u2770 foo!() \u2771; // macro call in expression positions doesn't include the semi\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n@@ -976,7 +1868,18 @@ impl MacroCall {\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Attribute.\n+///\n+/// ```\n+/// \u2770 #![inner_attr] \u2771\n+///\n+/// \u2770 #[attr] \u2771\n+/// \u2770 #[foo = \"bar\"] \u2771\n+/// \u2770 #[baz(bruh::bruuh = \"42\")] \u2771\n+/// struct Foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/attributes.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n     pub(crate) syntax: SyntaxNode,\n@@ -990,13 +1893,32 @@ impl Attr {\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Stores a list of lexer tokens and other `TokenTree`s.\n+/// It appears in attributes, macro_rules and macro call (foo!)\n+///\n+/// ```\n+/// macro_call! \u2770 { my syntax here } \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TokenTree {}\n-\n+/// Generic lifetime, type and constants parameters list **declaration**.\n+///\n+/// ```\n+/// fn foo\u2770 <'a, 'b, T, U, const BAR: u64> \u2771() {}\n+///\n+/// struct Baz\u2770 <T> \u2771(T);\n+///\n+/// impl\u2770 <T> \u2771 Bruh<T> {}\n+///\n+/// type Bruuh = for\u2770 <'a> \u2771 fn(&'a str) -> &'a str;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1009,7 +1931,13 @@ impl TypeParamList {\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// Single type parameter **declaration**.\n+///\n+/// ```\n+/// fn foo<\u2770 K \u2771, \u2770 I \u2771, \u2770 E: Debug \u2771, \u2770 V = DefaultType \u2771>() {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1021,7 +1949,12 @@ impl TypeParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Const generic parameter **declaration**.\n+/// ```\n+/// fn foo<T, U, \u2770 const BAR: usize \u2771, \u2770 const BAZ: bool \u2771>() {}\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1033,7 +1966,13 @@ impl ConstParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Lifetime parameter **declaration**.\n+///\n+/// ```\n+/// fn foo<\u2770 'a \u2771, \u2770 'b \u2771, V, G, D>(bar: &'a str, baz: &'b mut str) {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1044,7 +1983,20 @@ impl LifetimeParam {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Type bound declaration clause.\n+///\n+/// ```\n+/// fn foo<T: \u2770 ?Sized \u2771 + \u2770 Debug \u2771>() {}\n+///\n+/// trait Bar<T>\n+/// where\n+///     T: \u2770 Send \u2771 + \u2770 Sync \u2771\n+/// {\n+///     type Baz: \u2770 !Sync \u2771 + \u2770 Debug \u2771 + \u2770 ?const Add \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n@@ -1056,15 +2008,40 @@ impl TypeBound {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Type bounds list.\n+///\n+/// ```\n+///\n+/// fn foo<T: \u2770 ?Sized + Debug \u2771>() {}\n+///\n+/// trait Bar<T>\n+/// where\n+///     T: \u2770 Send + Sync \u2771\n+/// {\n+///     type Baz: \u2770 !Sync + Debug \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n-\n+/// Single where predicate.\n+///\n+/// ```\n+/// trait Foo<'a, 'b, T>\n+/// where\n+///     \u2770 'a: 'b \u2771,\n+///     \u2770 T: IntoIterator \u2771,\n+///     \u2770 for<'c> <T as IntoIterator>::Item: Bar<'c> \u2771\n+/// {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n@@ -1076,7 +2053,14 @@ impl WherePred {\n     }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Where clause.\n+///\n+/// ```\n+/// trait Foo<'a, T> \u2770 where 'a: 'static, T: Debug \u2771 {}\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -1085,13 +2069,42 @@ impl WhereClause {\n     pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n-\n+/// Abi declaration.\n+/// Note: the abi string is optional.\n+///\n+/// ```\n+/// \u2770 extern \"C\" \u2771 {\n+///     fn foo() {}\n+/// }\n+///\n+/// type Bar = \u2770 extern \u2771 fn() -> u32;\n+///\n+/// type Baz = \u2770 extern r#\"stdcall\"# \u2771 fn() -> bool;\n+/// ```\n+///\n+/// - [Extern blocks reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n+/// - [FFI function pointers reference](https://doc.rust-lang.org/reference/items/functions.html#functions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Abi {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Abi {}\n-\n+/// Expression statement.\n+///\n+/// ```\n+/// \u2770 42; \u2771\n+/// \u2770 foo(); \u2771\n+/// \u2770 (); \u2771\n+/// \u2770 {}; \u2771\n+///\n+/// // constructions with trailing curly brace can omit the semicolon\n+/// // but only when there are satements immediately after them (this is important!)\n+/// \u2770 if bool_cond { } \u2771\n+/// \u2770 loop {} \u2771\n+/// \u2770 somestatment; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/statements.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -1101,7 +2114,16 @@ impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Let statement.\n+///\n+/// ```\n+/// \u2770 #[attr] let foo; \u2771\n+/// \u2770 let bar: u64; \u2771\n+/// \u2770 let baz = 42; \u2771\n+/// \u2770 let bruh: bool = true; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/statements.html#let-statements)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -1115,7 +2137,18 @@ impl LetStmt {\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Condition of `if` or `while` expression.\n+///\n+/// ```\n+/// if \u2770 true \u2771 {}\n+/// if \u2770 let Pat(foo) = bar \u2771 {}\n+///\n+/// while \u2770 true \u2771 {}\n+/// while \u2770 let Pat(baz) = bruh \u2771 {}\n+/// ```\n+///\n+/// [If expression reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n+/// [While expression reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n@@ -1126,7 +2159,18 @@ impl Condition {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Parameter list **declaration**.\n+///\n+/// ```\n+/// fn foo\u2770 (a: u32, b: bool) \u2771 -> u32 {}\n+/// let bar = \u2770 |a, b| \u2771 {};\n+///\n+/// impl Baz {\n+///     fn bruh\u2770 (&self, a: u32) \u2771 {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)ocs to codegen script\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1137,7 +2181,19 @@ impl ParamList {\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Self parameter **declaration**.\n+///\n+/// ```\n+/// impl Bruh {\n+///     fn foo(\u2770 self \u2771) {}\n+///     fn bar(\u2770 &self \u2771) {}\n+///     fn baz(\u2770 &mut self \u2771) {}\n+///     fn blah<'a>(\u2770 &'a self \u2771) {}\n+///     fn blin(\u2770 self: Box<Self> \u2771) {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1152,7 +2208,17 @@ impl SelfParam {\n     }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n }\n-\n+/// Parameter **declaration**.\n+///\n+/// ```\n+/// fn foo(\u2770 #[attr] Pat(bar): Pat(u32) \u2771, \u2770 #[attr] _: bool \u2771) {}\n+///\n+/// extern \"C\" {\n+///     fn bar(\u2770 baz: u32 \u2771, \u2770 ... \u2771) -> u32;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n     pub(crate) syntax: SyntaxNode,\n@@ -1163,7 +2229,16 @@ impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n-\n+/// Use declaration.\n+///\n+/// ```\n+/// \u2770 #[attr] pub use foo; \u2771\n+/// \u2770 use bar as baz; \u2771\n+/// \u2770 use bruh::{self, bruuh}; \u2771\n+/// \u2770 use { blin::blen, blah::* };\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1174,7 +2249,16 @@ impl UseItem {\n     pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n-\n+/// Use tree.\n+///\n+/// ```\n+/// pub use \u2770 foo::\u2770 * \u2771 \u2771;\n+/// use \u2770 bar as baz \u2771;\n+/// use \u2770 bruh::bruuh::{ \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+/// use \u2770 { \u2770 blin::blen \u2771 } \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -1185,7 +2269,16 @@ impl UseTree {\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n-\n+/// Item alias.\n+/// Note: this is not the type alias.\n+///\n+/// ```\n+/// use foo \u2770 as bar \u2771;\n+/// use baz::{bruh \u2770 as _ \u2771};\n+/// extern crate bruuh \u2770 as blin \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Alias {\n     pub(crate) syntax: SyntaxNode,\n@@ -1194,7 +2287,14 @@ impl ast::NameOwner for Alias {}\n impl Alias {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n }\n-\n+/// Sublist of use trees.\n+///\n+/// ```\n+/// use bruh::bruuh::\u2770 { \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+/// use \u2770 { blin::blen::\u2770 {} \u2771 } \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1204,7 +2304,14 @@ impl UseTreeList {\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Extern crate item.\n+///\n+/// ```\n+/// \u2770 #[attr] pub extern crate foo; \u2771\n+/// \u2770 extern crate self as bar; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/extern-crates.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1217,7 +2324,13 @@ impl ExternCrateItem {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n-\n+/// Call site arguments list.\n+///\n+/// ```\n+/// foo::<T, U>\u2770 (42, true) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1227,16 +2340,41 @@ impl ArgList {\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Path to a symbol. Includes single identifier names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// (0..10).\u2770 \u2770 collect \u2771 ::<Vec<_>> \u2771();\n+/// \u2770 \u2770 \u2770 Vec \u2771 ::<u8> \u2771 ::with_capacity \u2771(1024);\n+/// \u2770 \u2770 <\u2770 Foo \u2771 as \u2770 \u2770 bar \u2771 ::Bar \u2771> \u2771 ::baz \u2771();\n+/// \u2770 \u2770 <\u2770 bruh \u2771> \u2771 ::bruuh \u2771();\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Path {\n     pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n     pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Segment of the path to a symbol.\n+/// Only path segment of an absolute path holds the `::` token,\n+/// all other `::` tokens that connect path segments reside under `Path` itself.`\n+///\n+/// ```\n+/// (0..10).\u2770 collect \u2771 :: \u2770 <Vec<_>> \u2771();\n+/// \u2770 Vec \u2771 :: \u2770 <u8> \u2771 :: \u2770 with_capacity \u2771(1024);\n+/// \u2770 <\u2770 Foo \u2771 as \u2770 bar \u2771 :: \u2770 Bar \u2771> \u2771 :: \u2770 baz \u2771();\n+/// \u2770 <\u2770 bruh \u2771> \u2771 :: \u2770 bruuh \u2771();\n+///\n+/// // Note that only in this case `::` token is inlcuded:\n+/// \u2770 ::foo \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n@@ -1254,7 +2392,15 @@ impl PathSegment {\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// List of type arguments that are passed at generic instantiation site.\n+///\n+/// ```\n+/// type _ = Foo \u2770 ::<'a, u64, Item = Bar, 42, {true}> \u2771::Bar;\n+///\n+/// Vec\u2770 ::<bool> \u2771::();\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1269,15 +2415,27 @@ impl TypeArgList {\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// Type argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// type _ = Foo::<'a, \u2770 u64 \u2771, \u2770 bool \u2771, Item = Bar, 42>::Baz;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeArg {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Associated type argument that is passed at generic instantiation site.\n+/// ```\n+/// type Foo = Bar::<'a, u64, bool, \u2770 Item = Baz \u2771, 42>::Bruh;\n+///\n+/// trait Bruh<T>: Iterator<\u2770 Item: Debug \u2771> {}\n+/// ```\n+///\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocTypeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -1288,7 +2446,15 @@ impl AssocTypeArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Lifetime argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// fn foo<'a>(s: &'a str) {\n+///     bar::<\u2770 'a \u2771>(s);\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -1298,24 +2464,41 @@ impl LifetimeArg {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Constant value argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// foo::<u32, \u2770 { true } \u2771>();\n+///\n+/// bar::<\u2770 { 2 + 2} \u2771>();\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ConstArg {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n-\n+/// FIXME: (@edwin0cheng) Remove it to use ItemList instead\n+/// https://github.com/rust-analyzer/rust-analyzer/pull/4083#discussion_r422666243\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroItems {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::ModuleItemOwner for MacroItems {}\n impl MacroItems {}\n-\n+/// FIXME: (@edwin0cheng) add some documentation here. As per the writing\n+/// of this comment this ast node is not used.\n+///\n+/// ```\n+/// // FIXME: example here\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroStmts {\n     pub(crate) syntax: SyntaxNode,\n@@ -1324,7 +2507,18 @@ impl MacroStmts {\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// List of items in an extern block.\n+///\n+/// ```\n+/// extern \"C\" \u2770\n+///     {\n+///         fn foo();\n+///         static var: u32;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1335,7 +2529,18 @@ impl ExternItemList {\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Extern block.\n+///\n+/// ```\n+/// \u2770\n+///     extern \"C\" {\n+///         fn foo();\n+///     }\n+/// \u2771\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n     pub(crate) syntax: SyntaxNode,\n@@ -1344,7 +2549,15 @@ impl ExternBlock {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n     pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n }\n-\n+/// Meta item in an attribute.\n+///\n+/// ```\n+/// #[\u2770 bar::baz = \"42\" \u2771]\n+/// #[\u2770 bruh(bruuh(\"true\")) \u2771]\n+/// struct Foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/attributes.html?highlight=meta,item#meta-item-attribute-syntax)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MetaItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1355,7 +2568,15 @@ impl MetaItem {\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }\n-\n+/// Macro 2.0 definition.\n+/// Their syntax is still WIP by rustc team...\n+/// ```\n+/// \u2770\n+///     macro foo { }\n+/// \u2771\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -1364,7 +2585,7 @@ impl MacroDef {\n     pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n-\n+/// Any kind of nominal type definition.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum NominalDef {\n     StructDef(StructDef),\n@@ -1374,22 +2595,22 @@ pub enum NominalDef {\n impl ast::NameOwner for NominalDef {}\n impl ast::TypeParamsOwner for NominalDef {}\n impl ast::AttrsOwner for NominalDef {}\n-\n+/// Any kind of **declared** generic parameter\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n     LifetimeParam(LifetimeParam),\n     TypeParam(TypeParam),\n     ConstParam(ConstParam),\n }\n-\n+/// Any kind of generic argument passed at instantiation site\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n     LifetimeArg(LifetimeArg),\n     TypeArg(TypeArg),\n     ConstArg(ConstArg),\n     AssocTypeArg(AssocTypeArg),\n }\n-\n+/// Any kind of construct valid in type context\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeRef {\n     ParenType(ParenType),\n@@ -1406,7 +2627,7 @@ pub enum TypeRef {\n     ImplTraitType(ImplTraitType),\n     DynTraitType(DynTraitType),\n }\n-\n+/// Any kind of top-level item that may appear in a module\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ModuleItem {\n     StructDef(StructDef),\n@@ -1427,7 +2648,9 @@ pub enum ModuleItem {\n impl ast::NameOwner for ModuleItem {}\n impl ast::AttrsOwner for ModuleItem {}\n impl ast::VisibilityOwner for ModuleItem {}\n-\n+/// Any kind of item that may appear in an impl block\n+///\n+/// // FIXME: impl blocks can also contain MacroCall\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     FnDef(FnDef),\n@@ -1436,7 +2659,9 @@ pub enum AssocItem {\n }\n impl ast::NameOwner for AssocItem {}\n impl ast::AttrsOwner for AssocItem {}\n-\n+/// Any kind of item that may appear in an extern block\n+///\n+/// // FIXME: extern blocks can also contain MacroCall\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ExternItem {\n     FnDef(FnDef),\n@@ -1445,7 +2670,7 @@ pub enum ExternItem {\n impl ast::NameOwner for ExternItem {}\n impl ast::AttrsOwner for ExternItem {}\n impl ast::VisibilityOwner for ExternItem {}\n-\n+/// Any kind of expression\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n     TupleExpr(TupleExpr),\n@@ -1481,7 +2706,7 @@ pub enum Expr {\n     BoxExpr(BoxExpr),\n }\n impl ast::AttrsOwner for Expr {}\n-\n+/// Any kind of pattern\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n     OrPat(OrPat),\n@@ -1500,25 +2725,28 @@ pub enum Pat {\n     LiteralPat(LiteralPat),\n     MacroPat(MacroPat),\n }\n-\n+/// Any kind of pattern that appears directly inside of the curly\n+/// braces of a record pattern\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum RecordInnerPat {\n     RecordFieldPat(RecordFieldPat),\n     BindPat(BindPat),\n }\n-\n+/// Any kind of input to an attribute\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AttrInput {\n     Literal(Literal),\n     TokenTree(TokenTree),\n }\n-\n+/// Any kind of statement\n+/// Note: there are no empty statements, these are just represented as\n+/// bare semicolons without a dedicated statement ast node.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n     LetStmt(LetStmt),\n     ExprStmt(ExprStmt),\n }\n-\n+/// Any kind of fields list (record or tuple field lists)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldDefList {\n     RecordFieldDefList(RecordFieldDefList),"}, {"sha": "a5446c32724a73ffddd4b08a2b5832381b0788e1", "filename": "editors/code/src/commands/syntax_tree.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "raw_url": "https://github.com/rust-lang/rust/raw/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts?ref=9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "patch": "@@ -206,7 +206,7 @@ class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, D\n     }\n \n     private parseRustTextRange(doc: vscode.TextDocument, astLine: string): undefined | vscode.Range {\n-        const parsedRange = /\\[(\\d+); (\\d+)\\)/.exec(astLine);\n+        const parsedRange = /(\\d+)\\.\\.(\\d+)/.exec(astLine);\n         if (!parsedRange) return;\n \n         const [begin, end] = parsedRange"}, {"sha": "394a7bc889b951e299a3703555224d9789b881e1", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1487, "deletions": 12, "changes": 1499, "blob_url": "https://github.com/rust-lang/rust/blob/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "patch": "@@ -230,6 +230,7 @@ pub(crate) struct AstSrc<'a> {\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n+    pub(crate) doc: &'a [&'a str],\n     pub(crate) name: &'a str,\n     pub(crate) traits: &'a [&'a str],\n     pub(crate) fields: &'a [Field<'a>],\n@@ -247,19 +248,22 @@ pub(crate) enum FieldSrc<'a> {\n }\n \n pub(crate) struct AstEnumSrc<'a> {\n+    pub(crate) doc: &'a [&'a str],\n     pub(crate) name: &'a str,\n     pub(crate) traits: &'a [&'a str],\n     pub(crate) variants: &'a [&'a str],\n }\n \n macro_rules! ast_nodes {\n     ($(\n+        $(#[doc = $doc:expr])+\n         struct $name:ident$(: $($trait:ident),*)? {\n             $($field_name:ident $(![$token:tt])? $(: $ty:tt)?),*$(,)?\n         }\n     )*) => {\n         [$(\n             AstNodeSrc {\n+                doc: &[$($doc),*],\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n                 fields: &[\n@@ -288,12 +292,14 @@ macro_rules! field {\n \n macro_rules! ast_enums {\n     ($(\n+        $(#[doc = $doc:expr])+\n         enum $name:ident $(: $($trait:ident),*)? {\n             $($variant:ident),*$(,)?\n         }\n     )*) => {\n         [$(\n             AstEnumSrc {\n+                doc: &[$($doc),*],\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n                 variants: &[$(stringify!($variant)),*],\n@@ -305,10 +311,35 @@ macro_rules! ast_enums {\n pub(crate) const AST_SRC: AstSrc = AstSrc {\n     tokens: &[\"Whitespace\", \"Comment\", \"String\", \"RawString\"],\n     nodes: &ast_nodes! {\n+        /// The entire Rust source file. Includes all top-level inner attributes and module items.\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/crates-and-source-files.html)\n         struct SourceFile: ModuleItemOwner, AttrsOwner, DocCommentsOwner {\n             modules: [Module],\n         }\n \n+        /// Function definition either with body or not.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub extern \"C\" fn foo<T>(#[attr] Patern {p}: Pattern) -> u32\n+        ///     where\n+        ///         T: Debug\n+        ///     {\n+        ///         42\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// extern \"C\" {\n+        ///     \u2770 fn fn_decl(also_variadic_ffi: u32, ...) -> u32; \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// - [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n+        /// - [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions)\n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n             Abi,\n             T![const],\n@@ -322,61 +353,275 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+        /// Return type annotation.\n+        ///\n+        /// ```\n+        /// fn foo(a: u32) \u2770 -> Option<u32> \u2771 { Some(a) }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct RetType { T![->], TypeRef }\n \n+        /// Struct definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     struct Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         pub a: u32,\n+        ///         b: T,\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// \u2770 struct Foo; \u2771\n+        /// \u2770 struct Foo<T>(#[attr] T) where T: Debug; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![struct],\n             FieldDefList,\n             T![;]\n         }\n \n+        /// Union definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub union Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         a: T,\n+        ///         b: u32,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/unions.html)\n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![union],\n             RecordFieldDefList,\n         }\n \n+        /// Record field definition list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// struct Foo // same for union\n+        /// \u2770\n+        ///     {\n+        ///         a: u32,\n+        ///         b: bool,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct RecordFieldDefList { T!['{'], fields: [RecordFieldDef], T!['}'] }\n+\n+        /// Record field definition including its attributes and doc comments.\n+        ///\n+        /// ` ``\n+        /// same for union\n+        /// struct Foo {\n+        ///      \u2770\n+        ///          /// Docs\n+        ///          #[attr]\n+        ///          pub a: u32\n+        ///      \u2771\n+        ///\n+        ///      \u2770 b: bool \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n+        /// Tuple field definition list including enclosing parens.\n+        ///\n+        /// ```\n+        /// struct Foo \u2770 (u32, String, Vec<u32>) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct TupleFieldDefList { T!['('], fields: [TupleFieldDef], T![')'] }\n+\n+        /// Tuple field definition including its attributes.\n+        ///\n+        /// ```\n+        /// struct Foo(\u2770 #[attr] u32 \u2771);\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n \n+        /// Enum definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub enum Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         Bar,\n+        ///         Baz(#[attr] u32),\n+        ///         Bruh {\n+        ///             a: u32,\n+        ///             /// Docs\n+        ///             #[attr]\n+        ///             b: T,\n+        ///         }\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![enum],\n             variant_list: EnumVariantList,\n         }\n+\n+        /// Enum variant definition list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// enum Foo\n+        /// \u2770\n+        ///     {\n+        ///         Bar,\n+        ///         Baz(u32),\n+        ///         Bruh {\n+        ///             a: u32\n+        ///         }\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumVariantList {\n             T!['{'],\n             variants: [EnumVariant],\n             T!['}']\n         }\n+\n+        /// Enum variant definition including its attributes and discriminant value definition.\n+        ///\n+        /// ```\n+        /// enum Foo {\n+        ///     \u2770\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         Bar\n+        ///     \u2771\n+        ///\n+        ///     // same for tuple and record variants\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n             FieldDefList,\n             T![=],\n             Expr\n         }\n \n+        /// Trait definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub unsafe trait Foo<T>: Debug where T: Debug {\n+        ///         // ...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/traits.html)\n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n             T![unsafe],\n             T![auto],\n             T![trait],\n             ItemList,\n         }\n \n+        /// Module definition either with body or not.\n+        /// Includes all of its inner and outer attributes, module items, doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub mod foo;\n+        /// \u2771\n+        ///\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub mod bar {\n+        ///        //! Inner docs\n+        ///        #![inner_attr]\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/modules.html)\n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n             T![mod],\n             ItemList,\n             T![;]\n         }\n \n+        /// Item defintion list.\n+        /// This is used for both top-level items and impl block items.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     fn foo {}\n+        ///     struct Bar;\n+        ///     enum Baz;\n+        ///     trait Bruh;\n+        ///     const BRUUH: u32 = 42;\n+        /// \u2771\n+        ///\n+        /// impl Foo\n+        /// \u2770\n+        ///     {\n+        ///         fn bar() {}\n+        ///         const BAZ: u32 = 42;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items.html)\n         struct ItemList: ModuleItemOwner {\n             T!['{'],\n             assoc_items: [AssocItem],\n             T!['}']\n         }\n \n+        /// Constant variable definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub const FOO: u32 = 42;\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/constant-items.html)\n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n             T![default],\n             T![const],\n@@ -385,6 +630,19 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+\n+        /// Static variable definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub static mut FOO: u32 = 42;\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/static-items.html)\n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n             T![static],\n             T![mut],\n@@ -393,6 +651,24 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+        /// Type alias definition.\n+        /// Includes associated type clauses with type bounds.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub type Foo<T> where T: Debug = T;\n+        /// \u2771\n+        ///\n+        /// trait Bar {\n+        ///     \u2770 type Baz: Debug; \u2771\n+        ///     \u2770 type Bruh = String; \u2771\n+        ///     \u2770 type Bruuh: Debug = u32; \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/type-aliases.html)\n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n             T![default],\n             T![type],\n@@ -401,6 +677,20 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+        /// Inherent and trait impl definition.\n+        /// Includes all of its inner and outer attributes.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     #[attr]\n+        ///     unsafe impl<T> const !Foo for Bar where T: Debug {\n+        ///         #![inner_attr]\n+        ///         // ...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/implementations.html)\n         struct ImplDef: TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![default],\n             T![const],\n@@ -411,99 +701,774 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             ItemList,\n         }\n \n+\n+        /// Parenthesized type reference.\n+        /// Note: parens are only used for grouping, this is not a tuple type.\n+        ///\n+        /// ```\n+        /// // This is effectively just `u32`.\n+        /// // Single-item tuple must be defined with a trailing comma: `(u32,)`\n+        /// type Foo = \u2770 (u32) \u2771;\n+        ///\n+        /// let bar: &'static \u2770 (dyn Debug) \u2771 = \"bruh\";\n+        /// ```\n         struct ParenType { T!['('], TypeRef, T![')'] }\n+\n+        /// Unnamed tuple type.\n+        ///\n+        /// ```\n+        /// let foo: \u2770 (u32, bool) \u2771 = (42, true);\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/tuple.html)\n         struct TupleType { T!['('], fields: [TypeRef], T![')'] }\n+\n+        /// The never type (i.e. the exclamation point).\n+        ///\n+        /// ```\n+        /// type T = \u2770 ! \u2771;\n+        ///\n+        /// fn no_return() -> \u2770 ! \u2771 {\n+        ///     loop {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/never.html)\n         struct NeverType { T![!] }\n+\n+        /// Path to a type.\n+        /// Includes single identifier type names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 String \u2771;\n+        /// type Bar = \u2770 std::vec::Vec<T> \u2771;\n+        /// type Baz = \u2770 ::bruh::<Bruuh as Iterator>::Item \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct PathType { Path }\n+\n+        /// Raw pointer type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 *const u32 \u2771;\n+        /// type Bar = \u2770 *mut u32 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut)\n         struct PointerType { T![*], T![const], T![mut], TypeRef }\n+\n+        /// Array type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 [u32; 24 - 3] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/array.html)\n         struct ArrayType { T!['['], TypeRef, T![;], Expr, T![']'] }\n+\n+        /// Slice type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 [u8] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/slice.html)\n         struct SliceType { T!['['], TypeRef, T![']'] }\n+\n+        /// Reference type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 &'static str \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html)\n         struct ReferenceType { T![&], T![lifetime], T![mut], TypeRef }\n+\n+        /// Placeholder type (i.e. the underscore).\n+        ///\n+        /// ```\n+        /// let foo: \u2770 _ \u2771 = 42_u32;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/inferred.html)\n         struct PlaceholderType { T![_] }\n+\n+        /// Function pointer type (not to be confused with `Fn*` family of traits).\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 async fn(#[attr] u32, named: bool) -> u32 \u2771;\n+        ///\n+        /// type Bar = \u2770 extern \"C\" fn(variadic: u32, #[attr] ...) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/function-pointer.html)\n         struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n+\n+        /// Higher order type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 for<'a> fn(&'a str) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/nomicon/hrtb.html)\n         struct ForType { T![for], TypeParamList, TypeRef }\n+\n+        /// Opaque `impl Trait` type.\n+        ///\n+        /// ```\n+        /// fn foo(bar: \u2770 impl Debug + Eq \u2771) {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/impl-trait.html)\n         struct ImplTraitType: TypeBoundsOwner { T![impl] }\n+\n+        /// Trait object type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 dyn Debug \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/trait-object.html)\n         struct DynTraitType: TypeBoundsOwner { T![dyn] }\n \n+        /// Tuple literal.\n+        ///\n+        /// ```\n+        /// \u2770 (42, true) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/tuple-expr.html)\n         struct TupleExpr: AttrsOwner { T!['('], exprs: [Expr], T![')'] }\n+\n+        /// Array literal.\n+        ///\n+        /// ```\n+        /// \u2770 [#![inner_attr] true, false, true] \u2771;\n+        ///\n+        /// \u2770 [\"baz\"; 24] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n         struct ArrayExpr: AttrsOwner { T!['['], exprs: [Expr], T![;], T![']'] }\n+\n+        /// Parenthesized expression.\n+        /// Note: parens are only used for grouping, this is not a tuple literal.\n+        ///\n+        /// ```\n+        /// \u2770 (#![inner_attr] 2 + 2) \u2771 * 2;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)\n         struct ParenExpr: AttrsOwner { T!['('], Expr, T![')'] }\n-        struct PathExpr  { Path }\n+\n+        /// Path to a symbol in expression context.\n+        /// Includes single identifier variable names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// \u2770 Some::<i32> \u2771;\n+        /// \u2770 foo \u2771 + 42;\n+        /// \u2770 Vec::<i32>::push \u2771;\n+        /// \u2770 <[i32]>::reverse \u2771;\n+        /// \u2770 <String as std::borrow::Borrow<str>>::borrow \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/path-expr.html)\n+        struct PathExpr { Path }\n+\n+        /// Anonymous callable object literal a.k.a. closure, lambda or functor.\n+        ///\n+        /// ```\n+        /// \u2770 || 42 \u2771;\n+        /// \u2770 |a: u32| val + 1 \u2771;\n+        /// \u2770 async |#[attr] Pattern(_): Pattern| { bar } \u2771;\n+        /// \u2770 move || baz \u2771;\n+        /// \u2770 || -> u32 { closure_with_ret_type_annotation_requires_block_expr } \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/closure-expr.html)\n         struct LambdaExpr: AttrsOwner {\n-            T![static],\n+            T![static], // Note(@matklad): I belive this is (used to be?) syntax for generators\n             T![async],\n             T![move],\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n+\n+        /// If expression. Includes both regular `if` and `if let` forms.\n+        /// Beware that `else if` is a special case syntax sugar, because in general\n+        /// there has to be block expression after `else`.\n+        ///\n+        /// ```\n+        /// \u2770 if bool_cond { 42 } \u2771\n+        /// \u2770 if bool_cond { 42 } else { 24 } \u2771\n+        /// \u2770 if bool_cond { 42 } else if bool_cond2 { 42 } \u2771\n+        ///\n+        /// \u2770\n+        ///     if let Pattern(foo) = bar {\n+        ///         foo\n+        ///     } else {\n+        ///         panic!();\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n         struct IfExpr: AttrsOwner { T![if], Condition }\n+\n+        /// Unconditional loop expression.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     loop {\n+        ///         // yeah, it's that simple...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html)\n         struct LoopExpr: AttrsOwner, LoopBodyOwner { T![loop] }\n+\n+        /// Block expression with an optional prefix (label, try ketword,\n+        /// unsafe keyword, async keyword...).\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     'label: try {\n+        ///         None?\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// - [try block](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)\n+        /// - [unsafe block](https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks)\n+        /// - [async block](https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks)\n         struct EffectExpr: AttrsOwner { Label, T![try], T![unsafe], T![async], BlockExpr }\n+\n+\n+        /// For loop expression.\n+        /// Note: record struct literals are not valid as iterable expression\n+        /// due to ambiguity.\n+        ///\n+        /// ```\n+        /// \u2770\n+        /// for i in (0..4) {\n+        ///     dbg!(i);\n+        /// }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops)\n         struct ForExpr: AttrsOwner, LoopBodyOwner {\n             T![for],\n             Pat,\n             T![in],\n             iterable: Expr,\n         }\n+\n+        /// While loop expression. Includes both regular `while` and `while let` forms.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     while bool_cond {\n+        ///         42;\n+        ///     }\n+        /// \u2771\n+        /// \u2770\n+        ///     while let Pattern(foo) = bar {\n+        ///         bar += 1;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n         struct WhileExpr: AttrsOwner, LoopBodyOwner { T![while], Condition }\n+\n+        /// Continue expression.\n+        ///\n+        /// ```\n+        /// while bool_cond {\n+        ///     \u2770 continue \u2771;\n+        /// }\n+        ///\n+        /// 'outer: loop {\n+        ///     loop {\n+        ///         \u2770 continue 'outer \u2771;\n+        ///     }\n+        /// }\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)\n         struct ContinueExpr: AttrsOwner { T![continue], T![lifetime] }\n+\n+        /// Break expression.\n+        ///\n+        /// ```\n+        /// while bool_cond {\n+        ///     \u2770 break \u2771;\n+        /// }\n+        /// 'outer: loop {\n+        ///     for foo in bar {\n+        ///         \u2770 break 'outer \u2771;\n+        ///     }\n+        /// }\n+        /// 'outer: loop {\n+        ///     loop {\n+        ///         \u2770 break 'outer 42 \u2771;\n+        ///     }\n+        /// }\n+        /// ```\n+        ///\n+        /// [Refernce](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions)\n         struct BreakExpr: AttrsOwner { T![break], T![lifetime], Expr }\n+\n+        /// Label.\n+        ///\n+        /// ```\n+        /// \u2770 'outer: \u2771 loop {}\n+        ///\n+        /// let foo = \u2770 'bar: \u2771 loop {}\n+        ///\n+        /// \u2770 'baz: \u2771 {\n+        ///     break 'baz;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html?highlight=label#loop-labels)\n+        /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct Label { T![lifetime] }\n+\n+        /// Block expression. Includes unsafe blocks and block labels.\n+        ///\n+        /// ```\n+        ///     let foo = \u2770\n+        ///         {\n+        ///             #![inner_attr]\n+        ///             \u2770 { } \u2771\n+        ///\n+        ///             \u2770 'label: { break 'label } \u2771\n+        ///         }\n+        ///     \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n+        /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct BlockExpr: AttrsOwner, ModuleItemOwner {\n             T!['{'], statements: [Stmt], Expr, T!['}'],\n         }\n+\n+        /// Return expression.\n+        ///\n+        /// ```\n+        /// || \u2770 return 42 \u2771;\n+        ///\n+        /// fn bar() {\n+        ///     \u2770 return \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/return-expr.html)\n         struct ReturnExpr: AttrsOwner { Expr }\n+\n+        /// Call expression (not to be confused with method call expression, it is\n+        /// a separate ast node).\n+        ///\n+        /// ```\n+        /// \u2770 foo() \u2771;\n+        /// \u2770 &str::len(\"bar\") \u2771;\n+        /// \u2770 <&str as PartialEq<&str>>::eq(&\"\", &\"\") \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n         struct CallExpr: ArgListOwner { Expr }\n+\n+        /// Method call expression.\n+        ///\n+        /// ```\n+        /// \u2770 receiver_expr.method() \u2771;\n+        /// \u2770 receiver_expr.method::<T>(42, true) \u2771;\n+        ///\n+        /// \u2770 \u2770 \u2770 foo.bar() \u2771 .baz() \u2771 .bruh() \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n             Expr, T![.], NameRef, TypeArgList,\n         }\n+\n+        /// Index expression a.k.a. subscript operator call.\n+        ///\n+        /// ```\n+        /// \u2770 foo[42] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n         struct IndexExpr: AttrsOwner { T!['['], T![']'] }\n+\n+        /// Field access expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr.bar \u2771;\n+        ///\n+        /// \u2770 \u2770 \u2770 foo.bar \u2771 .baz \u2771 .bruh \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/field-expr.html)\n         struct FieldExpr: AttrsOwner { Expr, T![.], NameRef }\n+\n+        /// Await operator call expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr.await \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/await-expr.html)\n         struct AwaitExpr: AttrsOwner { Expr, T![.], T![await] }\n+\n+        /// The question mark operator call.\n+        ///\n+        /// ```\n+        /// \u2770 expr? \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)\n         struct TryExpr: AttrsOwner { Expr, T![?] }\n+\n+        /// Type cast expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr as T \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)\n         struct CastExpr: AttrsOwner { Expr, T![as], TypeRef }\n+\n+\n+        /// Borrow operator call.\n+        ///\n+        /// ```\n+        /// \u2770 &foo \u2771;\n+        /// \u2770 &mut bar \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n         struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], Expr }\n+\n+        /// Prefix operator call. This is either `!` or `*` or `-`.\n+        ///\n+        /// ```\n+        /// \u2770 !foo \u2771;\n+        /// \u2770 *bar \u2771;\n+        /// \u2770 -42 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html)\n         struct PrefixExpr: AttrsOwner { /*PrefixOp,*/ Expr }\n+\n+        /// Box operator call.\n+        ///\n+        /// ```\n+        /// \u2770 box 42 \u2771;\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0809-box-and-in-for-stdlib.md)\n         struct BoxExpr: AttrsOwner { T![box], Expr }\n+\n+        /// Range operator call.\n+        ///\n+        /// ```\n+        /// \u2770 0..42 \u2771;\n+        /// \u2770 ..42 \u2771;\n+        /// \u2770 0.. \u2771;\n+        /// \u2770 .. \u2771;\n+        /// \u2770 0..=42 \u2771;\n+        /// \u2770 ..=42 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/range-expr.html)\n         struct RangeExpr: AttrsOwner { /*RangeOp*/ }\n+\n+\n+        /// Binary operator call.\n+        /// Includes all arithmetic, logic, bitwise and assignment operators.\n+        ///\n+        /// ```\n+        /// \u2770 2 + \u2770 2 * 2 \u2771 \u2771;\n+        /// \u2770 \u2770 true && false \u2771 || true \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)\n         struct BinExpr: AttrsOwner { /*BinOp*/ }\n+\n+\n+        /// [Raw] string, [raw] byte string, char, byte, integer, float or bool literal.\n+        ///\n+        /// ```\n+        /// \u2770 \"str\" \u2771;\n+        /// \u2770 br##\"raw byte str\"## \u2771;\n+        /// \u2770 'c' \u2771;\n+        /// \u2770 b'c' \u2771;\n+        /// \u2770 42 \u2771;\n+        /// \u2770 1e9 \u2771;\n+        /// \u2770 true \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/literal-expr.html)\n         struct Literal { /*LiteralToken*/ }\n \n+        /// Match expression.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     match expr {\n+        ///         Pat1 => {}\n+        ///         Pat2(_) => 42,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchExpr: AttrsOwner { T![match], Expr, MatchArmList }\n+\n+        /// Match arm list part of match expression. Includes its inner attributes.\n+        ///\n+        /// ```\n+        /// match expr\n+        /// \u2770\n+        ///     {\n+        ///         #![inner_attr]\n+        ///         Pat1 => {}\n+        ///         Pat2(_) => 42,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchArmList: AttrsOwner { T!['{'], arms: [MatchArm], T!['}'] }\n+\n+\n+        /// Match arm.\n+        /// Note: record struct literals are not valid as target match expression\n+        /// due to ambiguity.\n+        /// ```\n+        /// match expr {\n+        ///     \u2770 #[attr] Pattern(it) if bool_cond => it \u2771,\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n             T![=>],\n             Expr,\n         }\n+\n+        /// Match guard.\n+        ///\n+        /// ```\n+        /// match expr {\n+        ///     Pattern(it) \u2770 if bool_cond \u2771 => it,\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards)\n         struct MatchGuard { T![if], Expr }\n \n+        /// Record literal expression. The same syntax is used for structs,\n+        /// unions and record enum variants.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     foo::Bar {\n+        ///         #![inner_attr]\n+        ///         baz: 42,\n+        ///         bruh: true,\n+        ///         ..spread\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordLit { Path, RecordFieldList}\n+\n+        /// Record field list including enclosing curly braces.\n+        ///\n+        /// foo::Bar \u2770\n+        ///     {\n+        ///         baz: 42,\n+        ///         ..spread\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordFieldList {\n             T!['{'],\n             fields: [RecordField],\n             T![..],\n             spread: Expr,\n             T!['}']\n         }\n+\n+        /// Record field.\n+        ///\n+        /// ```\n+        /// foo::Bar {\n+        ///     \u2770 #[attr] baz: 42 \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordField: AttrsOwner { NameRef, T![:], Expr }\n \n+        /// Disjunction of patterns.\n+        ///\n+        /// ```\n+        /// let \u2770 Foo(it) | Bar(it) | Baz(it) \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html)\n         struct OrPat { pats: [Pat] }\n+\n+        /// Parenthesized pattern.\n+        /// Note: parens are only used for grouping, this is not a tuple pattern.\n+        ///\n+        /// ```\n+        /// if let \u2770 &(0..=42) \u2771 = foo {}\n+        /// ```\n+        ///\n+        /// https://doc.rust-lang.org/reference/patterns.html#grouped-patterns\n         struct ParenPat { T!['('], Pat, T![')'] }\n+\n+        /// Reference pattern.\n+        /// Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns.\n+        ///\n+        /// ```\n+        /// let \u2770 &mut foo \u2771 = bar;\n+        ///\n+        /// let \u2770 & \u2770 &mut \u2770 &_ \u2771 \u2771 \u2771 = baz;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#reference-patterns)\n         struct RefPat { T![&], T![mut], Pat }\n+\n+        /// Box pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 box foo \u2771 = box 42;\n+        /// ```\n+        ///\n+        /// [Unstable book](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)\n         struct BoxPat { T![box], Pat }\n+\n+        /// Bind pattern.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     Some(\u2770 ref mut bar \u2771) => {}\n+        ///     \u2770 baz @ None \u2771 => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#identifier-patterns)\n         struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], T![@], Pat }\n+\n+        /// Placeholder pattern a.k.a. the wildcard pattern or the underscore.\n+        ///\n+        /// ```\n+        /// let \u2770 _ \u2771 = foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern)\n         struct PlaceholderPat { T![_] }\n+\n+        /// Rest-of-the record/tuple pattern.\n+        /// Note: this is not the unbonded range pattern (even more: it doesn't exist).\n+        ///\n+        /// ```\n+        /// let Foo { bar, \u2770 .. \u2771 } = baz;\n+        /// let (\u2770 .. \u2771, bruh) = (42, 24, 42);\n+        /// let Bruuh(\u2770 .. \u2771) = bruuuh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct DotDotPat { T![..] }\n+\n+        /// Path pattern.\n+        /// Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`).\n+        ///\n+        /// ```\n+        /// let \u2770 foo::bar::Baz \u2771 { .. } = bruh;\n+        /// if let \u2770 CONST \u2771 = 42 {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#path-patterns)\n         struct PathPat { Path }\n+\n+        /// Slice pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 [foo, bar, baz] \u2771 = [1, 2, 3];\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#slice-patterns)\n         struct SlicePat { T!['['], args: [Pat], T![']'] }\n-        struct RangePat { /*RangeSeparator*/ }\n+\n+        /// Range pattern.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     \u2770 0..42 \u2771 => {}\n+        ///     \u2770 0..=42 \u2771 => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#range-patterns)\n+        struct RangePat { } // FIXME(@matklad): here should be T![..], T![..=] I think, if we don't already have an accessor in expresions_ext\n+\n+        /// Literal pattern.\n+        /// Includes only bool, number, char, and string literals.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     Number(\u2770 42 \u2771) => {}\n+        ///     String(\u2770 \"42\" \u2771) => {}\n+        ///     Bool(\u2770 true \u2771) => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#literal-patterns)\n         struct LiteralPat { Literal }\n+\n+        /// Macro invocation in pattern position.\n+        ///\n+        /// ```\n+        /// let \u2770 foo!(my custom syntax) \u2771 = baz;\n+        ///\n+        /// ```\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html#macro-invocation)\n         struct MacroPat { MacroCall }\n \n+        /// Record literal pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 foo::Bar { baz, .. } \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordPat { RecordFieldPatList, Path }\n+\n+        /// Record literal's field patterns list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// let foo::Bar \u2770 { baz, bind @ bruh, .. } \u2771 = bruuh;\n+        /// ``\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordFieldPatList {\n             T!['{'],\n             pats: [RecordInnerPat],\n@@ -512,20 +1477,148 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![..],\n             T!['}']\n         }\n+\n+        /// Record literal's field pattern.\n+        /// Note: record literal can also match tuple structs.\n+        ///\n+        /// ```\n+        /// let Foo { \u2770 bar: _ \u2771 } = baz;\n+        /// let TupleStruct { \u2770 0: _ \u2771 } = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordFieldPat: AttrsOwner { NameRef, T![:], Pat }\n \n+        /// Tuple struct literal pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 foo::Bar(baz, bruh) \u2771 = bruuh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns)\n         struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n+\n+        /// Tuple pattern.\n+        /// Note: this doesn't include tuple structs (see `TupleStructPat`)\n+        ///\n+        /// ```\n+        /// let \u2770 (foo, bar, .., baz) \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-patterns)\n         struct TuplePat { T!['('], args: [Pat], T![')'] }\n \n+        /// Visibility.\n+        ///\n+        /// ```\n+        /// \u2770 pub mod \u2771 foo;\n+        /// \u2770 pub(crate) \u2771 struct Bar;\n+        /// \u2770 pub(self) \u2771 enum Baz {}\n+        /// \u2770 pub(super) \u2771 fn bruh() {}\n+        /// \u2770 pub(in bruuh::bruuuh) \u2771 type T = u64;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html)\n         struct Visibility { T![pub], T![super], T![self], T![crate] }\n+\n+        /// Single identifier.\n+        /// Note(@matklad): `Name` is for things that install a new name into the scope,\n+        /// `NameRef` is a usage of a name. Most of the time, this definition/reference\n+        /// distinction can be determined purely syntactically, ie in\n+        /// ```\n+        /// fn foo() { foo() }\n+        /// ```\n+        /// the first foo is `Name`, the second one is `NameRef`.\n+        /// The notable exception are patterns, where in\n+        /// ``\n+        /// let x = 92\n+        /// ```\n+        /// `x` can be semantically either a name or a name ref, depeding on\n+        /// wether there's an `x` constant in scope.\n+        /// We use `Name` for patterns, and disambiguate semantically (see `NameClass` in ide_db).\n+        ///\n+        /// ```\n+        /// let \u2770 foo \u2771 = bar;\n+        /// struct \u2770 Baz \u2771;\n+        /// fn \u2770 bruh \u2771() {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n         struct Name { T![ident] }\n-        struct NameRef { /*NameRefToken*/ }\n \n-        struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n+        /// Reference to a name.\n+        /// See the explanation on the difference between `Name` and `NameRef`\n+        /// in `Name` ast node docs.\n+        ///\n+        /// ```\n+        /// let foo = \u2770 bar \u2771(\u2770 Baz(\u2770 bruh \u2771) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n+        struct NameRef { }\n+\n+        /// Macro call.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     macro_rules! foo {   // macro rules is also a macro call\n+        ///         ($bar: tt) => {}\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// // semicolon is a part of `MacroCall` when it is used in item positions\n+        /// \u2770 foo!(); \u2771\n+        ///\n+        /// fn main() {\n+        ///     \u2770 foo!() \u2771; // macro call in expression positions doesn't include the semi\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n+        struct MacroCall: NameOwner, AttrsOwner, DocCommentsOwner {\n             Path, T![!], TokenTree, T![;]\n         }\n+\n+        /// Attribute.\n+        ///\n+        /// ```\n+        /// \u2770 #![inner_attr] \u2771\n+        ///\n+        /// \u2770 #[attr] \u2771\n+        /// \u2770 #[foo = \"bar\"] \u2771\n+        /// \u2770 #[baz(bruh::bruuh = \"42\")] \u2771\n+        /// struct Foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/attributes.html)\n         struct Attr { T![#], T![!], T!['['], Path, T![=], input: AttrInput, T![']'] }\n+\n+        /// Stores a list of lexer tokens and other `TokenTree`s.\n+        /// It appears in attributes, macro_rules and macro call (foo!)\n+        ///\n+        /// ```\n+        /// macro_call! \u2770 { my syntax here } \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n         struct TokenTree {}\n+\n+        /// Generic lifetime, type and constants parameters list **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo\u2770 <'a, 'b, T, U, const BAR: u64> \u2771() {}\n+        ///\n+        /// struct Baz\u2770 <T> \u2771(T);\n+        ///\n+        /// impl\u2770 <T> \u2771 Bruh<T> {}\n+        ///\n+        /// type Bruuh = for\u2770 <'a> \u2771 fn(&'a str) -> &'a str;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct TypeParamList {\n             T![<],\n             generic_params: [GenericParam],\n@@ -534,64 +1627,334 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             const_params: [ConstParam],\n             T![>]\n         }\n+\n+        /// Single type parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo<\u2770 K \u2771, \u2770 I \u2771, \u2770 E: Debug \u2771, \u2770 V = DefaultType \u2771>() {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n             T![=],\n             default_type: TypeRef,\n         }\n+\n+        /// Const generic parameter **declaration**.\n+        /// ```\n+        /// fn foo<T, U, \u2770 const BAR: usize \u2771, \u2770 const BAZ: bool \u2771>() {}\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n         struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n             T![=],\n             default_val: Expr,\n         }\n+\n+        /// Lifetime parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo<\u2770 'a \u2771, \u2770 'b \u2771, V, G, D>(bar: &'a str, baz: &'b mut str) {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct LifetimeParam: AttrsOwner { T![lifetime] }\n-        struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question,  */ TypeRef}\n+\n+        /// Type bound declaration clause.\n+        ///\n+        /// ```\n+        /// fn foo<T: \u2770 ?Sized \u2771 + \u2770 Debug \u2771>() {}\n+        ///\n+        /// trait Bar<T>\n+        /// where\n+        ///     T: \u2770 Send \u2771 + \u2770 Sync \u2771\n+        /// {\n+        ///     type Baz: \u2770 !Sync \u2771 + \u2770 Debug \u2771 + \u2770 ?const Add \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n+        struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question, */ TypeRef }\n+\n+        /// Type bounds list.\n+        ///\n+        /// ```\n+        ///\n+        /// fn foo<T: \u2770 ?Sized + Debug \u2771>() {}\n+        ///\n+        /// trait Bar<T>\n+        /// where\n+        ///     T: \u2770 Send + Sync \u2771\n+        /// {\n+        ///     type Baz: \u2770 !Sync + Debug \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n         struct TypeBoundList { bounds: [TypeBound] }\n+\n+        /// Single where predicate.\n+        ///\n+        /// ```\n+        /// trait Foo<'a, 'b, T>\n+        /// where\n+        ///     \u2770 'a: 'b \u2771,\n+        ///     \u2770 T: IntoIterator \u2771,\n+        ///     \u2770 for<'c> <T as IntoIterator>::Item: Bar<'c> \u2771\n+        /// {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n         struct WherePred: TypeBoundsOwner { T![lifetime], TypeRef }\n+\n+        /// Where clause.\n+        ///\n+        /// ```\n+        /// trait Foo<'a, T> \u2770 where 'a: 'static, T: Debug \u2771 {}\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n         struct WhereClause { T![where], predicates: [WherePred] }\n+\n+        /// Abi declaration.\n+        /// Note: the abi string is optional.\n+        ///\n+        /// ```\n+        /// \u2770 extern \"C\" \u2771 {\n+        ///     fn foo() {}\n+        /// }\n+        ///\n+        /// type Bar = \u2770 extern \u2771 fn() -> u32;\n+        ///\n+        /// type Baz = \u2770 extern r#\"stdcall\"# \u2771 fn() -> bool;\n+        /// ```\n+        ///\n+        /// - [Extern blocks reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n+        /// - [FFI function pointers reference](https://doc.rust-lang.org/reference/items/functions.html#functions)\n         struct Abi { /*String*/ }\n+\n+        /// Expression statement.\n+        ///\n+        /// ```\n+        /// \u2770 42; \u2771\n+        /// \u2770 foo(); \u2771\n+        /// \u2770 (); \u2771\n+        /// \u2770 {}; \u2771\n+        ///\n+        /// // constructions with trailing curly brace can omit the semicolon\n+        /// // but only when there are satements immediately after them (this is important!)\n+        /// \u2770 if bool_cond { } \u2771\n+        /// \u2770 loop {} \u2771\n+        /// \u2770 somestatment; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/statements.html)\n         struct ExprStmt: AttrsOwner { Expr, T![;] }\n+\n+        /// Let statement.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] let foo; \u2771\n+        /// \u2770 let bar: u64; \u2771\n+        /// \u2770 let baz = 42; \u2771\n+        /// \u2770 let bruh: bool = true; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/statements.html#let-statements)\n         struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n             T![let],\n             Pat,\n             T![=],\n             initializer: Expr,\n             T![;],\n         }\n+\n+        /// Condition of `if` or `while` expression.\n+        ///\n+        /// ```\n+        /// if \u2770 true \u2771 {}\n+        /// if \u2770 let Pat(foo) = bar \u2771 {}\n+        ///\n+        /// while \u2770 true \u2771 {}\n+        /// while \u2770 let Pat(baz) = bruh \u2771 {}\n+        /// ```\n+        ///\n+        /// [If expression reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n+        /// [While expression reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n         struct Condition { T![let], Pat, T![=], Expr }\n-        struct ParamList {\n+\n+        /// Parameter list **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo\u2770 (a: u32, b: bool) \u2771 -> u32 {}\n+        /// let bar = \u2770 |a, b| \u2771 {};\n+        ///\n+        /// impl Baz {\n+        ///     fn bruh\u2770 (&self, a: u32) \u2771 {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)ocs to codegen script\n+        struct ParamList { // FIXME: this node is used by closure expressions too, but hey use pipes instead of parens...\n             T!['('],\n             SelfParam,\n             params: [Param],\n             T![')']\n         }\n+\n+        /// Self parameter **declaration**.\n+        ///\n+        /// ```\n+        /// impl Bruh {\n+        ///     fn foo(\u2770 self \u2771) {}\n+        ///     fn bar(\u2770 &self \u2771) {}\n+        ///     fn baz(\u2770 &mut self \u2771) {}\n+        ///     fn blah<'a>(\u2770 &'a self \u2771) {}\n+        ///     fn blin(\u2770 self: Box<Self> \u2771) {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct SelfParam: TypeAscriptionOwner, AttrsOwner { T![&], T![mut], T![lifetime], T![self] }\n+\n+        /// Parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo(\u2770 #[attr] Pat(bar): Pat(u32) \u2771, \u2770 #[attr] _: bool \u2771) {}\n+        ///\n+        /// extern \"C\" {\n+        ///     fn bar(\u2770 baz: u32 \u2771, \u2770 ... \u2771) -> u32;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n             T![...]\n         }\n+\n+        /// Use declaration.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] pub use foo; \u2771\n+        /// \u2770 use bar as baz; \u2771\n+        /// \u2770 use bruh::{self, bruuh}; \u2771\n+        /// \u2770 use { blin::blen, blah::* };\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseItem: AttrsOwner, VisibilityOwner {\n             T![use],\n             UseTree,\n         }\n+\n+        /// Use tree.\n+        ///\n+        /// ```\n+        /// pub use \u2770 foo::\u2770 * \u2771 \u2771;\n+        /// use \u2770 bar as baz \u2771;\n+        /// use \u2770 bruh::bruuh::{ \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+        /// use \u2770 { \u2770 blin::blen \u2771 } \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseTree {\n             Path, T![*], UseTreeList, Alias\n         }\n+\n+        /// Item alias.\n+        /// Note: this is not the type alias.\n+        ///\n+        /// ```\n+        /// use foo \u2770 as bar \u2771;\n+        /// use baz::{bruh \u2770 as _ \u2771};\n+        /// extern crate bruuh \u2770 as blin \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct Alias: NameOwner { T![as] }\n+\n+        /// Sublist of use trees.\n+        ///\n+        /// ```\n+        /// use bruh::bruuh::\u2770 { \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+        /// use \u2770 { blin::blen::\u2770 {} \u2771 } \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseTreeList { T!['{'], use_trees: [UseTree], T!['}'] }\n+\n+        /// Extern crate item.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] pub extern crate foo; \u2771\n+        /// \u2770 extern crate self as bar; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/extern-crates.html)\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n             T![extern], T![crate], NameRef, Alias,\n         }\n+\n+        /// Call site arguments list.\n+        ///\n+        /// ```\n+        /// foo::<T, U>\u2770 (42, true) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n         struct ArgList {\n             T!['('],\n             args: [Expr],\n             T![')']\n         }\n+\n+        /// Path to a symbol. Includes single identifier names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// (0..10).\u2770 \u2770 collect \u2771 ::<Vec<_>> \u2771();\n+        /// \u2770 \u2770 \u2770 Vec \u2771 ::<u8> \u2771 ::with_capacity \u2771(1024);\n+        /// \u2770 \u2770 <\u2770 Foo \u2771 as \u2770 \u2770 bar \u2771 ::Bar \u2771> \u2771 ::baz \u2771();\n+        /// \u2770 \u2770 <\u2770 bruh \u2771> \u2771 ::bruuh \u2771();\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct Path {\n             segment: PathSegment,\n+            T![::],\n             qualifier: Path,\n         }\n+\n+        /// Segment of the path to a symbol.\n+        /// Only path segment of an absolute path holds the `::` token,\n+        /// all other `::` tokens that connect path segments reside under `Path` itself.`\n+        ///\n+        /// ```\n+        /// (0..10).\u2770 collect \u2771 :: \u2770 <Vec<_>> \u2771();\n+        /// \u2770 Vec \u2771 :: \u2770 <u8> \u2771 :: \u2770 with_capacity \u2771(1024);\n+        /// \u2770 <\u2770 Foo \u2771 as \u2770 bar \u2771 :: \u2770 Bar \u2771> \u2771 :: \u2770 baz \u2771();\n+        /// \u2770 <\u2770 bruh \u2771> \u2771 :: \u2770 bruuh \u2771();\n+        ///\n+        /// // Note that only in this case `::` token is inlcuded:\n+        /// \u2770 ::foo \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct PathSegment {\n             T![::], T![crate], T![self], T![super], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n         }\n+\n+        /// List of type arguments that are passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// type _ = Foo \u2770 ::<'a, u64, Item = Bar, 42, {true}> \u2771::Bar;\n+        ///\n+        /// Vec\u2770 ::<bool> \u2771::();\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct TypeArgList {\n             T![::],\n             T![<],\n@@ -602,55 +1965,150 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             const_args: [ConstArg],\n             T![>]\n         }\n+\n+        /// Type argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// type _ = Foo::<'a, \u2770 u64 \u2771, \u2770 bool \u2771, Item = Bar, 42>::Baz;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct TypeArg { TypeRef }\n+\n+        /// Associated type argument that is passed at generic instantiation site.\n+        /// ```\n+        /// type Foo = Bar::<'a, u64, bool, \u2770 Item = Baz \u2771, 42>::Bruh;\n+        ///\n+        /// trait Bruh<T>: Iterator<\u2770 Item: Debug \u2771> {}\n+        /// ```\n+        ///\n         struct AssocTypeArg : TypeBoundsOwner { NameRef, T![=], TypeRef }\n+\n+        /// Lifetime argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// fn foo<'a>(s: &'a str) {\n+        ///     bar::<\u2770 'a \u2771>(s);\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct LifetimeArg { T![lifetime] }\n-        struct ConstArg { Literal, T![=], BlockExpr }\n \n-        struct MacroItems: ModuleItemOwner{ }\n+        /// Constant value argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// foo::<u32, \u2770 { true } \u2771>();\n+        ///\n+        /// bar::<\u2770 { 2 + 2} \u2771>();\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n+        struct ConstArg { Literal, BlockExpr }\n+\n+\n+        /// FIXME: (@edwin0cheng) Remove it to use ItemList instead\n+        /// https://github.com/rust-analyzer/rust-analyzer/pull/4083#discussion_r422666243\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n+        struct MacroItems: ModuleItemOwner { }\n \n+        /// FIXME: (@edwin0cheng) add some documentation here. As per the writing\n+        /// of this comment this ast node is not used.\n+        ///\n+        /// ```\n+        /// // FIXME: example here\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n         struct MacroStmts {\n             statements: [Stmt],\n             Expr,\n         }\n \n+        /// List of items in an extern block.\n+        ///\n+        /// ```\n+        /// extern \"C\" \u2770\n+        ///     {\n+        ///         fn foo();\n+        ///         static var: u32;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n         struct ExternItemList: ModuleItemOwner {\n             T!['{'],\n             extern_items: [ExternItem],\n             T!['}']\n         }\n \n+        /// Extern block.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     extern \"C\" {\n+        ///         fn foo();\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n         struct ExternBlock {\n             Abi,\n             ExternItemList\n         }\n \n+        /// Meta item in an attribute.\n+        ///\n+        /// ```\n+        /// #[\u2770 bar::baz = \"42\" \u2771]\n+        /// #[\u2770 bruh(bruuh(\"true\")) \u2771]\n+        /// struct Foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/attributes.html?highlight=meta,item#meta-item-attribute-syntax)\n         struct MetaItem {\n             Path, T![=], AttrInput, nested_meta_items: [MetaItem]\n         }\n \n+        /// Macro 2.0 definition.\n+        /// Their syntax is still WIP by rustc team...\n+        /// ```\n+        /// \u2770\n+        ///     macro foo { }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md)\n         struct MacroDef {\n             Name, TokenTree\n         }\n     },\n     enums: &ast_enums! {\n+        /// Any kind of nominal type definition.\n         enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n             StructDef, EnumDef, UnionDef,\n         }\n \n+        /// Any kind of **declared** generic parameter\n         enum GenericParam {\n             LifetimeParam,\n             TypeParam,\n             ConstParam\n         }\n \n+        /// Any kind of generic argument passed at instantiation site\n         enum GenericArg {\n             LifetimeArg,\n             TypeArg,\n             ConstArg,\n             AssocTypeArg\n         }\n \n+        /// Any kind of construct valid in type context\n         enum TypeRef {\n             ParenType,\n             TupleType,\n@@ -667,6 +2125,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             DynTraitType,\n         }\n \n+        /// Any kind of top-level item that may appear in a module\n         enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n             StructDef,\n             UnionDef,\n@@ -684,16 +2143,23 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             ExternBlock\n         }\n \n-        /* impl blocks can also contain MacroCall */\n+\n+\n+        /// Any kind of item that may appear in an impl block\n+        ///\n+        /// // FIXME: impl blocks can also contain MacroCall\n         enum AssocItem: NameOwner, AttrsOwner {\n             FnDef, TypeAliasDef, ConstDef\n         }\n \n-        /* extern blocks can also contain MacroCall */\n+        /// Any kind of item that may appear in an extern block\n+        ///\n+        /// // FIXME: extern blocks can also contain MacroCall\n         enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n             FnDef, StaticDef\n         }\n \n+        /// Any kind of expression\n         enum Expr: AttrsOwner {\n             TupleExpr,\n             ArrayExpr,\n@@ -728,6 +2194,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             BoxExpr,\n         }\n \n+        /// Any kind of pattern\n         enum Pat {\n             OrPat,\n             ParenPat,\n@@ -746,18 +2213,26 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             MacroPat,\n         }\n \n+        /// Any kind of pattern that appears directly inside of the curly\n+        /// braces of a record pattern\n         enum RecordInnerPat {\n             RecordFieldPat,\n             BindPat\n         }\n \n+        /// Any kind of input to an attribute\n         enum AttrInput { Literal, TokenTree }\n+\n+        /// Any kind of statement\n+        /// Note: there are no empty statements, these are just represented as\n+        /// bare semicolons without a dedicated statement ast node.\n         enum Stmt {\n             LetStmt,\n             ExprStmt,\n-            // macro calls are parsed as expression statements */\n+            // macro calls are parsed as expression statements\n         }\n \n+        /// Any kind of fields list (record or tuple field lists)\n         enum FieldDefList {\n             RecordFieldDefList,\n             TupleFieldDefList,"}, {"sha": "19d5594f5b06f6af89e0235f82a003e164f16f93", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=9594fe33fabeb2f97afad86c3a5d5ed79e3d54d8", "patch": "@@ -3,7 +3,7 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::collections::HashSet;\n+use std::{collections::HashSet, fmt::Write};\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n@@ -102,6 +102,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             });\n             (\n                 quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n                     #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n                     pub struct #name {\n                         pub(crate) syntax: SyntaxNode,\n@@ -145,6 +146,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n \n             (\n                 quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n                     #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n                     pub enum #name {\n                         #(#variants(#variants),)*\n@@ -230,10 +232,29 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     };\n \n     let ast = ast.to_string().replace(\"T ! [ \", \"T![\").replace(\" ] )\", \"])\");\n-    let pretty = crate::reformat(ast)?.replace(\"#[derive\", \"\\n#[derive\");\n+\n+    let mut res = String::with_capacity(ast.len() * 2);\n+\n+    let mut docs =\n+        grammar.nodes.iter().map(|it| it.doc).chain(grammar.enums.iter().map(|it| it.doc));\n+\n+    for chunk in ast.split(\"# [ pretty_doc_comment_placeholder_workaround ]\") {\n+        res.push_str(chunk);\n+        if let Some(doc) = docs.next() {\n+            write_doc_comment(doc, &mut res);\n+        }\n+    }\n+\n+    let pretty = crate::reformat(res)?;\n     Ok(pretty)\n }\n \n+fn write_doc_comment(contents: &[&str], dest: &mut String) {\n+    for line in contents {\n+        writeln!(dest, \"///{}\", line).unwrap();\n+    }\n+}\n+\n fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n     let (single_byte_tokens_values, single_byte_tokens): (Vec<_>, Vec<_>) = grammar\n         .punct"}]}