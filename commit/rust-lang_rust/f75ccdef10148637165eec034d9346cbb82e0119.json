{"sha": "f75ccdef10148637165eec034d9346cbb82e0119", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NWNjZGVmMTAxNDg2MzcxNjVlZWMwMzRkOTM0NmNiYjgyZTAxMTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-06T04:51:59Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-09T07:57:24Z"}, "message": "extract pattern lowering -> pat.rs", "tree": {"sha": "f8599f6c742f2b4faeb79b0f95a8ed673def8baa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8599f6c742f2b4faeb79b0f95a8ed673def8baa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f75ccdef10148637165eec034d9346cbb82e0119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f75ccdef10148637165eec034d9346cbb82e0119", "html_url": "https://github.com/rust-lang/rust/commit/f75ccdef10148637165eec034d9346cbb82e0119", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f75ccdef10148637165eec034d9346cbb82e0119/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "956265d55b7c2039eaa2476cfc3b370ead322ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/956265d55b7c2039eaa2476cfc3b370ead322ce4", "html_url": "https://github.com/rust-lang/rust/commit/956265d55b7c2039eaa2476cfc3b370ead322ce4"}], "stats": {"total": 502, "additions": 256, "deletions": 246}, "files": [{"sha": "658bcb26ecfcdcca2c715baabc3c5cebdf47a326", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 3, "deletions": 246, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/f75ccdef10148637165eec034d9346cbb82e0119/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75ccdef10148637165eec034d9346cbb82e0119/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=f75ccdef10148637165eec034d9346cbb82e0119", "patch": "@@ -33,6 +33,7 @@\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(array_value_iter)]\n+#![feature(crate_visibility_modifier)]\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n@@ -58,14 +59,13 @@ use rustc_session::config::nightly_options;\n use rustc_session::node_id::NodeMap;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::print::pprust;\n-use syntax::ptr::P as AstP;\n use syntax::sess::ParseSess;\n use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -86,6 +86,7 @@ macro_rules! arena_vec {\n \n mod expr;\n mod item;\n+mod pat;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -2636,250 +2637,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        let node = match p.kind {\n-            PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                node\n-            }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-            PatKind::TupleStruct(ref path, ref pats) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-            }\n-            PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n-            }\n-            PatKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::PatKind::Path(qpath)\n-            }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-\n-                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                    hir_id: self.next_id(),\n-                    ident: f.ident,\n-                    pat: self.lower_pat(&f.pat),\n-                    is_shorthand: f.is_shorthand,\n-                    span: f.span,\n-                }));\n-                hir::PatKind::Struct(qpath, fs, etc)\n-            }\n-            PatKind::Tuple(ref pats) => {\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                hir::PatKind::Tuple(pats, ddpos)\n-            }\n-            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                self.lower_expr(e1),\n-                self.lower_expr(e2),\n-                self.lower_range_end(end),\n-            ),\n-            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-            PatKind::Rest => {\n-                // If we reach here the `..` pattern is not semantically allowed.\n-                self.ban_illegal_rest_pat(p.span)\n-            }\n-            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-        };\n-\n-        self.pat_with_node_id_of(p, node)\n-    }\n-\n-    fn lower_pat_tuple(\n-        &mut self,\n-        pats: &[AstP<Pat>],\n-        ctx: &str,\n-    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n-        let mut elems = Vec::with_capacity(pats.len());\n-        let mut rest = None;\n-\n-        let mut iter = pats.iter().enumerate();\n-        for (idx, pat) in iter.by_ref() {\n-            // Interpret the first `..` pattern as a sub-tuple pattern.\n-            // Note that unlike for slice patterns,\n-            // where `xs @ ..` is a legal sub-slice pattern,\n-            // it is not a legal sub-tuple pattern.\n-            if pat.is_rest() {\n-                rest = Some((idx, pat.span));\n-                break;\n-            }\n-            // It was not a sub-tuple pattern so lower it normally.\n-            elems.push(self.lower_pat(pat));\n-        }\n-\n-        for (_, pat) in iter {\n-            // There was a previous sub-tuple pattern; make sure we don't allow more...\n-            if pat.is_rest() {\n-                // ...but there was one again, so error.\n-                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n-            } else {\n-                elems.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n-    }\n-\n-    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n-    /// `hir::PatKind::Slice(before, slice, after)`.\n-    ///\n-    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n-    /// this is interpreted as a sub-slice pattern semantically.\n-    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n-    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind<'hir> {\n-        let mut before = Vec::new();\n-        let mut after = Vec::new();\n-        let mut slice = None;\n-        let mut prev_rest_span = None;\n-\n-        let mut iter = pats.iter();\n-        // Lower all the patterns until the first occurence of a sub-slice pattern.\n-        for pat in iter.by_ref() {\n-            match pat.kind {\n-                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n-                PatKind::Rest => {\n-                    prev_rest_span = Some(pat.span);\n-                    slice = Some(self.pat_wild_with_node_id_of(pat));\n-                    break;\n-                }\n-                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n-                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n-                    prev_rest_span = Some(sub.span);\n-                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n-                    slice = Some(self.pat_with_node_id_of(pat, node));\n-                    break;\n-                }\n-                // It was not a subslice pattern so lower it normally.\n-                _ => before.push(self.lower_pat(pat)),\n-            }\n-        }\n-\n-        // Lower all the patterns after the first sub-slice pattern.\n-        for pat in iter {\n-            // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n-                PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n-                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n-                    after.push(self.pat_wild_with_node_id_of(pat));\n-                    Some(sub.span)\n-                }\n-                _ => None,\n-            };\n-            if let Some(rest_span) = rest_span {\n-                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n-                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n-            } else {\n-                // Lower the pattern normally.\n-                after.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        hir::PatKind::Slice(\n-            self.arena.alloc_from_iter(before),\n-            slice,\n-            self.arena.alloc_from_iter(after),\n-        )\n-    }\n-\n-    fn lower_pat_ident(\n-        &mut self,\n-        p: &Pat,\n-        binding_mode: &BindingMode,\n-        ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n-    ) -> hir::PatKind<'hir> {\n-        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n-            // `None` can occur in body-less function signatures\n-            res @ None | res @ Some(Res::Local(_)) => {\n-                let canonical_id = match res {\n-                    Some(Res::Local(id)) => id,\n-                    _ => p.id,\n-                };\n-\n-                hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n-                    self.lower_node_id(canonical_id),\n-                    ident,\n-                    lower_sub(self),\n-                )\n-            }\n-            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                self.arena.alloc(hir::Path {\n-                    span: ident.span,\n-                    res: self.lower_res(res),\n-                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n-                }),\n-            )),\n-        }\n-    }\n-\n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n-    }\n-\n-    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n-    }\n-\n-    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n-    }\n-\n-    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n-    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n-\n-        // We're not in a list context so `..` can be reasonably treated\n-        // as `_` because it should always be valid and roughly matches the\n-        // intent of `..` (notice that the rest of a single slot is that slot).\n-        hir::PatKind::Wild\n-    }\n-\n-    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n-        match *e {\n-            RangeEnd::Included(_) => hir::RangeEnd::Included,\n-            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n-        }\n-    }\n-\n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n         self.with_new_scopes(|this| hir::AnonConst {\n             hir_id: this.lower_node_id(c.id),"}, {"sha": "3a3ffd7560bab89f394e032080124b99756a86dc", "filename": "src/librustc_ast_lowering/pat.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/f75ccdef10148637165eec034d9346cbb82e0119/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75ccdef10148637165eec034d9346cbb82e0119/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=f75ccdef10148637165eec034d9346cbb82e0119", "patch": "@@ -0,0 +1,253 @@\n+use super::{ImplTraitContext, LoweringContext, ParamMode};\n+\n+use rustc::hir;\n+use rustc::hir::def::Res;\n+use rustc_span::{source_map::Spanned, Span};\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        let node = match p.kind {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                node\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+            PatKind::TupleStruct(ref path, ref pats) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n+            }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    qself,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                hir::PatKind::Path(qpath)\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+\n+                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                    hir_id: self.next_id(),\n+                    ident: f.ident,\n+                    pat: self.lower_pat(&f.pat),\n+                    is_shorthand: f.is_shorthand,\n+                    span: f.span,\n+                }));\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref pats) => {\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                hir::PatKind::Tuple(pats, ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n+            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n+                self.lower_expr(e1),\n+                self.lower_expr(e2),\n+                self.lower_range_end(end),\n+            ),\n+            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+            PatKind::Rest => {\n+                // If we reach here the `..` pattern is not semantically allowed.\n+                self.ban_illegal_rest_pat(p.span)\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n+\n+        self.pat_with_node_id_of(p, node)\n+    }\n+\n+    fn lower_pat_tuple(\n+        &mut self,\n+        pats: &[P<Pat>],\n+        ctx: &str,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n+        let mut elems = Vec::with_capacity(pats.len());\n+        let mut rest = None;\n+\n+        let mut iter = pats.iter().enumerate();\n+        for (idx, pat) in iter.by_ref() {\n+            // Interpret the first `..` pattern as a sub-tuple pattern.\n+            // Note that unlike for slice patterns,\n+            // where `xs @ ..` is a legal sub-slice pattern,\n+            // it is not a legal sub-tuple pattern.\n+            if pat.is_rest() {\n+                rest = Some((idx, pat.span));\n+                break;\n+            }\n+            // It was not a sub-tuple pattern so lower it normally.\n+            elems.push(self.lower_pat(pat));\n+        }\n+\n+        for (_, pat) in iter {\n+            // There was a previous sub-tuple pattern; make sure we don't allow more...\n+            if pat.is_rest() {\n+                // ...but there was one again, so error.\n+                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n+            } else {\n+                elems.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n+    }\n+\n+    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n+    /// `hir::PatKind::Slice(before, slice, after)`.\n+    ///\n+    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n+    /// this is interpreted as a sub-slice pattern semantically.\n+    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n+    fn lower_pat_slice(&mut self, pats: &[P<Pat>]) -> hir::PatKind<'hir> {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        let mut iter = pats.iter();\n+        // Lower all the patterns until the first occurence of a sub-slice pattern.\n+        for pat in iter.by_ref() {\n+            match pat.kind {\n+                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_wild_with_node_id_of(pat));\n+                    break;\n+                }\n+                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n+                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n+                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    break;\n+                }\n+                // It was not a subslice pattern so lower it normally.\n+                _ => before.push(self.lower_pat(pat)),\n+            }\n+        }\n+\n+        // Lower all the patterns after the first sub-slice pattern.\n+        for pat in iter {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.kind {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n+                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n+                    after.push(self.pat_wild_with_node_id_of(pat));\n+                    Some(sub.span)\n+                }\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                // Lower the pattern normally.\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n+    ) -> hir::PatKind<'hir> {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ None | res @ Some(Res::Local(_)) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                self.arena.alloc(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    }\n+\n+    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n+    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+        self.diagnostic()\n+            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n+            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n+            .span_label(prev_sp, \"previously used here\")\n+            .emit();\n+    }\n+\n+    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n+        self.diagnostic()\n+            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n+            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n+            .emit();\n+\n+        // We're not in a list context so `..` can be reasonably treated\n+        // as `_` because it should always be valid and roughly matches the\n+        // intent of `..` (notice that the rest of a single slot is that slot).\n+        hir::PatKind::Wild\n+    }\n+\n+    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n+        match *e {\n+            RangeEnd::Included(_) => hir::RangeEnd::Included,\n+            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n+        }\n+    }\n+}"}]}