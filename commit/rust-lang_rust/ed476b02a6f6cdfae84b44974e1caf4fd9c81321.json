{"sha": "ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDc2YjAyYTZmNmNkZmFlODRiNDQ5NzRlMWNhZjRmZDljODEzMjE=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-17T23:18:12Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-17T23:58:20Z"}, "message": "support LTO against libraries built with codegen-units > 1", "tree": {"sha": "ae624069a1fc7805589e914c083e785c9a91dfed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae624069a1fc7805589e914c083e785c9a91dfed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "html_url": "https://github.com/rust-lang/rust/commit/ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad9ed40e7fec03158929ba3a2847870d54498d6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9ed40e7fec03158929ba3a2847870d54498d6d", "html_url": "https://github.com/rust-lang/rust/commit/ad9ed40e7fec03158929ba3a2847870d54498d6d"}], "stats": {"total": 227, "additions": 120, "deletions": 107}, "files": [{"sha": "ddaafab7b383e72d54e419d8df4b7fc58e360956", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "patch": "@@ -659,19 +659,18 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n-            if sess.opts.cg.codegen_units == 1 {\n-                // For LTO purposes, the bytecode of this library is also\n-                // inserted into the archive.  We currently do this only when\n-                // codegen_units == 1, so we don't have to deal with multiple\n-                // bitcode files per crate.\n-                //\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.  If codegen_units > 1, we insert each of the\n+            // bitcode files.\n+            for i in range(0, sess.opts.cg.codegen_units) {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(\"bc\");\n-                let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n+                let bc_deflated_filename = obj_filename.with_extension(\n+                    format!(\"{}.bytecode.deflate\", i).as_slice());\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n@@ -705,8 +704,13 @@ fn link_rlib<'a>(sess: &'a Session,\n \n                 ab.add_file(&bc_deflated_filename).unwrap();\n                 remove(sess, &bc_deflated_filename);\n-                if !sess.opts.cg.save_temps &&\n-                   !sess.opts.output_types.contains(&OutputTypeBitcode) {\n+\n+                // See the bottom of back::write::run_passes for an explanation\n+                // of when we do and don't keep .0.bc files around.\n+                let user_wants_numbered_bitcode =\n+                        sess.opts.output_types.contains(&OutputTypeBitcode) &&\n+                        sess.opts.cg.codegen_units > 1;\n+                if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n                     remove(sess, &bc_filename);\n                 }\n             }"}, {"sha": "cd425b5fec170fafad637280fd6c4ffe5c23faed", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 72, "deletions": 65, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "patch": "@@ -21,6 +21,7 @@ use util::common::time;\n use libc;\n use flate;\n \n+use std::iter;\n use std::mem;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n@@ -60,78 +61,84 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = path.filename_str().unwrap();\n         let file = file.slice(3, file.len() - 5); // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n-        let bc_encoded = time(sess.time_passes(),\n-                              format!(\"read {}.bytecode.deflate\", name).as_slice(),\n-                              (),\n-                              |_| {\n-                                  archive.read(format!(\"{}.bytecode.deflate\",\n-                                                       file).as_slice())\n-                              });\n-        let bc_encoded = match bc_encoded {\n-            Some(data) => data,\n-            None => {\n-                sess.fatal(format!(\"missing compressed bytecode in {} \\\n-                                    (perhaps it was compiled with -C codegen-units > 1)\",\n-                                   path.display()).as_slice());\n-            },\n-        };\n-        let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n-            |_| {\n-                // Read the version\n-                let version = extract_bytecode_format_version(bc_encoded);\n-\n-                if version == 1 {\n-                    // The only version existing so far\n-                    let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                    let compressed_data = bc_encoded.slice(\n-                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n-                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n-\n-                    match flate::inflate_bytes(compressed_data) {\n-                        Some(inflated) => inflated,\n+        for i in iter::count(0u, 1) {\n+            let bc_encoded = time(sess.time_passes(),\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n+                                  (),\n+                                  |_| {\n+                                      archive.read(format!(\"{}.{}.bytecode.deflate\",\n+                                                           file, i).as_slice())\n+                                  });\n+            let bc_encoded = match bc_encoded {\n+                Some(data) => data,\n+                None => {\n+                    if i == 0 {\n+                        // No bitcode was found at all.\n+                        sess.fatal(format!(\"missing compressed bytecode in {}\",\n+                                           path.display()).as_slice());\n+                    }\n+                    // No more bitcode files to read.\n+                    break;\n+                },\n+            };\n+            let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n+                |_| {\n+                    // Read the version\n+                    let version = extract_bytecode_format_version(bc_encoded);\n+\n+                    if version == 1 {\n+                        // The only version existing so far\n+                        let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n+                        let compressed_data = bc_encoded.slice(\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n+\n+                        match flate::inflate_bytes(compressed_data) {\n+                            Some(inflated) => inflated,\n+                            None => {\n+                                sess.fatal(format!(\"failed to decompress bc of `{}`\",\n+                                                   name).as_slice())\n+                            }\n+                        }\n+                    } else {\n+                        sess.fatal(format!(\"Unsupported bytecode format version {}\",\n+                                           version).as_slice())\n+                    }\n+                }\n+            } else {\n+                // the object must be in the old, pre-versioning format, so simply\n+                // inflate everything and let LLVM decide if it can make sense of it\n+                |_| {\n+                    match flate::inflate_bytes(bc_encoded) {\n+                        Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n                                                name).as_slice())\n                         }\n                     }\n-                } else {\n-                    sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                       version).as_slice())\n                 }\n-            }\n-        } else {\n-            // the object must be in the old, pre-versioning format, so simply\n-            // inflate everything and let LLVM decide if it can make sense of it\n-            |_| {\n-                match flate::inflate_bytes(bc_encoded) {\n-                    Some(bc) => bc,\n-                    None => {\n-                        sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                           name).as_slice())\n-                    }\n+            };\n+\n+            let bc_decoded = time(sess.time_passes(),\n+                                  format!(\"decode {}.{}.bc\", file, i).as_slice(),\n+                                  (),\n+                                  bc_extractor);\n+\n+            let ptr = bc_decoded.as_slice().as_ptr();\n+            debug!(\"linking {}, part {}\", name, i);\n+            time(sess.time_passes(),\n+                 format!(\"ll link {}.{}\", name, i).as_slice(),\n+                 (),\n+                 |()| unsafe {\n+                if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                        ptr as *const libc::c_char,\n+                                                        bc_decoded.len() as libc::size_t) {\n+                    write::llvm_err(sess.diagnostic().handler(),\n+                                    format!(\"failed to load bc of `{}`\",\n+                                            name.as_slice()));\n                 }\n-            }\n-        };\n-\n-        let bc_decoded = time(sess.time_passes(),\n-                              format!(\"decode {}.bc\", file).as_slice(),\n-                              (),\n-                              bc_extractor);\n-\n-        let ptr = bc_decoded.as_slice().as_ptr();\n-        debug!(\"linking {}\", name);\n-        time(sess.time_passes(),\n-             format!(\"ll link {}\", name).as_slice(),\n-             (),\n-             |()| unsafe {\n-            if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                    ptr as *const libc::c_char,\n-                                                    bc_decoded.len() as libc::size_t) {\n-                write::llvm_err(sess.diagnostic().handler(),\n-                                format!(\"failed to load bc of `{}`\",\n-                                        name.as_slice()));\n-            }\n-        });\n+            });\n+        }\n     }\n \n     // Internalize everything but the reachable symbols of the current module"}, {"sha": "184f8497abe60015258a1b8a27da1385fffe2581", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "patch": "@@ -540,13 +540,12 @@ pub fn run_passes(sess: &Session,\n         metadata_config.emit_bc = true;\n     }\n \n-    // Emit a bitcode file for the crate if we're emitting an rlib.\n+    // Emit bitcode files for the crate if we're emitting an rlib.\n     // Whenever an rlib is created, the bitcode is inserted into the\n     // archive in order to allow LTO against it.\n     let needs_crate_bitcode =\n             sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-            sess.opts.output_types.contains(&OutputTypeExe) &&\n-            sess.opts.cg.codegen_units == 1;\n+            sess.opts.output_types.contains(&OutputTypeExe);\n     if needs_crate_bitcode {\n         modules_config.emit_bc = true;\n     }\n@@ -602,19 +601,8 @@ pub fn run_passes(sess: &Session,\n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n         run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n-\n-        if needs_crate_bitcode {\n-            // The only bitcode file produced (aside from metadata) was\n-            // \"crate.0.bc\".  Rename to \"crate.bc\" since that's what\n-            // `link_rlib` expects to find.\n-            fs::copy(&crate_output.with_extension(\"0.bc\"),\n-                     &crate_output.temp_path(OutputTypeBitcode)).unwrap();\n-        }\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n-\n-        assert!(!needs_crate_bitcode,\n-               \"can't produce a crate bitcode file from multiple compilation units\");\n     }\n \n     // All codegen is finished.\n@@ -624,14 +612,14 @@ pub fn run_passes(sess: &Session,\n \n     // Produce final compile outputs.\n \n-    let copy_if_one_unit = |ext: &str, output_type: OutputType| {\n+    let copy_if_one_unit = |ext: &str, output_type: OutputType, keep_numbered: bool| {\n         // Three cases:\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n             fs::copy(&crate_output.with_extension(ext),\n                      &crate_output.path(output_type)).unwrap();\n-            if !sess.opts.cg.save_temps {\n+            if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.0.x`.\n                 remove(sess, &crate_output.with_extension(ext));\n             }\n@@ -716,17 +704,18 @@ pub fn run_passes(sess: &Session,\n     // Flag to indicate whether the user explicitly requested bitcode.\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n-    // FIXME: Since we don't support LTO anyway, maybe we can avoid\n-    // producing the temporary .0.bc's in the first place?\n-    let mut save_bitcode = false;\n+    let mut user_wants_bitcode = false;\n     for output_type in output_types.iter() {\n         match *output_type {\n             OutputTypeBitcode => {\n-                save_bitcode = true;\n-                copy_if_one_unit(\"0.bc\", OutputTypeBitcode);\n+                user_wants_bitcode = true;\n+                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // check to figure out if we should delete .0.bc files, or keep\n+                // them for making an rlib.\n+                copy_if_one_unit(\"0.bc\", OutputTypeBitcode, true);\n             },\n-            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly); },\n-            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly); },\n+            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly, false); },\n+            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly, false); },\n             OutputTypeObject => { link_obj(&crate_output.path(OutputTypeObject)); },\n             OutputTypeExe => {\n                 // If OutputTypeObject is already in the list, then\n@@ -739,7 +728,7 @@ pub fn run_passes(sess: &Session,\n             },\n         }\n     }\n-    let save_bitcode = save_bitcode;\n+    let user_wants_bitcode = user_wants_bitcode;\n \n     // Clean up unwanted temporary files.\n \n@@ -755,22 +744,36 @@ pub fn run_passes(sess: &Session,\n \n     if !sess.opts.cg.save_temps {\n         // Remove the temporary .0.o objects.  If the user didn't\n-        // explicitly request bitcode (with --emit=bc), we must remove\n-        // .0.bc as well.  (We don't touch the crate.bc that may have been\n-        // produced earlier.)\n+        // explicitly request bitcode (with --emit=bc), and the bitcode is not\n+        // needed for building an rlib, then we must remove .0.bc as well.\n+\n+        // Specific rules for keeping .0.bc:\n+        //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n+        //    it.\n+        //  - If the user requested bitcode (`user_wants_bitcode`), and\n+        //    codegen_units > 1, then keep it.\n+        //  - If the user requested bitcode but codegen_units == 1, then we\n+        //    can toss .0.bc because we copied it to .bc earlier.\n+        //  - If we're not building an rlib and the user didn't request\n+        //    bitcode, then delete .0.bc.\n+        // If you change how this works, also update back::link::link_rlib,\n+        // where .0.bc files are (maybe) deleted after making an rlib.\n+        let keep_numbered_bitcode = needs_crate_bitcode ||\n+                (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n+\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n                 remove(sess, &crate_output.with_extension(ext.as_slice()));\n             }\n \n-            if modules_config.emit_bc && !save_bitcode {\n+            if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n                 remove(sess, &crate_output.with_extension(ext.as_slice()));\n             }\n         }\n \n-        if metadata_config.emit_bc && !save_bitcode {\n+        if metadata_config.emit_bc && !user_wants_bitcode {\n             remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n         }\n     }"}, {"sha": "51fd83a54ccb1e48553c4f1ca693a6b6f3c982c9", "filename": "src/test/run-pass/sepcomp-lib-lto.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed476b02a6f6cdfae84b44974e1caf4fd9c81321/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs?ref=ed476b02a6f6cdfae84b44974e1caf4fd9c81321", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Make sure we give a sane error message when the user requests LTO with a\n-// library built with -C codegen-units > 1.\n+// Check that we can use `-Z lto` when linking against libraries that were\n+// separately compiled.\n \n // aux-build:sepcomp_lib.rs\n // compile-flags: -Z lto\n-// error-pattern:missing compressed bytecode\n // no-prefer-dynamic\n \n extern crate sepcomp_lib;", "previous_filename": "src/test/compile-fail/sepcomp-lib-lto.rs"}]}