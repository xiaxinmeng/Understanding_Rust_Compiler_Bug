{"sha": "22e8d5f80e58574a13f0623bef14015f424e8a7a", "node_id": "C_kwDOAAsO6NoAKDIyZThkNWY4MGU1ODU3NGExM2YwNjIzYmVmMTQwMTVmNDI0ZThhN2E", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-04T16:23:50Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-06-03T17:01:53Z"}, "message": "Inline many methods of Encoder\n\nThey aren't overridden anyway", "tree": {"sha": "f87799b6cc3b7ed111682f6e42edd587ee1fa87a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f87799b6cc3b7ed111682f6e42edd587ee1fa87a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e8d5f80e58574a13f0623bef14015f424e8a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e8d5f80e58574a13f0623bef14015f424e8a7a", "html_url": "https://github.com/rust-lang/rust/commit/22e8d5f80e58574a13f0623bef14015f424e8a7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e8d5f80e58574a13f0623bef14015f424e8a7a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cd29225a5484d003f5acbeb5c5cc109bb15442f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd29225a5484d003f5acbeb5c5cc109bb15442f", "html_url": "https://github.com/rust-lang/rust/commit/5cd29225a5484d003f5acbeb5c5cc109bb15442f"}], "stats": {"total": 644, "additions": 255, "deletions": 389}, "files": [{"sha": "e99fa6c113b0d260a996ad58a42fc67cd82340a4", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -146,10 +146,9 @@ fn encodable_body(\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encoder::emit_struct_field(\n+                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                                #bind_ident,\n                                 __encoder,\n-                                |__encoder|\n-                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)\n@@ -161,9 +160,7 @@ fn encodable_body(\n                     .collect::<TokenStream>()\n             });\n             quote! {\n-                ::rustc_serialize::Encoder::emit_struct(__encoder, |__encoder| {\n-                    ::std::result::Result::Ok(match *self { #encode_inner })\n-                })\n+                ::std::result::Result::Ok(match *self { #encode_inner })\n             }\n         }\n         _ => {\n@@ -175,10 +172,9 @@ fn encodable_body(\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n+                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                                #bind_ident,\n                                 __encoder,\n-                                |__encoder|\n-                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)\n@@ -208,11 +204,9 @@ fn encodable_body(\n                 result\n             });\n             quote! {\n-                ::rustc_serialize::Encoder::emit_enum(__encoder, |__encoder| {\n-                    match *self {\n-                        #encode_inner\n-                    }\n-                })\n+                match *self {\n+                    #encode_inner\n+                }\n             }\n         }\n     };"}, {"sha": "c4541bbcac921e9ec34083e6fc1355b9e6c4ca13", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -25,12 +25,11 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -43,12 +42,11 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -65,13 +63,12 @@ where\n     V: Encodable<S>,\n {\n     fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(|e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -97,12 +94,11 @@ where\n     T: Encodable<S> + PartialEq + Ord,\n {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -127,13 +123,12 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(|e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -162,12 +157,11 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -194,13 +188,12 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(|e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -229,12 +222,11 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n "}, {"sha": "8c12d250f0fb331023dd564fb67dae5b9a60b96f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 16, "deletions": 127, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -35,15 +35,7 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n     fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>;\n \n-    // Compound types:\n-    #[inline]\n-    fn emit_enum<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n+    // Convenience for the derive macro:\n     fn emit_enum_variant<F>(&mut self, v_id: usize, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n@@ -62,106 +54,6 @@ pub trait Encoder {\n     fn emit_fieldless_enum_variant<const ID: usize>(&mut self) -> Result<(), Self::Error> {\n         self.emit_usize(ID)\n     }\n-\n-    #[inline]\n-    fn emit_enum_variant_arg<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_struct<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_struct_field<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_tuple<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_tuple_arg<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    // Specialized types:\n-    fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum(f)\n-    }\n-\n-    #[inline]\n-    fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n-        self.emit_enum_variant(0, |_| Ok(()))\n-    }\n-\n-    fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant(1, f)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_seq_elt<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_map_elt_key<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n }\n \n // Note: all the methods in this trait are infallible, which may be surprising.\n@@ -353,12 +245,11 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n     default fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for e in self.iter() {\n-                s.emit_seq_elt(|s| e.encode(s))?\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?\n+        }\n+        Ok(())\n     }\n }\n \n@@ -441,10 +332,10 @@ impl<'a, D: Decoder> Decodable<D> for Cow<'a, str> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_option(|s| match *self {\n-            None => s.emit_option_none(),\n-            Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n-        })\n+        match *self {\n+            None => s.emit_enum_variant(0, |_| Ok(())),\n+            Some(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n+        }\n     }\n }\n \n@@ -460,10 +351,10 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n \n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_enum(|s| match *self {\n-            Ok(ref v) => s.emit_enum_variant(0, |s| s.emit_enum_variant_arg(|s| v.encode(s))),\n-            Err(ref v) => s.emit_enum_variant(1, |s| s.emit_enum_variant_arg(|s| v.encode(s))),\n-        })\n+        match *self {\n+            Ok(ref v) => s.emit_enum_variant(0, |s| v.encode(s)),\n+            Err(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n+        }\n     }\n }\n \n@@ -493,10 +384,8 @@ macro_rules! tuple {\n             #[allow(non_snake_case)]\n             fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n-                s.emit_tuple(|s| {\n-                    $(s.emit_tuple_arg(|s| $name.encode(s))?;)+\n-                    Ok(())\n-                })\n+                $($name.encode(s)?;)+\n+                Ok(())\n             }\n         }\n         peel! { $($name,)+ }"}, {"sha": "2bd0880a7c4254fa036f728a39260aae8049e718", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -307,11 +307,8 @@ impl DefId {\n \n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(|s| {\n-            s.emit_struct_field(|s| self.krate.encode(s))?;\n-\n-            s.emit_struct_field(|s| self.index.encode(s))\n-        })\n+        self.krate.encode(s)?;\n+        self.index.encode(s)\n     }\n }\n "}, {"sha": "01fe9aea89bc2084ff274a7d359c13bd042fa586", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -196,10 +196,10 @@ impl Hash for RealFileName {\n // an added assert statement\n impl<S: Encoder> Encodable<S> for RealFileName {\n     fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n-        encoder.emit_enum(|encoder| match *self {\n+        match *self {\n             RealFileName::LocalPath(ref local_path) => encoder.emit_enum_variant(0, |encoder| {\n                 Ok({\n-                    encoder.emit_enum_variant_arg(|encoder| local_path.encode(encoder))?;\n+                    local_path.encode(encoder)?;\n                 })\n             }),\n \n@@ -208,11 +208,11 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n                     // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n-                    encoder.emit_enum_variant_arg(|encoder| local_path.encode(encoder))?;\n-                    encoder.emit_enum_variant_arg(|encoder| virtual_name.encode(encoder))?;\n+                    local_path.encode(encoder)?;\n+                    virtual_name.encode(encoder)?;\n                     Ok(())\n                 }),\n-        })\n+        }\n     }\n }\n \n@@ -949,10 +949,8 @@ impl Default for Span {\n impl<E: Encoder> Encodable<E> for Span {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n-        s.emit_struct(|s| {\n-            s.emit_struct_field(|s| span.lo.encode(s))?;\n-            s.emit_struct_field(|s| span.hi.encode(s))\n-        })\n+        span.lo.encode(s)?;\n+        span.hi.encode(s)\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n@@ -1301,79 +1299,77 @@ pub struct SourceFile {\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(|s| {\n-            s.emit_struct_field(|s| self.name.encode(s))?;\n-            s.emit_struct_field(|s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(|s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(|s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(|s| {\n-                // We are always in `Lines` form by the time we reach here.\n-                assert!(self.lines.borrow().is_lines());\n-                self.lines(|lines| {\n-                    // Store the length.\n-                    s.emit_u32(lines.len() as u32)?;\n-\n-                    // Compute and store the difference list.\n-                    if lines.len() != 0 {\n-                        let max_line_length = if lines.len() == 1 {\n-                            0\n-                        } else {\n-                            lines\n-                                .array_windows()\n-                                .map(|&[fst, snd]| snd - fst)\n-                                .map(|bp| bp.to_usize())\n-                                .max()\n-                                .unwrap()\n-                        };\n-\n-                        let bytes_per_diff: usize = match max_line_length {\n-                            0..=0xFF => 1,\n-                            0x100..=0xFFFF => 2,\n-                            _ => 4,\n-                        };\n-\n-                        // Encode the number of bytes used per diff.\n-                        s.emit_u8(bytes_per_diff as u8)?;\n-\n-                        // Encode the first element.\n-                        lines[0].encode(s)?;\n-\n-                        // Encode the difference list.\n-                        let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n-                        let num_diffs = lines.len() - 1;\n-                        let mut raw_diffs;\n-                        match bytes_per_diff {\n-                            1 => {\n-                                raw_diffs = Vec::with_capacity(num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.push(diff.0 as u8);\n-                                }\n-                            }\n-                            2 => {\n-                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.extend_from_slice(&(diff.0 as u16).to_le_bytes());\n-                                }\n-                            }\n-                            4 => {\n-                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.extend_from_slice(&(diff.0 as u32).to_le_bytes());\n-                                }\n-                            }\n-                            _ => unreachable!(),\n+        self.name.encode(s)?;\n+        self.src_hash.encode(s)?;\n+        self.start_pos.encode(s)?;\n+        self.end_pos.encode(s)?;\n+\n+        // We are always in `Lines` form by the time we reach here.\n+        assert!(self.lines.borrow().is_lines());\n+        self.lines(|lines| {\n+            // Store the length.\n+            s.emit_u32(lines.len() as u32)?;\n+\n+            // Compute and store the difference list.\n+            if lines.len() != 0 {\n+                let max_line_length = if lines.len() == 1 {\n+                    0\n+                } else {\n+                    lines\n+                        .array_windows()\n+                        .map(|&[fst, snd]| snd - fst)\n+                        .map(|bp| bp.to_usize())\n+                        .max()\n+                        .unwrap()\n+                };\n+\n+                let bytes_per_diff: usize = match max_line_length {\n+                    0..=0xFF => 1,\n+                    0x100..=0xFFFF => 2,\n+                    _ => 4,\n+                };\n+\n+                // Encode the number of bytes used per diff.\n+                s.emit_u8(bytes_per_diff as u8)?;\n+\n+                // Encode the first element.\n+                lines[0].encode(s)?;\n+\n+                // Encode the difference list.\n+                let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n+                let num_diffs = lines.len() - 1;\n+                let mut raw_diffs;\n+                match bytes_per_diff {\n+                    1 => {\n+                        raw_diffs = Vec::with_capacity(num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.push(diff.0 as u8);\n                         }\n-                        s.emit_raw_bytes(&raw_diffs)?;\n                     }\n-                    Ok(())\n-                })\n-            })?;\n-            s.emit_struct_field(|s| self.multibyte_chars.encode(s))?;\n-            s.emit_struct_field(|s| self.non_narrow_chars.encode(s))?;\n-            s.emit_struct_field(|s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(|s| self.normalized_pos.encode(s))?;\n-            s.emit_struct_field(|s| self.cnum.encode(s))\n-        })\n+                    2 => {\n+                        raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.extend_from_slice(&(diff.0 as u16).to_le_bytes());\n+                        }\n+                    }\n+                    4 => {\n+                        raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.extend_from_slice(&(diff.0 as u32).to_le_bytes());\n+                        }\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                s.emit_raw_bytes(&raw_diffs)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        self.multibyte_chars.encode(s)?;\n+        self.non_narrow_chars.encode(s)?;\n+        self.name_hash.encode(s)?;\n+        self.normalized_pos.encode(s)?;\n+        self.cnum.encode(s)\n     }\n }\n "}, {"sha": "22b5b475b2cacf9ee53e2906dceaef6f886edd9e", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e8d5f80e58574a13f0623bef14015f424e8a7a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=22e8d5f80e58574a13f0623bef14015f424e8a7a", "patch": "@@ -716,118 +716,116 @@ where\n     I::AllocId: Encodable<E>,\n {\n     fn encode(&self, e: &mut E) -> Result<(), <E as rustc_serialize::Encoder>::Error> {\n-        rustc_serialize::Encoder::emit_enum(e, |e| {\n-            let disc = discriminant(self);\n-            match self {\n-                Bool => e.emit_enum_variant(disc, |_| Ok(())),\n-                Char => e.emit_enum_variant(disc, |_| Ok(())),\n-                Int(i) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| i.encode(e))?;\n-                    Ok(())\n-                }),\n-                Uint(u) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| u.encode(e))?;\n-                    Ok(())\n-                }),\n-                Float(f) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| f.encode(e))?;\n-                    Ok(())\n-                }),\n-                Adt(adt, substs) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| adt.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Foreign(def_id) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n-                    Ok(())\n-                }),\n-                Str => e.emit_enum_variant(disc, |_| Ok(())),\n-                Array(t, c) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| c.encode(e))?;\n-                    Ok(())\n-                }),\n-                Slice(t) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n-                    Ok(())\n-                }),\n-                RawPtr(tam) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| tam.encode(e))?;\n-                    Ok(())\n-                }),\n-                Ref(r, t, m) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| r.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| m.encode(e))?;\n-                    Ok(())\n-                }),\n-                FnDef(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                FnPtr(polyfnsig) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| polyfnsig.encode(e))?;\n-                    Ok(())\n-                }),\n-                Dynamic(l, r) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| l.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| r.encode(e))?;\n-                    Ok(())\n-                }),\n-                Closure(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Generator(def_id, substs, m) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| m.encode(e))?;\n-                    Ok(())\n-                }),\n-                GeneratorWitness(b) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| b.encode(e))?;\n-                    Ok(())\n-                }),\n-                Never => e.emit_enum_variant(disc, |_| Ok(())),\n-                Tuple(substs) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Projection(p) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Param(p) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Bound(d, b) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| d.encode(e))?;\n-                    e.emit_enum_variant_arg(|e| b.encode(e))?;\n-                    Ok(())\n-                }),\n-                Placeholder(p) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Infer(i) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| i.encode(e))?;\n-                    Ok(())\n-                }),\n-                Error(d) => e.emit_enum_variant(disc, |e| {\n-                    e.emit_enum_variant_arg(|e| d.encode(e))?;\n-                    Ok(())\n-                }),\n-            }\n-        })\n+        let disc = discriminant(self);\n+        match self {\n+            Bool => e.emit_enum_variant(disc, |_| Ok(())),\n+            Char => e.emit_enum_variant(disc, |_| Ok(())),\n+            Int(i) => e.emit_enum_variant(disc, |e| {\n+                i.encode(e)?;\n+                Ok(())\n+            }),\n+            Uint(u) => e.emit_enum_variant(disc, |e| {\n+                u.encode(e)?;\n+                Ok(())\n+            }),\n+            Float(f) => e.emit_enum_variant(disc, |e| {\n+                f.encode(e)?;\n+                Ok(())\n+            }),\n+            Adt(adt, substs) => e.emit_enum_variant(disc, |e| {\n+                adt.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Foreign(def_id) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                Ok(())\n+            }),\n+            Str => e.emit_enum_variant(disc, |_| Ok(())),\n+            Array(t, c) => e.emit_enum_variant(disc, |e| {\n+                t.encode(e)?;\n+                c.encode(e)?;\n+                Ok(())\n+            }),\n+            Slice(t) => e.emit_enum_variant(disc, |e| {\n+                t.encode(e)?;\n+                Ok(())\n+            }),\n+            RawPtr(tam) => e.emit_enum_variant(disc, |e| {\n+                tam.encode(e)?;\n+                Ok(())\n+            }),\n+            Ref(r, t, m) => e.emit_enum_variant(disc, |e| {\n+                r.encode(e)?;\n+                t.encode(e)?;\n+                m.encode(e)?;\n+                Ok(())\n+            }),\n+            FnDef(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            FnPtr(polyfnsig) => e.emit_enum_variant(disc, |e| {\n+                polyfnsig.encode(e)?;\n+                Ok(())\n+            }),\n+            Dynamic(l, r) => e.emit_enum_variant(disc, |e| {\n+                l.encode(e)?;\n+                r.encode(e)?;\n+                Ok(())\n+            }),\n+            Closure(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Generator(def_id, substs, m) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                m.encode(e)?;\n+                Ok(())\n+            }),\n+            GeneratorWitness(b) => e.emit_enum_variant(disc, |e| {\n+                b.encode(e)?;\n+                Ok(())\n+            }),\n+            Never => e.emit_enum_variant(disc, |_| Ok(())),\n+            Tuple(substs) => e.emit_enum_variant(disc, |e| {\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Projection(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Param(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Bound(d, b) => e.emit_enum_variant(disc, |e| {\n+                d.encode(e)?;\n+                b.encode(e)?;\n+                Ok(())\n+            }),\n+            Placeholder(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Infer(i) => e.emit_enum_variant(disc, |e| {\n+                i.encode(e)?;\n+                Ok(())\n+            }),\n+            Error(d) => e.emit_enum_variant(disc, |e| {\n+                d.encode(e)?;\n+                Ok(())\n+            }),\n+        }\n     }\n }\n "}]}