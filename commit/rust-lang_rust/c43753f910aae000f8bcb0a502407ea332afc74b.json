{"sha": "c43753f910aae000f8bcb0a502407ea332afc74b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0Mzc1M2Y5MTBhYWUwMDBmOGJjYjBhNTAyNDA3ZWEzMzJhZmM3NGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-26T16:57:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-26T16:57:54Z"}, "message": "Auto merge of #63015 - Centril:rollup-ydhpcas, r=Centril\n\nRollup of 22 pull requests\n\nSuccessful merges:\n\n - #62084 (allow clippy::unreadable_literal in unicode tables)\n - #62120 (Add missing type links in documentation)\n - #62310 (Add missing doc links in boxed module)\n - #62421 (Introduce `as_deref` to Option)\n - #62583 (Implement Unpin for all raw pointers)\n - #62692 (rustc: precompute the largest Niche and store it in LayoutDetails.)\n - #62801 (Remove support for -Zlower-128bit-ops)\n - #62828 (Remove vector fadd/fmul reduction workarounds)\n - #62862 (code cleanup)\n - #62904 (Disable d32 on armv6 hf targets)\n - #62907 (Initialize the MSP430 AsmParser)\n - #62956 (Implement slow-path for FirstSets::first)\n - #62963 (Allow lexer to recover from some homoglyphs)\n - #62964 (clarify and unify some type test names)\n - #62970 (ci: gate toolstate repo pushes on the TOOLSTATE_PUBLISH envvar)\n - #62980 (std: Add more accessors for `Metadata` on Windows)\n - #62983 (Remove needless indirection through Rc)\n - #62985 (librustc_errors: Support ui-testing flag in annotate-snippet emitter)\n - #63002 (error_index_generator should output stdout/stderr when it panics.)\n - #63004 (Add test for issue-54062)\n - #63007 (ci: debug network failures while downloading awscli from PyPI)\n - #63009 (Remove redundant `mut` from variable declaration.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ad563761b27efd2cbab0ade95c5139aaccb93494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad563761b27efd2cbab0ade95c5139aaccb93494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c43753f910aae000f8bcb0a502407ea332afc74b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c43753f910aae000f8bcb0a502407ea332afc74b", "html_url": "https://github.com/rust-lang/rust/commit/c43753f910aae000f8bcb0a502407ea332afc74b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c43753f910aae000f8bcb0a502407ea332afc74b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a563362865e6051d4c350544131228e8eff5138", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a563362865e6051d4c350544131228e8eff5138", "html_url": "https://github.com/rust-lang/rust/commit/1a563362865e6051d4c350544131228e8eff5138"}, {"sha": "232d27c306d76d2f973c88b0e0d1883aac8717f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/232d27c306d76d2f973c88b0e0d1883aac8717f4", "html_url": "https://github.com/rust-lang/rust/commit/232d27c306d76d2f973c88b0e0d1883aac8717f4"}], "stats": {"total": 3429, "additions": 1106, "deletions": 2323}, "files": [{"sha": "015fd8348855038e5c3aa79c3cd7a25c56414a56", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -140,9 +140,35 @@ steps:\n # images, etc.\n - bash: |\n     set -e\n+    # Temporary code to debug #62967.\n+    debug_failed_connections() {\n+        echo \"trying to ping pypi.org\"\n+        ping pypi.org -c10 || true\n+        echo \"trying to ping google.com\"\n+        ping google.com -c10 || true\n+        echo \"trying to ping 8.8.8.8\"\n+        ping 8.8.8.8 -c10 || true\n+        echo \"trying to download pypi.org\"\n+        curl https://pypi.org || true\n+        echo \"trying to download from our S3 bucket\"\n+        curl https://rust-lang-ci2.s3.amazonaws.com || true\n+        echo \"trying to dig pypi.org\"\n+        dig pypi.org || true\n+        echo \"trying to dig files.pythonhosted.org\"\n+        dig files.pythonhosted.org || true\n+        echo \"trying to connect to pypi.org with openssl\"\n+        echo | openssl s_client -connect pypi.org:443 || true\n+        echo \"trying to connect to files.pythonhosted.org with openssl\"\n+        echo | openssl s_client -connect files.pythonhosted.org:443 || true\n+    }\n+    debug_failed_connections_and_fail() {\n+        debug_failed_connections\n+        return 1\n+    }\n     source src/ci/shared.sh\n     sudo apt-get install -y python3-setuptools\n-    retry pip3 install -r src/ci/awscli-requirements.txt --upgrade --user\n+    debug_failed_connections\n+    retry pip3 install -r src/ci/awscli-requirements.txt --upgrade --user || debug_failed_connections_and_fail\n     echo \"##vso[task.prependpath]$HOME/.local/bin\"\n   displayName: Install awscli (Linux)\n   condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Linux'))"}, {"sha": "6384560b672b1a97b7afc29fde3a70a680e7f6bb", "filename": "Cargo.lock", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -17,7 +17,7 @@ dependencies = [\n name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -44,6 +44,11 @@ dependencies = [\n  \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -110,7 +115,7 @@ dependencies = [\n  \"autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"backtrace-sys 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n@@ -122,7 +127,7 @@ version = \"0.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -331,7 +336,7 @@ name = \"cfg-if\"\n version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -460,7 +465,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -791,7 +796,7 @@ name = \"dlmalloc\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -956,7 +961,7 @@ name = \"fortanix-sgx-abi\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -1133,7 +1138,7 @@ name = \"hashbrown\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-alloc 1.0.0\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -1951,7 +1956,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1962,7 +1967,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unwind 0.0.0\",\n@@ -2133,7 +2138,7 @@ name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -2670,7 +2675,7 @@ name = \"rustc-demangle\"\n version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -2762,7 +2767,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -2891,7 +2896,7 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"annotate-snippets 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2984,7 +2989,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -3047,7 +3052,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -3165,7 +3170,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -3472,7 +3477,7 @@ dependencies = [\n  \"backtrace 0.3.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4099,7 +4104,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -4280,6 +4285,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6f484ae0c99fec2e858eb6134949117399f222608d84cadb3f58c1f97c2364c\"\n \"checksum ammonia 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"384d704f242a0a9faf793fff775a0be6ab9aa27edabffa097331d73779142520\"\n \"checksum annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8bcdcd5b291ce85a78f2b9d082a8de9676c12b1840d386d67bc5eea6f9d2b4e\"\n+\"checksum annotate-snippets 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7021ce4924a3f25f802b2cccd1af585e39ea1a363a1aa2e72afe54b67a3a7a7\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum arc-swap 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1025aeae2b664ca0ea726a89d574fe8f4e77dd712d443236ad1de00379450cf6\"\n \"checksum argon2rs 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f67b0b6a86dae6e67ff4ca2b6201396074996379fba2b92ff649126f37cb392\"\n@@ -4313,7 +4319,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n \"checksum commoncrypto-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-\"checksum compiler_builtins 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad9b4731b9e701aefe9e6bd1e9173f30526661508f9aaadaa5caec25ddf95585\"\n+\"checksum compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef1c086a06d6f52f9c0d50cacdc021bfb6034ddeec9fb7e62f099f13f65472f4\"\n \"checksum compiletest_rs 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f40ecc9332b68270998995c00f8051ee856121764a0d3230e64c9efd059d27b6\"\n \"checksum constant_time_eq 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n \"checksum core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e2640d6d0bf22e82bed1b73c6aef8d5dd31e5abe6666c57e6d45e2649f4f887\""}, {"sha": "7d945e20622f8f639ce2ea37d10656163a255cbf", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1493,7 +1493,7 @@ impl Step for ErrorIndex {\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n-        builder.run(&mut tool);\n+        builder.run_quiet(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }"}, {"sha": "2191d5d6e4680ce443cdae19d4bdbbccf3d1e1d3", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -112,7 +112,7 @@ $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n }\n \n if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n-    if [ -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n         . \"$(dirname $0)/repo.sh\"\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n         echo \"($OS CI update)\" > \"$MESSAGE_FILE\""}, {"sha": "488fda0b24738f8ff87af4e08d2eaf4815348e82", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,6 +1,6 @@\n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n //! drop their contents when they go out of scope.\n //!\n@@ -48,7 +48,7 @@\n //!\n //! It wouldn't work. This is because the size of a `List` depends on how many\n //! elements are in the list, and so we don't know how much memory to allocate\n-//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n+//! for a `Cons`. By introducing a [`Box<T>`], which has a defined size, we know how\n //! big `Cons` needs to be.\n //!\n //! # Memory layout\n@@ -59,15 +59,19 @@\n //! [`Layout`] used with the allocator is correct for the type. More precisely,\n //! a `value: *mut T` that has been allocated with the [`Global`] allocator\n //! with `Layout::for_value(&*value)` may be converted into a box using\n-//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n-//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n-//! [`Global`] allocator with `Layout::for_value(&*value)`.\n+//! [`Box::<T>::from_raw(value)`]. Conversely, the memory backing a `value: *mut\n+//! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n+//! [`Global`] allocator with [`Layout::for_value(&*value)`].\n //!\n //!\n //! [dereferencing]: ../../std/ops/trait.Deref.html\n //! [`Box`]: struct.Box.html\n+//! [`Box<T>`]: struct.Box.html\n+//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n+//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n //! [`Global`]: ../alloc/struct.Global.html\n //! [`Layout`]: ../alloc/struct.Layout.html\n+//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "f9613556a1ebc1bd593e68a8ec5616db4184c532", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -319,7 +319,7 @@ impl Ordering {\n     /// This method can be used to reverse a comparison:\n     ///\n     /// ```\n-    /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n+    /// let data: &mut [_] = &mut [2, 10, 5, 8];\n     ///\n     /// // sort the array from largest to smallest.\n     /// data.sort_by(|a, b| a.cmp(b).reverse());"}, {"sha": "79a188dbac99d891609cefed14f3edd81d90b96f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -655,6 +655,12 @@ impl<'a, T: ?Sized + 'a> Unpin for &'a T {}\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<'a, T: ?Sized + 'a> Unpin for &'a mut T {}\n \n+#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\n+impl<T: ?Sized> Unpin for *const T {}\n+\n+#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\n+impl<T: ?Sized> Unpin for *mut T {}\n+\n /// Implementations of `Copy` for primitive types.\n ///\n /// Implementations that cannot be described in Rust"}, {"sha": "abc8883d3985f2ab447721e32e92b2fb1dc8e094", "filename": "src/libcore/option.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -136,7 +136,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n-use crate::{convert, fmt, hint, mem, ops::{self, Deref}};\n+use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n@@ -1104,17 +1104,28 @@ impl<T: Default> Option<T> {\n \n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref> Option<T> {\n-    /// Converts from `&Option<T>` to `Option<&T::Target>`.\n+    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n     ///\n     /// Leaves the original Option in-place, creating a new one with a reference\n     /// to the original one, additionally coercing the contents via [`Deref`].\n     ///\n     /// [`Deref`]: ../../std/ops/trait.Deref.html\n-    pub fn deref(&self) -> Option<&T::Target> {\n+    pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n+#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+impl<T: DerefMut> Option<T> {\n+    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n+    ///\n+    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n+    /// the inner type's `Deref::Target` type.\n+    pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n+        self.as_mut().map(|t| t.deref_mut())\n+    }\n+}\n+\n impl<T, E> Option<Result<T, E>> {\n     /// Transposes an `Option` of a [`Result`] into a [`Result`] of an `Option`.\n     ///"}, {"sha": "2feaab7a09c9362d48d273244b7f69901cde7e92", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 81, "deletions": 63, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -11,13 +11,13 @@\n //! until it gets dropped. We say that the pointee is \"pinned\".\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as `Box<T>` and `&mut T` allow replacing and\n-//! moving the values they contain: you can move out of a `Box<T>`, or you can use [`mem::swap`].\n-//! [`Pin<P>`] wraps a pointer type `P`, so `Pin<Box<T>>` functions much like a regular `Box<T>`:\n-//! when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated.\n-//! Similarly, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does not let clients\n-//! actually obtain a `Box<T>` or `&mut T` to pinned data, which implies that you cannot use\n-//! operations such as [`mem::swap`]:\n+//! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n+//! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n+//! [`Pin<P>`] wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular\n+//! [`Box<T>`]: when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does\n+//! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n+//! cannot use operations such as [`mem::swap`]:\n //!\n //! ```\n //! use std::pin::Pin;\n@@ -30,15 +30,15 @@\n //! ```\n //!\n //! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin<P>`\n-//! prevents certain *values* (pointed to by pointers wrapped in `Pin<P>`) from being\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, [`Pin<P>`]\n+//! prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being\n //! moved by making it impossible to call methods that require `&mut T` on them\n //! (like [`mem::swap`]).\n //!\n //! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n-//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a `Pin<Box<T>>` is\n-//! an owned pointer to a pinned `T`, and a `Pin<Rc<T>>` is a reference-counted\n+//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n+//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is\n+//! an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted\n //! pointer to a pinned `T`.\n //! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n@@ -48,15 +48,15 @@\n //!\n //! Many types are always freely movable, even when pinned, because they do not\n //! rely on having a stable address. This includes all the basic types (like\n-//! `bool`, `i32`, and references) as well as types consisting solely of these\n+//! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n //! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n-//! `Pin<Box<T>>` and `Box<T>` function identically, as do `Pin<&mut T>` and\n+//! [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and\n //! `&mut T`.\n //!\n-//! Note that pinning and `Unpin` only affect the pointed-to type `P::Target`, not the pointer\n-//! type `P` itself that got wrapped in `Pin<P>`. For example, whether or not `Box<T>` is\n-//! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n+//! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n+//! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n+//! [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n //! # Example: self-referential struct\n@@ -122,15 +122,15 @@\n //!\n //! To make this work, every element has pointers to its predecessor and successor in\n //! the list. Elements can only be added when they are pinned, because moving the elements\n-//! around would invalidate the pointers. Moreover, the `Drop` implementation of a linked\n+//! around would invalidate the pointers. Moreover, the [`Drop`] implementation of a linked\n //! list element will patch the pointers of its predecessor and successor to remove itself\n //! from the list.\n //!\n-//! Crucially, we have to be able to rely on `drop` being called. If an element\n-//! could be deallocated or otherwise invalidated without calling `drop`, the pointers into it\n+//! Crucially, we have to be able to rely on [`drop`] being called. If an element\n+//! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n //! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n-//! Therefore, pinning also comes with a `drop`-related guarantee.\n+//! Therefore, pinning also comes with a [`drop`]-related guarantee.\n //!\n //! # `Drop` guarantee\n //!\n@@ -139,7 +139,7 @@\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n //! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n-//! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n+//! when [`drop`] is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n //! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n //! calling the destructor first.\n@@ -148,26 +148,27 @@\n //! section needs to function correctly.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n-//! completely okay not ever to call `drop` on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a `Pin<Box<T>>`). In the example of the doubly-linked\n+//! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n+//! call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`). In the example of the doubly-linked\n //! list, that element would just stay in the list. However you may not free or reuse the storage\n-//! *without calling `drop`*.\n+//! *without calling [`drop`]*.\n //!\n //! # `Drop` implementation\n //!\n //! If your type uses pinning (such as the two examples above), you have to be careful\n-//! when implementing `Drop`. The `drop` function takes `&mut self`, but this\n+//! when implementing [`Drop`]. The [`drop`] function takes `&mut self`, but this\n //! is called *even if your type was previously pinned*! It is as if the\n-//! compiler automatically called `get_unchecked_mut`.\n+//! compiler automatically called [`Pin::get_unchecked_mut`].\n //!\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! `Pin<&Self>` or `Pin<&mut Self>`) has consequences for your `Drop`\n+//! [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`]\n //! implementation as well: if an element of your type could have been pinned,\n-//! you must treat Drop as implicitly taking `Pin<&mut Self>`.\n+//! you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.\n //!\n //! For example, you could implement `Drop` as follows:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # struct Type { }\n@@ -182,7 +183,8 @@\n //!     }\n //! }\n //! ```\n-//! The function `inner_drop` has the type that `drop` *should* have, so this makes sure that\n+//!\n+//! The function `inner_drop` has the type that [`drop`] *should* have, so this makes sure that\n //! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n //!\n //! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n@@ -192,18 +194,18 @@\n //! # Projections and Structural Pinning\n //!\n //! When working with pinned structs, the question arises how one can access the\n-//! fields of that struct in a method that takes just `Pin<&mut Struct>`.\n+//! fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn `Pin<&mut Struct>` into a reference to the field, but what\n-//! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n+//! that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what\n+//! type should that reference have? Is it [`Pin`]`<&mut Field>` or `&mut Field`?\n //! The same question arises with the fields of an `enum`, and also when considering\n //! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n //! (This question applies to both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.)\n //!\n //! It turns out that it is actually up to the author of the data structure\n //! to decide whether the pinned projection for a particular field turns\n-//! `Pin<&mut Struct>` into `Pin<&mut Field>` or `&mut Field`. There are some\n+//! [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -218,12 +220,13 @@\n //! ## Pinning *is not* structural for `field`\n //!\n //! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n-//! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n+//! but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n //! Fields without structural pinning may have a projection method that turns\n-//! `Pin<&mut Struct>` into `&mut Field`:\n+//! [`Pin`]`<&mut Struct>` into `&mut Field`:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # type Field = i32;\n@@ -237,16 +240,17 @@\n //! ```\n //!\n //! You may also `impl Unpin for Struct` *even if* the type of `field`\n-//! is not `Unpin`. What that type thinks about pinning is not relevant\n-//! when no `Pin<&mut Field>` is ever created.\n+//! is not [`Unpin`]. What that type thinks about pinning is not relevant\n+//! when no [`Pin`]`<&mut Field>` is ever created.\n //!\n //! ## Pinning *is* structural for `field`\n //!\n //! The other option is to decide that pinning is \"structural\" for `field`,\n //! meaning that if the struct is pinned then so is the field.\n //!\n-//! This allows writing a projection that creates a `Pin<&mut Field>`, thus\n+//! This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus\n //! witnessing that the field is pinned:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # type Field = i32;\n@@ -262,30 +266,30 @@\n //! However, structural pinning comes with a few extra requirements:\n //!\n //! 1.  The struct must only be [`Unpin`] if all the structural fields are\n-//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n //!     the struct it is your responsibility *not* to add something like\n //!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n-//!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n+//!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)\n //! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n //!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n-//!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n+//!     You have to guarantee that you do not move a field inside your [`Drop`] implementation.\n //!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n-//!     See that section for how to write `drop` in a way that the compiler can help you\n+//!     See that section for how to write [`drop`] in a way that the compiler can help you\n //!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of `VecDeque<T>`\n-//!     can fail to call `drop` on all elements if one of the destructors panics. This violates the\n-//!     `Drop` guarantee, because it can lead to elements being deallocated without\n-//!     their destructor being called. (`VecDeque` has no pinning projections, so this\n+//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]\n+//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n+//!     the [`Drop`] guarantee, because it can lead to elements being deallocated without\n+//!     their destructor being called. ([`VecDeque<T>`] has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n-//!     `Option<T>` and there is a `take`-like operation with type\n+//!     [`Option<T>`] and there is a `take`-like operation with type\n //!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n //!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n //!     pinning cannot be structural for the field holding this data.\n@@ -301,37 +305,39 @@\n //!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the `RefCell<T>`\n+//!     This is catastrophic, it means we can first pin the content of the [`RefCell<T>`]\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n //! ## Examples\n //!\n //! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n-//! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n //! pinned references to elements. However, it could *not* allow calling\n-//! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n-//! Nor could it allow `push`, which might reallocate and thus also move the contents.\n-//! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n-//! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned)\n+//! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n+//! contents.\n+//!\n+//! A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the [`Vec<T>`] itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the `Box<T>` can be freely movable (aka `Unpin`) even if the `T`\n-//! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n-//! for the same reason: their contents (the `T`) are pinned, but the pointers themselves\n-//! can be moved without moving the pinned data. For both `Box<T>` and `Pin<Box<T>>`,\n-//! whether the content is pinned is entirely independent of whether the pointer is\n-//! pinned, meaning pinning is *not* structural.\n+//! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n+//! the `T` is not. In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always\n+//! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n+//! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n+//! [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the\n+//! pointer is pinned, meaning pinning is *not* structural.\n //!\n //! When implementing a [`Future`] combinator, you will usually need structural pinning\n-//! for the nested futures, as you need to get pinned references to them to call `poll`.\n+//! for the nested futures, as you need to get pinned references to them to call [`poll`].\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n-//! mutable reference even when you just have `Pin<&mut Self>` (such as in your own\n-//! `poll` implementation).\n+//! mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own\n+//! [`poll`] implementation).\n //!\n //! [`Pin<P>`]: struct.Pin.html\n //! [`Unpin`]: ../marker/trait.Unpin.html\n@@ -342,6 +348,16 @@\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n //! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n+//! [`Pin`]: struct.Pin.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n+//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n+//! [`Rc`]: ../../std/rc/struct.Rc.html\n+//! [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+//! [`Drop`]: ../../std/ops/trait.Drop.html\n+//! [`drop`]: ../../std/ops/trait.Drop.html#tymethod.drop\n+//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+//! [`Option<T>`]: ../../std/option/enum.Option.html\n //! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n //! [`RefCell<T>`]: ../cell/struct.RefCell.html\n //! [`None`]: ../option/enum.Option.html#variant.None\n@@ -350,6 +366,8 @@\n //! [`Future`]: ../future/trait.Future.html\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n+//! [`poll`]: ../../std/future/trait.Future.html#tymethod.poll\n+//! [`Pin::get_unchecked_mut`]: struct.Pin.html#method.get_unchecked_mut\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}, {"sha": "cb6bc058730d147d6cdcef8ead07caefeb9afb99", "filename": "src/libcore/result.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -232,7 +232,7 @@\n \n use crate::fmt;\n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n-use crate::ops::{self, Deref};\n+use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n ///\n@@ -981,42 +981,75 @@ impl<T: Default, E> Result<T, E> {\n \n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref, E> Result<T, E> {\n-    /// Converts from `&Result<T, E>` to `Result<&T::Target, &E>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E>`.\n     ///\n-    /// Leaves the original Result in-place, creating a new one with a reference\n-    /// to the original one, additionally coercing the `Ok` arm of the Result via\n-    /// `Deref`.\n-    pub fn deref_ok(&self) -> Result<&T::Target, &E> {\n+    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n+    /// `Ok` type's `Deref::Target` type.\n+    pub fn as_deref_ok(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T, E: Deref> Result<T, E> {\n-    /// Converts from `&Result<T, E>` to `Result<&T, &E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &E::Target>`.\n     ///\n-    /// Leaves the original Result in-place, creating a new one with a reference\n-    /// to the original one, additionally coercing the `Err` arm of the Result via\n-    /// `Deref`.\n-    pub fn deref_err(&self) -> Result<&T, &E::Target>\n+    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n+    /// `Err` type's `Deref::Target` type.\n+    pub fn as_deref_err(&self) -> Result<&T, &E::Target>\n     {\n         self.as_ref().map_err(|e| e.deref())\n     }\n }\n \n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref, E: Deref> Result<T, E> {\n-    /// Converts from `&Result<T, E>` to `Result<&T::Target, &E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E::Target>`.\n     ///\n-    /// Leaves the original Result in-place, creating a new one with a reference\n-    /// to the original one, additionally coercing both the `Ok` and `Err` arms\n-    /// of the Result via `Deref`.\n-    pub fn deref(&self) -> Result<&T::Target, &E::Target>\n+    /// Leaves the original `Result` in-place, creating a new one containing a reference to both\n+    /// the `Ok` and `Err` types' `Deref::Target` types.\n+    pub fn as_deref(&self) -> Result<&T::Target, &E::Target>\n     {\n         self.as_ref().map(|t| t.deref()).map_err(|e| e.deref())\n     }\n }\n \n+#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+impl<T: DerefMut, E> Result<T, E> {\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T::Target, &mut E>`.\n+    ///\n+    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n+    /// the `Ok` type's `Deref::Target` type.\n+    pub fn as_deref_mut_ok(&mut self) -> Result<&mut T::Target, &mut E> {\n+        self.as_mut().map(|t| t.deref_mut())\n+    }\n+}\n+\n+#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+impl<T, E: DerefMut> Result<T, E> {\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut E::Target>`.\n+    ///\n+    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n+    /// the `Err` type's `Deref::Target` type.\n+    pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target>\n+    {\n+        self.as_mut().map_err(|e| e.deref_mut())\n+    }\n+}\n+\n+#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+impl<T: DerefMut, E: DerefMut> Result<T, E> {\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to\n+    /// `Result<&mut T::Target, &mut E::Target>`.\n+    ///\n+    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n+    /// both the `Ok` and `Err` types' `Deref::Target` types.\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E::Target>\n+    {\n+        self.as_mut().map(|t| t.deref_mut()).map_err(|e| e.deref_mut())\n+    }\n+}\n+\n impl<T, E> Result<Option<T>, E> {\n     /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n     ///"}, {"sha": "ff43fc49f71e39aeb2b866b74b77ab3b8c07853e", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,6 +1,8 @@\n use core::option::*;\n use core::mem;\n use core::clone::Clone;\n+use core::array::FixedSizeArray;\n+use core::ops::DerefMut;\n \n #[test]\n fn test_get_ptr() {\n@@ -310,20 +312,38 @@ fn test_try() {\n }\n \n #[test]\n-fn test_option_deref() {\n+fn test_option_as_deref() {\n     // Some: &Option<T: Deref>::Some(T) -> Option<&T::Deref::Target>::Some(&*T)\n     let ref_option = &Some(&42);\n-    assert_eq!(ref_option.deref(), Some(&42));\n+    assert_eq!(ref_option.as_deref(), Some(&42));\n \n     let ref_option = &Some(String::from(\"a result\"));\n-    assert_eq!(ref_option.deref(), Some(\"a result\"));\n+    assert_eq!(ref_option.as_deref(), Some(\"a result\"));\n \n     let ref_option = &Some(vec![1, 2, 3, 4, 5]);\n-    assert_eq!(ref_option.deref(), Some(&[1, 2, 3, 4, 5][..]));\n+    assert_eq!(ref_option.as_deref(), Some([1, 2, 3, 4, 5].as_slice()));\n \n     // None: &Option<T: Deref>>::None -> None\n     let ref_option: &Option<&i32> = &None;\n-    assert_eq!(ref_option.deref(), None);\n+    assert_eq!(ref_option.as_deref(), None);\n+}\n+\n+#[test]\n+fn test_option_as_deref_mut() {\n+    // Some: &mut Option<T: Deref>::Some(T) -> Option<&mut T::Deref::Target>::Some(&mut *T)\n+    let mut val = 42;\n+    let ref_option = &mut Some(&mut val);\n+    assert_eq!(ref_option.as_deref_mut(), Some(&mut 42));\n+\n+    let ref_option = &mut Some(String::from(\"a result\"));\n+    assert_eq!(ref_option.as_deref_mut(), Some(String::from(\"a result\").deref_mut()));\n+\n+    let ref_option = &mut Some(vec![1, 2, 3, 4, 5]);\n+    assert_eq!(ref_option.as_deref_mut(), Some([1, 2, 3, 4, 5].as_mut_slice()));\n+\n+    // None: &mut Option<T: Deref>>::None -> None\n+    let ref_option: &mut Option<&mut i32> = &mut None;\n+    assert_eq!(ref_option.as_deref_mut(), None);\n }\n \n #[test]"}, {"sha": "163f8d0ab3797e731d4b51ea58fc0cee4050fbcf", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 153, "deletions": 32, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,4 +1,6 @@\n use core::option::*;\n+use core::array::FixedSizeArray;\n+use core::ops::DerefMut;\n \n fn op1() -> Result<isize, &'static str> { Ok(666) }\n fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n@@ -225,94 +227,213 @@ fn test_try() {\n }\n \n #[test]\n-fn test_result_deref() {\n-    // &Result<T: Deref, E>::Ok(T).deref_ok() ->\n+fn test_result_as_deref() {\n+    // &Result<T: Deref, E>::Ok(T).as_deref_ok() ->\n     //      Result<&T::Deref::Target, &E>::Ok(&*T)\n     let ref_ok = &Result::Ok::<&i32, u8>(&42);\n     let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.deref_ok(), expected_result);\n+    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n \n     let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n     let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n-    assert_eq!(ref_ok.deref_ok(), expected_result);\n+    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n \n     let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n-    let expected_result = Result::Ok::<&[i32], &u32>(&[1, 2, 3, 4, 5][..]);\n-    assert_eq!(ref_ok.deref_ok(), expected_result);\n+    let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n+    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n \n-    // &Result<T: Deref, E: Deref>::Ok(T).deref() ->\n+    // &Result<T: Deref, E: Deref>::Ok(T).as_deref() ->\n     //      Result<&T::Deref::Target, &E::Deref::Target>::Ok(&*T)\n     let ref_ok = &Result::Ok::<&i32, &u8>(&42);\n     let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.deref(), expected_result);\n+    assert_eq!(ref_ok.as_deref(), expected_result);\n \n     let ref_ok = &Result::Ok::<String, &u32>(String::from(\"a result\"));\n     let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n-    assert_eq!(ref_ok.deref(), expected_result);\n+    assert_eq!(ref_ok.as_deref(), expected_result);\n \n     let ref_ok = &Result::Ok::<Vec<i32>, &u32>(vec![1, 2, 3, 4, 5]);\n-    let expected_result = Result::Ok::<&[i32], &u32>(&[1, 2, 3, 4, 5][..]);\n-    assert_eq!(ref_ok.deref(), expected_result);\n+    let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n+    assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    // &Result<T, E: Deref>::Err(T).deref_err() ->\n+    // &Result<T, E: Deref>::Err(T).as_deref_err() ->\n     //      Result<&T, &E::Deref::Target>::Err(&*E)\n     let ref_err = &Result::Err::<u8, &i32>(&41);\n     let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.deref_err(), expected_result);\n+    assert_eq!(ref_err.as_deref_err(), expected_result);\n \n     let ref_err = &Result::Err::<u32, String>(String::from(\"an error\"));\n     let expected_result = Result::Err::<&u32, &str>(\"an error\");\n-    assert_eq!(ref_err.deref_err(), expected_result);\n+    assert_eq!(ref_err.as_deref_err(), expected_result);\n \n     let ref_err = &Result::Err::<u32, Vec<i32>>(vec![5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32]>(&[5, 4, 3, 2, 1][..]);\n-    assert_eq!(ref_err.deref_err(), expected_result);\n+    let expected_result = Result::Err::<&u32, &[i32]>([5, 4, 3, 2, 1].as_slice());\n+    assert_eq!(ref_err.as_deref_err(), expected_result);\n \n-    // &Result<T: Deref, E: Deref>::Err(T).deref_err() ->\n+    // &Result<T: Deref, E: Deref>::Err(T).as_deref_err() ->\n     //      Result<&T, &E::Deref::Target>::Err(&*E)\n     let ref_err = &Result::Err::<&u8, &i32>(&41);\n     let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.deref(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, String>(String::from(\"an error\"));\n     let expected_result = Result::Err::<&u32, &str>(\"an error\");\n-    assert_eq!(ref_err.deref(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, Vec<i32>>(vec![5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32]>(&[5, 4, 3, 2, 1][..]);\n-    assert_eq!(ref_err.deref(), expected_result);\n+    let expected_result = Result::Err::<&u32, &[i32]>([5, 4, 3, 2, 1].as_slice());\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n-    // The following cases test calling deref_* with the wrong variant (i.e.\n-    // `deref_ok()` with a `Result::Err()`, or `deref_err()` with a `Result::Ok()`.\n-    // While unusual, these cases are supported to ensure that an `inner_deref`\n+    // The following cases test calling `as_deref_*` with the wrong variant (i.e.\n+    // `as_deref_ok()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n+    // While uncommon, these cases are supported to ensure that an `as_deref_*`\n     // call can still be made even when one of the Result types does not implement\n     // `Deref` (for example, std::io::Error).\n \n-    // &Result<T, E: Deref>::Ok(T).deref_err() ->\n+    // &Result<T, E: Deref>::Ok(T).as_deref_err() ->\n     //      Result<&T, &E::Deref::Target>::Ok(&T)\n     let ref_ok = &Result::Ok::<i32, &u8>(42);\n     let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.deref_err(), expected_result);\n+    assert_eq!(ref_ok.as_deref_err(), expected_result);\n \n     let ref_ok = &Result::Ok::<&str, &u32>(\"a result\");\n     let expected_result = Result::Ok::<&&str, &u32>(&\"a result\");\n-    assert_eq!(ref_ok.deref_err(), expected_result);\n+    assert_eq!(ref_ok.as_deref_err(), expected_result);\n \n     let ref_ok = &Result::Ok::<[i32; 5], &u32>([1, 2, 3, 4, 5]);\n     let expected_result = Result::Ok::<&[i32; 5], &u32>(&[1, 2, 3, 4, 5]);\n-    assert_eq!(ref_ok.deref_err(), expected_result);\n+    assert_eq!(ref_ok.as_deref_err(), expected_result);\n \n-    // &Result<T: Deref, E>::Err(E).deref_ok() ->\n+    // &Result<T: Deref, E>::Err(E).as_deref_ok() ->\n     //      Result<&T::Deref::Target, &E>::Err(&E)\n     let ref_err = &Result::Err::<&u8, i32>(41);\n     let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref_ok(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, &str>(\"an error\");\n     let expected_result = Result::Err::<&u32, &&str>(&\"an error\");\n-    assert_eq!(ref_err.deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref_ok(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, [i32; 5]>([5, 4, 3, 2, 1]);\n     let expected_result = Result::Err::<&u32, &[i32; 5]>(&[5, 4, 3, 2, 1]);\n-    assert_eq!(ref_err.deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+}\n+\n+#[test]\n+fn test_result_as_deref_mut() {\n+    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut_ok() ->\n+    //      Result<&mut T::Deref::Target, &mut E>::Ok(&mut *T)\n+    let mut val = 42;\n+    let mut expected_val = 42;\n+    let mut_ok = &mut Result::Ok::<&mut i32, u8>(&mut val);\n+    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n+    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n+\n+    let mut expected_string = String::from(\"a result\");\n+    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n+    let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n+    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n+\n+    let mut expected_vec = vec![1, 2, 3, 4, 5];\n+    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n+    let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n+    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n+\n+    // &mut Result<T: Deref, E: Deref>::Ok(T).as_deref_mut() ->\n+    //      Result<&mut T::Deref::Target, &mut E::Deref::Target>::Ok(&mut *T)\n+    let mut val = 42;\n+    let mut expected_val = 42;\n+    let mut_ok = &mut Result::Ok::<&mut i32, &mut u8>(&mut val);\n+    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n+    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n+\n+    let mut expected_string = String::from(\"a result\");\n+    let mut_ok = &mut Result::Ok::<String, &mut u32>(expected_string.clone());\n+    let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n+    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n+\n+    let mut expected_vec = vec![1, 2, 3, 4, 5];\n+    let mut_ok = &mut Result::Ok::<Vec<i32>, &mut u32>(expected_vec.clone());\n+    let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n+    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n+\n+    // &mut Result<T, E: Deref>::Err(T).as_deref_mut_err() ->\n+    //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n+    let mut val = 41;\n+    let mut expected_val = 41;\n+    let mut_err = &mut Result::Err::<u8, &mut i32>(&mut val);\n+    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n+    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n+\n+    let mut expected_string = String::from(\"an error\");\n+    let mut_err = &mut Result::Err::<u32, String>(expected_string.clone());\n+    let expected_result = Result::Err::<&mut u32, &mut str>(expected_string.deref_mut());\n+    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n+\n+    let mut expected_vec = vec![5, 4, 3, 2, 1];\n+    let mut_err = &mut Result::Err::<u32, Vec<i32>>(expected_vec.clone());\n+    let expected_result = Result::Err::<&mut u32, &mut [i32]>(expected_vec.as_mut_slice());\n+    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n+\n+    // &mut Result<T: Deref, E: Deref>::Err(T).as_deref_mut_err() ->\n+    //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n+    let mut val = 41;\n+    let mut expected_val = 41;\n+    let mut_err = &mut Result::Err::<&mut u8, &mut i32>(&mut val);\n+    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n+\n+    let mut expected_string = String::from(\"an error\");\n+    let mut_err = &mut Result::Err::<&mut u32, String>(expected_string.clone());\n+    let expected_result = Result::Err::<&mut u32, &mut str>(expected_string.as_mut_str());\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n+\n+    let mut expected_vec = vec![5, 4, 3, 2, 1];\n+    let mut_err = &mut Result::Err::<&mut u32, Vec<i32>>(expected_vec.clone());\n+    let expected_result = Result::Err::<&mut u32, &mut [i32]>(expected_vec.as_mut_slice());\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n+\n+    // The following cases test calling `as_deref_mut_*` with the wrong variant (i.e.\n+    // `as_deref_mut_ok()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n+    // While uncommon, these cases are supported to ensure that an `as_deref_mut_*`\n+    // call can still be made even when one of the Result types does not implement\n+    // `Deref` (for example, std::io::Error).\n+\n+    // &mut Result<T, E: Deref>::Ok(T).as_deref_mut_err() ->\n+    //      Result<&mut T, &mut E::Deref::Target>::Ok(&mut T)\n+    let mut expected_val = 42;\n+    let mut_ok = &mut Result::Ok::<i32, &mut u8>(expected_val.clone());\n+    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n+    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n+\n+    let string = String::from(\"a result\");\n+    let expected_string = string.clone();\n+    let mut ref_str = expected_string.as_ref();\n+    let mut_ok = &mut Result::Ok::<&str, &mut u32>(string.as_str());\n+    let expected_result = Result::Ok::<&mut &str, &mut u32>(&mut ref_str);\n+    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n+\n+    let mut expected_arr = [1, 2, 3, 4, 5];\n+    let mut_ok = &mut Result::Ok::<[i32; 5], &mut u32>(expected_arr.clone());\n+    let expected_result = Result::Ok::<&mut [i32; 5], &mut u32>(&mut expected_arr);\n+    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n+\n+    // &mut Result<T: Deref, E>::Err(E).as_deref_mut_ok() ->\n+    //      Result<&mut T::Deref::Target, &mut E>::Err(&mut E)\n+    let mut expected_val = 41;\n+    let mut_err = &mut Result::Err::<&mut u8, i32>(expected_val.clone());\n+    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n+    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+\n+    let string = String::from(\"an error\");\n+    let expected_string = string.clone();\n+    let mut ref_str = expected_string.as_ref();\n+    let mut_err = &mut Result::Err::<&mut u32, &str>(string.as_str());\n+    let expected_result = Result::Err::<&mut u32, &mut &str>(&mut ref_str);\n+    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+\n+    let mut expected_arr = [5, 4, 3, 2, 1];\n+    let mut_err = &mut Result::Err::<&mut u32, [i32; 5]>(expected_arr.clone());\n+    let expected_result = Result::Err::<&mut u32, &mut [i32; 5]>(&mut expected_arr);\n+    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n }"}, {"sha": "bfe784afaa47d37555af4a182fed7d835d6cf7cf", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,6 +1,6 @@\n // NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n-#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n+#![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{BoolTrie, SmallBoolTrie};"}, {"sha": "5389d1cf803830edb6f82d1206351c2b54bd20e0", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -79,7 +79,7 @@ class UnicodeFiles(object):\n PREAMBLE = \"\"\"\\\n // NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n-#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n+#![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};"}, {"sha": "da4a25e0860b11b0228f2264a09a6496c4e5b847", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -941,7 +941,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(st.span.lo());\n         match st.node {\n             hir::StmtKind::Local(ref loc) => {\n-                self.print_local(loc.init.deref(), |this| this.print_local_decl(&loc));\n+                self.print_local(loc.init.as_deref(), |this| this.print_local_decl(&loc));\n             }\n             hir::StmtKind::Item(item) => {\n                 self.ann.nested(self, Nested::Item(item))"}, {"sha": "cc09a0b20cfd5deae1e01e11e17244538e86417f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -367,34 +367,6 @@ language_item_table! {\n \n     DebugTraitLangItem,          \"debug_trait\",        debug_trait,             Target::Trait;\n \n-    // A lang item for each of the 128-bit operators we can optionally lower.\n-    I128AddFnLangItem,           \"i128_add\",           i128_add_fn,             Target::Fn;\n-    U128AddFnLangItem,           \"u128_add\",           u128_add_fn,             Target::Fn;\n-    I128SubFnLangItem,           \"i128_sub\",           i128_sub_fn,             Target::Fn;\n-    U128SubFnLangItem,           \"u128_sub\",           u128_sub_fn,             Target::Fn;\n-    I128MulFnLangItem,           \"i128_mul\",           i128_mul_fn,             Target::Fn;\n-    U128MulFnLangItem,           \"u128_mul\",           u128_mul_fn,             Target::Fn;\n-    I128DivFnLangItem,           \"i128_div\",           i128_div_fn,             Target::Fn;\n-    U128DivFnLangItem,           \"u128_div\",           u128_div_fn,             Target::Fn;\n-    I128RemFnLangItem,           \"i128_rem\",           i128_rem_fn,             Target::Fn;\n-    U128RemFnLangItem,           \"u128_rem\",           u128_rem_fn,             Target::Fn;\n-    I128ShlFnLangItem,           \"i128_shl\",           i128_shl_fn,             Target::Fn;\n-    U128ShlFnLangItem,           \"u128_shl\",           u128_shl_fn,             Target::Fn;\n-    I128ShrFnLangItem,           \"i128_shr\",           i128_shr_fn,             Target::Fn;\n-    U128ShrFnLangItem,           \"u128_shr\",           u128_shr_fn,             Target::Fn;\n-    // And overflow versions for the operators that are checkable.\n-    // While MIR calls these Checked*, they return (T,bool), not Option<T>.\n-    I128AddoFnLangItem,          \"i128_addo\",          i128_addo_fn,            Target::Fn;\n-    U128AddoFnLangItem,          \"u128_addo\",          u128_addo_fn,            Target::Fn;\n-    I128SuboFnLangItem,          \"i128_subo\",          i128_subo_fn,            Target::Fn;\n-    U128SuboFnLangItem,          \"u128_subo\",          u128_subo_fn,            Target::Fn;\n-    I128MuloFnLangItem,          \"i128_mulo\",          i128_mulo_fn,            Target::Fn;\n-    U128MuloFnLangItem,          \"u128_mulo\",          u128_mulo_fn,            Target::Fn;\n-    I128ShloFnLangItem,          \"i128_shlo\",          i128_shlo_fn,            Target::Fn;\n-    U128ShloFnLangItem,          \"u128_shlo\",          u128_shlo_fn,            Target::Fn;\n-    I128ShroFnLangItem,          \"i128_shro\",          i128_shro_fn,            Target::Fn;\n-    U128ShroFnLangItem,          \"u128_shro\",          u128_shro_fn,            Target::Fn;\n-\n     // Align offset for stride != 1, must not panic.\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n "}, {"sha": "74653d4fbda73fd3f96dccf724ff644ced9ab051", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1406,10 +1406,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n         \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n          the max/min integer respectively, and NaN is mapped to 0\"),\n-    lower_128bit_ops: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"rewrite operators on i128 and u128 into lang item calls (typically provided \\\n-         by compiler-builtins) so codegen doesn't need to support them,\n-         overriding the default for the current target\"),\n     human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n         \"generate human-readable, predictable names for codegen units\"),\n     dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],"}, {"sha": "46b8114030f2976397d60e29d27803f0e1efce66", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -21,7 +21,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{self, Body, interpret, ProjectionKind};\n+use crate::mir::{Body, interpret, ProjectionKind};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -1297,40 +1297,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n-    /// Due to missing llvm support for lowering 128 bit math to software emulation\n-    /// (on some targets), the lowering can be done in MIR.\n-    ///\n-    /// This function only exists until said support is implemented.\n-    pub fn is_binop_lang_item(&self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let items = self.lang_items();\n-        let def_id = Some(def_id);\n-        if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.u128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.i128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.u128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.i128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.u128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.i128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.u128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.i128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.u128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.i128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.u128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.i128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.u128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.i128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.u128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.i128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.u128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.i128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.u128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.i128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.u128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.i128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else if items.u128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else { None }\n-    }\n-\n     pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n         self.stability_index(LOCAL_CRATE)\n     }"}, {"sha": "3b4b814c92a90fff9d37846b58db408df5af67bc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 100, "deletions": 127, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -246,13 +246,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n         let b_offset = a.value.size(dl).align_to(b_align.abi);\n         let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n+\n+        // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+        // returns the last maximum.\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b.clone())\n+            .into_iter()\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a.clone()))\n+            .max_by_key(|niche| niche.available(dl));\n+\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1]\n             },\n             abi: Abi::ScalarPair(a, b),\n+            largest_niche,\n             align,\n             size\n         }\n@@ -321,6 +330,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n \n         let mut offset = Size::ZERO;\n+        let mut largest_niche = None;\n+        let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n             let prefix_align = if packed {\n@@ -355,6 +366,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n+            if let Some(mut niche) = field.largest_niche.clone() {\n+                let available = niche.available(dl);\n+                if available > largest_niche_available {\n+                    largest_niche_available = available;\n+                    niche.offset += offset;\n+                    largest_niche = Some(niche);\n+                }\n+            }\n+\n             offset = offset.checked_add(field.size, dl)\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n@@ -466,6 +486,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 memory_index\n             },\n             abi,\n+            largest_niche,\n             align,\n             size\n         })\n@@ -525,6 +546,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -583,13 +605,20 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     Abi::Aggregate { sized: true }\n                 };\n \n+                let largest_niche = if count != 0 {\n+                    element.largest_niche.clone()\n+                } else {\n+                    None\n+                };\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n                     },\n                     abi,\n+                    largest_niche,\n                     align: element.align,\n                     size\n                 })\n@@ -603,6 +632,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: element.align,\n                     size: Size::ZERO\n                 })\n@@ -615,6 +645,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -683,6 +714,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         element: scalar,\n                         count\n                     },\n+                    largest_niche: element.largest_niche.clone(),\n                     size,\n                     align,\n                 })\n@@ -768,6 +800,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n                         abi,\n+                        largest_niche: None,\n                         align,\n                         size: size.align_to(align.abi)\n                     }));\n@@ -829,14 +862,38 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             // `#[rustc_layout_scalar_valid_range(n)]`\n                             // attribute to widen the range of anything as that would probably\n                             // result in UB somewhere\n+                            // FIXME(eddyb) the asserts are probably not needed,\n+                            // as larger validity ranges would result in missed\n+                            // optimizations, *not* wrongly assuming the inner\n+                            // value is valid. e.g. unions enlarge validity ranges,\n+                            // because the values may be uninitialized.\n                             if let Bound::Included(start) = start {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.start() <= start);\n                                 scalar.valid_range = start..=*scalar.valid_range.end();\n                             }\n                             if let Bound::Included(end) = end {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.end() >= end);\n                                 scalar.valid_range = *scalar.valid_range.start()..=end;\n                             }\n+\n+                            // Update `largest_niche` if we have introduced a larger niche.\n+                            let niche = Niche::from_scalar(dl, Size::ZERO, scalar.clone());\n+                            if let Some(niche) = niche {\n+                                match &st.largest_niche {\n+                                    Some(largest_niche) => {\n+                                        // Replace the existing niche even if they're equal,\n+                                        // because this one is at a lower offset.\n+                                        if largest_niche.available(dl) <= niche.available(dl) {\n+                                            st.largest_niche = Some(niche);\n+                                        }\n+                                    }\n+                                    None => st.largest_niche = Some(niche),\n+                                }\n+                            }\n                         }\n                         _ => assert!(\n                             start == Bound::Unbounded && end == Bound::Unbounded,\n@@ -845,6 +902,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             st,\n                         ),\n                     }\n+\n                     return Ok(tcx.intern_layout(st));\n                 }\n \n@@ -886,8 +944,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         let count = (\n                             niche_variants.end().as_u32() - niche_variants.start().as_u32() + 1\n                         ) as u128;\n+                        // FIXME(#62691) use the largest niche across all fields,\n+                        // not just the first one.\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n-                            let niche = match self.find_niche(field)? {\n+                            let niche = match &field.largest_niche {\n                                 Some(niche) => niche,\n                                 _ => continue,\n                             };\n@@ -937,6 +997,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 abi = Abi::Uninhabited;\n                             }\n \n+\n+                            let largest_niche =\n+                                Niche::from_scalar(dl, offset, niche_scalar.clone());\n+\n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::Multiple {\n                                     discr: niche_scalar,\n@@ -953,6 +1017,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     memory_index: vec![0]\n                                 },\n                                 abi,\n+                                largest_niche,\n                                 size,\n                                 align,\n                             }));\n@@ -1164,6 +1229,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi = Abi::Uninhabited;\n                 }\n \n+                let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Multiple {\n                         discr: tag,\n@@ -1175,6 +1242,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         offsets: vec![Size::ZERO],\n                         memory_index: vec![0]\n                     },\n+                    largest_niche,\n                     abi,\n                     align,\n                     size\n@@ -1332,16 +1400,31 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n         let discr_index = substs.prefix_tys(def_id, tcx).count();\n-        let promoted_tys =\n-            ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n-        let prefix_tys = substs.prefix_tys(def_id, tcx)\n-            .chain(iter::once(substs.discr_ty(tcx)))\n-            .chain(promoted_tys);\n-        let prefix = self.univariant_uninterned(\n+        // FIXME(eddyb) set the correct vaidity range for the discriminant.\n+        let discr_layout = self.layout_of(substs.discr_ty(tcx))?;\n+        let discr = match &discr_layout.abi {\n+            Abi::Scalar(s) => s.clone(),\n+            _ => bug!(),\n+        };\n+        // FIXME(eddyb) wrap each promoted type in `MaybeUninit` so that they\n+        // don't poison the `largest_niche` or `abi` fields of `prefix`.\n+        let promoted_layouts = ineligible_locals.iter()\n+            .map(|local| subst_field(info.field_tys[local]))\n+            .map(|ty| self.layout_of(ty));\n+        let prefix_layouts = substs.prefix_tys(def_id, tcx)\n+            .map(|ty| self.layout_of(ty))\n+            .chain(iter::once(Ok(discr_layout)))\n+            .chain(promoted_layouts)\n+            .collect::<Result<Vec<_>, _>>()?;\n+        let mut prefix = self.univariant_uninterned(\n             ty,\n-            &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+            &prefix_layouts,\n             &ReprOptions::default(),\n-            StructKind::AlwaysSized)?;\n+            StructKind::AlwaysSized,\n+        )?;\n+        // FIXME(eddyb) need `MaybeUninit` around promoted types (see above).\n+        prefix.largest_niche = None;\n+\n         let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n \n         // Split the prefix layout into the \"outer\" fields (upvars and\n@@ -1463,10 +1546,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         } else {\n             Abi::Aggregate { sized: true }\n         };\n-        let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n-            Abi::Scalar(s) => s.clone(),\n-            _ => bug!(),\n-        };\n \n         let layout = tcx.intern_layout(LayoutDetails {\n             variants: Variants::Multiple {\n@@ -1477,6 +1556,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             },\n             fields: outer_fields,\n             abi,\n+            largest_niche: prefix.largest_niche,\n             size,\n             align,\n         });\n@@ -1950,6 +2030,7 @@ where\n                     variants: Variants::Single { index: variant_index },\n                     fields: FieldPlacement::Union(fields),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: tcx.data_layout.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -2222,120 +2303,6 @@ where\n     }\n }\n \n-struct Niche {\n-    offset: Size,\n-    scalar: Scalar,\n-    available: u128,\n-}\n-\n-impl Niche {\n-    fn reserve<'tcx>(\n-        &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-        count: u128,\n-    ) -> Option<(u128, Scalar)> {\n-        if count > self.available {\n-            return None;\n-        }\n-        let Scalar { value, valid_range: ref v } = self.scalar;\n-        let bits = value.size(cx).bits();\n-        assert!(bits <= 128);\n-        let max_value = !0u128 >> (128 - bits);\n-        let start = v.end().wrapping_add(1) & max_value;\n-        let end = v.end().wrapping_add(count) & max_value;\n-        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n-    }\n-}\n-\n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n-    /// Find the offset of a niche leaf field, starting from\n-    /// the given type and recursing through aggregates.\n-    // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche(&self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n-        let scalar_niche = |scalar: &Scalar, offset| {\n-            let Scalar { value, valid_range: ref v } = *scalar;\n-\n-            let bits = value.size(self).bits();\n-            assert!(bits <= 128);\n-            let max_value = !0u128 >> (128 - bits);\n-\n-            // Find out how many values are outside the valid range.\n-            let available = if v.start() <= v.end() {\n-                v.start() + (max_value - v.end())\n-            } else {\n-                v.start() - v.end() - 1\n-            };\n-\n-            // Give up if there is no niche value available.\n-            if available == 0 {\n-                return None;\n-            }\n-\n-            Some(Niche { offset, scalar: scalar.clone(), available })\n-        };\n-\n-        // Locals variables which live across yields are stored\n-        // in the generator type as fields. These may be uninitialized\n-        // so we don't look for niches there.\n-        if let ty::Generator(..) = layout.ty.sty {\n-            return Ok(None);\n-        }\n-\n-        match layout.abi {\n-            Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_niche(scalar, Size::ZERO));\n-            }\n-            Abi::ScalarPair(ref a, ref b) => {\n-                // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n-                // returns the last maximum.\n-                let niche = iter::once(\n-                    (b, a.value.size(self).align_to(b.value.align(self).abi))\n-                )\n-                    .chain(iter::once((a, Size::ZERO)))\n-                    .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n-                    .max_by_key(|niche| niche.available);\n-                return Ok(niche);\n-            }\n-            Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_niche(element, Size::ZERO));\n-            }\n-            _ => {}\n-        }\n-\n-        // Perhaps one of the fields is non-zero, let's recurse and find out.\n-        if let FieldPlacement::Union(_) = layout.fields {\n-            // Only Rust enums have safe-to-inspect fields\n-            // (a discriminant), other unions are unsafe.\n-            if let Variants::Single { .. } = layout.variants {\n-                return Ok(None);\n-            }\n-        }\n-        if let FieldPlacement::Array { count: original_64_bit_count, .. } = layout.fields {\n-            // rust-lang/rust#57038: avoid ICE within FieldPlacement::count when count too big\n-            if original_64_bit_count > usize::max_value() as u64 {\n-                return Err(LayoutError::SizeOverflow(layout.ty));\n-            }\n-            if layout.fields.count() > 0 {\n-                return self.find_niche(layout.field(self, 0)?);\n-            } else {\n-                return Ok(None);\n-            }\n-        }\n-        let mut niche = None;\n-        let mut available = 0;\n-        for i in 0..layout.fields.count() {\n-            if let Some(mut c) = self.find_niche(layout.field(self, i)?)? {\n-                if c.available > available {\n-                    available = c.available;\n-                    c.offset += layout.fields.offset(i);\n-                    niche = Some(c);\n-                }\n-            }\n-        }\n-        Ok(niche)\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -2456,10 +2423,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     }\n }\n \n+impl_stable_hash_for!(struct crate::ty::layout::Niche {\n+    offset,\n+    scalar\n+});\n+\n impl_stable_hash_for!(struct crate::ty::layout::LayoutDetails {\n     variants,\n     fields,\n     abi,\n+    largest_niche,\n     size,\n     align\n });"}, {"sha": "77b8ebba216699a7121ecbe4c265c2cadecbff9d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1847,7 +1847,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_mutable_pointer(&self) -> bool {\n+    pub fn is_mutable_ptr(&self) -> bool {\n         match self.sty {\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n             Ref(_, _, hir::Mutability::MutMutable) => true,\n@@ -2002,7 +2002,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_pointer_sized(&self) -> bool {\n+    pub fn is_ptr_sized_integral(&self) -> bool {\n         match self.sty {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n             _ => false,"}, {"sha": "894e5c2fd3d93049d53f513039659813952b593b", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1153,21 +1153,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn vector_reduce_fadd(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src) }\n+    }\n+    pub fn vector_reduce_fmul(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src) }\n+    }\n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr"}, {"sha": "f00624f3811f189fc91f1780f7bd9f1996052a20", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -166,25 +166,6 @@ impl CodegenCx<'ll, 'tcx> {\n             r\n         }\n     }\n-\n-    pub fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n-        unsafe {\n-            if self.is_const_real(v) {\n-                let mut loses_info: llvm::Bool = 0;\n-                let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n-                let loses_info = if loses_info == 1 { true } else { false };\n-                Some((r, loses_info))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    fn is_const_real(&self, v: &'ll Value) -> bool {\n-        unsafe {\n-            llvm::LLVMIsAConstantFP(v).is_some()\n-        }\n-    }\n }\n \n impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {"}, {"sha": "44b3eff2ac5c9d91a8e3c5aba4f279b13e9c600a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1640,29 +1640,11 @@ fn generic_simd_intrinsic(\n                         }\n                     },\n                     ty::Float(f) => {\n-                        // ordered arithmetic reductions take an accumulator\n                         let acc = if $ordered {\n-                            let acc = args[1].immediate();\n-                            // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36734\n-                            // * if the accumulator of the fadd isn't 0, incorrect\n-                            //   code is generated\n-                            // * if the accumulator of the fmul isn't 1, incorrect\n-                            //   code is generated\n-                            match bx.const_get_real(acc) {\n-                                None => return_error!(\"accumulator of {} is not a constant\", $name),\n-                                Some((v, loses_info)) => {\n-                                    if $name.contains(\"mul\") && v != 1.0_f64 {\n-                                        return_error!(\"accumulator of {} is not 1.0\", $name);\n-                                    } else if $name.contains(\"add\") && v != 0.0_f64 {\n-                                        return_error!(\"accumulator of {} is not 0.0\", $name);\n-                                    } else if loses_info {\n-                                        return_error!(\"accumulator of {} loses information\", $name);\n-                                    }\n-                                }\n-                            }\n-                            acc\n+                            // ordered arithmetic reductions take an accumulator\n+                            args[1].immediate()\n                         } else {\n-                            // unordered arithmetic reductions do not:\n+                            // unordered arithmetic reductions use the identity accumulator\n                             let identity_acc = if $name.contains(\"mul\") { 1.0 } else { 0.0 };\n                             match f.bit_width() {\n                                 32 => bx.const_real(bx.type_f32(), identity_acc),\n@@ -1688,8 +1670,8 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n     }\n \n-    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd_fast, true);\n-    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul_fast, true);\n+    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd, true);\n+    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul, true);\n     arith_red!(\"simd_reduce_add_unordered\": vector_reduce_add, vector_reduce_fadd_fast, false);\n     arith_red!(\"simd_reduce_mul_unordered\": vector_reduce_mul, vector_reduce_fmul_fast, false);\n "}, {"sha": "8c6ea00eb8c872646147e37257e4c20ab66a029c", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -719,7 +719,6 @@ extern \"C\" {\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n                                   high: &mut u64, low: &mut u64) -> bool;\n-    pub fn LLVMConstRealGetDouble (ConstantVal: &Value, losesInfo: &mut Bool) -> f64;\n \n \n     // Operations on composite constants\n@@ -1663,7 +1662,6 @@ extern \"C\" {\n     pub fn LLVMRustWriteValueToString(value_ref: &Value, s: &RustString);\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&Value>;\n-    pub fn LLVMIsAConstantFP(value_ref: &Value) -> Option<&Value>;\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;"}, {"sha": "32f121f18f68970053915cbd25d77124194c9dc3", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -17,4 +17,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.5.0\"\n+annotate-snippets = \"0.6.1\""}, {"sha": "96a9b6c5c4f7fab34b5a4aec5ddd267c53515457", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -23,7 +23,7 @@ pub struct AnnotateSnippetEmitterWriter {\n     source_map: Option<Lrc<SourceMapperDyn>>,\n     /// If true, hides the longer explanation text\n     short_message: bool,\n-    /// If true, will normalize line numbers with LL to prevent noise in UI test diffs.\n+    /// If true, will normalize line numbers with `LL` to prevent noise in UI test diffs.\n     ui_testing: bool,\n }\n \n@@ -173,10 +173,6 @@ impl AnnotateSnippetEmitterWriter {\n     /// Allows to modify `Self` to enable or disable the `ui_testing` flag.\n     ///\n     /// If this is set to true, line numbers will be normalized as `LL` in the output.\n-    // FIXME(#59346): This method is used via the public interface, but setting the `ui_testing`\n-    // flag currently does not anonymize line numbers. We would have to add the `maybe_anonymized`\n-    // method from `emitter.rs` and implement rust-lang/annotate-snippets-rs#2 in order to\n-    // anonymize line numbers.\n     pub fn ui_testing(mut self, ui_testing: bool) -> Self {\n         self.ui_testing = ui_testing;\n         self\n@@ -202,7 +198,7 @@ impl AnnotateSnippetEmitterWriter {\n         };\n         if let Some(snippet) = converter.to_annotation_snippet() {\n             let dl = DisplayList::from(snippet);\n-            let dlf = DisplayListFormatter::new(true);\n+            let dlf = DisplayListFormatter::new(true, self.ui_testing);\n             // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n             // `emitter.rs` has the `Destination` enum that lists various possible output\n             // destinations."}, {"sha": "16cdbb7dd4d39a60cafe27c6b2506a6a96d3509b", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -112,6 +112,10 @@ fn main() {\n         println!(\"cargo:rustc-cfg=llvm_component=\\\"{}\\\"\", component);\n     }\n \n+    if major >= 9 {\n+        println!(\"cargo:rustc-cfg=llvm_has_msp430_asm_parser\");\n+    }\n+\n     // Link in our own LLVM shims, compiled with the same flags as LLVM\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--cxxflags\");"}, {"sha": "dea7e6ae0a2abf85088602bf6eafbc3e01b7b700", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -76,6 +76,8 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeMSP430Target,\n                  LLVMInitializeMSP430TargetMC,\n                  LLVMInitializeMSP430AsmPrinter);\n+    init_target!(all(llvm_component = \"msp430\", llvm_has_msp430_asm_parser),\n+                 LLVMInitializeMSP430AsmParser);\n     init_target!(llvm_component = \"riscv\",\n                  LLVMInitializeRISCVTargetInfo,\n                  LLVMInitializeRISCVTarget,"}, {"sha": "c767279dd8c7abad2b852e87174b9b0d33a9d2b2", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -536,7 +536,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let base_ty = Place::ty_from(deref_base.base, deref_base.projection, self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n-        } else if base_ty.is_mutable_pointer() {\n+        } else if base_ty.is_mutable_ptr() {\n             BorrowedContentSource::DerefMutableRef\n         } else {\n             BorrowedContentSource::DerefSharedRef"}, {"sha": "92774bbb7a6b4d509381c58ec521a15bc619218f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1329,7 +1329,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: None,\n             }) if self.body.local_decls[local].is_user_variable.is_none() => {\n-                if self.body.local_decls[local].ty.is_mutable_pointer() {\n+                if self.body.local_decls[local].ty.is_mutable_ptr() {\n                     // The variable will be marked as mutable by the borrow.\n                     return;\n                 }"}, {"sha": "567bac777d2657bb7f39181d4c5bc00603daf541", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1171,7 +1171,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive ||\n-            (pcx.ty.is_pointer_sized() && !cx.tcx.features().precise_pointer_size_matching);\n+            (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n             split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n@@ -1488,7 +1488,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n         _ => return false,\n     };\n     if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n-        !ty.is_pointer_sized() || tcx.features().precise_pointer_size_matching\n+        !ty.is_ptr_sized_integral() || tcx.features().precise_pointer_size_matching\n     } else {\n         false\n     }"}, {"sha": "6a5b933e4a530fdb9cc276ccbb188d8a23624490", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -230,21 +230,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        _dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n-        // Some fn calls are actually BinOp intrinsics\n-        if let Some((op, oflo)) = self.tcx.is_binop_lang_item(def_id) {\n-            let dest = dest.expect(\"128 lowerings can't diverge\");\n-            let l = self.read_immediate(args[0])?;\n-            let r = self.read_immediate(args[1])?;\n-            if oflo {\n-                self.binop_with_overflow(op, l, r, dest)?;\n-            } else {\n-                self.binop_ignore_overflow(op, l, r, dest)?;\n-            }\n-            return Ok(true);\n-        } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n+        if Some(def_id) == self.tcx.lang_items().panic_fn() {\n             assert!(args.len() == 1);\n             // &(&'static str, &'static str, u32, u32)\n             let place = self.deref_operand(args[0])?;"}, {"sha": "40cb1fbdc57fa9446f7e05549f723e4caecb3455", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -232,13 +232,6 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n-        // Do not inline {u,i}128 lang items, codegen const eval depends\n-        // on detecting calls to these lang items and intercepting them\n-        if tcx.is_binop_lang_item(callsite.callee).is_some() {\n-            debug!(\"    not inlining 128bit integer lang item\");\n-            return false;\n-        }\n-\n         let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee);\n \n         let hinted = match codegen_fn_attrs.inline {"}, {"sha": "f09a77d486c7e3ceccf2634c3cc42693ea44f856", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,230 +0,0 @@\n-//! Replaces 128-bit operators with lang item calls\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::lang_items::LangItem;\n-use rustc::mir::*;\n-use rustc::ty::{self, List, Ty, TyCtxt};\n-use rustc_data_structures::indexed_vec::{Idx};\n-use crate::transform::{MirPass, MirSource};\n-\n-pub struct Lower128Bit;\n-\n-impl MirPass for Lower128Bit {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n-        let target_default = tcx.sess.host.options.i128_lowering;\n-        if !debugging_override.unwrap_or(target_default) {\n-            return\n-        }\n-\n-        self.lower_128bit_ops(tcx, body);\n-}\n-}\n-\n-impl Lower128Bit {\n-    fn lower_128bit_ops<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let mut new_blocks = Vec::new();\n-        let cur_len = body.basic_blocks().len();\n-\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for block in basic_blocks.iter_mut() {\n-            for i in (0..block.statements.len()).rev() {\n-                let (lang_item, rhs_kind) =\n-                    if let Some((lang_item, rhs_kind)) =\n-                        lower_to(&block.statements[i], local_decls, tcx)\n-                    {\n-                        (lang_item, rhs_kind)\n-                    } else {\n-                        continue;\n-                    };\n-\n-                let rhs_override_ty = rhs_kind.ty(tcx);\n-                let cast_local =\n-                    match rhs_override_ty {\n-                        None => None,\n-                        Some(ty) => {\n-                            let local_decl = LocalDecl::new_internal(\n-                                ty, block.statements[i].source_info.span);\n-                            Some(local_decls.push(local_decl))\n-                        },\n-                    };\n-\n-                let storage_dead = cast_local.map(|local| {\n-                    Statement {\n-                        source_info: block.statements[i].source_info,\n-                        kind: StatementKind::StorageDead(local),\n-                    }\n-                });\n-                let after_call = BasicBlockData {\n-                    statements: storage_dead.into_iter()\n-                        .chain(block.statements.drain((i+1)..)).collect(),\n-                    is_cleanup: block.is_cleanup,\n-                    terminator: block.terminator.take(),\n-                };\n-\n-                let bin_statement = block.statements.pop().unwrap();\n-                let source_info = bin_statement.source_info;\n-                let (place, lhs, mut rhs) = match bin_statement.kind {\n-                    StatementKind::Assign(place, box rvalue) => {\n-                        match rvalue {\n-                            Rvalue::BinaryOp(_, lhs, rhs)\n-                            | Rvalue::CheckedBinaryOp(_, lhs, rhs) => (place, lhs, rhs),\n-                            _ => bug!(),\n-                        }\n-                    }\n-                    _ => bug!()\n-                };\n-\n-                if let Some(local) = cast_local {\n-                    block.statements.push(Statement {\n-                        source_info: source_info,\n-                        kind: StatementKind::StorageLive(local),\n-                    });\n-                    block.statements.push(Statement {\n-                        source_info: source_info,\n-                        kind: StatementKind::Assign(\n-                            Place::from(local),\n-                            box Rvalue::Cast(\n-                                CastKind::Misc,\n-                                rhs,\n-                                rhs_override_ty.unwrap())),\n-                    });\n-                    rhs = Operand::Move(Place::from(local));\n-                }\n-\n-                let call_did = check_lang_item_type(\n-                    lang_item, &place, &lhs, &rhs, local_decls, tcx);\n-\n-                let bb = BasicBlock::new(cur_len + new_blocks.len());\n-                new_blocks.push(after_call);\n-\n-                block.terminator =\n-                    Some(Terminator {\n-                        source_info,\n-                        kind: TerminatorKind::Call {\n-                            func: Operand::function_handle(tcx, call_did,\n-                                List::empty(), source_info.span),\n-                            args: vec![lhs, rhs],\n-                            destination: Some((place, bb)),\n-                            cleanup: None,\n-                            from_hir_call: false,\n-                        },\n-                    });\n-            }\n-        }\n-\n-        basic_blocks.extend(new_blocks);\n-    }\n-}\n-\n-fn check_lang_item_type<'tcx, D>(\n-    lang_item: LangItem,\n-    place: &Place<'tcx>,\n-    lhs: &Operand<'tcx>,\n-    rhs: &Operand<'tcx>,\n-    local_decls: &D,\n-    tcx: TyCtxt<'tcx>,\n-) -> DefId\n-where\n-    D: HasLocalDecls<'tcx>,\n-{\n-    let did = tcx.require_lang_item(lang_item);\n-    let poly_sig = tcx.fn_sig(did);\n-    let sig = poly_sig.no_bound_vars().unwrap();\n-    let lhs_ty = lhs.ty(local_decls, tcx);\n-    let rhs_ty = rhs.ty(local_decls, tcx);\n-    let place_ty = place.ty(local_decls, tcx).ty;\n-    let expected = [lhs_ty, rhs_ty, place_ty];\n-    assert_eq!(sig.inputs_and_output[..], expected,\n-        \"lang item `{}`\", tcx.def_path_str(did));\n-    did\n-}\n-\n-fn lower_to<'tcx, D>(\n-    statement: &Statement<'tcx>,\n-    local_decls: &D,\n-    tcx: TyCtxt<'tcx>,\n-) -> Option<(LangItem, RhsKind)>\n-where\n-    D: HasLocalDecls<'tcx>,\n-{\n-    match statement.kind {\n-        StatementKind::Assign(_, box Rvalue::BinaryOp(bin_op, ref lhs, _)) => {\n-            let ty = lhs.ty(local_decls, tcx);\n-            if let Some(is_signed) = sign_of_128bit(ty) {\n-                return item_for_op(bin_op, is_signed);\n-            }\n-        },\n-        StatementKind::Assign(_, box Rvalue::CheckedBinaryOp(bin_op, ref lhs, _)) => {\n-            let ty = lhs.ty(local_decls, tcx);\n-            if let Some(is_signed) = sign_of_128bit(ty) {\n-                return item_for_checked_op(bin_op, is_signed);\n-            }\n-        },\n-        _ => {},\n-    }\n-    None\n-}\n-\n-#[derive(Copy, Clone)]\n-enum RhsKind {\n-    Unchanged,\n-    ForceU128,\n-    ForceU32,\n-}\n-\n-impl RhsKind {\n-    fn ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Ty<'tcx>> {\n-        match *self {\n-            RhsKind::Unchanged => None,\n-            RhsKind::ForceU128 => Some(tcx.types.u128),\n-            RhsKind::ForceU32 => Some(tcx.types.u32),\n-        }\n-    }\n-}\n-\n-fn sign_of_128bit(ty: Ty<'_>) -> Option<bool> {\n-    match ty.sty {\n-        ty::Int(syntax::ast::IntTy::I128) => Some(true),\n-        ty::Uint(syntax::ast::UintTy::U128) => Some(false),\n-        _ => None,\n-    }\n-}\n-\n-fn item_for_op(bin_op: BinOp, is_signed: bool) -> Option<(LangItem, RhsKind)> {\n-    let i = match (bin_op, is_signed) {\n-        (BinOp::Add, true) => (LangItem::I128AddFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Add, false) => (LangItem::U128AddFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Sub, true) => (LangItem::I128SubFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Sub, false) => (LangItem::U128SubFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Mul, true) => (LangItem::I128MulFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Mul, false) => (LangItem::U128MulFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Div, true) => (LangItem::I128DivFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Div, false) => (LangItem::U128DivFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Rem, true) => (LangItem::I128RemFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Rem, false) => (LangItem::U128RemFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Shl, true) => (LangItem::I128ShlFnLangItem, RhsKind::ForceU32),\n-        (BinOp::Shl, false) => (LangItem::U128ShlFnLangItem, RhsKind::ForceU32),\n-        (BinOp::Shr, true) => (LangItem::I128ShrFnLangItem, RhsKind::ForceU32),\n-        (BinOp::Shr, false) => (LangItem::U128ShrFnLangItem, RhsKind::ForceU32),\n-        _ => return None,\n-    };\n-    Some(i)\n-}\n-\n-fn item_for_checked_op(bin_op: BinOp, is_signed: bool) -> Option<(LangItem, RhsKind)> {\n-    let i = match (bin_op, is_signed) {\n-        (BinOp::Add, true) => (LangItem::I128AddoFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Add, false) => (LangItem::U128AddoFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Sub, true) => (LangItem::I128SuboFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Sub, false) => (LangItem::U128SuboFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Mul, true) => (LangItem::I128MuloFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Mul, false) => (LangItem::U128MuloFnLangItem, RhsKind::Unchanged),\n-        (BinOp::Shl, true) => (LangItem::I128ShloFnLangItem, RhsKind::ForceU128),\n-        (BinOp::Shl, false) => (LangItem::U128ShloFnLangItem, RhsKind::ForceU128),\n-        (BinOp::Shr, true) => (LangItem::I128ShroFnLangItem, RhsKind::ForceU128),\n-        (BinOp::Shr, false) => (LangItem::U128ShroFnLangItem, RhsKind::ForceU128),\n-        _ => bug!(\"That should be all the checked ones?\"),\n-    };\n-    Some(i)\n-}"}, {"sha": "61d0b1f3485b6b741f2de4e2ee81a56d6fe50ce0", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -34,7 +34,6 @@ pub mod copy_prop;\n pub mod const_prop;\n pub mod generator;\n pub mod inline;\n-pub mod lower_128bit;\n pub mod uniform_array_move_out;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n@@ -272,8 +271,6 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n         // From here on out, regions are gone.\n         &erase_regions::EraseRegions,\n \n-        &lower_128bit::Lower128Bit,\n-\n \n         // Optimizations begin.\n         &uniform_array_move_out::RestoreSubsliceArrayMoveOut,"}, {"sha": "4a4c6799c005e0f5d35326aeea4b8b8c8ed800c2", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -878,23 +878,94 @@ pub enum DiscriminantKind {\n     },\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Niche {\n+    pub offset: Size,\n+    pub scalar: Scalar,\n+}\n+\n+impl Niche {\n+    pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n+        let niche = Niche {\n+            offset,\n+            scalar,\n+        };\n+        if niche.available(cx) > 0 {\n+            Some(niche)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+\n+        // Find out how many values are outside the valid range.\n+        let niche = v.end().wrapping_add(1)..*v.start();\n+        niche.end.wrapping_sub(niche.start) & max_value\n+    }\n+\n+    pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n+        assert!(count > 0);\n+\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+\n+        if count > max_value {\n+            return None;\n+        }\n+\n+        // Compute the range of invalid values being reserved.\n+        let start = v.end().wrapping_add(1) & max_value;\n+        let end = v.end().wrapping_add(count) & max_value;\n+\n+        // If the `end` of our range is inside the valid range,\n+        // then we ran out of invalid values.\n+        // FIXME(eddyb) abstract this with a wraparound range type.\n+        let valid_range_contains = |x| {\n+            if v.start() <= v.end() {\n+                *v.start() <= x && x <= *v.end()\n+            } else {\n+                *v.start() <= x || x <= *v.end()\n+            }\n+        };\n+        if valid_range_contains(end) {\n+            return None;\n+        }\n+\n+        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n+\n+    /// The leaf scalar with the largest number of invalid values\n+    /// (i.e. outside of its `valid_range`), if it exists.\n+    pub largest_niche: Option<Niche>,\n+\n     pub align: AbiAndPrefAlign,\n     pub size: Size\n }\n \n impl LayoutDetails {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n+        let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar.clone());\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Union(0),\n             abi: Abi::Scalar(scalar),\n+            largest_niche,\n             size,\n             align,\n         }"}, {"sha": "3c63371d121922d256322c709fb6376dc0789a3b", "filename": "src/librustc_target/spec/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_gnueabihf.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            features: \"+strict-align,+v6,+vfp2\".to_string(),\n+            features: \"+strict-align,+v6,+vfp2,-d32\".to_string(),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             .. base"}, {"sha": "fb5a16f74c00be21a06ba82bbc5d4023f6cdd4b1", "filename": "src/librustc_target/spec/arm_unknown_linux_musleabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farm_unknown_linux_musleabihf.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -5,7 +5,7 @@ pub fn target() -> TargetResult {\n \n     // Most of these settings are copied from the arm_unknown_linux_gnueabihf\n     // target.\n-    base.features = \"+strict-align,+v6,+vfp2\".to_string();\n+    base.features = \"+strict-align,+v6,+vfp2,-d32\".to_string();\n     base.max_atomic_width = Some(64);\n     Ok(Target {\n         // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM"}, {"sha": "06233f7caa35131c92de6d402a1c83b5ccb47991", "filename": "src/librustc_target/spec/armv6_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_freebsd.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            features: \"+v6,+vfp2\".to_string(),\n+            features: \"+v6,+vfp2,-d32\".to_string(),\n             max_atomic_width: Some(64),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),"}, {"sha": "40411befcfc2beb870fe73dde1516ab2c5593898", "filename": "src/librustc_target/spec/armv6_unknown_netbsd_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            features: \"+v6,+vfp2\".to_string(),\n+            features: \"+v6,+vfp2,-d32\".to_string(),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             target_mcount: \"__mcount\".to_string(),\n             .. base"}, {"sha": "54e3cad6a6149f8649fc7dce2a5df62d1d84b030", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -736,10 +736,6 @@ pub struct TargetOptions {\n     /// for this target unconditionally.\n     pub no_builtins: bool,\n \n-    /// Whether to lower 128-bit operations to compiler_builtins calls. Use if\n-    /// your backend only supports 64-bit and smaller math.\n-    pub i128_lowering: bool,\n-\n     /// The codegen backend to use for this target, typically \"llvm\"\n     pub codegen_backend: String,\n \n@@ -855,7 +851,6 @@ impl Default for TargetOptions {\n             requires_lto: false,\n             singlethread: false,\n             no_builtins: false,\n-            i128_lowering: false,\n             codegen_backend: \"llvm\".to_string(),\n             default_hidden_visibility: false,\n             embed_bitcode: false,"}, {"sha": "8d2160c0ec7aa7c39cd52cac37ffa79b469d5b19", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -225,7 +225,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.mk_unit()\n             }\n             ExprKind::Break(destination, ref expr_opt) => {\n-                self.check_expr_break(destination, expr_opt.deref(), expr)\n+                self.check_expr_break(destination, expr_opt.as_deref(), expr)\n             }\n             ExprKind::Continue(destination) => {\n                 if destination.target_id.is_ok() {\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => {\n-                self.check_expr_return(expr_opt.deref(), expr)\n+                self.check_expr_return(expr_opt.as_deref(), expr)\n             }\n             ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs)"}, {"sha": "408c267555c9ef0008ab481fc561eaa5564ea9ca", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 trait_name,\n                 item_name,\n                 if rcvr_ty.is_region_ptr() && args.is_some() {\n-                    if rcvr_ty.is_mutable_pointer() {\n+                    if rcvr_ty.is_mutable_ptr() {\n                         \"&mut \"\n                     } else {\n                         \"&\""}, {"sha": "6270ed37859055c0e99067f2877ed35c8a13d14b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1173,7 +1173,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                 title: \"Index of crates\",\n                 css_class: \"mod\",\n                 root_path: \"./\",\n-                static_root_path: cx.shared.static_root_path.deref(),\n+                static_root_path: cx.shared.static_root_path.as_deref(),\n                 description: \"List of crates\",\n                 keywords: BASIC_KEYWORDS,\n                 resource_suffix: &cx.shared.resource_suffix,\n@@ -1513,7 +1513,7 @@ impl<'a> SourceCollector<'a> {\n             title: &title,\n             css_class: \"source\",\n             root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.deref(),\n+            static_root_path: self.scx.static_root_path.as_deref(),\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n             resource_suffix: &self.scx.resource_suffix,\n@@ -2110,7 +2110,7 @@ impl Context {\n             title: \"List of all items in this crate\",\n             css_class: \"mod\",\n             root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.deref(),\n+            static_root_path: self.shared.static_root_path.as_deref(),\n             description: \"List of all items in this crate\",\n             keywords: BASIC_KEYWORDS,\n             resource_suffix: &self.shared.resource_suffix,\n@@ -2137,7 +2137,7 @@ impl Context {\n         self.shared.fs.write(&final_file, &v)?;\n \n         // Generating settings page.\n-        let settings = Settings::new(self.shared.static_root_path.deref().unwrap_or(\"./\"),\n+        let settings = Settings::new(self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n                                      &self.shared.resource_suffix);\n         page.title = \"Rustdoc settings\";\n         page.description = \"Settings of Rustdoc\";\n@@ -2195,7 +2195,7 @@ impl Context {\n         let page = layout::Page {\n             css_class: tyname,\n             root_path: &self.root_path(),\n-            static_root_path: self.shared.static_root_path.deref(),\n+            static_root_path: self.shared.static_root_path.as_deref(),\n             title: &title,\n             description: &desc,\n             keywords: &keywords,"}, {"sha": "e0c560b9214ea1e92b2b6b28137110d448179831", "filename": "src/libstd/sys/vxworks/alloc.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -41,36 +41,6 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(target_os = \"android\",\n-          target_os = \"hermit\",\n-          target_os = \"redox\",\n-          target_os = \"solaris\"))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    // On android we currently target API level 9 which unfortunately\n-    // doesn't have the `posix_memalign` API used below. Instead we use\n-    // `memalign`, but this unfortunately has the property on some systems\n-    // where the memory returned cannot be deallocated by `free`!\n-    //\n-    // Upon closer inspection, however, this appears to work just fine with\n-    // Android, so for this platform we should be fine to call `memalign`\n-    // (which is present in API level 9). Some helpful references could\n-    // possibly be chromium using memalign [1], attempts at documenting that\n-    // memalign + free is ok [2] [3], or the current source of chromium\n-    // which still uses memalign on android [4].\n-    //\n-    // [1]: https://codereview.chromium.org/10796020/\n-    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-    //                                       /memory/aligned_memory.cc\n-    libc::memalign(layout.align(), layout.size()) as *mut u8\n-}\n-\n-#[cfg(not(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\")))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();"}, {"sha": "6774160bb2561596117de3b16800bd8e7ff31fcf", "filename": "src/libstd/sys/vxworks/android.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,160 +0,0 @@\n-//! Android ABI-compatibility module\n-//!\n-//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n-//! be both forwards and backwards compatible as much as possible. We want to\n-//! always work with the most recent version of Android, but we also want to\n-//! work with older versions of Android for whenever projects need to.\n-//!\n-//! Our current minimum supported Android version is `android-9`, e.g., Android\n-//! with API level 9. We then in theory want to work on that and all future\n-//! versions of Android!\n-//!\n-//! Some of the detection here is done at runtime via `dlopen` and\n-//! introspection. Other times no detection is performed at all and we just\n-//! provide a fallback implementation as some versions of Android we support\n-//! don't have the function.\n-//!\n-//! You'll find more details below about why each compatibility shim is needed.\n-\n-#![cfg(target_os = \"android\")]\n-\n-use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n-use libc::{ftruncate, pread, pwrite};\n-\n-use crate::io;\n-use super::{cvt, cvt_r};\n-\n-// The `log2` and `log2f` functions apparently appeared in android-18, or at\n-// least you can see they're not present in the android-17 header [1] and they\n-// are present in android-18 [2].\n-//\n-// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-17/arch-arm/usr/include/math.h\n-// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-18/arch-arm/usr/include/math.h\n-//\n-// Note that these shims are likely less precise than directly calling `log2`,\n-// but hopefully that should be enough for now...\n-//\n-// Note that mathematically, for any arbitrary `y`:\n-//\n-//      log_2(x) = log_y(x) / log_y(2)\n-//               = log_y(x) / (1 / log_2(y))\n-//               = log_y(x) * log_2(y)\n-//\n-// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n-// and get:\n-//\n-//      log_2(x) = ln(x) * log_2(e)\n-\n-#[cfg(not(test))]\n-pub fn log2f32(f: f32) -> f32 {\n-    f.ln() * crate::f32::consts::LOG2_E\n-}\n-\n-#[cfg(not(test))]\n-pub fn log2f64(f: f64) -> f64 {\n-    f.ln() * crate::f64::consts::LOG2_E\n-}\n-\n-// Back in the day [1] the `signal` function was just an inline wrapper\n-// around `bsd_signal`, but starting in API level android-20 the `signal`\n-// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n-// removed [3].\n-//\n-// Basically this means that if we want to be binary compatible with multiple\n-// Android releases (oldest being 9 and newest being 21) then we need to check\n-// for both symbols and not actually link against either.\n-//\n-// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-18/arch-arm/usr/include/signal.h\n-// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n-//                                       /platforms/android-20/arch-arm\n-//                                       /usr/include/signal.h\n-// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n-//                                       /android-21/arch-arm/usr/include/signal.h\n-pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n-    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n-    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n-\n-    let f = signal.get().or_else(|| bsd_signal.get());\n-    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n-    f(signum, handler)\n-}\n-\n-// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n-// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n-//\n-// If it doesn't we just fall back to `ftruncate`, generating an error for\n-// too-large values.\n-#[cfg(target_pointer_width = \"32\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    weak!(fn ftruncate64(c_int, i64) -> c_int);\n-\n-    unsafe {\n-        match ftruncate64.get() {\n-            Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n-            None => {\n-                if size > i32::max_value() as u64 {\n-                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                       \"cannot truncate >2GB\"))\n-                } else {\n-                    cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    unsafe {\n-        cvt_r(|| ftruncate(fd, size as i64)).map(|_| ())\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    use crate::convert::TryInto;\n-    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n-    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pread(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pread >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    use crate::convert::TryInto;\n-    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n-    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pwrite(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pwrite >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    cvt(pread(fd, buf, count, offset))\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    cvt(pwrite(fd, buf, count, offset))\n-}"}, {"sha": "783c3eb7c766f3b49537df462992c724fd24f18a", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -62,10 +62,6 @@ impl Condvar {\n     // where we configure condition variable to use monotonic clock (instead of\n     // default system clock). This approach avoids all problems that result\n     // from changes made to the system time.\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"hermit\")))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -92,78 +88,9 @@ impl Condvar {\n     }\n \n \n-    // This implementation is modeled after libcxx's condition_variable\n-    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n-    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n-        use crate::ptr;\n-        use crate::time::Instant;\n-\n-        // 1000 years\n-        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n-\n-        if dur > max_dur {\n-            // OSX implementation of `pthread_cond_timedwait` is buggy\n-            // with super long durations. When duration is greater than\n-            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n-            // in macOS Sierra return error 316.\n-            //\n-            // This program demonstrates the issue:\n-            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n-            //\n-            // To work around this issue, and possible bugs of other OSes, timeout\n-            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n-            // because of spurious wakeups.\n-\n-            dur = max_dur;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and\n-        // stable time.  pthread_cond_timedwait uses system time, but we want to\n-        // report timeout based on stable time.\n-        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = Instant::now();\n-        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n-        debug_assert_eq!(r, 0);\n-\n-        let nsec = dur.subsec_nanos() as libc::c_long +\n-                   (sys_now.tv_usec * 1000) as libc::c_long;\n-        let extra = (nsec / 1_000_000_000) as libc::time_t;\n-        let nsec = nsec % 1_000_000_000;\n-        let seconds = saturating_cast_to_time_t(dur.as_secs());\n-\n-        let timeout = sys_now.tv_sec.checked_add(extra).and_then(|s| {\n-            s.checked_add(seconds)\n-        }).map(|s| {\n-            libc::timespec { tv_sec: s, tv_nsec: nsec }\n-        }).unwrap_or(TIMESPEC_MAX);\n-\n-        // And wait!\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n-                                            &timeout);\n-        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n-\n-        // ETIMEDOUT is not a totally reliable method of determining timeout due\n-        // to clock shifts, so do the check ourselves\n-        stable_now.elapsed() < dur\n-    }\n-\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_cond_destroy(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n-        // a condvar that was just initialized with\n-        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n-        // pthread_cond_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n-    }\n }"}, {"sha": "3f0a7e9e843199d9999bab826edce6e00a2da9a1", "filename": "src/libstd/sys/vxworks/ext/net.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -5,16 +5,6 @@\n #[cfg(unix)]\n use libc;\n \n-// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n-#[cfg(not(unix))]\n-mod libc {\n-    pub use libc::c_int;\n-    pub type socklen_t = u32;\n-    pub struct sockaddr;\n-    #[derive(Clone)]\n-    pub struct sockaddr_un;\n-}\n-\n use crate::ascii;\n use crate::ffi::OsStr;\n use crate::fmt;\n@@ -29,15 +19,6 @@ use crate::sys::{self, cvt};\n use crate::sys::net::Socket;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n \n-#[cfg(any(target_os = \"linux\", target_os = \"android\",\n-          target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"haiku\"))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n-              target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n@@ -202,13 +183,7 @@ impl SocketAddr {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n \n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n+        if self.addr.sun_path[0] == 0 {\n             AddressKind::Abstract(&path[1..len])\n         } else {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())"}, {"sha": "b3dd1cf6aaac7b8620ba75c26155810e1929adf7", "filename": "src/libstd/sys/vxworks/l4re.rs", "status": "removed", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,469 +0,0 @@\n-macro_rules! unimpl {\n-    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n-}\n-\n-pub mod net {\n-    #![allow(warnings)]\n-    use crate::fmt;\n-    use crate::io::{self, IoVec, IoVecMut};\n-    use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-    use crate::sys_common::{AsInner, FromInner, IntoInner};\n-    use crate::sys::fd::FileDesc;\n-    use crate::time::Duration;\n-    use crate::convert::TryFrom;\n-\n-    #[allow(unused_extern_crates)]\n-    pub extern crate libc as netc;\n-\n-    pub struct Socket(FileDesc);\n-    impl Socket {\n-        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n-                  -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn nodelay(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl AsInner<libc::c_int> for Socket {\n-        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n-    }\n-\n-    impl FromInner<libc::c_int> for Socket {\n-        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n-    }\n-\n-    impl IntoInner<libc::c_int> for Socket {\n-        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n-    }\n-\n-    pub struct TcpStream {\n-        inner: Socket,\n-    }\n-\n-    impl TcpStream {\n-        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn nodelay(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for TcpStream {\n-        fn from_inner(socket: Socket) -> TcpStream {\n-            TcpStream { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for TcpStream {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support available on L4Re\")\n-        }\n-    }\n-\n-    pub struct TcpListener {\n-        inner: Socket,\n-    }\n-\n-    impl TcpListener {\n-        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<TcpListener> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn only_v6(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for TcpListener {\n-        fn from_inner(socket: Socket) -> TcpListener {\n-            TcpListener { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for TcpListener {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support available on L4Re.\")\n-        }\n-    }\n-\n-    pub struct UdpSocket {\n-        inner: Socket,\n-    }\n-\n-    impl UdpSocket {\n-        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn broadcast(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n-        }\n-\n-        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n-        }\n-\n-        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n-        }\n-\n-        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for UdpSocket {\n-        fn from_inner(socket: Socket) -> UdpSocket {\n-            UdpSocket { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for UdpSocket {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support on L4Re available.\")\n-        }\n-    }\n-\n-    pub struct LookupHost {\n-        original: *mut libc::addrinfo,\n-        cur: *mut libc::addrinfo,\n-    }\n-\n-    impl Iterator for LookupHost {\n-        type Item = SocketAddr;\n-        fn next(&mut self) -> Option<SocketAddr> {\n-            None\n-        }\n-    }\n-\n-    impl LookupHost {\n-        pub fn port(&self) -> u16 {\n-            unimpl!();\n-        }\n-    }\n-\n-    unsafe impl Sync for LookupHost {}\n-    unsafe impl Send for LookupHost {}\n-\n-\n-    impl TryFrom<&str> for LookupHost {\n-        type Error = io::Error;\n-\n-        fn try_from(_v: &str) -> io::Result<LookupHost> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n-        type Error = io::Error;\n-\n-        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n-            unimpl!();\n-        }\n-    }\n-}"}, {"sha": "b5b4e6d9c134ee2f5e22329535efb9f2c41993ad", "filename": "src/libstd/sys/vxworks/memchr.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -16,25 +16,6 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n-        let p = unsafe {\n-            libc::memrchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len())\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"linux\"))]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         core::slice::memchr::memrchr(needle, haystack)\n     }"}, {"sha": "1eff4fbcd83b76f6fc73b32d145808ece1389f23", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -7,14 +7,8 @@ pub use crate::os::vxworks as platform;\n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;\n \n-#[macro_use]\n-pub mod weak;\n-\n pub mod alloc;\n pub mod args;\n-pub mod android;\n-//#[cfg(feature = \"backtrace\")]\n-//pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;\n@@ -25,12 +19,7 @@ pub mod fs;\n pub mod memchr;\n pub mod io;\n pub mod mutex;\n-#[cfg(not(target_os = \"l4re\"))]\n pub mod net;\n-#[cfg(target_os = \"l4re\")]\n-mod l4re;\n-#[cfg(target_os = \"l4re\")]\n-pub use self::l4re::net;\n pub mod os;\n pub mod path;\n pub mod pipe;\n@@ -61,9 +50,6 @@ pub fn init() {\n     unsafe fn reset_sigpipe() { }\n }\n \n-#[cfg(target_os = \"android\")]\n-pub use crate::sys::android::signal;\n-#[cfg(not(target_os = \"android\"))]\n pub use libc::signal;\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {"}, {"sha": "aa6b93c86006933e65dfbd01ce618b64a34df707", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -58,19 +58,6 @@ impl Socket {\n \n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n-            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n-            // atomically create the socket and set it as CLOEXEC. Support for\n-            // this option, however, was added in 2.6.27, and we still support\n-            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n-            // fallthrough to the fallback.\n-            if cfg!(target_os = \"linux\") {\n-                match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n-                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n             let fd = cvt(libc::socket(fam, ty, 0))?;\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec()?;"}, {"sha": "9fce5f5811f356bfd127e736cb68d5a3776017e7", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -422,46 +422,12 @@ mod tests {\n         }\n     }\n \n-    // Android with api less than 21 define sig* functions inline, so it is not\n-    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n-    // to support older Android version (independent of libc version).\n-    // The following implementations are based on https://git.io/vSkNf\n-\n-    #[cfg(not(target_os = \"android\"))]\n     extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n         fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n         fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n     }\n \n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n-        return 0;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use crate::slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n-    // See #14232 for more information, but it appears that signal delivery to a\n-    // newly spawned process may just be raced in the macOS, so to prevent this\n-    // test from being flaky we ignore it on macOS.\n     #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n-    // When run under our current QEMU emulation test suite this test fails,\n-    // although the reason isn't very clear as to why. For now this test is\n-    // ignored there.\n-    #[cfg_attr(target_arch = \"arm\", ignore)]\n-    #[cfg_attr(target_arch = \"aarch64\", ignore)]\n     fn test_process_mask() {\n         unsafe {\n             // Test to make sure that a signal mask does not get inherited."}, {"sha": "08e7b310ca1b83ed753289b63bfa4568ddbe7c99", "filename": "src/libstd/sys/vxworks/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -23,174 +23,6 @@ impl Drop for Handler {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"macos\",\n-          target_os = \"bitrig\",\n-          target_os = \"dragonfly\",\n-          target_os = \"freebsd\",\n-          target_os = \"solaris\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\"))]\n-mod imp {\n-    use super::Handler;\n-    use crate::mem;\n-    use crate::ptr;\n-\n-    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n-    use libc::{sigaction, SIGBUS, SIG_DFL,\n-               SA_SIGINFO, SA_ONSTACK, sighandler_t};\n-    use libc::{mmap, munmap};\n-    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n-    use libc::MAP_FAILED;\n-\n-    use crate::sys_common::thread_info;\n-\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n-        #[repr(C)]\n-        struct siginfo_t {\n-            a: [libc::c_int; 3], // si_signo, si_errno, si_code\n-            si_addr: *mut libc::c_void,\n-        }\n-\n-        (*(info as *const siginfo_t)).si_addr as usize\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n-        (*info).si_addr as usize\n-    }\n-\n-    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n-    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n-    // up running into the guard page it'll trigger this handler. We want to\n-    // detect these cases and print out a helpful error saying that the stack\n-    // has overflowed. All other signals, however, should go back to what they\n-    // were originally supposed to do.\n-    //\n-    // This handler currently exists purely to print an informative message\n-    // whenever a thread overflows its stack. We then abort to exit and\n-    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n-    // users to believe that unsafe code has accessed an invalid pointer; the\n-    // SIGSEGV encountered when overflowing the stack is expected and\n-    // well-defined.\n-    //\n-    // If this is not a stack overflow, the handler un-registers itself and\n-    // then returns (to allow the original signal to be delivered again).\n-    // Returning from this kind of signal handler is technically not defined\n-    // to work when reading the POSIX spec strictly, but in practice it turns\n-    // out many large systems and all implementations allow returning from a\n-    // signal handler to work. For a more detailed explanation see the\n-    // comments on #26458.\n-    unsafe extern fn signal_handler(signum: libc::c_int,\n-                                    info: *mut libc::siginfo_t,\n-                                    _data: *mut libc::c_void) {\n-        use crate::sys_common::util::report_overflow;\n-\n-        let guard = thread_info::stack_guard().unwrap_or(0..0);\n-        let addr = siginfo_si_addr(info);\n-\n-        // If the faulting address is within the guard page, then we print a\n-        // message saying so and abort.\n-        if guard.start <= addr && addr < guard.end {\n-            report_overflow();\n-            rtabort!(\"stack overflow\");\n-        } else {\n-            // Unregister ourselves by reverting back to the default behavior.\n-            let mut action: sigaction = mem::zeroed();\n-            action.sa_sigaction = SIG_DFL;\n-            sigaction(signum, &action, ptr::null_mut());\n-\n-            // See comment above for why this function returns.\n-        }\n-    }\n-\n-    static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n-\n-    pub unsafe fn init() {\n-        let mut action: sigaction = mem::zeroed();\n-        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n-        action.sa_sigaction = signal_handler as sighandler_t;\n-        sigaction(SIGSEGV, &action, ptr::null_mut());\n-        sigaction(SIGBUS, &action, ptr::null_mut());\n-\n-        let handler = make_handler();\n-        MAIN_ALTSTACK = handler._data;\n-        mem::forget(handler);\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        Handler { _data: MAIN_ALTSTACK };\n-    }\n-\n-    unsafe fn get_stackp() -> *mut libc::c_void {\n-        let stackp = mmap(ptr::null_mut(),\n-                          SIGSTKSZ,\n-                          PROT_READ | PROT_WRITE,\n-                          MAP_PRIVATE | MAP_ANON,\n-                          -1,\n-                          0);\n-        if stackp == MAP_FAILED {\n-            panic!(\"failed to allocate an alternative stack\");\n-        }\n-        stackp\n-    }\n-\n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"freebsd\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n-    unsafe fn get_stack() -> libc::stack_t {\n-        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n-    }\n-\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn get_stack() -> libc::stack_t {\n-        libc::stack_t { ss_sp: get_stackp() as *mut i8, ss_flags: 0, ss_size: SIGSTKSZ }\n-    }\n-\n-    pub unsafe fn make_handler() -> Handler {\n-        let mut stack = mem::zeroed();\n-        sigaltstack(ptr::null(), &mut stack);\n-        // Configure alternate signal stack, if one is not already set.\n-        if stack.ss_flags & SS_DISABLE != 0 {\n-            stack = get_stack();\n-            sigaltstack(&stack, ptr::null_mut());\n-            Handler { _data: stack.ss_sp as *mut libc::c_void }\n-        } else {\n-            Handler { _data: ptr::null_mut() }\n-        }\n-    }\n-\n-    pub unsafe fn drop_handler(handler: &mut Handler) {\n-        if !handler._data.is_null() {\n-            let stack =  libc::stack_t {\n-                ss_sp: ptr::null_mut(),\n-                ss_flags: SS_DISABLE,\n-                // Workaround for bug in macOS implementation of sigaltstack\n-                // UNIX2003 which returns ENOMEM when disabling a stack while\n-                // passing ss_size smaller than MINSIGSTKSZ. According to POSIX\n-                // both ss_sp and ss_size should be ignored in this case.\n-                ss_size: SIGSTKSZ,\n-            };\n-            sigaltstack(&stack, ptr::null_mut());\n-            munmap(handler._data, SIGSTKSZ);\n-        }\n-    }\n-}\n-\n-#[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"dragonfly\",\n-              target_os = \"freebsd\",\n-              target_os = \"solaris\",\n-              all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-              target_os = \"openbsd\")))]\n mod imp {\n     use crate::ptr;\n "}, {"sha": "58af8cbe48e3626522f633cc02a56ad740739126", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,4 +1,3 @@\n-//use crate::boxed::FnBox;\n use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n@@ -9,10 +8,7 @@ use crate::time::Duration;\n \n use crate::sys_common::thread::*;\n \n-#[cfg(not(target_os = \"l4re\"))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n-#[cfg(target_os = \"l4re\")]\n-pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n \n pub struct Thread {\n     id: libc::pthread_t,\n@@ -25,18 +21,11 @@ unsafe impl Sync for Thread {}\n \n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-#[cfg(not(target_os = \"emscripten\"))]\n unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                     stack_size: libc::size_t) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n-#[cfg(target_os = \"emscripten\")]\n-unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n-                                    _stack_size: libc::size_t) -> libc::c_int {\n-    panic!()\n-}\n-\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n@@ -149,31 +138,6 @@ pub mod guard {\n     pub unsafe fn deinit() {}\n }\n \n-// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n-// PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n-// storage.  We need that information to avoid blowing up when a small stack\n-// is created in an application with big thread-local storage requirements.\n-// See #6233 for rationale and details.\n-#[cfg(target_os = \"linux\")]\n-#[allow(deprecated)]\n-fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n-    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n-\n-    match __pthread_get_minstack.get() {\n-        None => libc::PTHREAD_STACK_MIN,\n-        Some(f) => unsafe { f(attr) },\n-    }\n-}\n-\n-// No point in looking up __pthread_get_minstack() on non-glibc\n-// platforms.\n-#[cfg(all(not(target_os = \"linux\"),\n-          not(target_os = \"netbsd\")))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     libc::PTHREAD_STACK_MIN\n }\n-\n-#[cfg(target_os = \"netbsd\")]\n-fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n-    2048 // just a guess\n-}"}, {"sha": "23964dc5bd5df9bf2233d8fea660dc8e51803d07", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -437,6 +437,33 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn file_size(&self) -> u64;\n+\n+    /// Returns the value of the `dwVolumeSerialNumber` field of this\n+    /// metadata.\n+    ///\n+    /// This will return `None` if the `Metadata` instance was created from a\n+    /// call to `DirEntry::metadata`. If this `Metadata` was created by using\n+    /// `fs::metadata` or `File::metadata`, then this will return `Some`.\n+    #[unstable(feature = \"windows_by_handle\", issue = \"63010\")]\n+    fn volume_serial_number(&self) -> Option<u32>;\n+\n+    /// Returns the value of the `nNumberOfLinks` field of this\n+    /// metadata.\n+    ///\n+    /// This will return `None` if the `Metadata` instance was created from a\n+    /// call to `DirEntry::metadata`. If this `Metadata` was created by using\n+    /// `fs::metadata` or `File::metadata`, then this will return `Some`.\n+    #[unstable(feature = \"windows_by_handle\", issue = \"63010\")]\n+    fn number_of_links(&self) -> Option<u32>;\n+\n+    /// Returns the value of the `nFileIndex{Low,High}` fields of this\n+    /// metadata.\n+    ///\n+    /// This will return `None` if the `Metadata` instance was created from a\n+    /// call to `DirEntry::metadata`. If this `Metadata` was created by using\n+    /// `fs::metadata` or `File::metadata`, then this will return `Some`.\n+    #[unstable(feature = \"windows_by_handle\", issue = \"63010\")]\n+    fn file_index(&self) -> Option<u64>;\n }\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -446,6 +473,9 @@ impl MetadataExt for Metadata {\n     fn last_access_time(&self) -> u64 { self.as_inner().accessed_u64() }\n     fn last_write_time(&self) -> u64 { self.as_inner().modified_u64() }\n     fn file_size(&self) -> u64 { self.as_inner().size() }\n+    fn volume_serial_number(&self) -> Option<u32> { self.as_inner().volume_serial_number() }\n+    fn number_of_links(&self) -> Option<u32> { self.as_inner().number_of_links() }\n+    fn file_index(&self) -> Option<u64> { self.as_inner().file_index() }\n }\n \n /// Windows-specific extensions to [`FileType`]."}, {"sha": "5bae6ba4749bd1e2f8bea3f0df94a5023e20ef39", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -25,6 +25,9 @@ pub struct FileAttr {\n     last_write_time: c::FILETIME,\n     file_size: u64,\n     reparse_tag: c::DWORD,\n+    volume_serial_number: Option<u32>,\n+    number_of_links: Option<u32>,\n+    file_index: Option<u64>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -156,6 +159,9 @@ impl DirEntry {\n                 } else {\n                     0\n                 },\n+            volume_serial_number: None,\n+            number_of_links: None,\n+            file_index: None,\n         })\n     }\n }\n@@ -291,23 +297,26 @@ impl File {\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         unsafe {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n-            cvt(c::GetFileInformationByHandle(self.handle.raw(),\n-                                              &mut info))?;\n-            let mut attr = FileAttr {\n-                attributes: info.dwFileAttributes,\n-                creation_time: info.ftCreationTime,\n-                last_access_time: info.ftLastAccessTime,\n-                last_write_time: info.ftLastWriteTime,\n-                file_size: ((info.nFileSizeHigh as u64) << 32) | (info.nFileSizeLow as u64),\n-                reparse_tag: 0,\n-            };\n-            if attr.is_reparse_point() {\n+            cvt(c::GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n+            let mut reparse_tag = 0;\n+            if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n                 let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    attr.reparse_tag = buf.ReparseTag;\n+                    reparse_tag = buf.ReparseTag;\n                 }\n             }\n-            Ok(attr)\n+            Ok(FileAttr {\n+                attributes: info.dwFileAttributes,\n+                creation_time: info.ftCreationTime,\n+                last_access_time: info.ftLastAccessTime,\n+                last_write_time: info.ftLastWriteTime,\n+                file_size: (info.nFileSizeLow as u64) | ((info.nFileSizeHigh as u64) << 32),\n+                reparse_tag,\n+                volume_serial_number: Some(info.dwVolumeSerialNumber),\n+                number_of_links: Some(info.nNumberOfLinks),\n+                file_index: Some((info.nFileIndexLow as u64) |\n+                                 ((info.nFileIndexHigh as u64) << 32)),\n+            })\n         }\n     }\n \n@@ -336,6 +345,9 @@ impl File {\n                 },\n                 file_size: 0,\n                 reparse_tag: 0,\n+                volume_serial_number: None,\n+                number_of_links: None,\n+                file_index: None,\n             };\n             let mut info: c::FILE_STANDARD_INFO = mem::zeroed();\n             let size = mem::size_of_val(&info);\n@@ -344,6 +356,7 @@ impl File {\n                                                 &mut info as *mut _ as *mut libc::c_void,\n                                                 size as c::DWORD))?;\n             attr.file_size = info.AllocationSize as u64;\n+            attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.is_reparse_point() {\n                 let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n@@ -507,7 +520,9 @@ impl FileAttr {\n         FilePermissions { attrs: self.attributes }\n     }\n \n-    pub fn attrs(&self) -> u32 { self.attributes as u32 }\n+    pub fn attrs(&self) -> u32 {\n+        self.attributes\n+    }\n \n     pub fn file_type(&self) -> FileType {\n         FileType::new(self.attributes, self.reparse_tag)\n@@ -537,8 +552,16 @@ impl FileAttr {\n         to_u64(&self.creation_time)\n     }\n \n-    fn is_reparse_point(&self) -> bool {\n-        self.attributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0\n+    pub fn volume_serial_number(&self) -> Option<u32> {\n+        self.volume_serial_number\n+    }\n+\n+    pub fn number_of_links(&self) -> Option<u32> {\n+        self.number_of_links\n+    }\n+\n+    pub fn file_index(&self) -> Option<u64> {\n+        self.file_index\n     }\n }\n "}, {"sha": "dbf14daa30e75e51bae34fd3a78a63dc1302e3e6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -92,7 +92,6 @@ use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n \n@@ -280,7 +279,7 @@ pub enum ParseResult<T> {\n \n /// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n-pub type NamedParseResult = ParseResult<FxHashMap<Ident, Rc<NamedMatch>>>;\n+pub type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n pub fn count_names(ms: &[TokenTree]) -> usize {\n@@ -373,7 +372,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n         sess: &ParseSess,\n         m: &TokenTree,\n         res: &mut I,\n-        ret_val: &mut FxHashMap<Ident, Rc<NamedMatch>>,\n+        ret_val: &mut FxHashMap<Ident, NamedMatch>,\n     ) -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => for next_m in &seq.tts {\n@@ -390,8 +389,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n             TokenTree::MetaVarDecl(sp, bind_name, _) => {\n                 match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n-                        // FIXME(simulacrum): Don't construct Rc here\n-                        spot.insert(Rc::new(res.next().unwrap()));\n+                        spot.insert(res.next().unwrap());\n                     }\n                     Occupied(..) => {\n                         return Err((sp, format!(\"duplicated bind name: {}\", bind_name)))"}, {"sha": "817d8547e87600aab902744571bed9c34f79aade", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -308,7 +308,7 @@ pub fn compile(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[&lhs_nm] {\n+    let lhses = match argument_map[&lhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {\n@@ -335,7 +335,7 @@ pub fn compile(\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match *argument_map[&rhs_nm] {\n+    let rhses = match argument_map[&rhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {\n@@ -625,38 +625,37 @@ impl FirstSets {\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n-                    match self.first.get(&sp.entire()) {\n-                        Some(&Some(ref subfirst)) => {\n-                            // If the sequence contents can be empty, then the first\n-                            // token could be the separator token itself.\n-\n-                            if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n-                                first.add_one_maybe(TokenTree::Token(sep.clone()));\n-                            }\n-\n-                            assert!(first.maybe_empty);\n-                            first.add_all(subfirst);\n-                            if subfirst.maybe_empty\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n-                            {\n-                                // continue scanning for more first\n-                                // tokens, but also make sure we\n-                                // restore empty-tracking state\n-                                first.maybe_empty = true;\n-                                continue;\n-                            } else {\n-                                return first;\n-                            }\n-                        }\n-\n+                    let subfirst_owned;\n+                    let subfirst = match self.first.get(&sp.entire()) {\n+                        Some(&Some(ref subfirst)) => subfirst,\n                         Some(&None) => {\n-                            panic!(\"assume all sequences have (unique) spans for now\");\n+                            subfirst_owned = self.first(&seq_rep.tts[..]);\n+                            &subfirst_owned\n                         }\n-\n                         None => {\n                             panic!(\"We missed a sequence during FirstSets construction\");\n                         }\n+                    };\n+\n+                    // If the sequence contents can be empty, then the first\n+                    // token could be the separator token itself.\n+                    if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n+                        first.add_one_maybe(TokenTree::Token(sep.clone()));\n+                    }\n+\n+                    assert!(first.maybe_empty);\n+                    first.add_all(subfirst);\n+                    if subfirst.maybe_empty\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                    {\n+                        // Continue scanning for more first\n+                        // tokens, but also make sure we\n+                        // restore empty-tracking state.\n+                        first.maybe_empty = true;\n+                        continue;\n+                    } else {\n+                        return first;\n                     }\n                 }\n             }"}, {"sha": "214e721fd1506dc838f2c0b28b19390f6271e774", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -12,7 +12,6 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n-use std::rc::Rc;\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n@@ -65,9 +64,9 @@ impl Iterator for Frame {\n /// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n ///\n /// Along the way, we do some additional error checking.\n-pub fn transcribe(\n+pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n-    interp: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n@@ -212,7 +211,7 @@ pub fn transcribe(\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n-                    if let MatchedNonterminal(ref nt) = *cur_matched {\n+                    if let MatchedNonterminal(ref nt) = cur_matched {\n                         // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n                         // (e.g. `$x:tt`), but not when we are matching any other type of token\n                         // tree?\n@@ -273,18 +272,17 @@ pub fn transcribe(\n /// See the definition of `repeats` in the `transcribe` function. `repeats` is used to descend\n /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n /// made a mistake, and we return `None`.\n-fn lookup_cur_matched(\n+fn lookup_cur_matched<'a>(\n     ident: Ident,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &'a FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n-) -> Option<Rc<NamedMatch>> {\n+) -> Option<&'a NamedMatch> {\n     interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched.clone();\n+        let mut matched = matched;\n         for &(idx, _) in repeats {\n-            let m = matched.clone();\n-            match *m {\n+            match matched {\n                 MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads, _) => matched = Rc::new(ads[idx].clone()),\n+                MatchedSeq(ref ads, _) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -343,7 +341,7 @@ impl LockstepIterSize {\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &quoted::TokenTree,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use quoted::TokenTree;\n@@ -360,7 +358,7 @@ fn lockstep_iter_size(\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(matched) => match *matched {\n+                Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n                     MatchedSeq(ref ads, _) => LockstepIterSize::Constraint(ads.len(), name),\n                 },"}, {"sha": "52f65e1b474754b5927eb12c59136fefd4bf03f8", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -389,8 +389,18 @@ impl<'a> StringReader<'a> {\n                                                           self.pos,\n                                                           \"unknown start of token\",\n                                                           c);\n-                unicode_chars::check_for_substitution(self, start, c, &mut err);\n-                return Err(err)\n+                // FIXME: the lexer could be used to turn the ASCII version of unicode homoglyphs,\n+                // instead of keeping a table in `check_for_substitution`into the token. Ideally,\n+                // this should be inside `rustc_lexer`. However, we should first remove compound\n+                // tokens like `<<` from `rustc_lexer`, and then add fancier error recovery to it,\n+                // as there will be less overall work to do this way.\n+                return match unicode_chars::check_for_substitution(self, start, c, &mut err) {\n+                    Some(token) => {\n+                        err.emit();\n+                        Ok(token)\n+                    }\n+                    None => Err(err),\n+                }\n             }\n         };\n         Ok(kind)"}, {"sha": "eaa736c6a351741a71ee29675592695bbb92dc67", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -3,7 +3,8 @@\n \n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION, symbol::kw};\n+use crate::parse::token;\n \n #[rustfmt::skip] // for line breaks\n const UNICODE_ARRAY: &[(char, &str, char)] = &[\n@@ -297,53 +298,59 @@ const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'),\n ];\n \n-const ASCII_ARRAY: &[(char, &str)] = &[\n-    (' ', \"Space\"),\n-    ('_', \"Underscore\"),\n-    ('-', \"Minus/Hyphen\"),\n-    (',', \"Comma\"),\n-    (';', \"Semicolon\"),\n-    (':', \"Colon\"),\n-    ('!', \"Exclamation Mark\"),\n-    ('?', \"Question Mark\"),\n-    ('.', \"Period\"),\n-    ('\\'', \"Single Quote\"),\n-    ('\"', \"Quotation Mark\"),\n-    ('(', \"Left Parenthesis\"),\n-    (')', \"Right Parenthesis\"),\n-    ('[', \"Left Square Bracket\"),\n-    (']', \"Right Square Bracket\"),\n-    ('{', \"Left Curly Brace\"),\n-    ('}', \"Right Curly Brace\"),\n-    ('*', \"Asterisk\"),\n-    ('/', \"Slash\"),\n-    ('\\\\', \"Backslash\"),\n-    ('&', \"Ampersand\"),\n-    ('+', \"Plus Sign\"),\n-    ('<', \"Less-Than Sign\"),\n-    ('=', \"Equals Sign\"),\n-    ('>', \"Greater-Than Sign\"),\n+// FIXME: the lexer could be used to turn the ASCII version of unicode homoglyphs, instead of\n+// keeping the substitution token in this table. Ideally, this should be inside `rustc_lexer`.\n+// However, we should first remove compound tokens like `<<` from `rustc_lexer`, and then add\n+// fancier error recovery to it, as there will be less overall work to do this way.\n+const ASCII_ARRAY: &[(char, &str, Option<token::TokenKind>)] = &[\n+    (' ', \"Space\", Some(token::Whitespace)),\n+    ('_', \"Underscore\", Some(token::Ident(kw::Underscore, false))),\n+    ('-', \"Minus/Hyphen\", Some(token::BinOp(token::Minus))),\n+    (',', \"Comma\", Some(token::Comma)),\n+    (';', \"Semicolon\", Some(token::Semi)),\n+    (':', \"Colon\", Some(token::Colon)),\n+    ('!', \"Exclamation Mark\", Some(token::Not)),\n+    ('?', \"Question Mark\", Some(token::Question)),\n+    ('.', \"Period\", Some(token::Dot)),\n+    ('(', \"Left Parenthesis\", Some(token::OpenDelim(token::Paren))),\n+    (')', \"Right Parenthesis\", Some(token::CloseDelim(token::Paren))),\n+    ('[', \"Left Square Bracket\", Some(token::OpenDelim(token::Bracket))),\n+    (']', \"Right Square Bracket\", Some(token::CloseDelim(token::Bracket))),\n+    ('{', \"Left Curly Brace\", Some(token::OpenDelim(token::Brace))),\n+    ('}', \"Right Curly Brace\", Some(token::CloseDelim(token::Brace))),\n+    ('*', \"Asterisk\", Some(token::BinOp(token::Star))),\n+    ('/', \"Slash\", Some(token::BinOp(token::Slash))),\n+    ('\\\\', \"Backslash\", None),\n+    ('&', \"Ampersand\", Some(token::BinOp(token::And))),\n+    ('+', \"Plus Sign\", Some(token::BinOp(token::Plus))),\n+    ('<', \"Less-Than Sign\", Some(token::Lt)),\n+    ('=', \"Equals Sign\", Some(token::Eq)),\n+    ('>', \"Greater-Than Sign\", Some(token::Gt)),\n+    // FIXME: Literals are already lexed by this point, so we can't recover gracefully just by\n+    // spitting the correct token out.\n+    ('\\'', \"Single Quote\", None),\n+    ('\"', \"Quotation Mark\", None),\n ];\n \n crate fn check_for_substitution<'a>(\n     reader: &StringReader<'a>,\n     pos: BytePos,\n     ch: char,\n     err: &mut DiagnosticBuilder<'a>,\n-) -> bool {\n+) -> Option<token::TokenKind> {\n     let (u_name, ascii_char) = match UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) {\n         Some(&(_u_char, u_name, ascii_char)) => (u_name, ascii_char),\n-        None => return false,\n+        None => return None,\n     };\n \n     let span = Span::new(pos, pos + Pos::from_usize(ch.len_utf8()), NO_EXPANSION);\n \n-    let ascii_name = match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n-        Some((_ascii_char, ascii_name)) => ascii_name,\n+    let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n+        Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n         None => {\n             let msg = format!(\"substitution character not found for '{}'\", ch);\n             reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n-            return false;\n+            return None;\n         }\n     };\n \n@@ -371,7 +378,7 @@ crate fn check_for_substitution<'a>(\n         );\n         err.span_suggestion(span, &msg, ascii_char.to_string(), Applicability::MaybeIncorrect);\n     }\n-    true\n+    token.clone()\n }\n \n /// Extract string if found at current position with given delimiters"}, {"sha": "1d23bac4ee2068aacdb906da98c93c9be1122f7b", "filename": "src/test/mir-opt/lower_128bit_debug_test.rs", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,226 +0,0 @@\n-// asmjs can't even pass i128 as arguments or return values, so ignore it.\n-// this will hopefully be fixed by the LLVM 5 upgrade (#43370)\n-// ignore-asmjs\n-// ignore-emscripten\n-\n-// compile-flags: -Z lower_128bit_ops=yes -C debug_assertions=yes\n-\n-static TEST_SIGNED: i128 = const_signed(-222);\n-static TEST_UNSIGNED: u128 = const_unsigned(200);\n-\n-const fn const_signed(mut x: i128) -> i128 {\n-    ((((((x + 1) - 2) * 3) / 4) % 5) << 6) >> 7\n-}\n-\n-const fn const_unsigned(mut x: u128) -> u128 {\n-    ((((((x + 1) - 2) * 3) / 4) % 5) << 6) >> 7\n-}\n-\n-fn test_signed(mut x: i128) -> i128 {\n-    x += 1;\n-    x -= 2;\n-    x *= 3;\n-    x /= 4;\n-    x %= 5;\n-    x <<= 6;\n-    x >>= 7;\n-    x\n-}\n-\n-fn test_unsigned(mut x: u128) -> u128 {\n-    x += 1;\n-    x -= 2;\n-    x *= 3;\n-    x /= 4;\n-    x %= 5;\n-    x <<= 6;\n-    x >>= 7;\n-    x\n-}\n-\n-fn check(x: i128, y: u128) {\n-    assert_eq!(test_signed(x), -1);\n-    assert_eq!(const_signed(x), -1);\n-    assert_eq!(TEST_SIGNED, -1);\n-    assert_eq!(test_unsigned(y), 2);\n-    assert_eq!(const_unsigned(y), 2);\n-    assert_eq!(TEST_UNSIGNED, 2);\n-}\n-\n-fn main() {\n-    check(-222, 200);\n-}\n-\n-// END RUST SOURCE\n-\n-// START rustc.const_signed.Lower128Bit.after.mir\n-//     _8 = _1;\n-//     _9 = const compiler_builtins::int::addsub::rust_i128_addo(move _8, const 1i128) -> bb10;\n-//     ...\n-//     _7 = move (_9.0: i128);\n-//     ...\n-//     _10 = const compiler_builtins::int::addsub::rust_i128_subo(move _7, const 2i128) -> bb11;\n-//     ...\n-//     _6 = move (_10.0: i128);\n-//     ...\n-//     _11 = const compiler_builtins::int::mul::rust_i128_mulo(move _6, const 3i128) -> bb12;\n-//     ...\n-//     _5 = move (_11.0: i128);\n-//     ...\n-//     _12 = Eq(const 4i128, const 0i128);\n-//     assert(!move _12, \"attempt to divide by zero\") -> bb4;\n-//     ...\n-//     _13 = Eq(const 4i128, const -1i128);\n-//     _14 = Eq(_5, const -170141183460469231731687303715884105728i128);\n-//     _15 = BitAnd(move _13, move _14);\n-//     assert(!move _15, \"attempt to divide with overflow\") -> bb5;\n-//     ...\n-//     _4 = const compiler_builtins::int::sdiv::rust_i128_div(move _5, const 4i128) -> bb13;\n-//     ...\n-//     _17 = Eq(const 5i128, const -1i128);\n-//     _18 = Eq(_4, const -170141183460469231731687303715884105728i128);\n-//     _19 = BitAnd(move _17, move _18);\n-//     assert(!move _19, \"attempt to calculate the remainder with overflow\") -> bb7;\n-//     ...\n-//     _3 = const compiler_builtins::int::sdiv::rust_i128_rem(move _4, const 5i128) -> bb15;\n-//     ...\n-//     _2 = move (_20.0: i128);\n-//     ...\n-//     _23 = const 7i32 as u128 (Misc);\n-//     _21 = const compiler_builtins::int::shift::rust_i128_shro(move _2, move _23) -> bb16;\n-//     ...\n-//     _0 = move (_21.0: i128);\n-//     ...\n-//     assert(!move (_9.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_10.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_11.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     _16 = Eq(const 5i128, const 0i128);\n-//     assert(!move _16, \"attempt to calculate the remainder with a divisor of zero\") -> bb6;\n-//     ...\n-//     assert(!move (_20.1: bool), \"attempt to shift left with overflow\") -> bb8;\n-//     ...\n-//     _22 = const 6i32 as u128 (Misc);\n-//     _20 = const compiler_builtins::int::shift::rust_i128_shlo(move _3, move _22) -> bb14;\n-//     ...\n-//     assert(!move (_21.1: bool), \"attempt to shift right with overflow\") -> bb9;\n-// END rustc.const_signed.Lower128Bit.after.mir\n-\n-// START rustc.const_unsigned.Lower128Bit.after.mir\n-//     _8 = _1;\n-//     _9 = const compiler_builtins::int::addsub::rust_u128_addo(move _8, const 1u128) -> bb8;\n-//     ...\n-//     _7 = move (_9.0: u128);\n-//     ...\n-//     _10 = const compiler_builtins::int::addsub::rust_u128_subo(move _7, const 2u128) -> bb9;\n-//     ...\n-//     _6 = move (_10.0: u128);\n-//     ...\n-//     _11 = const compiler_builtins::int::mul::rust_u128_mulo(move _6, const 3u128) -> bb10;\n-//     ...\n-//     _5 = move (_11.0: u128);\n-//     ...\n-//     _12 = Eq(const 4u128, const 0u128);\n-//     assert(!move _12, \"attempt to divide by zero\") -> bb4;\n-//     ...\n-//     _4 = const compiler_builtins::int::udiv::rust_u128_div(move _5, const 4u128) -> bb11;\n-//     ...\n-//     _3 = const compiler_builtins::int::udiv::rust_u128_rem(move _4, const 5u128) -> bb13;\n-//     ...\n-//     _2 = move (_14.0: u128);\n-//     ...\n-//     _17 = const 7i32 as u128 (Misc);\n-//     _15 = const compiler_builtins::int::shift::rust_u128_shro(move _2, move _17) -> bb14;\n-//     ...\n-//     _0 = move (_15.0: u128);\n-//     ...\n-//     assert(!move (_9.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_10.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_11.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     _13 = Eq(const 5u128, const 0u128);\n-//     assert(!move _13, \"attempt to calculate the remainder with a divisor of zero\") -> bb5;\n-//     ...\n-//     assert(!move (_14.1: bool), \"attempt to shift left with overflow\") -> bb6;\n-//     ...\n-//     _16 = const 6i32 as u128 (Misc);\n-//     _14 = const compiler_builtins::int::shift::rust_u128_shlo(move _3, move _16) -> bb12;\n-//     ...\n-//     assert(!move (_15.1: bool), \"attempt to shift right with overflow\") -> bb7;\n-// END rustc.const_unsigned.Lower128Bit.after.mir\n-\n-// START rustc.test_signed.Lower128Bit.after.mir\n-//     _2 = const compiler_builtins::int::addsub::rust_i128_addo(_1, const 1i128) -> bb10;\n-//     ...\n-//     _1 = move (_2.0: i128);\n-//     _3 = const compiler_builtins::int::addsub::rust_i128_subo(_1, const 2i128) -> bb11;\n-//     ...\n-//     _1 = move (_3.0: i128);\n-//     _4 = const compiler_builtins::int::mul::rust_i128_mulo(_1, const 3i128) -> bb12;\n-//     ...\n-//     _1 = move (_4.0: i128);\n-//     ...\n-//     _1 = const compiler_builtins::int::sdiv::rust_i128_div(_1, const 4i128) -> bb13;\n-//     ...\n-//     _1 = const compiler_builtins::int::sdiv::rust_i128_rem(_1, const 5i128) -> bb15;\n-//     ...\n-//     _1 = move (_13.0: i128);\n-//     ...\n-//     _16 = const 7i32 as u128 (Misc);\n-//     _14 = const compiler_builtins::int::shift::rust_i128_shro(_1, move _16) -> bb16;\n-//     ...\n-//     _1 = move (_14.0: i128);\n-//     ...\n-//     assert(!move (_2.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_3.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_4.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     assert(!move (_13.1: bool), \"attempt to shift left with overflow\") -> bb8;\n-//     ...\n-//     _15 = const 6i32 as u128 (Misc);\n-//     _13 = const compiler_builtins::int::shift::rust_i128_shlo(_1, move _15) -> bb14;\n-//     ...\n-//     assert(!move (_14.1: bool), \"attempt to shift right with overflow\") -> bb9;\n-// END rustc.test_signed.Lower128Bit.after.mir\n-\n-// START rustc.test_unsigned.Lower128Bit.after.mir\n-//     _2 = const compiler_builtins::int::addsub::rust_u128_addo(_1, const 1u128) -> bb8;\n-//     ...\n-//     _1 = move (_2.0: u128);\n-//     _3 = const compiler_builtins::int::addsub::rust_u128_subo(_1, const 2u128) -> bb9;\n-//     ...\n-//     _1 = move (_3.0: u128);\n-//     _4 = const compiler_builtins::int::mul::rust_u128_mulo(_1, const 3u128) -> bb10;\n-//     ...\n-//     _1 = move (_4.0: u128);\n-//     ...\n-//     _1 = const compiler_builtins::int::udiv::rust_u128_div(_1, const 4u128) -> bb11;\n-//     ...\n-//     _1 = const compiler_builtins::int::udiv::rust_u128_rem(_1, const 5u128) -> bb13;\n-//     ...\n-//     _1 = move (_7.0: u128);\n-//     ...\n-//     _10 = const 7i32 as u128 (Misc);\n-//     _8 = const compiler_builtins::int::shift::rust_u128_shro(_1, move _10) -> bb14;\n-//     ...\n-//     _1 = move (_8.0: u128);\n-//     ...\n-//     assert(!move (_2.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_3.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_4.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     assert(!move (_7.1: bool), \"attempt to shift left with overflow\") -> bb6;\n-//     ...\n-//     _9 = const 6i32 as u128 (Misc);\n-//     _7 = const compiler_builtins::int::shift::rust_u128_shlo(_1, move _9) -> bb12;\n-//     ...\n-//     assert(!move (_8.1: bool), \"attempt to shift right with overflow\") -> bb7;\n-// END rustc.test_unsigned.Lower128Bit.after.mir"}, {"sha": "7528330b030ce20b1ebf86631b5a6e7093b87594", "filename": "src/test/mir-opt/lower_128bit_test.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,149 +0,0 @@\n-// ignore-emscripten\n-\n-// compile-flags: -Z lower_128bit_ops=yes -C debug_assertions=no -O\n-\n-static TEST_SIGNED: i128 = const_signed(-222);\n-static TEST_UNSIGNED: u128 = const_unsigned(200);\n-\n-const fn const_signed(mut x: i128) -> i128 {\n-    ((((((x + 1) - 2) * 3) / 4) % 5) << 6) >> 7\n-}\n-\n-const fn const_unsigned(mut x: u128) -> u128 {\n-    ((((((x + 1) - 2) * 3) / 4) % 5) << 6) >> 7\n-}\n-\n-fn test_signed(mut x: i128) -> i128 {\n-    x += 1;\n-    x -= 2;\n-    x *= 3;\n-    x /= 4;\n-    x %= 5;\n-    x <<= 6;\n-    x >>= 7;\n-    x\n-}\n-\n-fn test_unsigned(mut x: u128) -> u128 {\n-    x += 1;\n-    x -= 2;\n-    x *= 3;\n-    x /= 4;\n-    x %= 5;\n-    x <<= 6;\n-    x >>= 7;\n-    x\n-}\n-\n-fn check(x: i128, y: u128) {\n-    assert_eq!(test_signed(x), -1);\n-    assert_eq!(const_signed(x), -1);\n-    assert_eq!(TEST_SIGNED, -1);\n-    assert_eq!(test_unsigned(y), 2);\n-    assert_eq!(const_unsigned(y), 2);\n-    assert_eq!(TEST_UNSIGNED, 2);\n-}\n-\n-fn main() {\n-    check(-222, 200);\n-}\n-\n-// END RUST SOURCE\n-\n-// START rustc.const_signed.Lower128Bit.after.mir\n-// _7 = const compiler_builtins::int::addsub::rust_i128_add(move _8, const 1i128) -> bb7;\n-// ...\n-// _10 = Eq(const 4i128, const -1i128);\n-// _11 = Eq(_5, const -170141183460469231731687303715884105728i128);\n-// _12 = BitAnd(move _10, move _11);\n-// assert(!move _12, \"attempt to divide with overflow\") -> bb2;\n-// ...\n-// _4 = const compiler_builtins::int::sdiv::rust_i128_div(move _5, const 4i128) -> bb8;\n-// ...\n-// _14 = Eq(const 5i128, const -1i128);\n-// _15 = Eq(_4, const -170141183460469231731687303715884105728i128);\n-// _16 = BitAnd(move _14, move _15);\n-// assert(!move _16, \"attempt to calculate the remainder with overflow\") -> bb4;\n-// ...\n-// _3 = const compiler_builtins::int::sdiv::rust_i128_rem(move _4, const 5i128) -> bb11;\n-// ...\n-// _9 = Eq(const 4i128, const 0i128);\n-// assert(!move _9, \"attempt to divide by zero\") -> bb1;\n-// ...\n-// _5 = const compiler_builtins::int::mul::rust_i128_mul(move _6, const 3i128) -> bb5;\n-// ...\n-// _6 = const compiler_builtins::int::addsub::rust_i128_sub(move _7, const 2i128) -> bb6;\n-// ...\n-// _13 = Eq(const 5i128, const 0i128);\n-// assert(!move _13, \"attempt to calculate the remainder with a divisor of zero\") -> bb3;\n-// ...\n-// _17 = const 7i32 as u32 (Misc);\n-// _0 = const compiler_builtins::int::shift::rust_i128_shr(move _2, move _17) -> bb9;\n-// ...\n-// _18 = const 6i32 as u32 (Misc);\n-// _2 = const compiler_builtins::int::shift::rust_i128_shl(move _3, move _18) -> bb10;\n-// END rustc.const_signed.Lower128Bit.after.mir\n-\n-// START rustc.const_unsigned.Lower128Bit.after.mir\n-// _8 = _1;\n-// _7 = const compiler_builtins::int::addsub::rust_u128_add(move _8, const 1u128) -> bb5;\n-// ...\n-// _4 = const compiler_builtins::int::udiv::rust_u128_div(move _5, const 4u128) -> bb6;\n-// ...\n-// _3 = const compiler_builtins::int::udiv::rust_u128_rem(move _4, const 5u128) -> bb9;\n-// ...\n-// _9 = Eq(const 4u128, const 0u128);\n-// assert(!move _9, \"attempt to divide by zero\") -> bb1;\n-// ...\n-// _5 = const compiler_builtins::int::mul::rust_u128_mul(move _6, const 3u128) -> bb3;\n-// ...\n-// _6 = const compiler_builtins::int::addsub::rust_u128_sub(move _7, const 2u128) -> bb4;\n-// ...\n-// _10 = Eq(const 5u128, const 0u128);\n-// assert(!move _10, \"attempt to calculate the remainder with a divisor of zero\") -> bb2;\n-// ...\n-// return;\n-// ...\n-// _11 = const 7i32 as u32 (Misc);\n-// _0 = const compiler_builtins::int::shift::rust_u128_shr(move _2, move _11) -> bb7;\n-// ...\n-// _12 = const 6i32 as u32 (Misc);\n-// _2 = const compiler_builtins::int::shift::rust_u128_shl(move _3, move _12) -> bb8;\n-\n-// END rustc.const_unsigned.Lower128Bit.after.mir\n-\n-// START rustc.test_signed.Lower128Bit.after.mir\n-//     _1 = const compiler_builtins::int::addsub::rust_i128_add(_1, const 1i128) -> bb7;\n-//     ...\n-//     _1 = const compiler_builtins::int::sdiv::rust_i128_div(_1, const 4i128) -> bb8;\n-//     ...\n-//     _1 = const compiler_builtins::int::sdiv::rust_i128_rem(_1, const 5i128) -> bb11;\n-//     ...\n-//     _1 = const compiler_builtins::int::mul::rust_i128_mul(_1, const 3i128) -> bb5;\n-//     ...\n-//     _1 = const compiler_builtins::int::addsub::rust_i128_sub(_1, const 2i128) -> bb6;\n-//     ...\n-//     _10 = const 7i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_i128_shr(_1, move _10) -> bb9;\n-//     ...\n-//     _11 = const 6i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_i128_shl(_1, move _11) -> bb10;\n-// END rustc.test_signed.Lower128Bit.after.mir\n-\n-// START rustc.test_unsigned.Lower128Bit.after.mir\n-//     _1 = const compiler_builtins::int::addsub::rust_u128_add(_1, const 1u128) -> bb5;\n-//     ...\n-//     _1 = const compiler_builtins::int::udiv::rust_u128_div(_1, const 4u128) -> bb6;\n-//     ...\n-//     _1 = const compiler_builtins::int::udiv::rust_u128_rem(_1, const 5u128) -> bb9;\n-//     ...\n-//     _1 = const compiler_builtins::int::mul::rust_u128_mul(_1, const 3u128) -> bb3;\n-//     ...\n-//     _1 = const compiler_builtins::int::addsub::rust_u128_sub(_1, const 2u128) -> bb4;\n-//     ...\n-//     _4 = const 7i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_u128_shr(_1, move _4) -> bb7;\n-//     ...\n-//     _5 = const 6i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_u128_shl(_1, move _5) -> bb8;\n-// END rustc.test_unsigned.Lower128Bit.after.mir"}, {"sha": "4195444a73f671ba607ae9c57e25dd9014b20b75", "filename": "src/test/run-pass/simd/simd-intrinsic-generic-reduction.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -2,7 +2,7 @@\n #![allow(non_camel_case_types)]\n \n // ignore-emscripten\n-// ignore-aarch64 FIXME: https://github.com/rust-lang/rust/issues/54510\n+// min-system-llvm-version: 9.0\n \n // Test that the simd_reduce_{op} intrinsics produce the correct results.\n \n@@ -124,14 +124,14 @@ fn main() {\n         assert_eq!(r, 6_f32);\n         let r: f32 = simd_reduce_mul_unordered(x);\n         assert_eq!(r, -24_f32);\n-        // FIXME: only works correctly for accumulator, 0:\n-        // https://bugs.llvm.org/show_bug.cgi?id=36734\n         let r: f32 = simd_reduce_add_ordered(x, 0.);\n         assert_eq!(r, 6_f32);\n-        // FIXME: only works correctly for accumulator, 1:\n-        // https://bugs.llvm.org/show_bug.cgi?id=36734\n         let r: f32 = simd_reduce_mul_ordered(x, 1.);\n         assert_eq!(r, -24_f32);\n+        let r: f32 = simd_reduce_add_ordered(x, 1.);\n+        assert_eq!(r, 7_f32);\n+        let r: f32 = simd_reduce_mul_ordered(x, 2.);\n+        assert_eq!(r, -48_f32);\n \n         let r: f32 = simd_reduce_min(x);\n         assert_eq!(r, -2_f32);"}, {"sha": "806acf0bed5d1887c435e9aa870cec8b30f8770c", "filename": "src/test/ui/annotate-snippet/missing-type.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,6 +1,6 @@\n error[E0412]: cannot find type `Iter` in this scope\n- --> $DIR/missing-type.rs:4:11\n-  |\n-4 |     let x: Iter;\n-  |            ^^^^ not found in this scope\n-  |\n+  --> $DIR/missing-type.rs:4:11\n+   |\n+LL |     let x: Iter;\n+   |            ^^^^ not found in this scope\n+   |"}, {"sha": "66d562d2eb51985020bf9721a3551eafff28ca58", "filename": "src/test/ui/did_you_mean/issue-49746-unicode-confusable-in-float-literal-expt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,5 +1,6 @@\n const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e\u221211; // m\u00b3\u22c5kg\u207b\u00b9\u22c5s\u207b\u00b2\n //~^ ERROR expected at least one digit in exponent\n //~| ERROR unknown start of token: \\u{2212}\n+//~| ERROR cannot subtract `{integer}` from `{float}`\n \n fn main() {}"}, {"sha": "9ee86adec52d9b27f92426fb6e238e526ffb0497", "filename": "src/test/ui/did_you_mean/issue-49746-unicode-confusable-in-float-literal-expt.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -14,5 +14,14 @@ help: Unicode character '\u2212' (Minus Sign) looks like '-' (Minus/Hyphen), but it\n LL | const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e-11; // m\u00b3\u22c5kg\u207b\u00b9\u22c5s\u207b\u00b2\n    |                                                     ^\n \n-error: aborting due to 2 previous errors\n+error[E0277]: cannot subtract `{integer}` from `{float}`\n+  --> $DIR/issue-49746-unicode-confusable-in-float-literal-expt.rs:1:53\n+   |\n+LL | const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e\u221211; // m\u00b3\u22c5kg\u207b\u00b9\u22c5s\u207b\u00b2\n+   |                                                     ^ no implementation for `{float} - {integer}`\n+   |\n+   = help: the trait `std::ops::Sub<{integer}>` is not implemented for `{float}`\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "67feb3ff6aec3a98457c1b87efba2fdfb27e706b", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &Some(42).as_deref();\n+//~^ ERROR no method named `as_deref` found for type `std::option::Option<{integer}>`\n+}"}, {"sha": "345f91437b82725ea92e7b25d0ada275d9938db7", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref` found for type `std::option::Option<{integer}>` in the current scope\n+  --> $DIR/option-as_deref.rs:4:29\n+   |\n+LL |     let _result = &Some(42).as_deref();\n+   |                             ^^^^^^^^ help: there is a method with a similar name: `as_ref`\n+   |\n+   = note: the method `as_deref` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::Deref`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "56aead8d0e00d2bcda6c445dbad592e37645b6d2", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &mut Some(42).as_deref_mut();\n+//~^ ERROR no method named `as_deref_mut` found for type `std::option::Option<{integer}>`\n+}"}, {"sha": "2c3a18be67c8f5d51f722d6b0ce2326218e9587f", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_mut` found for type `std::option::Option<{integer}>` in the current scope\n+  --> $DIR/option-as_deref_mut.rs:4:33\n+   |\n+LL |     let _result = &mut Some(42).as_deref_mut();\n+   |                                 ^^^^^^^^^^^^\n+   |\n+   = note: the method `as_deref_mut` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::DerefMut`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "f82eafcaffa9a624687a7593e08d0e81d980866b", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-deref.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Some(42).deref();\n-//~^ ERROR no method named `deref` found for type `std::option::Option<{integer}>`\n-}"}, {"sha": "e916b7d7d3447889f0e154fb2b40c15a2c0f59d7", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-deref.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-deref.stderr?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `deref` found for type `std::option::Option<{integer}>` in the current scope\n-  --> $DIR/option-deref.rs:4:29\n-   |\n-LL |     let _result = &Some(42).deref();\n-   |                             ^^^^^\n-   |\n-   = note: the method `deref` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::Deref`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "1d5eabd6170b72ccb3509fd630f6f6a9cda19e82", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &Ok(42).as_deref();\n+//~^ ERROR no method named `as_deref` found\n+}"}, {"sha": "5e016748770dc98ebade3318b8134c9759e31dc4", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref` found for type `std::result::Result<{integer}, _>` in the current scope\n+  --> $DIR/result-as_deref.rs:4:27\n+   |\n+LL |     let _result = &Ok(42).as_deref();\n+   |                           ^^^^^^^^ help: there is a method with a similar name: `as_ref`\n+   |\n+   = note: the method `as_deref` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::Deref`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "104aa3bcadff2e5ea2678333119d5b3a54b98bd7", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &Err(41).as_deref_err();\n+//~^ ERROR no method named `as_deref_err` found\n+}"}, {"sha": "6dc13da548b1246a81e3597ea23b3e6cb9225f48", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_err` found for type `std::result::Result<_, {integer}>` in the current scope\n+  --> $DIR/result-as_deref_err.rs:4:28\n+   |\n+LL |     let _result = &Err(41).as_deref_err();\n+   |                            ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_ok`\n+   |\n+   = note: the method `as_deref_err` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::Deref`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "c897ab3531f0ef26ce0735d4b5bd58a783b1ccd5", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &mut Ok(42).as_deref_mut();\n+//~^ ERROR no method named `as_deref_mut` found\n+}"}, {"sha": "f21e97388b6f4084b2453c4db26ac83d64fc8510", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_mut` found for type `std::result::Result<{integer}, _>` in the current scope\n+  --> $DIR/result-as_deref_mut.rs:4:31\n+   |\n+LL |     let _result = &mut Ok(42).as_deref_mut();\n+   |                               ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_err`\n+   |\n+   = note: the method `as_deref_mut` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::DerefMut`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "b7849ecb6d2422e3355784baca290883c612252d", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &mut Err(41).as_deref_mut_err();\n+//~^ ERROR no method named `as_deref_mut_err` found\n+}"}, {"sha": "44c0c954eeeca414dd1a5f1d6bbde25f707d5853", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_mut_err` found for type `std::result::Result<_, {integer}>` in the current scope\n+  --> $DIR/result-as_deref_mut_err.rs:4:32\n+   |\n+LL |     let _result = &mut Err(41).as_deref_mut_err();\n+   |                                ^^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut_ok`\n+   |\n+   = note: the method `as_deref_mut_err` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::DerefMut`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "54b695a0865f120546bfc199edaf281dc8aa3281", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_ok.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &mut Ok(42).as_deref_mut_ok();\n+//~^ ERROR no method named `as_deref_mut_ok` found\n+}"}, {"sha": "b8369c9b82e1a6d267e510da1a7362aeec4c876c", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_ok.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_mut_ok` found for type `std::result::Result<{integer}, _>` in the current scope\n+  --> $DIR/result-as_deref_mut_ok.rs:4:31\n+   |\n+LL |     let _result = &mut Ok(42).as_deref_mut_ok();\n+   |                               ^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut_err`\n+   |\n+   = note: the method `as_deref_mut_ok` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::DerefMut`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "ebb0500e8190fdc9309291450952d3496a2dbb83", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_ok.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inner_deref)]\n+\n+fn main() {\n+    let _result = &Ok(42).as_deref_ok();\n+//~^ ERROR no method named `as_deref_ok` found\n+}"}, {"sha": "b26705a99e3bcee38fb3e0aca0e4223dc32f7ec6", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_ok.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `as_deref_ok` found for type `std::result::Result<{integer}, _>` in the current scope\n+  --> $DIR/result-as_deref_ok.rs:4:27\n+   |\n+LL |     let _result = &Ok(42).as_deref_ok();\n+   |                           ^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_err`\n+   |\n+   = note: the method `as_deref_ok` exists but the following trait bounds were not satisfied:\n+           `{integer} : std::ops::Deref`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "4be2000f058a5d44ad5d604f76e6afb5c5d37ad8", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref-err.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Err(41).deref_err();\n-//~^ ERROR no method named `deref_err` found\n-}"}, {"sha": "333036127eadbd0fe4d34e4b5402c04fda871067", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref-err.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `deref_err` found for type `std::result::Result<_, {integer}>` in the current scope\n-  --> $DIR/result-deref-err.rs:4:28\n-   |\n-LL |     let _result = &Err(41).deref_err();\n-   |                            ^^^^^^^^^ help: there is a method with a similar name: `deref_ok`\n-   |\n-   = note: the method `deref_err` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::Deref`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "a706cde734805f8e02d149ca9d0e7cb114023149", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref-ok.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Ok(42).deref_ok();\n-//~^ ERROR no method named `deref_ok` found\n-}"}, {"sha": "593705123540c44fbffea8ebd8a38de27911269d", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref-ok.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-ok.stderr?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `deref_ok` found for type `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-deref-ok.rs:4:27\n-   |\n-LL |     let _result = &Ok(42).deref_ok();\n-   |                           ^^^^^^^^\n-   |\n-   = note: the method `deref_ok` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::Deref`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "43a68e37dd0c319cdd4dcbb25fd36d7e83f72dd3", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.rs?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Ok(42).deref();\n-//~^ ERROR no method named `deref` found\n-}"}, {"sha": "05baa7907fae0723f195e534a2536c18a87bb4a1", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a563362865e6051d4c350544131228e8eff5138/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref.stderr?ref=1a563362865e6051d4c350544131228e8eff5138", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `deref` found for type `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-deref.rs:4:27\n-   |\n-LL |     let _result = &Ok(42).deref();\n-   |                           ^^^^^\n-   |\n-   = note: the method `deref` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::Deref`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "495b7343f20341d9ce2c42661b3abb39e56ee57c", "filename": "src/test/ui/issues/issue-54062.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,13 @@\n+use std::sync::Mutex;\n+\n+struct Test {\n+    comps: Mutex<String>,\n+}\n+\n+fn main() {}\n+\n+fn testing(test: Test) {\n+    let _ = test.comps.inner.lock().unwrap();\n+    //~^ ERROR: field `inner` of struct `std::sync::Mutex` is private\n+    //~| ERROR: no method named `unwrap` found\n+}"}, {"sha": "082ac91edb1c44c487c0fd064149513bfbb5706c", "filename": "src/test/ui/issues/issue-54062.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,16 @@\n+error[E0616]: field `inner` of struct `std::sync::Mutex` is private\n+  --> $DIR/issue-54062.rs:10:13\n+   |\n+LL |     let _ = test.comps.inner.lock().unwrap();\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `unwrap` found for type `std::sys_common::mutex::MutexGuard<'_>` in the current scope\n+  --> $DIR/issue-54062.rs:10:37\n+   |\n+LL |     let _ = test.comps.inner.lock().unwrap();\n+   |                                     ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0599, E0616.\n+For more information about an error, try `rustc --explain E0599`."}, {"sha": "b50ed7ca92ad5e74a29bb53b86f42b52d80d6408", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,36 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_span, proc_macro_hygiene, proc_macro_quote)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{quote, Span, TokenStream};\n+\n+fn assert_same_span(a: Span, b: Span) {\n+    assert_eq!(a.start(), b.start());\n+    assert_eq!(a.end(), b.end());\n+}\n+\n+// This macro generates a macro with the same macro definition as `manual_foo` in\n+// `same-sequence-span.rs` but with the same span for all sequences.\n+#[proc_macro]\n+pub fn make_foo(_: TokenStream) -> TokenStream {\n+    let result = quote! {\n+        macro_rules! generated_foo {\n+            (1 $$x:expr $$($$y:tt,)* $$(= $$z:tt)*) => {};\n+        }\n+    };\n+\n+    // Check that all spans are equal.\n+    let mut span = None;\n+    for tt in result.clone() {\n+        match span {\n+            None => span = Some(tt.span()),\n+            Some(span) => assert_same_span(tt.span(), span),\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "a4f70b6b68d1ee29d8886ec34a7bcb92ae5264e7", "filename": "src/test/ui/macros/same-sequence-span.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,23 @@\n+// aux-build:proc_macro_sequence.rs\n+\n+// Regression test for issue #62831: Check that multiple sequences with the same span in the\n+// left-hand side of a macro definition behave as if they had unique spans, and in particular that\n+// they don't crash the compiler.\n+\n+#![feature(proc_macro_hygiene)]\n+#![allow(unused_macros)]\n+\n+extern crate proc_macro_sequence;\n+\n+// When ignoring spans, this macro has the same macro definition as `generated_foo` in\n+// `proc_macro_sequence.rs`.\n+macro_rules! manual_foo {\n+    (1 $x:expr $($y:tt,)*   //~ERROR `$x:expr` may be followed by `$y:tt`\n+               $(= $z:tt)*  //~ERROR `$x:expr` may be followed by `=`\n+    ) => {};\n+}\n+\n+proc_macro_sequence::make_foo!(); //~ERROR `$x:expr` may be followed by `$y:tt`\n+                                  //~^ERROR `$x:expr` may be followed by `=`\n+\n+fn main() {}"}, {"sha": "aee1b4c9c5d99a269b72dc6939b9bbfa45630930", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,34 @@\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:15:18\n+   |\n+LL |     (1 $x:expr $($y:tt,)*\n+   |                  ^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:16:18\n+   |\n+LL |                $(= $z:tt)*\n+   |                  ^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "99ce0d1a630df73ba67259e60aa862f0d3f9585d", "filename": "src/test/ui/parser/recover-from-homoglyph.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"\")\u037e //~ ERROR unknown start of token: \\u{37e}\n+    let x: usize = (); //~ ERROR mismatched types\n+}"}, {"sha": "424d492b7ba649523efc607377934862ef0e7b04", "filename": "src/test/ui/parser/recover-from-homoglyph.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-from-homoglyph.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -0,0 +1,22 @@\n+error: unknown start of token: \\u{37e}\n+  --> $DIR/recover-from-homoglyph.rs:2:17\n+   |\n+LL |     println!(\"\")\u037e\n+   |                 ^\n+help: Unicode character '\u037e' (Greek Question Mark) looks like ';' (Semicolon), but it is not\n+   |\n+LL |     println!(\"\");\n+   |                 ^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-from-homoglyph.rs:3:20\n+   |\n+LL |     let x: usize = ();\n+   |                    ^^ expected usize, found ()\n+   |\n+   = note: expected type `usize`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "9a6dbe9d9ab1d05be647f8fe17d30bb9fb4d853f", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-reduction.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.rs?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -30,13 +30,10 @@ fn main() {\n     let z = f32x4(0.0, 0.0, 0.0, 0.0);\n \n     unsafe {\n-        simd_reduce_add_ordered(z, 0_f32);\n-        simd_reduce_mul_ordered(z, 1_f32);\n-\n-        simd_reduce_add_ordered(z, 2_f32);\n-        //~^ ERROR accumulator of simd_reduce_add_ordered is not 0.0\n-        simd_reduce_mul_ordered(z, 3_f32);\n-        //~^ ERROR accumulator of simd_reduce_mul_ordered is not 1.0\n+        simd_reduce_add_ordered(z, 0);\n+        //~^ ERROR expected return type `f32` (element of input `f32x4`), found `i32`\n+        simd_reduce_mul_ordered(z, 1);\n+        //~^ ERROR expected return type `f32` (element of input `f32x4`), found `i32`\n \n         let _: f32 = simd_reduce_and(x);\n         //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n@@ -56,16 +53,5 @@ fn main() {\n         //~^ ERROR unsupported simd_reduce_all from `f32x4` with element `f32` to `bool`\n         let _: bool = simd_reduce_any(z);\n         //~^ ERROR unsupported simd_reduce_any from `f32x4` with element `f32` to `bool`\n-\n-        foo(0_f32);\n     }\n }\n-\n-#[inline(never)]\n-unsafe fn foo(x: f32) {\n-    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n-    simd_reduce_add_ordered(z, x);\n-    //~^ ERROR accumulator of simd_reduce_add_ordered is not a constant\n-    simd_reduce_mul_ordered(z, x);\n-    //~^ ERROR accumulator of simd_reduce_mul_ordered is not a constant\n-}"}, {"sha": "3863eeac3f3949747544a2cfe65f9633d92a51cb", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-reduction.stderr", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c43753f910aae000f8bcb0a502407ea332afc74b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-reduction.stderr?ref=c43753f910aae000f8bcb0a502407ea332afc74b", "patch": "@@ -1,74 +1,62 @@\n-error[E0511]: invalid monomorphization of `simd_reduce_add_ordered` intrinsic: accumulator of simd_reduce_add_ordered is not 0.0\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:36:9\n+error[E0511]: invalid monomorphization of `simd_reduce_add_ordered` intrinsic: expected return type `f32` (element of input `f32x4`), found `i32`\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:33:9\n    |\n-LL |         simd_reduce_add_ordered(z, 2_f32);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         simd_reduce_add_ordered(z, 0);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_reduce_mul_ordered` intrinsic: accumulator of simd_reduce_mul_ordered is not 1.0\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:38:9\n+error[E0511]: invalid monomorphization of `simd_reduce_mul_ordered` intrinsic: expected return type `f32` (element of input `f32x4`), found `i32`\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:35:9\n    |\n-LL |         simd_reduce_mul_ordered(z, 3_f32);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         simd_reduce_mul_ordered(z, 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_and` intrinsic: expected return type `u32` (element of input `u32x4`), found `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:41:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:38:22\n    |\n LL |         let _: f32 = simd_reduce_and(x);\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_or` intrinsic: expected return type `u32` (element of input `u32x4`), found `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:43:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:40:22\n    |\n LL |         let _: f32 = simd_reduce_or(x);\n    |                      ^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_xor` intrinsic: expected return type `u32` (element of input `u32x4`), found `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:45:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:42:22\n    |\n LL |         let _: f32 = simd_reduce_xor(x);\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_and` intrinsic: unsupported simd_reduce_and from `f32x4` with element `f32` to `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:48:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:45:22\n    |\n LL |         let _: f32 = simd_reduce_and(z);\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_or` intrinsic: unsupported simd_reduce_or from `f32x4` with element `f32` to `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:50:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:47:22\n    |\n LL |         let _: f32 = simd_reduce_or(z);\n    |                      ^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_xor` intrinsic: unsupported simd_reduce_xor from `f32x4` with element `f32` to `f32`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:52:22\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:49:22\n    |\n LL |         let _: f32 = simd_reduce_xor(z);\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_all` intrinsic: unsupported simd_reduce_all from `f32x4` with element `f32` to `bool`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:55:23\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:52:23\n    |\n LL |         let _: bool = simd_reduce_all(z);\n    |                       ^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_reduce_any` intrinsic: unsupported simd_reduce_any from `f32x4` with element `f32` to `bool`\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:57:23\n+  --> $DIR/simd-intrinsic-generic-reduction.rs:54:23\n    |\n LL |         let _: bool = simd_reduce_any(z);\n    |                       ^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_reduce_add_ordered` intrinsic: accumulator of simd_reduce_add_ordered is not a constant\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:67:5\n-   |\n-LL |     simd_reduce_add_ordered(z, x);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0511]: invalid monomorphization of `simd_reduce_mul_ordered` intrinsic: accumulator of simd_reduce_mul_ordered is not a constant\n-  --> $DIR/simd-intrinsic-generic-reduction.rs:69:5\n-   |\n-LL |     simd_reduce_mul_ordered(z, x);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 12 previous errors\n+error: aborting due to 10 previous errors\n "}]}