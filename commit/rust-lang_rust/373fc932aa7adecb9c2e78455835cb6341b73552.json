{"sha": "373fc932aa7adecb9c2e78455835cb6341b73552", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3M2ZjOTMyYWE3YWRlY2I5YzJlNzg0NTU4MzVjYjYzNDFiNzM1NTI=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-08-30T21:54:32Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-08-30T22:14:31Z"}, "message": "Make move out computation lazy", "tree": {"sha": "9a75b291f325465fad5dcd4595a890f6fef2df1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a75b291f325465fad5dcd4595a890f6fef2df1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/373fc932aa7adecb9c2e78455835cb6341b73552", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAluIbEkACgkQiMlBzaHU\nZDJNDhAAj13RUI1eOuxVeop9KXuxcuIddDifXdrJBn8h3MuAsryC7FkXVOjBOVZj\nJuHV73nI6YnKQpm1uqXfqEK0Cau6F8FdMbSxnN70qKqQI2bQXfUldzODJ/S9ciuI\nUYvexSq+udx4o0z063rccB3YXR2gHYm/bNzbcFsnEOeCS51DHuyFUlby/YlSCqOb\njn5pKCu48y5R7lE2rMTkjeldz7GNn35gnf0UDy8IvgKteCi7P1URPPYuIsIsqdtd\nBaKAQnvz4+aFmQbP7bgThMj6EoYWGH/LOCrk9MOOt85/H6cDVdF07IRAV9wWJoP+\nuy28DorkcPDLiywSm1m93evLMyRSI2iR2TSSyScqXpUDTcB7WsIGTnIETN+VyyST\n0I9yIeZ6LX0u9DaighPMVwVeYH8Ko9TSWfO4O6jAMn/Di+Hb5QMuM5XfJyzcJswN\npLkQL0sVfyq81dBVJif8Eq71LBIiTwZSG87Elafj+STijgJXiuS3SUbaHKZto+vO\nzlIuh3zBnE5u7toJSbYt4wbUc0NHkT58Nhlzn8jukR+ddJztd8Yaw0wdImXc7Olo\nvv6wlIVpr7xePhcvJHElbw221tovwLPejwuKlvuIB4L4RR7nR80s680Bavk9jbBY\n+T6Cye7dQBMKzuOfIlGiSp1yXzSTyNt0efbj6uFodE73RqgktTc=\n=KWt0\n-----END PGP SIGNATURE-----", "payload": "tree 9a75b291f325465fad5dcd4595a890f6fef2df1a\nparent 685fb543174f8f2cadc38ec0b2c6df635eb1c087\nauthor Santiago Pastorino <spastorino@gmail.com> 1535666072 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1535667271 -0300\n\nMake move out computation lazy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/373fc932aa7adecb9c2e78455835cb6341b73552", "html_url": "https://github.com/rust-lang/rust/commit/373fc932aa7adecb9c2e78455835cb6341b73552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/373fc932aa7adecb9c2e78455835cb6341b73552/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "685fb543174f8f2cadc38ec0b2c6df635eb1c087", "url": "https://api.github.com/repos/rust-lang/rust/commits/685fb543174f8f2cadc38ec0b2c6df635eb1c087", "html_url": "https://github.com/rust-lang/rust/commit/685fb543174f8f2cadc38ec0b2c6df635eb1c087"}], "stats": {"total": 299, "additions": 110, "deletions": 189}, "files": [{"sha": "c9374b6bfc7cee6a20f75d19058c092ff2a9e5ab", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -203,6 +203,28 @@ impl<'tcx> Mir<'tcx> {\n         ReadGuard::map(self.predecessors(), |p| &p[bb])\n     }\n \n+    #[inline]\n+    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n+        let if_zero_locations = if loc.statement_index == 0 {\n+            let predecessor_blocks = self.predecessors_for(loc.block);\n+            let num_predecessor_blocks = predecessor_blocks.len();\n+            Some((0 .. num_predecessor_blocks)\n+                .map(move |i| predecessor_blocks[i])\n+                .map(move |bb| self.terminator_loc(bb))\n+            )\n+        } else {\n+            None\n+        };\n+\n+        let if_not_zero_locations = if loc.statement_index == 0 {\n+            None\n+        } else {\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n+        };\n+\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n+    }\n+\n     #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(self)"}, {"sha": "efd804983067a6bec78de052a3aecbedf400d680", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 82, "deletions": 8, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n use rustc::mir::{LocalDecl, LocalKind, Location, Operand, Place};\n use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::DiagnosticBuilder;\n@@ -24,8 +25,9 @@ use super::borrow_set::BorrowData;\n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n \n+use dataflow::drop_flag_effects;\n use dataflow::move_paths::MovePathIndex;\n-use dataflow::{FlowAtLocation, MovingOutStatements};\n+use dataflow::move_paths::indexes::MoveOutIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -35,17 +37,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         desired_action: InitializationRequiringAction,\n         (place, span): (&Place<'tcx>, Span),\n         mpi: MovePathIndex,\n-        curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n     ) {\n         let use_spans = self\n             .move_spans(place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n-        let mois = self.move_data.path_map[mpi]\n-            .iter()\n-            .filter(|moi| curr_move_out.contains(moi))\n-            .collect::<Vec<_>>();\n+        let mois = self.get_moved_indexes(context, mpi);\n+        debug!(\"report_use_of_moved_or_uninitialized: mois={:?}\", mois);\n \n         if mois.is_empty() {\n             let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n@@ -93,7 +92,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let mut is_loop_move = false;\n             for moi in &mois {\n-                let move_out = self.move_data.moves[**moi];\n+                let move_out = self.move_data.moves[*moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n                 let move_spans = self.move_spans(moved_place, move_out.source);\n@@ -148,7 +147,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 if needs_note {\n-                    let mpi = self.move_data.moves[*mois[0]].path;\n+                    let mpi = self.move_data.moves[mois[0]].path;\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n@@ -521,6 +520,81 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n+    fn get_moved_indexes(\n+        &mut self,\n+        context: Context,\n+        mpi: MovePathIndex,\n+    ) -> Vec<MoveOutIndex> {\n+        let mir = self.mir;\n+\n+        let mut stack = Vec::new();\n+        stack.extend(mir.predecessor_locations(context.loc));\n+\n+        let mut visited = FxHashSet();\n+        let mut result = vec![];\n+\n+        'dfs:\n+        while let Some(l) = stack.pop() {\n+            debug!(\"report_use_of_moved_or_uninitialized: current_location={:?}\", l);\n+\n+            if !visited.insert(l) {\n+                continue;\n+            }\n+\n+            // check for moves\n+            let stmt_kind = mir[l.block].statements.get(l.statement_index).map(|s| &s.kind);\n+            if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n+                // this analysis only tries to find moves explicitly\n+                // written by the user, so we ignore the move-outs\n+                // created by `StorageDead` and at the beginning\n+                // of a function.\n+            } else {\n+                for moi in &self.move_data.loc_map[l] {\n+                    debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n+                    if self.move_data.moves[*moi].path == mpi {\n+                        debug!(\"report_use_of_moved_or_uninitialized: found\");\n+                        result.push(*moi);\n+\n+                        // Strictly speaking, we could continue our DFS here. There may be\n+                        // other moves that can reach the point of error. But it is kind of\n+                        // confusing to highlight them.\n+                        //\n+                        // Example:\n+                        //\n+                        // ```\n+                        // let a = vec![];\n+                        // let b = a;\n+                        // let c = a;\n+                        // drop(a); // <-- current point of error\n+                        // ```\n+                        //\n+                        // Because we stop the DFS here, we only highlight `let c = a`,\n+                        // and not `let b = a`. We will of course also report an error at\n+                        // `let c = a` which highlights `let b = a` as the move.\n+                        continue 'dfs;\n+                    }\n+                }\n+            }\n+\n+            // check for inits\n+            let mut any_match = false;\n+            drop_flag_effects::for_location_inits(\n+                self.tcx,\n+                self.mir,\n+                self.move_data,\n+                l,\n+                |m| if m == mpi { any_match = true; },\n+            );\n+            if any_match {\n+                continue 'dfs;\n+            }\n+\n+            stack.extend(mir.predecessor_locations(l));\n+        }\n+\n+        result\n+    }\n+\n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n         context: Context,"}, {"sha": "6b964fec74fdd1417b1145de05f44ed2df3b696e", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -24,7 +24,7 @@ use polonius_engine::Output;\n use dataflow::move_paths::indexes::BorrowIndex;\n use dataflow::move_paths::HasMoveData;\n use dataflow::Borrows;\n-use dataflow::{EverInitializedPlaces, MovingOutStatements};\n+use dataflow::EverInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::MaybeUninitializedPlaces;\n use either::Either;\n@@ -35,7 +35,6 @@ use std::rc::Rc;\n crate struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-    pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n     pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n \n     /// Polonius Output\n@@ -46,14 +45,12 @@ impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     crate fn new(\n         borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-        move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n         ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n         polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     ) -> Self {\n         Flows {\n             borrows,\n             uninits,\n-            move_outs,\n             ever_inits,\n             polonius_output,\n         }\n@@ -79,7 +76,6 @@ macro_rules! each_flow {\n     ($this:ident, $meth:ident($arg:ident)) => {\n         FlowAtLocation::$meth(&mut $this.borrows, $arg);\n         FlowAtLocation::$meth(&mut $this.uninits, $arg);\n-        FlowAtLocation::$meth(&mut $this.move_outs, $arg);\n         FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n     };\n }\n@@ -146,18 +142,6 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n         });\n         s.push_str(\"] \");\n \n-        s.push_str(\"move_out: [\");\n-        let mut saw_one = false;\n-        self.move_outs.each_state_bit(|mpi_move_out| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_out = &self.move_outs.operator().move_data().moves[mpi_move_out];\n-            s.push_str(&format!(\"{:?}\", move_out));\n-        });\n-        s.push_str(\"] \");\n-\n         s.push_str(\"ever_init: [\");\n         let mut saw_one = false;\n         self.ever_inits.each_state_bit(|mpi_ever_init| {"}, {"sha": "3536947b25ebfbdba7e75f2049751a82deced06d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -43,7 +43,7 @@ use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n use dataflow::{do_dataflow, DebugFormatted};\n-use dataflow::{EverInitializedPlaces, MovingOutStatements};\n+use dataflow::EverInitializedPlaces;\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -186,15 +186,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n-    let flow_move_outs = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        MovingOutStatements::new(tcx, mir, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().moves[i]),\n-    ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n@@ -268,7 +259,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut state = Flows::new(\n         flow_borrows,\n         flow_uninits,\n-        flow_move_outs,\n         flow_ever_inits,\n         polonius_output,\n     );\n@@ -1617,7 +1607,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1663,7 +1652,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         desired_action,\n                         place_span,\n                         mpi,\n-                        curr_move_outs,\n                     );\n                     return; // don't bother finding other problems.\n                 }\n@@ -1691,7 +1679,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1727,7 +1714,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     desired_action,\n                     place_span,\n                     child_mpi,\n-                    curr_move_outs,\n                 );\n                 return; // don't bother finding other problems.\n             }"}, {"sha": "62c6018809f39ef161b8407d8b0c26b0c4c657c1", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -22,13 +22,13 @@ use super::MoveDataParamEnv;\n \n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex};\n use super::move_paths::{LookupResult, InitKind};\n use super::{BitDenotation, BlockSets, InitialFlow};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n-use super::{on_lookup_result_bits, for_location_inits};\n+use super::on_lookup_result_bits;\n \n mod storage_liveness;\n \n@@ -211,40 +211,6 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular places. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// place in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that place.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedPlaces`. Both structures on their own only tell\n-/// you if a place *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error message may need to report.\n-#[allow(dead_code)]\n-pub struct MovingOutStatements<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> MovingOutStatements<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n-        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n-}\n-\n /// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n /// for a function, without an intervening `Storage Dead`.\n@@ -488,83 +454,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    type Idx = MoveOutIndex;\n-    fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.move_data().moves.len()\n-    }\n-\n-    fn start_block_effect(&self, _sets: &mut IdxSet<MoveOutIndex>) {\n-        // no move-statements have been executed prior to function\n-        // execution, so this method has no effect on `_sets`.\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<MoveOutIndex>,\n-                        location: Location) {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[location.block].statements[location.statement_index];\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-\n-        match stmt.kind {\n-            // this analysis only tries to find moves explicitly\n-            // written by the user, so we ignore the move-outs\n-            // created by `StorageDead` and at the beginning\n-            // of a function.\n-            mir::StatementKind::StorageDead(_) => {}\n-            _ => {\n-                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                       stmt, location, &loc_map[location]);\n-                // Every path deinitialized by a *particular move*\n-                // has corresponding bit, \"gen'ed\" (i.e. set)\n-                // here, in dataflow vector\n-                sets.gen_all_and_assert_dead(&loc_map[location]);\n-            }\n-        }\n-\n-        for_location_inits(tcx, mir, move_data, location,\n-                           |mpi| sets.kill_all(&path_map[mpi]));\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<MoveOutIndex>,\n-                         location: Location)\n-    {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let term = mir[location.block].terminator();\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-\n-        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, location, &loc_map[location]);\n-        sets.gen_all_and_assert_dead(&loc_map[location]);\n-\n-        for_location_inits(tcx, mir, move_data, location,\n-                           |mpi| sets.kill_all(&path_map[mpi]));\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place) {\n-        let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n-\n-        let path_map = &move_data.path_map;\n-        on_lookup_result_bits(self.tcx,\n-                              self.mir,\n-                              move_data,\n-                              move_data.rev_lookup.find(dest_place),\n-                              |mpi| for moi in &path_map[mpi] {\n-                                  assert!(moi.index() < bits_per_block);\n-                                  in_out.remove(&moi);\n-                              });\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n@@ -682,13 +571,6 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedPlaces<'a, 'gcx, '\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: Word, pred2: Word) -> Word {\n@@ -727,13 +609,6 @@ impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no loans in scope by default\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {"}, {"sha": "bee7d443c85408b430520fd4abc9612f3468e5cd", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -28,7 +28,7 @@ use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n+pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::HaveBeenBorrowedLocals;\n@@ -38,7 +38,7 @@ pub(crate) use self::drop_flag_effects::*;\n use self::move_paths::MoveData;\n \n mod at_location;\n-mod drop_flag_effects;\n+pub mod drop_flag_effects;\n mod graphviz;\n mod impls;\n pub mod move_paths;\n@@ -511,18 +511,6 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         }\n     }\n \n-    fn gen_all_and_assert_dead<I>(&mut self, i: I)\n-        where I: IntoIterator,\n-        I::Item: Borrow<E>\n-    {\n-        for j in i {\n-            let j = j.borrow();\n-            let retval = self.gen_set.add(j);\n-            self.kill_set.remove(j);\n-            assert!(retval);\n-        }\n-    }\n-\n     fn kill(&mut self, e: &E) {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);"}, {"sha": "9b25a865f921e1ff806c5efb99a478ece047f0c4", "filename": "src/test/ui/hygiene/fields-move.nll.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/373fc932aa7adecb9c2e78455835cb6341b73552/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr?ref=373fc932aa7adecb9c2e78455835cb6341b73552", "patch": "@@ -1,9 +1,6 @@\n error[E0382]: use of moved value: `foo.x`\n   --> $DIR/fields-move.rs:28:9\n    |\n-LL |    $foo.x\n-   |    ------ value moved here\n-...\n LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n    |         ^^^^^^ value used here after move\n ...\n@@ -28,14 +25,9 @@ LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved val\n error[E0382]: use of moved value: `foo.x`\n   --> $DIR/fields-move.rs:39:42\n    |\n-LL |    $foo.x\n-   |    ------ value moved here\n-...\n LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n    |         ------ value moved here\n ...\n-LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n-   |                                          ----- value moved here\n LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n    |                                          ^^^^^ value used here after move\n    |"}]}