{"sha": "964b72b3e0347e0364a974d7f7e8ce34cdeac972", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NGI3MmIzZTAzNDdlMDM2NGE5NzRkN2Y3ZThjZTM0Y2RlYWM5NzI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-16T11:41:19Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-03T23:39:16Z"}, "message": "Refactor resolve_import_for_module", "tree": {"sha": "e9f6628e98ca51e747689915c84a596cc120f7d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9f6628e98ca51e747689915c84a596cc120f7d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/964b72b3e0347e0364a974d7f7e8ce34cdeac972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/964b72b3e0347e0364a974d7f7e8ce34cdeac972", "html_url": "https://github.com/rust-lang/rust/commit/964b72b3e0347e0364a974d7f7e8ce34cdeac972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/964b72b3e0347e0364a974d7f7e8ce34cdeac972/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c4062175994d28120da4aa7518e3e10b19e2db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4062175994d28120da4aa7518e3e10b19e2db3", "html_url": "https://github.com/rust-lang/rust/commit/0c4062175994d28120da4aa7518e3e10b19e2db3"}], "stats": {"total": 109, "additions": 32, "deletions": 77}, "files": [{"sha": "c9f3d5a05a1bd850d5bc3e7a0e80d8403ac330e9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/964b72b3e0347e0364a974d7f7e8ce34cdeac972/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964b72b3e0347e0364a974d7f7e8ce34cdeac972/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=964b72b3e0347e0364a974d7f7e8ce34cdeac972", "patch": "@@ -662,10 +662,11 @@ enum ResolveResult<T> {\n }\n \n impl<T> ResolveResult<T> {\n-    fn success(&self) -> bool {\n-        match *self {\n-            Success(_) => true,\n-            _ => false,\n+    fn and_then<U, F: FnOnce(T) -> ResolveResult<U>>(self, f: F) -> ResolveResult<U> {\n+        match self {\n+            Failed(msg) => Failed(msg),\n+            Indeterminate => Indeterminate,\n+            Success(t) => f(t),\n         }\n     }\n }\n@@ -1335,8 +1336,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n                            -> ResolveResult<(Module<'a>, LastPrivate)> {\n-        let module_path_len = module_path.len();\n-        assert!(module_path_len > 0);\n+        if module_path.len() == 0 {\n+            return Success((self.graph_root, LastMod(AllPublic))) // Use the crate root\n+        }\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),"}, {"sha": "577f346fbe5ad498c055ef89defff645ceacd788", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 71, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/964b72b3e0347e0364a974d7f7e8ce34cdeac972/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964b72b3e0347e0364a974d7f7e8ce34cdeac972/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=964b72b3e0347e0364a974d7f7e8ce34cdeac972", "patch": "@@ -332,92 +332,45 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  module_: Module<'b>,\n                                  import_directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n-        let mut resolution_result = ResolveResult::Failed(None);\n-        let module_path = &import_directive.module_path;\n-\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&module_path[..]),\n+               names_to_string(&import_directive.module_path),\n                module_to_string(&*module_));\n \n-        // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.is_empty() {\n-            // Use the crate root.\n-            Some((self.resolver.graph_root, LastMod(AllPublic)))\n-        } else {\n-            match self.resolver.resolve_module_path(module_,\n-                                                    &module_path[..],\n-                                                    UseLexicalScopeFlag::DontUseLexicalScope,\n-                                                    import_directive.span) {\n-                ResolveResult::Failed(err) => {\n-                    resolution_result = ResolveResult::Failed(err);\n-                    None\n-                }\n-                ResolveResult::Indeterminate => {\n-                    resolution_result = ResolveResult::Indeterminate;\n-                    None\n-                }\n-                ResolveResult::Success(container) => Some(container),\n-            }\n-        };\n-\n-        match container {\n-            None => {}\n-            Some((containing_module, lp)) => {\n+        self.resolver\n+            .resolve_module_path(module_,\n+                                 &import_directive.module_path,\n+                                 UseLexicalScopeFlag::DontUseLexicalScope,\n+                                 import_directive.span)\n+            .and_then(|(containing_module, lp)| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n-\n-                match import_directive.subclass {\n-                    SingleImport(target, source) => {\n-                        resolution_result = self.resolve_single_import(&module_,\n-                                                                       containing_module,\n-                                                                       target,\n-                                                                       source,\n-                                                                       import_directive,\n-                                                                       lp);\n-                    }\n-                    GlobImport => {\n-                        resolution_result = self.resolve_glob_import(&module_,\n-                                                                     containing_module,\n-                                                                     import_directive,\n-                                                                     lp);\n-                    }\n+                if let SingleImport(target, source) = import_directive.subclass {\n+                    self.resolve_single_import(&module_,\n+                                               containing_module,\n+                                               target,\n+                                               source,\n+                                               import_directive,\n+                                               lp)\n+                } else {\n+                    self.resolve_glob_import(&module_, containing_module, import_directive, lp)\n                 }\n-            }\n-        }\n-\n-        // Decrement the count of unresolved imports.\n-        match resolution_result {\n-            ResolveResult::Success(()) => {\n+            })\n+            .and_then(|()| {\n+                // Decrement the count of unresolved imports.\n                 assert!(self.resolver.unresolved_imports >= 1);\n                 self.resolver.unresolved_imports -= 1;\n-            }\n-            _ => {\n-                // Nothing to do here; just return the error.\n-            }\n-        }\n \n-        // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is a success -- other cases will\n-        // be handled by the main loop.\n-\n-        if resolution_result.success() {\n-            match import_directive.subclass {\n-                GlobImport => {\n+                if let GlobImport = import_directive.subclass {\n                     module_.dec_glob_count();\n                     if import_directive.is_public {\n                         module_.dec_pub_glob_count();\n                     }\n                 }\n-                SingleImport(..) => {\n-                    // Ignore.\n+                if import_directive.is_public {\n+                    module_.dec_pub_count();\n                 }\n-            }\n-            if import_directive.is_public {\n-                module_.dec_pub_count();\n-            }\n-        }\n-\n-        return resolution_result;\n+                Success(())\n+            })\n     }\n \n     /// Resolves the name in the namespace of the module because it is being imported by"}]}