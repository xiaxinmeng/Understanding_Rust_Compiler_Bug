{"sha": "4b26b80dd56f03affae07eeaffae5c284247a40b", "node_id": "C_kwDOAAsO6NoAKDRiMjZiODBkZDU2ZjAzYWZmYWUwN2VlYWZmYWU1YzI4NDI0N2E0MGI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-23T11:14:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-23T11:14:27Z"}, "message": "Rollup merge of #111704 - compiler-errors:sized-return-cleanup, r=oli-obk\n\nRemove return type sized check hack from hir typeck\n\nRemove a bunch of special-cased suggestions when someone returns `-> dyn Trait` that checks for type equality, etc.\n\nThis was a pretty complex piece of code that also relied on a hack in hir typeck (see changes to `compiler/rustc_hir_typeck/src/check.rs`), and I'm not convinced that it's necessary to maintain, when all we really need to tell the user is that they should return `-> impl Trait` or `-> Box<dyn Trait>`, depending on their specific use-case.\n\nThis is necessary because we may need to move the \"return type is sized\" check from hir typeck to wfcheck, which does not have access to typeck results. This is a prerequisite for that, and I'm fairly confident that the diagnostics \"regressions\" here are not a big deal.", "tree": {"sha": "c16966b08c2f071298a914fbae738feace29521f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c16966b08c2f071298a914fbae738feace29521f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b26b80dd56f03affae07eeaffae5c284247a40b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkbKATCRBK7hj4Ov3rIwAA9lAIAIjocWMepWpB1MGKYjR0Nf8V\n8FDyRLz36C4Ww9o5BVSkaFTilEjo5q7v2o1UhIXWa4FC2Yrmk1RSyP/RcZsqXtmq\nWd4ayYhxI0lDYHv0g+wDXHgEzorC0oc3z5sfAxmbAdQR05eIpvmFk39aSVkQM4oE\n/bjTWEBdwRRz2ctKADVE20KPyxdBIbWq/aPHhYiGpngpGGSanKhN3m+/UJ9VS7wv\nk73F34pHSKE98wKMAlbcW1gdq3a/2skhMOzmyXsYWOrxapgO4j6nNtsh6+f+8w75\nI1l9WzP8+a2xzKe2/z3GOOAd6GRxtEvWlb029qoNKM13cVmfMiJ3canWp11wibk=\n=M5NU\n-----END PGP SIGNATURE-----\n", "payload": "tree c16966b08c2f071298a914fbae738feace29521f\nparent 00185bec7ce88eae94adbc3185b802bfec8cad9a\nparent 3db2bcf4ebb08f7fbe3de7fded45e96639ca3e68\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1684840467 +0530\ncommitter GitHub <noreply@github.com> 1684840467 +0530\n\nRollup merge of #111704 - compiler-errors:sized-return-cleanup, r=oli-obk\n\nRemove return type sized check hack from hir typeck\n\nRemove a bunch of special-cased suggestions when someone returns `-> dyn Trait` that checks for type equality, etc.\n\nThis was a pretty complex piece of code that also relied on a hack in hir typeck (see changes to `compiler/rustc_hir_typeck/src/check.rs`), and I'm not convinced that it's necessary to maintain, when all we really need to tell the user is that they should return `-> impl Trait` or `-> Box<dyn Trait>`, depending on their specific use-case.\n\nThis is necessary because we may need to move the \"return type is sized\" check from hir typeck to wfcheck, which does not have access to typeck results. This is a prerequisite for that, and I'm fairly confident that the diagnostics \"regressions\" here are not a big deal.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b26b80dd56f03affae07eeaffae5c284247a40b", "html_url": "https://github.com/rust-lang/rust/commit/4b26b80dd56f03affae07eeaffae5c284247a40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b26b80dd56f03affae07eeaffae5c284247a40b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00185bec7ce88eae94adbc3185b802bfec8cad9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/00185bec7ce88eae94adbc3185b802bfec8cad9a", "html_url": "https://github.com/rust-lang/rust/commit/00185bec7ce88eae94adbc3185b802bfec8cad9a"}, {"sha": "3db2bcf4ebb08f7fbe3de7fded45e96639ca3e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/3db2bcf4ebb08f7fbe3de7fded45e96639ca3e68", "html_url": "https://github.com/rust-lang/rust/commit/3db2bcf4ebb08f7fbe3de7fded45e96639ca3e68"}], "stats": {"total": 637, "additions": 182, "deletions": 455}, "files": [{"sha": "186ac536c6e5aa5bbb7c409f639af977741375d8", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -103,24 +103,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fcx.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    if let ty::Dynamic(_, _, ty::Dyn) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value, false);\n-    }\n+    fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+    fcx.check_return_expr(&body.value, false);\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "dc43a3d154ab3e9d270b28aa93c681f4b08bf368", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -885,7 +885,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             return;\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n+                        if self.suggest_impl_trait(&mut err, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n                         }"}, {"sha": "83511e898f70c8e3999b307a1b447d5972cdaaa0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 48, "deletions": 229, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -30,9 +30,9 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n-    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n-    TypeSuperFoldable, TypeVisitableExt, TypeckResults,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, InferTy, InternalSubsts, IsSuggestable,\n+    ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt, TypeckResults,\n };\n use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -261,7 +261,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n@@ -1792,215 +1791,66 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        match obligation.cause.code().peel_derives() {\n-            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n-            ObligationCauseCode::SizedReturnType => {}\n-            _ => return false,\n-        }\n-\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.local_def_id_to_hir_id(obligation.cause.body_id);\n-        let node = hir.find_by_def_id(obligation.cause.body_id);\n-        let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id),\n-            ..\n-        })) = node\n-        else {\n+        let ObligationCauseCode::SizedReturnType = obligation.cause.code() else {\n             return false;\n         };\n-        let body = hir.body(*body_id);\n-        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n-        let ty = trait_pred.skip_binder().self_ty();\n-        let is_object_safe = match ty.kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n-                predicates\n-                    .principal_def_id()\n-                    .map_or(true, |def_id| self.tcx.check_is_object_safe(def_id))\n-            }\n-            // We only want to suggest `impl Trait` to `dyn Trait`s.\n-            // For example, `fn foo() -> str` needs to be filtered out.\n-            _ => return false,\n-        };\n-\n-        let hir::FnRetTy::Return(ret_ty) = sig.decl.output else {\n+        let ty::Dynamic(_, _, ty::Dyn) = trait_pred.self_ty().skip_binder().kind() else {\n             return false;\n         };\n \n-        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n-        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n-        // Recursively look for `TraitObject` types and if there's only one, use that span to\n-        // suggest `impl Trait`.\n-\n-        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n-        // otherwise suggest using `Box<dyn Trait>` or an enum.\n-        let mut visitor = ReturnsVisitor::default();\n-        visitor.visit_body(&body);\n-\n-        let typeck_results = self.typeck_results.as_ref().unwrap();\n-        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n-\n-        let ret_types = visitor\n-            .returns\n-            .iter()\n-            .filter_map(|expr| Some((expr.span, typeck_results.node_type_opt(expr.hir_id)?)))\n-            .map(|(expr_span, ty)| (expr_span, self.resolve_vars_if_possible(ty)));\n-        let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n-            (None, true, true),\n-            |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n-             (_, ty)| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                same &=\n-                    !matches!(ty.kind(), ty::Error(_))\n-                        && last_ty.map_or(true, |last_ty| {\n-                            // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n-                            // *after* in the dependency graph.\n-                            match (ty.kind(), last_ty.kind()) {\n-                                (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n-                                | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n-                                | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n-                                | (\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                ) => true,\n-                                _ => ty == last_ty,\n-                            }\n-                        });\n-                (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n-            },\n-        );\n-        let mut spans_and_needs_box = vec![];\n-\n-        match liberated_sig.output().kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                let cause = ObligationCause::misc(ret_ty.span, obligation.cause.body_id);\n-                let param_env = ty::ParamEnv::empty();\n-\n-                if !only_never_return {\n-                    for (expr_span, return_ty) in ret_types {\n-                        let self_ty_satisfies_dyn_predicates = |self_ty| {\n-                            predicates.iter().all(|predicate| {\n-                                let pred = predicate.with_self_ty(self.tcx, self_ty);\n-                                let obl = Obligation::new(self.tcx, cause.clone(), param_env, pred);\n-                                self.predicate_may_hold(&obl)\n-                            })\n-                        };\n-\n-                        if let ty::Adt(def, substs) = return_ty.kind()\n-                            && def.is_box()\n-                            && self_ty_satisfies_dyn_predicates(substs.type_at(0))\n-                        {\n-                            spans_and_needs_box.push((expr_span, false));\n-                        } else if self_ty_satisfies_dyn_predicates(return_ty) {\n-                            spans_and_needs_box.push((expr_span, true));\n-                        } else {\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return false,\n-        };\n-\n-        let sm = self.tcx.sess.source_map();\n-        if !ret_ty.span.overlaps(span) {\n-            return false;\n-        }\n-        let snippet = if let hir::TyKind::TraitObject(..) = ret_ty.kind {\n-            if let Ok(snippet) = sm.span_to_snippet(ret_ty.span) {\n-                snippet\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            // Substitute the type, so we can print a fixup given `type Alias = dyn Trait`\n-            let name = liberated_sig.output().to_string();\n-            let name =\n-                name.strip_prefix('(').and_then(|name| name.strip_suffix(')')).unwrap_or(&name);\n-            if !name.starts_with(\"dyn \") {\n-                return false;\n-            }\n-            name.to_owned()\n-        };\n-\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n-        let impl_trait_msg = \"for information on `impl Trait`, see \\\n-            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-            #returning-types-that-implement-traits>\";\n-        let trait_obj_msg = \"for information on trait objects, see \\\n-            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n-            #using-trait-objects-that-allow-for-values-of-different-types>\";\n-\n-        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n-        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n-        if only_never_return {\n-            // No return paths, probably using `panic!()` or similar.\n-            // Suggest `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n-            suggest_trait_object_return_type_alternatives(\n-                err,\n-                ret_ty.span,\n-                trait_obj,\n-                is_object_safe,\n-            );\n-        } else if let (Some(last_ty), true) = (last_ty, all_returns_have_same_type) {\n-            // Suggest `-> impl Trait`.\n+\n+        let span = obligation.cause.span;\n+        if let Ok(snip) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && snip.starts_with(\"dyn \")\n+        {\n             err.span_suggestion(\n-                ret_ty.span,\n-                format!(\n-                    \"use `impl {1}` as the return type, as all return paths are of type `{}`, \\\n-                     which implements `{1}`\",\n-                    last_ty, trait_obj,\n-                ),\n-                format!(\"impl {}\", trait_obj),\n-                Applicability::MachineApplicable,\n+                span.with_hi(span.lo() + BytePos(4)),\n+                \"return an `impl Trait` instead of a `dyn Trait`, \\\n+                if all returned values are the same type\",\n+                \"impl \",\n+                Applicability::MaybeIncorrect,\n             );\n-            err.note(impl_trait_msg);\n-        } else {\n-            if is_object_safe {\n-                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                err.multipart_suggestion(\n-                    \"return a boxed trait object instead\",\n-                    vec![\n-                        (ret_ty.span.shrink_to_lo(), \"Box<\".to_string()),\n-                        (span.shrink_to_hi(), \">\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-                for (span, needs_box) in spans_and_needs_box {\n-                    if needs_box {\n-                        err.multipart_suggestion(\n-                            \"... and box this value\",\n-                            vec![\n-                                (span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n+        }\n+\n+        let body = self.tcx.hir().body(self.tcx.hir().body_owned_by(obligation.cause.body_id));\n+\n+        let mut visitor = ReturnsVisitor::default();\n+        visitor.visit_body(&body);\n+\n+        let mut sugg =\n+            vec![(span.shrink_to_lo(), \"Box<\".to_string()), (span.shrink_to_hi(), \">\".to_string())];\n+        sugg.extend(visitor.returns.into_iter().flat_map(|expr| {\n+            let span = expr.span.find_ancestor_in_same_ctxt(obligation.cause.span).unwrap_or(expr.span);\n+            if !span.can_be_used_for_suggestions() {\n+                vec![]\n+            } else if let hir::ExprKind::Call(path, ..) = expr.kind\n+                && let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, method)) = path.kind\n+                && method.ident.name == sym::new\n+                && let hir::TyKind::Path(hir::QPath::Resolved(.., box_path)) = ty.kind\n+                && box_path.res.opt_def_id().is_some_and(|def_id| Some(def_id) == self.tcx.lang_items().owned_box())\n+            {\n+                // Don't box `Box::new`\n+                vec![]\n             } else {\n-                // This is currently not possible to trigger because E0038 takes precedence, but\n-                // leave it in for completeness in case anything changes in an earlier stage.\n-                err.note(format!(\n-                    \"if trait `{}` were object-safe, you could return a trait object\",\n-                    trait_obj,\n-                ));\n+                vec![\n+                    (span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (span.shrink_to_hi(), \")\".to_string()),\n+                ]\n             }\n-            err.note(trait_obj_msg);\n-            err.note(format!(\n-                \"if all the returned values were of the same type you could use `impl {}` as the \\\n-                 return type\",\n-                trait_obj,\n-            ));\n-            err.note(impl_trait_msg);\n-            err.note(\"you can create a new `enum` with a variant for each returned type\");\n-        }\n+        }));\n+\n+        err.multipart_suggestion(\n+            \"box the return type, and wrap all of the returned values in `Box::new`\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+\n         true\n     }\n \n@@ -4139,37 +3989,6 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n     }\n }\n \n-fn suggest_trait_object_return_type_alternatives(\n-    err: &mut Diagnostic,\n-    ret_ty: Span,\n-    trait_obj: &str,\n-    is_object_safe: bool,\n-) {\n-    err.span_suggestion(\n-        ret_ty,\n-        format!(\n-            \"use `impl {}` as the return type if all return paths have the same type but you \\\n-                want to expose only the trait in the signature\",\n-            trait_obj,\n-        ),\n-        format!(\"impl {}\", trait_obj),\n-        Applicability::MaybeIncorrect,\n-    );\n-    if is_object_safe {\n-        err.multipart_suggestion(\n-            format!(\n-                \"use a boxed trait object if all return paths implement trait `{}`\",\n-                trait_obj,\n-            ),\n-            vec![\n-                (ret_ty.shrink_to_lo(), \"Box<\".to_string()),\n-                (ret_ty.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-}\n-\n /// Collect the spans that we see the generic param `param_did`\n struct ReplaceImplTraitVisitor<'a> {\n     ty_spans: &'a mut Vec<Span>,"}, {"sha": "ca8319aa020dceea3f35a462540de4f30b896ec1", "filename": "tests/ui/error-codes/E0746.fixed", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00185bec7ce88eae94adbc3185b802bfec8cad9a/tests%2Fui%2Ferror-codes%2FE0746.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/00185bec7ce88eae94adbc3185b802bfec8cad9a/tests%2Fui%2Ferror-codes%2FE0746.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.fixed?ref=00185bec7ce88eae94adbc3185b802bfec8cad9a", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-#![allow(dead_code)]\n-struct Struct;\n-trait Trait {}\n-impl Trait for Struct {}\n-impl Trait for u32 {}\n-\n-fn foo() -> impl Trait { Struct }\n-//~^ ERROR E0746\n-\n-fn bar() -> impl Trait { //~ ERROR E0746\n-    if true {\n-        return 0;\n-    }\n-    42\n-}\n-\n-fn main() {}"}, {"sha": "86b5b7444d18ef5bb448a4f20193832d983c1d13", "filename": "tests/ui/error-codes/E0746.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Ferror-codes%2FE0746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Ferror-codes%2FE0746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -1,5 +1,5 @@\n-// run-rustfix\n #![allow(dead_code)]\n+\n struct Struct;\n trait Trait {}\n impl Trait for Struct {}"}, {"sha": "9fe90ab7bec7fcb41f779bee3e785c84d22077ab", "filename": "tests/ui/error-codes/E0746.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Ferror-codes%2FE0746.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Ferror-codes%2FE0746.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -4,23 +4,33 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn foo() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn foo() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn foo() -> Box<dyn Trait> { Box::new(Struct) }\n+   |             ++++         +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/E0746.rs:11:13\n    |\n LL | fn bar() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bar() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bar() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(0);\n+LL |     }\n+LL ~     Box::new(42)\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "af368203de021bc075245e2f4bfa253f68dfb666", "filename": "tests/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -26,7 +26,7 @@ fn bax() -> dyn Trait { //~ ERROR E0746\n     if true {\n         Struct\n     } else {\n-        42 //~ ERROR `if` and `else` have incompatible types\n+        42\n     }\n }\n fn bam() -> Box<dyn Trait> {"}, {"sha": "ed9261d0de578f4d71f6ee603d78a2798e056e68", "filename": "tests/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -46,96 +46,78 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bap() -> Trait { Struct }\n    |             ^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn bap() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+LL | fn bap() -> Box<Trait> { Box::new(Struct) }\n+   |             ++++     +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:15:13\n    |\n LL | fn ban() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn ban() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn ban() -> Box<dyn Trait> { Box::new(Struct) }\n+   |             ++++         +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:17:13\n    |\n LL | fn bak() -> dyn Trait { unimplemented!() }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use `impl Trait` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bak() -> impl Trait { unimplemented!() }\n-   |             ~~~~~~~~~~\n-help: use a boxed trait object if all return paths implement trait `Trait`\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n-   |             ++++         +\n+LL | fn bak() -> Box<dyn Trait> { Box::new(unimplemented!()) }\n+   |             ++++         +   +++++++++                +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n    |\n LL | fn bal() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn bal() -> Box<dyn Trait> {\n-   |             ++++         +\n-help: ... and box this value\n+LL | fn bal() -> impl Trait {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         return Box::new(Struct);\n-   |                +++++++++      +\n-help: ... and box this value\n+LL ~ fn bal() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(Struct);\n+LL |     }\n+LL ~     Box::new(42)\n    |\n-LL |     Box::new(42)\n-   |     +++++++++  +\n-\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n-   |\n-LL | /     if true {\n-LL | |         Struct\n-   | |         ------ expected because of this\n-LL | |     } else {\n-LL | |         42\n-   | |         ^^ expected `Struct`, found integer\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:25:13\n    |\n LL | fn bax() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn bax() -> Box<dyn Trait> {\n-   |             ++++         +\n-help: ... and box this value\n+LL | fn bax() -> impl Trait {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         Box::new(Struct)\n-   |         +++++++++      +\n-help: ... and box this value\n+LL ~ fn bax() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         Box::new(Struct)\n+LL |     } else {\n+LL ~         Box::new(42)\n    |\n-LL |         Box::new(42)\n-   |         +++++++++  +\n \n error[E0308]: mismatched types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:34:16\n@@ -279,25 +261,39 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bat() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bat() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bat() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(0);\n+LL |     }\n+LL ~     Box::new(42)\n+   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:66:13\n    |\n LL | fn bay() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bay() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bay() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         Box::new(0)\n+LL |     } else {\n+LL ~         Box::new(42)\n+   |\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 19 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0746.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "a8a6288eb56fb3a349d0a6964923aed195a41071", "filename": "tests/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -77,7 +77,7 @@ fn hat() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed\n fn pug() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n     match 13 {\n         0 => 0i32,\n-        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        1 => 1u32,\n         _ => 2u32,\n     }\n }\n@@ -86,7 +86,7 @@ fn man() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed\n     if false {\n         0i32\n     } else {\n-        1u32 //~ ERROR `if` and `else` have incompatible types\n+        1u32\n     }\n }\n "}, {"sha": "9205d74504f6f2d6c43e77213cc7338d66909709", "filename": "tests/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 30, "deletions": 78, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -171,108 +171,60 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn hat() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n-   |\n-LL | fn hat() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n-   |\n-LL |             return Box::new(0i32);\n-   |                    +++++++++    +\n-help: ... and box this value\n-   |\n-LL |             Box::new(1u32)\n-   |             +++++++++    +\n-\n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | /     match 13 {\n-LL | |         0 => 0i32,\n-   | |              ---- this is found to be of type `i32`\n-LL | |         1 => 1u32,\n-   | |              ^^^^ expected `i32`, found `u32`\n-LL | |         _ => 2u32,\n-LL | |     }\n-   | |_____- `match` arms have incompatible types\n+LL | fn hat() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-help: change the type of the numeric literal from `u32` to `i32`\n+LL ~ fn hat() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => {\n+LL ~             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+LL ~             Box::new(1u32)\n    |\n-LL |         1 => 1i32,\n-   |               ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:77:13\n    |\n LL | fn pug() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n-   |\n-LL | fn pug() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL |         0 => Box::new(0i32),\n-   |              +++++++++    +\n-help: ... and box this value\n-   |\n-LL |         1 => Box::new(1u32),\n-   |              +++++++++    +\n-help: ... and box this value\n-   |\n-LL |         _ => Box::new(2u32),\n-   |              +++++++++    +\n-\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n+LL | fn pug() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | /     if false {\n-LL | |         0i32\n-   | |         ---- expected because of this\n-LL | |     } else {\n-LL | |         1u32\n-   | |         ^^^^ expected `i32`, found `u32`\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n-   |\n-help: change the type of the numeric literal from `u32` to `i32`\n+LL ~ fn pug() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL ~         0 => Box::new(0i32),\n+LL ~         1 => Box::new(1u32),\n+LL ~         _ => Box::new(2u32),\n    |\n-LL |         1i32\n-   |          ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:85:13\n    |\n LL | fn man() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn man() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n+LL | fn man() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         Box::new(0i32)\n-   |         +++++++++    +\n-help: ... and box this value\n+LL ~ fn man() -> Box<dyn std::fmt::Display> {\n+LL |     if false {\n+LL ~         Box::new(0i32)\n+LL |     } else {\n+LL ~         Box::new(1u32)\n    |\n-LL |         Box::new(1u32)\n-   |         +++++++++    +\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 12 previous errors\n \n Some errors have detailed explanations: E0308, E0746.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "cf4e06316a71004ab67f44de63bbb74e57cf4000", "filename": "tests/ui/issues/issue-18107.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-18107.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -4,14 +4,18 @@ error[E0746]: return type cannot have an unboxed trait object\n LL |     dyn AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use `impl AbstractRenderer` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL |     impl AbstractRenderer\n+   |     ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n+LL ~     Box<dyn AbstractRenderer>\n+LL |\n+LL | {\n+LL |     match 0 {\n+LL ~         _ => Box::new(unimplemented!())\n    |\n-LL |     Box<dyn AbstractRenderer>\n-   |     ++++                    +\n \n error: aborting due to previous error\n "}, {"sha": "321c2ebf5a12244eb23e27231f7670743e054788", "filename": "tests/ui/unsized/box-instead-of-dyn-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -8,7 +8,6 @@ fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n         move || println!(\"{a}\")\n     } else {\n         Box::new(move || println!(\"{}\", b))\n-        //~^ ERROR `if` and `else` have incompatible types\n     }\n }\n "}, {"sha": "6087f5c5465266f570d9f647c5837c9897367ee7", "filename": "tests/ui/unsized/box-instead-of-dyn-fn.stderr", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -1,42 +1,21 @@\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/box-instead-of-dyn-fn.rs:10:9\n-   |\n-LL | /     if a % 2 == 0 {\n-LL | |         move || println!(\"{a}\")\n-   | |         -----------------------\n-   | |         |\n-   | |         the expected closure\n-   | |         expected because of this\n-LL | |     } else {\n-LL | |         Box::new(move || println!(\"{}\", b))\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found `Box<[closure@box-instead-of-dyn-fn.rs:10:18]>`\n-LL | |\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n-   |\n-   = note: expected closure `[closure@$DIR/box-instead-of-dyn-fn.rs:8:9: 8:16]`\n-               found struct `Box<[closure@$DIR/box-instead-of-dyn-fn.rs:10:18: 10:25]>`\n-\n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/box-instead-of-dyn-fn.rs:5:56\n    |\n LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n    |                                                        ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Fn() + 'a` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> impl Fn() + 'a {\n+   |                                                        ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n-   |                                                        ++++             +\n-help: ... and box this value\n+LL ~ fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n+LL |\n+LL |     if a % 2 == 0 {\n+LL ~         Box::new(move || println!(\"{a}\"))\n    |\n-LL |         Box::new(move || println!(\"{a}\"))\n-   |         +++++++++                       +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0746.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "da5c4322403486d6557c1b40a851e8caebca21a4", "filename": "tests/ui/unsized/issue-91801.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fissue-91801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fissue-91801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fissue-91801.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -4,11 +4,10 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n    |                                                                             ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a` as the return type, as all return paths are of type `Box<[closure@$DIR/issue-91801.rs:10:21: 10:70]>`, which implements `Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a`\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a {\n-   |                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Box<Validator<'a>> {\n+   |                                                                             ++++             +\n \n error: aborting due to previous error\n "}, {"sha": "a43b8d0741f2c6bbf4b2b3ee7f063a84da53f115", "filename": "tests/ui/unsized/issue-91803.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fissue-91803.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b26b80dd56f03affae07eeaffae5c284247a40b/tests%2Fui%2Funsized%2Fissue-91803.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fissue-91803.stderr?ref=4b26b80dd56f03affae07eeaffae5c284247a40b", "patch": "@@ -4,11 +4,14 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n    |                                           ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Foo<'a>` as the return type, as all return paths are of type `Box<_>`, which implements `Foo<'a>`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn or<'a>(first: &'static dyn Foo<'a>) -> impl Foo<'a> {\n-   |                                           ~~~~~~~~~~~~\n+   |                                           ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> Box<dyn Foo<'a>> {\n+   |                                           ++++           +\n \n error: aborting due to previous error\n "}]}