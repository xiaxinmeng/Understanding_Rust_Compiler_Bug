{"sha": "6a2d2c949581c710eeb505000e56ffa1e5a860b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMmQyYzk0OTU4MWM3MTBlZWI1MDUwMDBlNTZmZmExZTVhODYwYjU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-29T04:16:43Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-09-21T20:47:57Z"}, "message": "Adds a `ProcMacro` form of syntax extension\n\nThis commit adds syntax extension forms matching the types for procedural macros 2.0 (RFC #1566), these still require the usual syntax extension boiler plate, but this is a first step towards proper implementation and should be useful for macros 1.1 stuff too.\n\nSupports both attribute-like and function-like macros.", "tree": {"sha": "053157b72ce58708786d8356c07aaafbef95e5c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/053157b72ce58708786d8356c07aaafbef95e5c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a2d2c949581c710eeb505000e56ffa1e5a860b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2d2c949581c710eeb505000e56ffa1e5a860b5", "html_url": "https://github.com/rust-lang/rust/commit/6a2d2c949581c710eeb505000e56ffa1e5a860b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a2d2c949581c710eeb505000e56ffa1e5a860b5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c772948b687488a087356cb91432425662e034b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c772948b687488a087356cb91432425662e034b9", "html_url": "https://github.com/rust-lang/rust/commit/c772948b687488a087356cb91432425662e034b9"}], "stats": {"total": 440, "additions": 422, "deletions": 18}, "files": [{"sha": "f8bce297a42ad654679e2b8d3ce2133325140281", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -111,6 +111,8 @@ impl<'a> Registry<'a> {\n             }\n             MultiDecorator(ext) => MultiDecorator(ext),\n             MultiModifier(ext) => MultiModifier(ext),\n+            SyntaxExtension::ProcMacro(ext) => SyntaxExtension::ProcMacro(ext),\n+            SyntaxExtension::AttrProcMacro(ext) => SyntaxExtension::AttrProcMacro(ext),\n         }));\n     }\n "}, {"sha": "82db9ffca83a46e951da57e8caedfb9422fcf0cf", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 195, "deletions": 8, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::SyntaxExtension::*;\n+pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT, MacroRulesTT};\n \n use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n@@ -19,7 +19,7 @@ use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n use parse;\n-use parse::parser;\n+use parse::parser::{self, Parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n@@ -31,7 +31,8 @@ use feature_gate;\n use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use tokenstream;\n+use std::default::Default;\n+use tokenstream::{self, TokenStream};\n \n \n #[derive(Debug,Clone)]\n@@ -60,6 +61,14 @@ impl HasAttrs for Annotatable {\n }\n \n impl Annotatable {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            Annotatable::Item(ref item) => item.span,\n+            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n+            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -146,6 +155,173 @@ impl Into<Vec<Annotatable>> for Annotatable {\n     }\n }\n \n+pub trait ProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   ts: TokenStream)\n+                   -> Box<MacResult+'cx>;\n+}\n+\n+impl<F> ProcMacro for F\n+    where F: Fn(TokenStream) -> TokenStream\n+{\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   ts: TokenStream)\n+                   -> Box<MacResult+'cx> {\n+        let result = (*self)(ts);\n+        // FIXME setup implicit context in TLS before calling self.\n+        let parser = ecx.new_parser_from_tts(&result.to_tts());\n+        Box::new(TokResult { parser: parser, span: span })\n+    }\n+}\n+\n+pub trait AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> Box<MacResult+'cx>;\n+}\n+\n+impl<F> AttrProcMacro for F\n+    where F: Fn(TokenStream, TokenStream) -> TokenStream\n+{\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> Box<MacResult+'cx> {\n+        // FIXME setup implicit context in TLS before calling self.\n+        let parser = ecx.new_parser_from_tts(&(*self)(annotation, annotated).to_tts());\n+        Box::new(TokResult { parser: parser, span: span })\n+    }\n+}\n+\n+struct TokResult<'a> {\n+    parser: Parser<'a>,\n+    span: Span,\n+}\n+\n+impl<'a> MacResult for TokResult<'a> {\n+    fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n+        if self.parser.sess.span_diagnostic.has_errors() {\n+            return None;\n+        }\n+\n+        let mut items = SmallVector::zero();\n+        loop {\n+            match self.parser.parse_item() {\n+                Ok(Some(item)) => {\n+                    // FIXME better span info.\n+                    let mut item = item.unwrap();\n+                    item.span = self.span;\n+                    items.push(P(item));\n+                }\n+                Ok(None) => {\n+                    return Some(items);\n+                }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n+        let mut items = SmallVector::zero();\n+        loop {\n+            match self.parser.parse_impl_item() {\n+                Ok(mut item) => {\n+                    // FIXME better span info.\n+                    item.span = self.span;\n+                    items.push(item);\n+\n+                    return Some(items);\n+                }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        let mut items = SmallVector::zero();\n+        loop {\n+            match self.parser.parse_trait_item() {\n+                Ok(mut item) => {\n+                    // FIXME better span info.\n+                    item.span = self.span;\n+                    items.push(item);\n+\n+                    return Some(items);\n+                }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n+        match self.parser.parse_expr() {\n+            Ok(e) => Some(e),\n+            Err(mut e) => {\n+                e.emit();\n+                return None;\n+            }\n+        }\n+    }\n+\n+    fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n+        match self.parser.parse_pat() {\n+            Ok(e) => Some(e),\n+            Err(mut e) => {\n+                e.emit();\n+                return None;\n+            }\n+        }\n+    }\n+\n+    fn make_stmts(mut self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n+        let mut stmts = SmallVector::zero();\n+        loop {\n+            if self.parser.token == token::Eof {\n+                return Some(stmts);\n+            }\n+            match self.parser.parse_full_stmt(true) {\n+                Ok(Some(mut stmt)) => {\n+                    stmt.span = self.span;\n+                    stmts.push(stmt);\n+                }\n+                Ok(None) => { /* continue */ }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n+        match self.parser.parse_ty() {\n+            Ok(e) => Some(e),\n+            Err(mut e) => {\n+                e.emit();\n+                return None;\n+            }\n+        }\n+    }\n+}\n+\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,\n@@ -439,24 +615,35 @@ pub enum SyntaxExtension {\n     /// based upon it.\n     ///\n     /// `#[derive(...)]` is a `MultiItemDecorator`.\n-    MultiDecorator(Box<MultiItemDecorator + 'static>),\n+    ///\n+    /// Prefer ProcMacro or MultiModifier since they are more flexible.\n+    MultiDecorator(Box<MultiItemDecorator>),\n \n     /// A syntax extension that is attached to an item and modifies it\n-    /// in-place. More flexible version than Modifier.\n-    MultiModifier(Box<MultiItemModifier + 'static>),\n+    /// in-place. Also allows decoration, i.e., creating new items.\n+    MultiModifier(Box<MultiItemModifier>),\n+\n+    /// A function-like procedural macro. TokenStream -> TokenStream.\n+    ProcMacro(Box<ProcMacro>),\n+\n+    /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n+    /// The first TokenSteam is the attribute, the second is the annotated item.\n+    /// Allows modification of the input items and adding new items, similar to\n+    /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n+    AttrProcMacro(Box<AttrProcMacro>),\n \n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n     ///\n     /// The `bool` dictates whether the contents of the macro can\n     /// directly use `#[unstable]` things (true == yes).\n-    NormalTT(Box<TTMacroExpander + 'static>, Option<Span>, bool),\n+    NormalTT(Box<TTMacroExpander>, Option<Span>, bool),\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    IdentTT(Box<IdentMacroExpander + 'static>, Option<Span>, bool),\n+    IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);"}, {"sha": "f022dd3a08b5edaff3097bd63c4ebfba05fd37b5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -22,8 +22,9 @@ use feature_gate::{self, Features};\n use fold;\n use fold::*;\n use parse::token::{intern, keywords};\n+use parse::span_to_tts;\n use ptr::P;\n-use tokenstream::TokenTree;\n+use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n \n@@ -308,6 +309,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n             }\n+            SyntaxExtension::AttrProcMacro(ref mac) => {\n+                let attr_toks = TokenStream::from_tts(span_to_tts(&fld.cx.parse_sess,\n+                                                                  attr.span));\n+                let item_toks = TokenStream::from_tts(span_to_tts(&fld.cx.parse_sess,\n+                                                                  item.span()));\n+                let result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n+                let items = match item {\n+                    Annotatable::Item(_) => result.make_items()\n+                                                  .unwrap_or(SmallVector::zero())\n+                                                  .into_iter()\n+                                                  .map(|i| Annotatable::Item(i))\n+                                                  .collect(),\n+                    Annotatable::TraitItem(_) => result.make_trait_items()\n+                                                       .unwrap_or(SmallVector::zero())\n+                                                       .into_iter()\n+                                                       .map(|i| Annotatable::TraitItem(P(i)))\n+                                                       .collect(),\n+                    Annotatable::ImplItem(_) => result.make_impl_items()\n+                                                      .unwrap_or(SmallVector::zero())\n+                                                      .into_iter()\n+                                                      .map(|i| Annotatable::ImplItem(P(i)))\n+                                                      .collect(),\n+                };\n+                kind.expect_from_annotatables(items)\n+            }\n             _ => unreachable!(),\n         }\n     }\n@@ -377,11 +403,34 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.make_from(expander.expand(self.cx, span, ident, marked_tts, attrs))\n             }\n \n-            MultiDecorator(..) | MultiModifier(..) => {\n+            MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", extname));\n                 return kind.dummy(span);\n             }\n+\n+            SyntaxExtension::ProcMacro(ref expandfun) => {\n+                if ident.name != keywords::Invalid.name() {\n+                    let msg =\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                    fld.cx.span_err(path.span, &msg);\n+                    return None;\n+                }\n+\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        // FIXME procedural macros do not have proper span info\n+                        // yet, when they do, we should use it here.\n+                        span: None,\n+                        // FIXME probably want to follow macro_rules macros here.\n+                        allow_internal_unstable: false,\n+                    },\n+                });\n+\n+                Some(expandfun.expand(fld.cx, call_site, TokenStream::from_tts(marked_tts)))\n+            }\n         };\n \n         let expanded = if let Some(expanded) = opt_expanded {"}, {"sha": "dc3a01f41bc9db92392877a147d44d9ac48923f8", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -24,7 +24,9 @@ use ext::base::*;\n \n /// Take a `ExtCtxt`, `Span`, and `TokenStream`, and produce a Macro Result that parses\n /// the TokenStream as a block and returns it as an `Expr`.\n-pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt, sp: Span, output: TokenStream)\n+pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt,\n+                                sp: Span,\n+                                output: TokenStream)\n                                 -> Box<MacResult + 'cx> {\n     let parser = cx.new_parser_from_tts(&output.to_tts());\n \n@@ -60,7 +62,7 @@ pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt, sp: Span, output: TokenStr\n }\n \n pub mod prelude {\n-    pub use ext::proc_macro_shim::build_block_emitter;\n+    pub use super::build_block_emitter;\n     pub use ast::Ident;\n     pub use codemap::{DUMMY_SP, Span};\n     pub use ext::base::{ExtCtxt, MacResult};"}, {"sha": "53294e78710bc9b00d5eb039e7c452e3a7a95fac", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -85,6 +85,12 @@ pub struct StringReader<'a> {\n     /// The last character to be read\n     pub curr: Option<char>,\n     pub filemap: Rc<syntax_pos::FileMap>,\n+    /// If Some, stop reading the source at this position (inclusive).\n+    pub terminator: Option<BytePos>,\n+    /// Whether to record new-lines in filemap. This is only necessary the first\n+    /// time a filemap is lexed. If part of a filemap is being re-lexed, this\n+    /// should be set to false.\n+    pub save_new_lines: bool,\n     // cached:\n     pub peek_tok: token::Token,\n     pub peek_span: Span,\n@@ -96,7 +102,15 @@ pub struct StringReader<'a> {\n \n impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool {\n-        self.curr.is_none()\n+        if self.curr.is_none() {\n+            return true;\n+        }\n+\n+        match self.terminator {\n+            Some(t) => self.pos > t,\n+            None => false,\n+        }\n+\n     }\n     /// Return the next token. EFFECT: advances the string_reader.\n     fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n@@ -164,6 +178,14 @@ impl<'a> StringReader<'a> {\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<syntax_pos::FileMap>)\n                        -> StringReader<'b> {\n+        let mut sr = StringReader::new_raw_internal(span_diagnostic, filemap);\n+        sr.bump();\n+        sr\n+    }\n+\n+    fn new_raw_internal<'b>(span_diagnostic: &'b Handler,\n+                            filemap: Rc<syntax_pos::FileMap>)\n+                            -> StringReader<'b> {\n         if filemap.src.is_none() {\n             span_diagnostic.bug(&format!(\"Cannot lex filemap \\\n                                           without source: {}\",\n@@ -172,21 +194,21 @@ impl<'a> StringReader<'a> {\n \n         let source_text = (*filemap.src.as_ref().unwrap()).clone();\n \n-        let mut sr = StringReader {\n+        StringReader {\n             span_diagnostic: span_diagnostic,\n             pos: filemap.start_pos,\n             last_pos: filemap.start_pos,\n             col: CharPos(0),\n             curr: Some('\\n'),\n             filemap: filemap,\n+            terminator: None,\n+            save_new_lines: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n             source_text: source_text,\n             fatal_errs: Vec::new(),\n-        };\n-        sr.bump();\n-        sr\n+        }\n     }\n \n     pub fn new<'b>(span_diagnostic: &'b Handler,\n@@ -200,6 +222,28 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n+    pub fn from_span<'b>(span_diagnostic: &'b Handler,\n+                         span: Span,\n+                         codemap: &CodeMap)\n+                         -> StringReader<'b> {\n+        let start_pos = codemap.lookup_byte_offset(span.lo);\n+        let last_pos = codemap.lookup_byte_offset(span.hi);\n+        assert!(start_pos.fm.name == last_pos.fm.name, \"Attempt to lex span which crosses files\");\n+        let mut sr = StringReader::new_raw_internal(span_diagnostic, start_pos.fm.clone());\n+        sr.pos = span.lo;\n+        sr.last_pos = span.lo;\n+        sr.terminator = Some(span.hi);\n+        sr.save_new_lines = false;\n+\n+        sr.bump();\n+\n+        if let Err(_) = sr.advance_token() {\n+            sr.emit_fatal_errors();\n+            panic!(FatalError);\n+        }\n+        sr\n+    }\n+\n     pub fn curr_is(&self, c: char) -> bool {\n         self.curr == Some(c)\n     }\n@@ -405,7 +449,9 @@ impl<'a> StringReader<'a> {\n             self.curr = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n-                self.filemap.next_line(self.last_pos);\n+                if self.save_new_lines {\n+                    self.filemap.next_line(self.last_pos);\n+                }\n                 self.col = CharPos(0);\n             }\n "}, {"sha": "4ad8e227cbb544769171777d90ea9db704eecedc", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -258,6 +258,13 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     }\n }\n \n+pub fn span_to_tts(sess: &ParseSess, span: Span) -> Vec<tokenstream::TokenTree> {\n+    let cfg = Vec::new();\n+    let srdr = lexer::StringReader::from_span(&sess.span_diagnostic, span, &sess.code_map);\n+    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n+    panictry!(p1.parse_all_token_trees())\n+}\n+\n /// Given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<tokenstream::TokenTree> {"}, {"sha": "b35b4617ea11ec139e8abe989f1861e7cf49fef5", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -33,6 +33,7 @@ use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n+use print::pprust;\n \n use std::fmt;\n use std::iter::*;\n@@ -781,6 +782,12 @@ impl TokenStream {\n     }\n }\n \n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&pprust::tts_to_string(&self.to_tts()))\n+    }\n+}\n+\n // FIXME Reimplement this iterator to hold onto a slice iterator for a leaf, getting the\n // next leaf's iterator when the current one is exhausted.\n pub struct Iter<'a> {"}, {"sha": "52c38a6ee038cee8a9d6764ba73435462c47a541", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(plugin, plugin_registrar, rustc_private)]\n+\n+extern crate proc_macro;\n+extern crate rustc_plugin;\n+extern crate syntax;\n+\n+use proc_macro::prelude::*;\n+use rustc_plugin::Registry;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::proc_macro_shim::prelude::*;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_syntax_extension(token::intern(\"attr_tru\"),\n+                                  SyntaxExtension::AttrProcMacro(Box::new(attr_tru)));\n+    reg.register_syntax_extension(token::intern(\"attr_identity\"),\n+                                  SyntaxExtension::AttrProcMacro(Box::new(attr_identity)));\n+    reg.register_syntax_extension(token::intern(\"tru\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(tru)));\n+    reg.register_syntax_extension(token::intern(\"ret_tru\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(ret_tru)));\n+    reg.register_syntax_extension(token::intern(\"identity\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(identity)));\n+}\n+\n+fn attr_tru(_attr: TokenStream, _item: TokenStream) -> TokenStream {\n+    lex(\"fn f1() -> bool { true }\")\n+}\n+\n+fn attr_identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let source = item.to_string();\n+    lex(&source)\n+}\n+\n+fn tru(_ts: TokenStream) -> TokenStream {\n+    lex(\"true\")\n+}\n+\n+fn ret_tru(_ts: TokenStream) -> TokenStream {\n+    lex(\"return true;\")\n+}\n+\n+fn identity(ts: TokenStream) -> TokenStream {\n+    let source = ts.to_string();\n+    lex(&source)\n+}"}, {"sha": "22cc9f0f8d40e32e8b497f040c5b1a782fe0dce6", "filename": "src/test/run-pass-fulldeps/proc_macro.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2d2c949581c710eeb505000e56ffa1e5a860b5/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs?ref=6a2d2c949581c710eeb505000e56ffa1e5a860b5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:proc_macro_def.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+\n+#![feature(plugin, custom_attribute)]\n+#![feature(type_macros)]\n+\n+#![plugin(proc_macro_def)]\n+\n+#[attr_tru]\n+fn f1() -> bool {\n+    return false;\n+}\n+\n+#[attr_identity]\n+fn f2() -> bool {\n+    return identity!(true);\n+}\n+\n+fn f3() -> identity!(bool) {\n+    ret_tru!();\n+}\n+\n+fn f4(x: bool) -> bool {\n+    match x {\n+        identity!(true) => false,\n+        identity!(false) => true,\n+    }\n+}\n+\n+fn main() {\n+    assert!(f1());\n+    assert!(f2());\n+    assert!(tru!());\n+    assert!(f3());\n+    assert!(identity!(5 == 5));\n+    assert!(f4(false));\n+}"}]}