{"sha": "5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "node_id": "C_kwDOAAsO6NoAKDViZTJmNTE0MjhkZDJkYWVhZmM1ODJkNWMwNjMyOGUyMWYyZmQ1YTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T05:15:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T05:15:28Z"}, "message": "Rollup merge of #107285 - compiler-errors:new-solver-future-and-generator, r=lcnr\n\nImplement `Generator` and `Future` in the new solver\n\nr? `@lcnr`", "tree": {"sha": "3f0a870f65a3b92019cf7d3d2311e13ddac62571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f0a870f65a3b92019cf7d3d2311e13ddac62571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0gxwCRBK7hj4Ov3rIwAAfz8IAAABnLOCI7F0qe1A6I+J9rsg\nmyI11pAQUoMBUlRrS9AaO7ixmNauEhbugHkYd6RSwO75f8M/47vpQ+nApPlslXN6\npuDRuyzq9TadcpU2XKC5jFIcmRDHYbbtyUQksnJRaZPAziTMWSvkwsfe+2xa9nz+\n0jyeCcAKlPqeDZA+WlV+w+SrH8lcIhJgjIWJDnNm3Wdgasi/CYHaICDzv/uFCc39\nWUIQosEDE25D+3yqm+dB6w7Q7OyYfNOx7JF4zhG3CpKN4p37DSMa5bBJ8GkJuVrf\n7nwQEy6QeCgF538WDzy4fuGkojcViIoeBmOznTmH54Ck/kZCkuKuXlo/s4V9b9w=\n=mNT1\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f0a870f65a3b92019cf7d3d2311e13ddac62571\nparent a84e0601738ac8ba6da81acb394027f8a7bff646\nparent d600b94ebb5a418ba011797b85045975f18f90dd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674710128 +0100\ncommitter GitHub <noreply@github.com> 1674710128 +0100\n\nRollup merge of #107285 - compiler-errors:new-solver-future-and-generator, r=lcnr\n\nImplement `Generator` and `Future` in the new solver\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "html_url": "https://github.com/rust-lang/rust/commit/5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a84e0601738ac8ba6da81acb394027f8a7bff646", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84e0601738ac8ba6da81acb394027f8a7bff646", "html_url": "https://github.com/rust-lang/rust/commit/a84e0601738ac8ba6da81acb394027f8a7bff646"}, {"sha": "d600b94ebb5a418ba011797b85045975f18f90dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d600b94ebb5a418ba011797b85045975f18f90dd", "html_url": "https://github.com/rust-lang/rust/commit/d600b94ebb5a418ba011797b85045975f18f90dd"}], "stats": {"total": 327, "additions": 316, "deletions": 11}, "files": [{"sha": "baff0f8630ee56ce01fcf2665d8e7626fa3cc283", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -138,6 +138,16 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -266,6 +276,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_tuple_candidate(self, goal)\n         } else if lang_items.pointee_trait() == Some(trait_def_id) {\n             G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.future_trait() == Some(trait_def_id) {\n+            G::consider_builtin_future_candidate(self, goal)\n+        } else if lang_items.gen_trait() == Some(trait_def_id) {\n+            G::consider_builtin_generator_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "278024b22760a754a8634d5cd16b58f583948da6", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -1,13 +1,14 @@\n use std::mem;\n \n-use super::{Certainty, InferCtxtEvalExt};\n-use rustc_infer::{\n-    infer::InferCtxt,\n-    traits::{\n-        query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n-        SelectionError, TraitEngine,\n-    },\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::{\n+    query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n+    PredicateObligation, SelectionError, TraitEngine,\n };\n+use rustc_middle::ty;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+\n+use super::{Certainty, InferCtxtEvalExt};\n \n /// A trait engine using the new trait solver.\n ///\n@@ -70,9 +71,55 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),\n-                            code: FulfillmentErrorCode::CodeSelectionError(\n-                                SelectionError::Unimplemented,\n-                            ),\n+                            code: match goal.predicate.kind().skip_binder() {\n+                                ty::PredicateKind::Clause(ty::Clause::Projection(_)) => {\n+                                    FulfillmentErrorCode::CodeProjectionError(\n+                                        // FIXME: This could be a `Sorts` if the term is a type\n+                                        MismatchedProjectionTypes { err: TypeError::Mismatch },\n+                                    )\n+                                }\n+                                ty::PredicateKind::Subtype(pred) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((pred.a, pred.b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(true, a, b);\n+                                    FulfillmentErrorCode::CodeSubtypeError(\n+                                        expected_found,\n+                                        TypeError::Sorts(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::Coerce(pred) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((pred.a, pred.b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(false, a, b);\n+                                    FulfillmentErrorCode::CodeSubtypeError(\n+                                        expected_found,\n+                                        TypeError::Sorts(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::ConstEquate(a, b) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((a, b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(true, a, b);\n+                                    FulfillmentErrorCode::CodeConstEquateError(\n+                                        expected_found,\n+                                        TypeError::ConstMismatch(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::Clause(_)\n+                                | ty::PredicateKind::WellFormed(_)\n+                                | ty::PredicateKind::ObjectSafe(_)\n+                                | ty::PredicateKind::ClosureKind(_, _, _)\n+                                | ty::PredicateKind::ConstEvaluatable(_)\n+                                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                                | ty::PredicateKind::Ambiguous => {\n+                                    FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented,\n+                                    )\n+                                }\n+                            },\n                             root_obligation: obligation,\n                         });\n                         continue;"}, {"sha": "4a9b95af4a27cbc8f20618c10f8099a5e5367106", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n use rustc_middle::ty::{ToPredicate, TypeVisitable};\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -482,6 +482,73 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.evaluate_all_and_make_canonical_response(nested_goals)\n         })\n     }\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // Generators are not futures unless they come from `async` desugaring\n+        let tcx = ecx.tcx();\n+        if !tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let term = substs.as_generator().return_ty().into();\n+\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(ty::ProjectionPredicate {\n+                projection_ty: ecx.tcx().mk_alias_ty(goal.predicate.def_id(), [self_ty]),\n+                term,\n+            })\n+            .to_predicate(tcx),\n+        )\n+    }\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // `async`-desugared generators do not implement the generator trait\n+        let tcx = ecx.tcx();\n+        if tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let generator = substs.as_generator();\n+\n+        let name = tcx.associated_item(goal.predicate.def_id()).name;\n+        let term = if name == sym::Return {\n+            generator.return_ty().into()\n+        } else if name == sym::Yield {\n+            generator.yield_ty().into()\n+        } else {\n+            bug!(\"unexpected associated item `<{self_ty} as Generator>::{name}`\")\n+        };\n+\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(ty::ProjectionPredicate {\n+                projection_ty: ecx\n+                    .tcx()\n+                    .mk_alias_ty(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n+                term,\n+            })\n+            .to_predicate(tcx),\n+        )\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "d74857dc4b4803bac6b418941d6e9122dd1fae3b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -192,6 +192,50 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         ecx.make_canonical_response(Certainty::Yes)\n     }\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let ty::Generator(def_id, _, _) = *goal.predicate.self_ty().kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // Generators are not futures unless they come from `async` desugaring\n+        let tcx = ecx.tcx();\n+        if !tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        // Async generator unconditionally implement `Future`\n+        ecx.make_canonical_response(Certainty::Yes)\n+    }\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // `async`-desugared generators do not implement the generator trait\n+        let tcx = ecx.tcx();\n+        if tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let generator = substs.as_generator();\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(\n+                tcx.mk_trait_ref(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n+            )\n+            .to_predicate(tcx),\n+        )\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "162953180c75ce09717fb2c071edec930acac33f", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -173,6 +173,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n     }\n }\n \n+// Returns a binder of the tupled inputs types and output type from a builtin callable type.\n pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     self_ty: Ty<'tcx>,"}, {"sha": "b395c23ae00572d7ee65a74ecfa71fe6a3dceb8a", "filename": "tests/ui/traits/new-solver/async.fail.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: expected `[async block@$DIR/async.rs:12:17: 12:25]` to be a future that resolves to `i32`, but it resolves to `()`\n+  --> $DIR/async.rs:12:17\n+   |\n+LL |     needs_async(async {});\n+   |     ----------- ^^^^^^^^ expected `i32`, found `()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `needs_async`\n+  --> $DIR/async.rs:8:31\n+   |\n+LL | fn needs_async(_: impl Future<Output = i32>) {}\n+   |                               ^^^^^^^^^^^^ required by this bound in `needs_async`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "195cc35cad2adb9be9f383868b59066c1a9eee3c", "filename": "tests/ui/traits/new-solver/async.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// edition: 2021\n+// revisions: pass fail\n+//[pass] check-pass\n+\n+use std::future::Future;\n+\n+fn needs_async(_: impl Future<Output = i32>) {}\n+\n+#[cfg(fail)]\n+fn main() {\n+    needs_async(async {});\n+    //[fail]~^ ERROR to be a future that resolves to `i32`, but it resolves to `()`\n+}\n+\n+#[cfg(pass)]\n+fn main() {\n+    needs_async(async { 1i32 });\n+}"}, {"sha": "d94d41e3587b6572162e2122fc22c7fb4222eb0b", "filename": "tests/ui/traits/new-solver/generator.fail.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -0,0 +1,64 @@\n+error[E0277]: the trait bound `[generator@$DIR/generator.rs:18:21: 18:23]: Generator<A>` is not satisfied\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ the trait `Generator<A>` is not implemented for `[generator@$DIR/generator.rs:18:21: 18:23]`\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:28\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator.rs:18:21: 18:23] as Generator<A>>::Yield == B`\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ types differ\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:41\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                                         ^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator.rs:18:21: 18:23] as Generator<A>>::Return == C`\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ types differ\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:52\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                                                    ^^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0271, E0277.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "364373ca8be7172f35bade6e744e586c96258d1a", "filename": "tests/ui/traits/new-solver/generator.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be2f51428dd2daeafc582d5c06328e21f2fd5a9/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs?ref=5be2f51428dd2daeafc582d5c06328e21f2fd5a9", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -Ztrait-solver=next\n+// edition: 2021\n+// revisions: pass fail\n+//[pass] check-pass\n+\n+#![feature(generator_trait, generators)]\n+\n+use std::ops::Generator;\n+\n+struct A;\n+struct B;\n+struct C;\n+\n+fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+\n+#[cfg(fail)]\n+fn main() {\n+    needs_generator(|| {\n+        //[fail]~^ ERROR Generator<A>` is not satisfied\n+        //[fail]~| ERROR as Generator<A>>::Yield == B`\n+        //[fail]~| ERROR as Generator<A>>::Return == C`\n+        yield ();\n+    });\n+}\n+\n+#[cfg(pass)]\n+fn main() {\n+    needs_generator(|_: A| {\n+        let _: A = yield B;\n+        C\n+    })\n+}"}]}