{"sha": "2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNmUzNzY0YjRlMmZlY2YxYjFhOGMzYTE3NGU5MzkwNmQ1NTU3MDM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-20T11:58:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-20T11:58:29Z"}, "message": "Rollup merge of #66497 - Nadrieril:fix-53820, r=varkor\n\nFix #53820\n\nThis fixes ICE #53820 by being more clever when matching large arrays with slice patterns.\nIn particular, it avoids treating large arrays like large tuples, and instead reuses the `VarLenSlice` constructor behaviour to only consider as little values as needed.\nAs a side-effect, such matches also get improved diagnostics, by reporting `[true, ..]` missing instead of `[true, _, _, _, _, _, _, _]`.", "tree": {"sha": "3c1eba96914c206d082b1d12dad17368607416b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c1eba96914c206d082b1d12dad17368607416b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1SplCRBK7hj4Ov3rIwAAdHIIAKs2VrzHxnGKW0sXVWQvmDpT\nOKs3+vJTOD8nkjEbUfDyA1cLJgoQMtG3wKQBN4/1kuy+gBi1Q45uO+KkuTMAGBtG\ncevEKgfHtL/sztAI72ETlZ0pltYNTlRQcZo0Nofo+xhNm0HcUDqNpSKWYp38AOkL\nMbv1TMjil80PKOUHnAvyRMN16V824zDccjCFoiI9smEuYG8kP+81IAcTLo/pjNY/\n+yHbYEHxNYFd8M8T9Fh4u/qPJJxxGX+GP2UHKZH6qpe/6nFQiePHedMA/aUkUUc+\ngcfBJZ60MdWaE1RK4og8mZgW3kUzV6ZP/7/vrMcp++n62gQmlKBw4bzcsP4/Csk=\n=KmZk\n-----END PGP SIGNATURE-----\n", "payload": "tree 3c1eba96914c206d082b1d12dad17368607416b6\nparent 3ef2384e50a44bd6ac5223da586bd0be63296383\nparent 1425ae1154f3541a32e9ca607c09ce50cfb1298e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574251109 +0100\ncommitter GitHub <noreply@github.com> 1574251109 +0100\n\nRollup merge of #66497 - Nadrieril:fix-53820, r=varkor\n\nFix #53820\n\nThis fixes ICE #53820 by being more clever when matching large arrays with slice patterns.\nIn particular, it avoids treating large arrays like large tuples, and instead reuses the `VarLenSlice` constructor behaviour to only consider as little values as needed.\nAs a side-effect, such matches also get improved diagnostics, by reporting `[true, ..]` missing instead of `[true, _, _, _, _, _, _, _]`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "html_url": "https://github.com/rust-lang/rust/commit/2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ef2384e50a44bd6ac5223da586bd0be63296383", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef2384e50a44bd6ac5223da586bd0be63296383", "html_url": "https://github.com/rust-lang/rust/commit/3ef2384e50a44bd6ac5223da586bd0be63296383"}, {"sha": "1425ae1154f3541a32e9ca607c09ce50cfb1298e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1425ae1154f3541a32e9ca607c09ce50cfb1298e", "html_url": "https://github.com/rust-lang/rust/commit/1425ae1154f3541a32e9ca607c09ce50cfb1298e"}], "stats": {"total": 434, "additions": 295, "deletions": 139}, "files": [{"sha": "5e7a7f01e7a328087e7d47f87b42b75369e2324b", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 228, "deletions": 111, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "patch": "@@ -225,6 +225,7 @@\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n use self::Constructor::*;\n+use self::SliceKind::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n@@ -582,6 +583,114 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum SliceKind {\n+    /// Patterns of length `n` (`[x, y]`).\n+    FixedLen(u64),\n+    /// Patterns using the `..` notation (`[x, .., y]`). Captures any array constructor of `length\n+    /// >= i + j`. In the case where `array_len` is `Some(_)`, this indicates that we only care\n+    /// about the first `i` and the last `j` values of the array, and everything in between is a\n+    /// wildcard `_`.\n+    VarLen(u64, u64),\n+}\n+\n+impl SliceKind {\n+    fn arity(self) -> u64 {\n+        match self {\n+            FixedLen(length) => length,\n+            VarLen(prefix, suffix) => prefix + suffix,\n+        }\n+    }\n+\n+    /// Whether this pattern includes patterns of length `other_len`.\n+    fn covers_length(self, other_len: u64) -> bool {\n+        match self {\n+            FixedLen(len) => len == other_len,\n+            VarLen(prefix, suffix) => prefix + suffix <= other_len,\n+        }\n+    }\n+\n+    /// Returns a collection of slices that spans the values covered by `self`, subtracted by the\n+    /// values covered by `other`: i.e., `self \\ other` (in set notation).\n+    fn subtract(self, other: Self) -> SmallVec<[Self; 1]> {\n+        // Remember, `VarLen(i, j)` covers the union of `FixedLen` from `i + j` to infinity.\n+        // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+        match self {\n+            FixedLen(pos_len) => {\n+                if other.covers_length(pos_len) {\n+                    smallvec![]\n+                } else {\n+                    smallvec![self]\n+                }\n+            }\n+            VarLen(pos_prefix, pos_suffix) => {\n+                let pos_len = pos_prefix + pos_suffix;\n+                match other {\n+                    FixedLen(neg_len) => {\n+                        if neg_len < pos_len {\n+                            smallvec![self]\n+                        } else {\n+                            (pos_len..neg_len)\n+                                .map(FixedLen)\n+                                // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n+                                .chain(Some(VarLen(neg_len + 1 - pos_suffix, pos_suffix)))\n+                                .collect()\n+                        }\n+                    }\n+                    VarLen(neg_prefix, neg_suffix) => {\n+                        let neg_len = neg_prefix + neg_suffix;\n+                        if neg_len <= pos_len {\n+                            smallvec![]\n+                        } else {\n+                            (pos_len..neg_len).map(FixedLen).collect()\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct Slice {\n+    /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n+    array_len: Option<u64>,\n+    /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n+    kind: SliceKind,\n+}\n+\n+impl Slice {\n+    /// Returns what patterns this constructor covers: either fixed-length patterns or\n+    /// variable-length patterns.\n+    fn pattern_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n+                if prefix + suffix == len =>\n+            {\n+                FixedLen(len)\n+            }\n+            _ => self.kind,\n+        }\n+    }\n+\n+    /// Returns what values this constructor covers: either values of only one given length, or\n+    /// values of length above a given length.\n+    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n+    /// account a subset of the entries of the array, but still only captures values of a given\n+    /// length.\n+    fn value_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n+            _ => self.kind,\n+        }\n+    }\n+\n+    fn arity(self) -> u64 {\n+        self.pattern_kind().arity()\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n@@ -595,18 +704,16 @@ enum Constructor<'tcx> {\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n-    /// Array patterns of length `n`.\n-    FixedLenSlice(u64),\n-    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n-    VarLenSlice(u64, u64),\n+    /// Array and slice patterns.\n+    Slice(Slice),\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            FixedLenSlice { .. } | VarLenSlice { .. } => true,\n+            Slice(_) => true,\n             _ => false,\n         }\n     }\n@@ -635,76 +742,49 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &FixedLenSlice(self_len) => {\n-                let overlaps = |c: &Constructor<'_>| match *c {\n-                    FixedLenSlice(other_len) => other_len == self_len,\n-                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n-                    _ => false,\n-                };\n-                if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n-            }\n-            VarLenSlice(..) => {\n-                let mut remaining_ctors = vec![self.clone()];\n-\n-                // For each used ctor, subtract from the current set of constructors.\n-                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                // Remember, `VarLenSlice(i, j)` covers the union of `FixedLenSlice` from\n-                // `i + j` to infinity.\n-                for neg_ctor in other_ctors {\n-                    remaining_ctors = remaining_ctors\n-                        .into_iter()\n-                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n-                            // Compute `pos_ctor \\ neg_ctor`.\n-                            match (&pos_ctor, neg_ctor) {\n-                                (&FixedLenSlice(pos_len), &VarLenSlice(neg_prefix, neg_suffix)) => {\n-                                    let neg_len = neg_prefix + neg_suffix;\n-                                    if neg_len <= pos_len {\n-                                        smallvec![]\n-                                    } else {\n-                                        smallvec![pos_ctor]\n-                                    }\n-                                }\n-                                (\n-                                    &VarLenSlice(pos_prefix, pos_suffix),\n-                                    &VarLenSlice(neg_prefix, neg_suffix),\n-                                ) => {\n-                                    let neg_len = neg_prefix + neg_suffix;\n-                                    let pos_len = pos_prefix + pos_suffix;\n-                                    if neg_len <= pos_len {\n-                                        smallvec![]\n-                                    } else {\n-                                        (pos_len..neg_len).map(FixedLenSlice).collect()\n-                                    }\n-                                }\n-                                (&VarLenSlice(pos_prefix, pos_suffix), &FixedLenSlice(neg_len)) => {\n-                                    let pos_len = pos_prefix + pos_suffix;\n-                                    if neg_len < pos_len {\n-                                        smallvec![pos_ctor]\n-                                    } else {\n-                                        (pos_len..neg_len)\n-                                            .map(FixedLenSlice)\n-                                            // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n-                                            .chain(Some(VarLenSlice(\n-                                                neg_len + 1 - pos_suffix,\n-                                                pos_suffix,\n-                                            )))\n-                                            .collect()\n-                                    }\n-                                }\n-                                _ if pos_ctor == *neg_ctor => smallvec![],\n-                                _ => smallvec![pos_ctor],\n+            &Slice(slice) => {\n+                let mut other_slices = other_ctors\n+                    .iter()\n+                    .filter_map(|c: &Constructor<'_>| match c {\n+                        Slice(slice) => Some(*slice),\n+                        // FIXME(#65413): We ignore `ConstantValue`s here.\n+                        ConstantValue(..) => None,\n+                        _ => bug!(\"bad slice pattern constructor {:?}\", c),\n+                    })\n+                    .map(Slice::value_kind);\n+\n+                match slice.value_kind() {\n+                    FixedLen(self_len) => {\n+                        if other_slices.any(|other_slice| other_slice.covers_length(self_len)) {\n+                            vec![]\n+                        } else {\n+                            vec![Slice(slice)]\n+                        }\n+                    }\n+                    kind @ VarLen(..) => {\n+                        let mut remaining_slices = vec![kind];\n+\n+                        // For each used slice, subtract from the current set of slices.\n+                        for other_slice in other_slices {\n+                            remaining_slices = remaining_slices\n+                                .into_iter()\n+                                .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n+                                .collect();\n+\n+                            // If the constructors that have been considered so far already cover\n+                            // the entire range of `self`, no need to look at more constructors.\n+                            if remaining_slices.is_empty() {\n+                                break;\n                             }\n-                        })\n-                        .collect();\n+                        }\n \n-                    // If the constructors that have been considered so far already cover\n-                    // the entire range of `self`, no need to look at more constructors.\n-                    if remaining_ctors.is_empty() {\n-                        break;\n+                        remaining_slices\n+                            .into_iter()\n+                            .map(|kind| Slice { array_len: slice.array_len, kind })\n+                            .map(Slice)\n+                            .collect()\n                     }\n                 }\n-\n-                remaining_ctors\n             }\n             IntRange(self_range) => {\n                 let mut remaining_ranges = vec![self_range.clone()];\n@@ -798,7 +878,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => vec![],\n             },\n-            FixedLenSlice(_) | VarLenSlice(..) => match ty.kind {\n+            Slice(_) => match ty.kind {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = self.arity(cx, ty);\n                     (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n@@ -828,8 +908,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => 0,\n             },\n-            FixedLenSlice(length) => *length,\n-            VarLenSlice(prefix, suffix) => prefix + suffix,\n+            Slice(slice) => slice.arity(),\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n@@ -884,15 +963,31 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n-            FixedLenSlice(_) => {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n-            &VarLenSlice(prefix_len, _) => {\n-                let prefix = subpatterns.by_ref().take(prefix_len as usize).collect();\n-                let suffix = subpatterns.collect();\n-                let wild = Pat::wildcard_from_ty(ty);\n-                PatKind::Slice { prefix, slice: Some(wild), suffix }\n-            }\n+            Slice(slice) => match slice.pattern_kind() {\n+                FixedLen(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLen(prefix, _) => {\n+                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n+                    if slice.array_len.is_some() {\n+                        // Improves diagnostics a bit: if the type is a known-size array, instead\n+                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n+                        // This is incorrect if the size is not known, since `[_, ..]` captures\n+                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n+                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n+                            prefix.pop();\n+                        }\n+                    }\n+                    let suffix: Vec<_> = if slice.array_len.is_some() {\n+                        // Same as above.\n+                        subpatterns.skip_while(Pat::is_wildcard).collect()\n+                    } else {\n+                        subpatterns.collect()\n+                    };\n+                    let wild = Pat::wildcard_from_ty(ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+            },\n             &ConstantValue(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n@@ -1105,15 +1200,16 @@ fn all_constructors<'a, 'tcx>(\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n+            if len != 0 && cx.is_uninhabited(sub_ty) {\n+                vec![]\n+            } else {\n+                vec![Slice(Slice { array_len: Some(len), kind: VarLen(0, 0) })]\n+            }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n-            if cx.is_uninhabited(sub_ty) {\n-                vec![FixedLenSlice(0)]\n-            } else {\n-                vec![VarLenSlice(0, 0)]\n-            }\n+            let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+            vec![Slice(Slice { array_len: None, kind })]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             let ctors: Vec<_> = def\n@@ -1693,18 +1789,18 @@ fn pat_constructor<'tcx>(\n                 Some(FloatRange(lo, hi, end))\n             }\n         }\n-        PatKind::Array { .. } => match pat.ty.kind {\n-            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(tcx, param_env))),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n-        },\n-        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { ref prefix, ref slice, ref suffix }\n+        | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let array_len = match pat.ty.kind {\n+                ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n+                ty::Slice(_) => None,\n+                _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n+            };\n             let prefix = prefix.len() as u64;\n             let suffix = suffix.len() as u64;\n-            if slice.is_some() {\n-                Some(VarLenSlice(prefix, suffix))\n-            } else {\n-                Some(FixedLenSlice(prefix + suffix))\n-            }\n+            let kind =\n+                if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n+            Some(Slice(Slice { array_len, kind }))\n         }\n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n@@ -1832,6 +1928,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n ) -> Vec<Constructor<'tcx>> {\n     let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n+    debug!(\"split_grouped_constructors({:#?}, {:#?})\", matrix, ctors);\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n@@ -1919,7 +2016,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         .map(IntRange),\n                 );\n             }\n-            VarLenSlice(self_prefix, self_suffix) => {\n+            Slice(Slice { array_len, kind: VarLen(self_prefix, self_suffix) }) => {\n                 // The exhaustiveness-checking paper does not include any details on\n                 // checking variable-length slice patterns. However, they are matched\n                 // by an infinite collection of fixed-length array patterns.\n@@ -2004,11 +2101,13 @@ fn split_grouped_constructors<'p, 'tcx>(\n                                 _ => {}\n                             }\n                         }\n-                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix }\n+                        | PatKind::Array { ref prefix, slice: None, ref suffix } => {\n                             let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                             max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n                         }\n-                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix }\n+                        | PatKind::Array { ref prefix, slice: Some(_), ref suffix } => {\n                             max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n                             max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n                         }\n@@ -2026,20 +2125,38 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n                 }\n \n-                // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n-                // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n-                // are treated independently as fixed-lengths slices, and lengths above are\n-                // captured by a final VarLenSlice constructor.\n-                split_ctors.extend(\n-                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLenSlice),\n-                );\n-                split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+                match array_len {\n+                    Some(len) => {\n+                        let kind = if max_prefix_len + max_suffix_len < len {\n+                            VarLen(max_prefix_len, max_suffix_len)\n+                        } else {\n+                            FixedLen(len)\n+                        };\n+                        split_ctors.push(Slice(Slice { array_len, kind }));\n+                    }\n+                    None => {\n+                        // `ctor` originally covered the range `(self_prefix +\n+                        // self_suffix..infinity)`. We now split it into two: lengths smaller than\n+                        // `max_prefix_len + max_suffix_len` are treated independently as\n+                        // fixed-lengths slices, and lengths above are captured by a final VarLen\n+                        // constructor.\n+                        split_ctors.extend(\n+                            (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n+                                .map(|len| Slice(Slice { array_len, kind: FixedLen(len) })),\n+                        );\n+                        split_ctors.push(Slice(Slice {\n+                            array_len,\n+                            kind: VarLen(max_prefix_len, max_suffix_len),\n+                        }));\n+                    }\n+                }\n             }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n     }\n \n+    debug!(\"split_grouped_constructors(..)={:#?}\", split_ctors);\n     split_ctors\n }\n \n@@ -2251,7 +2368,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            FixedLenSlice(..) | VarLenSlice(..) => {\n+            Slice(_) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}, {"sha": "c910cded96be44c137f7764c1c670fc32e67f412", "filename": "src/test/ui/pattern/issue-53820-slice-pattern-large-array.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs?ref=2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+// This used to cause a stack overflow in the compiler.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    const LARGE_SIZE: usize = 1024 * 1024;\n+    let [..] = [0u8; LARGE_SIZE];\n+    match [0u8; LARGE_SIZE] {\n+        [..] => {}\n+    }\n+}"}, {"sha": "63ed49094fc50547a48d7d252536bb1b2897724f", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[_, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[..]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ pattern `&[_, _, _, _]` not covered\n+   |           ^^^ pattern `&[..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "eb3dfac950f798d3a3ddc24fbb87beddc1970bce", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "patch": "@@ -5,6 +5,20 @@ fn main() {\n     let s1: &[bool; 1] = &[false; 1];\n     let s2: &[bool; 2] = &[false; 2];\n     let s3: &[bool; 3] = &[false; 3];\n+    let s10: &[bool; 10] = &[false; 10];\n+\n+    match s2 {\n+    //~^ ERROR `&[false, _]` not covered\n+        [true, .., true] => {}\n+    }\n+    match s3 {\n+    //~^ ERROR `&[false, ..]` not covered\n+        [true, .., true] => {}\n+    }\n+    match s10 {\n+    //~^ ERROR `&[false, ..]` not covered\n+        [true, .., true] => {}\n+    }\n \n     match s1 {\n         [true, ..] => {}\n@@ -16,7 +30,7 @@ fn main() {\n         [.., false] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, _, true]` not covered\n+    //~^ ERROR `&[false, .., true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n@@ -27,10 +41,6 @@ fn main() {\n         [.., false] => {}\n     }\n \n-    match s3 {\n-    //~^ ERROR `&[false, _, _]` not covered\n-        [true, .., true] => {}\n-    }\n     match s {\n     //~^ ERROR `&[_, ..]` not covered\n         [] => {}"}, {"sha": "ebadedccfea217991f539bc1a2f7e73ac3b088ff", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6e3764b4e2fecf1b1a8c3a174e93906d555703/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=2d6e3764b4e2fecf1b1a8c3a174e93906d555703", "patch": "@@ -1,91 +1,107 @@\n-error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:13:11\n+error[E0004]: non-exhaustive patterns: `&[false, _]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:10:11\n    |\n LL |     match s2 {\n-   |           ^^ pattern `&[false, true]` not covered\n+   |           ^^ pattern `&[false, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n+error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:14:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, true]` not covered\n+   |           ^^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:23:11\n+error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n    |\n-LL |     match s {\n-   |           ^ pattern `&[false, .., true]` not covered\n+LL |     match s10 {\n+   |           ^^^ pattern `&[false, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:27:11\n+   |\n+LL |     match s2 {\n+   |           ^^ pattern `&[false, true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, _]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:30:11\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:32:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, _]` not covered\n+   |           ^^ pattern `&[false, .., true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:37:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:34:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:44:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:38:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:48:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:43:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:53:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[false, _, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:48:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:58:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, .., false]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:54:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:64:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, .., false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, _, .., true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:61:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:71:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[true, _, .., _]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:68:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:78:11\n    |\n LL |     match s {\n    |           ^ pattern `&[true, _, .., _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}