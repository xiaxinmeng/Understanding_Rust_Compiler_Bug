{"sha": "ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNWIxODNlOGJiYWE3YTJmYTdkMjAwNzc4MDgwMjdlMGNjNWJkNzg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T20:03:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-11T06:59:39Z"}, "message": "update for new return place handling", "tree": {"sha": "63aadd20f4969f85454fd917c85e0d0a30230eb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63aadd20f4969f85454fd917c85e0d0a30230eb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "html_url": "https://github.com/rust-lang/rust/commit/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde707d28b1e3489c5bb34c0f86d650537436790", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde707d28b1e3489c5bb34c0f86d650537436790", "html_url": "https://github.com/rust-lang/rust/commit/cde707d28b1e3489c5bb34c0f86d650537436790"}], "stats": {"total": 27, "additions": 14, "deletions": 13}, "files": [{"sha": "9b6a9c67b16af5faf73b16090494d295596d1f08", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "patch": "@@ -252,12 +252,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n                 let mir = self.load_mir(f_instance.def)?;\n-                let closure_dest = Place::null(&self);\n                 self.push_stack_frame(\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    closure_dest,\n+                    None,\n                     StackPopCleanup::Goto(Some(ret)), // directly return to caller\n                 )?;\n                 let mut args = self.frame().mir.args_iter();"}, {"sha": "04405f383d1220aee09778e00fe5efb836f56424", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "patch": "@@ -67,7 +67,6 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n                 .to_owned(),\n         ));\n     }\n-    let ptr_size = ecx.memory.pointer_size();\n \n     if let Some(start_id) = start_wrapper {\n         let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n@@ -89,16 +88,15 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         }\n \n         // Return value (in static memory so that it does not count as leak)\n-        let size = ecx.tcx.data_layout.pointer_size;\n-        let align = ecx.tcx.data_layout.pointer_align;\n-        let ret_ptr = ecx.memory_mut().allocate(size, align, MiriMemoryKind::MutStatic.into())?;\n+        let ret = ecx.layout_of(start_mir.return_ty())?;\n+        let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into())?;\n \n         // Push our stack frame\n         ecx.push_stack_frame(\n             start_instance,\n             start_mir.span,\n             start_mir,\n-            Place::from_ptr(ret_ptr, align),\n+            Some(ret_ptr.into()),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -126,11 +124,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n     } else {\n+        let ret_place = MPlaceTy::dangling(ecx.layout_of(tcx.mk_unit())?, &ecx).into();\n         ecx.push_stack_frame(\n             main_instance,\n             main_mir.span,\n             main_mir,\n-            Place::from_scalar_ptr(Scalar::from_int(1, ptr_size).into(), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+            Some(ret_place),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -286,7 +285,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             malloc,\n             malloc_mir.span,\n             malloc_mir,\n-            *dest,\n+            Some(dest),\n             // Don't do anything when we are done.  The statement() function will increment\n             // the old stack frame's stmt counter to the next statement, which means that when\n             // exchange_malloc returns, we go on evaluating exactly where we want to be."}, {"sha": "c04f7a9c350204cc8882eb1a0c1fe3d7d8e31ef5", "filename": "src/tls.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "patch": "@@ -1,9 +1,12 @@\n use std::collections::BTreeMap;\n \n+use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n-use super::{EvalResult, EvalErrorKind, Scalar, Evaluator,\n-            Place, StackPopCleanup, EvalContext};\n+use super::{\n+    EvalResult, EvalErrorKind, StackPopCleanup, EvalContext, Evaluator,\n+    MPlaceTy, Scalar,\n+};\n \n pub type TlsKey = u128;\n \n@@ -139,12 +142,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // TODO: Potentially, this has to support all the other possible instances?\n             // See eval_fn_call in interpret/terminator/mod.rs\n             let mir = self.load_mir(instance.def)?;\n-            let ret = Place::null(&self);\n+            let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, &self).into();\n             self.push_stack_frame(\n                 instance,\n                 mir.span,\n                 mir,\n-                ret,\n+                Some(ret_place),\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n             let arg_local = self.frame().mir.args_iter().next().ok_or_else("}]}