{"sha": "0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhOGNlYWY4YjBiMzQzZmI5NDNmYTE4YmJmYTZhNTJhM2NlOTNlYzY=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-09-06T10:33:00Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-09-06T10:33:00Z"}, "message": "rustfmt clippy_lints/src/write.rs", "tree": {"sha": "67b65576b8bad1208cae38d06e86f7774909cd44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b65576b8bad1208cae38d06e86f7774909cd44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6", "html_url": "https://github.com/rust-lang/rust/commit/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3262f9283fd8753873545e2ebeb40dc49f351e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3262f9283fd8753873545e2ebeb40dc49f351e18", "html_url": "https://github.com/rust-lang/rust/commit/3262f9283fd8753873545e2ebeb40dc49f351e18"}], "stats": {"total": 52, "additions": 24, "deletions": 28}, "files": [{"sha": "06a4f6cb39eaeb513de984e5cf22e78c32e874e2", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=0a8ceaf8b0b343fb943fa18bbfa6a52a3ce93ec6", "patch": "@@ -1,10 +1,10 @@\n+use crate::utils::{snippet, span_lint, span_lint_and_sugg};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n+use std::borrow::Cow;\n use syntax::ast::*;\n+use syntax::parse::{parser, token};\n use syntax::tokenstream::{ThinTokenStream, TokenStream};\n-use syntax::parse::{token, parser};\n-use std::borrow::Cow;\n-use crate::utils::{span_lint, span_lint_and_sugg, snippet};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -196,24 +196,34 @@ impl EarlyLintPass for Pass {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n             if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n-                    span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n-                            \"using `print!()` with a format string that ends in a \\\n-                            single newline, consider using `println!()` instead\");\n+                    span_lint(\n+                        cx,\n+                        PRINT_WITH_NEWLINE,\n+                        mac.span,\n+                        \"using `print!()` with a format string that ends in a \\\n+                         single newline, consider using `println!()` instead\",\n+                    );\n                 }\n             }\n         } else if mac.node.path == \"write\" {\n             if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n-                    span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n-                            \"using `write!()` with a format string that ends in a \\\n-                            single newline, consider using `writeln!()` instead\");\n+                    span_lint(\n+                        cx,\n+                        WRITE_WITH_NEWLINE,\n+                        mac.span,\n+                        \"using `write!()` with a format string that ends in a \\\n+                         single newline, consider using `writeln!()` instead\",\n+                    );\n                 }\n             }\n         } else if mac.node.path == \"writeln\" {\n             let check_tts = check_tts(cx, &mac.node.tts, true);\n             if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n-                    let suggestion = check_tts.1.map_or(Cow::Borrowed(\"v\"), |expr| snippet(cx, expr.span, \"v\"));\n+                    let suggestion = check_tts\n+                        .1\n+                        .map_or(Cow::Borrowed(\"v\"), |expr| snippet(cx, expr.span, \"v\"));\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -231,13 +241,7 @@ impl EarlyLintPass for Pass {\n \n fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n     let tts = TokenStream::from(tts.clone());\n-    let mut parser = parser::Parser::new(\n-        &cx.sess.parse_sess,\n-        tts,\n-        None,\n-        false,\n-        false,\n-    );\n+    let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false);\n     let mut expr: Option<Expr> = None;\n     if is_write {\n         expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n@@ -270,11 +274,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n             args.push(arg);\n         }\n     }\n-    let lint = if is_write {\n-        WRITE_LITERAL\n-    } else {\n-        PRINT_LITERAL\n-    };\n+    let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n     let mut idx = 0;\n     loop {\n         if !parser.eat(&token::Comma) {\n@@ -299,9 +299,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                 let mut seen = false;\n                 for arg in &args {\n                     match arg.position {\n-                        | ArgumentImplicitlyIs(n)\n-                        | ArgumentIs(n)\n-                        => if n == idx {\n+                        ArgumentImplicitlyIs(n) | ArgumentIs(n) => if n == idx {\n                             all_simple &= arg.format == SIMPLE;\n                             seen = true;\n                         },\n@@ -320,9 +318,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                         let mut seen = false;\n                         for arg in &args {\n                             match arg.position {\n-                                | ArgumentImplicitlyIs(_)\n-                                | ArgumentIs(_)\n-                                => {},\n+                                ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n                                 ArgumentNamed(name) => if *p == name {\n                                     seen = true;\n                                     all_simple &= arg.format == SIMPLE;"}]}