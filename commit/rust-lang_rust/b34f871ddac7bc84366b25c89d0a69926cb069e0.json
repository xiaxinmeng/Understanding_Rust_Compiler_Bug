{"sha": "b34f871ddac7bc84366b25c89d0a69926cb069e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNGY4NzFkZGFjN2JjODQzNjZiMjVjODlkMGE2OTkyNmNiMDY5ZTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-06T22:28:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-06T22:28:02Z"}, "message": "librustc: Change i1 to i8 for bools. Attempts to put out burning tree. rs=burningtree", "tree": {"sha": "4cc654141976e54f424e668e0dc31c3b9f0d9ef3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cc654141976e54f424e668e0dc31c3b9f0d9ef3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b34f871ddac7bc84366b25c89d0a69926cb069e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b34f871ddac7bc84366b25c89d0a69926cb069e0", "html_url": "https://github.com/rust-lang/rust/commit/b34f871ddac7bc84366b25c89d0a69926cb069e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b34f871ddac7bc84366b25c89d0a69926cb069e0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "801f3225b24a796402b83f660f80e62ac504befe", "url": "https://api.github.com/repos/rust-lang/rust/commits/801f3225b24a796402b83f660f80e62ac504befe", "html_url": "https://github.com/rust-lang/rust/commit/801f3225b24a796402b83f660f80e62ac504befe"}], "stats": {"total": 120, "additions": 86, "deletions": 34}, "files": [{"sha": "99b5641ac6adc315b8bbddd5c6b3135aa708b88a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -1028,6 +1028,8 @@ pub fn pick_col(m: &[@Match]) -> uint {\n pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things.\n+//\n+// NB: This must produce an i1, not a Rust bool (i8).\n pub fn compare_values(cx: block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n@@ -1053,7 +1055,11 @@ pub fn compare_values(cx: block,\n                                                           scratch_rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         ty::ty_estr(_) => {\n             let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n@@ -1063,7 +1069,11 @@ pub fn compare_values(cx: block,\n                                                         ~[lhs, rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         _ => {\n             cx.tcx().sess.bug(~\"only scalars and strings supported in \\\n@@ -1176,6 +1186,7 @@ pub fn compile_guard(bcx: block,\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n         }\n     });\n+    let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n     for temp_cleanups.each |llval| {"}, {"sha": "b48eb088c504135fe08ec0cf27bb530bb0e0c0ca", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -494,8 +494,13 @@ pub fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                            t: ty::t, op: ast::binop) -> Result {\n+// NB: This produces an i1, not a Rust bool (i8).\n+pub fn compare_scalar_types(cx: block,\n+                            lhs: ValueRef,\n+                            rhs: ValueRef,\n+                            t: ty::t,\n+                            op: ast::binop)\n+                         -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     match ty::get(t).sty {\n@@ -521,8 +526,12 @@ pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                             nt: scalar_type, op: ast::binop) -> ValueRef {\n+pub fn compare_scalar_values(cx: block,\n+                             lhs: ValueRef,\n+                             rhs: ValueRef,\n+                             nt: scalar_type,\n+                             op: ast::binop)\n+                          -> ValueRef {\n     let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n@@ -533,8 +542,8 @@ pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::eq | ast::le | ast::ge => return C_bool(true),\n-          ast::ne | ast::lt | ast::gt => return C_bool(false),\n+          ast::eq | ast::le | ast::ge => return C_i1(true),\n+          ast::ne | ast::lt | ast::gt => return C_i1(false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -1442,7 +1451,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, memcpy, ~[dst_ptr, src_ptr, size, align, volatile]);\n }\n \n@@ -1489,7 +1498,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, ~[llptr, llzeroval, size, align, volatile]);\n }\n "}, {"sha": "4bd5ae969f206dc4dadaf0c86c5d8dbc776ff881", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -438,7 +438,9 @@ pub fn trans_call_inner(\n             let flag = alloca(bcx, T_bool());\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n-        } else { None };\n+        } else {\n+            None\n+        };\n \n         let (llfn, llenv) = unsafe {\n             match callee.data {\n@@ -506,7 +508,8 @@ pub fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = do with_cond(bcx, Load(bcx, ret_flag.get())) |bcx| {\n+            let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n+            bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 do option::iter(&copy bcx.fcx.loop_ret) |lret| {\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);"}, {"sha": "837ca8ca3aadec43aa89f1b19a9ed45c8debfc18", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -759,7 +759,7 @@ pub fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n \n pub fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n \n-pub fn T_bool() -> TypeRef { return T_i1(); }\n+pub fn T_bool() -> TypeRef { return T_i8(); }\n \n pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n@@ -1109,6 +1109,10 @@ pub fn C_bool(b: bool) -> ValueRef {\n     C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n }\n \n+pub fn C_i1(b: bool) -> ValueRef {\n+    return C_integral(T_i1(), if b { 1 } else { 0 }, False);\n+}\n+\n pub fn C_i32(i: i32) -> ValueRef {\n     return C_integral(T_i32(), i as u64, True);\n }\n@@ -1435,6 +1439,11 @@ pub fn struct_dtor() -> [uint * 2] {\n     [0, 1]\n }\n \n+// Casts a Rust bool value to an i1.\n+pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n+    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "a1505dd2f11c3b7b57d09b03e5c78d6e882dab8d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -62,6 +62,8 @@ pub fn trans_if(bcx: block,\n \n     let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n     let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n+\n+    let cond_val = bool_to_i1(bcx, cond_val);\n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n \n     debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n@@ -139,6 +141,7 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans_to_datum(cond_bcx_in, cond).to_result();\n+    let cond_val = bool_to_i1(cond_bcx_out, cond_val);\n     let cond_bcx_out =\n         trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n     CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n@@ -324,6 +327,7 @@ pub fn trans_check_expr(bcx: block,\n             expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n+    let val = bool_to_i1(bcx, val);\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n         trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n     }"}, {"sha": "ff842b5b4bed0c97be1132585506c6928e88f525", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -77,7 +77,7 @@ fn lli64(val: int) -> ValueRef {\n     C_i64(val as i64)\n }\n fn lli1(bval: bool) -> ValueRef {\n-    C_bool(bval)\n+    C_i1(bval)\n }\n fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n     unsafe {"}, {"sha": "61204fe4e07e0416f23d46530b8ad352b019ae74", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -1236,7 +1236,6 @@ fn trans_unary_datum(bcx: block,\n                      un_expr: @ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n-\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1251,7 +1250,21 @@ fn trans_unary_datum(bcx: block,\n     return match op {\n         ast::not => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n-            immediate_rvalue_bcx(bcx, Not(bcx, val), un_ty)\n+\n+            // If this is a boolean type, we must not use the LLVM Not\n+            // instruction, as that is a *bitwise* not and we want *logical*\n+            // not on our 8-bit boolean values.\n+            let llresult = match ty::get(un_ty).sty {\n+                ty::ty_bool => {\n+                    let llcond = ICmp(bcx,\n+                                      lib::llvm::IntEQ,\n+                                      val,\n+                                      C_bool(false));\n+                    Select(bcx, llcond, C_bool(true), C_bool(false))\n+                }\n+                _ => Not(bcx, val)\n+            };\n+            immediate_rvalue_bcx(bcx, llresult, un_ty)\n         }\n         ast::neg => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n@@ -1308,8 +1321,8 @@ fn trans_eager_binop(bcx: block,\n                      binop_ty: ty::t,\n                      op: ast::binop,\n                      lhs_datum: &Datum,\n-                     rhs_datum: &Datum) -> DatumBlock\n-{\n+                     rhs_datum: &Datum)\n+                  -> DatumBlock {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n \n@@ -1388,7 +1401,7 @@ fn trans_eager_binop(bcx: block,\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            cmpr.val\n+            ZExt(bcx, cmpr.val, T_i8())\n         }\n       }\n       _ => {\n@@ -1406,8 +1419,7 @@ fn trans_lazy_binop(bcx: block,\n                     binop_expr: @ast::expr,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n-                    b: @ast::expr) -> DatumBlock\n-{\n+                    b: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let mut bcx = bcx;\n@@ -1425,10 +1437,12 @@ fn trans_lazy_binop(bcx: block,\n     let join = base::sub_block(bcx, ~\"join\");\n     let before_rhs = base::sub_block(bcx, ~\"rhs\");\n \n+    let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs_i1, before_rhs.llbb, join.llbb),\n+      lazy_or => CondBr(past_lhs, lhs_i1, join.llbb, before_rhs.llbb)\n     }\n+\n     let Result {bcx: past_rhs, val: rhs} = {\n         do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n             trans_to_datum(bcx, b).to_result()"}, {"sha": "ae05ceb1ec57059f2738edd0572576d7f44e3c8e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -524,7 +524,8 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n+            Store(bcx,\n+                  C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"visit_tydesc\" => {\n@@ -574,7 +575,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n@@ -584,7 +585,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n@@ -769,49 +770,49 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }"}, {"sha": "7380fa2e562693087759549520cc308d425ee3b0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34f871ddac7bc84366b25c89d0a69926cb069e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=b34f871ddac7bc84366b25c89d0a69926cb069e0", "patch": "@@ -109,6 +109,7 @@ pub impl reflector {\n                                                         ast::m_imm)),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n+        let result = bool_to_i1(bcx, result);\n         let next_bcx = sub_block(bcx, ~\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx"}]}