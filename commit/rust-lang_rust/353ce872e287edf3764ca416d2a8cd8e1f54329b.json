{"sha": "353ce872e287edf3764ca416d2a8cd8e1f54329b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1M2NlODcyZTI4N2VkZjM3NjRjYTQxNmQyYThjZDhlMWY1NDMyOWI=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-13T13:44:35Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-13T15:14:02Z"}, "message": "Generate NumCast impls and tests using macros", "tree": {"sha": "ecf1d474c0c5ed5694f1d6f3e130cbf43344c3ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecf1d474c0c5ed5694f1d6f3e130cbf43344c3ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/353ce872e287edf3764ca416d2a8cd8e1f54329b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/353ce872e287edf3764ca416d2a8cd8e1f54329b", "html_url": "https://github.com/rust-lang/rust/commit/353ce872e287edf3764ca416d2a8cd8e1f54329b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/353ce872e287edf3764ca416d2a8cd8e1f54329b/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffd735b45c821441c7a73fa5beace04b67b7ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffd735b45c821441c7a73fa5beace04b67b7ba1", "html_url": "https://github.com/rust-lang/rust/commit/3ffd735b45c821441c7a73fa5beace04b67b7ba1"}], "stats": {"total": 1036, "additions": 114, "deletions": 922}, "files": [{"sha": "b9e9e7c3073f5dc7598fe15dee376974c7b5b9b8", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -12,7 +12,6 @@\n \n use cmath;\n use libc::{c_float, c_int};\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -287,30 +286,6 @@ impl num::One for f32 {\n     fn one() -> f32 { 1.0 }\n }\n \n-impl NumCast for f32 {\n-    /**\n-     * Cast `n` to an `f32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self          }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n #[cfg(notest)]\n impl ops::Add<f32,f32> for f32 {\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n@@ -592,51 +567,6 @@ pub fn test_num() {\n     assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n-#[test]\n-fn test_numcast() {\n-    assert!((20u     == 20f32.to_uint()));\n-    assert!((20u8    == 20f32.to_u8()));\n-    assert!((20u16   == 20f32.to_u16()));\n-    assert!((20u32   == 20f32.to_u32()));\n-    assert!((20u64   == 20f32.to_u64()));\n-    assert!((20i     == 20f32.to_int()));\n-    assert!((20i8    == 20f32.to_i8()));\n-    assert!((20i16   == 20f32.to_i16()));\n-    assert!((20i32   == 20f32.to_i32()));\n-    assert!((20i64   == 20f32.to_i64()));\n-    assert!((20f     == 20f32.to_float()));\n-    assert!((20f32   == 20f32.to_f32()));\n-    assert!((20f64   == 20f32.to_f64()));\n-\n-    assert!((20f32 == NumCast::from(20u)));\n-    assert!((20f32 == NumCast::from(20u8)));\n-    assert!((20f32 == NumCast::from(20u16)));\n-    assert!((20f32 == NumCast::from(20u32)));\n-    assert!((20f32 == NumCast::from(20u64)));\n-    assert!((20f32 == NumCast::from(20i)));\n-    assert!((20f32 == NumCast::from(20i8)));\n-    assert!((20f32 == NumCast::from(20i16)));\n-    assert!((20f32 == NumCast::from(20i32)));\n-    assert!((20f32 == NumCast::from(20i64)));\n-    assert!((20f32 == NumCast::from(20f)));\n-    assert!((20f32 == NumCast::from(20f32)));\n-    assert!((20f32 == NumCast::from(20f64)));\n-\n-    assert!((20f32 == num::cast(20u)));\n-    assert!((20f32 == num::cast(20u8)));\n-    assert!((20f32 == num::cast(20u16)));\n-    assert!((20f32 == num::cast(20u32)));\n-    assert!((20f32 == num::cast(20u64)));\n-    assert!((20f32 == num::cast(20i)));\n-    assert!((20f32 == num::cast(20i8)));\n-    assert!((20f32 == num::cast(20i16)));\n-    assert!((20f32 == num::cast(20i32)));\n-    assert!((20f32 == num::cast(20i64)));\n-    assert!((20f32 == num::cast(20f)));\n-    assert!((20f32 == num::cast(20f32)));\n-    assert!((20f32 == num::cast(20f64)));\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "5e8961fa718773580b4e51b77974d5e98320572a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -12,7 +12,6 @@\n \n use cmath;\n use libc::{c_double, c_int};\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -299,30 +298,6 @@ impl cmp::Ord for f64 {\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n-impl NumCast for f64 {\n-    /**\n-     * Cast `n` to an `f64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self          }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n impl num::Zero for f64 {\n     #[inline(always)]\n     fn zero() -> f64 { 0.0 }\n@@ -614,51 +589,6 @@ pub fn test_num() {\n     assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20f64.to_uint()));\n-    assert!((20u8  == 20f64.to_u8()));\n-    assert!((20u16 == 20f64.to_u16()));\n-    assert!((20u32 == 20f64.to_u32()));\n-    assert!((20u64 == 20f64.to_u64()));\n-    assert!((20i   == 20f64.to_int()));\n-    assert!((20i8  == 20f64.to_i8()));\n-    assert!((20i16 == 20f64.to_i16()));\n-    assert!((20i32 == 20f64.to_i32()));\n-    assert!((20i64 == 20f64.to_i64()));\n-    assert!((20f   == 20f64.to_float()));\n-    assert!((20f32 == 20f64.to_f32()));\n-    assert!((20f64 == 20f64.to_f64()));\n-\n-    assert!((20f64 == NumCast::from(20u)));\n-    assert!((20f64 == NumCast::from(20u8)));\n-    assert!((20f64 == NumCast::from(20u16)));\n-    assert!((20f64 == NumCast::from(20u32)));\n-    assert!((20f64 == NumCast::from(20u64)));\n-    assert!((20f64 == NumCast::from(20i)));\n-    assert!((20f64 == NumCast::from(20i8)));\n-    assert!((20f64 == NumCast::from(20i16)));\n-    assert!((20f64 == NumCast::from(20i32)));\n-    assert!((20f64 == NumCast::from(20i64)));\n-    assert!((20f64 == NumCast::from(20f)));\n-    assert!((20f64 == NumCast::from(20f32)));\n-    assert!((20f64 == NumCast::from(20f64)));\n-\n-    assert!((20f64 == num::cast(20u)));\n-    assert!((20f64 == num::cast(20u8)));\n-    assert!((20f64 == num::cast(20u16)));\n-    assert!((20f64 == num::cast(20u32)));\n-    assert!((20f64 == num::cast(20u64)));\n-    assert!((20f64 == num::cast(20i)));\n-    assert!((20f64 == num::cast(20i8)));\n-    assert!((20f64 == num::cast(20i16)));\n-    assert!((20f64 == num::cast(20i32)));\n-    assert!((20f64 == num::cast(20i64)));\n-    assert!((20f64 == num::cast(20f)));\n-    assert!((20f64 == num::cast(20f32)));\n-    assert!((20f64 == num::cast(20f64)));\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e8d7b1e532cea5324e6f5dd0ab0237560ab30764", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -21,7 +21,6 @@\n // PORT this must match in width according to architecture\n \n use f64;\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -417,30 +416,6 @@ impl num::One for float {\n     fn one() -> float { 1.0 }\n }\n \n-impl NumCast for float {\n-    /**\n-     * Cast `n` to a `float`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> float { n.to_float() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self          }\n-}\n-\n impl num::Round for float {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> float {\n@@ -700,51 +675,6 @@ pub fn test_num() {\n     assert!((ten.modulo(&two) == num::cast(0)));\n }\n \n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20f.to_uint()));\n-    assert!((20u8  == 20f.to_u8()));\n-    assert!((20u16 == 20f.to_u16()));\n-    assert!((20u32 == 20f.to_u32()));\n-    assert!((20u64 == 20f.to_u64()));\n-    assert!((20i   == 20f.to_int()));\n-    assert!((20i8  == 20f.to_i8()));\n-    assert!((20i16 == 20f.to_i16()));\n-    assert!((20i32 == 20f.to_i32()));\n-    assert!((20i64 == 20f.to_i64()));\n-    assert!((20f   == 20f.to_float()));\n-    assert!((20f32 == 20f.to_f32()));\n-    assert!((20f64 == 20f.to_f64()));\n-\n-    assert!((20f == NumCast::from(20u)));\n-    assert!((20f == NumCast::from(20u8)));\n-    assert!((20f == NumCast::from(20u16)));\n-    assert!((20f == NumCast::from(20u32)));\n-    assert!((20f == NumCast::from(20u64)));\n-    assert!((20f == NumCast::from(20i)));\n-    assert!((20f == NumCast::from(20i8)));\n-    assert!((20f == NumCast::from(20i16)));\n-    assert!((20f == NumCast::from(20i32)));\n-    assert!((20f == NumCast::from(20i64)));\n-    assert!((20f == NumCast::from(20f)));\n-    assert!((20f == NumCast::from(20f32)));\n-    assert!((20f == NumCast::from(20f64)));\n-\n-    assert!((20f == num::cast(20u)));\n-    assert!((20f == num::cast(20u8)));\n-    assert!((20f == num::cast(20u16)));\n-    assert!((20f == num::cast(20u32)));\n-    assert!((20f == num::cast(20u64)));\n-    assert!((20f == num::cast(20i)));\n-    assert!((20f == num::cast(20i8)));\n-    assert!((20f == num::cast(20i16)));\n-    assert!((20f == num::cast(20i32)));\n-    assert!((20f == num::cast(20i64)));\n-    assert!((20f == num::cast(20f)));\n-    assert!((20f == num::cast(20f32)));\n-    assert!((20f == num::cast(20f64)));\n-}\n-\n \n //\n // Local Variables:"}, {"sha": "34dcd508397854bb1abb7088df3b61c19753da48", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i16`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i16;\n     pub static bits: uint = ::u16::bits;\n }\n-\n-impl NumCast for i16 {\n-    /**\n-     * Cast `n` to a `i16`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self          }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i16.to_uint()));\n-    assert!((20u8  == 20i16.to_u8()));\n-    assert!((20u16 == 20i16.to_u16()));\n-    assert!((20u32 == 20i16.to_u32()));\n-    assert!((20u64 == 20i16.to_u64()));\n-    assert!((20i   == 20i16.to_int()));\n-    assert!((20i8  == 20i16.to_i8()));\n-    assert!((20i16 == 20i16.to_i16()));\n-    assert!((20i32 == 20i16.to_i32()));\n-    assert!((20i64 == 20i16.to_i64()));\n-    assert!((20f   == 20i16.to_float()));\n-    assert!((20f32 == 20i16.to_f32()));\n-    assert!((20f64 == 20i16.to_f64()));\n-\n-    assert!((20i16 == NumCast::from(20u)));\n-    assert!((20i16 == NumCast::from(20u8)));\n-    assert!((20i16 == NumCast::from(20u16)));\n-    assert!((20i16 == NumCast::from(20u32)));\n-    assert!((20i16 == NumCast::from(20u64)));\n-    assert!((20i16 == NumCast::from(20i)));\n-    assert!((20i16 == NumCast::from(20i8)));\n-    assert!((20i16 == NumCast::from(20i16)));\n-    assert!((20i16 == NumCast::from(20i32)));\n-    assert!((20i16 == NumCast::from(20i64)));\n-    assert!((20i16 == NumCast::from(20f)));\n-    assert!((20i16 == NumCast::from(20f32)));\n-    assert!((20i16 == NumCast::from(20f64)));\n-\n-    assert!((20i16 == num::cast(20u)));\n-    assert!((20i16 == num::cast(20u8)));\n-    assert!((20i16 == num::cast(20u16)));\n-    assert!((20i16 == num::cast(20u32)));\n-    assert!((20i16 == num::cast(20u64)));\n-    assert!((20i16 == num::cast(20i)));\n-    assert!((20i16 == num::cast(20i8)));\n-    assert!((20i16 == num::cast(20i16)));\n-    assert!((20i16 == num::cast(20i32)));\n-    assert!((20i16 == num::cast(20i64)));\n-    assert!((20i16 == num::cast(20f)));\n-    assert!((20i16 == num::cast(20f32)));\n-    assert!((20i16 == num::cast(20f64)));\n-}"}, {"sha": "91eea0e8d4709fe2cff71b9835aa4efcc64517c6", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i32`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i32;\n     pub static bits: uint = ::u32::bits;\n }\n-\n-impl NumCast for i32 {\n-    /**\n-     * Cast `n` to a `i32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self          }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i32.to_uint()));\n-    assert!((20u8  == 20i32.to_u8()));\n-    assert!((20u16 == 20i32.to_u16()));\n-    assert!((20u32 == 20i32.to_u32()));\n-    assert!((20u64 == 20i32.to_u64()));\n-    assert!((20i   == 20i32.to_int()));\n-    assert!((20i8  == 20i32.to_i8()));\n-    assert!((20i16 == 20i32.to_i16()));\n-    assert!((20i32 == 20i32.to_i32()));\n-    assert!((20i64 == 20i32.to_i64()));\n-    assert!((20f   == 20i32.to_float()));\n-    assert!((20f32 == 20i32.to_f32()));\n-    assert!((20f64 == 20i32.to_f64()));\n-\n-    assert!((20i32 == NumCast::from(20u)));\n-    assert!((20i32 == NumCast::from(20u8)));\n-    assert!((20i32 == NumCast::from(20u16)));\n-    assert!((20i32 == NumCast::from(20u32)));\n-    assert!((20i32 == NumCast::from(20u64)));\n-    assert!((20i32 == NumCast::from(20i)));\n-    assert!((20i32 == NumCast::from(20i8)));\n-    assert!((20i32 == NumCast::from(20i16)));\n-    assert!((20i32 == NumCast::from(20i32)));\n-    assert!((20i32 == NumCast::from(20i64)));\n-    assert!((20i32 == NumCast::from(20f)));\n-    assert!((20i32 == NumCast::from(20f32)));\n-    assert!((20i32 == NumCast::from(20f64)));\n-\n-    assert!((20i32 == num::cast(20u)));\n-    assert!((20i32 == num::cast(20u8)));\n-    assert!((20i32 == num::cast(20u16)));\n-    assert!((20i32 == num::cast(20u32)));\n-    assert!((20i32 == num::cast(20u64)));\n-    assert!((20i32 == num::cast(20i)));\n-    assert!((20i32 == num::cast(20i8)));\n-    assert!((20i32 == num::cast(20i16)));\n-    assert!((20i32 == num::cast(20i32)));\n-    assert!((20i32 == num::cast(20i64)));\n-    assert!((20i32 == num::cast(20f)));\n-    assert!((20i32 == num::cast(20f32)));\n-    assert!((20i32 == num::cast(20f64)));\n-}"}, {"sha": "3834a1e2a0387e584c19817c67004cbf2a589531", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i64`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i64;\n     pub static bits: uint = ::u64::bits;\n }\n-\n-impl NumCast for i64 {\n-    /**\n-     * Cast `n` to a `i64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self          }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i64.to_uint()));\n-    assert!((20u8  == 20i64.to_u8()));\n-    assert!((20u16 == 20i64.to_u16()));\n-    assert!((20u32 == 20i64.to_u32()));\n-    assert!((20u64 == 20i64.to_u64()));\n-    assert!((20i   == 20i64.to_int()));\n-    assert!((20i8  == 20i64.to_i8()));\n-    assert!((20i16 == 20i64.to_i16()));\n-    assert!((20i32 == 20i64.to_i32()));\n-    assert!((20i64 == 20i64.to_i64()));\n-    assert!((20f   == 20i64.to_float()));\n-    assert!((20f32 == 20i64.to_f32()));\n-    assert!((20f64 == 20i64.to_f64()));\n-\n-    assert!((20i64 == NumCast::from(20u)));\n-    assert!((20i64 == NumCast::from(20u8)));\n-    assert!((20i64 == NumCast::from(20u16)));\n-    assert!((20i64 == NumCast::from(20u32)));\n-    assert!((20i64 == NumCast::from(20u64)));\n-    assert!((20i64 == NumCast::from(20i)));\n-    assert!((20i64 == NumCast::from(20i8)));\n-    assert!((20i64 == NumCast::from(20i16)));\n-    assert!((20i64 == NumCast::from(20i32)));\n-    assert!((20i64 == NumCast::from(20i64)));\n-    assert!((20i64 == NumCast::from(20f)));\n-    assert!((20i64 == NumCast::from(20f32)));\n-    assert!((20i64 == NumCast::from(20f64)));\n-\n-    assert!((20i64 == num::cast(20u)));\n-    assert!((20i64 == num::cast(20u8)));\n-    assert!((20i64 == num::cast(20u16)));\n-    assert!((20i64 == num::cast(20u32)));\n-    assert!((20i64 == num::cast(20u64)));\n-    assert!((20i64 == num::cast(20i)));\n-    assert!((20i64 == num::cast(20i8)));\n-    assert!((20i64 == num::cast(20i16)));\n-    assert!((20i64 == num::cast(20i32)));\n-    assert!((20i64 == num::cast(20i64)));\n-    assert!((20i64 == num::cast(20f)));\n-    assert!((20i64 == num::cast(20f32)));\n-    assert!((20i64 == num::cast(20f64)));\n-}"}, {"sha": "9486ed748d7d00334e97a7c1decf5e2dfc7ff42c", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i8`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i8;\n     pub static bits: uint = ::u8::bits;\n }\n-\n-impl NumCast for i8 {\n-    /**\n-     * Cast `n` to a `i8`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self          }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i8.to_uint()));\n-    assert!((20u8  == 20i8.to_u8()));\n-    assert!((20u16 == 20i8.to_u16()));\n-    assert!((20u32 == 20i8.to_u32()));\n-    assert!((20u64 == 20i8.to_u64()));\n-    assert!((20i   == 20i8.to_int()));\n-    assert!((20i8  == 20i8.to_i8()));\n-    assert!((20i16 == 20i8.to_i16()));\n-    assert!((20i32 == 20i8.to_i32()));\n-    assert!((20i64 == 20i8.to_i64()));\n-    assert!((20f   == 20i8.to_float()));\n-    assert!((20f32 == 20i8.to_f32()));\n-    assert!((20f64 == 20i8.to_f64()));\n-\n-    assert!((20i8 == NumCast::from(20u)));\n-    assert!((20i8 == NumCast::from(20u8)));\n-    assert!((20i8 == NumCast::from(20u16)));\n-    assert!((20i8 == NumCast::from(20u32)));\n-    assert!((20i8 == NumCast::from(20u64)));\n-    assert!((20i8 == NumCast::from(20i)));\n-    assert!((20i8 == NumCast::from(20i8)));\n-    assert!((20i8 == NumCast::from(20i16)));\n-    assert!((20i8 == NumCast::from(20i32)));\n-    assert!((20i8 == NumCast::from(20i64)));\n-    assert!((20i8 == NumCast::from(20f)));\n-    assert!((20i8 == NumCast::from(20f32)));\n-    assert!((20i8 == NumCast::from(20f64)));\n-\n-    assert!((20i8 == num::cast(20u)));\n-    assert!((20i8 == num::cast(20u8)));\n-    assert!((20i8 == num::cast(20u16)));\n-    assert!((20i8 == num::cast(20u32)));\n-    assert!((20i8 == num::cast(20u64)));\n-    assert!((20i8 == num::cast(20i)));\n-    assert!((20i8 == num::cast(20i8)));\n-    assert!((20i8 == num::cast(20i16)));\n-    assert!((20i8 == num::cast(20i32)));\n-    assert!((20i8 == num::cast(20i64)));\n-    assert!((20i8 == num::cast(20f)));\n-    assert!((20i8 == num::cast(20f32)));\n-    assert!((20i8 == num::cast(20f64)));\n-}"}, {"sha": "6649b364015d3a5dbec43b9f27f8e335327ffcad", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for `int`\n \n-use num::NumCast;\n-\n pub use self::inst::pow;\n \n mod inst {\n@@ -57,72 +55,3 @@ mod inst {\n         assert!((::int::min_value + ::int::max_value + 1 == 0));\n     }\n }\n-\n-impl NumCast for int {\n-    /**\n-     * Cast `n` to a `int`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> int { n.to_int() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self          }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i.to_uint()));\n-    assert!((20u8  == 20i.to_u8()));\n-    assert!((20u16 == 20i.to_u16()));\n-    assert!((20u32 == 20i.to_u32()));\n-    assert!((20u64 == 20i.to_u64()));\n-    assert!((20i   == 20i.to_int()));\n-    assert!((20i8  == 20i.to_i8()));\n-    assert!((20i16 == 20i.to_i16()));\n-    assert!((20i32 == 20i.to_i32()));\n-    assert!((20i64 == 20i.to_i64()));\n-    assert!((20f   == 20i.to_float()));\n-    assert!((20f32 == 20i.to_f32()));\n-    assert!((20f64 == 20i.to_f64()));\n-\n-    assert!((20i == NumCast::from(20u)));\n-    assert!((20i == NumCast::from(20u8)));\n-    assert!((20i == NumCast::from(20u16)));\n-    assert!((20i == NumCast::from(20u32)));\n-    assert!((20i == NumCast::from(20u64)));\n-    assert!((20i == NumCast::from(20i)));\n-    assert!((20i == NumCast::from(20i8)));\n-    assert!((20i == NumCast::from(20i16)));\n-    assert!((20i == NumCast::from(20i32)));\n-    assert!((20i == NumCast::from(20i64)));\n-    assert!((20i == NumCast::from(20f)));\n-    assert!((20i == NumCast::from(20f32)));\n-    assert!((20i == NumCast::from(20f64)));\n-\n-    assert!((20i == num::cast(20u)));\n-    assert!((20i == num::cast(20u8)));\n-    assert!((20i == num::cast(20u16)));\n-    assert!((20i == num::cast(20u32)));\n-    assert!((20i == num::cast(20u64)));\n-    assert!((20i == num::cast(20i)));\n-    assert!((20i == num::cast(20i8)));\n-    assert!((20i == num::cast(20i16)));\n-    assert!((20i == num::cast(20i32)));\n-    assert!((20i == num::cast(20i64)));\n-    assert!((20i == num::cast(20f)));\n-    assert!((20i == num::cast(20f32)));\n-    assert!((20i == num::cast(20f64)));\n-}"}, {"sha": "50894b85a49d5302a0b84c6fd16400890df5ffa2", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n //! An interface for numeric types\n-use cmp::Ord;\n-use ops::{Div, Mul, Neg};\n+use cmp::{Eq, Ord};\n+use ops::{Neg, Add, Sub, Mul, Div, Modulo};\n use option::Option;\n use kinds::Copy;\n \n@@ -86,6 +86,57 @@ pub trait NumCast {\n     fn to_float(&self) -> float;\n }\n \n+macro_rules! impl_num_cast(\n+    ($T:ty, $conv:ident) => (\n+        // FIXME #4375: This enclosing module is necessary because\n+        // of a bug with macros expanding into multiple items \n+        pub mod $conv {\n+            use num::NumCast;\n+            \n+            #[cfg(notest)]\n+            impl NumCast for $T {\n+                #[doc = \"Cast `n` to a `$T`\"]\n+                #[inline(always)]\n+                fn from<N:NumCast>(n: N) -> $T {\n+                    // `$conv` could be generated using `concat_idents!`, but that\n+                    // macro seems to be broken at the moment\n+                    n.$conv()\n+                }\n+\n+                #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+                #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+                #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+                #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+                #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+                #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+                #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+                #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+                #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+                #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n+\n+                #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+                #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+                #[inline(always)] fn to_float(&self) -> float { *self as float }\n+            }\n+        }\n+    )\n+)\n+\n+impl_num_cast!(u8,    to_u8)\n+impl_num_cast!(u16,   to_u16)\n+impl_num_cast!(u32,   to_u32)\n+impl_num_cast!(u64,   to_u64)\n+impl_num_cast!(uint,  to_uint)\n+impl_num_cast!(i8,    to_i8)\n+impl_num_cast!(i16,   to_i16)\n+impl_num_cast!(i32,   to_i32)\n+impl_num_cast!(i64,   to_i64)\n+impl_num_cast!(int,   to_int)\n+impl_num_cast!(f32,   to_f32)\n+impl_num_cast!(f64,   to_f64)\n+impl_num_cast!(float, to_float)\n+\n pub trait ToStrRadix {\n     pub fn to_str_radix(&self, radix: uint) -> ~str;\n }\n@@ -129,3 +180,64 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     total\n }\n \n+macro_rules! test_cast_20(\n+    ($_20:expr) => ({\n+        let _20 = $_20;\n+        \n+        assert!(20u   == _20.to_uint());\n+        assert!(20u8  == _20.to_u8());\n+        assert!(20u16 == _20.to_u16());\n+        assert!(20u32 == _20.to_u32());\n+        assert!(20u64 == _20.to_u64());\n+        assert!(20i   == _20.to_int());\n+        assert!(20i8  == _20.to_i8());\n+        assert!(20i16 == _20.to_i16());\n+        assert!(20i32 == _20.to_i32());\n+        assert!(20i64 == _20.to_i64());\n+        assert!(20f   == _20.to_float());\n+        assert!(20f32 == _20.to_f32());\n+        assert!(20f64 == _20.to_f64());\n+\n+        assert!(_20 == NumCast::from(20u));\n+        assert!(_20 == NumCast::from(20u8));\n+        assert!(_20 == NumCast::from(20u16));\n+        assert!(_20 == NumCast::from(20u32));\n+        assert!(_20 == NumCast::from(20u64));\n+        assert!(_20 == NumCast::from(20i));\n+        assert!(_20 == NumCast::from(20i8));\n+        assert!(_20 == NumCast::from(20i16));\n+        assert!(_20 == NumCast::from(20i32));\n+        assert!(_20 == NumCast::from(20i64));\n+        assert!(_20 == NumCast::from(20f));\n+        assert!(_20 == NumCast::from(20f32));\n+        assert!(_20 == NumCast::from(20f64));\n+\n+        assert!(_20 == cast(20u));\n+        assert!(_20 == cast(20u8));\n+        assert!(_20 == cast(20u16));\n+        assert!(_20 == cast(20u32));\n+        assert!(_20 == cast(20u64));\n+        assert!(_20 == cast(20i));\n+        assert!(_20 == cast(20i8));\n+        assert!(_20 == cast(20i16));\n+        assert!(_20 == cast(20i32));\n+        assert!(_20 == cast(20i64));\n+        assert!(_20 == cast(20f));\n+        assert!(_20 == cast(20f32));\n+        assert!(_20 == cast(20f64));\n+    })\n+)\n+\n+#[test] fn test_u8_cast()    { test_cast_20!(20u8)  }\n+#[test] fn test_u16_cast()   { test_cast_20!(20u16) }\n+#[test] fn test_u32_cast()   { test_cast_20!(20u32) }\n+#[test] fn test_u64_cast()   { test_cast_20!(20u64) }\n+#[test] fn test_uint_cast()  { test_cast_20!(20u)   }\n+#[test] fn test_i8_cast()    { test_cast_20!(20i8)  }\n+#[test] fn test_i16_cast()   { test_cast_20!(20i16) }\n+#[test] fn test_i32_cast()   { test_cast_20!(20i32) }\n+#[test] fn test_i64_cast()   { test_cast_20!(20i64) }\n+#[test] fn test_int_cast()   { test_cast_20!(20i)   }\n+#[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n+#[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n+#[test] fn test_float_cast() { test_cast_20!(20f)   }\n\\ No newline at end of file"}, {"sha": "63144162fc50aa842647fbdb55079336792d3e92", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u16`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u16;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i16;\n     pub static bits: uint = 16;\n }\n-\n-impl NumCast for u16 {\n-    /**\n-     * Cast `n` to a `u16`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self          }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u16.to_uint()));\n-    assert!((20u8  == 20u16.to_u8()));\n-    assert!((20u16 == 20u16.to_u16()));\n-    assert!((20u32 == 20u16.to_u32()));\n-    assert!((20u64 == 20u16.to_u64()));\n-    assert!((20i   == 20u16.to_int()));\n-    assert!((20i8  == 20u16.to_i8()));\n-    assert!((20i16 == 20u16.to_i16()));\n-    assert!((20i32 == 20u16.to_i32()));\n-    assert!((20i64 == 20u16.to_i64()));\n-    assert!((20f   == 20u16.to_float()));\n-    assert!((20f32 == 20u16.to_f32()));\n-    assert!((20f64 == 20u16.to_f64()));\n-\n-    assert!((20u16 == NumCast::from(20u)));\n-    assert!((20u16 == NumCast::from(20u8)));\n-    assert!((20u16 == NumCast::from(20u16)));\n-    assert!((20u16 == NumCast::from(20u32)));\n-    assert!((20u16 == NumCast::from(20u64)));\n-    assert!((20u16 == NumCast::from(20i)));\n-    assert!((20u16 == NumCast::from(20i8)));\n-    assert!((20u16 == NumCast::from(20i16)));\n-    assert!((20u16 == NumCast::from(20i32)));\n-    assert!((20u16 == NumCast::from(20i64)));\n-    assert!((20u16 == NumCast::from(20f)));\n-    assert!((20u16 == NumCast::from(20f32)));\n-    assert!((20u16 == NumCast::from(20f64)));\n-\n-    assert!((20u16 == num::cast(20u)));\n-    assert!((20u16 == num::cast(20u8)));\n-    assert!((20u16 == num::cast(20u16)));\n-    assert!((20u16 == num::cast(20u32)));\n-    assert!((20u16 == num::cast(20u64)));\n-    assert!((20u16 == num::cast(20i)));\n-    assert!((20u16 == num::cast(20i8)));\n-    assert!((20u16 == num::cast(20i16)));\n-    assert!((20u16 == num::cast(20i32)));\n-    assert!((20u16 == num::cast(20i64)));\n-    assert!((20u16 == num::cast(20f)));\n-    assert!((20u16 == num::cast(20f32)));\n-    assert!((20u16 == num::cast(20f64)));\n-}"}, {"sha": "4d9958fe38aaf4e273d08838664642754f9ddeb5", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u32`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u32;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i32;\n     pub static bits: uint = 32;\n }\n-\n-impl NumCast for u32 {\n-    /**\n-     * Cast `n` to a `u32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self          }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u64.to_uint()));\n-    assert!((20u8  == 20u64.to_u8()));\n-    assert!((20u16 == 20u64.to_u16()));\n-    assert!((20u32 == 20u64.to_u32()));\n-    assert!((20u64 == 20u64.to_u64()));\n-    assert!((20i   == 20u64.to_int()));\n-    assert!((20i8  == 20u64.to_i8()));\n-    assert!((20i16 == 20u64.to_i16()));\n-    assert!((20i32 == 20u64.to_i32()));\n-    assert!((20i64 == 20u64.to_i64()));\n-    assert!((20f   == 20u64.to_float()));\n-    assert!((20f32 == 20u64.to_f32()));\n-    assert!((20f64 == 20u64.to_f64()));\n-\n-    assert!((20u64 == NumCast::from(20u)));\n-    assert!((20u64 == NumCast::from(20u8)));\n-    assert!((20u64 == NumCast::from(20u16)));\n-    assert!((20u64 == NumCast::from(20u32)));\n-    assert!((20u64 == NumCast::from(20u64)));\n-    assert!((20u64 == NumCast::from(20i)));\n-    assert!((20u64 == NumCast::from(20i8)));\n-    assert!((20u64 == NumCast::from(20i16)));\n-    assert!((20u64 == NumCast::from(20i32)));\n-    assert!((20u64 == NumCast::from(20i64)));\n-    assert!((20u64 == NumCast::from(20f)));\n-    assert!((20u64 == NumCast::from(20f32)));\n-    assert!((20u64 == NumCast::from(20f64)));\n-\n-    assert!((20u64 == num::cast(20u)));\n-    assert!((20u64 == num::cast(20u8)));\n-    assert!((20u64 == num::cast(20u16)));\n-    assert!((20u64 == num::cast(20u32)));\n-    assert!((20u64 == num::cast(20u64)));\n-    assert!((20u64 == num::cast(20i)));\n-    assert!((20u64 == num::cast(20i8)));\n-    assert!((20u64 == num::cast(20i16)));\n-    assert!((20u64 == num::cast(20i32)));\n-    assert!((20u64 == num::cast(20i64)));\n-    assert!((20u64 == num::cast(20f)));\n-    assert!((20u64 == num::cast(20f32)));\n-    assert!((20u64 == num::cast(20f64)));\n-}"}, {"sha": "af198dd69424b79f879a79aae7c8d6f64048cfb1", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u64`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u64;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i64;\n     pub static bits: uint = 64;\n }\n-\n-impl NumCast for u64 {\n-    /**\n-     * Cast `n` to a `u64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self          }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u64.to_uint()));\n-    assert!((20u8  == 20u64.to_u8()));\n-    assert!((20u16 == 20u64.to_u16()));\n-    assert!((20u32 == 20u64.to_u32()));\n-    assert!((20u64 == 20u64.to_u64()));\n-    assert!((20i   == 20u64.to_int()));\n-    assert!((20i8  == 20u64.to_i8()));\n-    assert!((20i16 == 20u64.to_i16()));\n-    assert!((20i32 == 20u64.to_i32()));\n-    assert!((20i64 == 20u64.to_i64()));\n-    assert!((20f   == 20u64.to_float()));\n-    assert!((20f32 == 20u64.to_f32()));\n-    assert!((20f64 == 20u64.to_f64()));\n-\n-    assert!((20u64 == NumCast::from(20u)));\n-    assert!((20u64 == NumCast::from(20u8)));\n-    assert!((20u64 == NumCast::from(20u16)));\n-    assert!((20u64 == NumCast::from(20u32)));\n-    assert!((20u64 == NumCast::from(20u64)));\n-    assert!((20u64 == NumCast::from(20i)));\n-    assert!((20u64 == NumCast::from(20i8)));\n-    assert!((20u64 == NumCast::from(20i16)));\n-    assert!((20u64 == NumCast::from(20i32)));\n-    assert!((20u64 == NumCast::from(20i64)));\n-    assert!((20u64 == NumCast::from(20f)));\n-    assert!((20u64 == NumCast::from(20f32)));\n-    assert!((20u64 == NumCast::from(20f64)));\n-\n-    assert!((20u64 == num::cast(20u)));\n-    assert!((20u64 == num::cast(20u8)));\n-    assert!((20u64 == num::cast(20u16)));\n-    assert!((20u64 == num::cast(20u32)));\n-    assert!((20u64 == num::cast(20u64)));\n-    assert!((20u64 == num::cast(20i)));\n-    assert!((20u64 == num::cast(20i8)));\n-    assert!((20u64 == num::cast(20i16)));\n-    assert!((20u64 == num::cast(20i32)));\n-    assert!((20u64 == num::cast(20i64)));\n-    assert!((20u64 == num::cast(20f)));\n-    assert!((20u64 == num::cast(20f32)));\n-    assert!((20u64 == num::cast(20f64)));\n-}"}, {"sha": "ce23bebacdad136976305038d0ea41db19f5fe9b", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -12,8 +12,6 @@\n \n pub use self::inst::is_ascii;\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u8;\n     #[allow(non_camel_case_types)]\n@@ -25,72 +23,3 @@ mod inst {\n \n     pub fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n-\n-impl NumCast for u8 {\n-    /**\n-     * Cast `n` to a `u8`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self          }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u     == 20u8.to_uint()));\n-    assert!((20u8    == 20u8.to_u8()));\n-    assert!((20u16   == 20u8.to_u16()));\n-    assert!((20u32   == 20u8.to_u32()));\n-    assert!((20u64   == 20u8.to_u64()));\n-    assert!((20i     == 20u8.to_int()));\n-    assert!((20i8    == 20u8.to_i8()));\n-    assert!((20i16   == 20u8.to_i16()));\n-    assert!((20i32   == 20u8.to_i32()));\n-    assert!((20i64   == 20u8.to_i64()));\n-    assert!((20f     == 20u8.to_float()));\n-    assert!((20f32   == 20u8.to_f32()));\n-    assert!((20f64   == 20u8.to_f64()));\n-\n-    assert!((20u8 == NumCast::from(20u)));\n-    assert!((20u8 == NumCast::from(20u8)));\n-    assert!((20u8 == NumCast::from(20u16)));\n-    assert!((20u8 == NumCast::from(20u32)));\n-    assert!((20u8 == NumCast::from(20u64)));\n-    assert!((20u8 == NumCast::from(20i)));\n-    assert!((20u8 == NumCast::from(20i8)));\n-    assert!((20u8 == NumCast::from(20i16)));\n-    assert!((20u8 == NumCast::from(20i32)));\n-    assert!((20u8 == NumCast::from(20i64)));\n-    assert!((20u8 == NumCast::from(20f)));\n-    assert!((20u8 == NumCast::from(20f32)));\n-    assert!((20u8 == NumCast::from(20f64)));\n-\n-    assert!((20u8 == num::cast(20u)));\n-    assert!((20u8 == num::cast(20u8)));\n-    assert!((20u8 == num::cast(20u16)));\n-    assert!((20u8 == num::cast(20u32)));\n-    assert!((20u8 == num::cast(20u64)));\n-    assert!((20u8 == num::cast(20i)));\n-    assert!((20u8 == num::cast(20i8)));\n-    assert!((20u8 == num::cast(20i16)));\n-    assert!((20u8 == num::cast(20i32)));\n-    assert!((20u8 == num::cast(20i64)));\n-    assert!((20u8 == num::cast(20f)));\n-    assert!((20u8 == num::cast(20f32)));\n-    assert!((20u8 == num::cast(20f64)));\n-}"}, {"sha": "efcf68aba3160f228c2a208f3acc3d0512b406d7", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353ce872e287edf3764ca416d2a8cd8e1f54329b/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=353ce872e287edf3764ca416d2a8cd8e1f54329b", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for `uint`\n \n-use num::NumCast;\n-\n pub use self::inst::{\n     div_ceil, div_round, div_floor, iterate,\n     next_power_of_two\n@@ -209,72 +207,3 @@ pub mod inst {\n         assert!((accum == 10));\n     }\n }\n-\n-impl NumCast for uint {\n-    /**\n-     * Cast `n` to a `uint`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self          }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u.to_uint()));\n-    assert!((20u8  == 20u.to_u8()));\n-    assert!((20u16 == 20u.to_u16()));\n-    assert!((20u32 == 20u.to_u32()));\n-    assert!((20u64 == 20u.to_u64()));\n-    assert!((20i   == 20u.to_int()));\n-    assert!((20i8  == 20u.to_i8()));\n-    assert!((20i16 == 20u.to_i16()));\n-    assert!((20i32 == 20u.to_i32()));\n-    assert!((20i64 == 20u.to_i64()));\n-    assert!((20f   == 20u.to_float()));\n-    assert!((20f32 == 20u.to_f32()));\n-    assert!((20f64 == 20u.to_f64()));\n-\n-    assert!((20u == NumCast::from(20u)));\n-    assert!((20u == NumCast::from(20u8)));\n-    assert!((20u == NumCast::from(20u16)));\n-    assert!((20u == NumCast::from(20u32)));\n-    assert!((20u == NumCast::from(20u64)));\n-    assert!((20u == NumCast::from(20i)));\n-    assert!((20u == NumCast::from(20i8)));\n-    assert!((20u == NumCast::from(20i16)));\n-    assert!((20u == NumCast::from(20i32)));\n-    assert!((20u == NumCast::from(20i64)));\n-    assert!((20u == NumCast::from(20f)));\n-    assert!((20u == NumCast::from(20f32)));\n-    assert!((20u == NumCast::from(20f64)));\n-\n-    assert!((20u == num::cast(20u)));\n-    assert!((20u == num::cast(20u8)));\n-    assert!((20u == num::cast(20u16)));\n-    assert!((20u == num::cast(20u32)));\n-    assert!((20u == num::cast(20u64)));\n-    assert!((20u == num::cast(20i)));\n-    assert!((20u == num::cast(20i8)));\n-    assert!((20u == num::cast(20i16)));\n-    assert!((20u == num::cast(20i32)));\n-    assert!((20u == num::cast(20i64)));\n-    assert!((20u == num::cast(20f)));\n-    assert!((20u == num::cast(20f32)));\n-    assert!((20u == num::cast(20f64)));\n-}"}]}