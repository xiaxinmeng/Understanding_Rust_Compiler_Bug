{"sha": "a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExODk0ZTRhZmUxYTM5ZjcxOGNjMjcyMzJhNWEyZjBkMDJiNTAxZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T04:03:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T04:03:28Z"}, "message": "Auto merge of #76558 - tmandry:rollup-bskim2r, r=tmandry\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #74787 (Move `rustllvm` into `compiler/rustc_llvm`)\n - #76458 (Add drain_filter method to HashMap and HashSet)\n - #76472 (rustbuild: don't set PYTHON_EXECUTABLE and WITH_POLLY cmake vars since they are no longer supported by llvm)\n - #76497 (Use intra-doc links in `core::ptr`)\n - #76500 (Add -Zgraphviz_dark_mode and monospace font fix)\n - #76543 (Document btree's unwrap_unchecked)\n - #76556 (Revert #76285)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "0d698d42b60ac432aed6ce83a2e9a66e176060be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d698d42b60ac432aed6ce83a2e9a66e176060be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "html_url": "https://github.com/rust-lang/rust/commit/a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97eb606e4b2becd17d46a67d87169f52b210e67c", "url": "https://api.github.com/repos/rust-lang/rust/commits/97eb606e4b2becd17d46a67d87169f52b210e67c", "html_url": "https://github.com/rust-lang/rust/commit/97eb606e4b2becd17d46a67d87169f52b210e67c"}, {"sha": "193503eb62aba269b505b99dc1c143645a115e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/193503eb62aba269b505b99dc1c143645a115e31", "html_url": "https://github.com/rust-lang/rust/commit/193503eb62aba269b505b99dc1c143645a115e31"}], "stats": {"total": 829, "additions": 617, "deletions": 212}, "files": [{"sha": "1c50d9b054ddc8b1edd734fe1d404af8da742974", "filename": ".gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -33,7 +33,6 @@ __pycache__/\n /mingw-build/\n # Created by default with `src/ci/docker/run.sh`:\n /obj/\n-/rustllvm/\n /unicode-downloads\n /target\n # Generated by compiletest for incremental:"}, {"sha": "b687e714d4fa29609ae2d878530c9beb5ae55b80", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1259,11 +1259,10 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e91b62f79061a0bc2e046024cb7ba44b08419ed238ecbd9adbd787434b9e8c25\"\n+checksum = \"00d63df3d41950fb462ed38308eea019113ad1508da725bbedcd0fa5a85ef5f7\"\n dependencies = [\n- \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1401,9 +1400,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.5.1\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n+checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\","}, {"sha": "151acddae840e567c171362311ce6813f6603c5b", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -403,8 +403,8 @@ impl Cursor {\n         self.index = index;\n     }\n \n-    pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n-        self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n+    pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n+        self.stream.0[self.index..].get(n).map(|(tree, _)| tree.clone())\n     }\n }\n "}, {"sha": "04792b334d553ff0ab70d7456208bebf8fe7bffb", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -25,7 +25,7 @@ rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n rustc_index = { path = \"../rustc_index\" }\n-rustc_llvm = { path = \"../../src/librustc_llvm\" }\n+rustc_llvm = { path = \"../rustc_llvm\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "4942c997682d80b7fbae0a9e0669e01420726403", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -96,7 +96,7 @@ pub enum DLLStorageClass {\n     DllExport = 2, // Function to be accessible from DLL.\n }\n \n-/// Matches LLVMRustAttribute in rustllvm.h\n+/// Matches LLVMRustAttribute in LLVMWrapper.h\n /// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n /// though it is not ABI compatible (since it's a C++ enum)\n #[repr(C)]\n@@ -1705,7 +1705,7 @@ extern \"C\" {\n         PM: &PassManager<'_>,\n     );\n \n-    // Stuff that's in rustllvm/ because it's not upstream yet.\n+    // Stuff that's in llvm-wrapper/ because it's not upstream yet.\n \n     /// Opens an object file.\n     pub fn LLVMCreateObjectFile("}, {"sha": "39c82f97e0a39ce3503f084269ba7fba98285941", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -47,26 +47,15 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl\n-    FromInternal<(\n-        TreeAndJoint,\n-        Option<&'_ tokenstream::TokenTree>,\n-        &'_ ParseSess,\n-        &'_ mut Vec<Self>,\n-    )> for TokenTree<Group, Punct, Ident, Literal>\n+impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n+    for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, is_joint), look_ahead, sess, stack): (\n-            TreeAndJoint,\n-            Option<&tokenstream::TokenTree>,\n-            &ParseSess,\n-            &mut Vec<Self>,\n-        ),\n+        ((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = is_joint == Joint\n-            && matches!(look_ahead, Some(tokenstream::TokenTree::Token(t)) if t.is_op());\n+        let joint = is_joint == Joint;\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n@@ -456,8 +445,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n                 let next = iter.cursor.next_with_joint()?;\n-                let lookahead = iter.cursor.look_ahead(0);\n-                Some(TokenTree::from_internal((next, lookahead, self.sess, &mut iter.stack)))\n+                Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n             })?;\n             // A hack used to pass AST fragments to attribute and derive macros\n             // as a single nonterminal token instead of a token stream."}, {"sha": "29ec3572016d759185989c8c6efb1e9f7d941eb0", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -599,6 +599,7 @@ pub enum RenderOption {\n     NoNodeStyles,\n \n     Monospace,\n+    DarkTheme,\n }\n \n /// Returns vec holding all the default render options.\n@@ -630,10 +631,23 @@ where\n     writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n \n     // Global graph properties\n+    let mut graph_attrs = Vec::new();\n+    let mut content_attrs = Vec::new();\n     if options.contains(&RenderOption::Monospace) {\n-        writeln!(w, r#\"    graph[fontname=\"monospace\"];\"#)?;\n-        writeln!(w, r#\"    node[fontname=\"monospace\"];\"#)?;\n-        writeln!(w, r#\"    edge[fontname=\"monospace\"];\"#)?;\n+        let font = r#\"fontname=\"Courier, monospace\"\"#;\n+        graph_attrs.push(font);\n+        content_attrs.push(font);\n+    };\n+    if options.contains(&RenderOption::DarkTheme) {\n+        graph_attrs.push(r#\"bgcolor=\"black\"\"#);\n+        content_attrs.push(r#\"color=\"white\"\"#);\n+        content_attrs.push(r#\"fontcolor=\"white\"\"#);\n+    }\n+    if !(graph_attrs.is_empty() && content_attrs.is_empty()) {\n+        writeln!(w, r#\"    graph[{}];\"#, graph_attrs.join(\" \"))?;\n+        let content_attrs_str = content_attrs.join(\" \");\n+        writeln!(w, r#\"    node[{}];\"#, content_attrs_str)?;\n+        writeln!(w, r#\"    edge[{}];\"#, content_attrs_str)?;\n     }\n \n     for n in g.nodes().iter() {"}, {"sha": "ee83689f0a4695d41de257fec03e8d60a66866cc", "filename": "compiler/rustc_llvm/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2FCargo.toml?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -4,9 +4,6 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n-[lib]\n-path = \"lib.rs\"\n-\n [features]\n static-libstdcpp = []\n emscripten = []\n@@ -15,5 +12,5 @@ emscripten = []\n libc = \"0.2.73\"\n \n [build-dependencies]\n-build_helper = { path = \"../build_helper\" }\n+build_helper = { path = \"../../src/build_helper\" }\n cc = \"1.0.58\"", "previous_filename": "src/librustc_llvm/Cargo.toml"}, {"sha": "7f1e5cf336ac414046673967de62c72864876a05", "filename": "compiler/rustc_llvm/build.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -175,15 +175,15 @@ fn main() {\n         cfg.debug(false);\n     }\n \n-    build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n-    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n-        .file(\"../rustllvm/RustWrapper.cpp\")\n-        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n-        .file(\"../rustllvm/CoverageMappingWrapper.cpp\")\n-        .file(\"../rustllvm/Linker.cpp\")\n+    build_helper::rerun_if_changed_anything_in_dir(Path::new(\"llvm-wrapper\"));\n+    cfg.file(\"llvm-wrapper/PassWrapper.cpp\")\n+        .file(\"llvm-wrapper/RustWrapper.cpp\")\n+        .file(\"llvm-wrapper/ArchiveWrapper.cpp\")\n+        .file(\"llvm-wrapper/CoverageMappingWrapper.cpp\")\n+        .file(\"llvm-wrapper/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below\n-        .compile(\"rustllvm\");\n+        .compile(\"llvm-wrapper\");\n \n     let (llvm_kind, llvm_link_arg) = detect_llvm_link();\n \n@@ -259,7 +259,7 @@ fn main() {\n     }\n \n     // Some LLVM linker flags (-L and -l) may be needed even when linking\n-    // librustc_llvm, for example when using static libc++, we may need to\n+    // rustc_llvm, for example when using static libc++, we may need to\n     // manually specify the library search path and -ldl -lpthread as link\n     // dependencies.\n     let llvm_linker_flags = tracked_env_var_os(\"LLVM_LINKER_FLAGS\");", "previous_filename": "src/librustc_llvm/build.rs"}, {"sha": "865cd45f708fb4034a6d2d59a305d5a93a0488ae", "filename": "compiler/rustc_llvm/llvm-wrapper/.editorconfig", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2F.editorconfig?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "previous_filename": "src/rustllvm/.editorconfig"}, {"sha": "2797fe8df4a8e0460f7899aa5ba2c342ed593b64", "filename": "compiler/rustc_llvm/llvm-wrapper/ArchiveWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ArchiveWriter.h\"", "previous_filename": "src/rustllvm/ArchiveWrapper.cpp"}, {"sha": "2b1143a4ecff54ab6b79a737a2ddf54b269b75e2", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n #include \"llvm/ProfileData/Coverage/CoverageMapping.h\"\n #include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n #include \"llvm/ProfileData/InstrProf.h\"", "previous_filename": "src/rustllvm/CoverageMappingWrapper.cpp"}, {"sha": "57b8664d3b6058d1050790354cb0a5fc89cc16ca", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "previous_filename": "src/rustllvm/rustllvm.h"}, {"sha": "8766e96f086d2e845ae8b07a9afdb3bc40570598", "filename": "compiler/rustc_llvm/llvm-wrapper/Linker.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLinker.cpp?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,6 +1,6 @@\n #include \"llvm/Linker/Linker.h\"\n \n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n using namespace llvm;\n ", "previous_filename": "src/rustllvm/Linker.cpp"}, {"sha": "7b1c3f9ba2c686c2600d6e8bee08b558280744cd", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -3,7 +3,7 @@\n #include <vector>\n #include <set>\n \n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n \n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"", "previous_filename": "src/rustllvm/PassWrapper.cpp"}, {"sha": "e1c6dd07d2b3856a5a2050a8551474123f7a56c3", "filename": "compiler/rustc_llvm/llvm-wrapper/README", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FREADME?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "previous_filename": "src/rustllvm/README"}, {"sha": "e85a9b763800465c44da19eac5e1463f8a3d57c8", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,4 +1,4 @@\n-#include \"rustllvm.h\"\n+#include \"LLVMWrapper.h\"\n #include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"", "previous_filename": "src/rustllvm/RustWrapper.cpp"}, {"sha": "9d23397ade08e80e170bd9b41ebce4e72c5c7982", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "previous_filename": "src/librustc_llvm/lib.rs"}, {"sha": "0b5b437d186aade4297534aaa699ff0327276eee", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -306,7 +306,11 @@ where\n     let mut buf = Vec::new();\n \n     let graphviz = graphviz::Formatter::new(body, def_id, results, style);\n-    dot::render_opts(&graphviz, &mut buf, &[dot::RenderOption::Monospace])?;\n+    let mut render_opts = vec![dot::RenderOption::Monospace];\n+    if tcx.sess.opts.debugging_opts.graphviz_dark_mode {\n+        render_opts.push(dot::RenderOption::DarkTheme);\n+    }\n+    dot::render_opts(&graphviz, &mut buf, &render_opts)?;\n \n     if let Some(parent) = path.parent() {\n         fs::create_dir_all(parent)?;"}, {"sha": "e89c9437706384e3a8ff65ca067135485f72a9dc", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -55,16 +55,28 @@ where\n     writeln!(w, \"{} {}Mir_{} {{\", kind, cluster, def_name)?;\n \n     // Global graph properties\n-    writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#)?;\n-    writeln!(w, r#\"    node [fontname=\"monospace\"];\"#)?;\n-    writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#)?;\n+    let font = r#\"fontname=\"Courier, monospace\"\"#;\n+    let mut graph_attrs = vec![font];\n+    let mut content_attrs = vec![font];\n+\n+    let dark_mode = tcx.sess.opts.debugging_opts.graphviz_dark_mode;\n+    if dark_mode {\n+        graph_attrs.push(r#\"bgcolor=\"black\"\"#);\n+        content_attrs.push(r#\"color=\"white\"\"#);\n+        content_attrs.push(r#\"fontcolor=\"white\"\"#);\n+    }\n+\n+    writeln!(w, r#\"    graph [{}];\"#, graph_attrs.join(\" \"))?;\n+    let content_attrs_str = content_attrs.join(\" \");\n+    writeln!(w, r#\"    node [{}];\"#, content_attrs_str)?;\n+    writeln!(w, r#\"    edge [{}];\"#, content_attrs_str)?;\n \n     // Graph label\n     write_graph_label(tcx, def_id, body, w)?;\n \n     // Nodes\n     for (block, _) in body.basic_blocks().iter_enumerated() {\n-        write_node(def_id, block, body, w)?;\n+        write_node(def_id, block, body, dark_mode, w)?;\n     }\n \n     // Edges\n@@ -84,6 +96,7 @@ where\n pub fn write_node_label<W: Write, INIT, FINI>(\n     block: BasicBlock,\n     body: &Body<'_>,\n+    dark_mode: bool,\n     w: &mut W,\n     num_cols: u32,\n     init: INIT,\n@@ -100,8 +113,9 @@ where\n     // Basic block number at the top.\n     write!(\n         w,\n-        r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n-        attrs = r#\"bgcolor=\"gray\" align=\"center\"\"#,\n+        r#\"<tr><td bgcolor=\"{bgcolor}\" {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n+        bgcolor = if dark_mode { \"dimgray\" } else { \"gray\" },\n+        attrs = r#\"align=\"center\"\"#,\n         colspan = num_cols,\n         blk = block.index()\n     )?;\n@@ -134,11 +148,12 @@ fn write_node<W: Write>(\n     def_id: DefId,\n     block: BasicBlock,\n     body: &Body<'_>,\n+    dark_mode: bool,\n     w: &mut W,\n ) -> io::Result<()> {\n     // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n     write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(def_id, block))?;\n-    write_node_label(block, body, w, 1, |_| Ok(()), |_| Ok(()))?;\n+    write_node_label(block, body, dark_mode, w, 1, |_| Ok(()), |_| Ok(()))?;\n     // Close the node label and the node itself.\n     writeln!(w, \">];\")\n }"}, {"sha": "d5977ca3c7d2fb8a735841b50dc13c578af613b9", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -262,7 +262,10 @@ impl<'a> TokenTreesReader<'a> {\n             }\n             _ => {\n                 let tt = TokenTree::Token(self.token.take());\n-                let is_joint = self.bump();\n+                let mut is_joint = self.bump();\n+                if !self.token.is_op() {\n+                    is_joint = NonJoint;\n+                }\n                 Ok((tt, is_joint))\n             }\n         }"}, {"sha": "84edfecad192fdbccc83accc02578d01eb155396", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -822,15 +822,15 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        match frame.tree_cursor.look_ahead(dist - 1) {\n+        looker(&match frame.tree_cursor.look_ahead(dist - 1) {\n             Some(tree) => match tree {\n-                TokenTree::Token(token) => looker(token),\n+                TokenTree::Token(token) => token,\n                 TokenTree::Delimited(dspan, delim, _) => {\n-                    looker(&Token::new(token::OpenDelim(delim.clone()), dspan.open))\n+                    Token::new(token::OpenDelim(delim), dspan.open)\n                 }\n             },\n-            None => looker(&Token::new(token::CloseDelim(frame.delim), frame.span.close)),\n-        }\n+            None => Token::new(token::CloseDelim(frame.delim), frame.span.close),\n+        })\n     }\n \n     /// Returns whether any of the given keywords are `dist` tokens ahead of the current one."}, {"sha": "c5050dbea73394efc094fcede30ee8bc3436adbe", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -909,6 +909,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"force all crates to be `rustc_private` unstable (default: no)\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n         \"set the optimization fuel quota for a crate\"),\n+    graphviz_dark_mode: bool = (false, parse_bool, [UNTRACKED],\n+        \"use dark-themed colors in graphviz output (default: no)\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some statistics about AST and HIR (default: no)\"),\n     human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],"}, {"sha": "52531f54c299e5340dcfc5a4eafbb6922f606335", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -45,7 +45,7 @@\n # this flag will indicate that this version check should not be done.\n #version-check = true\n \n-# Link libstdc++ statically into the librustc_llvm instead of relying on a\n+# Link libstdc++ statically into the rustc_llvm instead of relying on a\n # dynamic version to be available.\n #static-libstdcpp = false\n "}, {"sha": "1a836f11499ec8189f4734e75053990cb3bad5ff", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -13,6 +13,9 @@ trait Recover<Q: ?Sized> {\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n \n+/// Same purpose as `Option::unwrap` but doesn't always guarantee a panic\n+/// if the option contains no value.\n+/// SAFETY: the caller must ensure that the option contains a value.\n #[inline(always)]\n pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n     val.unwrap_or_else(|| {"}, {"sha": "92c4f2ccfe8a00df2876e82f121231b22f19e35b", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 58, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -54,16 +54,9 @@\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n-//! [null]: ./fn.null.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n-//! [atomic operations]: ../../std/sync/atomic/index.html\n-//! [`copy`]: ../../std/ptr/fn.copy.html\n+//! [atomic operations]: crate::sync::atomic\n //! [`offset`]: ../../std/primitive.pointer.html#method.offset\n-//! [`read_unaligned`]: ./fn.read_unaligned.html\n-//! [`write_unaligned`]: ./fn.write_unaligned.html\n-//! [`read_volatile`]: ./fn.read_volatile.html\n-//! [`write_volatile`]: ./fn.write_volatile.html\n-//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -118,9 +111,9 @@ mod mut_ptr;\n /// done automatically by the compiler. This means the fields of packed structs\n /// are not dropped in-place.\n ///\n-/// [`ptr::read`]: ../ptr/fn.read.html\n-/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n-/// [pinned]: ../pin/index.html\n+/// [`ptr::read`]: self::read\n+/// [`ptr::read_unaligned`]: self::read_unaligned\n+/// [pinned]: crate::pin\n ///\n /// # Safety\n ///\n@@ -136,14 +129,12 @@ mod mut_ptr;\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n /// foo` counts as a use because it will cause the value to be dropped\n-/// again. [`write`] can be used to overwrite data without causing it to be\n+/// again. [`write()`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write`]: ../ptr/fn.write.html\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -243,9 +234,9 @@ pub(crate) struct FatPtr<T> {\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n ///\n-/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+/// [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n ///\n /// # Examples\n ///\n@@ -274,10 +265,9 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n /// See the documentation of [`slice_from_raw_parts`] for more details.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n ///\n-/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n-/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n+/// [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n ///\n /// # Examples\n ///\n@@ -316,8 +306,6 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///   overlapping region of memory from `x` will be used. This is demonstrated\n ///   in the second example below.\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -328,7 +316,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///\n /// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -406,7 +394,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n /// the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -533,8 +521,6 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n /// operates on raw pointers instead of references. When references are\n /// available, [`mem::replace`] should be preferred.\n ///\n-/// [`mem::replace`]: ../mem/fn.replace.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -547,7 +533,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -653,7 +639,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n-/// [`write`] can be used to overwrite data without causing it to be dropped.\n+/// [`write()`] can be used to overwrite data without causing it to be dropped.\n ///\n /// ```\n /// use std::ptr;\n@@ -682,11 +668,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// assert_eq!(s, \"bar\");\n /// ```\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-/// [`write`]: ./fn.write.html\n+/// [valid]: self#safety\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -723,11 +705,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n+/// [valid]: self#safety\n ///\n /// ## On `packed` structs\n ///\n@@ -819,8 +798,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been [`read`] from.\n ///\n-/// [`read`]: ./fn.read.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -832,8 +809,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -888,8 +864,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// assert_eq!(foo, \"bar\");\n /// assert_eq!(bar, \"foo\");\n /// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -904,7 +878,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike [`write`], the pointer may be unaligned.\n+/// Unlike [`write()`], the pointer may be unaligned.\n ///\n /// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n /// could leak allocations or resources, so care should be taken not to overwrite\n@@ -916,9 +890,6 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been read with [`read_unaligned`].\n ///\n-/// [`write`]: ./fn.write.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -927,7 +898,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// ## On `packed` structs\n ///\n@@ -1007,8 +978,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// [`write_volatile`]: ./fn.write_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1041,10 +1010,8 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n+/// [valid]: self#safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n@@ -1089,8 +1056,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n-/// [`read_volatile`]: ./fn.read_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1115,7 +1080,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile"}, {"sha": "bfd05db6b1bbee628c1554fdd33db18d7296d81d", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -20,7 +20,7 @@ libc = { version = \"0.2.74\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.35\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.8.1\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.9.0\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate\n addr2line = { version = \"0.13.0\", optional = true, default-features = false }"}, {"sha": "1a3a493fbb8f68dcff12a948f828669847bf99fb", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 93, "deletions": 6, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -497,6 +497,50 @@ impl<K, V, S> HashMap<K, V, S> {\n         Drain { base: self.base.drain() }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n+    /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n+    }\n+\n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n     /// for reuse.\n     ///\n@@ -1190,6 +1234,19 @@ impl<'a, K, V> Drain<'a, K, V> {\n     }\n }\n \n+/// A draining, filtering iterator over the entries of a `HashMap`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n+///\n+/// [`drain_filter`]: HashMap::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, V, F>,\n+}\n+\n /// A mutable iterator over the values of a `HashMap`.\n ///\n /// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n@@ -1247,16 +1304,16 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n-    Occupied(RawOccupiedEntryMut<'a, K, V>),\n+    Occupied(RawOccupiedEntryMut<'a, K, V, S>),\n     /// A vacant entry.\n     Vacant(RawVacantEntryMut<'a, K, V, S>),\n }\n \n /// A view into an occupied entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n-    base: base::RawOccupiedEntryMut<'a, K, V>,\n+pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n+    base: base::RawOccupiedEntryMut<'a, K, V, S>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n@@ -1457,7 +1514,7 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     }\n }\n \n-impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n+impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n     /// Gets a reference to the key in the entry.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n@@ -1597,7 +1654,7 @@ impl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-impl<K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'_, K, V> {\n+impl<K: Debug, V: Debug, S> Debug for RawOccupiedEntryMut<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"RawOccupiedEntryMut\")\n             .field(\"key\", self.key())\n@@ -1990,6 +2047,36 @@ where\n     }\n }\n \n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2698,7 +2785,7 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n+pub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n         hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n         hashbrown::TryReserveError::AllocError { layout } => {"}, {"sha": "467968354e25d984d1b47f885da660a1ae238a9d", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -924,3 +924,164 @@ fn test_raw_entry() {\n         }\n     }\n }\n+\n+mod test_drain_filter {\n+    use super::*;\n+\n+    use crate::panic::{catch_unwind, AssertUnwindSafe};\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+    trait EqSorted: Iterator {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool;\n+    }\n+\n+    impl<T: Iterator> EqSorted for T\n+    where\n+        T::Item: Eq + Ord,\n+    {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool {\n+            let mut v: Vec<_> = self.collect();\n+            v.sort_unstable();\n+            v.into_iter().eq(other)\n+        }\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: HashMap<i32, i32> = HashMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n+        assert_eq!(map.len(), 3);\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq_sorted(crate::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq_sorted(0..3));\n+        assert!(map.values().copied().eq_sorted(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq_sorted((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|_, _| {\n+                PREDS.fetch_add(1, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            }))\n+        }))\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+\n+    // Same as above, but attempt to use the iterator again after the panic in the predicate\n+    #[test]\n+    fn pred_panic_reuse() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        {\n+            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            });\n+            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+            // Iterator behaviour after a panic is explicitly unspecified,\n+            // so this is just the current implementation:\n+            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+            assert!(result.is_err());\n+        }\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+}"}, {"sha": "72f4798b65d66d665f27c1bb9af67636e09bb6b0", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 136, "deletions": 57, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,14 +1,16 @@\n #[cfg(test)]\n mod tests;\n \n+use hashbrown::hash_set as base;\n+\n use crate::borrow::Borrow;\n use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{BuildHasher, Hash};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n use crate::ops::{BitAnd, BitOr, BitXor, Sub};\n \n-use super::map::{self, HashMap, Keys, RandomState};\n+use super::map::{map_try_reserve_error, RandomState};\n \n // Future Optimization (FIXME!)\n // ============================\n@@ -101,13 +103,14 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// // use the values stored in the set\n /// ```\n ///\n+/// [`HashMap`]: crate::collections::HashMap\n /// [`RefCell`]: crate::cell::RefCell\n /// [`Cell`]: crate::cell::Cell\n #[derive(Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>,\n+    base: base::HashSet<T, S>,\n }\n \n impl<T> HashSet<T, RandomState> {\n@@ -125,7 +128,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::new() }\n+        Default::default()\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity.\n@@ -143,7 +146,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, Default::default()) }\n     }\n }\n \n@@ -160,7 +163,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n+        self.base.capacity()\n     }\n \n     /// An iterator visiting all elements in arbitrary order.\n@@ -182,7 +185,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.map.keys() }\n+        Iter { base: self.base.iter() }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -200,7 +203,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.map.len()\n+        self.base.len()\n     }\n \n     /// Returns `true` if the set contains no elements.\n@@ -218,7 +221,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.map.is_empty()\n+        self.base.is_empty()\n     }\n \n     /// Clears the set, returning all elements in an iterator.\n@@ -241,7 +244,48 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, T> {\n-        Drain { iter: self.map.drain() }\n+        Drain { base: self.base.drain() }\n+    }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<i32> = (0..8).collect();\n+    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n+    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n     }\n \n     /// Clears the set, removing all values.\n@@ -259,7 +303,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.map.clear()\n+        self.base.clear()\n     }\n \n     /// Creates a new empty hash set which will use the given hasher to hash\n@@ -288,7 +332,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_hasher(hasher) }\n+        HashSet { base: base::HashSet::with_hasher(hasher) }\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity, using\n@@ -318,7 +362,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n     /// Returns a reference to the set's [`BuildHasher`].\n@@ -336,7 +380,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n-        self.map.hasher()\n+        self.base.hasher()\n     }\n }\n \n@@ -364,7 +408,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        self.map.reserve(additional)\n+        self.base.reserve(additional)\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -387,7 +431,7 @@ where\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.map.try_reserve(additional)\n+        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n     }\n \n     /// Shrinks the capacity of the set as much as possible. It will drop\n@@ -409,7 +453,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        self.map.shrink_to_fit()\n+        self.base.shrink_to_fit()\n     }\n \n     /// Shrinks the capacity of the set with a lower limit. It will drop\n@@ -437,7 +481,7 @@ where\n     #[inline]\n     #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.map.shrink_to(min_capacity)\n+        self.base.shrink_to(min_capacity)\n     }\n \n     /// Visits the values representing the difference,\n@@ -577,7 +621,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.contains_key(value)\n+        self.base.contains(value)\n     }\n \n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n@@ -602,7 +646,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.get_key_value(value).map(|(k, _)| k)\n+        self.base.get(value)\n     }\n \n     /// Inserts the given `value` into the set if it is not present, then\n@@ -626,7 +670,7 @@ where\n     pub fn get_or_insert(&mut self, value: T) -> &T {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(&value).or_insert(value, ()).0\n+        self.base.get_or_insert(value)\n     }\n \n     /// Inserts an owned copy of the given `value` into the set if it is not\n@@ -658,7 +702,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (value.to_owned(), ())).0\n+        self.base.get_or_insert_owned(value)\n     }\n \n     /// Inserts a value computed from `f` into the set if the given `value` is\n@@ -691,7 +735,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (f(value), ())).0\n+        self.base.get_or_insert_with(value, f)\n     }\n \n     /// Returns `true` if `self` has no elements in common with `other`.\n@@ -788,7 +832,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n-        self.map.insert(value, ()).is_none()\n+        self.base.insert(value)\n     }\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n@@ -809,13 +853,7 @@ where\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn replace(&mut self, value: T) -> Option<T> {\n-        match self.map.entry(value) {\n-            map::Entry::Occupied(occupied) => Some(occupied.replace_key()),\n-            map::Entry::Vacant(vacant) => {\n-                vacant.insert(());\n-                None\n-            }\n-        }\n+        self.base.replace(value)\n     }\n \n     /// Removes a value from the set. Returns whether the value was\n@@ -843,7 +881,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove(value).is_some()\n+        self.base.remove(value)\n     }\n \n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n@@ -868,7 +906,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove_entry(value).map(|(k, _)| k)\n+        self.base.take(value)\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -886,11 +924,11 @@ where\n     /// assert_eq!(set.len(), 3);\n     /// ```\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n-    pub fn retain<F>(&mut self, mut f: F)\n+    pub fn retain<F>(&mut self, f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        self.map.retain(|k, _| f(k));\n+        self.base.retain(f)\n     }\n }\n \n@@ -949,17 +987,17 @@ where\n {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        self.map.extend(iter.into_iter().map(|k| (k, ())));\n+        self.base.extend(iter);\n     }\n \n     #[inline]\n     fn extend_one(&mut self, item: T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n-        self.map.extend_reserve(additional);\n+        self.base.extend_reserve(additional);\n     }\n }\n \n@@ -976,7 +1014,7 @@ where\n \n     #[inline]\n     fn extend_one(&mut self, &item: &'a T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n@@ -993,7 +1031,7 @@ where\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     #[inline]\n     fn default() -> HashSet<T, S> {\n-        HashSet { map: HashMap::default() }\n+        HashSet { base: Default::default() }\n     }\n }\n \n@@ -1137,7 +1175,7 @@ where\n /// [`iter`]: HashSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>,\n+    base: base::Iter<'a, K>,\n }\n \n /// An owning iterator over the items of a `HashSet`.\n@@ -1148,7 +1186,7 @@ pub struct Iter<'a, K: 'a> {\n /// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: map::IntoIter<K, ()>,\n+    base: base::IntoIter<K>,\n }\n \n /// A draining iterator over the items of a `HashSet`.\n@@ -1159,7 +1197,20 @@ pub struct IntoIter<K> {\n /// [`drain`]: HashSet::drain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: map::Drain<'a, K, ()>,\n+    base: base::Drain<'a, K>,\n+}\n+\n+/// A draining, filtering iterator over the items of a `HashSet`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n+///\n+/// [`drain_filter`]: HashSet::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, F>,\n }\n \n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n@@ -1250,15 +1301,15 @@ impl<T, S> IntoIterator for HashSet<T, S> {\n     /// ```\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { iter: self.map.into_iter() }\n+        IntoIter { base: self.base.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Clone for Iter<'_, K> {\n     #[inline]\n     fn clone(&self) -> Self {\n-        Iter { iter: self.iter.clone() }\n+        Iter { base: self.base.clone() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1267,18 +1318,18 @@ impl<'a, K> Iterator for Iter<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a K> {\n-        self.iter.next()\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Iter<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1297,18 +1348,18 @@ impl<K> Iterator for IntoIter<K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1317,8 +1368,7 @@ impl<K> FusedIterator for IntoIter<K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n     }\n }\n \n@@ -1328,18 +1378,18 @@ impl<'a, K> Iterator for Drain<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Drain<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1348,8 +1398,37 @@ impl<K> FusedIterator for Drain<'_, K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> Iterator for DrainFilter<'_, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    type Item = K;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n     }\n }\n "}, {"sha": "40f8467fd93fddf18907d1a9d55440164a9a522f", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,6 +1,9 @@\n use super::super::map::RandomState;\n use super::HashSet;\n \n+use crate::panic::{catch_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicU32, Ordering};\n+\n #[test]\n fn test_zero_capacities() {\n     type HS = HashSet<i32>;\n@@ -413,3 +416,71 @@ fn test_retain() {\n     assert!(set.contains(&4));\n     assert!(set.contains(&6));\n }\n+\n+#[test]\n+fn test_drain_filter() {\n+    let mut x: HashSet<_> = [1].iter().copied().collect();\n+    let mut y: HashSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|_| {\n+            PREDS.fetch_add(1, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D;\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            0 => true,\n+            _ => panic!(),\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 1);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    assert_eq!(set.len(), 0);\n+}"}, {"sha": "d2baf4a1d1e6aeebee68622ef3b732fdfb884418", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -812,7 +812,7 @@ impl<'a> Builder<'a> {\n             format!(\"CARGO_PROFILE_{}_{}\", profile, name)\n         };\n \n-        // See comment in librustc_llvm/build.rs for why this is necessary, largely llvm-config\n+        // See comment in rustc_llvm/build.rs for why this is necessary, largely llvm-config\n         // needs to not accidentally link to libLLVM in stage0/lib.\n         cargo.env(\"REAL_LIBRARY_PATH_VAR\", &util::dylib_path_var());\n         if let Some(e) = env::var_os(util::dylib_path_var()) {\n@@ -829,9 +829,9 @@ impl<'a> Builder<'a> {\n         // scripts can do less work (i.e. not building/requiring LLVM).\n         if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n             // If we've not yet built LLVM, or it's stale, then bust\n-            // the librustc_llvm cache. That will always work, even though it\n+            // the rustc_llvm cache. That will always work, even though it\n             // may mean that on the next non-check build we'll need to rebuild\n-            // librustc_llvm. But if LLVM is stale, that'll be a tiny amount\n+            // rustc_llvm. But if LLVM is stale, that'll be a tiny amount\n             // of work comparitively, and we'd likely need to rebuild it anyway,\n             // so that's okay.\n             if crate::native::prebuilt_llvm_config(self, target).is_err() {"}, {"sha": "9d314e8452b9c58385336f707b7625f83242c2b7", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -560,7 +560,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n     }\n \n     // Pass down configuration from the LLVM build into the build of\n-    // librustc_llvm and librustc_codegen_llvm.\n+    // rustc_llvm and rustc_codegen_llvm.\n     //\n     // Note that this is disabled if LLVM itself is disabled or we're in a check\n     // build. If we are in a check build we still go ahead here presuming we've\n@@ -579,7 +579,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             cargo.env(\"CFG_LLVM_ROOT\", s);\n         }\n-        // Some LLVM linker flags (-L and -l) may be needed to link librustc_llvm.\n+        // Some LLVM linker flags (-L and -l) may be needed to link rustc_llvm.\n         if let Some(ref s) = builder.config.llvm_ldflags {\n             cargo.env(\"LLVM_LINKER_FLAGS\", s);\n         }"}, {"sha": "6cd850bc0bfaadfe8cc343f42ca86a8f0b811d2e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -169,7 +169,6 @@ impl Step for Llvm {\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n-            .define(\"WITH_POLLY\", \"OFF\")\n             .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n             .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n             .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")\n@@ -305,10 +304,6 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n         }\n \n-        if let Some(ref python) = builder.config.python {\n-            cfg.define(\"PYTHON_EXECUTABLE\", python);\n-        }\n-\n         configure_cmake(builder, target, &mut cfg, true);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM"}, {"sha": "a5a1824c84e78be919f81ea5f4119d70686b7121", "filename": "src/etc/gdb_lookup.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -69,9 +69,9 @@ def lookup(valobj):\n         else:\n             return StdOldHashMapProvider(valobj)\n     if rust_type == RustType.STD_HASH_SET:\n-        hash_map = valobj[\"map\"]\n+        hash_map = valobj[valobj.type.fields()[0]]\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapProvider(hash_map, show_values=False)\n+            return StdHashMapProvider(valobj, show_values=False)\n         else:\n             return StdOldHashMapProvider(hash_map, show_values=False)\n "}, {"sha": "bae51e6f9ee93a394ba51718ebfe5b81a9f1c5a5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -347,7 +347,7 @@ def __init__(self, valobj, show_values=True):\n         self.valobj = valobj\n         self.show_values = show_values\n \n-        table = self.valobj[\"base\"][\"table\"]\n+        table = self.table()\n         capacity = int(table[\"bucket_mask\"]) + 1\n         ctrl = table[\"ctrl\"][\"pointer\"]\n \n@@ -368,6 +368,18 @@ def __init__(self, valobj, show_values=True):\n             if is_presented:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj[\"base\"]\n+        elif self.valobj.type.fields()[0].name == \"map\":\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps std::collections::HashMap, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"map\"][\"base\"]\n+        else:\n+            # HashSet wraps hashbrown::HashSet, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"base\"][\"map\"]\n+        return hashbrown_hashmap[\"table\"]\n+\n     def to_string(self):\n         if self.show_values:\n             return \"HashMap(size={})\".format(self.size)"}, {"sha": "3cee51982ba9f921eac8be4e9eeed216df09680b", "filename": "src/etc/lldb_lookup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -94,7 +94,7 @@ def synthetic_lookup(valobj, dict):\n     if rust_type == RustType.STD_HASH_SET:\n         hash_map = valobj.GetChildAtIndex(0)\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+            return StdHashMapSyntheticProvider(valobj, dict, show_values=False)\n         else:\n             return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n "}, {"sha": "64cb9837943b902b0b8fcdf9749859848c25e884", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -526,7 +526,7 @@ def get_child_at_index(self, index):\n \n     def update(self):\n         # type: () -> None\n-        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        table = self.table()\n         capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n         ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n \n@@ -552,6 +552,17 @@ def update(self):\n             if is_present:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        # type: () -> SBValue\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj.GetChildMemberWithName(\"base\")\n+        else:\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps either std HashMap or hashbrown::HashSet, which both\n+            # wrap hashbrown::HashMap, so either way we \"unwrap\" twice.\n+            hashbrown_hashmap = self.valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+        return hashbrown_hashmap.GetChildMemberWithName(\"table\")\n+\n     def has_children(self):\n         # type: () -> bool\n         return True"}, {"sha": "9550c25f2fcfe5da1b78cc5b2ab743f3f1ab105f", "filename": "src/etc/natvis/libstd.natvis", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -5,7 +5,7 @@\n \n     Current std impls:\n       std::collections::hash::set::HashSet<K, S>      is implemented in terms of...\n-      std::collections::hash::map::HashMap<K, V, S>   is implemented in terms of...\n+      hashbrown::set::HashSet<K, S>                   is implemented in terms of...\n       hashbrown::map::HashMap<K, V, S>                is implemented in terms of...\n       hashbrown::raw::RawTable<(K, V)>\n \n@@ -50,22 +50,22 @@\n   </Type>\n \n   <Type Name=\"std::collections::hash::set::HashSet&lt;*,*&gt;\">\n-    <DisplayString>{{ size={map.base.table.items} }}</DisplayString>\n+    <DisplayString>{{ size={base.map.table.items} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[size]\">map.base.table.items</Item>\n-      <Item Name=\"[capacity]\">map.base.table.items + map.base.table.growth_left</Item>\n-      <Item Name=\"[state]\">map.base.hash_builder</Item>\n+      <Item Name=\"[size]\">base.map.table.items</Item>\n+      <Item Name=\"[capacity]\">base.map.table.items + base.map.table.growth_left</Item>\n+      <Item Name=\"[state]\">base.map.hash_builder</Item>\n \n       <CustomListItems>\n         <Variable Name=\"i\" InitialValue=\"0\" />\n-        <Variable Name=\"n\" InitialValue=\"map.base.table.items\" />\n-        <Size>map.base.table.items</Size>\n+        <Variable Name=\"n\" InitialValue=\"base.map.table.items\" />\n+        <Size>base.map.table.items</Size>\n         <Loop>\n           <Break Condition=\"n == 0\" />\n-          <If Condition=\"(map.base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n+          <If Condition=\"(base.map.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n             <!-- Bucket is populated -->\n             <Exec>n--</Exec>\n-            <Item>(($T1*)map.base.table.ctrl.pointer)[-(i + 1)]</Item>\n+            <Item>(($T1*)base.map.table.ctrl.pointer)[-(i + 1)]</Item>\n           </If>\n           <Exec>i++</Exec>\n         </Loop>"}, {"sha": "df4f11f0f21693ba41f3eea94f223781aa62d80d", "filename": "src/test/mir-opt/graphviz.main.mir_map.0.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Ftest%2Fmir-opt%2Fgraphviz.main.mir_map.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/a1894e4afe1a39f718cc27232a5a2f0d02b501f6/src%2Ftest%2Fmir-opt%2Fgraphviz.main.mir_map.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgraphviz.main.mir_map.0.dot?ref=a1894e4afe1a39f718cc27232a5a2f0d02b501f6", "patch": "@@ -1,7 +1,7 @@\n digraph Mir_0_3 {\n-    graph [fontname=\"monospace\"];\n-    node [fontname=\"monospace\"];\n-    edge [fontname=\"monospace\"];\n+    graph [fontname=\"Courier, monospace\"];\n+    node [fontname=\"Courier, monospace\"];\n+    edge [fontname=\"Courier, monospace\"];\n     label=<fn main() -&gt; ()<br align=\"left\"/>>;\n     bb0__0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">0</td></tr><tr><td align=\"left\" balign=\"left\">_0 = const ()<br/></td></tr><tr><td align=\"left\">goto</td></tr></table>>];\n     bb1__0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">1</td></tr><tr><td align=\"left\">resume</td></tr></table>>];"}]}