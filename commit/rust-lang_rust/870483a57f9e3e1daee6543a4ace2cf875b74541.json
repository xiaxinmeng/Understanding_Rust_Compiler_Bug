{"sha": "870483a57f9e3e1daee6543a4ace2cf875b74541", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MDQ4M2E1N2Y5ZTNlMWRhZWU2NTQzYTRhY2UyY2Y4NzViNzQ1NDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-20T21:26:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-20T21:26:15Z"}, "message": "Auto merge of #44392 - Zoxc:yield-order, r=nikomatsakis\n\nOnly consider yields coming after the expressions when computing generator interiors\n\nWhen looking at the scopes which temporaries of expressions can live for during computation of generator interiors, only consider yields which appear after the expression in question in the HIR.", "tree": {"sha": "0d7b9d76e81c06b47045fee183a4a984dff85c38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d7b9d76e81c06b47045fee183a4a984dff85c38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/870483a57f9e3e1daee6543a4ace2cf875b74541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/870483a57f9e3e1daee6543a4ace2cf875b74541", "html_url": "https://github.com/rust-lang/rust/commit/870483a57f9e3e1daee6543a4ace2cf875b74541", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/870483a57f9e3e1daee6543a4ace2cf875b74541/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01c65cb15ac57bfdc91613a4f6032ecc76c402a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/01c65cb15ac57bfdc91613a4f6032ecc76c402a3", "html_url": "https://github.com/rust-lang/rust/commit/01c65cb15ac57bfdc91613a4f6032ecc76c402a3"}, {"sha": "2384dd92dc53feda1e5cebf371917787b9b3906c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2384dd92dc53feda1e5cebf371917787b9b3906c", "html_url": "https://github.com/rust-lang/rust/commit/2384dd92dc53feda1e5cebf371917787b9b3906c"}], "stats": {"total": 287, "additions": 225, "deletions": 62}, "files": [{"sha": "9d8075de2eb2f985b03c72137519e816e5b7ca82", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -27,11 +27,19 @@\n //! for more details.\n //!\n //! Note: it is an important invariant that the default visitor walks\n-//! the body of a function in \"execution order\" (more concretely,\n-//! reverse post-order with respect to the CFG implied by the AST),\n-//! meaning that if AST node A may execute before AST node B, then A\n-//! is visited first.  The borrow checker in particular relies on this\n-//! property.\n+//! the body of a function in \"execution order\" - more concretely, if\n+//! we consider the reverse post-order (RPO) of the CFG implied by the HIR,\n+//! then a pre-order traversal of the HIR is consistent with the CFG RPO\n+//! on the *initial CFG point* of each HIR node, while a post-order traversal\n+//! of the HIR is consistent with the CFG RPO on each *final CFG point* of\n+//! each CFG node.\n+//!\n+//! One thing that follows is that if HIR node A always starts/ends executing\n+//! before HIR node B, then A appears in traversal pre/postorder before B,\n+//! respectively. (This follows from RPO respecting CFG domination).\n+//!\n+//! This order consistency is required in a few places in rustc, for\n+//! example generator inference, and possibly also HIR borrowck.\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n@@ -403,10 +411,13 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n-    walk_list!(visitor, visit_expr, &local.init);\n }\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {"}, {"sha": "41a253f7904f72e7b6b5b31e5c4b5780b1a141ed", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -1495,7 +1495,7 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             hir::ExprYield(ref expr) => {\n-                self.s.word(\"yield\")?;\n+                self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n         }"}, {"sha": "6cce7447669f740103df7dff03bddf72779be2a6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 117, "deletions": 28, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -18,7 +18,6 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n-use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n@@ -250,8 +249,80 @@ pub struct ScopeTree {\n     closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n \n     /// If there are any `yield` nested within a scope, this map\n-    /// stores the `Span` of the first one.\n-    yield_in_scope: FxHashMap<Scope, Span>,\n+    /// stores the `Span` of the last one and its index in the\n+    /// postorder of the Visitor traversal on the HIR.\n+    ///\n+    /// HIR Visitor postorder indexes might seem like a peculiar\n+    /// thing to care about. but it turns out that HIR bindings\n+    /// and the temporary results of HIR expressions are never\n+    /// storage-live at the end of HIR nodes with postorder indexes\n+    /// lower than theirs, and therefore don't need to be suspended\n+    /// at yield-points at these indexes.\n+    ///\n+    /// For an example, suppose we have some code such as:\n+    /// ```rust,ignore (example)\n+    ///     foo(f(), yield y, bar(g()))\n+    /// ```\n+    ///\n+    /// With the HIR tree (calls numbered for expository purposes)\n+    /// ```\n+    ///     Call#0(foo, [Call#1(f), Yield(y), Call#2(bar, Call#3(g))])\n+    /// ```\n+    ///\n+    /// Obviously, the result of `f()` was created before the yield\n+    /// (and therefore needs to be kept valid over the yield) while\n+    /// the result of `g()` occurs after the yield (and therefore\n+    /// doesn't). If we want to infer that, we can look at the\n+    /// postorder traversal:\n+    /// ```\n+    /// `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```\n+    ///\n+    /// In which we can easily see that `Call#1` occurs before the yield,\n+    /// and `Call#3` after it.\n+    ///\n+    /// To see that this method works, consider:\n+    ///\n+    /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n+    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n+    /// the yield and D would be one of the calls). Let's show that\n+    /// `D` is storage-dead at `U`.\n+    ///\n+    /// Remember that storage-live/storage-dead refers to the state of\n+    /// the *storage*, and does not consider moves/drop flags.\n+    ///\n+    /// Then:\n+    ///     1. From the ordering guarantee of HIR visitors (see\n+    ///     `rustc::hir::intravisit`), `D` does not dominate `U`.\n+    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n+    ///     we might visit `U` without ever getting to `D`).\n+    ///     3. However, we guarantee that at each HIR point, each\n+    ///     binding/temporary is always either always storage-live\n+    ///     or always storage-dead. This is what is being guaranteed\n+    ///     by `terminating_scopes` including all blocks where the\n+    ///     count of executions is not guaranteed.\n+    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n+    ///     QED.\n+    ///\n+    /// I don't think this property relies on `3.` in an essential way - it\n+    /// is probably still correct even if we have \"unrestricted\" terminating\n+    /// scopes. However, why use the complicated proof when a simple one\n+    /// works?\n+    ///\n+    /// A subtle thing: `box` expressions, such as `box (&x, yield 2, &y)`. It\n+    /// might seem that a `box` expression creates a `Box<T>` temporary\n+    /// when it *starts* executing, at `HIR-preorder(BOX-EXPR)`. That might\n+    /// be true in the MIR desugaring, but it is not important in the semantics.\n+    ///\n+    /// The reason is that semantically, until the `box` expression returns,\n+    /// the values are still owned by their containing expressions. So\n+    /// we'll see that `&x`.\n+    yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n+\n+    /// The number of visit_expr and visit_pat calls done in the body.\n+    /// Used to sanity check visit_expr/visit_pat call count when\n+    /// calculating geneartor interiors.\n+    body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -274,6 +345,9 @@ pub struct Context {\n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    // The number of expressions and patterns visited in the current body\n+    expr_and_pat_count: usize,\n+\n     // Generated scope tree:\n     scope_tree: ScopeTree,\n \n@@ -611,10 +685,18 @@ impl<'tcx> ScopeTree {\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n-    /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<Span> {\n+    /// returns `Some((span, expr_count))` with the span of a yield we found and\n+    /// the number of expressions appearing before the `yield` in the body.\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<(Span, usize)> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n+\n+    /// Gives the number of expressions visited in a body.\n+    /// Used to sanity check visit_expr call count when\n+    /// calculating geneartor interiors.\n+    pub fn body_expr_count(&self, body_id: hir::BodyId) -> Option<usize> {\n+        self.body_expr_count.get(&body_id).map(|r| *r)\n+    }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n@@ -714,6 +796,8 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n     }\n \n     intravisit::walk_pat(visitor, pat);\n+\n+    visitor.expr_and_pat_count += 1;\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n@@ -804,29 +888,6 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 // record_superlifetime(new_cx, expr.callee_id);\n             }\n \n-            hir::ExprYield(..) => {\n-                // Mark this expr's scope and all parent scopes as containing `yield`.\n-                let mut scope = Scope::Node(expr.hir_id.local_id);\n-                loop {\n-                    match visitor.scope_tree.yield_in_scope.entry(scope) {\n-                        // Another `yield` has already been found.\n-                        Entry::Occupied(_) => break,\n-\n-                        Entry::Vacant(entry) => {\n-                            entry.insert(expr.span);\n-                        }\n-                    }\n-\n-                    // Keep traversing up while we can.\n-                    match visitor.scope_tree.parent_map.get(&scope) {\n-                        // Don't cross from closure bodies to their parent.\n-                        Some(&Scope::CallSite(_)) => break,\n-                        Some(&superscope) => scope = superscope,\n-                        None => break\n-                    }\n-                }\n-            }\n-\n             _ => {}\n         }\n     }\n@@ -842,6 +903,25 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         _ => intravisit::walk_expr(visitor, expr)\n     }\n \n+    visitor.expr_and_pat_count += 1;\n+\n+    if let hir::ExprYield(..) = expr.node {\n+        // Mark this expr's scope and all parent scopes as containing `yield`.\n+        let mut scope = Scope::Node(expr.hir_id.local_id);\n+        loop {\n+            visitor.scope_tree.yield_in_scope.insert(scope,\n+                (expr.span, visitor.expr_and_pat_count));\n+\n+            // Keep traversing up while we can.\n+            match visitor.scope_tree.parent_map.get(&scope) {\n+                // Don't cross from closure bodies to their parent.\n+                Some(&Scope::CallSite(_)) => break,\n+                Some(&superscope) => scope = superscope,\n+                None => break\n+            }\n+        }\n+    }\n+\n     visitor.cx = prev_cx;\n }\n \n@@ -1120,6 +1200,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                body_id,\n                self.cx.parent);\n \n+        let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n         let outer_cx = self.cx;\n         let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n@@ -1165,7 +1246,12 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n             resolve_local(self, None, Some(&body.value));\n         }\n \n+        if body.is_generator {\n+            self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n+        }\n+\n         // Restore context we had at the start.\n+        self.expr_and_pat_count = outer_ec;\n         self.cx = outer_cx;\n         self.terminating_scopes = outer_ts;\n     }\n@@ -1200,6 +1286,7 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n+            expr_and_pat_count: 0,\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n@@ -1246,6 +1333,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n         let ScopeTree {\n             root_body,\n             root_parent,\n+            ref body_expr_count,\n             ref parent_map,\n             ref var_map,\n             ref destruction_scopes,\n@@ -1259,6 +1347,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n             root_parent.hash_stable(hcx, hasher);\n         });\n \n+        body_expr_count.hash_stable(hcx, hasher);\n         parent_map.hash_stable(hcx, hasher);\n         var_map.hash_stable(hcx, hasher);\n         destruction_scopes.hash_stable(hcx, hasher);"}, {"sha": "ef93e0365e66d2e7dd38c901ca90d4b602531df3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -857,7 +857,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None\n                 };\n \n-                if let Some(yield_span) = maybe_borrow_across_yield {\n+                if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n                     struct_span_err!(self.tcx.sess,\n                                      error_span,"}, {"sha": "f2607b164de26346f63179b872d1fb31f2aeea6f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -96,7 +96,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Box { value } => {\n                 let value = this.hir.mirror(value);\n-                let result = this.local_decls.push(LocalDecl::new_temp(expr.ty, expr_span));\n+                // The `Box<T>` temporary created here is not a part of the HIR,\n+                // and therefore is not considered during generator OIBIT\n+                // determination. See the comment about `box` at `yield_in_scope`.\n+                let result = this.local_decls.push(\n+                    LocalDecl::new_internal(expr.ty, expr_span));\n                 this.cfg.push(block, Statement {\n                     source_info,\n                     kind: StatementKind::StorageLive(result)"}, {"sha": "af1297697c24188b04e5426e2188e4c4458c1526", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Body, Pat, PatKind, Expr};\n+use rustc::hir::{self, Pat, PatKind, Expr};\n use rustc::middle::region;\n use rustc::ty::Ty;\n use std::rc::Rc;\n@@ -26,14 +26,27 @@ struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_scope_tree: Rc<region::ScopeTree>,\n+    expr_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<region::Scope>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s)\n+            self.region_scope_tree.yield_in_scope(s).and_then(|(span, expr_count)| {\n+                // If we are recording an expression that is the last yield\n+                // in the scope, or that has a postorder CFG index larger\n+                // than the one of all of the yields, then its value can't\n+                // be storage-live (and therefore live) at any of the yields.\n+                //\n+                // See the mega-comment at `yield_in_scope` for a proof.\n+                if expr_count >= self.expr_count {\n+                    Some(span)\n+                } else {\n+                    None\n+                }\n+            })\n         });\n \n         if let Some(span) = live_across_yield {\n@@ -60,9 +73,14 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n         fcx,\n         types: FxHashMap(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+        expr_count: 0,\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n+    // Check that we visited the same amount of expressions and the RegionResolutionVisitor\n+    let region_expr_count = visitor.region_scope_tree.body_expr_count(body_id).unwrap();\n+    assert_eq!(region_expr_count, visitor.expr_count);\n+\n     let mut types: Vec<_> = visitor.types.drain().collect();\n \n     // Sort types by insertion order\n@@ -82,30 +100,34 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n    }\n }\n \n+// This visitor has to have the same visit_expr calls as RegionResolutionVisitor in\n+// librustc/middle/region.rs since `expr_count` is compared against the results\n+// there.\n impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_body(&mut self, _body: &'tcx Body) {\n-        // Closures inside are not considered part of the generator interior\n-    }\n-\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None);\n         }\n \n+        self.expr_count += 1;\n+\n         intravisit::walk_pat(self, pat);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        intravisit::walk_expr(self, expr);\n+\n+        self.expr_count += 1;\n+\n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n-\n-        intravisit::walk_expr(self, expr);\n     }\n }"}, {"sha": "df1a1dcebe60608cd2831a32e339c50c2d1fe15b", "filename": "src/test/run-pass/generator/borrow-in-tail-expr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    let _a = || {\n+        yield;\n+        let a = String::new();\n+        a.len()\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "df00329799e96e68aae4a2adc4318202c18e94a2", "filename": "src/test/run-pass/generator/yield-in-args-rev.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a borrow that occurs after a yield in the same\n+// argument list is not treated as live across the yield by\n+// type-checking.\n+\n #![feature(generators)]\n \n fn foo(_a: (), _b: &bool) {}\n \n-// Some examples that probably *could* be accepted, but which we reject for now.\n-\n fn bar() {\n     || {\n         let b = true;\n-        foo(yield, &b); //~ ERROR\n+        foo(yield, &b);\n     };\n }\n ", "previous_filename": "src/test/ui/generator/yield-in-args-rev.rs"}, {"sha": "d68007be05c881844ad46a737c965c2f80e02943", "filename": "src/test/run-pass/generator/yield-in-box.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that box-statements with yields in them work.\n+\n+#![feature(generators, box_syntax)]\n+\n+fn main() {\n+    let x = 0i32;\n+    || {\n+        let y = 2u32;\n+        {\n+            let _t = box (&x, yield 0, &y);\n+        }\n+        match box (&x, yield 0, &y) {\n+            _t => {}\n+        }\n+    };\n+}"}, {"sha": "a1f110accc100cc56ea9cf21280dd74df7ef16b7", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/870483a57f9e3e1daee6543a4ace2cf875b74541/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=870483a57f9e3e1daee6543a4ace2cf875b74541", "patch": "@@ -9,15 +9,15 @@ error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not s\n    = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:26:17: 30:6 a:&std::cell::Cell<i32> _]`\n    = note: required by `main::assert_send`\n \n-error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n   --> $DIR/not-send-sync.rs:19:5\n    |\n 19 |     assert_sync(|| {\n    |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n    |\n-   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n-   = note: required because it appears within the type `((), std::cell::Cell<i32>)`\n-   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n+   = note: required because it appears within the type `(std::cell::Cell<i32>, ())`\n+   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n    = note: required by `main::assert_sync`\n \n error: aborting due to 2 previous errors"}, {"sha": "157f896820906fac6b5891061f6c080cf165f87d", "filename": "src/test/ui/generator/yield-in-args-rev.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01c65cb15ac57bfdc91613a4f6032ecc76c402a3/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01c65cb15ac57bfdc91613a4f6032ecc76c402a3/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr?ref=01c65cb15ac57bfdc91613a4f6032ecc76c402a3", "patch": "@@ -1,10 +0,0 @@\n-error[E0626]: borrow may still be in use when generator yields\n-  --> $DIR/yield-in-args-rev.rs:20:21\n-   |\n-20 |         foo(yield, &b); //~ ERROR\n-   |             -----   ^\n-   |             |\n-   |             possible yield occurs here\n-\n-error: aborting due to previous error\n-"}]}