{"sha": "7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "node_id": "C_kwDOAAsO6NoAKDdhNzA0ZjJjYzcyOGQ2NWNhMjliMThiM2U2MTdiMzVjMjk2NGZjZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T12:19:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T12:19:14Z"}, "message": "Auto merge of #13147 - lowr:fix/dyn-ty-inherent-methods, r=Veykril\n\nfix: handle trait methods as inherent methods for trait-related types\n\nFixes #10677\n\nWhen resolving methods for trait object types and placeholder types that are bounded by traits, we need to count the methods of the trait and its super traits as inherent methods. This matters because these trait methods have higher priority than the other traits' methods.\n\nRelevant code in rustc: [`assemble_inherent_candidates_from_object()`](https://github.com/rust-lang/rust/blob/0631ea5d73f4a3199c776687b12c20c50a91f0d2/compiler/rustc_typeck/src/check/method/probe.rs#L783-L792) for trait object types, [`assemble_inherent_candidates_from_param()`](https://github.com/rust-lang/rust/blob/0631ea5d73f4a3199c776687b12c20c50a91f0d2/compiler/rustc_typeck/src/check/method/probe.rs#L838-L847) for placeholder types. Notice the second arg of `push_candidate()` is `is_inherent`.", "tree": {"sha": "7e00f490d08d226d2df5c8de73c7669073997c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e00f490d08d226d2df5c8de73c7669073997c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "html_url": "https://github.com/rust-lang/rust/commit/7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a704f2cc728d65ca29b18b3e617b35c2964fcdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38dfe55365cfbc787db917b2c423942d607775e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38dfe55365cfbc787db917b2c423942d607775e", "html_url": "https://github.com/rust-lang/rust/commit/e38dfe55365cfbc787db917b2c423942d607775e"}, {"sha": "484d5b6e70e30e3e2b1714c9dcf641bb47f01b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/484d5b6e70e30e3e2b1714c9dcf641bb47f01b7c", "html_url": "https://github.com/rust-lang/rust/commit/484d5b6e70e30e3e2b1714c9dcf641bb47f01b7c"}], "stats": {"total": 107, "additions": 94, "deletions": 13}, "files": [{"sha": "dbf2750032074b76500605929db7c232a6360b06", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7a704f2cc728d65ca29b18b3e617b35c2964fcdc/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a704f2cc728d65ca29b18b3e617b35c2964fcdc/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "patch": "@@ -914,22 +914,10 @@ fn iterate_trait_method_candidates(\n     let db = table.db;\n     let env = table.trait_env.clone();\n     let self_is_array = matches!(self_ty.kind(Interner), chalk_ir::TyKind::Array(..));\n-    // if ty is `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait =\n-        self_ty.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.kind(Interner), TyKind::Placeholder(_))\n-        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        .then(|| {\n-            env.traits_in_scope_from_clauses(self_ty.clone())\n-                .flat_map(|t| all_super_traits(db.upcast(), t))\n-        })\n-        .into_iter()\n-        .flatten();\n-    let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     let canonical_self_ty = table.canonicalize(self_ty.clone()).value;\n \n-    'traits: for t in traits {\n+    'traits: for &t in traits_in_scope {\n         let data = db.trait_data(t);\n \n         // Traits annotated with `#[rustc_skip_array_during_method_dispatch]` are skipped during\n@@ -979,6 +967,43 @@ fn iterate_inherent_methods(\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n+\n+    // For trait object types and placeholder types with trait bounds, the methods of the trait and\n+    // its super traits are considered inherent methods. This matters because these methods have\n+    // higher priority than the other traits' methods, which would be considered in\n+    // `iterate_trait_method_candidates()` only after this function.\n+    match self_ty.kind(Interner) {\n+        TyKind::Placeholder(_) => {\n+            let env = table.trait_env.clone();\n+            let traits = env\n+                .traits_in_scope_from_clauses(self_ty.clone())\n+                .flat_map(|t| all_super_traits(db.upcast(), t));\n+            iterate_inherent_trait_methods(\n+                self_ty,\n+                table,\n+                name,\n+                receiver_ty,\n+                receiver_adjustments.clone(),\n+                callback,\n+                traits,\n+            )?;\n+        }\n+        TyKind::Dyn(_) => {\n+            let principal_trait = self_ty.dyn_trait().unwrap();\n+            let traits = all_super_traits(db.upcast(), principal_trait);\n+            iterate_inherent_trait_methods(\n+                self_ty,\n+                table,\n+                name,\n+                receiver_ty,\n+                receiver_adjustments.clone(),\n+                callback,\n+                traits.into_iter(),\n+            )?;\n+        }\n+        _ => {}\n+    }\n+\n     let def_crates = match def_crates(db, self_ty, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n@@ -1020,6 +1045,28 @@ fn iterate_inherent_methods(\n     }\n     return ControlFlow::Continue(());\n \n+    fn iterate_inherent_trait_methods(\n+        self_ty: &Ty,\n+        table: &mut InferenceTable<'_>,\n+        name: Option<&Name>,\n+        receiver_ty: Option<&Ty>,\n+        receiver_adjustments: Option<ReceiverAdjustments>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        traits: impl Iterator<Item = TraitId>,\n+    ) -> ControlFlow<()> {\n+        let db = table.db;\n+        for t in traits {\n+            let data = db.trait_data(t);\n+            for &(_, item) in data.items.iter() {\n+                // We don't pass `visible_from_module` as all trait items should be visible.\n+                if is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                    callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+                }\n+            }\n+        }\n+        ControlFlow::Continue(())\n+    }\n+\n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n         self_ty: &Ty,"}, {"sha": "ac8edb841a580322b18b5a47b9eb39ae174b3a49", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a704f2cc728d65ca29b18b3e617b35c2964fcdc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a704f2cc728d65ca29b18b3e617b35c2964fcdc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=7a704f2cc728d65ca29b18b3e617b35c2964fcdc", "patch": "@@ -1218,6 +1218,40 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn dyn_trait_method_priority() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo(a: &dyn Trait) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_priority_for_placeholder_type() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo<T: Trait>(a: &T) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn autoderef_visibility_field() {\n     check("}]}