{"sha": "e49a29933be3bd988ccb75b053f480d9c99a7ff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0OWEyOTkzM2JlM2JkOTg4Y2NiNzViMDUzZjQ4MGQ5Yzk5YTdmZjU=", "commit": {"author": {"name": "Ricky", "email": "Ricky@Hosfelt.io", "date": "2020-09-01T20:26:59Z"}, "committer": {"name": "Ricky", "email": "Ricky@Hosfelt.io", "date": "2020-09-01T20:26:59Z"}, "message": "Working map_err_ignore lint", "tree": {"sha": "2420561679661db4ad90efb2782d889262af4b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2420561679661db4ad90efb2782d889262af4b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e49a29933be3bd988ccb75b053f480d9c99a7ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e49a29933be3bd988ccb75b053f480d9c99a7ff5", "html_url": "https://github.com/rust-lang/rust/commit/e49a29933be3bd988ccb75b053f480d9c99a7ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e49a29933be3bd988ccb75b053f480d9c99a7ff5/comments", "author": null, "committer": null, "parents": [{"sha": "066f105d679d2c120ad92baf19a10337c446e794", "url": "https://api.github.com/repos/rust-lang/rust/commits/066f105d679d2c120ad92baf19a10337c446e794", "html_url": "https://github.com/rust-lang/rust/commit/066f105d679d2c120ad92baf19a10337c446e794"}], "stats": {"total": 113, "additions": 113, "deletions": 0}, "files": [{"sha": "8e80779377bcd92529c53aa629cbfabbae68078b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e49a29933be3bd988ccb75b053f480d9c99a7ff5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e49a29933be3bd988ccb75b053f480d9c99a7ff5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e49a29933be3bd988ccb75b053f480d9c99a7ff5", "patch": "@@ -230,6 +230,7 @@ mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n mod map_clone;\n+mod map_err_ignore;\n mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -624,6 +625,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n+        &map_err_ignore::MAP_ERR_IGNORE,\n         &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -916,6 +918,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n     store.register_late_pass(|| box methods::Methods);\n     store.register_late_pass(|| box map_clone::MapClone);\n+    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n     store.register_late_pass(|| box types::LetUnitValue);\n     store.register_late_pass(|| box types::UnitCmp);\n@@ -1327,6 +1330,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n@@ -1534,6 +1538,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&map_err_ignore::MAP_ERR_IGNORE), \n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),"}, {"sha": "c63c201a9f35ad4a632478e6100588436b95bd51", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e49a29933be3bd988ccb75b053f480d9c99a7ff5/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e49a29933be3bd988ccb75b053f480d9c99a7ff5/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=e49a29933be3bd988ccb75b053f480d9c99a7ff5", "patch": "@@ -0,0 +1,108 @@\n+use crate::utils::span_lint_and_sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, CaptureBy, PatKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// **Why is this bad?** This map_err throws away the original error rather than allowing the enum to bubble the original error\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// enum Errors {\n+    ///    Ignore\n+    ///}\n+    ///fn main() -> Result<(), Errors> {\n+    ///    \n+    ///    let x = u32::try_from(-123_i32);\n+    ///\n+    ///    println!(\"{:?}\", x.map_err(|_| Errors::Ignore));\n+    ///\n+    ///    Ok(())\n+    ///}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// enum Errors {\n+    ///    WithContext(TryFromIntError)\n+    ///}\n+    ///fn main() -> Result<(), Errors> {\n+    ///    \n+    ///    let x = u32::try_from(-123_i32);\n+    ///\n+    ///    println!(\"{:?}\", x.map_err(|e| Errors::WithContext(e)));\n+    ///\n+    ///    Ok(())\n+    ///}\n+    /// ```\n+    pub MAP_ERR_IGNORE,\n+    style,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n+declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n+    // do not try to lint if this is from a macro or desugaring \n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+\n+        // check if this is a method call (e.g. x.foo())\n+        if let ExprKind::MethodCall(ref method, _t_span, ref args, _) = e.kind {\n+            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1] Enum::Variant[2]))\n+            if method.ident.as_str() == \"map_err\" && args.len() == 2 {\n+                // make sure the first argument is a closure, and grab the CaptureRef, body_id, and body_span fields\n+                if let ExprKind::Closure(capture, _, body_id, body_span, _) = args[1].kind {  \n+                    // check if this is by Reference (meaning there's no move statement)\n+                    if capture == CaptureBy::Ref { \n+                        // Get the closure body to check the parameters and values \n+                        let closure_body = cx.tcx.hir().body(body_id);\n+                        // make sure there's only one parameter (`|_|`)\n+                        if closure_body.params.len() == 1 {          \n+                            // make sure that parameter is the wild token (`_`)                  \n+                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n+                                // Check the value of the closure to see if we can build the enum we are throwing away the error for\n+                                // make sure this is a Path\n+                                if let ExprKind::Path(q_path) = &closure_body.value.kind {\n+                                    // this should be a resolved path, only keep the path field\n+                                    if let QPath::Resolved(_, path) = q_path {\n+                                        // finally get the idents for each path segment collect them as a string and join them with the path separator (\"::\"\")\n+                                        let closure_fold: String = path.segments.iter().map(|x| x.ident.as_str().to_string()).collect::<Vec<String>>().join(\"::\");\n+                                        //Span the body of the closure (the |...| bit) and suggest the fix by taking the error and encapsulating it in the enum \n+                                        span_lint_and_sugg(\n+                                            cx,\n+                                            MAP_ERR_IGNORE,\n+                                            body_span,\n+                                            \"`map_err` has thrown away the original error\",\n+                                            \"Allow the error enum to encapsulate the original error\",\n+                                            format!(\"|e| {}(e)\", closure_fold),\n+                                            Applicability::HasPlaceholders,\n+                                        ); \n+                                    }\n+                                } else {\n+                                    //If we cannot build the enum in a human readable way just suggest not throwing way the error\n+                                    span_lint_and_sugg(\n+                                        cx,\n+                                        MAP_ERR_IGNORE,\n+                                        body_span,\n+                                        \"`map_err` has thrown away the original error\",\n+                                        \"Allow the error enum to encapsulate the original error\",\n+                                        \"|e|\".to_string(),\n+                                        Applicability::HasPlaceholders,\n+                                    ); \n+                                }\n+                            }\n+                        }\n+                    }  \n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}]}