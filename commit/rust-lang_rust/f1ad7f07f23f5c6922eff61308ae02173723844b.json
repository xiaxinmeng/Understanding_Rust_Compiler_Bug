{"sha": "f1ad7f07f23f5c6922eff61308ae02173723844b", "node_id": "C_kwDOAAsO6NoAKGYxYWQ3ZjA3ZjIzZjVjNjkyMmVmZjYxMzA4YWUwMjE3MzcyMzg0NGI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-02-22T09:35:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-22T09:35:07Z"}, "message": "Rollup merge of #108110 - compiler-errors:new-solver-less-infcx, r=lcnr\n\nMove some `InferCtxt` methods to `EvalCtxt` in new solver\n\nMoving towards eventually making the `InferCtxt` within `EvalCtxt` private, so that we make sure not to do anything strange in the solver. This doesn't finish this work yet, just gets it started.\n\nr? ``@lcnr``", "tree": {"sha": "73b0c62bf9a08ca1906d4d5afcbedfc17fb26574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73b0c62bf9a08ca1906d4d5afcbedfc17fb26574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1ad7f07f23f5c6922eff61308ae02173723844b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj9eHLCRBK7hj4Ov3rIwAAU6wIAEwbDU7Kb2kBa2J3SwyBOkXq\ni5KqZxq3Pqp5f6qMHMisnEpq03oNH7y49HNOv9z7R2F4xv8T5z+feENRV00lqPVZ\nFoPPOS5pBO6Tqg0FK/FjXfZr+rPTNBYAG7xmB3Oj5P6AOB2d2CAyu4/GMzMFwjgN\n9Qc9Zb7Bxb2IQWV32l+lX/pwD/HWuc5k9sKUIF2g8xWkRNmaGEK7MV77eYC7IQQ4\ndeUKZhvJuMGdObqrFPxrEIE9jyldXYOqYmNOQ7fQGB6uSYc+jwkwEacJE4yDFYJz\nXTq0YF73Efdajpksj5U7n0PwS1r8SAOUQRr/X2kSSgJgFzdNBICfsfTMCCDGB2I=\n=zdcN\n-----END PGP SIGNATURE-----\n", "payload": "tree 73b0c62bf9a08ca1906d4d5afcbedfc17fb26574\nparent f9216b75646cde0c4c69ae00232778a47fc893d3\nparent 7596998d1cea422fa66f18529941da7d5b2ea20c\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1677058507 +0100\ncommitter GitHub <noreply@github.com> 1677058507 +0100\n\nRollup merge of #108110 - compiler-errors:new-solver-less-infcx, r=lcnr\n\nMove some `InferCtxt` methods to `EvalCtxt` in new solver\n\nMoving towards eventually making the `InferCtxt` within `EvalCtxt` private, so that we make sure not to do anything strange in the solver. This doesn't finish this work yet, just gets it started.\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ad7f07f23f5c6922eff61308ae02173723844b", "html_url": "https://github.com/rust-lang/rust/commit/f1ad7f07f23f5c6922eff61308ae02173723844b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1ad7f07f23f5c6922eff61308ae02173723844b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9216b75646cde0c4c69ae00232778a47fc893d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9216b75646cde0c4c69ae00232778a47fc893d3", "html_url": "https://github.com/rust-lang/rust/commit/f9216b75646cde0c4c69ae00232778a47fc893d3"}, {"sha": "7596998d1cea422fa66f18529941da7d5b2ea20c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7596998d1cea422fa66f18529941da7d5b2ea20c", "html_url": "https://github.com/rust-lang/rust/commit/7596998d1cea422fa66f18529941da7d5b2ea20c"}], "stats": {"total": 454, "additions": 228, "deletions": 226}, "files": [{"sha": "d55aebf1a269612d2f212425ec0ad961fa77cdfd", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -1,6 +1,5 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n-use super::infcx_ext::InferCtxtExt;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n@@ -206,7 +205,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, G>,\n     ) -> Vec<Candidate<'tcx>> {\n-        debug_assert_eq!(goal, self.infcx.resolve_vars_if_possible(goal));\n+        debug_assert_eq!(goal, self.resolve_vars_if_possible(goal));\n \n         // HACK: `_: Trait` is ambiguous, because it may be satisfied via a builtin rule,\n         // object bound, alias bound, etc. We are unable to determine this until we can at\n@@ -250,25 +249,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.infcx.probe(|_| {\n-            let normalized_ty = self.infcx.next_ty_infer();\n+        self.probe(|this| {\n+            let normalized_ty = this.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match self.evaluate_goal(normalizes_to_goal) {\n+            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n                 Ok((_, certainty)) => certainty,\n                 Err(NoSolution) => return,\n             };\n-            let normalized_ty = self.infcx.resolve_vars_if_possible(normalized_ty);\n+            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n+            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n             for mut normalized_candidate in normalized_candidates {\n                 normalized_candidate.result =\n                     normalized_candidate.result.unchecked_map(|mut response| {"}, {"sha": "67addd732d0adfa4dcfc3cba641efe34003119d0", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -0,0 +1,172 @@\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::at::ToTrace;\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::ty::{self, ir::TypeVisitor, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable};\n+use rustc_span::DUMMY_SP;\n+use std::ops::ControlFlow;\n+\n+use super::search_graph::SearchGraph;\n+use super::Goal;\n+\n+pub struct EvalCtxt<'a, 'tcx> {\n+    // FIXME: should be private.\n+    pub(super) infcx: &'a InferCtxt<'tcx>,\n+\n+    pub(super) var_values: CanonicalVarValues<'tcx>,\n+\n+    pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n+\n+    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    pub in_projection_eq_hack: bool,\n+}\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n+        self.infcx.probe(|_| f(self))\n+    }\n+\n+    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    pub(super) fn next_ty_infer(&self) -> Ty<'tcx> {\n+        self.infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::MiscVariable,\n+            span: DUMMY_SP,\n+        })\n+    }\n+\n+    pub(super) fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.infcx.next_const_var(\n+            ty,\n+            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n+        )\n+    }\n+\n+    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n+    ///\n+    /// This is the case if the `term` is an inference variable in the innermost universe\n+    /// and does not occur in any other part of the predicate.\n+    pub(super) fn term_is_fully_unconstrained(\n+        &self,\n+        goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ) -> bool {\n+        let term_is_infer = match goal.predicate.term.unpack() {\n+            ty::TermKind::Ty(ty) => {\n+                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n+                    match self.infcx.probe_ty_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == self.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            ty::TermKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n+                    match self.infcx.probe_const_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == self.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+\n+        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n+        struct ContainsTerm<'tcx> {\n+            term: ty::Term<'tcx>,\n+        }\n+        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'tcx> {\n+            type BreakTy = ();\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if t.needs_infer() {\n+                    if ty::Term::from(t) == self.term {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        t.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::Continue(())\n+                }\n+            }\n+\n+            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if c.needs_infer() {\n+                    if ty::Term::from(c) == self.term {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        c.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::Continue(())\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+\n+        term_is_infer\n+            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n+            && goal.param_env.visit_with(&mut visitor).is_continue()\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                obligations.into_iter().map(|o| o.into()).collect()\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    pub(super) fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.infcx.instantiate_binder_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            value,\n+        )\n+    }\n+\n+    pub(super) fn instantiate_binder_with_placeholders<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.infcx.instantiate_binder_with_placeholders(value)\n+    }\n+\n+    pub(super) fn resolve_vars_if_possible<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx.resolve_vars_if_possible(value)\n+    }\n+\n+    pub(super) fn fresh_substs_for_item(&self, def_id: DefId) -> ty::SubstsRef<'tcx> {\n+        self.infcx.fresh_substs_for_item(DUMMY_SP, def_id)\n+    }\n+\n+    pub(super) fn universe(&self) -> ty::UniverseIndex {\n+        self.infcx.universe()\n+    }\n+}"}, {"sha": "06570e1f4b41cd600615f1507e023378c7cb3125", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f9216b75646cde0c4c69ae00232778a47fc893d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9216b75646cde0c4c69ae00232778a47fc893d3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=f9216b75646cde0c4c69ae00232778a47fc893d3", "patch": "@@ -1,77 +0,0 @@\n-use rustc_infer::infer::at::ToTrace;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::ObligationCause;\n-use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_span::DUMMY_SP;\n-\n-use super::Goal;\n-\n-/// Methods used inside of the canonical queries of the solver.\n-///\n-/// Most notably these do not care about diagnostics information.\n-/// If you find this while looking for methods to use outside of the\n-/// solver, you may look at the implementation of these method for\n-/// help.\n-pub(super) trait InferCtxtExt<'tcx> {\n-    fn next_ty_infer(&self) -> Ty<'tcx>;\n-    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx>;\n-\n-    fn eq<T: ToTrace<'tcx>>(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        lhs: T,\n-        rhs: T,\n-    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n-\n-    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n-        &self,\n-        value: ty::Binder<'tcx, T>,\n-    ) -> T;\n-}\n-\n-impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n-    fn next_ty_infer(&self) -> Ty<'tcx> {\n-        self.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::MiscVariable,\n-            span: DUMMY_SP,\n-        })\n-    }\n-    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n-        self.next_const_var(\n-            ty,\n-            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n-        )\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n-    fn eq<T: ToTrace<'tcx>>(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        lhs: T,\n-        rhs: T,\n-    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n-        self.at(&ObligationCause::dummy(), param_env)\n-            .eq(lhs, rhs)\n-            .map(|InferOk { value: (), obligations }| {\n-                obligations.into_iter().map(|o| o.into()).collect()\n-            })\n-            .map_err(|e| {\n-                debug!(?e, \"failed to equate\");\n-                NoSolution\n-            })\n-    }\n-\n-    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n-        &self,\n-        value: ty::Binder<'tcx, T>,\n-    ) -> T {\n-        self.instantiate_binder_with_fresh_vars(\n-            DUMMY_SP,\n-            LateBoundRegionConversionTime::HigherRankedType,\n-            value,\n-        )\n-    }\n-}"}, {"sha": "c080f7e59fa225a1ad65b3ac84654866b7371ce0", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -35,16 +35,15 @@ use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n+mod eval_ctxt;\n mod fulfill;\n-mod infcx_ext;\n mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n+pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-use self::infcx_ext::InferCtxtExt;\n-\n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n ///\n@@ -180,22 +179,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n     }\n }\n \n-struct EvalCtxt<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-\n-    search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-\n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    in_projection_eq_hack: bool,\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n     /// The entry point of the solver.\n     ///\n     /// This function deals with (coinductive) cycles, overflow, and caching\n@@ -427,7 +411,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let r = ecx.infcx.probe(|_| {\n+            let r = ecx.probe(|ecx| {\n                 let (_, certainty) = ecx.evaluate_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -462,10 +446,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.infcx.probe(|_| {\n+                candidates.push(self.probe(|this| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = self.infcx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    self.evaluate_all_and_make_canonical_response(nested_goals)\n+                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    this.evaluate_all_and_make_canonical_response(nested_goals)\n                 }));\n \n                 debug!(?candidates);\n@@ -481,7 +465,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.infcx.eq(goal.param_env, ct.ty(), ty)?;\n+        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n         self.evaluate_all_and_make_canonical_response(nested_goals)\n     }\n }"}, {"sha": "9f83bfa1ccb9bf6a97535471aa986c58f8860555", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly;\n-use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n@@ -13,12 +12,11 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::ty::{ir::TypeVisitor, ProjectionPredicate, TypeSuperVisitable};\n use rustc_middle::ty::{ToPredicate, TypeVisitable};\n use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n-use std::ops::ControlFlow;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n@@ -38,8 +36,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.infcx.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.infcx.next_const_infer(ct.ty()).into(),\n+                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n             };\n             let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n@@ -49,8 +47,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n             })?;\n \n-            let nested_eq_goals =\n-                self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n             let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n             self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n         }\n@@ -65,73 +62,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         result\n     }\n \n-    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n-    ///\n-    /// This is the case if the `term` is an inference variable in the innermost universe\n-    /// and does not occur in any other part of the predicate.\n-    fn term_is_fully_unconstrained(&self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) -> bool {\n-        let infcx = self.infcx;\n-        let term_is_infer = match goal.predicate.term.unpack() {\n-            ty::TermKind::Ty(ty) => {\n-                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n-                    match infcx.probe_ty_var(vid) {\n-                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == infcx.universe(),\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-            ty::TermKind::Const(ct) => {\n-                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n-                    match self.infcx.probe_const_var(vid) {\n-                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == infcx.universe(),\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-        };\n-\n-        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n-        struct ContainsTerm<'tcx> {\n-            term: ty::Term<'tcx>,\n-        }\n-        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'tcx> {\n-            type BreakTy = ();\n-            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if t.needs_infer() {\n-                    if ty::Term::from(t) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        t.super_visit_with(self)\n-                    }\n-                } else {\n-                    ControlFlow::Continue(())\n-                }\n-            }\n-\n-            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if c.needs_infer() {\n-                    if ty::Term::from(c) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        c.super_visit_with(self)\n-                    }\n-                } else {\n-                    ControlFlow::Continue(())\n-                }\n-            }\n-        }\n-\n-        let mut visitor = ContainsTerm { term: goal.predicate.term };\n-\n-        term_is_infer\n-            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n-            && goal.param_env.visit_with(&mut visitor).is_continue()\n-    }\n-\n     /// After normalizing the projection to `normalized_alias` with the given\n     /// `normalization_certainty`, constrain the inference variable `term` to it\n     /// and return a query response.\n@@ -145,7 +75,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         //\n         // It can however be ambiguous when the `normalized_alias` contains a projection.\n         let nested_goals = self\n-            .infcx\n             .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n             .expect(\"failed to unify with unconstrained term\");\n         let rhs_certainty =\n@@ -177,10 +106,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n-            ecx.infcx.probe(|_| {\n+            ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.infcx.eq(\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n@@ -215,11 +144,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n-        ecx.infcx.probe(|_| {\n-            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.probe(|ecx| {\n+            let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.infcx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n@@ -367,7 +296,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             let metadata_ty = match goal.predicate.self_ty().kind() {\n                 ty::Bool\n                 | ty::Char\n@@ -546,8 +475,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.infcx\n-            .probe(|_| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n     }\n }\n "}, {"sha": "6d1381bbf0c9f35c02c8a915f1df682c2f68ad32", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -3,11 +3,9 @@\n use std::iter;\n \n use super::assembly;\n-use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -45,12 +43,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n-        ecx.infcx.probe(|_| {\n-            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.probe(|ecx| {\n+            let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n             let mut nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n@@ -72,10 +70,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n         {\n             // FIXME: Constness and polarity\n-            ecx.infcx.probe(|_| {\n+            ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.infcx.eq(\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                let mut nested_goals = ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -118,7 +116,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n \n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n@@ -275,7 +273,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         if b_ty.is_ty_var() {\n             return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n         }\n-        ecx.infcx.probe(|_| {\n+        ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n                 // Trait upcasting, or `dyn Trait + Auto + 'a` -> `dyn Trait + 'b`\n                 (&ty::Dynamic(_, _, ty::Dyn), &ty::Dynamic(_, _, ty::Dyn)) => {\n@@ -318,7 +316,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.infcx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n                     ecx.evaluate_all_and_make_canonical_response(nested_goals)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n@@ -352,7 +350,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n                     nested_goals.push(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n@@ -371,7 +369,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n                     nested_goals.push(goal.with(\n@@ -411,7 +409,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         let mut unsize_dyn_to_principal = |principal: Option<ty::PolyExistentialTraitRef<'tcx>>| {\n-            ecx.infcx.probe(|_| -> Result<_, NoSolution> {\n+            ecx.probe(|ecx| -> Result<_, NoSolution> {\n                 // Require that all of the trait predicates from A match B, except for\n                 // the auto traits. We do this by constructing a new A type with B's\n                 // auto traits, and equating these types.\n@@ -431,7 +429,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n                 nested_obligations.push(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n@@ -482,16 +480,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn probe_and_evaluate_goal_for_constituent_tys(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n-        constituent_tys: impl Fn(&InferCtxt<'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n+        constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.probe(|_| {\n-            self.evaluate_all_and_make_canonical_response(\n-                constituent_tys(self.infcx, goal.predicate.self_ty())?\n+        self.probe(|this| {\n+            this.evaluate_all_and_make_canonical_response(\n+                constituent_tys(this, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            self.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                            this.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n                         )\n                     })\n                     .collect(),"}, {"sha": "2c13465d347c40b26d38e5e0dc8e4bbee1343980", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ad7f07f23f5c6922eff61308ae02173723844b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=f1ad7f07f23f5c6922eff61308ae02173723844b", "patch": "@@ -1,16 +1,18 @@\n use rustc_hir::{Movability, Mutability};\n-use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n+use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use crate::solve::EvalCtxt;\n+\n // Calculates the constituent types of a type for `auto trait` purposes.\n //\n // For types with an \"existential\" binder, i.e. generator witnesses, we also\n // instantiate the binder with placeholders eagerly.\n pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n-    let tcx = infcx.tcx;\n+    let tcx = ecx.tcx();\n     match *ty.kind() {\n         ty::Uint(_)\n         | ty::Int(_)\n@@ -53,9 +55,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n             Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n         }\n \n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n-        }\n+        ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n \n@@ -74,7 +74,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n }\n \n pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n     match *ty.kind() {\n@@ -113,18 +113,18 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n         ty::Tuple(tys) => Ok(tys.to_vec()),\n \n         ty::Adt(def, substs) => {\n-            let sized_crit = def.sized_constraint(infcx.tcx);\n+            let sized_crit = def.sized_constraint(ecx.tcx());\n             Ok(sized_crit\n                 .0\n                 .iter()\n-                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n+                .map(|ty| sized_crit.rebind(*ty).subst(ecx.tcx(), substs))\n                 .collect())\n         }\n     }\n }\n \n pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n     match *ty.kind() {\n@@ -165,17 +165,15 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         ty::Closure(_, substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n \n         ty::Generator(_, substs, Movability::Movable) => {\n-            if infcx.tcx.features().generator_clone {\n+            if ecx.tcx().features().generator_clone {\n                 let generator = substs.as_generator();\n                 Ok(vec![generator.tupled_upvars_ty(), generator.witness()])\n             } else {\n                 Err(NoSolution)\n             }\n         }\n \n-        ty::GeneratorWitness(types) => {\n-            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n-        }\n+        ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n     }"}]}