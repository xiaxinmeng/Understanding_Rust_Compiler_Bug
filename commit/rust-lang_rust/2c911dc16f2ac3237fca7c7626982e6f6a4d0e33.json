{"sha": "2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "node_id": "C_kwDOAAsO6NoAKDJjOTExZGMxNmYyYWMzMjM3ZmNhN2M3NjI2OTgyZTZmNmE0ZDBlMzM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T05:08:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T08:37:29Z"}, "message": "Avoid unnecessary 1-tuples in derived code.", "tree": {"sha": "a0ebfd913ceff8b7b49795bdcd32724b160c87a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0ebfd913ceff8b7b49795bdcd32724b160c87a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "html_url": "https://github.com/rust-lang/rust/commit/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7b1d31a9f358747221e8eb9986bb8303d5d6586", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b1d31a9f358747221e8eb9986bb8303d5d6586", "html_url": "https://github.com/rust-lang/rust/commit/a7b1d31a9f358747221e8eb9986bb8303d5d6586"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "f3e1176cab3de8e91c9f2d473a6a6b2f1f2fc302", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "patch": "@@ -1239,7 +1239,11 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat_tuple(span, subpats);\n+                let single_pat = if subpats.len() == 1 {\n+                    subpats.pop().unwrap()\n+                } else {\n+                    cx.pat_tuple(span, subpats)\n+                };\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n@@ -1471,7 +1475,11 @@ impl<'a> MethodDef<'a> {\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            let match_arg = if self_args.len() == 1 {\n+                self_args.pop().unwrap()\n+            } else {\n+                cx.expr(span, ast::ExprKind::Tup(self_args))\n+            };\n             BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n     }"}, {"sha": "260d9de867087696af0675fb36d1dab22c2aa68c", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "patch": "@@ -10,7 +10,7 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc14 = {{.*}}, align 2\n+// CHECK: @alloc12 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used"}, {"sha": "763b39a212a58c69b51adcd5e28e38ceaf3ba5e2", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "patch": "@@ -554,8 +554,8 @@ enum Enum1 {\n impl ::core::clone::Clone for Enum1 {\n     #[inline]\n     fn clone(&self) -> Enum1 {\n-        match (&*self,) {\n-            (&Enum1::Single { x: ref __self_0 },) =>\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } =>\n                 Enum1::Single { x: ::core::clone::Clone::clone(&*__self_0) },\n         }\n     }\n@@ -564,8 +564,8 @@ impl ::core::clone::Clone for Enum1 {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Enum1::Single { x: ref __self_0 },) =>\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } =>\n                 ::core::fmt::Formatter::debug_struct_field1_finish(f,\n                     \"Single\", \"x\", &&*__self_0),\n         }\n@@ -575,8 +575,8 @@ impl ::core::fmt::Debug for Enum1 {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Enum1::Single { x: ref __self_0 },) => {\n+        match &*self {\n+            &Enum1::Single { x: ref __self_0 } => {\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n         }\n@@ -669,10 +669,10 @@ impl ::core::marker::Copy for Fieldless { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Fieldless::A,) => ::core::fmt::Formatter::write_str(f, \"A\"),\n-            (&Fieldless::B,) => ::core::fmt::Formatter::write_str(f, \"B\"),\n-            (&Fieldless::C,) => ::core::fmt::Formatter::write_str(f, \"C\"),\n+        match &*self {\n+            &Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n+            &Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n+            &Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n         }\n     }\n }\n@@ -686,7 +686,7 @@ impl ::core::default::Default for Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n+        match &*self {\n             _ => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state)\n@@ -775,13 +775,13 @@ impl ::core::marker::Copy for Mixed { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Mixed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Mixed::P,) => ::core::fmt::Formatter::write_str(f, \"P\"),\n-            (&Mixed::Q,) => ::core::fmt::Formatter::write_str(f, \"Q\"),\n-            (&Mixed::R(ref __self_0),) =>\n+        match &*self {\n+            &Mixed::P => ::core::fmt::Formatter::write_str(f, \"P\"),\n+            &Mixed::Q => ::core::fmt::Formatter::write_str(f, \"Q\"),\n+            &Mixed::R(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n                     &&*__self_0),\n-            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) =>\n+            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } =>\n                 ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n                     \"d1\", &&*__self_0, \"d2\", &&*__self_1),\n         }\n@@ -797,13 +797,13 @@ impl ::core::default::Default for Mixed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Mixed::R(ref __self_0),) => {\n+        match &*self {\n+            &Mixed::R(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) => {\n+            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state);\n@@ -943,12 +943,12 @@ enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n impl ::core::clone::Clone for Fielded {\n     #[inline]\n     fn clone(&self) -> Fielded {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) =>\n+        match &*self {\n+            &Fielded::X(ref __self_0) =>\n                 Fielded::X(::core::clone::Clone::clone(&*__self_0)),\n-            (&Fielded::Y(ref __self_0),) =>\n+            &Fielded::Y(ref __self_0) =>\n                 Fielded::Y(::core::clone::Clone::clone(&*__self_0)),\n-            (&Fielded::Z(ref __self_0),) =>\n+            &Fielded::Z(ref __self_0) =>\n                 Fielded::Z(::core::clone::Clone::clone(&*__self_0)),\n         }\n     }\n@@ -957,14 +957,14 @@ impl ::core::clone::Clone for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fielded {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) =>\n+        match &*self {\n+            &Fielded::X(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n                     &&*__self_0),\n-            (&Fielded::Y(ref __self_0),) =>\n+            &Fielded::Y(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n                     &&*__self_0),\n-            (&Fielded::Z(ref __self_0),) =>\n+            &Fielded::Z(ref __self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n                     &&*__self_0),\n         }\n@@ -974,18 +974,18 @@ impl ::core::fmt::Debug for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Fielded::X(ref __self_0),) => {\n+        match &*self {\n+            &Fielded::X(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Fielded::Y(ref __self_0),) => {\n+            &Fielded::Y(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            (&Fielded::Z(ref __self_0),) => {\n+            &Fielded::Z(ref __self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)"}]}