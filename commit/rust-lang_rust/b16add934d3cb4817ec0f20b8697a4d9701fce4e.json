{"sha": "b16add934d3cb4817ec0f20b8697a4d9701fce4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNmFkZDkzNGQzY2I0ODE3ZWMwZjIwYjg2OTdhNGQ5NzAxZmNlNGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-22T15:45:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-22T15:45:50Z"}, "message": "Merge #7310 #7395\n\n7310: Add assist: add lifetime to type r=matklad a=bnjjj\n\nclose #7200 \n\n7395: Obtain `ModuleId`'s `DefMap` through a method r=jonas-schievink a=jonas-schievink\n\nOnce `ModuleId` can represent modules inside block expressions, this will be required in order to obtain the correct `DefMap`. Otherwise existing code might use a `LocalModuleId` from the wrong `DefMap` and cause a panic.\r\n\r\nbors r+\n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "ed30dd2086b20340d4f45242a3d6c6ac6787dc92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed30dd2086b20340d4f45242a3d6c6ac6787dc92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b16add934d3cb4817ec0f20b8697a4d9701fce4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgCvMvCRBK7hj4Ov3rIwAAdHIIADTREgTW3fjYdrqfnAoSYtp1\n5uWsu1IWFGncBgRsRAJhIgk8CK3oVFeGg3v37gxr8kLPm509jE4iPUGVoIF6JQeE\nbJbylwWalnjyLGlwiIazrxNs+rXxIOpSR0olfyXcoFfgvwnKcLO1Lv60kyYJBWgs\nkW5apFDkO9LfJ1nlTohNV9GwXSkRHgl+0sjXk7k5bgCTMYsh/DCRCsUbZ7110gIc\nTeQe57dwpxMYEQJynCBzoS3DK22X68ObaIHYsozr2pblQ0+gkgzQSvUgzCkZu6vl\n8ZGUZo9Ca55kznhkWFY5iEyo7u15HgsUbcpMDH5mlCk3cPHGYnAnzEzCGL/gvtU=\n=vLfa\n-----END PGP SIGNATURE-----\n", "payload": "tree ed30dd2086b20340d4f45242a3d6c6ac6787dc92\nparent 0c37b3a0fc6d62cd1401320c53feb51a58ea09a6\nparent 06f1c8f5a10f0114cbd94111312ea58d59570efc\nparent ce29730bc773a27eaeaae7fa4122563df3b253b6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611330350 +0000\ncommitter GitHub <noreply@github.com> 1611330350 +0000\n\nMerge #7310 #7395\n\n7310: Add assist: add lifetime to type r=matklad a=bnjjj\n\nclose #7200 \n\n7395: Obtain `ModuleId`'s `DefMap` through a method r=jonas-schievink a=jonas-schievink\n\nOnce `ModuleId` can represent modules inside block expressions, this will be required in order to obtain the correct `DefMap`. Otherwise existing code might use a `LocalModuleId` from the wrong `DefMap` and cause a panic.\r\n\r\nbors r+\n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b16add934d3cb4817ec0f20b8697a4d9701fce4e", "html_url": "https://github.com/rust-lang/rust/commit/b16add934d3cb4817ec0f20b8697a4d9701fce4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b16add934d3cb4817ec0f20b8697a4d9701fce4e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c37b3a0fc6d62cd1401320c53feb51a58ea09a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c37b3a0fc6d62cd1401320c53feb51a58ea09a6", "html_url": "https://github.com/rust-lang/rust/commit/0c37b3a0fc6d62cd1401320c53feb51a58ea09a6"}, {"sha": "06f1c8f5a10f0114cbd94111312ea58d59570efc", "url": "https://api.github.com/repos/rust-lang/rust/commits/06f1c8f5a10f0114cbd94111312ea58d59570efc", "html_url": "https://github.com/rust-lang/rust/commit/06f1c8f5a10f0114cbd94111312ea58d59570efc"}, {"sha": "ce29730bc773a27eaeaae7fa4122563df3b253b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce29730bc773a27eaeaae7fa4122563df3b253b6", "html_url": "https://github.com/rust-lang/rust/commit/ce29730bc773a27eaeaae7fa4122563df3b253b6"}], "stats": {"total": 324, "additions": 292, "deletions": 32}, "files": [{"sha": "c1603e9722a33fdcf8bbb65c453972b3db0eab80", "filename": "crates/assists/src/handlers/add_lifetime_to_type.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -0,0 +1,228 @@\n+use ast::FieldList;\n+use syntax::ast::{self, AstNode, GenericParamsOwner, NameOwner, RefType, Type};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: add_lifetime_to_type\n+//\n+// Adds a new lifetime to a struct, enum or union.\n+//\n+// ```\n+// struct Point {\n+//     x: &$0u32,\n+//     y: u32,\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Point<'a> {\n+//     x: &'a u32,\n+//     y: u32,\n+// }\n+// ```\n+pub(crate) fn add_lifetime_to_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ref_type_focused = ctx.find_node_at_offset::<ast::RefType>()?;\n+    if ref_type_focused.lifetime().is_some() {\n+        return None;\n+    }\n+\n+    let node = ctx.find_node_at_offset::<ast::AdtDef>()?;\n+    let has_lifetime = node\n+        .generic_param_list()\n+        .map(|gen_list| gen_list.lifetime_params().count() > 0)\n+        .unwrap_or_default();\n+\n+    if has_lifetime {\n+        return None;\n+    }\n+\n+    let ref_types = fetch_borrowed_types(&node)?;\n+    let target = node.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"add_lifetime_to_type\", AssistKind::Generate),\n+        \"Add lifetime`\",\n+        target,\n+        |builder| {\n+            match node.generic_param_list() {\n+                Some(gen_param) => {\n+                    if let Some(left_angle) = gen_param.l_angle_token() {\n+                        builder.insert(left_angle.text_range().end(), \"'a, \");\n+                    }\n+                }\n+                None => {\n+                    if let Some(name) = node.name() {\n+                        builder.insert(name.syntax().text_range().end(), \"<'a>\");\n+                    }\n+                }\n+            }\n+\n+            for ref_type in ref_types {\n+                if let Some(amp_token) = ref_type.amp_token() {\n+                    builder.insert(amp_token.text_range().end(), \"'a \");\n+                }\n+            }\n+        },\n+    )\n+}\n+\n+fn fetch_borrowed_types(node: &ast::AdtDef) -> Option<Vec<RefType>> {\n+    let ref_types: Vec<RefType> = match node {\n+        ast::AdtDef::Enum(enum_) => {\n+            let variant_list = enum_.variant_list()?;\n+            variant_list\n+                .variants()\n+                .filter_map(|variant| {\n+                    let field_list = variant.field_list()?;\n+\n+                    find_ref_types_from_field_list(&field_list)\n+                })\n+                .flatten()\n+                .collect()\n+        }\n+        ast::AdtDef::Struct(strukt) => {\n+            let field_list = strukt.field_list()?;\n+            find_ref_types_from_field_list(&field_list)?\n+        }\n+        ast::AdtDef::Union(un) => {\n+            let record_field_list = un.record_field_list()?;\n+            record_field_list\n+                .fields()\n+                .filter_map(|r_field| {\n+                    if let Type::RefType(ref_type) = r_field.ty()? {\n+                        if ref_type.lifetime().is_none() {\n+                            return Some(ref_type);\n+                        }\n+                    }\n+\n+                    None\n+                })\n+                .collect()\n+        }\n+    };\n+\n+    if ref_types.is_empty() {\n+        None\n+    } else {\n+        Some(ref_types)\n+    }\n+}\n+\n+fn find_ref_types_from_field_list(field_list: &FieldList) -> Option<Vec<RefType>> {\n+    let ref_types: Vec<RefType> = match field_list {\n+        ast::FieldList::RecordFieldList(record_list) => record_list\n+            .fields()\n+            .filter_map(|f| {\n+                if let Type::RefType(ref_type) = f.ty()? {\n+                    if ref_type.lifetime().is_none() {\n+                        return Some(ref_type);\n+                    }\n+                }\n+\n+                None\n+            })\n+            .collect(),\n+        ast::FieldList::TupleFieldList(tuple_field_list) => tuple_field_list\n+            .fields()\n+            .filter_map(|f| {\n+                if let Type::RefType(ref_type) = f.ty()? {\n+                    if ref_type.lifetime().is_none() {\n+                        return Some(ref_type);\n+                    }\n+                }\n+\n+                None\n+            })\n+            .collect(),\n+    };\n+\n+    if ref_types.is_empty() {\n+        None\n+    } else {\n+        Some(ref_types)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn add_lifetime_to_struct() {\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"struct Foo { a: &$0i32 }\",\n+            \"struct Foo<'a> { a: &'a i32 }\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"struct Foo { a: &$0i32, b: &usize }\",\n+            \"struct Foo<'a> { a: &'a i32, b: &'a usize }\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"struct Foo { a: &$0i32, b: usize }\",\n+            \"struct Foo<'a> { a: &'a i32, b: usize }\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"struct Foo<T> { a: &$0T, b: usize }\",\n+            \"struct Foo<'a, T> { a: &'a T, b: usize }\",\n+        );\n+\n+        check_assist_not_applicable(add_lifetime_to_type, \"struct Foo<'a> { a: &$0'a i32 }\");\n+        check_assist_not_applicable(add_lifetime_to_type, \"struct Foo { a: &'a$0 i32 }\");\n+    }\n+\n+    #[test]\n+    fn add_lifetime_to_enum() {\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"enum Foo { Bar { a: i32 }, Other, Tuple(u32, &$0u32)}\",\n+            \"enum Foo<'a> { Bar { a: i32 }, Other, Tuple(u32, &'a u32)}\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"enum Foo { Bar { a: &$0i32 }}\",\n+            \"enum Foo<'a> { Bar { a: &'a i32 }}\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"enum Foo<T> { Bar { a: &$0i32, b: &T }}\",\n+            \"enum Foo<'a, T> { Bar { a: &'a i32, b: &'a T }}\",\n+        );\n+\n+        check_assist_not_applicable(add_lifetime_to_type, \"enum Foo<'a> { Bar { a: &$0'a i32 }}\");\n+        check_assist_not_applicable(add_lifetime_to_type, \"enum Foo { Bar, $0Misc }\");\n+    }\n+\n+    #[test]\n+    fn add_lifetime_to_union() {\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"union Foo { a: &$0i32 }\",\n+            \"union Foo<'a> { a: &'a i32 }\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"union Foo { a: &$0i32, b: &usize }\",\n+            \"union Foo<'a> { a: &'a i32, b: &'a usize }\",\n+        );\n+\n+        check_assist(\n+            add_lifetime_to_type,\n+            \"union Foo<T> { a: &$0T, b: usize }\",\n+            \"union Foo<'a, T> { a: &'a T, b: usize }\",\n+        );\n+\n+        check_assist_not_applicable(add_lifetime_to_type, \"struct Foo<'a> { a: &'a $0i32 }\");\n+    }\n+}"}, {"sha": "559b9651e80041a6e7aaac9ac5e499ab605b3f9f", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -108,6 +108,7 @@ mod handlers {\n     pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_explicit_type;\n+    mod add_lifetime_to_type;\n     mod add_missing_impl_members;\n     mod add_turbo_fish;\n     mod apply_demorgan;\n@@ -164,6 +165,7 @@ mod handlers {\n         &[\n             // These are alphabetic for the foolish consistency\n             add_explicit_type::add_explicit_type,\n+            add_lifetime_to_type::add_lifetime_to_type,\n             add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,"}, {"sha": "9aa807f10a8f1ff2396488fa409667ef0b4c08b6", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -103,6 +103,25 @@ impl Trait<u32> for () {\n     )\n }\n \n+#[test]\n+fn doctest_add_lifetime_to_type() {\n+    check_doc_test(\n+        \"add_lifetime_to_type\",\n+        r#####\"\n+struct Point {\n+    x: &$0u32,\n+    y: u32,\n+}\n+\"#####,\n+        r#####\"\n+struct Point<'a> {\n+    x: &'a u32,\n+    y: u32,\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_turbo_fish() {\n     check_doc_test("}, {"sha": "c34a99d90bdff7ee834b10e756b48e249e762dde", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -281,7 +281,7 @@ impl Module {\n \n     /// Name of this module.\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         let parent = def_map[self.id.local_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n             if *module_id == self.id.local_id {\n@@ -307,7 +307,7 @@ impl Module {\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         let children = def_map[self.id.local_id]\n             .children\n             .iter()\n@@ -318,7 +318,7 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &dyn HirDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         let parent_id = def_map[self.id.local_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n@@ -339,7 +339,7 @@ impl Module {\n         db: &dyn HirDatabase,\n         visible_from: Option<Module>,\n     ) -> Vec<(Name, ScopeDef)> {\n-        db.crate_def_map(self.id.krate)[self.id.local_id]\n+        self.id.def_map(db.upcast())[self.id.local_id]\n             .scope\n             .entries()\n             .filter_map(|(name, def)| {\n@@ -362,14 +362,14 @@ impl Module {\n     }\n \n     pub fn visibility_of(self, db: &dyn HirDatabase, def: &ModuleDef) -> Option<Visibility> {\n-        db.crate_def_map(self.id.krate)[self.id.local_id].scope.visibility_of(def.clone().into())\n+        self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of(def.clone().into())\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n-        let crate_def_map = db.crate_def_map(self.id.krate);\n+        let crate_def_map = self.id.def_map(db.upcast());\n         crate_def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n@@ -396,12 +396,12 @@ impl Module {\n     }\n \n     pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         def_map[self.id.local_id].scope.declarations().map(ModuleDef::from).collect()\n     }\n \n     pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<Impl> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         def_map[self.id.local_id].scope.impls().map(Impl::from).collect()\n     }\n "}, {"sha": "2620026713c80ed3e234055fe20bfa0039c358f2", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -24,12 +24,12 @@ pub trait HasSource {\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &dyn HirDatabase) -> InFile<ModuleSource> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         def_map[self.id.local_id].definition_source(db.upcast())\n     }\n \n     pub fn is_mod_rs(self, db: &dyn HirDatabase) -> bool {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         match def_map[self.id.local_id].origin {\n             ModuleOrigin::File { is_mod_rs, .. } => is_mod_rs,\n             _ => false,\n@@ -39,7 +39,7 @@ impl Module {\n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n     pub fn declaration_source(self, db: &dyn HirDatabase) -> Option<InFile<ast::Module>> {\n-        let def_map = db.crate_def_map(self.id.krate);\n+        let def_map = self.id.def_map(db.upcast());\n         def_map[self.id.local_id].declaration_source(db.upcast())\n     }\n }"}, {"sha": "775f7ec8b7687f36fd6fd1066bf6b9f883237abe", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -31,6 +31,7 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn file_to_def(&mut self, file: FileId) -> Option<ModuleId> {\n         let _p = profile::span(\"SourceBinder::to_module_def\");\n         let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n+            // FIXME: inner items\n             let crate_def_map = self.db.crate_def_map(crate_id);\n             let local_id = crate_def_map.modules_for_file(file).next()?;\n             Some((crate_id, local_id))\n@@ -60,7 +61,7 @@ impl SourceToDefCtx<'_, '_> {\n         }?;\n \n         let child_name = src.value.name()?.as_name();\n-        let def_map = self.db.crate_def_map(parent_module.krate);\n+        let def_map = parent_module.def_map(self.db.upcast());\n         let child_id = *def_map[parent_module.local_id].children.get(&child_name)?;\n         Some(ModuleId { krate: parent_module.krate, local_id: child_id })\n     }"}, {"sha": "6513daec87dc9a03cef322ba1373a1126e87deb9", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -196,7 +196,7 @@ impl Attrs {\n     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n         let raw_attrs = match def {\n             AttrDefId::ModuleId(module) => {\n-                let def_map = db.crate_def_map(module.krate);\n+                let def_map = module.def_map(db);\n                 let mod_data = &def_map[module.local_id];\n                 match mod_data.declaration_source(db) {\n                     Some(it) => {"}, {"sha": "d0c84ab0b5907771018aca94e9725ff853fbea14", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -86,7 +86,7 @@ impl Expander {\n         module: ModuleId,\n     ) -> Expander {\n         let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n-        let crate_def_map = db.crate_def_map(module.krate);\n+        let crate_def_map = module.def_map(db);\n         let ast_id_map = db.ast_id_map(current_file_id);\n         Expander {\n             cfg_expander,"}, {"sha": "65d85c86a782cb27ecfe6b5a63b9ab80217952ee", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -74,7 +74,7 @@ impl ChildBySource for ImplId {\n \n impl ChildBySource for ModuleId {\n     fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n-        let crate_def_map = db.crate_def_map(self.krate);\n+        let crate_def_map = self.def_map(db);\n         let module_data = &crate_def_map[self.local_id];\n         module_data.scope.child_by_source(db)\n     }"}, {"sha": "c01b6daf2c03a0b5b0c58b65f01bb16f19d7b2fc", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -110,7 +110,7 @@ fn find_path_inner(\n     // Base cases:\n \n     // - if the item is already in scope, return the name under which it is\n-    let def_map = db.crate_def_map(from.krate);\n+    let def_map = from.def_map(db);\n     let from_scope: &crate::item_scope::ItemScope = &def_map[from.local_id].scope;\n     let scope_name =\n         if let Some((name, _)) = from_scope.name_of(item) { Some(name.clone()) } else { None };\n@@ -145,7 +145,7 @@ fn find_path_inner(\n \n     // - if the item is in the prelude, return the name from there\n     if let Some(prelude_module) = def_map.prelude() {\n-        let prelude_def_map = db.crate_def_map(prelude_module.krate);\n+        let prelude_def_map = prelude_module.def_map(db);\n         let prelude_scope: &crate::item_scope::ItemScope =\n             &prelude_def_map[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n@@ -283,7 +283,7 @@ fn find_local_import_locations(\n     // above `from` with any visibility. That means we do not need to descend into private siblings\n     // of `from` (and similar).\n \n-    let def_map = db.crate_def_map(from.krate);\n+    let def_map = from.def_map(db);\n \n     // Compute the initial worklist. We start with all direct child modules of `from` as well as all\n     // of its (recursive) parent modules.\n@@ -312,7 +312,7 @@ fn find_local_import_locations(\n             &def_map[module.local_id]\n         } else {\n             // The crate might reexport a module defined in another crate.\n-            ext_def_map = db.crate_def_map(module.krate);\n+            ext_def_map = module.def_map(db);\n             &ext_def_map[module.local_id]\n         };\n \n@@ -375,7 +375,7 @@ mod tests {\n             parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n         let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n \n-        let crate_def_map = db.crate_def_map(module.krate);\n+        let crate_def_map = module.def_map(&db);\n         let resolved = crate_def_map\n             .resolve_path(\n                 &db,"}, {"sha": "0b783044564b678a97a48eb8fcdaaef23bfd1f33", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -83,7 +83,7 @@ impl ImportMap {\n                 &def_map[module.local_id]\n             } else {\n                 // The crate might reexport a module defined in another crate.\n-                ext_def_map = db.crate_def_map(module.krate);\n+                ext_def_map = module.def_map(db);\n                 &ext_def_map[module.local_id]\n             };\n "}, {"sha": "2f9261a7fe6b22648a658446ec8ae1a01bb60c03", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -50,14 +50,18 @@ pub mod import_map;\n #[cfg(test)]\n mod test_db;\n \n-use std::hash::{Hash, Hasher};\n+use std::{\n+    hash::{Hash, Hasher},\n+    sync::Arc,\n+};\n \n use base_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::{\n     ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n     MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use la_arena::Idx;\n+use nameres::DefMap;\n use syntax::ast;\n \n use crate::builtin_type::BuiltinType;\n@@ -73,6 +77,12 @@ pub struct ModuleId {\n     pub local_id: LocalModuleId,\n }\n \n+impl ModuleId {\n+    pub fn def_map(&self, db: &dyn db::DefDatabase) -> Arc<DefMap> {\n+        db.crate_def_map(self.krate)\n+    }\n+}\n+\n /// An ID of a module, **local** to a specific crate\n pub type LocalModuleId = Idx<nameres::ModuleData>;\n "}, {"sha": "adfcf879a44866fd351f8b6e6764b89f6a9fea39", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -578,7 +578,7 @@ impl DefCollector<'_> {\n                     } else if m.krate != self.def_map.krate {\n                         mark::hit!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate);\n+                        let item_map = m.def_map(self.db);\n                         let scope = &item_map[m.local_id].scope;\n \n                         // Module scoped macros is included"}, {"sha": "82528b792062ea5c04e8123660ea6ea12356660f", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -243,7 +243,7 @@ impl DefMap {\n                             kind: PathKind::Super(0),\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n+                        let defp_map = module.def_map(db);\n                         let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n                         return ResolvePathResult::with(\n                             def,\n@@ -356,7 +356,7 @@ impl DefMap {\n                 self\n             } else {\n                 // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n+                keep = prelude.def_map(db);\n                 &keep\n             };\n             def_map[prelude.local_id].scope.get(name)"}, {"sha": "130c074f0887e1eaf5a3cb1e75bf9794be01ef13", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -430,7 +430,7 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    let prelude_def_map = prelude.def_map(db);\n                     traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n                 }\n                 traits.extend(m.crate_def_map[m.module_id].scope.traits());\n@@ -529,7 +529,7 @@ impl Scope {\n                     f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    let prelude_def_map = prelude.def_map(db);\n                     prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, def)| {\n                         let seen_tuple = (name.clone(), def);\n                         if !seen.contains(&seen_tuple) {\n@@ -633,7 +633,7 @@ pub trait HasResolver: Copy {\n \n impl HasResolver for ModuleId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate);\n+        let def_map = self.def_map(db);\n         Resolver::default().push_module_scope(def_map, self.local_id)\n     }\n }"}, {"sha": "e79a911023813b6efd952fcc04662211ee0a9624", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -103,7 +103,7 @@ impl Visibility {\n         if from_module.krate != to_module.krate {\n             return false;\n         }\n-        let def_map = db.crate_def_map(from_module.krate);\n+        let def_map = from_module.def_map(db);\n         self.is_visible_from_def_map(&def_map, from_module.local_id)\n     }\n "}, {"sha": "25ee664d6f4cacb91f54de0ed942bb63da9bd47b", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16add934d3cb4817ec0f20b8697a4d9701fce4e/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=b16add934d3cb4817ec0f20b8697a4d9701fce4e", "patch": "@@ -188,10 +188,10 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n     };\n \n     let module = db.module_for_file(file_id);\n-    let crate_def_map = db.crate_def_map(module.krate);\n+    let def_map = module.def_map(&db);\n \n     let mut defs: Vec<DefWithBodyId> = Vec::new();\n-    visit_module(&db, &crate_def_map, module.local_id, &mut |it| defs.push(it));\n+    visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n     defs.sort_by_key(|def| match def {\n         DefWithBodyId::FunctionId(it) => {\n             let loc = it.lookup(&db);\n@@ -321,7 +321,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     {\n         let events = db.log_executed(|| {\n             let module = db.module_for_file(pos.file_id);\n-            let crate_def_map = db.crate_def_map(module.krate);\n+            let crate_def_map = module.def_map(&db);\n             visit_module(&db, &crate_def_map, module.local_id, &mut |def| {\n                 db.infer(def);\n             });"}]}