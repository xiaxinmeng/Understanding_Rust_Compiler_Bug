{"sha": "418f6089e93d7f784643d55e6782055c9bb479d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOGY2MDg5ZTkzZDdmNzg0NjQzZDU1ZTY3ODIwNTVjOWJiNDc5ZDU=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-21T20:37:31Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:48:19Z"}, "message": "Give a better error message when linking to a macro with the wrong disambiguator\n\nBefore:\n\n```\nwarning: unresolved link to `m`\n --> m.rs:1:6\n  |\n1 | /// [value@m]\n  |      ^^^^^^^\n  |\n  = note: `#[warn(broken_intra_doc_links)]` on by default\n  = note: no item named `m` is in scope\n  = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n```\n\nAfter:\n\n```\nwarning: unresolved link to `m`\n --> m.rs:1:6\n  |\n1 | /// [value@m]\n  |      ^^^^^^^ help: to link to the macro, use its disambiguator: `m!`\n  |\n  = note: `#[warn(broken_intra_doc_links)]` on by default\n  = note: this link resolves to the macro `m`, which is not in the value namespace\n```", "tree": {"sha": "f0dde355e2fba31cf78ac9c10a0f8d726d28d567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0dde355e2fba31cf78ac9c10a0f8d726d28d567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/418f6089e93d7f784643d55e6782055c9bb479d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/418f6089e93d7f784643d55e6782055c9bb479d5", "html_url": "https://github.com/rust-lang/rust/commit/418f6089e93d7f784643d55e6782055c9bb479d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/418f6089e93d7f784643d55e6782055c9bb479d5/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6875220e1abea26c67885833c27365854cd7f73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6875220e1abea26c67885833c27365854cd7f73c", "html_url": "https://github.com/rust-lang/rust/commit/6875220e1abea26c67885833c27365854cd7f73c"}], "stats": {"total": 192, "additions": 142, "deletions": 50}, "files": [{"sha": "7bd4b8ca854b5c916c483b2b2577fe5b97581abe", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 79, "deletions": 40, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=418f6089e93d7f784643d55e6782055c9bb479d5", "patch": "@@ -74,8 +74,6 @@ enum ResolutionFailure<'a> {\n     NoAssocItem(Res, Symbol),\n     /// should not ever happen\n     NoParentItem,\n-    /// the root of this path resolved, but it was not an enum.\n-    NotAnEnum(Res),\n     /// this could be an enum variant, but the last path fragment wasn't resolved.\n     /// the `String` is the variant that didn't exist\n     NotAVariant(Res, Symbol),\n@@ -91,7 +89,6 @@ impl ResolutionFailure<'a> {\n             NoPrimitiveAssocItem { res, .. }\n             | NoAssocItem(res, _)\n             | NoPrimitiveImpl(res, _)\n-            | NotAnEnum(res)\n             | NotAVariant(res, _)\n             | WrongNamespace(res, _)\n             | CannotHaveAssociatedItems(res, _) => Some(*res),\n@@ -133,6 +130,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         current_item: &Option<String>,\n         module_id: DefId,\n+        extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n@@ -202,7 +200,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     _ => unreachable!(),\n                 }\n             }\n-            _ => Err(ErrorKind::Resolve(ResolutionFailure::NotAnEnum(ty_res))),\n+            // `variant_field` looks at 3 different path segments in a row.\n+            // But `NoAssocItem` assumes there are only 2. Check to see if there's\n+            // an intermediate segment that resolves.\n+            _ => {\n+                let intermediate_path = format!(\"{}::{}\", path, variant_name);\n+                // NOTE: we have to be careful here, because we're already in `resolve`.\n+                // We know this doesn't recurse forever because we use a shorter path each time.\n+                // NOTE: this uses `TypeNS` because nothing else has a valid path segment after\n+                let kind = if let Some(intermediate) = self.check_full_res(\n+                    TypeNS,\n+                    &intermediate_path,\n+                    Some(module_id),\n+                    current_item,\n+                    extra_fragment,\n+                ) {\n+                    ResolutionFailure::NoAssocItem(intermediate, variant_field_name)\n+                } else {\n+                    // Even with the shorter path, it didn't resolve, so say that.\n+                    ResolutionFailure::NoAssocItem(ty_res, variant_name)\n+                };\n+                Err(ErrorKind::Resolve(kind))\n+            }\n         }\n     }\n \n@@ -376,7 +395,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             let ty_res = match ty_res {\n                 Err(()) | Ok(Res::Err) => {\n                     return if ns == Namespace::ValueNS {\n-                        self.variant_field(path_str, current_item, module_id)\n+                        self.variant_field(path_str, current_item, module_id, extra_fragment)\n                     } else {\n                         // See if it only broke because of the namespace.\n                         let kind = cx.enter_resolver(|resolver| {\n@@ -533,7 +552,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             };\n             res.unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id)\n+                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n                 } else {\n                     Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(ty_res, item_name)))\n                 }\n@@ -543,6 +562,41 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             Err(ErrorKind::Resolve(ResolutionFailure::NoParentItem))\n         }\n     }\n+\n+    // used for reporting better errors\n+    fn check_full_res(\n+        &self,\n+        ns: Namespace,\n+        path_str: &str,\n+        base_node: Option<DefId>,\n+        current_item: &Option<String>,\n+        extra_fragment: &Option<String>,\n+    ) -> Option<Res> {\n+        let check_full_res_inner = |this: &Self, result: Result<Res, ErrorKind<'_>>| {\n+            let res = match result {\n+                Ok(res) => Some(res),\n+                Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n+                Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => {\n+                    Some(res)\n+                }\n+                Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n+            };\n+            this.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n+        };\n+        // cannot be used for macro namespace\n+        let check_full_res = |this: &Self, ns| {\n+            let result = this.resolve(path_str, ns, current_item, base_node, extra_fragment);\n+            check_full_res_inner(this, result.map(|(res, _)| res))\n+        };\n+        let check_full_res_macro = |this: &Self| {\n+            let result = this.macro_resolve(path_str, base_node);\n+            check_full_res_inner(this, result.map_err(ErrorKind::Resolve))\n+        };\n+        match ns {\n+            Namespace::MacroNS => check_full_res_macro(self),\n+            Namespace::TypeNS | Namespace::ValueNS => check_full_res(self, ns),\n+        }\n+    }\n }\n \n fn resolve_associated_trait_item(\n@@ -652,7 +706,7 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n             let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.self_ty();\n-            debug!(\n+            trace!(\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,\n                 impl_type.kind(),\n@@ -875,40 +929,26 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n \n-                // used for reporting better errors\n-                let check_full_res = |this: &mut Self, ns| {\n-                    let res =\n-                        match this.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n-                        {\n-                            Ok(res) => {\n-                                debug!(\n-                                    \"check_full_res: saw res for {} in {:?} ns: {:?}\",\n-                                    path_str, ns, res.0\n-                                );\n-                                Some(res.0)\n-                            }\n-                            Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n-                            Err(ErrorKind::AnchorFailure(\n-                                AnchorFailure::RustdocAnchorConflict(res),\n-                            )) => Some(res),\n-                            Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n-                        };\n-                    this.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n-                };\n-\n                 match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ (ValueNS | TypeNS)) => {\n                         match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n                         {\n                             Ok(res) => res,\n                             Err(ErrorKind::Resolve(mut kind)) => {\n                                 // We only looked in one namespace. Try to give a better error if possible.\n-                                // TODO: handle MacroNS too\n                                 if kind.full_res().is_none() {\n                                     let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n-                                    if let Some(res) = check_full_res(self, other_ns) {\n-                                        // recall that this stores the _expected_ namespace\n-                                        kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                    for &ns in &[other_ns, MacroNS] {\n+                                        if let Some(res) = self.check_full_res(\n+                                            ns,\n+                                            path_str,\n+                                            base_node,\n+                                            &current_item,\n+                                            &extra_fragment,\n+                                        ) {\n+                                            kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                            break;\n+                                        }\n                                     }\n                                 }\n                                 resolution_failure(\n@@ -1033,7 +1073,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             Err(mut kind) => {\n                                 // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n                                 for &ns in &[TypeNS, ValueNS] {\n-                                    if let Some(res) = check_full_res(self, ns) {\n+                                    if let Some(res) = self.check_full_res(\n+                                        ns,\n+                                        path_str,\n+                                        base_node,\n+                                        &current_item,\n+                                        &extra_fragment,\n+                                    ) {\n                                         kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n                                         break;\n                                     }\n@@ -1525,13 +1571,6 @@ fn resolution_failure(\n                     ResolutionFailure::CannotHaveAssociatedItems(res, _) => {\n                         assoc_item_not_allowed(res, diag)\n                     }\n-                    // TODO: is there ever a case where this happens?\n-                    ResolutionFailure::NotAnEnum(res) => {\n-                        let note =\n-                            format!(\"this link resolves to {}, which is not an enum\", item(res));\n-                        diag.note(&note);\n-                        diag.note(\"if this were an enum, it might have a variant which resolved\");\n-                    }\n                     ResolutionFailure::NotAVariant(res, variant) => {\n                         let note = format!(\n                             \"this link partially resolves to {}, but there is no variant named {}\","}, {"sha": "33c8d1b3c4965ddcb2453a44680513d6b8174bdf", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=418f6089e93d7f784643d55e6782055c9bb479d5", "patch": "@@ -10,6 +10,18 @@\n //~| NOTE no item named `path::to` is in scope\n //~| HELP to escape\n \n+/// [std::io::not::here]\n+//~^ ERROR unresolved link\n+//~| NOTE the module `io` has no inner item\n+\n+/// [std::io::Error::x]\n+//~^ ERROR unresolved link\n+//~| NOTE the struct `Error` has no field\n+\n+/// [std::io::ErrorKind::x]\n+//~^ ERROR unresolved link\n+//~| NOTE the enum `ErrorKind` has no variant\n+\n /// [f::A]\n //~^ ERROR unresolved link\n //~| NOTE `f` is a function, not a module\n@@ -60,3 +72,12 @@ impl S {\n pub trait T {\n     fn g() {}\n }\n+\n+/// [m()]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the macro\n+//~| NOTE not in the value namespace\n+#[macro_export]\n+macro_rules! m {\n+    () => {};\n+}"}, {"sha": "0b9149cd8ea45990448190b885f884a8235bb81a", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/418f6089e93d7f784643d55e6782055c9bb479d5/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=418f6089e93d7f784643d55e6782055c9bb479d5", "patch": "@@ -12,64 +12,88 @@ LL | #![deny(broken_intra_doc_links)]\n    = note: no item named `path::to` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n-error: unresolved link to `f::A`\n+error: unresolved link to `std::io::not::here`\n   --> $DIR/intra-link-errors.rs:13:6\n    |\n+LL | /// [std::io::not::here]\n+   |      ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the module `io` has no inner item named `not`\n+\n+error: unresolved link to `std::io::Error::x`\n+  --> $DIR/intra-link-errors.rs:17:6\n+   |\n+LL | /// [std::io::Error::x]\n+   |      ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the struct `Error` has no field or associated item named `x`\n+\n+error: unresolved link to `std::io::ErrorKind::x`\n+  --> $DIR/intra-link-errors.rs:21:6\n+   |\n+LL | /// [std::io::ErrorKind::x]\n+   |      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the enum `ErrorKind` has no variant or associated item named `x`\n+\n+error: unresolved link to `f::A`\n+  --> $DIR/intra-link-errors.rs:25:6\n+   |\n LL | /// [f::A]\n    |      ^^^^\n    |\n    = note: `f` is a function, not a module or type, and cannot have associated items\n \n error: unresolved link to `S::A`\n-  --> $DIR/intra-link-errors.rs:17:6\n+  --> $DIR/intra-link-errors.rs:29:6\n    |\n LL | /// [S::A]\n    |      ^^^^\n    |\n    = note: the struct `S` has no field or associated item named `A`\n \n error: unresolved link to `S::fmt`\n-  --> $DIR/intra-link-errors.rs:21:6\n+  --> $DIR/intra-link-errors.rs:33:6\n    |\n LL | /// [S::fmt]\n    |      ^^^^^^\n    |\n    = note: the struct `S` has no field or associated item named `fmt`\n \n error: unresolved link to `E::D`\n-  --> $DIR/intra-link-errors.rs:25:6\n+  --> $DIR/intra-link-errors.rs:37:6\n    |\n LL | /// [E::D]\n    |      ^^^^\n    |\n    = note: the enum `E` has no variant or associated item named `D`\n \n error: unresolved link to `u8::not_found`\n-  --> $DIR/intra-link-errors.rs:29:6\n+  --> $DIR/intra-link-errors.rs:41:6\n    |\n LL | /// [u8::not_found]\n    |      ^^^^^^^^^^^^^\n    |\n    = note: the builtin type `u8` does not have an associated item named `not_found`\n \n error: unresolved link to `S`\n-  --> $DIR/intra-link-errors.rs:33:6\n+  --> $DIR/intra-link-errors.rs:45:6\n    |\n LL | /// [S!]\n    |      ^^ help: to link to the struct, use its disambiguator: `struct@S`\n    |\n    = note: this link resolves to the struct `S`, which is not in the macro namespace\n \n error: unresolved link to `T::g`\n-  --> $DIR/intra-link-errors.rs:51:6\n+  --> $DIR/intra-link-errors.rs:63:6\n    |\n LL | /// [type@T::g]\n    |      ^^^^^^^^^ help: to link to the associated function, use its disambiguator: `T::g()`\n    |\n    = note: this link resolves to the associated function `g`, which is not in the type namespace\n \n error: unresolved link to `T::h`\n-  --> $DIR/intra-link-errors.rs:56:6\n+  --> $DIR/intra-link-errors.rs:68:6\n    |\n LL | /// [T::h!]\n    |      ^^^^^\n@@ -78,12 +102,20 @@ LL | /// [T::h!]\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:43:6\n+  --> $DIR/intra-link-errors.rs:55:6\n    |\n LL | /// [type@S::h]\n    |      ^^^^^^^^^ help: to link to the associated function, use its disambiguator: `S::h()`\n    |\n    = note: this link resolves to the associated function `h`, which is not in the type namespace\n \n-error: aborting due to 10 previous errors\n+error: unresolved link to `m`\n+  --> $DIR/intra-link-errors.rs:76:6\n+   |\n+LL | /// [m()]\n+   |      ^^^ help: to link to the macro, use its disambiguator: `m!`\n+   |\n+   = note: this link resolves to the macro `m`, which is not in the value namespace\n+\n+error: aborting due to 14 previous errors\n "}]}