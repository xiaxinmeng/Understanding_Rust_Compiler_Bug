{"sha": "c31a88c7f4fddb217c022ac214c0a49501d9ded3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMWE4OGM3ZjRmZGRiMjE3YzAyMmFjMjE0YzBhNDk1MDFkOWRlZDM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T23:31:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T23:32:00Z"}, "message": "De-export the submodules of task. Part of #3583.", "tree": {"sha": "0a50046c9db56310dc354f0c7086954ab00ab285", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a50046c9db56310dc354f0c7086954ab00ab285"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c31a88c7f4fddb217c022ac214c0a49501d9ded3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c31a88c7f4fddb217c022ac214c0a49501d9ded3", "html_url": "https://github.com/rust-lang/rust/commit/c31a88c7f4fddb217c022ac214c0a49501d9ded3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c31a88c7f4fddb217c022ac214c0a49501d9ded3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4101d8c22d239eba5b2202faa28db54b5e1a4909", "url": "https://api.github.com/repos/rust-lang/rust/commits/4101d8c22d239eba5b2202faa28db54b5e1a4909", "html_url": "https://github.com/rust-lang/rust/commit/4101d8c22d239eba5b2202faa28db54b5e1a4909"}], "stats": {"total": 116, "additions": 55, "deletions": 61}, "files": [{"sha": "818e1e890ec9beba406f23e668e491fd9e577d1e", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -216,17 +216,11 @@ mod send_map;\n \n // Concurrency\n mod comm;\n-#[legacy_exports]\n mod task {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod local_data;\n-    #[legacy_exports]\n+    pub mod local_data;\n     mod local_data_priv;\n-    #[legacy_exports]\n-    mod spawn;\n-    #[legacy_exports]\n-    mod rt;\n+    pub mod spawn;\n+    pub mod rt;\n }\n mod future;\n mod pipes;"}, {"sha": "9bc83a5f9043d3ba18fd54e5b3c1cc64f4241055", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -11,10 +11,9 @@ use libc::uintptr_t;\n use gc::{cleanup_stack_for_failure, gc, Word};\n \n #[allow(non_camel_case_types)]\n-type rust_task = c_void;\n+pub type rust_task = c_void;\n \n extern mod rustrt {\n-    #[legacy_exports];\n     #[rust_stack]\n     fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n \n@@ -35,13 +34,13 @@ extern mod rustrt {\n // 'rt_', otherwise the compiler won't find it. To fix this, see\n // gather_rust_rtcalls.\n #[rt(fail_)]\n-fn rt_fail_(expr: *c_char, file: *c_char, line: size_t) {\n+pub fn rt_fail_(expr: *c_char, file: *c_char, line: size_t) {\n     cleanup_stack_for_failure();\n     rustrt::rust_upcall_fail(expr, file, line);\n }\n \n #[rt(fail_bounds_check)]\n-fn rt_fail_bounds_check(file: *c_char, line: size_t,\n+pub fn rt_fail_bounds_check(file: *c_char, line: size_t,\n                         index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n@@ -51,28 +50,28 @@ fn rt_fail_bounds_check(file: *c_char, line: size_t,\n }\n \n #[rt(exchange_malloc)]\n-fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_exchange_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[rt(exchange_free)]\n-fn rt_exchange_free(ptr: *c_char) {\n+pub fn rt_exchange_free(ptr: *c_char) {\n     rustrt::rust_upcall_exchange_free(ptr);\n }\n \n #[rt(malloc)]\n-fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[rt(free)]\n-fn rt_free(ptr: *c_char) {\n+pub fn rt_free(ptr: *c_char) {\n     rustrt::rust_upcall_free(ptr);\n }\n "}, {"sha": "9849ce7b68cdb15a7f40bcdad5b519466927063c", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -3,7 +3,7 @@\n use local_data::LocalDataKey;\n use rt::rust_task;\n \n-trait LocalData { }\n+pub trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n@@ -17,19 +17,19 @@ impl LocalData: Eq {\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+pub type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+pub type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+pub extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n     let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n@@ -52,7 +52,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: Owned>(\n+pub unsafe fn key_to_key_value<T: Owned>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -62,7 +62,7 @@ unsafe fn key_to_key_value<T: Owned>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: Owned>(\n+pub unsafe fn local_data_lookup<T: Owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n@@ -80,7 +80,7 @@ unsafe fn local_data_lookup<T: Owned>(\n     }\n }\n \n-unsafe fn local_get_helper<T: Owned>(\n+pub unsafe fn local_get_helper<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n@@ -102,21 +102,21 @@ unsafe fn local_get_helper<T: Owned>(\n }\n \n \n-unsafe fn local_pop<T: Owned>(\n+pub unsafe fn local_pop<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n-unsafe fn local_get<T: Owned>(\n+pub unsafe fn local_get<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, false)\n }\n \n-unsafe fn local_set<T: Owned>(\n+pub unsafe fn local_set<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>, data: @T) {\n \n     let map = get_task_local_map(task);\n@@ -148,7 +148,7 @@ unsafe fn local_set<T: Owned>(\n     }\n }\n \n-unsafe fn local_modify<T: Owned>(\n+pub unsafe fn local_modify<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n "}, {"sha": "db3d1ec9f70940ef4275ee3527e0941ebbbffda2", "filename": "src/libcore/task/rt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Frt.rs?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -7,16 +7,16 @@ The task interface to the runtime\n #[doc(hidden)]; // FIXME #3538\n \n #[allow(non_camel_case_types)] // runtime type\n-type sched_id = int;\n+pub type sched_id = int;\n #[allow(non_camel_case_types)] // runtime type\n-type task_id = int;\n+pub type task_id = int;\n \n // These are both opaque runtime/compiler types that we don't know the\n // structure of and should only deal with via unsafe pointer\n #[allow(non_camel_case_types)] // runtime type\n-type rust_task = libc::c_void;\n+pub type rust_task = libc::c_void;\n #[allow(non_camel_case_types)] // runtime type\n-type rust_closure = libc::c_void;\n+pub type rust_closure = libc::c_void;\n \n extern {\n     #[rust_stack]"}, {"sha": "0e1284da3bcbbd2bd0c9e7fb388397d403563b14", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -69,38 +69,38 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of(&($x)); move y } }\n )\n \n-type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n+pub type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n-fn new_taskset() -> TaskSet {\n+pub fn new_taskset() -> TaskSet {\n     send_map::linear::LinearMap()\n }\n-fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n+pub fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());\n     assert didnt_overwrite;\n }\n-fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n+pub fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n-fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n+pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n     tasks.each_key(|k| blk(*k))\n }\n \n // One of these per group of linked-failure tasks.\n-type TaskGroupData = {\n+pub type TaskGroupData = {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n     mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n     mut descendants: TaskSet,\n };\n-type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n+pub type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n \n-type TaskGroupInner = &mut Option<TaskGroupData>;\n+pub type TaskGroupInner = &mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&tg.members).is_empty()\n }\n \n@@ -111,7 +111,7 @@ pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-type AncestorNode = {\n+pub type AncestorNode = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -124,16 +124,16 @@ type AncestorNode = {\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n };\n-enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n+pub enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+pub fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n-fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n+pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -146,9 +146,9 @@ fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n // FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n-fn each_ancestor(list:        &mut AncestorList,\n-                 bail_opt:    Option<fn@(TaskGroupInner)>,\n-                 forward_blk: fn(TaskGroupInner) -> bool)\n+pub fn each_ancestor(list:        &mut AncestorList,\n+                     bail_opt:    Option<fn@(TaskGroupInner)>,\n+                     forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n@@ -271,7 +271,7 @@ fn each_ancestor(list:        &mut AncestorList,\n }\n \n // One of these per task.\n-struct TCB {\n+pub struct TCB {\n     me:            *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n     tasks:         TaskGroupArc, // 'none' means the group has failed.\n@@ -303,7 +303,7 @@ struct TCB {\n     }\n }\n \n-fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n+pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n        is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n     let notifier = move notifier;\n@@ -318,7 +318,7 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n     }\n }\n \n-struct AutoNotify {\n+pub struct AutoNotify {\n     notify_chan: Chan<Notification>,\n     mut failed:  bool,\n     drop {\n@@ -327,15 +327,15 @@ struct AutoNotify {\n     }\n }\n \n-fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n+pub fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n \n-fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n-                       is_member: bool) -> bool {\n+pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n+                           is_member: bool) -> bool {\n     let newstate = util::replace(state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n@@ -350,7 +350,8 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n+pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n+                       is_member: bool) {\n     let newstate = util::replace(state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n@@ -362,7 +363,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n+pub fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -404,8 +405,8 @@ macro_rules! taskgroup_key (\n     () => (cast::transmute((-2 as uint, 0u)))\n )\n \n-fn gen_child_taskgroup(linked: bool, supervised: bool)\n-        -> (TaskGroupArc, AncestorList, bool) {\n+pub fn gen_child_taskgroup(linked: bool, supervised: bool)\n+    -> (TaskGroupArc, AncestorList, bool) {\n     let spawner = rt::rust_get_task();\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n@@ -486,7 +487,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n+pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n "}, {"sha": "a9c6fed8ecae6822e159384f9c8ef5b204706cb1", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31a88c7f4fddb217c022ac214c0a49501d9ded3/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=c31a88c7f4fddb217c022ac214c0a49501d9ded3", "patch": "@@ -1,6 +1,6 @@\n extern mod std;\n use comm::*;\n-use task::*;\n+use task::spawn;\n \n fn a() {\n     fn doit() {"}]}