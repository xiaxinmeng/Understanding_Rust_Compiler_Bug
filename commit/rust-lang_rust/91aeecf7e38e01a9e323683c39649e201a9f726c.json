{"sha": "91aeecf7e38e01a9e323683c39649e201a9f726c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYWVlY2Y3ZTM4ZTAxYTllMzIzNjgzYzM5NjQ5ZTIwMWE5ZjcyNmM=", "commit": {"author": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-04-22T19:05:07Z"}, "committer": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-04-23T20:23:15Z"}, "message": "Fix issue #5976 - HANDLE leaks and undefined/bad behavour\non windows.", "tree": {"sha": "fbe806c0e209189685865d0df14f3e54ccfabf93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe806c0e209189685865d0df14f3e54ccfabf93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91aeecf7e38e01a9e323683c39649e201a9f726c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91aeecf7e38e01a9e323683c39649e201a9f726c", "html_url": "https://github.com/rust-lang/rust/commit/91aeecf7e38e01a9e323683c39649e201a9f726c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91aeecf7e38e01a9e323683c39649e201a9f726c/comments", "author": null, "committer": null, "parents": [{"sha": "d9896d592b4af23e9a8e8893de77c99cbb85b2c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9896d592b4af23e9a8e8893de77c99cbb85b2c2", "html_url": "https://github.com/rust-lang/rust/commit/d9896d592b4af23e9a8e8893de77c99cbb85b2c2"}], "stats": {"total": 159, "additions": 119, "deletions": 40}, "files": [{"sha": "44864630f9873856ddf2f1676efedb6744b806ed", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=91aeecf7e38e01a9e323683c39649e201a9f726c", "patch": "@@ -1725,6 +1725,7 @@ pub mod funcs {\n                                        findFileData: HANDLE)\n                     -> BOOL;\n                 unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n+                unsafe fn CloseHandle(hObject: HANDLE) -> BOOL;\n                 unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n             }\n         }"}, {"sha": "0b73eb9dca3ee1b6b749830495886d7f3bf2a4d4", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=91aeecf7e38e01a9e323683c39649e201a9f726c", "patch": "@@ -60,7 +60,7 @@ pub mod rustrt {\n         unsafe fn rust_get_argv() -> **c_char;\n         unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n         unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n-        unsafe fn rust_process_wait(handle: c_int) -> c_int;\n+        unsafe fn rust_process_wait(pid: c_int) -> c_int;\n         unsafe fn rust_set_exit_status(code: libc::intptr_t);\n     }\n }\n@@ -356,7 +356,11 @@ pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n #[cfg(windows)]\n pub fn waitpid(pid: pid_t) -> c_int {\n     unsafe {\n-        return rustrt::rust_process_wait(pid);\n+        let status = rustrt::rust_process_wait(pid);\n+        if status < 0 {\n+            fail!(fmt!(\"failure in rust_process_wait: %s\", last_os_error()));\n+        }\n+        return status;\n     }\n }\n "}, {"sha": "4c5da132532d43b379a724635641963eb2e37877", "filename": "src/libcore/run.rs", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=91aeecf7e38e01a9e323683c39649e201a9f726c", "patch": "@@ -24,8 +24,9 @@ use task;\n use vec;\n \n pub mod rustrt {\n-    use libc::{c_int, c_void, pid_t};\n+    use libc::{c_int, c_void};\n     use libc;\n+    use run;\n \n     #[abi = \"cdecl\"]\n     pub extern {\n@@ -34,11 +35,18 @@ pub mod rustrt {\n                                    dir: *libc::c_char,\n                                    in_fd: c_int,\n                                    out_fd: c_int,\n-                                   err_fd: c_int)\n-                                -> pid_t;\n+                                   err_fd: c_int) -> run::RunProgramResult;\n     }\n }\n \n+pub struct RunProgramResult {\n+    // the process id of the program, or -1 if in case of errors\n+    pid: pid_t,\n+    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n+    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n+    handle: *(),\n+}\n+\n /// A value representing a child process\n pub trait Program {\n     /// Returns the process id of the program\n@@ -100,16 +108,24 @@ pub trait Program {\n  * The process id of the spawned process\n  */\n pub fn spawn_process(prog: &str, args: &[~str],\n-                 env: &Option<~[(~str,~str)]>,\n-                 dir: &Option<~str>,\n-                 in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-              -> pid_t {\n+                     env: &Option<~[(~str,~str)]>,\n+                     dir: &Option<~str>,\n+                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> pid_t {\n+\n+    let res = spawn_process_internal(prog, args, env, dir, in_fd, out_fd, err_fd);\n+    free_handle(res.handle);\n+    return res.pid;\n+}\n+\n+fn spawn_process_internal(prog: &str, args: &[~str],\n+                          env: &Option<~[(~str,~str)]>,\n+                          dir: &Option<~str>,\n+                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n     unsafe {\n         do with_argv(prog, args) |argv| {\n             do with_envp(env) |envp| {\n                 do with_dirp(dir) |dirp| {\n-                    rustrt::rust_run_program(argv, envp, dirp,\n-                                             in_fd, out_fd, err_fd)\n+                    rustrt::rust_run_program(argv, envp, dirp, in_fd, out_fd, err_fd)\n                 }\n             }\n         }\n@@ -195,6 +211,18 @@ priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n     }\n }\n \n+#[cfg(windows)]\n+priv fn free_handle(handle: *()) {\n+    unsafe {\n+        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n+    }\n+}\n+\n+#[cfg(unix)]\n+priv fn free_handle(_handle: *()) {\n+    // unix has no process handle object, just a pid\n+}\n+\n /**\n  * Spawns a process and waits for it to terminate\n  *\n@@ -208,10 +236,13 @@ priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n  * The process's exit code\n  */\n pub fn run_program(prog: &str, args: &[~str]) -> int {\n-    let pid = spawn_process(prog, args, &None, &None,\n-                            0i32, 0i32, 0i32);\n-    if pid == -1 as pid_t { fail!(); }\n-    return waitpid(pid);\n+    let res = spawn_process_internal(prog, args, &None, &None,\n+                                     0i32, 0i32, 0i32);\n+    if res.pid == -1 as pid_t { fail!(); }\n+\n+    let code = waitpid(res.pid);\n+    free_handle(res.handle);\n+    return code;\n }\n \n /**\n@@ -234,20 +265,21 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid =\n-        spawn_process(prog, args, &None, &None,\n-                      pipe_input.in, pipe_output.out,\n-                      pipe_err.out);\n+    let res =\n+        spawn_process_internal(prog, args, &None, &None,\n+                               pipe_input.in, pipe_output.out,\n+                               pipe_err.out);\n \n     unsafe {\n-        if pid == -1 as pid_t { fail!(); }\n+        if res.pid == -1 as pid_t { fail!(); }\n         libc::close(pipe_input.in);\n         libc::close(pipe_output.out);\n         libc::close(pipe_err.out);\n     }\n \n     struct ProgRepr {\n         pid: pid_t,\n+        handle: *(),\n         in_fd: c_int,\n         out_file: *libc::FILE,\n         err_file: *libc::FILE,\n@@ -317,6 +349,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n                 finish_repr(cast::transmute(&self.r));\n                 close_repr_outputs(cast::transmute(&self.r));\n             }\n+            free_handle(self.r.handle);\n         }\n     }\n \n@@ -343,8 +376,9 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n         fn force_destroy(&mut self) { destroy_repr(&mut self.r, true); }\n     }\n \n-    let repr = ProgRepr {\n-        pid: pid,\n+    let mut repr = ProgRepr {\n+        pid: res.pid,\n+        handle: res.handle,\n         in_fd: pipe_input.out,\n         out_file: os::fdopen(pipe_output.in),\n         err_file: os::fdopen(pipe_err.in),\n@@ -385,13 +419,13 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, &None, &None,\n-                            pipe_in.in, pipe_out.out, pipe_err.out);\n+    let res = spawn_process_internal(prog, args, &None, &None,\n+                                     pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n     os::close(pipe_out.out);\n     os::close(pipe_err.out);\n-    if pid == -1i32 {\n+    if res.pid == -1i32 {\n         os::close(pipe_in.out);\n         os::close(pipe_out.in);\n         os::close(pipe_err.in);\n@@ -415,7 +449,10 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n         let output = readclose(pipe_out.in);\n         ch_clone.send((1, output));\n     };\n-    let status = run::waitpid(pid);\n+\n+    let status = waitpid(res.pid);\n+    free_handle(res.handle);\n+\n     let mut errs = ~\"\";\n     let mut outs = ~\"\";\n     let mut count = 2;\n@@ -563,6 +600,12 @@ mod tests {\n         assert!(status == 1);\n     }\n \n+    #[test]\n+    #[should_fail]\n+    fn waitpid_non_existant_pid() {\n+        run::waitpid(123456789); // assume that this pid doesn't exist\n+    }\n+\n     #[test]\n     fn test_destroy_once() {\n         let mut p = run::start_program(\"echo\", []);"}, {"sha": "cf4beed1a00c6fea11b258f4c40202b83c0d3f78", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/91aeecf7e38e01a9e323683c39649e201a9f726c/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=91aeecf7e38e01a9e323683c39649e201a9f726c", "patch": "@@ -15,6 +15,11 @@\n #include <crt_externs.h>\n #endif\n \n+struct RunProgramResult {\n+    pid_t pid;\n+    void* handle;\n+};\n+\n #if defined(__WIN32__)\n \n #include <process.h>\n@@ -78,7 +83,7 @@ void append_arg(char *& buf, char const *arg, bool last) {\n     }\n }\n \n-extern \"C\" CDECL int\n+extern \"C\" CDECL RunProgramResult\n rust_run_program(const char* argv[],\n                  void* envp,\n                  const char* dir,\n@@ -88,19 +93,21 @@ rust_run_program(const char* argv[],\n     si.cb = sizeof(STARTUPINFO);\n     si.dwFlags = STARTF_USESTDHANDLES;\n \n+    RunProgramResult result = {-1, NULL};\n+\n     HANDLE curproc = GetCurrentProcess();\n     HANDLE origStdin = (HANDLE)_get_osfhandle(in_fd ? in_fd : 0);\n     if (!DuplicateHandle(curproc, origStdin,\n         curproc, &si.hStdInput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n     HANDLE origStdout = (HANDLE)_get_osfhandle(out_fd ? out_fd : 1);\n     if (!DuplicateHandle(curproc, origStdout,\n         curproc, &si.hStdOutput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n     HANDLE origStderr = (HANDLE)_get_osfhandle(err_fd ? err_fd : 2);\n     if (!DuplicateHandle(curproc, origStderr,\n         curproc, &si.hStdError, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n \n     size_t cmd_len = 0;\n     for (const char** arg = argv; *arg; arg++) {\n@@ -124,18 +131,39 @@ rust_run_program(const char* argv[],\n     CloseHandle(si.hStdError);\n     free(cmd);\n \n-    if (!created) return -1;\n-    return (int)pi.hProcess;\n+    if (!created) {\n+        return result;\n+    }\n+\n+    // We close the thread handle because we don't care about keeping the thread id valid,\n+    // and we aren't keeping the thread handle around to be able to close it later. We don't\n+    // close the process handle however because we want the process id to stay valid at least\n+    // until the calling rust code closes the process handle.\n+    CloseHandle(pi.hThread);\n+    result.pid = pi.dwProcessId;\n+    result.handle = pi.hProcess;\n+    return result;\n }\n \n extern \"C\" CDECL int\n-rust_process_wait(int proc) {\n+rust_process_wait(int pid) {\n+\n+    HANDLE proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid);\n+    if (proc == NULL) {\n+        return -1;\n+    }\n+\n     DWORD status;\n     while (true) {\n-        if (GetExitCodeProcess((HANDLE)proc, &status) &&\n-            status != STILL_ACTIVE)\n-            return (int)status;\n-        WaitForSingleObject((HANDLE)proc, INFINITE);\n+        if (!GetExitCodeProcess(proc, &status)) {\n+            CloseHandle(proc);\n+            return -1;\n+        }\n+        if (status != STILL_ACTIVE) {\n+            CloseHandle(proc);\n+            return (int) status;\n+        }\n+        WaitForSingleObject(proc, INFINITE);\n     }\n }\n \n@@ -151,13 +179,16 @@ rust_process_wait(int proc) {\n extern char **environ;\n #endif\n \n-extern \"C\" CDECL int\n+extern \"C\" CDECL RunProgramResult\n rust_run_program(const char* argv[],\n                  void* envp,\n                  const char* dir,\n                  int in_fd, int out_fd, int err_fd) {\n     int pid = fork();\n-    if (pid != 0) return pid;\n+    if (pid != 0) {\n+        RunProgramResult result = {pid, NULL};\n+        return result;\n+    }\n \n     sigset_t sset;\n     sigemptyset(&sset);\n@@ -187,7 +218,7 @@ rust_run_program(const char* argv[],\n }\n \n extern \"C\" CDECL int\n-rust_process_wait(int proc) {\n+rust_process_wait(int pid) {\n     // FIXME: stub; exists to placate linker. (#2692)\n     return 0;\n }"}]}