{"sha": "ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3", "node_id": "C_kwDOAAsO6NoAKGFjMDM0NzBjM2JhNDk1OWQ3NGNhMWI2MWE1N2UwYmNmYjZkMmQyZjM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-31T16:21:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-11-30T21:55:06Z"}, "message": "Flatten match.", "tree": {"sha": "1180f03a4faa54007faf0b56b7eb10ac9dae74f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1180f03a4faa54007faf0b56b7eb10ac9dae74f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3", "html_url": "https://github.com/rust-lang/rust/commit/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c44e93086d5476e8649d45b27ace321c66b05a39", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44e93086d5476e8649d45b27ace321c66b05a39", "html_url": "https://github.com/rust-lang/rust/commit/c44e93086d5476e8649d45b27ace321c66b05a39"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "85e704874e26c567844f43f2108f978ed23c97b5", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=ac03470c3ba4959d74ca1b61a57e0bcfb6d2d2f3", "patch": "@@ -3076,50 +3076,54 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Elision { ref elide, ref s, .. } => {\n-                    let lifetime = match *elide {\n-                        Elide::FreshLateAnon(named_late_bound_vars, ref counter) => {\n-                            for lifetime_ref in lifetime_refs {\n-                                let lifetime = Region::late_anon(named_late_bound_vars, counter)\n-                                    .shifted(late_depth);\n-\n-                                self.insert_lifetime(lifetime_ref, lifetime);\n-                            }\n-                            return;\n-                        }\n-                        Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => {\n-                            let mut scope = s;\n-                            loop {\n-                                match scope {\n-                                    Scope::Binder { ref lifetimes, s, .. } => {\n-                                        // Collect named lifetimes for suggestions.\n-                                        for name in lifetimes.keys() {\n-                                            if let hir::ParamName::Plain(name) = name {\n-                                                lifetime_names.insert(name.name);\n-                                                lifetime_spans.push(name.span);\n-                                            }\n-                                        }\n-                                        scope = s;\n-                                    }\n-                                    Scope::ObjectLifetimeDefault { ref s, .. }\n-                                    | Scope::Elision { ref s, .. }\n-                                    | Scope::TraitRefBoundary { ref s, .. } => {\n-                                        scope = s;\n+                Scope::Elision {\n+                    elide: Elide::FreshLateAnon(named_late_bound_vars, ref counter),\n+                    ..\n+                } => {\n+                    for lifetime_ref in lifetime_refs {\n+                        let lifetime =\n+                            Region::late_anon(named_late_bound_vars, counter).shifted(late_depth);\n+\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    return;\n+                }\n+\n+                Scope::Elision { elide: Elide::Exact(l), .. } => {\n+                    let lifetime = l.shifted(late_depth);\n+                    for lifetime_ref in lifetime_refs {\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    return;\n+                }\n+\n+                Scope::Elision { elide: Elide::Error(ref e), ref s, .. } => {\n+                    let mut scope = s;\n+                    loop {\n+                        match scope {\n+                            Scope::Binder { ref lifetimes, s, .. } => {\n+                                // Collect named lifetimes for suggestions.\n+                                for name in lifetimes.keys() {\n+                                    if let hir::ParamName::Plain(name) = name {\n+                                        lifetime_names.insert(name.name);\n+                                        lifetime_spans.push(name.span);\n                                     }\n-                                    _ => break,\n                                 }\n+                                scope = s;\n                             }\n-                            break Some(&e[..]);\n+                            Scope::ObjectLifetimeDefault { ref s, .. }\n+                            | Scope::Elision { ref s, .. }\n+                            | Scope::TraitRefBoundary { ref s, .. } => {\n+                                scope = s;\n+                            }\n+                            _ => break,\n                         }\n-                        Elide::Forbid => break None,\n-                    };\n-                    for lifetime_ref in lifetime_refs {\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n                     }\n-                    return;\n+                    break Some(&e[..]);\n                 }\n \n+                Scope::Elision { elide: Elide::Forbid, .. } => break None,\n+\n                 Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {"}]}