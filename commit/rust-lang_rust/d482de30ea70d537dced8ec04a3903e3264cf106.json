{"sha": "d482de30ea70d537dced8ec04a3903e3264cf106", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ODJkZTMwZWE3MGQ1MzdkY2VkOGVjMDRhMzkwM2UzMjY0Y2YxMDY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2021-01-01T04:27:33Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2021-01-01T04:27:33Z"}, "message": "Merge remote-tracking branch 'origin/master' into frewsxcv-san", "tree": {"sha": "67d6cd380ef7a66e785a54993bb0ca93b07b43ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67d6cd380ef7a66e785a54993bb0ca93b07b43ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d482de30ea70d537dced8ec04a3903e3264cf106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d482de30ea70d537dced8ec04a3903e3264cf106", "html_url": "https://github.com/rust-lang/rust/commit/d482de30ea70d537dced8ec04a3903e3264cf106", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d482de30ea70d537dced8ec04a3903e3264cf106/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26cc060756d0456b17fdc53ac5d34e7f7bdc873d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26cc060756d0456b17fdc53ac5d34e7f7bdc873d", "html_url": "https://github.com/rust-lang/rust/commit/26cc060756d0456b17fdc53ac5d34e7f7bdc873d"}, {"sha": "99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "html_url": "https://github.com/rust-lang/rust/commit/99ad5a1a2824fea1ecf60068fd3636beae7ea2da"}], "stats": {"total": 51133, "additions": 29563, "deletions": 21570}, "files": [{"sha": "3e42594c8280dc50b93fe31713b85194e4d71f1e", "filename": ".github/ISSUE_TEMPLATE/library_tracking_issue.md", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,63 @@\n+---\n+name: Library Tracking Issue\n+about: A tracking issue for an unstable library feature.\n+title: Tracking Issue for XXX\n+labels: C-tracking-issue, T-libs\n+---\n+<!--\n+Thank you for creating a tracking issue!\n+\n+Tracking issues are for tracking a feature from implementation to stabilization.\n+\n+Make sure to include the relevant RFC for the feature if it has one.\n+\n+If the new feature is small, it may be fine to skip the RFC process. In that\n+case, you can use use `issue = \"none\"` in your initial implementation PR. The\n+reviewer will ask you to open a tracking issue if they agree your feature can be\n+added without an RFC.\n+-->\n+\n+Feature gate: `#![feature(...)]`\n+\n+This is a tracking issue for ...\n+\n+<!--\n+Include a short description of the feature.\n+-->\n+\n+### Public API\n+\n+<!--\n+For most library features, it'd be useful to include a summarized version of the public API.\n+(E.g. just the public function signatures without their doc comments or implementation.)\n+-->\n+\n+```rust\n+...\n+```\n+\n+### Steps / History\n+\n+<!--\n+In the simplest case, this is a PR implementing the feature followed by a PR\n+that stabilises the feature. However it's not uncommon for the feature to be\n+changed before stabilization. For larger features, the implementation could be\n+split up in multiple steps.\n+-->\n+\n+- [ ] Implementation: ...\n+- [ ] Stabilization PR\n+\n+### Unresolved Questions\n+\n+<!--\n+Include any open questions that need to be answered before the feature can be\n+stabilised. If multiple (unrelated) big questions come up, it can be a good idea\n+to open a separate issue for each, to make it easier to keep track of the\n+discussions.\n+\n+It's useful to link any relevant discussions and conclusions (whether on GitHub,\n+Zulip, or the internals forum) here.\n+-->\n+\n+- None yet."}, {"sha": "4676e4127e83c62bdafc6f3696d8bd2fdacaa1fd", "filename": "Cargo.lock", "status": "modified", "additions": 90, "deletions": 19, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -355,6 +355,35 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"cargo-credential\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"cargo-credential-1password\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo-credential\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"cargo-credential-macos-keychain\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo-credential\",\n+ \"security-framework\",\n+]\n+\n+[[package]]\n+name = \"cargo-credential-wincred\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo-credential\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"cargo-miri\"\n version = \"0.1.0\"\n@@ -725,9 +754,6 @@ checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n [[package]]\n name = \"coverage_test_macros\"\n version = \"0.0.0\"\n-dependencies = [\n- \"proc-macro2\",\n-]\n \n [[package]]\n name = \"cpuid-bool\"\n@@ -869,9 +895,9 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.31\"\n+version = \"0.4.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9447ad28eee2a5cfb031c329d46bef77487244fff6a724b378885b8691a35f78\"\n+checksum = \"e268162af1a5fe89917ae25ba3b0a77c8da752bdc58e7dbb4f15b91fbd33756e\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n@@ -884,9 +910,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.34+curl-7.71.1\"\n+version = \"0.4.39+curl-7.74.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ad4eff0be6985b7e709f64b5a541f700e9ad1407190a29f4884319eb663ed1d6\"\n+checksum = \"07a8ce861e7b68a0b394e814d7ee9f1b2750ff8bd10372c6ad3bacc10e86f874\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1304,9 +1330,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.13.12\"\n+version = \"0.13.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca6f1a0238d7f8f8fd5ee642f4ebac4dbc03e03d1f78fbe7a3ede35dcf7e2224\"\n+checksum = \"186dd99cc77576e58344ad614fa9bb27bad9d048f85de3ca850c1f4e8b048260\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1319,9 +1345,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"502d532a2d06184beb3bc869d4d90236e60934e3382c921b203fa3c33e212bd7\"\n+checksum = \"883539cb0ea94bab3f8371a98cd8e937bbe9ee7c044499184aa4c17deb643a50\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -1348,6 +1374,15 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"gsgdt\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a0d876ce7262df96262a2a19531da6ff9a86048224d49580a585fc5c04617825\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"handlebars\"\n version = \"3.4.0\"\n@@ -1724,9 +1759,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.12.14+1.1.0\"\n+version = \"0.12.16+1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f25af58e6495f7caf2919d08f212de550cfa3ed2f5e744988938ea292b9f549\"\n+checksum = \"9f91b2f931ee975a98155195be8cd82d02e8e029d7d793d2bac1b8181ac97020\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -3400,6 +3435,7 @@ dependencies = [\n  \"byteorder\",\n  \"crossbeam-utils 0.7.2\",\n  \"libc\",\n+ \"libz-sys\",\n  \"proc-macro2\",\n  \"quote\",\n  \"serde\",\n@@ -3932,6 +3968,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec 1.4.2\",\n  \"tracing\",\n ]\n@@ -3942,6 +3979,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"coverage_test_macros\",\n  \"either\",\n+ \"gsgdt\",\n  \"itertools 0.9.0\",\n  \"polonius-engine\",\n  \"regex\",\n@@ -4266,6 +4304,16 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_type_ir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"rustc_data_structures\",\n+ \"rustc_index\",\n+ \"rustc_serialize\",\n+]\n+\n [[package]]\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n@@ -4349,7 +4397,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.29\"\n+version = \"1.4.30\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\",\n@@ -4424,6 +4472,29 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n+[[package]]\n+name = \"security-framework\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c1759c2e3c8580017a484a7ac56d3abc5a6c1feadf88db2f3633f12ae4268c69\"\n+dependencies = [\n+ \"bitflags\",\n+ \"core-foundation\",\n+ \"core-foundation-sys\",\n+ \"libc\",\n+ \"security-framework-sys\",\n+]\n+\n+[[package]]\n+name = \"security-framework-sys\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f99b9d5e26d2a71633cc4f2ebae7cc9f874044e0c351a27e17892d76dce5678b\"\n+dependencies = [\n+ \"core-foundation-sys\",\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"semver\"\n version = \"0.9.0\"\n@@ -4471,18 +4542,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.115\"\n+version = \"1.0.118\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e54c9a88f2da7238af84b5101443f0c0d0a3bbdc455e34a5c9497b1903ed55d5\"\n+checksum = \"06c64263859d87aa2eb554587e2d23183398d617427327cf2b3d0ed8c69e4800\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.115\"\n+version = \"1.0.118\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"609feed1d0a73cc36a0182a840a9b37b4a82f0b1150369f0536a9e3f2a31dc48\"\n+checksum = \"c84d3526699cd55261af4b941e4e725444df67aa4f9e6a3564f18030d12672df\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5272,7 +5343,7 @@ dependencies = [\n  \"chrono\",\n  \"lazy_static\",\n  \"matchers\",\n- \"parking_lot 0.11.0\",\n+ \"parking_lot 0.9.0\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\","}, {"sha": "204c92045b110a920d0ae84d140ffabb4894c95c", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -20,6 +20,9 @@ members = [\n   \"src/tools/rust-installer\",\n   \"src/tools/rust-demangler\",\n   \"src/tools/cargo\",\n+  \"src/tools/cargo/crates/credential/cargo-credential-1password\",\n+  \"src/tools/cargo/crates/credential/cargo-credential-macos-keychain\",\n+  \"src/tools/cargo/crates/credential/cargo-credential-wincred\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\","}, {"sha": "8f04980e390367dcf5bb9c187f710a00ead0d819", "filename": "RELEASES.md", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,3 +1,131 @@\n+Version 1.49.0 (2020-12-31)\n+============================\n+\n+Language\n+-----------------------\n+\n+- [Unions can now implement `Drop`, and you can now have a field in a union\n+  with `ManuallyDrop<T>`.][77547]\n+- [You can now cast uninhabited enums to integers.][76199]\n+- [You can now bind by reference and by move in patterns.][76119] This\n+  allows you to selectively borrow individual components of a type. E.g.\n+  ```rust\n+  #[derive(Debug)]\n+  struct Person {\n+      name: String,\n+      age: u8,\n+  }\n+\n+  let person = Person {\n+      name: String::from(\"Alice\"),\n+      age: 20,\n+  };\n+\n+  // `name` is moved out of person, but `age` is referenced.\n+  let Person { name, ref age } = person;\n+  println!(\"{} {}\", name, age);\n+  ```\n+\n+Compiler\n+-----------------------\n+\n+- [Added tier 1\\* support for `aarch64-unknown-linux-gnu`.][78228]\n+- [Added tier 2 support for `aarch64-apple-darwin`.][75991]\n+- [Added tier 2 support for `aarch64-pc-windows-msvc`.][75914]\n+- [Added tier 3 support for `mipsel-unknown-none`.][78676]\n+- [Raised the minimum supported LLVM version to LLVM 9.][78848]\n+- [Output from threads spawned in tests is now captured.][78227]\n+- [Change os and vendor values to \"none\" and \"unknown\" for some targets][78951]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+-----------------------\n+\n+- [`RangeInclusive` now checks for exhaustion when calling `contains` and indexing.][78109]\n+- [`ToString::to_string` now no longer shrinks the internal buffer in the default implementation.][77997]\n+- [`ops::{Index, IndexMut}` are now implemented for fixed sized arrays of any length.][74989]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`slice::select_nth_unstable`]\n+- [`slice::select_nth_unstable_by`]\n+- [`slice::select_nth_unstable_by_key`]\n+\n+The following previously stable methods are now `const`.\n+\n+- [`Poll::is_ready`]\n+- [`Poll::is_pending`]\n+\n+Cargo\n+-----------------------\n+- [Building a crate with `cargo-package` should now be independently reproducible.][cargo/8864]\n+- [`cargo-tree` now marks proc-macro crates.][cargo/8765]\n+- [Added `CARGO_PRIMARY_PACKAGE` build-time environment variable.][cargo/8758] This\n+  variable will be set if the crate being built is one the user selected to build, either\n+  with `-p` or through defaults.\n+- [You can now use glob patterns when specifying packages & targets.][cargo/8752]\n+\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Demoted `i686-unknown-freebsd` from host tier 2 to target tier 2 support.][78746]\n+- [Macros that end with a semi-colon are now treated as statements even if they expand to nothing.][78376]\n+- [Rustc will now check for the validity of some built-in attributes on enum variants.][77015]\n+  Previously such invalid or unused attributes could be ignored.\n+- Leading whitespace is stripped more uniformly in documentation comments, which may change behavior. You\n+  read [this post about the changes][rustdoc-ws-post] for more details.\n+- [Trait bounds are no longer inferred for associated types.][79904]\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [rustc's internal crates are now compiled using the `initial-exec` Thread\n+  Local Storage model.][78201]\n+- [Calculate visibilities once in resolve.][78077]\n+- [Added `system` to the `llvm-libunwind` bootstrap config option.][77703]\n+- [Added `--color` for configuring terminal color support to bootstrap.][79004]\n+\n+\n+[75991]: https://github.com/rust-lang/rust/pull/75991\n+[78951]: https://github.com/rust-lang/rust/pull/78951\n+[78848]: https://github.com/rust-lang/rust/pull/78848\n+[78746]: https://github.com/rust-lang/rust/pull/78746\n+[78376]: https://github.com/rust-lang/rust/pull/78376\n+[78228]: https://github.com/rust-lang/rust/pull/78228\n+[78227]: https://github.com/rust-lang/rust/pull/78227\n+[78201]: https://github.com/rust-lang/rust/pull/78201\n+[78109]: https://github.com/rust-lang/rust/pull/78109\n+[78077]: https://github.com/rust-lang/rust/pull/78077\n+[77997]: https://github.com/rust-lang/rust/pull/77997\n+[77703]: https://github.com/rust-lang/rust/pull/77703\n+[77547]: https://github.com/rust-lang/rust/pull/77547\n+[77015]: https://github.com/rust-lang/rust/pull/77015\n+[76199]: https://github.com/rust-lang/rust/pull/76199\n+[76119]: https://github.com/rust-lang/rust/pull/76119\n+[75914]: https://github.com/rust-lang/rust/pull/75914\n+[74989]: https://github.com/rust-lang/rust/pull/74989\n+[79004]: https://github.com/rust-lang/rust/pull/79004\n+[78676]: https://github.com/rust-lang/rust/pull/78676\n+[79904]: https://github.com/rust-lang/rust/issues/79904\n+[cargo/8864]: https://github.com/rust-lang/cargo/pull/8864\n+[cargo/8765]: https://github.com/rust-lang/cargo/pull/8765\n+[cargo/8758]: https://github.com/rust-lang/cargo/pull/8758\n+[cargo/8752]: https://github.com/rust-lang/cargo/pull/8752\n+[`slice::select_nth_unstable`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable\n+[`slice::select_nth_unstable_by`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by\n+[`slice::select_nth_unstable_by_key`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by_key\n+[`hint::spin_loop`]: https://doc.rust-lang.org/stable/std/hint/fn.spin_loop.html\n+[`Poll::is_ready`]: https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_ready\n+[`Poll::is_pending`]: https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_pending\n+[rustdoc-ws-post]: https://blog.guillaume-gomez.fr/articles/2020-11-11+New+doc+comment+handling+in+rustdoc\n+\n Version 1.48.0 (2020-11-19)\n ==========================\n \n@@ -10,7 +138,7 @@ Language\n Compiler\n --------\n - [Stabilised the `-C link-self-contained=<yes|no>` compiler flag.][76158] This tells\n-  `rustc` whether to link its own C runtime and libraries or to rely on a external \n+  `rustc` whether to link its own C runtime and libraries or to rely on a external\n   linker to find them. (Supported only on `windows-gnu`, `linux-musl`, and `wasi` platforms.)\n - [You can now use `-C target-feature=+crt-static` on `linux-gnu` targets.][77386]\n   Note: If you're using cargo you must explicitly pass the `--target` flag.\n@@ -82,7 +210,7 @@ Compatibility Notes\n - [Foreign exceptions are now caught by `catch_unwind` and will cause an abort.][70212]\n   Note: This behaviour is not guaranteed and is still considered undefined behaviour,\n   see the [`catch_unwind`] documentation for further information.\n-  \n+\n \n \n Internal Only\n@@ -102,7 +230,7 @@ related tools.\n [76030]: https://github.com/rust-lang/rust/pull/76030/\n [70212]: https://github.com/rust-lang/rust/pull/70212/\n [27675]: https://github.com/rust-lang/rust/issues/27675/\n-[54121]: https://github.com/rust-lang/rust/issues/54121/  \n+[54121]: https://github.com/rust-lang/rust/issues/54121/\n [71274]: https://github.com/rust-lang/rust/pull/71274/\n [77386]: https://github.com/rust-lang/rust/pull/77386/\n [77153]: https://github.com/rust-lang/rust/pull/77153/"}, {"sha": "a0493056b816b8c8df0e6db135a0e6e2a3d45483", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -16,7 +16,7 @@\n #![feature(new_uninit)]\n #![feature(maybe_uninit_slice)]\n #![feature(array_value_iter)]\n-#![feature(min_const_generics)]\n+#![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(min_specialization)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "cf31e566c384e1c5d52c68c909d7c52b311b5fe4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 20, "deletions": 53, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -167,10 +167,7 @@ pub enum GenericArgs {\n \n impl GenericArgs {\n     pub fn is_angle_bracketed(&self) -> bool {\n-        match *self {\n-            AngleBracketed(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, AngleBracketed(..))\n     }\n \n     pub fn span(&self) -> Span {\n@@ -629,23 +626,20 @@ impl Pat {\n \n     /// Is this a `..` pattern?\n     pub fn is_rest(&self) -> bool {\n-        match self.kind {\n-            PatKind::Rest => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, PatKind::Rest)\n     }\n }\n \n-/// A single field in a struct pattern\n+/// A single field in a struct pattern.\n ///\n-/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n-/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n-/// except is_shorthand is true\n+/// Patterns like the fields of `Foo { x, ref y, ref mut z }`\n+/// are treated the same as `x: x, y: ref y, z: ref mut z`,\n+/// except when `is_shorthand` is true.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FieldPat {\n-    /// The identifier for the field\n+    /// The identifier for the field.\n     pub ident: Ident,\n-    /// The pattern the field is destructured to\n+    /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n     pub attrs: AttrVec,\n@@ -852,10 +846,7 @@ impl BinOpKind {\n         }\n     }\n     pub fn lazy(&self) -> bool {\n-        match *self {\n-            BinOpKind::And | BinOpKind::Or => true,\n-            _ => false,\n-        }\n+        matches!(self, BinOpKind::And | BinOpKind::Or)\n     }\n \n     pub fn is_comparison(&self) -> bool {\n@@ -963,17 +954,11 @@ impl Stmt {\n     }\n \n     pub fn is_item(&self) -> bool {\n-        match self.kind {\n-            StmtKind::Item(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, StmtKind::Item(_))\n     }\n \n     pub fn is_expr(&self) -> bool {\n-        match self.kind {\n-            StmtKind::Expr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, StmtKind::Expr(_))\n     }\n }\n \n@@ -1107,15 +1092,9 @@ impl Expr {\n         if let ExprKind::Block(ref block, _) = self.kind {\n             match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n                 // Implicit return\n-                Some(&StmtKind::Expr(_)) => true,\n-                Some(&StmtKind::Semi(ref expr)) => {\n-                    if let ExprKind::Ret(_) = expr.kind {\n-                        // Last statement is explicit return.\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n+                Some(StmtKind::Expr(_)) => true,\n+                // Last statement is an explicit return?\n+                Some(StmtKind::Semi(expr)) => matches!(expr.kind, ExprKind::Ret(_)),\n                 // This is a block that doesn't end in either an implicit or explicit return.\n                 _ => false,\n             }\n@@ -1128,7 +1107,7 @@ impl Expr {\n     /// Is this expr either `N`, or `{ N }`.\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using\n-    /// `feature(min_const_generics)` as more complex expressions are not supported.\n+    /// `min_const_generics` as more complex expressions are not supported.\n     pub fn is_potential_trivial_const_param(&self) -> bool {\n         let this = if let ExprKind::Block(ref block, None) = self.kind {\n             if block.stmts.len() == 1 {\n@@ -1652,26 +1631,17 @@ pub enum LitKind {\n impl LitKind {\n     /// Returns `true` if this literal is a string.\n     pub fn is_str(&self) -> bool {\n-        match *self {\n-            LitKind::Str(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::Str(..))\n     }\n \n     /// Returns `true` if this literal is byte literal string.\n     pub fn is_bytestr(&self) -> bool {\n-        match self {\n-            LitKind::ByteStr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::ByteStr(_))\n     }\n \n     /// Returns `true` if this is a numeric literal.\n     pub fn is_numeric(&self) -> bool {\n-        match *self {\n-            LitKind::Int(..) | LitKind::Float(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::Int(..) | LitKind::Float(..))\n     }\n \n     /// Returns `true` if this literal has no suffix.\n@@ -1974,7 +1944,7 @@ impl TyKind {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n+        matches!(self, TyKind::Tup(tys) if tys.is_empty())\n     }\n }\n \n@@ -2237,10 +2207,7 @@ impl FnDecl {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map_or(false, |arg| match arg.ty.kind {\n-            TyKind::CVarArgs => true,\n-            _ => false,\n-        })\n+        self.inputs.last().map_or(false, |arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n     }\n }\n "}, {"sha": "726ae5e51f7a668c3ccb5b45d2312ba9179295b2", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -234,10 +234,7 @@ impl MetaItem {\n     }\n \n     pub fn is_word(&self) -> bool {\n-        match self.kind {\n-            MetaItemKind::Word => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, MetaItemKind::Word)\n     }\n \n     pub fn has_name(&self, name: Symbol) -> bool {"}, {"sha": "6dde304e8cfe5e6e0c500496923dec3ab2bcfac1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::ExpnKind;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, FileName, RealFileName, Span, DUMMY_SP};\n+use rustc_span::{self, edition::Edition, FileName, RealFileName, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n@@ -130,10 +130,7 @@ impl LitKind {\n     }\n \n     crate fn may_have_suffix(self) -> bool {\n-        match self {\n-            Integer | Float | Err => true,\n-            _ => false,\n-        }\n+        matches!(self, Integer | Float | Err)\n     }\n }\n \n@@ -305,10 +302,7 @@ impl TokenKind {\n     }\n \n     pub fn should_end_const_arg(&self) -> bool {\n-        match self {\n-            Gt | Ge | BinOp(Shr) | BinOpEq(Shr) => true,\n-            _ => false,\n-        }\n+        matches!(self, Gt | Ge | BinOp(Shr) | BinOpEq(Shr))\n     }\n }\n \n@@ -346,18 +340,21 @@ impl Token {\n     }\n \n     pub fn is_op(&self) -> bool {\n-        match self.kind {\n-            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)\n-            | Lifetime(..) | Interpolated(..) | Eof => false,\n-            _ => true,\n-        }\n+        !matches!(\n+            self.kind,\n+            OpenDelim(..)\n+                | CloseDelim(..)\n+                | Literal(..)\n+                | DocComment(..)\n+                | Ident(..)\n+                | Lifetime(..)\n+                | Interpolated(..)\n+                | Eof\n+        )\n     }\n \n     pub fn is_like_plus(&self) -> bool {\n-        match self.kind {\n-            BinOp(Plus) | BinOpEq(Plus) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, BinOp(Plus) | BinOpEq(Plus))\n     }\n \n     /// Returns `true` if the token can appear at the start of an expression.\n@@ -379,13 +376,10 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt) => match **nt {\n-                NtLiteral(..) |\n+            Interpolated(ref nt) => matches!(**nt, NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n-                NtPath(..) => true,\n-                _ => false,\n-            },\n+                NtPath(..)),\n             _ => false,\n         }\n     }\n@@ -405,10 +399,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt) => match **nt {\n-                NtTy(..) | NtPath(..) => true,\n-                _ => false,\n-            },\n+            Interpolated(ref nt) => matches!(**nt, NtTy(..) | NtPath(..)),\n             _ => false,\n         }\n     }\n@@ -417,10 +408,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt) => match **nt {\n-                NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n-                _ => false,\n-            },\n+            Interpolated(ref nt) => matches!(**nt, NtExpr(..) | NtBlock(..) | NtLiteral(..)),\n             _ => self.can_begin_literal_maybe_minus(),\n         }\n     }\n@@ -434,12 +422,9 @@ impl Token {\n             || self == &OpenDelim(Paren)\n     }\n \n-    /// Returns `true` if the token is any literal\n+    /// Returns `true` if the token is any literal.\n     pub fn is_lit(&self) -> bool {\n-        match self.kind {\n-            Literal(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, Literal(..))\n     }\n \n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n@@ -705,7 +690,16 @@ pub enum NonterminalKind {\n     Item,\n     Block,\n     Stmt,\n-    Pat,\n+    Pat2018 {\n+        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+        /// edition of the span. This is used for diagnostics.\n+        inferred: bool,\n+    },\n+    Pat2021 {\n+        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+        /// edition of the span. This is used for diagnostics.\n+        inferred: bool,\n+    },\n     Expr,\n     Ty,\n     Ident,\n@@ -718,12 +712,25 @@ pub enum NonterminalKind {\n }\n \n impl NonterminalKind {\n-    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+    /// The `edition` closure is used to get the edition for the given symbol. Doing\n+    /// `span.edition()` is expensive, so we do it lazily.\n+    pub fn from_symbol(\n+        symbol: Symbol,\n+        edition: impl FnOnce() -> Edition,\n+    ) -> Option<NonterminalKind> {\n         Some(match symbol {\n             sym::item => NonterminalKind::Item,\n             sym::block => NonterminalKind::Block,\n             sym::stmt => NonterminalKind::Stmt,\n-            sym::pat => NonterminalKind::Pat,\n+            sym::pat => match edition() {\n+                Edition::Edition2015 | Edition::Edition2018 => {\n+                    NonterminalKind::Pat2018 { inferred: true }\n+                }\n+                // FIXME(mark-i-m): uncomment when 2021 machinery is available.\n+                //Edition::Edition2021 => NonterminalKind::Pat2021{inferred:true},\n+            },\n+            sym::pat2018 => NonterminalKind::Pat2018 { inferred: false },\n+            sym::pat2021 => NonterminalKind::Pat2021 { inferred: false },\n             sym::expr => NonterminalKind::Expr,\n             sym::ty => NonterminalKind::Ty,\n             sym::ident => NonterminalKind::Ident,\n@@ -741,7 +748,10 @@ impl NonterminalKind {\n             NonterminalKind::Item => sym::item,\n             NonterminalKind::Block => sym::block,\n             NonterminalKind::Stmt => sym::stmt,\n-            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Pat2018 { inferred: false } => sym::pat2018,\n+            NonterminalKind::Pat2021 { inferred: false } => sym::pat2021,\n+            NonterminalKind::Pat2018 { inferred: true }\n+            | NonterminalKind::Pat2021 { inferred: true } => sym::pat,\n             NonterminalKind::Expr => sym::expr,\n             NonterminalKind::Ty => sym::ty,\n             NonterminalKind::Ident => sym::ident,"}, {"sha": "0550f53a96fb3838918925dbce66390109035a69", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -44,6 +44,12 @@ pub enum TokenTree {\n     Delimited(DelimSpan, DelimToken, TokenStream),\n }\n \n+#[derive(Copy, Clone)]\n+pub enum CanSynthesizeMissingTokens {\n+    Yes,\n+    No,\n+}\n+\n // Ensure all fields of `TokenTree` is `Send` and `Sync`.\n #[cfg(parallel_compiler)]\n fn _dummy()"}, {"sha": "90786520fe8025d5db38773f921d704e7fa80221", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,14 +12,14 @@ use crate::ast;\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n-    match e.kind {\n+    !matches!(\n+        e.kind,\n         ast::ExprKind::If(..)\n-        | ast::ExprKind::Match(..)\n-        | ast::ExprKind::Block(..)\n-        | ast::ExprKind::While(..)\n-        | ast::ExprKind::Loop(..)\n-        | ast::ExprKind::ForLoop(..)\n-        | ast::ExprKind::TryBlock(..) => false,\n-        _ => true,\n-    }\n+            | ast::ExprKind::Match(..)\n+            | ast::ExprKind::Block(..)\n+            | ast::ExprKind::While(..)\n+            | ast::ExprKind::Loop(..)\n+            | ast::ExprKind::ForLoop(..)\n+            | ast::ExprKind::TryBlock(..)\n+    )\n }"}, {"sha": "542a330a031414f469f52a256793b93c311f1fc7", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -25,9 +25,8 @@ pub struct Comment {\n \n /// Makes a doc string more presentable to users.\n /// Used by rustdoc and perhaps other tools, but not by rustc.\n-pub fn beautify_doc_string(data: Symbol) -> String {\n-    /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: Vec<String>) -> Vec<String> {\n+pub fn beautify_doc_string(data: Symbol) -> Symbol {\n+    fn get_vertical_trim(lines: &[&str]) -> Option<(usize, usize)> {\n         let mut i = 0;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n@@ -47,55 +46,58 @@ pub fn beautify_doc_string(data: Symbol) -> String {\n             j -= 1;\n         }\n \n-        lines[i..j].to_vec()\n+        if i != 0 || j != lines.len() { Some((i, j)) } else { None }\n     }\n \n-    /// remove a \"[ \\t]*\\*\" block from each line, if possible\n-    fn horizontal_trim(lines: Vec<String>) -> Vec<String> {\n+    fn get_horizontal_trim(lines: &[&str]) -> Option<usize> {\n         let mut i = usize::MAX;\n-        let mut can_trim = true;\n         let mut first = true;\n \n-        for line in &lines {\n+        for line in lines {\n             for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains(c) {\n-                    can_trim = false;\n-                    break;\n+                    return None;\n                 }\n                 if c == '*' {\n                     if first {\n                         i = j;\n                         first = false;\n                     } else if i != j {\n-                        can_trim = false;\n+                        return None;\n                     }\n                     break;\n                 }\n             }\n             if i >= line.len() {\n-                can_trim = false;\n-            }\n-            if !can_trim {\n-                break;\n+                return None;\n             }\n         }\n+        Some(i)\n+    }\n \n-        if can_trim {\n-            lines.iter().map(|line| (&line[i + 1..line.len()]).to_string()).collect()\n+    let data_s = data.as_str();\n+    if data_s.contains('\\n') {\n+        let mut lines = data_s.lines().collect::<Vec<&str>>();\n+        let mut changes = false;\n+        let lines = if let Some((i, j)) = get_vertical_trim(&lines) {\n+            changes = true;\n+            // remove whitespace-only lines from the start/end of lines\n+            &mut lines[i..j]\n         } else {\n-            lines\n+            &mut lines\n+        };\n+        if let Some(horizontal) = get_horizontal_trim(&lines) {\n+            changes = true;\n+            // remove a \"[ \\t]*\\*\" block from each line, if possible\n+            for line in lines.iter_mut() {\n+                *line = &line[horizontal + 1..];\n+            }\n+        }\n+        if changes {\n+            return Symbol::intern(&lines.join(\"\\n\"));\n         }\n     }\n-\n-    let data = data.as_str();\n-    if data.contains('\\n') {\n-        let lines = data.lines().map(|s| s.to_string()).collect::<Vec<String>>();\n-        let lines = vertical_trim(lines);\n-        let lines = horizontal_trim(lines);\n-        lines.join(\"\\n\")\n-    } else {\n-        data.to_string()\n-    }\n+    data\n }\n \n /// Returns `None` if the first `col` chars of `s` contain a non-whitespace char.\n@@ -178,10 +180,8 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n             }\n             rustc_lexer::TokenKind::BlockComment { doc_style, .. } => {\n                 if doc_style.is_none() {\n-                    let code_to_the_right = match text[pos + token.len..].chars().next() {\n-                        Some('\\r' | '\\n') => false,\n-                        _ => true,\n-                    };\n+                    let code_to_the_right =\n+                        !matches!(text[pos + token.len..].chars().next(), Some('\\r' | '\\n'));\n                     let style = match (code_to_the_left, code_to_the_right) {\n                         (_, true) => CommentStyle::Mixed,\n                         (false, false) => CommentStyle::Isolated,"}, {"sha": "98ab653e45f70e740da4226366cd194676986d14", "filename": "compiler/rustc_ast/src/util/comments/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -6,7 +6,7 @@ fn test_block_doc_comment_1() {\n     with_default_session_globals(|| {\n         let comment = \"\\n * Test \\n **  Test\\n *   Test\\n\";\n         let stripped = beautify_doc_string(Symbol::intern(comment));\n-        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n+        assert_eq!(stripped.as_str(), \" Test \\n*  Test\\n   Test\");\n     })\n }\n \n@@ -15,7 +15,7 @@ fn test_block_doc_comment_2() {\n     with_default_session_globals(|| {\n         let comment = \"\\n * Test\\n *  Test\\n\";\n         let stripped = beautify_doc_string(Symbol::intern(comment));\n-        assert_eq!(stripped, \" Test\\n  Test\");\n+        assert_eq!(stripped.as_str(), \" Test\\n  Test\");\n     })\n }\n \n@@ -24,20 +24,20 @@ fn test_block_doc_comment_3() {\n     with_default_session_globals(|| {\n         let comment = \"\\n let a: *i32;\\n *a = 5;\\n\";\n         let stripped = beautify_doc_string(Symbol::intern(comment));\n-        assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n+        assert_eq!(stripped.as_str(), \" let a: *i32;\\n *a = 5;\");\n     })\n }\n \n #[test]\n fn test_line_doc_comment() {\n     with_default_session_globals(|| {\n         let stripped = beautify_doc_string(Symbol::intern(\" test\"));\n-        assert_eq!(stripped, \" test\");\n+        assert_eq!(stripped.as_str(), \" test\");\n         let stripped = beautify_doc_string(Symbol::intern(\"! test\"));\n-        assert_eq!(stripped, \"! test\");\n+        assert_eq!(stripped.as_str(), \"! test\");\n         let stripped = beautify_doc_string(Symbol::intern(\"test\"));\n-        assert_eq!(stripped, \"test\");\n+        assert_eq!(stripped.as_str(), \"test\");\n         let stripped = beautify_doc_string(Symbol::intern(\"!test\"));\n-        assert_eq!(stripped, \"!test\");\n+        assert_eq!(stripped.as_str(), \"!test\");\n     })\n }"}, {"sha": "9b1642df1140142efa17274342c3e05de8e05734", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -505,14 +505,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n+        let pat = self.lower_pat(&arm.pat);\n+        let guard = arm.guard.as_ref().map(|cond| {\n+            if let ExprKind::Let(ref pat, ref scrutinee) = cond.kind {\n+                hir::Guard::IfLet(self.lower_pat(pat), self.lower_expr(scrutinee))\n+            } else {\n+                hir::Guard::If(self.lower_expr(cond))\n+            }\n+        });\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pat: self.lower_pat(&arm.pat),\n-            guard: match arm.guard {\n-                Some(ref x) => Some(hir::Guard::If(self.lower_expr(x))),\n-                _ => None,\n-            },\n+            pat,\n+            guard,\n             body: self.lower_expr(&arm.body),\n             span: arm.span,\n         }"}, {"sha": "d17b29089d6949832278459f0979c76a8ba0ac64", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 88, "deletions": 38, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -37,7 +37,7 @@\n \n use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n-use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, DelimSpan, TokenStream, TokenTree};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::{self as ast, *};\n@@ -206,7 +206,8 @@ pub trait ResolverAstLowering {\n     ) -> LocalDefId;\n }\n \n-type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n+type NtToTokenstream =\n+    fn(&Nonterminal, &ParseSess, Span, CanSynthesizeMissingTokens) -> TokenStream;\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n@@ -393,6 +394,47 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n+struct TokenStreamLowering<'a> {\n+    parse_sess: &'a ParseSess,\n+    synthesize_tokens: CanSynthesizeMissingTokens,\n+    nt_to_tokenstream: NtToTokenstream,\n+}\n+\n+impl<'a> TokenStreamLowering<'a> {\n+    fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n+        tokens.into_trees().flat_map(|tree| self.lower_token_tree(tree).into_trees()).collect()\n+    }\n+\n+    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n+        match tree {\n+            TokenTree::Token(token) => self.lower_token(token),\n+            TokenTree::Delimited(span, delim, tts) => {\n+                TokenTree::Delimited(span, delim, self.lower_token_stream(tts)).into()\n+            }\n+        }\n+    }\n+\n+    fn lower_token(&mut self, token: Token) -> TokenStream {\n+        match token.kind {\n+            token::Interpolated(nt) => {\n+                let tts = (self.nt_to_tokenstream)(\n+                    &nt,\n+                    self.parse_sess,\n+                    token.span,\n+                    self.synthesize_tokens,\n+                );\n+                TokenTree::Delimited(\n+                    DelimSpan::from_single(token.span),\n+                    DelimToken::NoDelim,\n+                    self.lower_token_stream(tts),\n+                )\n+                .into()\n+            }\n+            _ => TokenTree::Token(token).into(),\n+        }\n+    }\n+}\n+\n struct ImplTraitTypeIdVisitor<'a> {\n     ids: &'a mut SmallVec<[NodeId; 1]>,\n }\n@@ -955,40 +997,49 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n             MacArgs::Delimited(dspan, delim, ref tokens) => {\n-                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone()))\n-            }\n-            MacArgs::Eq(eq_span, ref tokens) => {\n-                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone()))\n-            }\n-        }\n-    }\n-\n-    fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens.into_trees().flat_map(|tree| self.lower_token_tree(tree).into_trees()).collect()\n-    }\n-\n-    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n-        match tree {\n-            TokenTree::Token(token) => self.lower_token(token),\n-            TokenTree::Delimited(span, delim, tts) => {\n-                TokenTree::Delimited(span, delim, self.lower_token_stream(tts)).into()\n+                // This is either a non-key-value attribute, or a `macro_rules!` body.\n+                // We either not have any nonterminals present (in the case of an attribute),\n+                // or have tokens available for all nonterminals in the case of a nested\n+                // `macro_rules`: e.g:\n+                //\n+                // ```rust\n+                // macro_rules! outer {\n+                //     ($e:expr) => {\n+                //         macro_rules! inner {\n+                //             () => { $e }\n+                //         }\n+                //     }\n+                // }\n+                // ```\n+                //\n+                // In both cases, we don't want to synthesize any tokens\n+                MacArgs::Delimited(\n+                    dspan,\n+                    delim,\n+                    self.lower_token_stream(tokens.clone(), CanSynthesizeMissingTokens::No),\n+                )\n             }\n+            // This is an inert key-value attribute - it will never be visible to macros\n+            // after it gets lowered to HIR. Therefore, we can synthesize tokens with fake\n+            // spans to handle nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n+            MacArgs::Eq(eq_span, ref tokens) => MacArgs::Eq(\n+                eq_span,\n+                self.lower_token_stream(tokens.clone(), CanSynthesizeMissingTokens::Yes),\n+            ),\n         }\n     }\n \n-    fn lower_token(&mut self, token: Token) -> TokenStream {\n-        match token.kind {\n-            token::Interpolated(nt) => {\n-                let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n-                TokenTree::Delimited(\n-                    DelimSpan::from_single(token.span),\n-                    DelimToken::NoDelim,\n-                    self.lower_token_stream(tts),\n-                )\n-                .into()\n-            }\n-            _ => TokenTree::Token(token).into(),\n+    fn lower_token_stream(\n+        &self,\n+        tokens: TokenStream,\n+        synthesize_tokens: CanSynthesizeMissingTokens,\n+    ) -> TokenStream {\n+        TokenStreamLowering {\n+            parse_sess: &self.sess.parse_sess,\n+            synthesize_tokens,\n+            nt_to_tokenstream: self.nt_to_tokenstream,\n         }\n+        .lower_token_stream(tokens)\n     }\n \n     /// Given an associated type constraint like one of these:\n@@ -1716,7 +1767,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         self.arena.alloc_from_iter(inputs.iter().map(|param| match param.pat.kind {\n             PatKind::Ident(_, ident, _) => ident,\n-            _ => Ident::new(kw::Invalid, param.pat.span),\n+            _ => Ident::new(kw::Empty, param.pat.span),\n         }))\n     }\n \n@@ -1806,12 +1857,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             output,\n             c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n-                let is_mutable_pat = match arg.pat.kind {\n-                    PatKind::Ident(BindingMode::ByValue(mt) | BindingMode::ByRef(mt), _, _) => {\n-                        mt == Mutability::Mut\n-                    }\n-                    _ => false,\n-                };\n+                use BindingMode::{ByRef, ByValue};\n+                let is_mutable_pat = matches!(\n+                    arg.pat.kind,\n+                    PatKind::Ident(ByValue(Mutability::Mut) | ByRef(Mutability::Mut), ..)\n+                );\n \n                 match arg.ty.kind {\n                     TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,"}, {"sha": "c40f00bc9e99bbab94a27abb0197825dcf781dfa", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -184,7 +184,7 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_lifetime(&self, ident: Ident) {\n-        let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Invalid];\n+        let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n             self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }\n@@ -400,7 +400,7 @@ impl<'a> AstValidator<'a> {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n             self.err_handler()\n-                .struct_span_err(span, \"`default` is only allowed on items in `impl` definitions\")\n+                .struct_span_err(span, \"`default` is only allowed on items in trait impls\")\n                 .span_label(def_span, \"`default` because of this\")\n                 .emit();\n         }\n@@ -717,35 +717,46 @@ impl<'a> AstValidator<'a> {\n \n /// Checks that generic parameters are in the correct order,\n /// which is lifetimes, then types and then consts. (`<'a, T, const N: usize>`)\n-fn validate_generic_param_order<'a>(\n+fn validate_generic_param_order(\n     sess: &Session,\n     handler: &rustc_errors::Handler,\n-    generics: impl Iterator<Item = (ParamKindOrd, Option<&'a [GenericBound]>, Span, Option<String>)>,\n+    generics: &[GenericParam],\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n     let mut out_of_order = FxHashMap::default();\n     let mut param_idents = vec![];\n \n-    for (kind, bounds, span, ident) in generics {\n+    for param in generics {\n+        let ident = Some(param.ident.to_string());\n+        let (kind, bounds, span) = (&param.kind, Some(&*param.bounds), param.ident.span);\n+        let (ord_kind, ident) = match &param.kind {\n+            GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident),\n+            GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n+            GenericParamKind::Const { ref ty, kw_span: _ } => {\n+                let ty = pprust::ty_to_string(ty);\n+                let unordered = sess.features_untracked().const_generics;\n+                (ParamKindOrd::Const { unordered }, Some(format!(\"const {}: {}\", param.ident, ty)))\n+            }\n+        };\n         if let Some(ident) = ident {\n-            param_idents.push((kind, bounds, param_idents.len(), ident));\n+            param_idents.push((kind, ord_kind, bounds, param_idents.len(), ident));\n         }\n         let max_param = &mut max_param;\n         match max_param {\n-            Some(max_param) if *max_param > kind => {\n-                let entry = out_of_order.entry(kind).or_insert((*max_param, vec![]));\n+            Some(max_param) if *max_param > ord_kind => {\n+                let entry = out_of_order.entry(ord_kind).or_insert((*max_param, vec![]));\n                 entry.1.push(span);\n             }\n-            Some(_) | None => *max_param = Some(kind),\n+            Some(_) | None => *max_param = Some(ord_kind),\n         };\n     }\n \n     let mut ordered_params = \"<\".to_string();\n     if !out_of_order.is_empty() {\n-        param_idents.sort_by_key(|&(po, _, i, _)| (po, i));\n+        param_idents.sort_by_key(|&(_, po, _, i, _)| (po, i));\n         let mut first = true;\n-        for (_, bounds, _, ident) in param_idents {\n+        for (kind, _, bounds, _, ident) in param_idents {\n             if !first {\n                 ordered_params += \", \";\n             }\n@@ -756,6 +767,16 @@ fn validate_generic_param_order<'a>(\n                     ordered_params += &pprust::bounds_to_string(&bounds);\n                 }\n             }\n+            match kind {\n+                GenericParamKind::Type { default: Some(default) } => {\n+                    ordered_params += \" = \";\n+                    ordered_params += &pprust::ty_to_string(default);\n+                }\n+                GenericParamKind::Type { default: None } => (),\n+                GenericParamKind::Lifetime => (),\n+                // FIXME(const_generics:defaults)\n+                GenericParamKind::Const { ty: _, kw_span: _ } => (),\n+            }\n             first = false;\n         }\n     }\n@@ -773,14 +794,12 @@ fn validate_generic_param_order<'a>(\n         err.span_suggestion(\n             span,\n             &format!(\n-                \"reorder the parameters: lifetimes{}\",\n+                \"reorder the parameters: lifetimes, {}\",\n                 if sess.features_untracked().const_generics {\n-                    \", then consts and types\"\n-                } else if sess.features_untracked().min_const_generics {\n-                    \", then types, then consts\"\n+                    \"then consts and types\"\n                 } else {\n-                    \", then types\"\n-                },\n+                    \"then types, then consts\"\n+                }\n             ),\n             ordered_params.clone(),\n             Applicability::MachineApplicable,\n@@ -1152,22 +1171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         validate_generic_param_order(\n             self.session,\n             self.err_handler(),\n-            generics.params.iter().map(|param| {\n-                let ident = Some(param.ident.to_string());\n-                let (kind, ident) = match &param.kind {\n-                    GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident),\n-                    GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n-                    GenericParamKind::Const { ref ty, kw_span: _ } => {\n-                        let ty = pprust::ty_to_string(ty);\n-                        let unordered = self.session.features_untracked().const_generics;\n-                        (\n-                            ParamKindOrd::Const { unordered },\n-                            Some(format!(\"const {}: {}\", param.ident, ty)),\n-                        )\n-                    }\n-                };\n-                (kind, Some(&*param.bounds), param.ident.span, ident)\n-            }),\n+            &generics.params,\n             generics.span,\n         );\n "}, {"sha": "6a9d6d2ed121eabad7d4405414c866b44a65e449", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocTyConstraint, AssocTyConstraintKind, NodeId};\n-use rustc_ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n+use rustc_ast::{PatKind, RangeEnd, VariantData};\n use rustc_errors::struct_span_err;\n use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n use rustc_feature::{Features, GateIssue};\n@@ -397,10 +397,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n                 let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n-                let links_to_llvm = match link_name {\n-                    Some(val) => val.as_str().starts_with(\"llvm.\"),\n-                    _ => false,\n-                };\n+                let links_to_llvm =\n+                    link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {\n                     gate_feature_post!(\n                         &self,\n@@ -529,19 +527,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, span)\n     }\n \n-    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        if let GenericParamKind::Const { .. } = param.kind {\n-            gate_feature_fn!(\n-                &self,\n-                |x: &Features| x.const_generics || x.min_const_generics,\n-                param.ident.span,\n-                sym::min_const_generics,\n-                \"const generics are unstable\"\n-            );\n-        }\n-        visit::walk_generic_param(self, param)\n-    }\n-\n     fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n         if let AssocTyConstraintKind::Bound { .. } = constraint.kind {\n             gate_feature_post!(\n@@ -620,7 +605,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n-    gate_all!(if_let_guard, \"`if let` guard is not implemented\");\n+    gate_all!(if_let_guard, \"`if let` guards are experimental\");\n     gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure, \"async closures are unstable\");\n     gate_all!(generators, \"yield syntax is experimental\");"}, {"sha": "ea298d28e72c6a983bc7409067d6273c635fbfca", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -75,15 +75,15 @@\n //! breaking inconsistently to become\n //!\n //! ```\n-//! foo(hello, there\n+//! foo(hello, there,\n //!     good, friends);\n //! ```\n //!\n //! whereas a consistent breaking would yield:\n //!\n //! ```\n //! foo(hello,\n-//!     there\n+//!     there,\n //!     good,\n //!     friends);\n //! ```"}, {"sha": "333a396a0b4fc694e9dfd07482e8807fe7eb09f0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2420,7 +2420,15 @@ impl<'a> State<'a> {\n                 if mutbl == ast::Mutability::Mut {\n                     self.s.word(\"mut \");\n                 }\n-                self.print_pat(inner);\n+                if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n+                    inner.kind\n+                {\n+                    self.popen();\n+                    self.print_pat(inner);\n+                    self.pclose();\n+                } else {\n+                    self.print_pat(inner);\n+                }\n             }\n             PatKind::Lit(ref e) => self.print_expr(&**e),\n             PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n@@ -2779,7 +2787,7 @@ impl<'a> State<'a> {\n                     self.print_explicit_self(&eself);\n                 } else {\n                     let invalid = if let PatKind::Ident(_, ident, _) = input.pat.kind {\n-                        ident.name == kw::Invalid\n+                        ident.name == kw::Empty\n                     } else {\n                         false\n                     };"}, {"sha": "ead90f23ce7a12f7dea70b9ac51430b63ec92951", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -621,7 +621,7 @@ pub fn eval_condition(\n     }\n }\n \n-#[derive(Encodable, Decodable, Clone, HashStable_Generic)]\n+#[derive(Debug, Encodable, Decodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     /// The note to issue a reason."}, {"sha": "ca1226b445d97beb94301349c1544660ea72cc1e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -38,10 +38,9 @@ pub fn expand_deriving_clone(\n             | ItemKind::Enum(_, Generics { ref params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n                 if cx.resolver.has_derive_copy(container_id)\n-                    && !params.iter().any(|param| match param.kind {\n-                        ast::GenericParamKind::Type { .. } => true,\n-                        _ => false,\n-                    })\n+                    && !params\n+                        .iter()\n+                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. }))\n                 {\n                     bounds = vec![];\n                     is_shallow = true;"}, {"sha": "e78d1368b357e5f0b1ff89fc34d9b71fc92bbea0", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -257,7 +257,10 @@ pub struct Substructure<'a> {\n     pub type_ident: Ident,\n     /// ident of the method\n     pub method_ident: Ident,\n-    /// dereferenced access to any `Self_` or `Ptr(Self_, _)` arguments\n+    /// dereferenced access to any [`Self_`] or [`Ptr(Self_, _)][ptr]` arguments\n+    ///\n+    /// [`Self_`]: ty::Ty::Self_\n+    /// [ptr]: ty::Ty::Ptr\n     pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n     pub nonself_args: &'a [P<Expr>],\n@@ -401,12 +404,10 @@ impl<'a> TraitDef<'a> {\n                 let has_no_type_params = match item.kind {\n                     ast::ItemKind::Struct(_, ref generics)\n                     | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => {\n-                        !generics.params.iter().any(|param| match param.kind {\n-                            ast::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        })\n-                    }\n+                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                        .params\n+                        .iter()\n+                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n@@ -597,10 +598,7 @@ impl<'a> TraitDef<'a> {\n \n             let mut ty_params = params\n                 .iter()\n-                .filter_map(|param| match param.kind {\n-                    ast::GenericParamKind::Type { .. } => Some(param),\n-                    _ => None,\n-                })\n+                .filter(|param| matches!(param.kind,  ast::GenericParamKind::Type{..}))\n                 .peekable();\n \n             if ty_params.peek().is_some() {\n@@ -868,7 +866,7 @@ impl<'a> MethodDef<'a> {\n                 Self_ if nonstatic => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(ref ty, _) if (if let Self_ = **ty { true } else { false }) && nonstatic => {\n+                Ptr(ref ty, _) if matches!(**ty, Self_) && nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {"}, {"sha": "85ca1da6f1daa1a9eba11b5895de321657135a27", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1044,10 +1044,7 @@ pub fn expand_preparsed_format_args(\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece<'_>| match *arg {\n         parse::String(_) => false,\n-        parse::NextArgument(arg) => match arg.position {\n-            parse::Position::ArgumentIs(_) => true,\n-            _ => false,\n-        },\n+        parse::NextArgument(arg) => matches!(arg.position, parse::Position::ArgumentIs(_)),\n     });\n \n     cx.build_index_map();"}, {"sha": "0496c72cb0050dfd6816e34928b256a89155612d", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -580,10 +580,7 @@ pub mod printf {\n     }\n \n     fn is_flag(c: &char) -> bool {\n-        match c {\n-            '0' | '-' | '+' | ' ' | '#' | '\\'' => true,\n-            _ => false,\n-        }\n+        matches!(c, '0' | '-' | '+' | ' ' | '#' | '\\'')\n     }\n \n     #[cfg(test)]"}, {"sha": "d72bfa660e58f855725ff145087abd63b2181af3", "filename": "compiler/rustc_builtin_macros/src/llvm_asm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -87,13 +87,15 @@ fn parse_inline_asm<'a>(\n     // parsed as `llvm_asm!(z)` with `z = \"x\": y` which is type ascription.\n     let first_colon = tts\n         .trees()\n-        .position(|tt| match tt {\n-            tokenstream::TokenTree::Token(Token { kind: token::Colon | token::ModSep, .. }) => true,\n-            _ => false,\n+        .position(|tt| {\n+            matches!(\n+                tt,\n+                tokenstream::TokenTree::Token(Token { kind: token::Colon | token::ModSep, .. })\n+            )\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(tts.trees().skip(first_colon).collect());\n-    let mut asm = kw::Invalid;\n+    let mut asm = kw::Empty;\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();"}, {"sha": "7582d9805390ec24295c9792a35c76bb3c0f4797", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -256,10 +256,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // we're just not interested in this item.\n         //\n         // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n-        let is_fn = match item.kind {\n-            ast::ItemKind::Fn(..) => true,\n-            _ => false,\n-        };\n+        let is_fn = matches!(item.kind, ast::ItemKind::Fn(..));\n \n         let mut found_attr: Option<&'a ast::Attribute> = None;\n "}, {"sha": "7618251acd5c26ae8972288cd292ed4afbe3cf89", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,6 +1,7 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.assist.importMergeBehaviour\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "0382835269d1fdef8cb38b6aeadd28282b885374", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -50,15 +50,15 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n [[package]]\n name = \"cranelift-bforest\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -76,7 +76,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-meta\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n@@ -85,28 +85,46 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-shared\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-entity\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-frontend\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"cranelift-jit\"\n+version = \"0.68.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cranelift-codegen\",\n+ \"cranelift-entity\",\n+ \"cranelift-module\",\n+ \"cranelift-native\",\n+ \"errno\",\n+ \"libc\",\n+ \"log\",\n+ \"region\",\n+ \"target-lexicon\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"cranelift-module\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -118,7 +136,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-native\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"raw-cpuid\",\n@@ -128,7 +146,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-object\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,23 +156,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"cranelift-simplejit\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n-dependencies = [\n- \"cranelift-codegen\",\n- \"cranelift-entity\",\n- \"cranelift-module\",\n- \"cranelift-native\",\n- \"errno\",\n- \"libc\",\n- \"log\",\n- \"region\",\n- \"target-lexicon\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"crc32fast\"\n version = \"1.2.1\"\n@@ -325,9 +326,9 @@ dependencies = [\n  \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n+ \"cranelift-jit\",\n  \"cranelift-module\",\n  \"cranelift-object\",\n- \"cranelift-simplejit\",\n  \"gimli\",\n  \"indexmap\",\n  \"libloading\","}, {"sha": "8e1933bb14e7c197fa8bb83050368c0187395c95", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n-cranelift-simplejit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n+cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n@@ -27,15 +27,15 @@ libloading = { version = \"0.6.0\", optional = true }\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n-#cranelift-simplejit = { path = \"../wasmtime/cranelift/simplejit\" }\n+#cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n \n #[patch.crates-io]\n #gimli = { path = \"../\" }\n \n [features]\n default = [\"jit\", \"inline_asm\"]\n-jit = [\"cranelift-simplejit\", \"libloading\"]\n+jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n \n [profile.dev]"}, {"sha": "22d9e00923f006f1711a5d6791fd8ac78ad9d827", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2,7 +2,7 @@\n \n > \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n \n-The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/master/cranelift).\n+The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift).\n This has the potential to improve compilation times in debug mode.\n If your project doesn't use any of the things listed under \"Not yet supported\", it should work fine.\n If not please open an issue.\n@@ -68,7 +68,15 @@ $ $cg_clif_dir/build/cargo.sh jit\n or\n \n ```bash\n-$ $cg_clif_dir/build/bin/cg_clif --jit my_crate.rs\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n ```\n \n ### Shell\n@@ -77,7 +85,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - --jit\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "990557694ead4a4282f943a825c31d23baff9e83", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -47,9 +47,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.65\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95752358c8f7552394baf48cd82695b345628ad3f170d607de3ca03b8dacca15\"\n+checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -141,9 +141,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.80\"\n+version = \"0.2.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+checksum = \"1482821306169ec4d07f6aca392a4681f66c75c9918aa49641a2595db64053cb\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "3dbd28c286a246f25677b2420cc6fb07410961c8", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,13 +5,14 @@ version = \"0.0.0\"\n \n [dependencies]\n core = { path = \"./sysroot_src/library/core\" }\n-compiler_builtins = \"0.1\"\n alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n alloc_system = { path = \"./alloc_system\" }\n \n+compiler_builtins = { version = \"=0.1.36\", default-features = false }\n+\n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }"}, {"sha": "015bbdfed4648ee106cb18d47f2e7217d7f30cd9", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,6 +15,8 @@ fn main() {\n     let stderr = ::std::io::stderr();\n     let mut stderr = stderr.lock();\n \n+    // FIXME support lazy jit when multi threading\n+    #[cfg(not(lazy_jit))]\n     std::thread::spawn(move || {\n         println!(\"Hello from another thread!\");\n     });"}, {"sha": "d6ad24bcf26ddf48007753c231b74bb11ac38281", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1 +1 @@\n-nightly-2020-11-27\n+nightly-2020-12-23"}, {"sha": "a3d6d303057b8050ed0d51c30c00ab0cbcf9d31c", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -10,7 +10,9 @@ cmd=$1\n shift || true\n \n if [[ \"$cmd\" = \"jit\" ]]; then\n-cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- --jit\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit -Cprefer-dynamic\n+elif [[ \"$cmd\" = \"lazy-jit\" ]]; then\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit-lazy -Cprefer-dynamic\n else\n cargo \"+${TOOLCHAIN}\" \"$cmd\" \"$@\"\n fi"}, {"sha": "15388926ec9ec62ddb5c707cc64c926317f75f09", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,7 +4,7 @@\n pushd $(dirname \"$0\")/../\n source build/config.sh\n popd\n-PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS --jit $0\n+PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/\n \n //! This program filters away uninteresting samples and trims uninteresting frames for stackcollapse"}, {"sha": "a61774f479ec7f9cb7ee3533042806ff61b21c05", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,7 +15,10 @@ function no_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC --jit example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] mini_core_hello_world\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] mini_core_hello_world (skipped)\"\n     fi\n@@ -37,7 +40,10 @@ function base_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] std_example\"\n-        $MY_RUSTC --jit example/std_example.rs --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] std_example\"\n+        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --cfg lazy_jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi"}, {"sha": "76e1987459f875bd72b84240317f69ac066b8d03", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx\n         ty::Generator(_, substs, _) => {\n             let sig = substs.as_generator().poly_sig();\n \n-            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv });\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n             let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);"}, {"sha": "0ce34c904bdcc43d274263f46035c5302d5b5a78", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -162,7 +162,7 @@ impl AddConstructor for ObjectProduct {\n }\n \n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::build_isa(sess, true).triple().clone();\n+    let triple = crate::build_isa(sess).triple().clone();\n \n     let binary_format = match triple.binary_format {\n         target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n@@ -193,7 +193,7 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n \n pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n     let mut builder = ObjectBuilder::new(\n-        crate::build_isa(sess, true),\n+        crate::build_isa(sess),\n         name + \".o\",\n         cranelift_module::default_libcall_names(),\n     )"}, {"sha": "34c9561d6762287a6113ee700e4042e6041b4352", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -118,6 +118,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n     context.dce(cx.module.isa()).unwrap();\n \n+    context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n+\n     // Define function\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n@@ -140,6 +142,16 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n+    if let Some(mach_compile_result) = &context.mach_compile_result {\n+        if let Some(disasm) = &mach_compile_result.disasm {\n+            crate::pretty_clif::write_ir_file(\n+                tcx,\n+                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n+    }\n+\n     // Define debuginfo for function\n     let isa = cx.module.isa();\n     let debug_context = &mut cx.debug_context;\n@@ -307,7 +319,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n-                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n+                let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n+                    || (targets.iter().count() == 1 && targets.iter().next().unwrap().0 == 0);\n+                if use_bool_opt {\n                     assert_eq!(targets.iter().count(), 1);\n                     let (then_value, then_block) = targets.iter().next().unwrap();\n                     let then_block = fx.get_block(then_block);\n@@ -325,12 +339,22 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let discr =\n                         crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n-                    if test_zero {\n-                        fx.bcx.ins().brz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                    if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n+                        &fx.bcx, discr, test_zero,\n+                    ) {\n+                        if taken {\n+                            fx.bcx.ins().jump(then_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     } else {\n-                        fx.bcx.ins().brnz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                        if test_zero {\n+                            fx.bcx.ins().brz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().brnz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     }\n                 } else {\n                     let mut switch = ::cranelift_frontend::Switch::new();"}, {"sha": "58e45b4e9b972fbb1adbc6bbe112015654cc4f4c", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -44,9 +44,7 @@ fn main() {\n     let mut callbacks = CraneliftPassesCallbacks::default();\n     rustc_driver::install_ice_hook();\n     let exit_code = rustc_driver::catch_with_exit_code(|| {\n-        let mut use_jit = false;\n-\n-        let mut args = std::env::args_os()\n+        let args = std::env::args_os()\n             .enumerate()\n             .map(|(i, arg)| {\n                 arg.into_string().unwrap_or_else(|arg| {\n@@ -56,23 +54,10 @@ fn main() {\n                     )\n                 })\n             })\n-            .filter(|arg| {\n-                if arg == \"--jit\" {\n-                    use_jit = true;\n-                    false\n-                } else {\n-                    true\n-                }\n-            })\n             .collect::<Vec<_>>();\n-        if use_jit {\n-            args.push(\"-Cprefer-dynamic\".to_string());\n-        }\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                config: rustc_codegen_cranelift::BackendConfig { use_jit },\n-            })\n+            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n         })));\n         run_compiler.run()\n     });"}, {"sha": "8ee4cd46c94e0d2f36591b39622912437b95c225", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -92,9 +92,7 @@ fn main() {\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         if use_clif {\n             run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                    config: rustc_codegen_cranelift::BackendConfig { use_jit: false },\n-                })\n+                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n             })));\n         }\n         run_compiler.run()"}, {"sha": "beff84fb2e217ae04445e7979f807ddebf7b65ab", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -100,7 +100,10 @@ fn codegen_static_ref<'tcx>(\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n-        matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}),\n+        matches!(\n+            fx.bcx.func.global_values[local_data_id],\n+            GlobalValueData::Symbol { tls: false, .. }\n+        ),\n         \"tls static referenced without Rvalue::ThreadLocalRef\"\n     );\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n@@ -447,7 +450,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        module.define_data(data_id, &data_ctx).unwrap();\n+        // FIXME don't duplicate definitions in lazy jit mode\n+        let _ = module.define_data(data_id, &data_ctx);\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "6160f9b78d8b3a6d9cd3cefde854f4ca60813f67", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -74,10 +74,7 @@ impl WriterRelocate {\n \n     /// Perform the collected relocations to be usable for JIT usage.\n     #[cfg(feature = \"jit\")]\n-    pub(super) fn relocate_for_jit(\n-        mut self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n-    ) -> Vec<u8> {\n+    pub(super) fn relocate_for_jit(mut self, jit_module: &cranelift_jit::JITModule) -> Vec<u8> {\n         use std::convert::TryInto;\n \n         for reloc in self.relocs.drain(..) {"}, {"sha": "49de927cdba059d0fd4c154bccae6737d46c916e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,11 +15,11 @@ pub(crate) struct UnwindContext<'tcx> {\n }\n \n impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n-            if isa.flags().is_pic() {\n+            if pic_eh_frame {\n                 cie.fde_address_encoding =\n                     gimli::DwEhPe(gimli::DW_EH_PE_pcrel.0 | gimli::DW_EH_PE_sdata4.0);\n             }\n@@ -80,7 +80,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     #[cfg(feature = \"jit\")]\n     pub(crate) unsafe fn register_jit(\n         self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n+        jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n         let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n             self.tcx,"}, {"sha": "16f9bfc99189f5cbe1e7f3d59b24f7cca8364b8c", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -8,7 +8,7 @@ use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n-use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n@@ -75,6 +75,7 @@ fn emit_module(\n             name,\n             kind,\n             object: Some(tmp_file),\n+            dwarf_object: None,\n             bytecode: None,\n         },\n         work_product,\n@@ -111,6 +112,7 @@ fn reuse_workproduct_for_cgu(\n         name: cgu.name().to_string(),\n         kind: ModuleKind::Regular,\n         object,\n+        dwarf_object: None,\n         bytecode: None,\n     }\n }\n@@ -144,11 +146,34 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         }\n     }\n \n-    let mut cx = crate::CodegenCx::new(tcx, module, tcx.sess.opts.debuginfo != DebugInfo::None);\n+    let mut cx = crate::CodegenCx::new(\n+        tcx,\n+        module,\n+        tcx.sess.opts.debuginfo != DebugInfo::None,\n+        true,\n+    );\n     super::predefine_mono_items(&mut cx, &mono_items);\n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-        super::codegen_mono_item(&mut cx, mono_item, linkage);\n+        match mono_item {\n+            MonoItem::Fn(inst) => {\n+                cx.tcx.sess.time(\"codegen fn\", || {\n+                    crate::base::codegen_fn(&mut cx, inst, linkage)\n+                });\n+            }\n+            MonoItem::Static(def_id) => {\n+                crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+            }\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let item = cx.tcx.hir().expect_item(hir_id);\n+                if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n+                    cx.global_asm.push_str(&*asm.as_str());\n+                    cx.global_asm.push_str(\"\\n\\n\");\n+                } else {\n+                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+                }\n+            }\n+        }\n     }\n     let (mut module, global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n@@ -234,7 +259,7 @@ pub(super) fn run_aot(\n     tcx.sess.abort_if_errors();\n \n     let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n-    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa());\n+    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n@@ -290,6 +315,7 @@ pub(super) fn run_aot(\n             name: metadata_cgu_name,\n             kind: ModuleKind::Metadata,\n             object: Some(tmp_file),\n+            dwarf_object: None,\n             bytecode: None,\n         })\n     } else {"}, {"sha": "9a42c675cc14498a1955983ce99e799a382ea63d", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 150, "deletions": 16, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,16 +1,23 @@\n //! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n //! files.\n \n+use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n use rustc_codegen_ssa::CrateInfo;\n+use rustc_middle::mir::mono::MonoItem;\n \n-use cranelift_simplejit::{SimpleJITBuilder, SimpleJITModule};\n+use cranelift_jit::{JITBuilder, JITModule};\n \n use crate::prelude::*;\n+use crate::{CodegenCx, CodegenMode};\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n+thread_local! {\n+    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+}\n+\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n@@ -35,12 +42,13 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = SimpleJITBuilder::with_isa(\n-        crate::build_isa(tcx.sess, false),\n+    let mut jit_builder = JITBuilder::with_isa(\n+        crate::build_isa(tcx.sess),\n         cranelift_module::default_libcall_names(),\n     );\n+    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n-    let mut jit_module = SimpleJITModule::new(jit_builder);\n+    let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n     let sig = Signature {\n@@ -66,20 +74,42 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false);\n+    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n-        super::time(tcx, \"codegen mono items\", || {\n-            super::predefine_mono_items(&mut cx, &mono_items);\n-            for (mono_item, (linkage, visibility)) in mono_items {\n-                let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-                super::codegen_mono_item(&mut cx, mono_item, linkage);\n+    super::time(tcx, \"codegen mono items\", || {\n+        super::predefine_mono_items(&mut cx, &mono_items);\n+        for (mono_item, (linkage, visibility)) in mono_items {\n+            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+            match mono_item {\n+                MonoItem::Fn(inst) => match codegen_mode {\n+                    CodegenMode::Aot => unreachable!(),\n+                    CodegenMode::Jit => {\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, inst, linkage)\n+                        });\n+                    }\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                },\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+                }\n+                MonoItem::GlobalAsm(hir_id) => {\n+                    let item = cx.tcx.hir().expect_item(hir_id);\n+                    tcx.sess\n+                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                }\n             }\n-            tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n-        });\n+        }\n+    });\n+\n+    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n+    jit_module.finalize_definitions();\n+\n     if !global_asm.is_empty() {\n-        tcx.sess.fatal(\"Global asm is not supported in JIT mode\");\n+        tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n+\n     crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n@@ -91,7 +121,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because --jit was passed\");\n+    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -107,11 +137,50 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    CURRENT_MODULE\n+        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n+\n     let ret = f(args.len() as c_int, argv.as_ptr());\n \n     std::process::exit(ret);\n }\n \n+#[no_mangle]\n+extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8 {\n+    rustc_middle::ty::tls::with(|tcx| {\n+        // lift is used to ensure the correct lifetime for instance.\n+        let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n+\n+        CURRENT_MODULE.with(|jit_module| {\n+            let mut jit_module = jit_module.borrow_mut();\n+            let jit_module = jit_module.as_mut().unwrap();\n+            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+\n+            let (name, sig) = crate::abi::get_function_name_and_sig(\n+                tcx,\n+                cx.module.isa().triple(),\n+                instance,\n+                true,\n+            );\n+            let func_id = cx\n+                .module\n+                .declare_function(&name, Linkage::Export, &sig)\n+                .unwrap();\n+            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n+            });\n+\n+            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            assert!(global_asm.is_empty());\n+            jit_module.finalize_definitions();\n+            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            jit_module.get_finalized_function(func_id)\n+        })\n+    })\n+}\n+\n fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n@@ -171,3 +240,68 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n \n     imported_symbols\n }\n+\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+    let tcx = cx.tcx;\n+\n+    let pointer_type = cx.module.target_config().pointer_type();\n+\n+    let (name, sig) =\n+        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let func_id = cx\n+        .module\n+        .declare_function(&name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let instance_ptr = Box::into_raw(Box::new(inst));\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_function(\n+            \"__clif_jit_fn\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(pointer_type)],\n+                returns: vec![AbiParam::new(pointer_type)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    let mut builder_ctx = FunctionBuilderContext::new();\n+    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let sig_ref = trampoline_builder.func.import_signature(sig);\n+\n+    let entry_block = trampoline_builder.create_block();\n+    trampoline_builder.append_block_params_for_function_params(entry_block);\n+    let fn_args = trampoline_builder\n+        .func\n+        .dfg\n+        .block_params(entry_block)\n+        .to_vec();\n+\n+    trampoline_builder.switch_to_block(entry_block);\n+    let instance_ptr = trampoline_builder\n+        .ins()\n+        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n+    let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n+    let call_inst = trampoline_builder\n+        .ins()\n+        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n+    trampoline_builder.ins().return_(&ret_vals);\n+\n+    cx.module\n+        .define_function(\n+            func_id,\n+            &mut Context::for_function(trampoline),\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+}"}, {"sha": "9f4ea9a386551f88436198bf27214f7f6902f39a", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 17, "deletions": 39, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -7,6 +7,7 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n+use crate::CodegenMode;\n \n mod aot;\n #[cfg(feature = \"jit\")]\n@@ -20,24 +21,25 @@ pub(crate) fn codegen_crate(\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    if config.use_jit {\n-        let is_executable = tcx\n-            .sess\n-            .crate_types()\n-            .contains(&rustc_session::config::CrateType::Executable);\n-        if !is_executable {\n-            tcx.sess.fatal(\"can't jit non-executable crate\");\n-        }\n+    match config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+        CodegenMode::Jit | CodegenMode::JitLazy => {\n+            let is_executable = tcx\n+                .sess\n+                .crate_types()\n+                .contains(&rustc_session::config::CrateType::Executable);\n+            if !is_executable {\n+                tcx.sess.fatal(\"can't jit non-executable crate\");\n+            }\n \n-        #[cfg(feature = \"jit\")]\n-        let _: ! = jit::run_jit(tcx);\n+            #[cfg(feature = \"jit\")]\n+            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n \n-        #[cfg(not(feature = \"jit\"))]\n-        tcx.sess\n-            .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            #[cfg(not(feature = \"jit\"))]\n+            tcx.sess\n+                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+        }\n     }\n-\n-    aot::run_aot(tcx, metadata, need_metadata_module)\n }\n \n fn predefine_mono_items<'tcx>(\n@@ -63,30 +65,6 @@ fn predefine_mono_items<'tcx>(\n     });\n }\n \n-fn codegen_mono_item<'tcx, M: Module>(\n-    cx: &mut crate::CodegenCx<'tcx, M>,\n-    mono_item: MonoItem<'tcx>,\n-    linkage: Linkage,\n-) {\n-    match mono_item {\n-        MonoItem::Fn(inst) => {\n-            cx.tcx\n-                .sess\n-                .time(\"codegen fn\", || crate::base::codegen_fn(cx, inst, linkage));\n-        }\n-        MonoItem::Static(def_id) => crate::constant::codegen_static(&mut cx.constants_cx, def_id),\n-        MonoItem::GlobalAsm(hir_id) => {\n-            let item = cx.tcx.hir().expect_item(hir_id);\n-            if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n-                cx.global_asm.push_str(&*asm.as_str());\n-                cx.global_asm.push_str(\"\\n\\n\");\n-            } else {\n-                bug!(\"Expected GlobalAsm found {:?}\", item);\n-            }\n-        }\n-    }\n-}\n-\n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n     if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n         .as_ref()"}, {"sha": "d58e4d499584210e78fda8527de716e4ccba5034", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -23,8 +23,8 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, a.layout());\n-            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n \n             let mut res = fx.bcx.ins().iconst(types::I32, 0);"}, {"sha": "be5b247bb9f0bf7e1a4db31c2ed9c3593a78b92e", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 14, "deletions": 55, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -171,27 +171,6 @@ macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     }\n }\n \n-fn lane_type_and_count<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-) -> (TyAndLayout<'tcx>, u16) {\n-    assert!(layout.ty.is_simd());\n-    let lane_count = match layout.fields {\n-        rustc_target::abi::FieldsShape::Array { stride: _, count } => u16::try_from(count).unwrap(),\n-        _ => unreachable!(\"lane_type_and_count({:?})\", layout),\n-    };\n-    let lane_layout = layout\n-        .field(\n-            &ty::layout::LayoutCx {\n-                tcx,\n-                param_env: ParamEnv::reveal_all(),\n-            },\n-            0,\n-        )\n-        .unwrap();\n-    (lane_layout, lane_count)\n-}\n-\n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n     let (element, count) = match &layout.abi {\n         Abi::Vector { element, count } => (element.clone(), *count),\n@@ -218,8 +197,10 @@ fn simd_for_each_lane<'tcx, M: Module>(\n ) {\n     let layout = val.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n@@ -248,8 +229,10 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane in 0..lane_count {\n@@ -269,13 +252,14 @@ fn simd_reduce<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n@@ -289,14 +273,14 @@ fn simd_reduce_bool<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n ) {\n-    let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n@@ -460,9 +444,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 \"abort\" => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"unreachable\" => {\n-                    trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n-                }\n                 \"transmute\" => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n@@ -575,12 +556,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n-        discriminant_value, (c ptr) {\n-            let pointee_layout = fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), pointee_layout);\n-            let discr = crate::discriminant::codegen_get_discriminant(fx, val, ret.layout());\n-            ret.write_cvalue(fx, discr);\n-        };\n         size_of_val, <T> (c ptr) {\n             let layout = fx.layout_of(T);\n             let size = if layout.is_unsized() {\n@@ -641,22 +616,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"wrapping_\"), (c x, c y) {\n-            assert_eq!(x.layout().ty, y.layout().ty);\n-            let bin_op = match intrinsic {\n-                \"wrapping_add\" => BinOp::Add,\n-                \"wrapping_sub\" => BinOp::Sub,\n-                \"wrapping_mul\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n-            };\n-            let res = crate::num::codegen_int_binop(\n-                fx,\n-                bin_op,\n-                x,\n-                y,\n-            );\n-            ret.write_cvalue(fx, res);\n-        };\n         _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n@@ -916,7 +875,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             dest.write_cvalue(fx, val);\n         };\n \n-        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n+        pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n                 fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n             let val = crate::constant::codegen_const_value("}, {"sha": "e0eb5c59590ffba54aeffe2931d933875cf9f093", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -73,11 +73,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n \n-            let (lane_type, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n \n-            assert_eq!(lane_type, ret_lane_type);\n-            assert_eq!(n, ret_lane_count);\n+            assert_eq!(lane_ty, ret_lane_ty);\n+            assert_eq!(u64::from(n), ret_lane_count);\n \n             let total_len = lane_count * 2;\n \n@@ -105,14 +105,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             for &idx in &indexes {\n-                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+                assert!(u64::from(idx) < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n             }\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n-                let in_lane = if in_idx < lane_count {\n+                let in_lane = if u64::from(in_idx) < lane_count {\n                     x.value_field(fx, mir::Field::new(in_idx.into()))\n                 } else {\n-                    y.value_field(fx, mir::Field::new((in_idx - lane_count).into()))\n+                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n                 };\n                 let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n                 out_lane.write_cvalue(fx, in_lane);\n@@ -131,7 +131,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, base.layout());\n+            let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -160,7 +160,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, v.layout());\n+            let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -212,12 +212,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n \n-            let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n             assert_eq!(lane_count, ret_lane_count);\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.into());\n+                let lane = mir::Field::new(lane.try_into().unwrap());\n                 let a_lane = a.value_field(fx, lane).load_scalar(fx);\n                 let b_lane = b.value_field(fx, lane).load_scalar(fx);\n                 let c_lane = c.value_field(fx, lane).load_scalar(fx);"}, {"sha": "6e4f3bf2898d827900ec449dafd08325ea77b886", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,7 +5,8 @@\n     associated_type_bounds,\n     never_type,\n     try_blocks,\n-    hash_drain_filter\n+    hash_drain_filter,\n+    str_split_once\n )]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n@@ -34,6 +35,7 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n+use std::str::FromStr;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -141,8 +143,8 @@ struct CodegenCx<'tcx, M: Module> {\n }\n \n impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa());\n+    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n+        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n         let debug_context = if debug_info {\n             Some(DebugContext::new(tcx, module.isa()))\n         } else {\n@@ -172,12 +174,55 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n }\n \n #[derive(Copy, Clone, Debug)]\n+pub enum CodegenMode {\n+    Aot,\n+    Jit,\n+    JitLazy,\n+}\n+\n+impl Default for CodegenMode {\n+    fn default() -> Self {\n+        CodegenMode::Aot\n+    }\n+}\n+\n+impl FromStr for CodegenMode {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"aot\" => Ok(CodegenMode::Aot),\n+            \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n+            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n pub struct BackendConfig {\n-    pub use_jit: bool,\n+    pub codegen_mode: CodegenMode,\n+}\n+\n+impl BackendConfig {\n+    fn from_opts(opts: &[String]) -> Result<Self, String> {\n+        let mut config = BackendConfig::default();\n+        for opt in opts {\n+            if let Some((name, value)) = opt.split_once('=') {\n+                match name {\n+                    \"mode\" => config.codegen_mode = value.parse()?,\n+                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n+                }\n+            } else {\n+                return Err(format!(\"Invalid option `{}`\", opt));\n+            }\n+        }\n+        Ok(config)\n+    }\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: BackendConfig,\n+    pub config: Option<BackendConfig>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -204,7 +249,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, self.config);\n+        let config = if let Some(config) = self.config {\n+            config\n+        } else {\n+            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n+        };\n+        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n \n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n \n@@ -250,17 +301,13 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     sess.target.llvm_target.parse().unwrap()\n }\n \n-fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n \n     let mut flags_builder = settings::builder();\n-    if enable_pic {\n-        flags_builder.enable(\"is_pic\").unwrap();\n-    } else {\n-        flags_builder.set(\"is_pic\", \"false\").unwrap();\n-    }\n+    flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n         .set(\n@@ -283,8 +330,6 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n-    // FIXME(CraneStation/cranelift#732) fix LICM in presence of jump tables\n-    /*\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n@@ -297,7 +342,7 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n         OptLevel::Size | OptLevel::SizeMin => {\n             sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n         }\n-    }*/\n+    }\n \n     let flags = settings::Flags::new(flags_builder);\n \n@@ -311,7 +356,5 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend {\n-        config: BackendConfig { use_jit: false },\n-    })\n+    Box::new(CraneliftCodegenBackend { config: None })\n }"}, {"sha": "a575ed8dc35f80b0a3662df42cade581ab5cf672", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -73,11 +73,48 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     })()\n     .unwrap_or_else(|| {\n         match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I32 => {\n+            types::I8 | types::I16 => {\n                 // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n                 bcx.ins().uextend(types::I32, arg)\n             }\n             _ => arg,\n         }\n     })\n }\n+\n+/// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n+pub(crate) fn maybe_known_branch_taken(\n+    bcx: &FunctionBuilder<'_>,\n+    arg: Value,\n+    test_zero: bool,\n+) -> Option<bool> {\n+    let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        arg_inst\n+    } else {\n+        return None;\n+    };\n+\n+    match bcx.func.dfg[arg_inst] {\n+        InstructionData::UnaryBool {\n+            opcode: Opcode::Bconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(!imm)\n+            } else {\n+                Some(imm)\n+            }\n+        }\n+        InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(imm.bits() == 0)\n+            } else {\n+                Some(imm.bits() != 0)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "22c94fec82fc13a61b03ff1063376ecef26f652d", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -53,6 +53,7 @@\n //! ```\n \n use std::fmt;\n+use std::io::Write;\n \n use cranelift_codegen::{\n     entity::SecondaryMap,\n@@ -200,32 +201,24 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    postfix: &str,\n-    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n-    instance: Instance<'tcx>,\n-    context: &cranelift_codegen::Context,\n-    mut clif_comments: &CommentWriter,\n-) {\n-    use std::io::Write;\n-\n-    if !cfg!(debug_assertions)\n-        && !tcx\n+pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n+    cfg!(debug_assertions)\n+        || tcx\n             .sess\n             .opts\n             .output_types\n             .contains_key(&OutputType::LlvmAssembly)\n-    {\n+}\n+\n+pub(crate) fn write_ir_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    name: &str,\n+    write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n+) {\n+    if !should_write_ir(tcx) {\n         return;\n     }\n \n-    let value_ranges = isa.map(|isa| {\n-        context\n-            .build_value_labels_ranges(isa)\n-            .expect(\"value location ranges\")\n-    });\n-\n     let clif_output_dir = tcx.output_filenames(LOCAL_CRATE).with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n@@ -234,41 +227,58 @@ pub(crate) fn write_clif_file<'tcx>(\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(format!(\n-        \"{}.{}.clif\",\n-        tcx.symbol_name(instance).name,\n-        postfix\n-    ));\n-\n-    let mut clif = String::new();\n-    cranelift_codegen::write::decorate_function(\n-        &mut clif_comments,\n-        &mut clif,\n-        &context.func,\n-        &DisplayFunctionAnnotations {\n-            isa: Some(&*crate::build_isa(\n-                tcx.sess, true, /* PIC doesn't matter here */\n-            )),\n-            value_ranges: value_ranges.as_ref(),\n-        },\n-    )\n-    .unwrap();\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res: std::io::Result<()> = try {\n         let mut file = std::fs::File::create(clif_file_name)?;\n-        let target_triple = crate::target_triple(tcx.sess);\n-        writeln!(file, \"test compile\")?;\n-        writeln!(file, \"set is_pic\")?;\n-        writeln!(file, \"set enable_simd\")?;\n-        writeln!(file, \"target {} haswell\", target_triple)?;\n-        writeln!(file)?;\n-        file.write_all(clif.as_bytes())?;\n+        write(&mut file)?;\n     };\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"err writing clif file: {}\", err));\n+        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }\n }\n \n+pub(crate) fn write_clif_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    postfix: &str,\n+    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n+    instance: Instance<'tcx>,\n+    context: &cranelift_codegen::Context,\n+    mut clif_comments: &CommentWriter,\n+) {\n+    write_ir_file(\n+        tcx,\n+        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n+        |file| {\n+            let value_ranges = isa.map(|isa| {\n+                context\n+                    .build_value_labels_ranges(isa)\n+                    .expect(\"value location ranges\")\n+            });\n+\n+            let mut clif = String::new();\n+            cranelift_codegen::write::decorate_function(\n+                &mut clif_comments,\n+                &mut clif,\n+                &context.func,\n+                &DisplayFunctionAnnotations {\n+                    isa: Some(&*crate::build_isa(tcx.sess)),\n+                    value_ranges: value_ranges.as_ref(),\n+                },\n+            )\n+            .unwrap();\n+\n+            writeln!(file, \"test compile\")?;\n+            writeln!(file, \"set is_pic\")?;\n+            writeln!(file, \"set enable_simd\")?;\n+            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+            writeln!(file)?;\n+            file.write_all(clif.as_bytes())?;\n+            Ok(())\n+        },\n+    );\n+}\n+\n impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;"}, {"sha": "5bcb11fd515a0f925d2054860706d61ef9348b82", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -480,17 +480,19 @@ impl<'tcx> CPlace<'tcx> {\n                     // fn(&T) -> for<'l> fn(&'l T) is allowed\n                 }\n                 (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n-                    let from_traits = fx\n-                        .tcx\n-                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from_traits);\n-                    let to_traits = fx\n-                        .tcx\n-                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_traits);\n-                    assert_eq!(\n-                        from_traits, to_traits,\n-                        \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                        from_traits, to_traits, fx,\n-                    );\n+                    for (from, to) in from_traits.iter().zip(to_traits) {\n+                        let from = fx\n+                            .tcx\n+                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                        let to = fx\n+                            .tcx\n+                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                        assert_eq!(\n+                            from, to,\n+                            \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                            from_traits, to_traits, fx,\n+                        );\n+                    }\n                     // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n                 }\n                 _ => {"}, {"sha": "8f15586a9dc06b8c2444280a3d80509cefb36552", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -158,7 +158,8 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    // FIXME don't duplicate definitions in lazy jit mode\n+    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n \n     data_id\n }"}, {"sha": "29415973ed0739a7d1cc43d4e44e7b07255453f2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -6,7 +6,9 @@ use crate::llvm::{self, build_string, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::FxHashMap;\n@@ -728,20 +730,23 @@ pub unsafe fn optimize_thin_module(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n-    let tm = (cgcx.tm_factory.0)().map_err(|e| write::llvm_err(&diag_handler, &e))?;\n+\n+    let module_name = &thin_module.shared.module_names[thin_module.idx];\n+    let split_dwarf_file = cgcx\n+        .output_filenames\n+        .split_dwarf_filename(cgcx.split_dwarf_kind, Some(module_name.to_str().unwrap()));\n+    let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+    let tm =\n+        (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n \n     // Right now the implementation we've got only works over serialized\n     // modules, so we create a fresh new LLVM context and parse the module\n     // into that context. One day, however, we may do this for upstream\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw = parse_module(\n-        llcx,\n-        &thin_module.shared.module_names[thin_module.idx],\n-        thin_module.data(),\n-        &diag_handler,\n-    )? as *const _;\n+    let llmod_raw =\n+        parse_module(llcx, &module_name, thin_module.data(), &diag_handler)? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm { llmod_raw, llcx, tm },\n         name: thin_module.name().to_string(),"}, {"sha": "230e11f274eaebecd52c30dc8ce93231a6a1f1ef", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -11,7 +11,10 @@ use crate::llvm_util;\n use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n use crate::ModuleLlvm;\n-use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    BitcodeSection, CodegenContext, EmitObj, ModuleConfig, TargetMachineFactoryConfig,\n+    TargetMachineFactoryFn,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -20,7 +23,9 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{\n+    self, Lto, OutputType, Passes, SanitizerSet, SplitDwarfKind, SwitchWithOptPath,\n+};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n@@ -49,11 +54,31 @@ pub fn write_output_file(\n     pm: &llvm::PassManager<'ll>,\n     m: &'ll llvm::Module,\n     output: &Path,\n+    dwo_output: Option<&Path>,\n     file_type: llvm::FileType,\n ) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path_to_c_string(output);\n-        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n+        let result = if let Some(dwo_output) = dwo_output {\n+            let dwo_output_c = path_to_c_string(dwo_output);\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                dwo_output_c.as_ptr(),\n+                file_type,\n+            )\n+        } else {\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                std::ptr::null(),\n+                file_type,\n+            )\n+        };\n         result.into_result().map_err(|()| {\n             let msg = format!(\"could not write output to {}\", output.display());\n             llvm_err(handler, &msg)\n@@ -62,12 +87,17 @@ pub fn write_output_file(\n }\n \n pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(sess, config::OptLevel::No)()\n+    let config = TargetMachineFactoryConfig { split_dwarf_file: None };\n+    target_machine_factory(sess, config::OptLevel::No)(config)\n         .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n }\n \n-pub fn create_target_machine(tcx: TyCtxt<'_>) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))()\n+pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n+    let split_dwarf_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(mod_name));\n+    let config = TargetMachineFactoryConfig { split_dwarf_file };\n+    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n@@ -122,7 +152,7 @@ fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n pub fn target_machine_factory(\n     sess: &Session,\n     optlvl: config::OptLevel,\n-) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+) -> TargetMachineFactoryFn<LlvmCodegenBackend> {\n     let reloc_model = to_llvm_relocation_model(sess.relocation_model());\n \n     let (opt_level, _) = to_llvm_opt_settings(optlvl);\n@@ -163,7 +193,10 @@ pub fn target_machine_factory(\n     let use_init_array =\n         !sess.opts.debugging_opts.use_ctors_section.unwrap_or(sess.target.use_ctors_section);\n \n-    Arc::new(move || {\n+    Arc::new(move |config: TargetMachineFactoryConfig| {\n+        let split_dwarf_file = config.split_dwarf_file.unwrap_or_default();\n+        let split_dwarf_file = CString::new(split_dwarf_file.to_str().unwrap()).unwrap();\n+\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n                 triple.as_ptr(),\n@@ -182,6 +215,7 @@ pub fn target_machine_factory(\n                 emit_stack_size_section,\n                 relax_elf_relocations,\n                 use_init_array,\n+                split_dwarf_file.as_ptr(),\n             )\n         };\n \n@@ -451,7 +485,7 @@ pub(crate) unsafe fn optimize(\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n-) -> Result<(), FatalError> {\n+) {\n     let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n@@ -477,7 +511,7 @@ pub(crate) unsafe fn optimize(\n                 _ => llvm::OptStage::PreLinkNoLTO,\n             };\n             optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n-            return Ok(());\n+            return;\n         }\n \n         if cgcx.prof.llvm_recording_enabled() {\n@@ -600,7 +634,6 @@ pub(crate) unsafe fn optimize(\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n     }\n-    Ok(())\n }\n \n unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n@@ -785,7 +818,15 @@ pub(crate) unsafe fn codegen(\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n+                write_output_file(\n+                    diag_handler,\n+                    tm,\n+                    cpm,\n+                    llmod,\n+                    &path,\n+                    None,\n+                    llvm::FileType::AssemblyFile,\n+                )\n             })?;\n         }\n \n@@ -794,13 +835,23 @@ pub(crate) unsafe fn codegen(\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+\n+                let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n+                let dwo_out = match cgcx.split_dwarf_kind {\n+                    // Don't change how DWARF is emitted in single mode (or when disabled).\n+                    SplitDwarfKind::None | SplitDwarfKind::Single => None,\n+                    // Emit (a subset of the) DWARF into a separate file in split mode.\n+                    SplitDwarfKind::Split => Some(dwo_out.as_path()),\n+                };\n+\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(\n                         diag_handler,\n                         tm,\n                         cpm,\n                         llmod,\n                         &obj_out,\n+                        dwo_out,\n                         llvm::FileType::ObjectFile,\n                     )\n                 })?;\n@@ -828,6 +879,7 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n+        cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "d5be3132dee10fbe29f8e8667cd82dfe447b8dd7", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,17 +1,15 @@\n-//! Codegen the completed AST to the LLVM IR.\n-//!\n-//! Some functions here, such as codegen_block and codegen_expr, return a value --\n-//! the result of the codegen to LLVM -- while others, such as codegen_fn\n-//! and mono_item, are called only for the side effect of adding a\n-//! particular definition to the LLVM IR output we're producing.\n+//! Codegen the MIR to the LLVM IR.\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//! * There's no way to find out the [`Ty`] type of a [`Value`]. Doing so\n //!   would be \"trying to get the eggs out of an omelette\" (credit:\n-//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n-//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n-//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n+//!   pcwalton). You can, instead, find out its [`llvm::Type`] by calling [`val_ty`],\n+//!   but one [`llvm::Type`] corresponds to many [`Ty`]s; for instance, `tup(int, int,\n+//!   int)` and `rec(x=int, y=int, z=int)` will have the same [`llvm::Type`].\n+//!\n+//! [`Ty`]: rustc_middle::ty::Ty\n+//! [`val_ty`]: common::val_ty\n \n use super::ModuleLlvm;\n "}, {"sha": "58af9d4cd04a9d116a1b9e1a91f9123fbb5382de", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -314,6 +314,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n+/// Get the [LLVM type][Type] of a [`Value`].\n pub fn val_ty(v: &Value) -> &Type {\n     unsafe { llvm::LLVMTypeOf(v) }\n }"}, {"sha": "36a21b38c035d27876ebedd8b398d91844c1ea1d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -993,9 +993,15 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-    let split_name = \"\";\n+\n+    let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n+    let split_name = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(codegen_unit_name))\n+        .unwrap_or_default();\n+    let out_dir = out_dir.to_str().unwrap();\n+    let split_name = split_name.to_str().unwrap();\n \n     // FIXME(#60020):\n     //\n@@ -1020,8 +1026,8 @@ pub fn compile_unit_metadata(\n             debug_context.builder,\n             name_in_debuginfo.as_ptr().cast(),\n             name_in_debuginfo.len(),\n-            work_dir.as_ptr().cast(),\n-            work_dir.len(),\n+            out_dir.as_ptr().cast(),\n+            out_dir.len(),\n             llvm::ChecksumKind::None,\n             ptr::null(),\n             0,\n@@ -1039,6 +1045,8 @@ pub fn compile_unit_metadata(\n             split_name.as_ptr().cast(),\n             split_name.len(),\n             kind,\n+            0,\n+            tcx.sess.opts.debugging_opts.split_dwarf_inlining,\n         );\n \n         if tcx.sess.opts.debugging_opts.profile {\n@@ -1409,10 +1417,11 @@ fn generator_layout_and_saved_local_names(\n \n     let state_arg = mir::Local::new(1);\n     for var in &body.var_debug_info {\n-        if var.place.local != state_arg {\n+        let place = if let mir::VarDebugInfoContents::Place(p) = var.value { p } else { continue };\n+        if place.local != state_arg {\n             continue;\n         }\n-        match var.place.projection[..] {\n+        match place.projection[..] {\n             [\n                 // Deref of the `Pin<&mut Self>` state argument.\n                 mir::ProjectionElem::Field(..),\n@@ -2313,13 +2322,13 @@ fn set_members_of_composite_type(\n             DIB(cx),\n             composite_type_metadata,\n             Some(type_array),\n-            type_params,\n+            Some(type_params),\n         );\n     }\n }\n \n /// Computes the type parameters for a type, if any, for the given metadata.\n-fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'ll DIArray> {\n+fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIArray {\n     if let ty::Adt(def, substs) = *ty.kind() {\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n@@ -2349,10 +2358,10 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n                 })\n                 .collect();\n \n-            return Some(create_DIArray(DIB(cx), &template_params[..]));\n+            return create_DIArray(DIB(cx), &template_params[..]);\n         }\n     }\n-    return Some(create_DIArray(DIB(cx), &[]));\n+    return create_DIArray(DIB(cx), &[]);\n \n     fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n         let mut names = generics"}, {"sha": "bf0d499e6c4919b433095c08e9e41dc716301c9f", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -854,8 +854,8 @@ fn generic_simd_intrinsic(\n         ));\n     }\n \n-    if name_str.starts_with(\"simd_shuffle\") {\n-        let n: u64 = name_str[\"simd_shuffle\".len()..].parse().unwrap_or_else(|_| {\n+    if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n+        let n: u64 = stripped.parse().unwrap_or_else(|_| {\n             span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n         });\n "}, {"sha": "92ac770aca554ed338b9c4b5056933884da0e8b1", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -19,7 +19,9 @@ use back::write::{create_informational_target_machine, create_target_machine};\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n-use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig, TargetMachineFactoryFn,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n@@ -34,7 +36,6 @@ use rustc_span::symbol::Symbol;\n \n use std::any::Any;\n use std::ffi::CStr;\n-use std::sync::Arc;\n \n mod back {\n     pub mod archive;\n@@ -109,7 +110,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         sess: &Session,\n         optlvl: OptLevel,\n-    ) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+    ) -> TargetMachineFactoryFn<Self> {\n         back::write::target_machine_factory(sess, optlvl)\n     }\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n@@ -159,7 +160,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError> {\n-        back::write::optimize(cgcx, diag_handler, module, config)\n+        Ok(back::write::optimize(cgcx, diag_handler, module, config))\n     }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n@@ -297,21 +298,19 @@ impl CodegenBackend for LlvmCodegenBackend {\n         codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n+        use crate::back::archive::LlvmArchiveBuilder;\n+        use rustc_codegen_ssa::back::link::link_binary;\n+\n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.time(\"link_crate\", || {\n-            use crate::back::archive::LlvmArchiveBuilder;\n-            use rustc_codegen_ssa::back::link::link_binary;\n-\n-            let target_cpu = crate::llvm_util::target_cpu(sess);\n-            link_binary::<LlvmArchiveBuilder<'_>>(\n-                sess,\n-                &codegen_results,\n-                outputs,\n-                &codegen_results.crate_name.as_str(),\n-                target_cpu,\n-            );\n-        });\n+        let target_cpu = crate::llvm_util::target_cpu(sess);\n+        link_binary::<LlvmArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+            &codegen_results.crate_name.as_str(),\n+            target_cpu,\n+        );\n \n         Ok(())\n     }\n@@ -331,7 +330,7 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;\n-            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx) }\n+            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx, mod_name) }\n         }\n     }\n \n@@ -352,7 +351,13 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n             let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n-            let tm = match (cgcx.tm_factory.0)() {\n+\n+            let split_dwarf_file = cgcx\n+                .output_filenames\n+                .split_dwarf_filename(cgcx.split_dwarf_kind, Some(name.to_str().unwrap()));\n+            let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+\n+            let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n                     handler.struct_err(&e).emit();"}, {"sha": "707aaa2b53ffc8575925f48da94c200fc6d1cb80", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1830,6 +1830,8 @@ extern \"C\" {\n         SplitName: *const c_char,\n         SplitNameLen: size_t,\n         kind: DebugEmissionKind,\n+        DWOId: u64,\n+        SplitDebugInlining: bool,\n     ) -> &'a DIDescriptor;\n \n     pub fn LLVMRustDIBuilderCreateFile(\n@@ -2151,6 +2153,7 @@ extern \"C\" {\n         EmitStackSizeSection: bool,\n         RelaxELFRelocations: bool,\n         UseInitArray: bool,\n+        SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddBuilderLibraryInfo(\n@@ -2179,6 +2182,7 @@ extern \"C\" {\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         Output: *const c_char,\n+        DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n     pub fn LLVMRustOptimizeWithNewPassManager("}, {"sha": "0876907e1194b27e3b69c1bb0de0d12beb264970", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -40,9 +40,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n         // FIXME(eddyb) producing readable type names for trait objects can result\n         // in problematically distinct types due to HRTB and subtyping (see #47638).\n         // ty::Dynamic(..) |\n-        ty::Adt(..) | ty::Closure(..) | ty::Foreign(..) | ty::Generator(..) | ty::Str\n-            if !cx.sess().fewer_names() =>\n-        {\n+        ty::Adt(..) | ty::Closure(..) | ty::Foreign(..) | ty::Generator(..) | ty::Str => {\n             let mut name = with_no_trimmed_paths(|| layout.ty.to_string());\n             if let (&ty::Adt(def, _), &Variants::Single { index }) =\n                 (layout.ty.kind(), &layout.variants)\n@@ -58,12 +56,6 @@ fn uncached_llvm_type<'a, 'tcx>(\n             }\n             Some(name)\n         }\n-        ty::Adt(..) => {\n-            // If `Some` is returned then a named struct is created in LLVM. Name collisions are\n-            // avoided by LLVM (with increasing suffixes). If rustc doesn't generate names then that\n-            // can improve perf.\n-            Some(String::new())\n-        }\n         _ => None,\n     };\n "}, {"sha": "55fddb38e10beede84041212c9cb13835a0a0029", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 146, "deletions": 69, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n-use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLib};\n+use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SanitizerSet};\n@@ -21,7 +21,10 @@ use super::archive::ArchiveBuilder;\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n+use crate::{\n+    looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n+    METADATA_FILENAME,\n+};\n \n use cc::windows_registry;\n use tempfile::Builder as TempFileBuilder;\n@@ -96,6 +99,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         path.as_ref(),\n                         target_cpu,\n                     );\n+                    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Split {\n+                        link_dwarf_object(sess, &out_filename);\n+                    }\n                 }\n             }\n             if sess.opts.json_artifact_notifications {\n@@ -107,22 +113,30 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     // Remove the temporary object file and metadata if we aren't saving temps\n     sess.time(\"link_binary_remove_temps\", || {\n         if !sess.opts.cg.save_temps {\n+            let remove_temps_from_module = |module: &CompiledModule| {\n+                if let Some(ref obj) = module.object {\n+                    remove(sess, obj);\n+                }\n+\n+                if let Some(ref obj) = module.dwarf_object {\n+                    remove(sess, obj);\n+                }\n+            };\n+\n             if sess.opts.output_types.should_codegen()\n                 && !preserve_objects_for_their_debuginfo(sess)\n             {\n-                for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-                    remove(sess, obj);\n+                for module in &codegen_results.modules {\n+                    remove_temps_from_module(module);\n                 }\n             }\n+\n             if let Some(ref metadata_module) = codegen_results.metadata_module {\n-                if let Some(ref obj) = metadata_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(metadata_module);\n             }\n+\n             if let Some(ref allocator_module) = codegen_results.allocator_module {\n-                if let Some(ref obj) = allocator_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(allocator_module);\n             }\n         }\n     });\n@@ -279,12 +293,12 @@ pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeT\n     out_filename\n }\n \n-// Create an 'rlib'\n-//\n-// An rlib in its current incarnation is essentially a renamed .a file. The\n-// rlib primarily contains the object file of the crate, but it also contains\n-// all of the object files from native libraries. This is done by unzipping\n-// native libraries and inserting all of the contents into this archive.\n+/// Create an 'rlib'.\n+///\n+/// An rlib in its current incarnation is essentially a renamed .a file. The rlib primarily contains\n+/// the object file of the crate, but it also contains all of the object files from native\n+/// libraries. This is done by unzipping native libraries and inserting all of the contents into\n+/// this archive.\n fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n@@ -379,18 +393,17 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     ab\n }\n \n-// Create a static archive\n-//\n-// This is essentially the same thing as an rlib, but it also involves adding\n-// all of the upstream crates' objects into the archive. This will slurp in\n-// all of the native libraries of upstream dependencies as well.\n-//\n-// Additionally, there's no way for us to link dynamic libraries, so we warn\n-// about all dynamic library dependencies that they're not linked in.\n-//\n-// There's no need to include metadata in a static archive, so ensure to not\n-// link in the metadata object file (and also don't prepare the archive with a\n-// metadata file).\n+/// Create a static archive.\n+///\n+/// This is essentially the same thing as an rlib, but it also involves adding all of the upstream\n+/// crates' objects into the archive. This will slurp in all of the native libraries of upstream\n+/// dependencies as well.\n+///\n+/// Additionally, there's no way for us to link dynamic libraries, so we warn about all dynamic\n+/// library dependencies that they're not linked in.\n+///\n+/// There's no need to include metadata in a static archive, so ensure to not link in the metadata\n+/// object file (and also don't prepare the archive with a metadata file).\n fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n@@ -447,10 +460,73 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-// Create a dynamic library or executable\n-//\n-// This will invoke the system linker/cc to create the resulting file. This\n-// links to all upstream files as well.\n+fn escape_stdout_stderr_string(s: &[u8]) -> String {\n+    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n+        let mut x = \"Non-UTF-8 output: \".to_string();\n+        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n+        x\n+    })\n+}\n+\n+const LLVM_DWP_EXECUTABLE: &'static str = \"rust-llvm-dwp\";\n+\n+/// Invoke `llvm-dwp` (shipped alongside rustc) to link `dwo` files from Split DWARF into a `dwp`\n+/// file.\n+fn link_dwarf_object<'a>(sess: &'a Session, executable_out_filename: &Path) {\n+    info!(\"preparing dwp to {}.dwp\", executable_out_filename.to_str().unwrap());\n+\n+    let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n+    let mut cmd = Command::new(LLVM_DWP_EXECUTABLE);\n+    cmd.arg(\"-e\");\n+    cmd.arg(executable_out_filename);\n+    cmd.arg(\"-o\");\n+    cmd.arg(&dwp_out_filename);\n+\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(false);\n+    if let Some(path) = env::var_os(\"PATH\") {\n+        new_path.extend(env::split_paths(&path));\n+    }\n+    let new_path = env::join_paths(new_path).unwrap();\n+    cmd.env(\"PATH\", new_path);\n+\n+    info!(\"{:?}\", &cmd);\n+    match sess.time(\"run_dwp\", || cmd.output()) {\n+        Ok(prog) if !prog.status.success() => {\n+            sess.struct_err(&format!(\n+                \"linking dwarf objects with `{}` failed: {}\",\n+                LLVM_DWP_EXECUTABLE, prog.status\n+            ))\n+            .note(&format!(\"{:?}\", &cmd))\n+            .note(&escape_stdout_stderr_string(&prog.stdout))\n+            .note(&escape_stdout_stderr_string(&prog.stderr))\n+            .emit();\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n+        }\n+        Ok(_) => {}\n+        Err(e) => {\n+            let dwp_not_found = e.kind() == io::ErrorKind::NotFound;\n+            let mut err = if dwp_not_found {\n+                sess.struct_err(&format!(\"linker `{}` not found\", LLVM_DWP_EXECUTABLE))\n+            } else {\n+                sess.struct_err(&format!(\"could not exec the linker `{}`\", LLVM_DWP_EXECUTABLE))\n+            };\n+\n+            err.note(&e.to_string());\n+\n+            if !dwp_not_found {\n+                err.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Create a dynamic library or executable.\n+///\n+/// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n+/// files as well.\n fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     crate_type: CrateType,\n@@ -662,7 +738,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n-                .note(&escape_string(&output))\n+                .note(&escape_stdout_stderr_string(&output))\n                 .emit();\n \n                 // If MSVC's `link.exe` was expected but the return code\n@@ -715,8 +791,8 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n                 sess.abort_if_errors();\n             }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n         }\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n@@ -962,6 +1038,13 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n         return false;\n     }\n \n+    // Single mode keeps debuginfo in the same object file, but in such a way that it it skipped\n+    // by the linker - so it's expected that when codegen units are linked together that this\n+    // debuginfo would be lost without keeping around the temps.\n+    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Single {\n+        return true;\n+    }\n+\n     // If we're on OSX then the equivalent of split dwarf is turned on by\n     // default. The final executable won't actually have any debug information\n     // except it'll have pointers to elsewhere. Historically we've always run\n@@ -1677,17 +1760,15 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.take_cmd()\n }\n \n-// # Native library linking\n-//\n-// User-supplied library search paths (-L on the command line). These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n-//\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n+/// # Native library linking\n+///\n+/// User-supplied library search paths (-L on the command line). These are the same paths used to\n+/// find Rust crates, so some of them may have been added already by the previous crate linking\n+/// code. This only allows them to be found at compile time so it is still entirely up to outside\n+/// forces to make sure that library can be found at runtime.\n+///\n+/// Also note that the native libraries linked here are only the ones located in the current crate.\n+/// Upstream crates with native library dependencies may have their native library pulled in above.\n fn add_local_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n@@ -1727,11 +1808,10 @@ fn add_local_native_libraries(\n     }\n }\n \n-// # Rust Crate linking\n-//\n-// Rust crates are not considered at all when creating an rlib output. All\n-// dependencies will be linked when producing the final output (instead of\n-// the intermediate rlib version)\n+/// # Rust Crate linking\n+///\n+/// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n+/// linked when producing the final output (instead of the intermediate rlib version).\n fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n@@ -1996,24 +2076,21 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-// Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native dependencies are all non-static\n-// dependencies. We've got two cases then:\n-//\n-// 1. The upstream crate is an rlib. In this case we *must* link in the\n-// native dependency because the rlib is just an archive.\n-//\n-// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-// have the dependency present on the system somewhere. Thus, we don't\n-// gain a whole lot from not linking in the dynamic dependency to this\n-// crate as well.\n-//\n-// The use case for this is a little subtle. In theory the native\n-// dependencies of a crate are purely an implementation detail of the crate\n-// itself, but the problem arises with generic and inlined functions. If a\n-// generic function calls a native function, then the generic function must\n-// be instantiated in the target crate, meaning that the native symbol must\n-// also be resolved in the target crate.\n+/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n+/// native dependencies are all non-static dependencies. We've got two cases then:\n+///\n+/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n+/// the rlib is just an archive.\n+///\n+/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n+/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n+/// dynamic dependency to this crate as well.\n+///\n+/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n+/// purely an implementation detail of the crate itself, but the problem arises with generic and\n+/// inlined functions. If a generic function calls a native function, then the generic function\n+/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n+/// in the target crate.\n fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,"}, {"sha": "c84b87964b845507b673af2c29247d24e7ddfc35", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -274,17 +274,20 @@ impl ModuleConfig {\n     }\n }\n \n-// HACK(eddyb) work around `#[derive]` producing wrong bounds for `Clone`.\n-pub struct TargetMachineFactory<B: WriteBackendMethods>(\n-    pub Arc<dyn Fn() -> Result<B::TargetMachine, String> + Send + Sync>,\n-);\n-\n-impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n-    fn clone(&self) -> Self {\n-        TargetMachineFactory(self.0.clone())\n-    }\n+/// Configuration passed to the function returned by the `target_machine_factory`.\n+pub struct TargetMachineFactoryConfig {\n+    /// Split DWARF is enabled in LLVM by checking that `TM.MCOptions.SplitDwarfFile` isn't empty,\n+    /// so the path to the dwarf object has to be provided when we create the target machine.\n+    /// This can be ignored by backends which do not need it for their Split DWARF support.\n+    pub split_dwarf_file: Option<PathBuf>,\n }\n \n+pub type TargetMachineFactoryFn<B> = Arc<\n+    dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n+        + Send\n+        + Sync,\n+>;\n+\n pub type ExportedSymbols = FxHashMap<CrateNum, Arc<Vec<(String, SymbolExportLevel)>>>;\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n@@ -305,12 +308,13 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub regular_module_config: Arc<ModuleConfig>,\n     pub metadata_module_config: Arc<ModuleConfig>,\n     pub allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: TargetMachineFactory<B>,\n+    pub tm_factory: TargetMachineFactoryFn<B>,\n     pub msvc_imps_needed: bool,\n     pub is_pe_coff: bool,\n     pub target_pointer_width: u32,\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n+    pub split_dwarf_kind: config::SplitDwarfKind,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -627,6 +631,12 @@ fn produce_final_output_artifacts(\n                 }\n             }\n \n+            if let Some(ref path) = module.dwarf_object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n+            }\n+\n             if let Some(ref path) = module.bytecode {\n                 if !keep_numbered_bitcode {\n                     remove(sess, path);\n@@ -849,6 +859,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n+        dwarf_object: None,\n         bytecode: None,\n     }))\n }\n@@ -1020,13 +1031,14 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         regular_module_config: regular_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n-        tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, ol)),\n+        tm_factory: backend.target_machine_factory(tcx.sess, ol),\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         is_pe_coff: tcx.sess.target.is_like_windows,\n         target_pointer_width: tcx.sess.target.pointer_width,\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n+        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "f47d2ada61a1441d043fb3a4b562ab3c50d25b61", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,18 +1,3 @@\n-//! Codegen the completed AST to the LLVM IR.\n-//!\n-//! Some functions here, such as `codegen_block` and `codegen_expr`, return a value --\n-//! the result of the codegen to LLVM -- while others, such as `codegen_fn`\n-//! and `mono_item`, are called only for the side effect of adding a\n-//! particular definition to the LLVM IR output we're producing.\n-//!\n-//! Hopefully useful general knowledge about codegen:\n-//!\n-//! * There's no way to find out the `Ty` type of a `Value`. Doing so\n-//!   would be \"trying to get the eggs out of an omelette\" (credit:\n-//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n-//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n-//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n-\n use crate::back::write::{\n     compute_per_cgu_lto_type, start_async_codegen, submit_codegened_module_to_llvm,\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n@@ -46,7 +31,6 @@ use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n-use rustc_symbol_mangling::test as symbol_names_test;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n use std::cmp;\n@@ -486,8 +470,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         ongoing_codegen.codegen_finished(tcx);\n \n-        finalize_tcx(tcx);\n-\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n         return ongoing_codegen;\n@@ -688,14 +670,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         total_codegen_time.into_inner(),\n     );\n \n-    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-\n-    symbol_names_test::report_symbol_names(tcx);\n-\n     ongoing_codegen.check_for_errors(tcx.sess);\n \n-    finalize_tcx(tcx);\n-\n     ongoing_codegen.into_inner()\n }\n \n@@ -746,18 +722,6 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn finalize_tcx(tcx: TyCtxt<'_>) {\n-    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n-\n-    // We assume that no queries are run past here. If there are new queries\n-    // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n-        tcx.alloc_self_profile_query_strings();\n-    }\n-}\n-\n impl CrateInfo {\n     pub fn new(tcx: TyCtxt<'_>) -> CrateInfo {\n         let mut info = CrateInfo {\n@@ -766,7 +730,7 @@ impl CrateInfo {\n             profiler_runtime: None,\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n-            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE).iter().map(Into::into).collect(),\n             link_args: tcx.link_args(LOCAL_CRATE),\n             crate_name: Default::default(),\n             used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n@@ -787,7 +751,8 @@ impl CrateInfo {\n         info.missing_lang_items.reserve(n_crates);\n \n         for &cnum in crates.iter() {\n-            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.native_libraries\n+                .insert(cnum, tcx.native_libraries(cnum).iter().map(Into::into).collect());\n             info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n             info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n             if tcx.is_panic_runtime(cnum) {"}, {"sha": "e27eac3f69b00e5fe25620529303c436cf53012c", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -21,15 +21,17 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n+use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::LangItem;\n use rustc_middle::dep_graph::WorkProduct;\n-use rustc_middle::middle::cstore::{CrateSource, LibSource, NativeLib};\n+use rustc_middle::middle::cstore::{self, CrateSource, LibSource};\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::ty::query::Providers;\n use rustc_session::config::{OutputFilenames, OutputType, RUST_CGU_EXT};\n+use rustc_session::utils::NativeLibKind;\n use rustc_span::symbol::Symbol;\n use std::path::{Path, PathBuf};\n \n@@ -64,13 +66,15 @@ impl<M> ModuleCodegen<M> {\n     pub fn into_compiled_module(\n         self,\n         emit_obj: bool,\n+        emit_dwarf_obj: bool,\n         emit_bc: bool,\n         outputs: &OutputFilenames,\n     ) -> CompiledModule {\n         let object = emit_obj.then(|| outputs.temp_path(OutputType::Object, Some(&self.name)));\n+        let dwarf_object = emit_dwarf_obj.then(|| outputs.temp_path_dwo(Some(&self.name)));\n         let bytecode = emit_bc.then(|| outputs.temp_path(OutputType::Bitcode, Some(&self.name)));\n \n-        CompiledModule { name: self.name.clone(), kind: self.kind, object, bytecode }\n+        CompiledModule { name: self.name.clone(), kind: self.kind, object, dwarf_object, bytecode }\n     }\n }\n \n@@ -79,6 +83,7 @@ pub struct CompiledModule {\n     pub name: String,\n     pub kind: ModuleKind,\n     pub object: Option<PathBuf>,\n+    pub dwarf_object: Option<PathBuf>,\n     pub bytecode: Option<PathBuf>,\n }\n \n@@ -102,6 +107,19 @@ bitflags::bitflags! {\n     }\n }\n \n+#[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n+pub struct NativeLib {\n+    pub kind: NativeLibKind,\n+    pub name: Option<Symbol>,\n+    pub cfg: Option<ast::MetaItem>,\n+}\n+\n+impl From<&cstore::NativeLib> for NativeLib {\n+    fn from(lib: &cstore::NativeLib) -> Self {\n+        NativeLib { kind: lib.kind, name: lib.name, cfg: lib.cfg.clone() }\n+    }\n+}\n+\n /// Misc info we load from metadata to persist beyond the tcx.\n ///\n /// Note: though `CrateNum` is only meaningful within the same tcx, information within `CrateInfo`\n@@ -116,9 +134,9 @@ pub struct CrateInfo {\n     pub compiler_builtins: Option<CrateNum>,\n     pub profiler_runtime: Option<CrateNum>,\n     pub is_no_builtins: FxHashSet<CrateNum>,\n-    pub native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLib>>>,\n+    pub native_libraries: FxHashMap<CrateNum, Vec<NativeLib>>,\n     pub crate_name: FxHashMap<CrateNum, String>,\n-    pub used_libraries: Lrc<Vec<NativeLib>>,\n+    pub used_libraries: Vec<NativeLib>,\n     pub link_args: Lrc<Vec<String>>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates_static: Vec<(CrateNum, LibSource)>,"}, {"sha": "57e49ba8d1a56031411972aeff8e772d2c659732", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -112,12 +112,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n \n             // Allow uses of projections that are ZSTs or from scalar fields.\n-            let is_consume = match context {\n+            let is_consume = matches!(\n+                context,\n                 PlaceContext::NonMutatingUse(\n                     NonMutatingUseContext::Copy | NonMutatingUseContext::Move,\n-                ) => true,\n-                _ => false,\n-            };\n+                )\n+            );\n             if is_consume {\n                 let base_ty =\n                     mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());"}, {"sha": "ecac05fd955720b35a1b291f46e5fbf963466d4a", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -522,7 +522,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         mut bx: Bx,\n         terminator: &mir::Terminator<'tcx>,\n         func: &mir::Operand<'tcx>,\n-        args: &Vec<mir::Operand<'tcx>>,\n+        args: &[mir::Operand<'tcx>],\n         destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n         fn_span: Span,\n@@ -1395,6 +1395,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         dst: PlaceRef<'tcx, Bx::Value>,\n     ) {\n         let src = self.codegen_operand(bx, src);\n+\n+        // Special-case transmutes between scalars as simple bitcasts.\n+        match (&src.layout.abi, &dst.layout.abi) {\n+            (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n+                // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n+                if (src_scalar.value == abi::Pointer) == (dst_scalar.value == abi::Pointer) {\n+                    assert_eq!(src.layout.size, dst.layout.size);\n+\n+                    // NOTE(eddyb) the `from_immediate` and `to_immediate_scalar`\n+                    // conversions allow handling `bool`s the same as `u8`s.\n+                    let src = bx.from_immediate(src.immediate());\n+                    let src_as_dst = bx.bitcast(src, bx.backend_type(dst.layout));\n+                    Immediate(bx.to_immediate_scalar(src_as_dst, dst_scalar)).store(bx, dst);\n+                    return;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let llty = bx.backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n         let align = src.layout.align.abi.min(dst.align);"}, {"sha": "3a85c268e0ea94d5d130933fec586027331d9f79", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -11,7 +11,7 @@ use super::FunctionCx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn eval_mir_constant_to_operand(\n-        &mut self,\n+        &self,\n         bx: &mut Bx,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n@@ -21,7 +21,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n     pub fn eval_mir_constant(\n-        &mut self,\n+        &self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n         match self.monomorphize(constant.literal).val {"}, {"sha": "f1eae605da0181b12967dea276510702b23f894c", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_target::abi::{LayoutOf, Size};\n \n-use super::operand::OperandValue;\n+use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n@@ -116,6 +116,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         span\n     }\n \n+    fn spill_operand_to_stack(\n+        operand: &OperandRef<'tcx, Bx::Value>,\n+        name: Option<String>,\n+        bx: &mut Bx,\n+    ) -> PlaceRef<'tcx, Bx::Value> {\n+        // \"Spill\" the value onto the stack, for debuginfo,\n+        // without forcing non-debuginfo uses of the local\n+        // to also load from the stack every single time.\n+        // FIXME(#68817) use `llvm.dbg.value` instead,\n+        // at least for the cases which LLVM handles correctly.\n+        let spill_slot = PlaceRef::alloca(bx, operand.layout);\n+        if let Some(name) = name {\n+            bx.set_var_name(spill_slot.llval, &(name + \".dbg.spill\"));\n+        }\n+        operand.val.store(bx, spill_slot);\n+        spill_slot\n+    }\n+\n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n     /// or initializing the local with an operand (whichever applies).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n@@ -152,7 +170,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // (after #67586 gets fixed).\n                 None\n             } else {\n-                let name = kw::Invalid;\n+                let name = kw::Empty;\n                 let decl = &self.mir.local_decls[local];\n                 let dbg_var = if full_debug_info {\n                     self.adjusted_span_and_dbg_scope(decl.source_info).map(\n@@ -186,7 +204,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             None\n         } else {\n             Some(match whole_local_var.or(fallback_var) {\n-                Some(var) if var.name != kw::Invalid => var.name.to_string(),\n+                Some(var) if var.name != kw::Empty => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             })\n         };\n@@ -226,17 +244,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return;\n                 }\n \n-                // \"Spill\" the value onto the stack, for debuginfo,\n-                // without forcing non-debuginfo uses of the local\n-                // to also load from the stack every single time.\n-                // FIXME(#68817) use `llvm.dbg.value` instead,\n-                // at least for the cases which LLVM handles correctly.\n-                let spill_slot = PlaceRef::alloca(bx, operand.layout);\n-                if let Some(name) = name {\n-                    bx.set_var_name(spill_slot.llval, &(name + \".dbg.spill\"));\n-                }\n-                operand.val.store(bx, spill_slot);\n-                spill_slot\n+                Self::spill_operand_to_stack(operand, name, bx)\n             }\n \n             LocalRef::Place(place) => *place,\n@@ -308,6 +316,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Partition all `VarDebugInfo` in `self.mir`, by their base `Local`.\n     pub fn compute_per_local_var_debug_info(\n         &self,\n+        bx: &mut Bx,\n     ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n         let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n \n@@ -322,31 +331,63 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 None\n             };\n+\n             let dbg_var = dbg_scope_and_span.map(|(dbg_scope, _, span)| {\n-                let place = var.place;\n-                let var_ty = self.monomorphized_place_ty(place.as_ref());\n-                let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n-                    && place.projection.is_empty()\n-                    && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n-                {\n-                    let arg_index = place.local.index() - 1;\n-\n-                    // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n-                    // offset in closures to account for the hidden environment?\n-                    // Also, is this `+ 1` needed at all?\n-                    VariableKind::ArgumentVariable(arg_index + 1)\n-                } else {\n-                    VariableKind::LocalVariable\n+                let (var_ty, var_kind) = match var.value {\n+                    mir::VarDebugInfoContents::Place(place) => {\n+                        let var_ty = self.monomorphized_place_ty(place.as_ref());\n+                        let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n+                            && place.projection.is_empty()\n+                            && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n+                        {\n+                            let arg_index = place.local.index() - 1;\n+\n+                            // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                            // offset in closures to account for the hidden environment?\n+                            // Also, is this `+ 1` needed at all?\n+                            VariableKind::ArgumentVariable(arg_index + 1)\n+                        } else {\n+                            VariableKind::LocalVariable\n+                        };\n+                        (var_ty, var_kind)\n+                    }\n+                    mir::VarDebugInfoContents::Const(c) => {\n+                        let ty = self.monomorphize(c.literal.ty);\n+                        (ty, VariableKind::LocalVariable)\n+                    }\n                 };\n+\n                 self.cx.create_dbg_var(var.name, var_ty, dbg_scope, var_kind, span)\n             });\n \n-            per_local[var.place.local].push(PerLocalVarDebugInfo {\n-                name: var.name,\n-                source_info: var.source_info,\n-                dbg_var,\n-                projection: var.place.projection,\n-            });\n+            match var.value {\n+                mir::VarDebugInfoContents::Place(place) => {\n+                    per_local[place.local].push(PerLocalVarDebugInfo {\n+                        name: var.name,\n+                        source_info: var.source_info,\n+                        dbg_var,\n+                        projection: place.projection,\n+                    });\n+                }\n+                mir::VarDebugInfoContents::Const(c) => {\n+                    if let Some(dbg_var) = dbg_var {\n+                        let dbg_loc = match self.dbg_loc(var.source_info) {\n+                            Some(dbg_loc) => dbg_loc,\n+                            None => continue,\n+                        };\n+\n+                        if let Ok(operand) = self.eval_mir_constant_to_operand(bx, &c) {\n+                            let base = Self::spill_operand_to_stack(\n+                                &operand,\n+                                Some(var.name.to_string()),\n+                                bx,\n+                            );\n+\n+                            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, Size::ZERO, &[]);\n+                        }\n+                    }\n+                }\n+            }\n         }\n         Some(per_local)\n     }"}, {"sha": "80e3ed75b8585de8c7f5e2341ccceca7c9f39eee", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -83,9 +83,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 return;\n             }\n \n-            sym::unreachable => {\n-                return;\n-            }\n             sym::va_start => bx.va_start(args[0].immediate()),\n             sym::va_end => bx.va_end(args[0].immediate()),\n             sym::size_of_val => {\n@@ -106,8 +103,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bx.const_usize(bx.layout_of(tp_ty).align.abi.bytes())\n                 }\n             }\n-            sym::size_of\n-            | sym::pref_align_of\n+            sym::pref_align_of\n             | sym::min_align_of\n             | sym::needs_drop\n             | sym::type_id\n@@ -119,10 +115,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .unwrap();\n                 OperandRef::from_const(bx, value, ret_ty).immediate_or_packed_pair(bx)\n             }\n-            // Effectively no-op\n-            sym::forget => {\n-                return;\n-            }\n             sym::offset => {\n                 let ptr = args[0].immediate();\n                 let offset = args[1].immediate();\n@@ -218,9 +210,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             sym::add_with_overflow\n             | sym::sub_with_overflow\n             | sym::mul_with_overflow\n-            | sym::wrapping_add\n-            | sym::wrapping_sub\n-            | sym::wrapping_mul\n             | sym::unchecked_div\n             | sym::unchecked_rem\n             | sym::unchecked_shl\n@@ -254,9 +243,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                             return;\n                         }\n-                        sym::wrapping_add => bx.add(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_sub => bx.sub(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_mul => bx.mul(args[0].immediate(), args[1].immediate()),\n                         sym::exact_div => {\n                             if signed {\n                                 bx.exactsdiv(args[0].immediate(), args[1].immediate())\n@@ -538,8 +524,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         };\n \n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n-                            bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n+                        if int_type_width_signed(ty, bx.tcx()).is_some()\n+                            || (ty.is_unsafe_ptr() && op == \"xchg\")\n+                        {\n+                            let mut ptr = args[0].immediate();\n+                            let mut val = args[1].immediate();\n+                            if ty.is_unsafe_ptr() {\n+                                // Some platforms do not support atomic operations on pointers,\n+                                // so we cast to integer first.\n+                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                ptr = bx.pointercast(ptr, ptr_llty);\n+                                val = bx.ptrtoint(val, bx.type_isize());\n+                            }\n+                            bx.atomic_rmw(atom_op, ptr, val, order)\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }"}, {"sha": "285140060be45ad59cf9a03bc8311b44bec5f0a1", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -186,7 +186,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info();\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n \n     for const_ in &mir.required_consts {\n         if let Err(err) = fx.eval_mir_constant(const_) {"}, {"sha": "e3a6cabd600578665242351a276e231806318e23", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -489,6 +489,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(self.mir, bx.tcx());\n+                let discr_ty = self.monomorphize(discr_ty);\n                 let discr = self\n                     .codegen_place(&mut bx, place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);"}, {"sha": "f28db2fe84b6b00bf0adc35d436c9698b9fd7843", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,5 +1,6 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n+use crate::back::write::TargetMachineFactoryFn;\n use crate::{CodegenResults, ModuleCodegen};\n \n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -21,7 +22,6 @@ use rustc_target::spec::Target;\n pub use rustc_data_structures::sync::MetadataRef;\n \n use std::any::Any;\n-use std::sync::Arc;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -123,7 +123,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         sess: &Session,\n         opt_level: config::OptLevel,\n-    ) -> Arc<dyn Fn() -> Result<Self::TargetMachine, String> + Send + Sync>;\n+    ) -> TargetMachineFactoryFn<Self>;\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n     fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n }"}, {"sha": "09b91083a6347c61238198d399491ffec892891c", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -149,8 +149,6 @@ struct Event<N> {\n /// those successors), we will pop off that node's `Settled` event.\n ///\n /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n-/// [`NodeStatus`]: ./enum.NodeStatus.html\n-/// [`TriColorVisitor::node_examined`]: ./trait.TriColorVisitor.html#method.node_examined\n pub struct TriColorDepthFirstSearch<'graph, G>\n where\n     G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,"}, {"sha": "e2cbb09ce5e6d29e54c70975f4ff5c49f5903298", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -523,7 +523,7 @@ where\n                             successors_len: 0,\n                             min_depth: depth,\n                             min_cycle_root: successor_node,\n-                            successor_node: successor_node,\n+                            successor_node,\n                         });\n                         continue 'recurse;\n                     }"}, {"sha": "5880bbd3de44e83018d2d69b3476fd47aef11df0", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,8 +15,7 @@\n #![feature(fn_traits)]\n #![feature(int_bits_const)]\n #![feature(min_specialization)]\n-#![cfg_attr(bootstrap, feature(optin_builtin_traits))]\n-#![cfg_attr(not(bootstrap), feature(auto_traits))]\n+#![feature(auto_traits)]\n #![feature(nll)]\n #![feature(allow_internal_unstable)]\n #![feature(hash_raw_entry)]\n@@ -27,7 +26,7 @@\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n #![feature(const_panic)]\n-#![feature(min_const_generics)]\n+#![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(maybe_uninit_uninit_array)]"}, {"sha": "01cd1cec9245563d6d1ff44c5e973d98e96fcd77", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -24,8 +24,7 @@ use rustc_index::vec::{Idx, IndexVec};\n /// to insert into the middle of the sorted array. Users should avoid mutating this data structure\n /// in-place.\n ///\n-/// [`IndexVec`]: ../../rustc_index/vec/struct.IndexVec.html\n-/// [`SortedMap`]: ../sorted_map/struct.SortedMap.html\n+/// [`SortedMap`]: super::SortedMap\n #[derive(Clone, Debug)]\n pub struct SortedIndexMultiMap<I: Idx, K, V> {\n     /// The elements of the map in insertion order."}, {"sha": "06e8442d47539841fb20fc776be7c241e3e43a54", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -40,7 +40,7 @@ const SSO_ARRAY_SIZE: usize = 8;\n //   into_keys/into_values (unstable)\n //   all raw_entry-related\n //   PartialEq/Eq (requires sorting the array)\n-//   Entry::or_insert_with_key (unstable)\n+//   Entry::or_insert_with_key\n //   Vacant/Occupied entries and related\n //\n // FIXME: In HashMap most methods accepting key reference"}, {"sha": "d57ab2433ad1b291c0306046e3de028d9b253e72", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -603,7 +603,7 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     }\n }\n \n-fn show_content_with_pager(content: &String) {\n+fn show_content_with_pager(content: &str) {\n     let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| {\n         if cfg!(windows) { OsString::from(\"more.com\") } else { OsString::from(\"less\") }\n     });"}, {"sha": "c669f7fed272a298762341b6db2ef50db48bec97", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -111,6 +111,7 @@ E0206: include_str!(\"./error_codes/E0206.md\"),\n E0207: include_str!(\"./error_codes/E0207.md\"),\n E0210: include_str!(\"./error_codes/E0210.md\"),\n E0211: include_str!(\"./error_codes/E0211.md\"),\n+E0212: include_str!(\"./error_codes/E0212.md\"),\n E0214: include_str!(\"./error_codes/E0214.md\"),\n E0220: include_str!(\"./error_codes/E0220.md\"),\n E0221: include_str!(\"./error_codes/E0221.md\"),\n@@ -463,6 +464,7 @@ E0776: include_str!(\"./error_codes/E0776.md\"),\n E0777: include_str!(\"./error_codes/E0777.md\"),\n E0778: include_str!(\"./error_codes/E0778.md\"),\n E0779: include_str!(\"./error_codes/E0779.md\"),\n+E0780: include_str!(\"./error_codes/E0780.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n@@ -503,7 +505,6 @@ E0779: include_str!(\"./error_codes/E0779.md\"),\n //  E0196, // cannot determine a type for this closure\n     E0208,\n //  E0209, // builtin traits can only be implemented on structs or enums\n-    E0212, // cannot extract an associated type from a higher-ranked trait bound\n //  E0213, // associated types are not accepted in this context\n //  E0215, // angle-bracket notation is not stable with `Fn`\n //  E0216, // parenthetical notation is only stable with `Fn`"}, {"sha": "17465414650b393f2e714f516a67e237561c18ce", "filename": "compiler/rustc_error_codes/src/error_codes/E0212.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0212.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0212.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0212.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,35 @@\n+Cannot use the associated type of\n+a trait with uninferred generic parameters.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0212\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo2<I : for<'x> Foo<&'x isize>>(\n+    field: I::A) {} // error!\n+```\n+\n+In this example, we have to instantiate `'x`, and\n+we don't know what lifetime to instantiate it with.\n+To fix this, spell out the precise lifetimes involved.\n+Example:\n+\n+```\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo3<I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&isize>>::A) {} // ok!\n+\n+\n+fn foo4<'a, I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&'a isize>>::A) {} // ok!\n+```"}, {"sha": "56d0e6afa183dcc4eeb85fc9b0bcc4da8dd00cd7", "filename": "compiler/rustc_error_codes/src/error_codes/E0730.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0730.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -3,8 +3,6 @@ An array without a fixed length was pattern-matched.\n Erroneous code example:\n \n ```compile_fail,E0730\n-#![feature(const_generics)]\n-\n fn is_123<const N: usize>(x: [u32; N]) -> bool {\n     match x {\n         [1, 2, ..] => true, // error: cannot pattern-match on an"}, {"sha": "b39163a9de3fd7b63bc2fdc85cac7d72f0f93114", "filename": "compiler/rustc_error_codes/src/error_codes/E0770.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0770.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0770.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0770.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -10,6 +10,5 @@ fn foo<T, const N: T>() {} // error!\n To fix this error, use a concrete type for the const parameter:\n \n ```\n-#![feature(const_generics)]\n fn foo<T, const N: usize>() {}\n ```"}, {"sha": "704b4ae181bb26fcac0007979f566340ad877de3", "filename": "compiler/rustc_error_codes/src/error_codes/E0780.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0780.md", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0780.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0780.md?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,19 @@\n+Cannot use `doc(inline)` with anonymous imports\n+\n+Erroneous code example:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+\n+#[doc(inline)] // error: invalid doc argument\n+pub use foo::Foo as _;\n+```\n+\n+Anonymous imports are always rendered with `#[doc(no_inline)]`. To fix this\n+error, remove the `#[doc(inline)]` attribute.\n+\n+Example:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+\n+pub use foo::Foo as _;\n+```"}, {"sha": "e61476bf23e1e5f0d1046ec093d68808a8584878", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -30,7 +30,8 @@ pub enum DiagnosticId {\n     Lint { name: String, has_future_breakage: bool },\n }\n \n-/// For example a note attached to an error.\n+/// A \"sub\"-diagnostic attached to a parent diagnostic.\n+/// For example, a note attached to an error.\n #[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n@@ -124,6 +125,7 @@ impl Diagnostic {\n         self.level = Level::Cancelled;\n     }\n \n+    /// Check if this diagnostic [was cancelled][Self::cancel()].\n     pub fn cancelled(&self) -> bool {\n         self.level == Level::Cancelled\n     }\n@@ -136,8 +138,6 @@ impl Diagnostic {\n     ///\n     /// This span is *not* considered a [\"primary span\"][`MultiSpan`]; only\n     /// the `Span` supplied when creating the diagnostic is primary.\n-    ///\n-    /// [`MultiSpan`]: ../rustc_span/struct.MultiSpan.html\n     pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n         self.span.push_span_label(span, label.into());\n         self\n@@ -164,7 +164,7 @@ impl Diagnostic {\n         self.note_expected_found_extra(expected_label, expected, found_label, found, &\"\", &\"\")\n     }\n \n-    pub fn note_unsuccessfull_coercion(\n+    pub fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -241,6 +241,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Add a note attached to this diagnostic.\n     pub fn note(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n@@ -252,33 +253,40 @@ impl Diagnostic {\n     }\n \n     /// Prints the span with a note above it.\n+    /// This is like [`Diagnostic::note()`], but it gets its own span.\n     pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n+    /// Add a warning attached to this diagnostic.\n     pub fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n-    /// Prints the span with a warn above it.\n+    /// Prints the span with a warning above it.\n+    /// This is like [`Diagnostic::warn()`], but it gets its own span.\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n+    /// Add a help message attached to this diagnostic.\n     pub fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n+    /// This is like [`Diagnostic::help()`], but it gets its own span.\n     pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n \n+    /// Show a suggestion that has multiple parts to it.\n+    /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -299,6 +307,8 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Show multiple suggestions that have multiple parts.\n+    /// See also [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n@@ -382,6 +392,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// [`Diagnostic::span_suggestion()`] but you can set the [`SuggestionStyle`].\n     pub fn span_suggestion_with_style(\n         &mut self,\n         sp: Span,\n@@ -401,6 +412,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Always show the suggested change.\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n@@ -419,6 +431,7 @@ impl Diagnostic {\n     }\n \n     /// Prints out a message with multiple suggested edits of the code.\n+    /// See also [`Diagnostic::span_suggestion()`].\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n@@ -458,7 +471,7 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Prints out a message with for a suggestion without showing the suggested code.\n+    /// Prints out a message for a suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to\n     /// be from the message, showing the span label inline would be visually unpleasant\n@@ -481,7 +494,7 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Adds a suggestion to the json output, but otherwise remains silent/undisplayed in the cli.\n+    /// Adds a suggestion to the JSON output that will not be shown in the CLI.\n     ///\n     /// This is intended to be used for suggestions that are *very* obvious in what the changes\n     /// need to be from the message, but we still want other tools to be able to apply them."}, {"sha": "f165a60336a6a57ad9d553cb4d4ece2c6b27de7c", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -30,6 +30,15 @@ struct DiagnosticBuilderInner<'a> {\n     allow_suggestions: bool,\n }\n \n+/// This is a helper macro for [`forward!`] that allows automatically adding documentation\n+/// that uses tokens from [`forward!`]'s input.\n+macro_rules! forward_inner_docs {\n+    ($e:expr => $i:item) => {\n+        #[doc = $e]\n+        $i\n+    }\n+}\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to\n@@ -45,10 +54,11 @@ macro_rules! forward {\n         pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)?) -> &Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n             self.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n \n     // Forward pattern for &mut self -> &mut Self\n@@ -57,10 +67,11 @@ macro_rules! forward {\n         pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)?) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n \n     // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n@@ -74,10 +85,11 @@ macro_rules! forward {\n         ) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n }\n \n@@ -116,7 +128,7 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Stashes diagnostic for possible later improvement in a different,\n     /// later stage of the compiler. The diagnostic can be accessed with\n-    /// the provided `span` and `key` through `.steal_diagnostic` on `Handler`.\n+    /// the provided `span` and `key` through [`Handler::steal_diagnostic()`].\n     ///\n     /// As with `buffer`, this is unless the handler has disabled such buffering.\n     pub fn stash(self, span: Span, key: StashKey) {\n@@ -202,7 +214,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     }\n \n     /// Labels all the given spans with the provided label.\n-    /// See `span_label` for more information.\n+    /// See [`Diagnostic::span_label()`] for more information.\n     pub fn span_labels(\n         &mut self,\n         spans: impl IntoIterator<Item = Span>,\n@@ -233,7 +245,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         found_extra: &dyn fmt::Display,\n     ) -> &mut Self);\n \n-    forward!(pub fn note_unsuccessfull_coercion(\n+    forward!(pub fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -254,6 +266,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         msg: &str,\n     ) -> &mut Self);\n \n+    /// See [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -267,6 +280,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::multipart_suggestions()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n@@ -280,6 +294,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -293,6 +308,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion()`].\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n@@ -307,6 +323,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestions()`].\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n@@ -321,6 +338,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_short()`].\n     pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n@@ -335,6 +353,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_verbose()`].\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n@@ -349,6 +368,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_hidden()`].\n     pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n@@ -363,6 +383,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::tool_only_span_suggestion()`] for more information.\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n@@ -380,19 +401,22 @@ impl<'a> DiagnosticBuilder<'a> {\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n+    /// Allow attaching suggestions this diagnostic.\n+    /// If this is set to `false`, then any suggestions attached with the `span_suggestion_*`\n+    /// methods after this is set to `false` will be ignored.\n     pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n         self.0.allow_suggestions = allow;\n         self\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n+    /// `struct_*` methods on [`Handler`].\n     crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder::new_with_code(handler, level, None, message)\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n+    /// `struct_*` methods on [`Handler`].\n     crate fn new_with_code(\n         handler: &'a Handler,\n         level: Level,"}, {"sha": "774a0764d114f952f251549f74c1afff1d441c1a", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2,8 +2,8 @@ use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirectoryOwnership;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, Attribute, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n@@ -119,8 +119,8 @@ impl Annotatable {\n         }\n     }\n \n-    crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n-        let nt = match self {\n+    crate fn into_nonterminal(self) -> Nonterminal {\n+        match self {\n             Annotatable::Item(item) => token::NtItem(item),\n             Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n                 token::NtItem(P(item.and_then(ast::AssocItem::into_item)))\n@@ -137,8 +137,11 @@ impl Annotatable {\n             | Annotatable::Param(..)\n             | Annotatable::StructField(..)\n             | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n-        };\n-        nt_to_tokenstream(&nt, sess, DUMMY_SP)\n+        }\n+    }\n+\n+    crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n+        nt_to_tokenstream(&self.into_nonterminal(), sess, DUMMY_SP, CanSynthesizeMissingTokens::No)\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {"}, {"sha": "1193f66651ce9dda9c34d8c53ed34a80bae5f1db", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -29,6 +29,7 @@ use smallvec::SmallVec;\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n     pub features: Option<&'a Features>,\n+    pub modified: bool,\n }\n \n fn get_features(\n@@ -199,7 +200,7 @@ fn get_features(\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features) {\n-    let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n+    let mut strip_unconfigured = StripUnconfigured { sess, features: None, modified: false };\n \n     let unconfigured_attrs = krate.attrs.clone();\n     let diag = &sess.parse_sess.span_diagnostic;\n@@ -243,7 +244,12 @@ const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n-        self.in_cfg(node.attrs()).then_some(node)\n+        if self.in_cfg(node.attrs()) {\n+            Some(node)\n+        } else {\n+            self.modified = true;\n+            None\n+        }\n     }\n \n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n@@ -270,6 +276,9 @@ impl<'a> StripUnconfigured<'a> {\n             return vec![attr];\n         }\n \n+        // A `#[cfg_attr]` either gets removed, or replaced with a new attribute\n+        self.modified = true;\n+\n         let (cfg_predicate, expanded_attrs) = match self.parse_cfg_attr(&attr) {\n             None => return vec![],\n             Some(r) => r,"}, {"sha": "5d40d478b963d7bce9adef36551494e5010e5650", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, AttrItem, Block, LitKind, NodeId, PatKind, Path};\n+use rustc_ast::{self as ast, AttrItem, AttrStyle, Block, LitKind, NodeId, PatKind, Path};\n use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n@@ -522,12 +522,29 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n                         (item, Vec::new())\n                     } else {\n-                        let mut item = StripUnconfigured {\n+                        let mut visitor = StripUnconfigured {\n                             sess: self.cx.sess,\n                             features: self.cx.ecfg.features,\n-                        }\n-                        .fully_configure(item);\n+                            modified: false,\n+                        };\n+                        let mut item = visitor.fully_configure(item);\n                         item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n+                        if visitor.modified && !derives.is_empty() {\n+                            // Erase the tokens if cfg-stripping modified the item\n+                            // This will cause us to synthesize fake tokens\n+                            // when `nt_to_tokenstream` is called on this item.\n+                            match &mut item {\n+                                Annotatable::Item(item) => item.tokens = None,\n+                                Annotatable::Stmt(stmt) => {\n+                                    if let StmtKind::Item(item) = &mut stmt.kind {\n+                                        item.tokens = None\n+                                    } else {\n+                                        panic!(\"Unexpected stmt {:?}\", stmt);\n+                                    }\n+                                }\n+                                _ => panic!(\"Unexpected annotatable {:?}\", item),\n+                            }\n+                        }\n \n                         invocations.reserve(derives.len());\n                         let derive_placeholders = derives\n@@ -622,7 +639,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let invocations = {\n             let mut collector = InvocationCollector {\n-                cfg: StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features },\n+                cfg: StripUnconfigured {\n+                    sess: &self.cx.sess,\n+                    features: self.cx.ecfg.features,\n+                    modified: false,\n+                },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n@@ -716,7 +737,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = item.into_tokens(&self.cx.sess.parse_sess);\n+                    let tokens = match attr.style {\n+                        AttrStyle::Outer => item.into_tokens(&self.cx.sess.parse_sess),\n+                        // FIXME: Properly collect tokens for inner attributes\n+                        AttrStyle::Inner => rustc_parse::fake_token_stream(\n+                            &self.cx.sess.parse_sess,\n+                            &item.into_nonterminal(),\n+                            span,\n+                        ),\n+                    };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");"}, {"sha": "3b722c04cb154b19f5d938966843de8a6577bc17", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -36,16 +36,13 @@ crate mod mbe;\n mod tests;\n #[cfg(test)]\n mod parse {\n-    #[cfg(test)]\n     mod tests;\n }\n #[cfg(test)]\n mod tokenstream {\n-    #[cfg(test)]\n     mod tests;\n }\n #[cfg(test)]\n mod mut_visit {\n-    #[cfg(test)]\n     mod tests;\n }"}, {"sha": "cbc4d14a65a1bf605a8515e80e4633493f6fd4c6", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -84,7 +84,7 @@ enum TokenTree {\n     /// e.g., `$var`\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(Span, Ident /* name to bind */, NonterminalKind),\n+    MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n }\n \n impl TokenTree {"}, {"sha": "e76cc6f1fed7bd4710de45006e832300bf0cf28b", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,4 +1,4 @@\n-//! This is an NFA-based parser, which calls out to the main rust parser for named non-terminals\n+//! This is an NFA-based parser, which calls out to the main Rust parser for named non-terminals\n //! (which it commits to fully when it hits one in a grammar). There's a set of current NFA threads\n //! and a set of next ones. Instead of NTs, we have a special case for Kleene star. The big-O, in\n //! pathological cases, is worse than traditional use of NFA or Earley parsing, but it's an easier\n@@ -378,6 +378,11 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n+            TokenTree::MetaVarDecl(span, _, None) => {\n+                if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n+                    return Err((span, \"missing fragment specifier\".to_string()));\n+                }\n+            }\n             TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val\n                 .entry(MacroRulesNormalizedIdent::new(bind_name))\n             {\n@@ -422,21 +427,19 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n ///\n /// # Parameters\n ///\n-/// - `sess`: the parsing session into which errors are emitted.\n /// - `cur_items`: the set of current items to be processed. This should be empty by the end of a\n ///   successful execution of this function.\n /// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n ///   the function `parse`.\n /// - `eof_items`: the set of items that would be valid if this was the EOF.\n /// - `bb_items`: the set of items that are waiting for the black-box parser.\n /// - `token`: the current token of the parser.\n-/// - `span`: the `Span` in the source code corresponding to the token trees we are trying to match\n-///   against the matcher positions in `cur_items`.\n ///\n /// # Returns\n ///\n /// A `ParseResult`. Note that matches are kept track of through the items generated.\n fn inner_parse_loop<'root, 'tt>(\n+    sess: &ParseSess,\n     cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n     eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n@@ -554,11 +557,21 @@ fn inner_parse_loop<'root, 'tt>(\n                     })));\n                 }\n \n+                // We need to match a metavar (but the identifier is invalid)... this is an error\n+                TokenTree::MetaVarDecl(span, _, None) => {\n+                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n+                        return Error(span, \"missing fragment specifier\".to_string());\n+                    }\n+                }\n+\n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, kind) => {\n-                    // Built-in nonterminals never start with these tokens,\n-                    // so we can eliminate them from consideration.\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n+                    // Built-in nonterminals never start with these tokens, so we can eliminate\n+                    // them from consideration.\n+                    //\n+                    // We use the span of the metavariable declaration to determine any\n+                    // edition-specific matching behavior for non-terminals.\n                     if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n@@ -627,6 +640,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n         match inner_parse_loop(\n+            parser.sess,\n             &mut cur_items,\n             &mut next_items,\n             &mut eof_items,\n@@ -688,7 +702,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, kind) => format!(\"{} ('{}')\", kind, bind),\n+                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n                     _ => panic!(),\n                 })\n                 .collect::<Vec<String>>()\n@@ -718,8 +732,10 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, kind) = item.top_elts.get_tt(item.idx) {\n+            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n+                // We use the span of the metavariable declaration to determine any\n+                // edition-specific matching behavior for non-terminals.\n                 let nt = match parser.to_mut().parse_nonterminal(kind) {\n                     Err(mut err) => {\n                         err.span_label("}, {"sha": "3d126749d541d184c92b8507bf8a2acda7febc94", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -401,7 +401,7 @@ pub fn compile_declarative_macro(\n     let diag = &sess.parse_sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n-    let tt_spec = NonterminalKind::TT;\n+    let tt_spec = Some(NonterminalKind::TT);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n@@ -476,10 +476,15 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt =\n-                            mbe::quoted::parse(tt.clone().into(), true, &sess.parse_sess, def.id)\n-                                .pop()\n-                                .unwrap();\n+                        let tt = mbe::quoted::parse(\n+                            tt.clone().into(),\n+                            true,\n+                            &sess.parse_sess,\n+                            def.id,\n+                            features,\n+                        )\n+                        .pop()\n+                        .unwrap();\n                         valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -501,6 +506,7 @@ pub fn compile_declarative_macro(\n                             false,\n                             &sess.parse_sess,\n                             def.id,\n+                            features,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -578,7 +584,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none()\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, NonterminalKind::Vis) => true,\n+                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n@@ -961,7 +967,7 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, kind) = *token {\n+            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n                     match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n@@ -1019,7 +1025,7 @@ fn check_matcher_core(\n }\n \n fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n-    if let mbe::TokenTree::MetaVarDecl(_, _, kind) = *tok {\n+    if let mbe::TokenTree::MetaVarDecl(_, _, Some(kind)) = *tok {\n         frag_can_be_followed_by_any(kind)\n     } else {\n         // (Non NT's can always be followed by anything in matchers.)\n@@ -1090,7 +1096,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            NonterminalKind::Pat => {\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1123,7 +1129,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                         }\n                         _ => IsInFollow::No(TOKENS),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, NonterminalKind::Block) => IsInFollow::Yes,\n+                    TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Block)) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n@@ -1158,7 +1164,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     TokenTree::MetaVarDecl(\n                         _,\n                         _,\n-                        NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path,\n+                        Some(NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path),\n                     ) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n@@ -1171,7 +1177,8 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n         mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),\n         _ => panic!(\n             \"{}\",\n             \"unexpected mbe::TokenTree::{Sequence or Delimited} \\"}, {"sha": "a4b44931fc1aeb0a66f73d8e1fc606de938516d8", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 53, "deletions": 26, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -3,10 +3,11 @@ use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree\n \n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n-use rustc_ast::NodeId;\n+use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n-use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_feature::Features;\n+use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_span::symbol::{kw, sym, Ident};\n \n use rustc_span::Span;\n \n@@ -29,10 +30,8 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n ///   `ident` are \"matchers\". They are not present in the body of a macro rule -- just in the\n ///   pattern, so we pass a parameter to indicate whether to expect them or not.\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n-/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n-///   unstable features or not.\n-/// - `edition`: which edition are we in.\n-/// - `macro_node_id`: the NodeId of the macro we are parsing.\n+/// - `node_id`: the NodeId of the macro we are parsing.\n+/// - `features`: language features so we can do feature gating.\n ///\n /// # Returns\n ///\n@@ -42,6 +41,7 @@ pub(super) fn parse(\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n+    features: &Features,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -52,7 +52,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -61,19 +61,40 @@ pub(super) fn parse(\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n                                 Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n-                                        .unwrap_or_else(|| {\n-                                            let msg = format!(\n-                                                \"invalid fragment specifier `{}`\",\n-                                                frag.name\n-                                            );\n-                                            sess.span_diagnostic\n-                                                .struct_span_err(span, &msg)\n-                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+\n+                                    match frag.name {\n+                                        sym::pat2018 | sym::pat2021 => {\n+                                            if !features.edition_macro_pats {\n+                                                feature_err(\n+                                                    sess,\n+                                                    sym::edition_macro_pats,\n+                                                    frag.span,\n+                                                    \"`pat2018` and `pat2021` are unstable.\",\n+                                                )\n                                                 .emit();\n-                                            token::NonterminalKind::Ident\n-                                        });\n-                                    result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                            }\n+                                        }\n+                                        _ => {}\n+                                    }\n+\n+                                    let kind =\n+                                        token::NonterminalKind::from_symbol(frag.name, || {\n+                                            span.edition()\n+                                        })\n+                                        .unwrap_or_else(\n+                                            || {\n+                                                let msg = format!(\n+                                                    \"invalid fragment specifier `{}`\",\n+                                                    frag.name\n+                                                );\n+                                                sess.span_diagnostic\n+                                                    .struct_span_err(span, &msg)\n+                                                    .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                    .emit();\n+                                                token::NonterminalKind::Ident\n+                                            },\n+                                        );\n+                                    result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n                                 _ => token.span,\n@@ -83,8 +104,11 @@ pub(super) fn parse(\n                     }\n                     tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n-                sess.span_diagnostic.struct_span_err(span, \"missing fragment specifier\").emit();\n-                continue;\n+                if node_id != DUMMY_NODE_ID {\n+                    // Macros loaded from other crates have dummy node ids.\n+                    sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n+                }\n+                result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree\n@@ -107,14 +131,14 @@ pub(super) fn parse(\n ///   converting `tree`\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n-/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n-///   unstable features or not.\n+/// - `features`: language features so we can do feature gating.\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n     outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n+    features: &Features,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -142,7 +166,7 @@ fn parse_tree(\n                         sess.span_diagnostic.span_err(span.entire(), &msg);\n                     }\n                     // Parse the contents of the sequence itself\n-                    let sequence = parse(tts, expect_matchers, sess, node_id);\n+                    let sequence = parse(tts, expect_matchers, sess, node_id, features);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n@@ -193,7 +217,10 @@ fn parse_tree(\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n-            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess, node_id) }),\n+            Lrc::new(Delimited {\n+                delim,\n+                tts: parse(tts, expect_matchers, sess, node_id, features),\n+            }),\n         ),\n     }\n }"}, {"sha": "e8e098b621295b898750510464a46c1bb856d894", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -3,7 +3,7 @@ use crate::proc_macro_server;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n@@ -94,7 +94,12 @@ impl MultiItemModifier for ProcMacroDerive {\n         let input = if item.pretty_printing_compatibility_hack() {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {\n-            nt_to_tokenstream(&item, &ecx.sess.parse_sess, DUMMY_SP)\n+            nt_to_tokenstream(\n+                &item,\n+                &ecx.sess.parse_sess,\n+                DUMMY_SP,\n+                CanSynthesizeMissingTokens::Yes,\n+            )\n         };\n \n         let server = proc_macro_server::Rustc::new(ecx);"}, {"sha": "02ae842675f37029e50827f3a7733618c8dcc5ae", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2,7 +2,8 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n+use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n+use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n@@ -178,7 +179,7 @@ impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n                 {\n                     TokenTree::Ident(Ident::new(sess, name.name, is_raw, name.span))\n                 } else {\n-                    let stream = nt_to_tokenstream(&nt, sess, span);\n+                    let stream = nt_to_tokenstream(&nt, sess, span, CanSynthesizeMissingTokens::No);\n                     TokenTree::Group(Group {\n                         delimiter: Delimiter::None,\n                         stream,"}, {"sha": "aa54ffb132dc9686b73f00aeb3e90a695c380ce5", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -273,6 +273,8 @@ declare_features! (\n     /// Allows patterns with concurrent by-move and by-ref bindings.\n     /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n     (accepted, move_ref_pattern, \"1.48.0\", Some(68354), None),\n+    /// The smallest useful subset of `const_generics`.\n+    (accepted, min_const_generics, \"1.51.0\", Some(74878), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "c61857a1cd0ae46304df4285b6e26fe5cc55f780", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -578,9 +578,6 @@ declare_features! (\n     /// Allows calling `transmute` in const fn\n     (active, const_fn_transmute, \"1.46.0\", Some(53605), None),\n \n-    /// The smallest useful subset of `const_generics`.\n-    (active, min_const_generics, \"1.47.0\", Some(74878), None),\n-\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n \n@@ -623,6 +620,9 @@ declare_features! (\n     /// Allows arbitrary expressions in key-value attributes at parse time.\n     (active, extended_key_value_attributes, \"1.50.0\", Some(78835), None),\n \n+    /// `:pat2018` and `:pat2021` macro matchers.\n+    (active, edition_macro_pats, \"1.51.0\", Some(54883), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -651,5 +651,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n \n /// Some features are not allowed to be used together at the same time, if\n /// the two are present, produce an error.\n-pub const INCOMPATIBLE_FEATURES: &[(Symbol, Symbol)] =\n-    &[(sym::const_generics, sym::min_const_generics)];\n+///\n+/// Currently empty, but we will probably need this again in the future,\n+/// so let's keep it in for now.\n+pub const INCOMPATIBLE_FEATURES: &[(Symbol, Symbol)] = &[];"}, {"sha": "2a7c2a02fbaf4b5e728a16520e2fb8ac23e12f98", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -18,6 +18,9 @@ mod active;\n mod builtin_attrs;\n mod removed;\n \n+#[cfg(test)]\n+mod tests;\n+\n use rustc_span::{edition::Edition, symbol::Symbol, Span};\n use std::fmt;\n use std::num::NonZeroU32;\n@@ -149,30 +152,3 @@ pub use builtin_attrs::{\n     AttributeType, BuiltinAttribute, GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n };\n pub use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n-\n-#[cfg(test)]\n-mod test {\n-    use super::UnstableFeatures;\n-\n-    #[test]\n-    fn rustc_bootstrap_parsing() {\n-        let is_bootstrap = |env, krate| {\n-            std::env::set_var(\"RUSTC_BOOTSTRAP\", env);\n-            matches!(UnstableFeatures::from_environment(krate), UnstableFeatures::Cheat)\n-        };\n-        assert!(is_bootstrap(\"1\", None));\n-        assert!(is_bootstrap(\"1\", Some(\"x\")));\n-        // RUSTC_BOOTSTRAP allows specifying a specific crate\n-        assert!(is_bootstrap(\"x\", Some(\"x\")));\n-        // RUSTC_BOOTSTRAP allows multiple comma-delimited crates\n-        assert!(is_bootstrap(\"x,y,z\", Some(\"x\")));\n-        assert!(is_bootstrap(\"x,y,z\", Some(\"y\")));\n-        // Crate that aren't specified do not get unstable features\n-        assert!(!is_bootstrap(\"x\", Some(\"a\")));\n-        assert!(!is_bootstrap(\"x,y,z\", Some(\"a\")));\n-        assert!(!is_bootstrap(\"x,y,z\", None));\n-\n-        // this is technically a breaking change, but there are no stability guarantees for RUSTC_BOOTSTRAP\n-        assert!(!is_bootstrap(\"0\", None));\n-    }\n-}"}, {"sha": "50433e44b135051edf79266517e5bc9f0fb1265a", "filename": "compiler/rustc_feature/src/tests.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_feature%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Ftests.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,23 @@\n+use super::UnstableFeatures;\n+\n+#[test]\n+fn rustc_bootstrap_parsing() {\n+    let is_bootstrap = |env, krate| {\n+        std::env::set_var(\"RUSTC_BOOTSTRAP\", env);\n+        matches!(UnstableFeatures::from_environment(krate), UnstableFeatures::Cheat)\n+    };\n+    assert!(is_bootstrap(\"1\", None));\n+    assert!(is_bootstrap(\"1\", Some(\"x\")));\n+    // RUSTC_BOOTSTRAP allows specifying a specific crate\n+    assert!(is_bootstrap(\"x\", Some(\"x\")));\n+    // RUSTC_BOOTSTRAP allows multiple comma-delimited crates\n+    assert!(is_bootstrap(\"x,y,z\", Some(\"x\")));\n+    assert!(is_bootstrap(\"x,y,z\", Some(\"y\")));\n+    // Crate that aren't specified do not get unstable features\n+    assert!(!is_bootstrap(\"x\", Some(\"a\")));\n+    assert!(!is_bootstrap(\"x,y,z\", Some(\"a\")));\n+    assert!(!is_bootstrap(\"x,y,z\", None));\n+\n+    // this is technically a breaking change, but there are no stability guarantees for RUSTC_BOOTSTRAP\n+    assert!(!is_bootstrap(\"0\", None));\n+}"}, {"sha": "47a7651e1d4147170bab4edfa67e66a87e885645", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -28,7 +28,7 @@ pub struct Lifetime {\n     pub span: Span,\n \n     /// Either \"`'a`\", referring to a named lifetime definition,\n-    /// or \"``\" (i.e., `kw::Invalid`), for elision placeholders.\n+    /// or \"``\" (i.e., `kw::Empty`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n@@ -607,7 +607,7 @@ pub struct Crate<'hir> {\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n-    // detected, which in turn can make compile-fail tests yield\n+    // detected, which in turn can make UI tests yield\n     // slightly different results.\n     pub items: BTreeMap<HirId, Item<'hir>>,\n \n@@ -760,9 +760,9 @@ pub struct Pat<'hir> {\n     pub default_binding_modes: bool,\n }\n \n-impl Pat<'_> {\n+impl<'hir> Pat<'hir> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n@@ -785,12 +785,12 @@ impl Pat<'_> {\n     /// Note that when visiting e.g. `Tuple(ps)`,\n     /// if visiting `ps[0]` returns `false`,\n     /// then `ps[1]` will not be visited.\n-    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'_>) -> bool) -> bool {\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         self.walk_short_(&mut it)\n     }\n \n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) {\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) {\n         if !it(self) {\n             return;\n         }\n@@ -810,7 +810,7 @@ impl Pat<'_> {\n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If `it(pat)` returns `false`, the children are not visited.\n-    pub fn walk(&self, mut it: impl FnMut(&Pat<'_>) -> bool) {\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'hir>) -> bool) {\n         self.walk_(&mut it)\n     }\n \n@@ -1160,6 +1160,7 @@ pub struct Arm<'hir> {\n #[derive(Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n+    IfLet(&'hir Pat<'hir>, &'hir Expr<'hir>),\n }\n \n #[derive(Debug, HashStable_Generic)]\n@@ -1721,6 +1722,8 @@ pub enum MatchSource {\n     IfDesugar { contains_else_clause: bool },\n     /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar { contains_else_clause: bool },\n+    /// An `if let _ = _ => { .. }` match guard.\n+    IfLetGuardDesugar,\n     /// A `while _ { .. }` (which was desugared to a `loop { match _ { .. } }`).\n     WhileDesugar,\n     /// A `while let _ = _ { .. }` (which was desugared to a\n@@ -1739,7 +1742,7 @@ impl MatchSource {\n         use MatchSource::*;\n         match self {\n             Normal => \"match\",\n-            IfDesugar { .. } | IfLetDesugar { .. } => \"if\",\n+            IfDesugar { .. } | IfLetDesugar { .. } | IfLetGuardDesugar => \"if\",\n             WhileDesugar | WhileLetDesugar => \"while\",\n             ForLoopDesugar => \"for\",\n             TryDesugar => \"?\","}, {"sha": "03c8b1738853dc02fff2da2b0e555221c29ff124", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1228,6 +1228,10 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     if let Some(ref g) = arm.guard {\n         match g {\n             Guard::If(ref e) => visitor.visit_expr(e),\n+            Guard::IfLet(ref pat, ref e) => {\n+                visitor.visit_pat(pat);\n+                visitor.visit_expr(e);\n+            }\n         }\n     }\n     visitor.visit_expr(&arm.body);"}, {"sha": "2774cc9c08e1621a58b577647aeec7f0dda1065e", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -9,6 +9,13 @@ use crate::{Item, ItemKind, TraitItem, TraitItemKind};\n \n use std::fmt::{self, Display};\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum GenericParamKind {\n+    Type,\n+    Lifetime,\n+    Const,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum MethodKind {\n     Trait { body: bool },\n@@ -43,6 +50,7 @@ pub enum Target {\n     ForeignFn,\n     ForeignStatic,\n     ForeignTy,\n+    GenericParam(GenericParamKind),\n }\n \n impl Display for Target {\n@@ -77,6 +85,11 @@ impl Display for Target {\n                 Target::ForeignFn => \"foreign function\",\n                 Target::ForeignStatic => \"foreign static item\",\n                 Target::ForeignTy => \"foreign type\",\n+                Target::GenericParam(kind) => match kind {\n+                    GenericParamKind::Type => \"type parameter\",\n+                    GenericParamKind::Lifetime => \"lifetime parameter\",\n+                    GenericParamKind::Const => \"const parameter\",\n+                },\n             }\n         )\n     }\n@@ -124,4 +137,14 @@ impl Target {\n             hir::ForeignItemKind::Type => Target::ForeignTy,\n         }\n     }\n+\n+    pub fn from_generic_param(generic_param: &hir::GenericParam<'_>) -> Target {\n+        match generic_param.kind {\n+            hir::GenericParamKind::Type { .. } => Target::GenericParam(GenericParamKind::Type),\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                Target::GenericParam(GenericParamKind::Lifetime)\n+            }\n+            hir::GenericParamKind::Const { .. } => Target::GenericParam(GenericParamKind::Const),\n+        }\n+    }\n }"}, {"sha": "0b5eb1d82667df5161dfbd462d5948b5ff524dc0", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -2002,6 +2002,15 @@ impl<'a> State<'a> {\n                     self.print_expr(&e);\n                     self.s.space();\n                 }\n+                hir::Guard::IfLet(pat, e) => {\n+                    self.word_nbsp(\"if\");\n+                    self.word_nbsp(\"let\");\n+                    self.print_pat(&pat);\n+                    self.s.space();\n+                    self.word_space(\"=\");\n+                    self.print_expr(&e);\n+                    self.s.space();\n+                }\n             }\n         }\n         self.word_space(\"=>\");"}, {"sha": "9b4388c911f1bb036b813e21d084b6ee749594bb", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,7 +12,7 @@\n //! In this code, we report errors on each `rustc_if_this_changed`\n //! annotation. If a path exists in all cases, then we would report\n //! \"all path(s) exist\". Otherwise, we report: \"no path to `foo`\" for\n-//! each case where no path exists. `compile-fail` tests can then be\n+//! each case where no path exists. `ui` tests can then be\n //! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is"}, {"sha": "0b501da7cd97515db84dfe93c6215e581f4cff07", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -27,7 +27,6 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// to or greater than the domain size. All operations that involve two bitsets\n /// will panic if the bitsets have differing domain sizes.\n ///\n-/// [`GrowableBitSet`]: struct.GrowableBitSet.html\n #[derive(Eq, PartialEq, Decodable, Encodable)]\n pub struct BitSet<T> {\n     domain_size: usize,"}, {"sha": "9002d251f12370841742938cb8452338f5a1a75d", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -625,7 +625,8 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let region = ty::ReLateBound(self.binder_index, ty::BoundRegion::BrAnon(var.as_u32()));\n+        let br = ty::BoundRegion { kind: ty::BrAnon(var.as_u32()) };\n+        let region = ty::ReLateBound(self.binder_index, br);\n         self.tcx().mk_region(region)\n     }\n "}, {"sha": "71ce50f7453725be234897a53cd5daa4a2a9b100", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -525,10 +525,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints.iter().map(move |&constraint| {\n-            let ty::OutlivesPredicate(k1, r2) =\n-                substitute_value(self.tcx, result_subst, constraint).skip_binder();\n+            let predicate = substitute_value(self.tcx, result_subst, constraint);\n+            let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n \n-            let predicate = match k1.unpack() {\n+            let atom = match k1.unpack() {\n                 GenericArgKind::Lifetime(r1) => {\n                     ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                 }\n@@ -540,8 +540,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     // encounter this branch.\n                     span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n                 }\n-            }\n-            .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+            };\n+            let predicate =\n+                predicate.rebind(atom).potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n \n             Obligation::new(cause.clone(), param_env, predicate)\n         })"}, {"sha": "387f480814ae767a9b927cd65217a26627cd9136", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -87,6 +87,6 @@ where\n             c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n         };\n \n-        tcx.replace_escaping_bound_vars(value, fld_r, fld_t, fld_c).0\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t, fld_c)\n     }\n }"}, {"sha": "e38eebe23b1e1d11aba2ce7e29e432ce4d985a92", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -543,6 +543,10 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n+    fn visit_ct_substs(&self) -> bool {\n+        true\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<T>,\n@@ -551,7 +555,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn relate_item_substs(\n@@ -716,7 +720,10 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n-                    ConstVariableValue::Known { value: u } => self.relate(u, u),\n+                    ConstVariableValue::Known { value: u } => {\n+                        drop(inner);\n+                        self.relate(u, u)\n+                    }\n                     ConstVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n                             Ok(c)\n@@ -815,6 +822,10 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n+    fn visit_ct_substs(&self) -> bool {\n+        true\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,\n@@ -833,7 +844,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n@@ -870,6 +881,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => Ok(t),\n             _ => relate::super_relate_tys(self, t, t),\n         }\n     }"}, {"sha": "777107ed863109854043de0ba6bd3dcf133b53ad", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -153,6 +153,7 @@ fn msg_span_from_early_bound_and_free_regions(\n         Some(Node::Item(it)) => item_scope_tag(&it),\n         Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n         Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+        Some(Node::ForeignItem(it)) => foreign_item_scope_tag(&it),\n         _ => unreachable!(),\n     };\n     let (prefix, span) = match *region {\n@@ -165,7 +166,9 @@ fn msg_span_from_early_bound_and_free_regions(\n             }\n             (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n-        ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n+        ty::ReFree(ty::FreeRegion {\n+            bound_region: ty::BoundRegionKind::BrNamed(_, name), ..\n+        }) => {\n             let mut sp = sm.guess_head_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n@@ -231,6 +234,13 @@ fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n     }\n }\n \n+fn foreign_item_scope_tag(item: &hir::ForeignItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ForeignItemKind::Fn(..) => \"method body\",\n+        hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => \"associated item\",\n+    }\n+}\n+\n fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option<Span>) {\n     let lo = tcx.sess.source_map().lookup_char_pos(span.lo());\n     (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n@@ -415,7 +425,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     // obviously it never weeds out ALL errors.\n     fn process_errors(\n         &self,\n-        errors: &Vec<RegionResolutionError<'tcx>>,\n+        errors: &[RegionResolutionError<'tcx>],\n     ) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n \n@@ -440,7 +450,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n-            errors.clone()\n+            errors.to_owned()\n         } else {\n             errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n         };\n@@ -496,7 +506,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n@@ -1622,7 +1632,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 (TypeError::ObjectUnsafeCoercion(_), _) => {\n-                    diag.note_unsuccessfull_coercion(found, expected);\n+                    diag.note_unsuccessful_coercion(found, expected);\n                 }\n                 (_, _) => {\n                     debug!(\n@@ -2279,7 +2289,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         var_origin: RegionVariableOrigin,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let br_string = |br: ty::BoundRegion| {\n+        let br_string = |br: ty::BoundRegionKind| {\n             let mut s = match br {\n                 ty::BrNamed(_, name) => name.to_string(),\n                 _ => String::new(),"}, {"sha": "b014b9832e783731c63f25f808846a1c1b21950b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     pub(super) fn find_anon_type(\n         &self,\n         region: Region<'tcx>,\n-        br: &ty::BoundRegion,\n+        br: &ty::BoundRegionKind,\n     ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let hir_id = self.tcx().hir().local_def_id_to_hir_id(anon_reg.def_id);\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn find_component_for_bound_region(\n         &self,\n         arg: &'tcx hir::Ty<'tcx>,\n-        br: &ty::BoundRegion,\n+        br: &ty::BoundRegionKind,\n     ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n             tcx: self.tcx(),\n@@ -80,7 +80,7 @@ struct FindNestedTypeVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // The bound_region corresponding to the Refree(freeregion)\n     // associated with the anonymous region we are looking for.\n-    bound_region: ty::BoundRegion,\n+    bound_region: ty::BoundRegionKind,\n     // The type where the anonymous lifetime appears\n     // for e.g., Vec<`&u8`> and <`&u8`>\n     found_type: Option<&'tcx hir::Ty<'tcx>>,\n@@ -207,7 +207,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n struct TyPathVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     found_it: bool,\n-    bound_region: ty::BoundRegion,\n+    bound_region: ty::BoundRegionKind,\n     current_index: ty::DebruijnIndex,\n }\n "}, {"sha": "0958afa03082a22e1da445c7c44baa6e3eccbe3a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -132,10 +132,7 @@ impl Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n                 [segment]\n                     if segment\n                         .res\n-                        .map(|res| match res {\n-                            Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _) => true,\n-                            _ => false,\n-                        })\n+                        .map(|res| matches!(res, Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _)))\n                         .unwrap_or(false) =>\n                 {\n                     self.types.push(path.span);"}, {"sha": "17a56046a5cc89b39c2c2b5611f4c89655b90d70", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -14,8 +14,8 @@ pub(super) struct AnonymousParamInfo<'tcx> {\n     pub param: &'tcx hir::Param<'tcx>,\n     /// The type corresponding to the anonymous region parameter.\n     pub param_ty: Ty<'tcx>,\n-    /// The ty::BoundRegion corresponding to the anonymous region.\n-    pub bound_region: ty::BoundRegion,\n+    /// The ty::BoundRegionKind corresponding to the anonymous region.\n+    pub bound_region: ty::BoundRegionKind,\n     /// The `Span` of the parameter type.\n     pub param_ty_span: Span,\n     /// Signals that the argument is the first parameter in the declaration.\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ebr) => (\n                 self.tcx().parent(ebr.def_id).unwrap(),\n-                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+                ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region\n         };\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     pub(super) fn is_return_type_anon(\n         &self,\n         scope_def_id: LocalDefId,\n-        br: ty::BoundRegion,\n+        br: ty::BoundRegionKind,\n         decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx().type_of(scope_def_id);"}, {"sha": "728dc2de370319897fee6eb3dff68a2e66940bd1", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -93,10 +93,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     /// True for free regions other than `'static`.\n     pub fn is_free(&self, r: Region<'_>) -> bool {\n-        match *r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-            _ => false,\n-        }\n+        matches!(r, ty::ReEarlyBound(_) | ty::ReFree(_))\n     }\n \n     /// True if `r` is a free region or static of the sort that this"}, {"sha": "e794903fca3aaefb15fff95dabff9879fb9a3399", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -77,10 +77,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // (i.e., if there are no placeholders).\n         let next_universe = self.universe().next_universe();\n \n-        let fld_r = |br| {\n+        let fld_r = |br: ty::BoundRegion| {\n             self.tcx.mk_region(ty::RePlaceholder(ty::PlaceholderRegion {\n                 universe: next_universe,\n-                name: br,\n+                name: br.kind,\n             }))\n         };\n "}, {"sha": "ab34cda8cc18f514edec1adcd522ea453b05d3cd", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -393,10 +393,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if self.expand_node(a_region, b_vid, b_data) {\n                     changes.push(b_vid);\n                 }\n-                match *b_data {\n-                    VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                    _ => true,\n-                }\n+                !matches!(b_data, VarValue::Value(ReStatic) | VarValue::ErrorValue)\n             });\n         }\n     }\n@@ -972,11 +969,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::IsEmpty => {\n-                if let ty::ReEmpty(_) = min {\n-                    true\n-                } else {\n-                    false\n-                }\n+                matches!(min, ty::ReEmpty(_))\n             }\n \n             VerifyBound::AnyBound(bs) => {"}, {"sha": "56d9634213ae515b4c39c85d86a55b36b1bb249a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -450,7 +450,7 @@ pub enum RegionVariableOrigin {\n \n     /// Region variables created for bound regions\n     /// in a function or method that is called\n-    LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n+    LateBoundRegion(Span, ty::BoundRegionKind, LateBoundRegionConversionTime),\n \n     UpvarRegion(ty::UpvarId, Span),\n \n@@ -1317,7 +1317,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n-            return value.clone(); // Avoid duplicated subst-folding.\n+            return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n@@ -1421,7 +1421,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n+        let fld_r =\n+            |br: ty::BoundRegion| self.next_region_var(LateBoundRegion(span, br.kind, lbrct));\n         let fld_t = |_| {\n             self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::MiscVariable,"}, {"sha": "97ef685cf6f82f0543e68cee40002edc260083c1", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -176,7 +176,7 @@ where\n                         universe\n                     });\n \n-                    let placeholder = ty::PlaceholderRegion { universe, name: br };\n+                    let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n                     delegate.next_placeholder_region(placeholder)\n                 } else {\n                     delegate.next_existential_region_var(true)\n@@ -1008,6 +1008,6 @@ where\n         self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n         self.first_free_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n+        Ok(a.rebind(result))\n     }\n }"}, {"sha": "33bddf1dedc1b2a6fa055207cbc5892b66e1357e", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -90,6 +90,7 @@ impl ProjectionCacheKey<'tcx> {\n pub enum ProjectionCacheEntry<'tcx> {\n     InProgress,\n     Ambiguous,\n+    Recur,\n     Error,\n     NormalizedTy(NormalizedTy<'tcx>),\n }\n@@ -143,7 +144,12 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value\n         );\n-        let fresh_key = self.map().insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        let mut map = self.map();\n+        if let Some(ProjectionCacheEntry::Recur) = map.get(&key) {\n+            debug!(\"Not overwriting Recur\");\n+            return;\n+        }\n+        let fresh_key = map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n@@ -197,6 +203,14 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n \n+    /// Indicates that while trying to normalize `key`, `key` was required to\n+    /// be normalized again. Selection or evaluation should eventually report\n+    /// an error here.\n+    pub fn recur(&mut self, key: ProjectionCacheKey<'tcx>) {\n+        let fresh = self.map().insert(key, ProjectionCacheEntry::Recur);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// error.\n     pub fn error(&mut self, key: ProjectionCacheKey<'tcx>) {"}, {"sha": "28eb1fed6a0ab6ae415bbab188878a0bb7fe8803", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -25,8 +25,9 @@ use std::sync::{Arc, Mutex};\n pub type Result<T> = result::Result<T, ErrorReported>;\n \n /// Represents a compiler session.\n+///\n /// Can be used to run `rustc_interface` queries.\n-/// Created by passing `Config` to `run_compiler`.\n+/// Created by passing [`Config`] to [`run_compiler`].\n pub struct Compiler {\n     pub(crate) sess: Lrc<Session>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,"}, {"sha": "461ee08592275c9eab7dda327d11446640991383", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -29,6 +29,7 @@ use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n+use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n@@ -95,7 +96,7 @@ declare_box_region_type!(\n /// harness if one is to be provided, injection of a dependency on the\n /// standard library and prelude, and name resolution.\n ///\n-/// Returns `None` if we're aborting after handling -W help.\n+/// Returns [`None`] if we're aborting after handling -W help.\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n     lint_store: Lrc<LintStore>,\n@@ -306,11 +307,27 @@ fn configure_and_expand_inner<'a>(\n             ecx.check_unused_macros();\n         });\n \n+        let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .sess\n+            .parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .map(|(span, node_id)| (*span, *node_id))\n+            .collect();\n+        missing_fragment_specifiers.sort_unstable_by_key(|(span, _)| *span);\n+\n+        let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n+\n+        for (span, node_id) in missing_fragment_specifiers {\n+            let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n+            let msg = \"missing fragment specifier\";\n+            resolver.lint_buffer().buffer_lint(lint, node_id, span, msg);\n+        }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n \n-        let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n         if recursion_limit_hit {\n             // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n             // with a large AST\n@@ -872,7 +889,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     // Avoid overwhelming user with errors if borrow checking failed.\n     // I'm not sure how helpful this is, to be honest, but it avoids a\n-    // lot of annoying errors in the compile-fail tests (basically,\n+    // lot of annoying errors in the ui tests (basically,\n     // lint warnings and so on -- kindck used to do this abort, but\n     // kindck is gone now). -nmatsakis\n     if sess.has_errors() {\n@@ -996,6 +1013,23 @@ pub fn start_codegen<'tcx>(\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n \n+    // Don't run these test assertions when not doing codegen. Compiletest tries to build\n+    // build-fail tests in check mode first and expects it to not give an error in that case.\n+    if tcx.sess.opts.output_types.should_codegen() {\n+        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+        rustc_symbol_mangling::test::report_symbol_names(tcx);\n+    }\n+\n+    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n+    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n+\n+    // We assume that no queries are run past here. If there are new queries\n+    // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n+        tcx.alloc_self_profile_query_strings();\n+    }\n+\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "9c49f926d417bb9e5b31656343435db0ba716b30", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -23,7 +23,11 @@ use std::cell::{Ref, RefCell, RefMut};\n use std::rc::Rc;\n \n /// Represent the result of a query.\n-/// This result can be stolen with the `take` method and generated with the `compute` method.\n+///\n+/// This result can be stolen with the [`take`] method and generated with the [`compute`] method.\n+///\n+/// [`take`]: Self::take\n+/// [`compute`]: Self::compute\n pub struct Query<T> {\n     result: RefCell<Option<Result<T>>>,\n }\n@@ -276,7 +280,7 @@ impl<'tcx> Queries<'tcx> {\n                 // Don't do code generation if there were any errors\n                 self.session().compile_status()?;\n \n-                // Hook for compile-fail tests.\n+                // Hook for UI tests.\n                 Self::check_for_rustc_errors_attr(tcx);\n \n                 Ok(passes::start_codegen(&***self.codegen_backend(), tcx, &*outputs.peek()))\n@@ -285,7 +289,7 @@ impl<'tcx> Queries<'tcx> {\n     }\n \n     /// Check for the `#[rustc_error]` annotation, which forces an error in codegen. This is used\n-    /// to write compile-fail tests that actually test that compilation succeeds without reporting\n+    /// to write UI tests that actually test that compilation succeeds without reporting\n     /// an error.\n     fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n         let def_id = match tcx.entry_fn(LOCAL_CRATE) {\n@@ -399,6 +403,7 @@ impl Linker {\n             return Ok(());\n         }\n \n+        let _timer = sess.prof.verbose_generic_activity(\"link_crate\");\n         self.codegen_backend.link(&self.sess, codegen_results, &self.prepare_outputs)\n     }\n }"}, {"sha": "3e94f1637734a0f2ca09edde93c8e9bb653ff895", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -587,7 +587,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(share_generics, Some(true));\n     tracked!(show_span, Some(String::from(\"abc\")));\n     tracked!(src_hash_algorithm, Some(SourceFileHashAlgorithm::Sha1));\n-    tracked!(symbol_mangling_version, SymbolManglingVersion::V0);\n+    tracked!(symbol_mangling_version, Some(SymbolManglingVersion::V0));\n     tracked!(teach, true);\n     tracked!(thinlto, Some(true));\n     tracked!(tune_cpu, Some(String::from(\"abc\")));"}, {"sha": "b4dd0fc2449ecb7ffbe653bcb4b6a4f6403df5c2", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -201,7 +201,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n                 return Err(EscapeError::NoBraceInUnicodeEscape);\n             }\n \n-            // First characrer must be a hexadecimal digit.\n+            // First character must be a hexadecimal digit.\n             let mut n_digits = 1;\n             let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n                 '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),"}, {"sha": "a8371274f61f8cabf9cc5ca1f655a51db67c4a80", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -868,7 +868,7 @@ impl EarlyLintPass for AnonymousParameters {\n         if let ast::AssocItemKind::Fn(_, ref sig, _, _) = it.kind {\n             for arg in sig.decl.inputs.iter() {\n                 if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n-                    if ident.name == kw::Invalid {\n+                    if ident.name == kw::Empty {\n                         cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n                             let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n \n@@ -2299,7 +2299,7 @@ impl EarlyLintPass for IncompleteFeatures {\n     }\n }\n \n-const HAS_MIN_FEATURES: &[Symbol] = &[sym::const_generics, sym::specialization];\n+const HAS_MIN_FEATURES: &[Symbol] = &[sym::specialization];\n \n declare_lint! {\n     /// The `invalid_value` lint detects creating a value that is not valid,"}, {"sha": "c82fe50af870621c4f4400400f278104f58a5032", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -261,6 +261,7 @@ impl LintStore {\n         }\n     }\n \n+    #[track_caller]\n     pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.get(new_name) {\n             Some(&Id(lint_id)) => lint_id,\n@@ -728,7 +729,7 @@ impl<'tcx> LateContext<'tcx> {\n \n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n-    /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;\n+    /// Anonymous scopes such as `extern` imports are matched with `kw::Empty`;\n     /// inherent `impl` blocks are matched with the name of the type.\n     ///\n     /// Instead of using this method, it is often preferable to instead use\n@@ -786,7 +787,7 @@ impl<'tcx> LateContext<'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Ok(())\n             }"}, {"sha": "5cece569903c77aa8d02e88b6c286ede650321e1", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,7 +12,9 @@ use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::LevelSource;\n use rustc_middle::lint::LintDiagnosticBuilder;\n-use rustc_middle::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n+use rustc_middle::lint::{\n+    struct_lint_level, LintLevelMap, LintLevelSets, LintLevelSource, LintSet,\n+};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::{builtin, Level, Lint, LintId};\n@@ -91,7 +93,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             };\n             for id in ids {\n                 self.check_gated_lint(id, DUMMY_SP);\n-                let src = LintSource::CommandLine(lint_flag_val, orig_level);\n+                let src = LintLevelSource::CommandLine(lint_flag_val, orig_level);\n                 specs.insert(id, (level, src));\n             }\n         }\n@@ -128,19 +130,19 @@ impl<'s> LintLevelsBuilder<'s> {\n                 );\n                 diag_builder.span_label(src.span(), \"overruled by previous forbid\");\n                 match old_src {\n-                    LintSource::Default => {\n+                    LintLevelSource::Default => {\n                         diag_builder.note(&format!(\n                             \"`forbid` lint level is the default for {}\",\n                             id.to_string()\n                         ));\n                     }\n-                    LintSource::Node(_, forbid_source_span, reason) => {\n+                    LintLevelSource::Node(_, forbid_source_span, reason) => {\n                         diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n                         if let Some(rationale) = reason {\n                             diag_builder.note(&rationale.as_str());\n                         }\n                     }\n-                    LintSource::CommandLine(_, _) => {\n+                    LintLevelSource::CommandLine(_, _) => {\n                         diag_builder.note(\"`forbid` lint level was set on command line\");\n                     }\n                 }\n@@ -276,7 +278,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                 let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n                 match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n-                        let src = LintSource::Node(name, li.span(), reason);\n+                        let src = LintLevelSource::Node(name, li.span(), reason);\n                         for &id in ids {\n                             self.check_gated_lint(id, attr.span);\n                             self.insert_spec(&mut specs, id, (level, src));\n@@ -287,7 +289,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                         match result {\n                             Ok(ids) => {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n-                                let src = LintSource::Node(\n+                                let src = LintLevelSource::Node(\n                                     Symbol::intern(complete_name),\n                                     li.span(),\n                                     reason,\n@@ -324,7 +326,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     },\n                                 );\n \n-                                let src = LintSource::Node(\n+                                let src = LintLevelSource::Node(\n                                     Symbol::intern(&new_lint_name),\n                                     li.span(),\n                                     reason,\n@@ -403,7 +405,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                 }\n \n                 let (lint_attr_name, lint_attr_span) = match *src {\n-                    LintSource::Node(name, span, _) => (name, span),\n+                    LintLevelSource::Node(name, span, _) => (name, span),\n                     _ => continue,\n                 };\n \n@@ -460,7 +462,7 @@ impl<'s> LintLevelsBuilder<'s> {\n     }\n \n     /// Find the lint level for a lint.\n-    pub fn lint_level(&self, lint: &'static Lint) -> (Level, LintSource) {\n+    pub fn lint_level(&self, lint: &'static Lint) -> (Level, LintLevelSource) {\n         self.sets.get_lint_level(lint, self.cur, None, self.sess)\n     }\n "}, {"sha": "2336b52619ab8a0e40230522d306b06ab17b1d17", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -283,7 +283,6 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         UNUSED_MUT,\n         UNREACHABLE_CODE,\n         UNREACHABLE_PATTERNS,\n-        OVERLAPPING_PATTERNS,\n         UNUSED_MUST_USE,\n         UNUSED_UNSAFE,\n         PATH_STATEMENTS,\n@@ -335,6 +334,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n     store.register_renamed(\"intra_doc_link_resolution_failure\", \"broken_intra_doc_links\");\n+    store.register_renamed(\"overlapping_patterns\", \"overlapping_range_endpoints\");\n     store.register_removed(\"unknown_features\", \"replaced by an error\");\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");"}, {"sha": "0fe6564880f010b8e46de5a64a3c589753a39f34", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -28,40 +28,26 @@ declare_lint_pass!(RedundantSemicolons => [REDUNDANT_SEMICOLONS]);\n \n impl EarlyLintPass for RedundantSemicolons {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n-        let mut after_item_stmt = false;\n         let mut seq = None;\n         for stmt in block.stmts.iter() {\n             match (&stmt.kind, &mut seq) {\n                 (StmtKind::Empty, None) => seq = Some((stmt.span, false)),\n                 (StmtKind::Empty, Some(seq)) => *seq = (seq.0.to(stmt.span), true),\n-                (_, seq) => {\n-                    maybe_lint_redundant_semis(cx, seq, after_item_stmt);\n-                    after_item_stmt = matches!(stmt.kind, StmtKind::Item(_));\n-                }\n+                (_, seq) => maybe_lint_redundant_semis(cx, seq),\n             }\n         }\n-        maybe_lint_redundant_semis(cx, &mut seq, after_item_stmt);\n+        maybe_lint_redundant_semis(cx, &mut seq);\n     }\n }\n \n-fn maybe_lint_redundant_semis(\n-    cx: &EarlyContext<'_>,\n-    seq: &mut Option<(Span, bool)>,\n-    after_item_stmt: bool,\n-) {\n+fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, bool)>) {\n     if let Some((span, multiple)) = seq.take() {\n         // FIXME: Find a better way of ignoring the trailing\n         // semicolon from macro expansion\n         if span == rustc_span::DUMMY_SP {\n             return;\n         }\n \n-        // FIXME: Lint on semicolons after item statements\n-        // once doing so doesn't break bootstrapping\n-        if after_item_stmt {\n-            return;\n-        }\n-\n         cx.struct_span_lint(REDUNDANT_SEMICOLONS, span, |lint| {\n             let (msg, rem) = if multiple {\n                 (\"unnecessary trailing semicolons\", \"remove these semicolons\")"}, {"sha": "5e1f94c071c65157a4a7d3e13d6153872e04fcaf", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -218,8 +218,10 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 }\n                 ty::Dynamic(binder, _) => {\n                     let mut has_emitted = false;\n-                    for predicate in binder.skip_binder().iter() {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n+                    for predicate in binder.iter() {\n+                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n+                            predicate.skip_binder()\n+                        {\n                             let def_id = trait_ref.def_id;\n                             let descr_post =\n                                 &format!(\" trait object{}{}\", plural_suffix, descr_post,);"}, {"sha": "1c692d4f207620197a4a3f3102cae67b8c7df5ad", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -588,8 +588,8 @@ declare_lint! {\n }\n \n declare_lint! {\n-    /// The `overlapping_patterns` lint detects `match` arms that have\n-    /// [range patterns] that overlap.\n+    /// The `overlapping_range_endpoints` lint detects `match` arms that have [range patterns] that\n+    /// overlap on their endpoints.\n     ///\n     /// [range patterns]: https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns\n     ///\n@@ -607,13 +607,12 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// It is likely a mistake to have range patterns in a match expression\n-    /// that overlap. Check that the beginning and end values are what you\n-    /// expect, and keep in mind that with `..=` the left and right bounds are\n-    /// inclusive.\n-    pub OVERLAPPING_PATTERNS,\n+    /// It is likely a mistake to have range patterns in a match expression that overlap in this\n+    /// way. Check that the beginning and end values are what you expect, and keep in mind that\n+    /// with `..=` the left and right bounds are inclusive.\n+    pub OVERLAPPING_RANGE_ENDPOINTS,\n     Warn,\n-    \"detects overlapping patterns\"\n+    \"detects range patterns with overlapping endpoints\"\n }\n \n declare_lint! {\n@@ -1228,6 +1227,50 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `missing_fragment_specifier` lint is issued when an unused pattern in a\n+    /// `macro_rules!` macro definition has a meta-variable (e.g. `$e`) that is not\n+    /// followed by a fragment specifier (e.g. `:expr`).\n+    ///\n+    /// This warning can always be fixed by removing the unused pattern in the\n+    /// `macro_rules!` macro definition.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// macro_rules! foo {\n+    ///    () => {};\n+    ///    ($name) => { };\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///    foo!();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// To fix this, remove the unused pattern from the `macro_rules!` macro definition:\n+    ///\n+    /// ```rust\n+    /// macro_rules! foo {\n+    ///     () => {};\n+    /// }\n+    /// fn main() {\n+    ///     foo!();\n+    /// }\n+    /// ```\n+    pub MISSING_FRAGMENT_SPECIFIER,\n+    Deny,\n+    \"detects missing fragment specifiers in unused `macro_rules!` patterns\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint! {\n     /// The `late_bound_lifetime_arguments` lint detects generic lifetime\n     /// arguments in path segments with late bound lifetime parameters.\n@@ -2809,7 +2852,7 @@ declare_lint_pass! {\n         DEAD_CODE,\n         UNREACHABLE_CODE,\n         UNREACHABLE_PATTERNS,\n-        OVERLAPPING_PATTERNS,\n+        OVERLAPPING_RANGE_ENDPOINTS,\n         BINDINGS_WITH_VARIANT_NAME,\n         UNUSED_MACROS,\n         WARNINGS,\n@@ -2828,6 +2871,7 @@ declare_lint_pass! {\n         CONST_ITEM_MUTATION,\n         SAFE_PACKED_BORROWS,\n         PATTERNS_IN_FNS_WITHOUT_BODY,\n+        MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n         ORDER_DEPENDENT_TRAIT_OBJECTS,\n         COHERENCE_LEAK_CHECK,"}, {"sha": "621363bed80e1ea2c989a6580da34ee1c82c66a6", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -201,10 +201,10 @@ fn main() {\n     cmd.args(&components);\n \n     for lib in output(&mut cmd).split_whitespace() {\n-        let name = if lib.starts_with(\"-l\") {\n-            &lib[2..]\n-        } else if lib.starts_with('-') {\n-            &lib[1..]\n+        let name = if let Some(stripped) = lib.strip_prefix(\"-l\") {\n+            stripped\n+        } else if let Some(stripped) = lib.strip_prefix('-') {\n+            stripped\n         } else if Path::new(lib).exists() {\n             // On MSVC llvm-config will print the full name to libraries, but\n             // we're only interested in the name part\n@@ -241,17 +241,17 @@ fn main() {\n     cmd.arg(llvm_link_arg).arg(\"--ldflags\");\n     for lib in output(&mut cmd).split_whitespace() {\n         if is_crossed {\n-            if lib.starts_with(\"-LIBPATH:\") {\n-                println!(\"cargo:rustc-link-search=native={}\", lib[9..].replace(&host, &target));\n-            } else if lib.starts_with(\"-L\") {\n-                println!(\"cargo:rustc-link-search=native={}\", lib[2..].replace(&host, &target));\n+            if let Some(stripped) = lib.strip_prefix(\"-LIBPATH:\") {\n+                println!(\"cargo:rustc-link-search=native={}\", stripped.replace(&host, &target));\n+            } else if let Some(stripped) = lib.strip_prefix(\"-L\") {\n+                println!(\"cargo:rustc-link-search=native={}\", stripped.replace(&host, &target));\n             }\n-        } else if lib.starts_with(\"-LIBPATH:\") {\n-            println!(\"cargo:rustc-link-search=native={}\", &lib[9..]);\n-        } else if lib.starts_with(\"-l\") {\n-            println!(\"cargo:rustc-link-lib={}\", &lib[2..]);\n-        } else if lib.starts_with(\"-L\") {\n-            println!(\"cargo:rustc-link-search=native={}\", &lib[2..]);\n+        } else if let Some(stripped) = lib.strip_prefix(\"-LIBPATH:\") {\n+            println!(\"cargo:rustc-link-search=native={}\", stripped);\n+        } else if let Some(stripped) = lib.strip_prefix(\"-l\") {\n+            println!(\"cargo:rustc-link-lib={}\", stripped);\n+        } else if let Some(stripped) = lib.strip_prefix(\"-L\") {\n+            println!(\"cargo:rustc-link-search=native={}\", stripped);\n         }\n     }\n \n@@ -262,10 +262,10 @@ fn main() {\n     let llvm_linker_flags = tracked_env_var_os(\"LLVM_LINKER_FLAGS\");\n     if let Some(s) = llvm_linker_flags {\n         for lib in s.into_string().unwrap().split_whitespace() {\n-            if lib.starts_with(\"-l\") {\n-                println!(\"cargo:rustc-link-lib={}\", &lib[2..]);\n-            } else if lib.starts_with(\"-L\") {\n-                println!(\"cargo:rustc-link-search=native={}\", &lib[2..]);\n+            if let Some(stripped) = lib.strip_prefix(\"-l\") {\n+                println!(\"cargo:rustc-link-lib={}\", stripped);\n+            } else if let Some(stripped) = lib.strip_prefix(\"-L\") {\n+                println!(\"cargo:rustc-link-search=native={}\", stripped);\n             }\n         }\n     }"}, {"sha": "2264908995bb7f34ce335e3224b97e6f4c911a14", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -450,7 +450,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool AsmComments,\n     bool EmitStackSizeSection,\n     bool RelaxELFRelocations,\n-    bool UseInitArray) {\n+    bool UseInitArray,\n+    const char *SplitDwarfFile) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -476,6 +477,9 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.MCOptions.AsmVerbose = AsmComments;\n   Options.MCOptions.PreserveAsmComments = AsmComments;\n   Options.MCOptions.ABIName = ABIStr;\n+  if (SplitDwarfFile) {\n+      Options.MCOptions.SplitDwarfFile = SplitDwarfFile;\n+  }\n   Options.RelaxELFRelocations = RelaxELFRelocations;\n   Options.UseInitArray = UseInitArray;\n \n@@ -610,7 +614,7 @@ static TargetMachine::CodeGenFileType fromRust(LLVMRustFileType Type) {\n \n extern \"C\" LLVMRustResult\n LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M, const char *Path,\n+                        LLVMModuleRef M, const char *Path, const char *DwoPath,\n                         LLVMRustFileType RustFileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   auto FileType = fromRust(RustFileType);\n@@ -626,8 +630,22 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   }\n \n   buffer_ostream BOS(OS);\n-  unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false);\n-  PM->run(*unwrap(M));\n+  if (DwoPath) {\n+    raw_fd_ostream DOS(DwoPath, EC, sys::fs::F_None);\n+    EC.clear();\n+    if (EC)\n+        ErrorInfo = EC.message();\n+    if (ErrorInfo != \"\") {\n+      LLVMRustSetLastError(ErrorInfo.c_str());\n+      return LLVMRustResult::Failure;\n+    }\n+    buffer_ostream DBOS(DOS);\n+    unwrap(Target)->addPassesToEmitFile(*PM, BOS, &DBOS, FileType, false);\n+    PM->run(*unwrap(M));\n+  } else {\n+    unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false);\n+    PM->run(*unwrap(M));\n+  }\n \n   // Apparently `addPassesToEmitFile` adds a pointer to our on-the-stack output\n   // stream (OS), so the only real safe place to delete this is here? Don't we"}, {"sha": "c0ff62c17beb56db0c28d438d649256bc33d37c8", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -690,13 +690,14 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n     const char *Producer, size_t ProducerLen, bool isOptimized,\n     const char *Flags, unsigned RuntimeVer,\n     const char *SplitName, size_t SplitNameLen,\n-    LLVMRustDebugEmissionKind Kind) {\n+    LLVMRustDebugEmissionKind Kind,\n+    uint64_t DWOId, bool SplitDebugInlining) {\n   auto *File = unwrapDI<DIFile>(FileRef);\n \n   return wrap(Builder->createCompileUnit(Lang, File, StringRef(Producer, ProducerLen),\n                                          isOptimized, Flags, RuntimeVer,\n                                          StringRef(SplitName, SplitNameLen),\n-                                         fromRust(Kind)));\n+                                         fromRust(Kind), DWOId, SplitDebugInlining));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile("}, {"sha": "152ae159aed446556ad243c1d58cf10f6a9df691", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -21,7 +21,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n #[proc_macro]\n pub fn symbols(input: TokenStream) -> TokenStream {\n-    symbols::symbols(input)\n+    symbols::symbols(input.into()).into()\n }\n \n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);"}, {"sha": "6d876784be65368fcff190fd872d8ff9fb673f53", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,8 +5,8 @@ use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n use syn::{\n-    braced, parenthesized, parse_macro_input, AttrStyle, Attribute, Block, Error, Expr, Ident,\n-    ReturnType, Token, Type,\n+    braced, parenthesized, parse_macro_input, parse_quote, AttrStyle, Attribute, Block, Error,\n+    Expr, Ident, ReturnType, Token, Type,\n };\n \n mod kw {\n@@ -272,6 +272,40 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 if desc.is_some() {\n                     panic!(\"duplicate modifier `desc` for query `{}`\", query.name);\n                 }\n+                // If there are no doc-comments, give at least some idea of what\n+                // it does by showing the query description.\n+                if query.doc_comments.is_empty() {\n+                    use ::syn::*;\n+                    let mut list = list.iter();\n+                    let format_str: String = match list.next() {\n+                        Some(&Expr::Lit(ExprLit { lit: Lit::Str(ref lit_str), .. })) => {\n+                            lit_str.value().replace(\"`{}`\", \"{}\") // We add them later anyways for consistency\n+                        }\n+                        _ => panic!(\"Expected a string literal\"),\n+                    };\n+                    let mut fmt_fragments = format_str.split(\"{}\");\n+                    let mut doc_string = fmt_fragments.next().unwrap().to_string();\n+                    list.map(::quote::ToTokens::to_token_stream).zip(fmt_fragments).for_each(\n+                        |(tts, next_fmt_fragment)| {\n+                            use ::core::fmt::Write;\n+                            write!(\n+                                &mut doc_string,\n+                                \" `{}` {}\",\n+                                tts.to_string().replace(\" . \", \".\"),\n+                                next_fmt_fragment,\n+                            )\n+                            .unwrap();\n+                        },\n+                    );\n+                    let doc_string = format!(\n+                        \"[query description - consider adding a doc-comment!] {}\",\n+                        doc_string\n+                    );\n+                    let comment = parse_quote! {\n+                        #[doc = #doc_string]\n+                    };\n+                    query.doc_comments.push(comment);\n+                }\n                 desc = Some((tcx, list));\n             }\n             QueryModifier::FatalCycle => {"}, {"sha": "5c061a9d3c7949a529c077090889d80a51265a8b", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -574,7 +574,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n     /// ```\n     /// This function builds the entire call to format!.\n-    fn build_format(&self, input: &String, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n+    fn build_format(&self, input: &str, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n         // This set is used later to generate the final format string. To keep builds reproducible,\n         // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n         // of a HashSet."}, {"sha": "5b932864dff5da7a8a547bce4a1601de9ac3cbdb", "filename": "compiler/rustc_macros/src/symbols.rs", "status": "modified", "additions": 116, "deletions": 73, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,8 +1,35 @@\n-use proc_macro::TokenStream;\n+//! Proc macro which builds the Symbol table\n+//!\n+//! # Debugging\n+//!\n+//! Since this proc-macro does some non-trivial work, debugging it is important.\n+//! This proc-macro can be invoked as an ordinary unit test, like so:\n+//!\n+//! ```bash\n+//! cd compiler/rustc_macros\n+//! cargo test symbols::test_symbols -- --nocapture\n+//! ```\n+//!\n+//! This unit test finds the `symbols!` invocation in `compiler/rustc_span/src/symbol.rs`\n+//! and runs it. It verifies that the output token stream can be parsed as valid module\n+//! items and that no errors were produced.\n+//!\n+//! You can also view the generated code by using `cargo expand`:\n+//!\n+//! ```bash\n+//! cargo install cargo-expand          # this is necessary only once\n+//! cd compiler/rustc_span\n+//! cargo expand > /tmp/rustc_span.rs   # it's a big file\n+//! ```\n+\n+use proc_macro2::{Span, TokenStream};\n use quote::quote;\n-use std::collections::HashSet;\n+use std::collections::HashMap;\n use syn::parse::{Parse, ParseStream, Result};\n-use syn::{braced, parse_macro_input, Ident, LitStr, Token};\n+use syn::{braced, punctuated::Punctuated, Ident, LitStr, Token};\n+\n+#[cfg(test)]\n+mod tests;\n \n mod kw {\n     syn::custom_keyword!(Keywords);\n@@ -19,7 +46,6 @@ impl Parse for Keyword {\n         let name = input.parse()?;\n         input.parse::<Token![:]>()?;\n         let value = input.parse()?;\n-        input.parse::<Token![,]>()?;\n \n         Ok(Keyword { name, value })\n     }\n@@ -37,144 +63,156 @@ impl Parse for Symbol {\n             Ok(_) => Some(input.parse()?),\n             Err(_) => None,\n         };\n-        input.parse::<Token![,]>()?;\n \n         Ok(Symbol { name, value })\n     }\n }\n \n-/// A type used to greedily parse another type until the input is empty.\n-struct List<T>(Vec<T>);\n-\n-impl<T: Parse> Parse for List<T> {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let mut list = Vec::new();\n-        while !input.is_empty() {\n-            list.push(input.parse()?);\n-        }\n-        Ok(List(list))\n-    }\n-}\n-\n struct Input {\n-    keywords: List<Keyword>,\n-    symbols: List<Symbol>,\n+    keywords: Punctuated<Keyword, Token![,]>,\n+    symbols: Punctuated<Symbol, Token![,]>,\n }\n \n impl Parse for Input {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n         input.parse::<kw::Keywords>()?;\n         let content;\n         braced!(content in input);\n-        let keywords = content.parse()?;\n+        let keywords = Punctuated::parse_terminated(&content)?;\n \n         input.parse::<kw::Symbols>()?;\n         let content;\n         braced!(content in input);\n-        let symbols = content.parse()?;\n+        let symbols = Punctuated::parse_terminated(&content)?;\n \n         Ok(Input { keywords, symbols })\n     }\n }\n \n+#[derive(Default)]\n+struct Errors {\n+    list: Vec<syn::Error>,\n+}\n+\n+impl Errors {\n+    fn error(&mut self, span: Span, message: String) {\n+        self.list.push(syn::Error::new(span, message));\n+    }\n+}\n+\n pub fn symbols(input: TokenStream) -> TokenStream {\n-    let input = parse_macro_input!(input as Input);\n+    let (mut output, errors) = symbols_with_errors(input);\n+\n+    // If we generated any errors, then report them as compiler_error!() macro calls.\n+    // This lets the errors point back to the most relevant span. It also allows us\n+    // to report as many errors as we can during a single run.\n+    output.extend(errors.into_iter().map(|e| e.to_compile_error()));\n+\n+    output\n+}\n+\n+fn symbols_with_errors(input: TokenStream) -> (TokenStream, Vec<syn::Error>) {\n+    let mut errors = Errors::default();\n+\n+    let input: Input = match syn::parse2(input) {\n+        Ok(input) => input,\n+        Err(e) => {\n+            // This allows us to display errors at the proper span, while minimizing\n+            // unrelated errors caused by bailing out (and not generating code).\n+            errors.list.push(e);\n+            Input { keywords: Default::default(), symbols: Default::default() }\n+        }\n+    };\n \n     let mut keyword_stream = quote! {};\n     let mut symbols_stream = quote! {};\n-    let mut digits_stream = quote! {};\n     let mut prefill_stream = quote! {};\n     let mut counter = 0u32;\n-    let mut keys = HashSet::<String>::new();\n-    let mut prev_key: Option<String> = None;\n-    let mut errors = Vec::<String>::new();\n-\n-    let mut check_dup = |str: &str, errors: &mut Vec<String>| {\n-        if !keys.insert(str.to_string()) {\n-            errors.push(format!(\"Symbol `{}` is duplicated\", str));\n+    let mut keys =\n+        HashMap::<String, Span>::with_capacity(input.keywords.len() + input.symbols.len() + 10);\n+    let mut prev_key: Option<(Span, String)> = None;\n+\n+    let mut check_dup = |span: Span, str: &str, errors: &mut Errors| {\n+        if let Some(prev_span) = keys.get(str) {\n+            errors.error(span, format!(\"Symbol `{}` is duplicated\", str));\n+            errors.error(*prev_span, format!(\"location of previous definition\"));\n+        } else {\n+            keys.insert(str.to_string(), span);\n         }\n     };\n \n-    let mut check_order = |str: &str, errors: &mut Vec<String>| {\n-        if let Some(ref prev_str) = prev_key {\n+    let mut check_order = |span: Span, str: &str, errors: &mut Errors| {\n+        if let Some((prev_span, ref prev_str)) = prev_key {\n             if str < prev_str {\n-                errors.push(format!(\"Symbol `{}` must precede `{}`\", str, prev_str));\n+                errors.error(span, format!(\"Symbol `{}` must precede `{}`\", str, prev_str));\n+                errors.error(prev_span, format!(\"location of previous symbol `{}`\", prev_str));\n             }\n         }\n-        prev_key = Some(str.to_string());\n+        prev_key = Some((span, str.to_string()));\n     };\n \n     // Generate the listed keywords.\n-    for keyword in &input.keywords.0 {\n+    for keyword in input.keywords.iter() {\n         let name = &keyword.name;\n         let value = &keyword.value;\n-        check_dup(&value.value(), &mut errors);\n+        let value_string = value.value();\n+        check_dup(keyword.name.span(), &value_string, &mut errors);\n         prefill_stream.extend(quote! {\n             #value,\n         });\n         keyword_stream.extend(quote! {\n-            #[allow(non_upper_case_globals)]\n             pub const #name: Symbol = Symbol::new(#counter);\n         });\n         counter += 1;\n     }\n \n     // Generate the listed symbols.\n-    for symbol in &input.symbols.0 {\n+    for symbol in input.symbols.iter() {\n         let name = &symbol.name;\n         let value = match &symbol.value {\n             Some(value) => value.value(),\n             None => name.to_string(),\n         };\n-        check_dup(&value, &mut errors);\n-        check_order(&name.to_string(), &mut errors);\n+        check_dup(symbol.name.span(), &value, &mut errors);\n+        check_order(symbol.name.span(), &name.to_string(), &mut errors);\n+\n         prefill_stream.extend(quote! {\n             #value,\n         });\n         symbols_stream.extend(quote! {\n-            #[allow(rustc::default_hash_types)]\n-            #[allow(non_upper_case_globals)]\n             pub const #name: Symbol = Symbol::new(#counter);\n         });\n         counter += 1;\n     }\n \n     // Generate symbols for the strings \"0\", \"1\", ..., \"9\".\n+    let digits_base = counter;\n+    counter += 10;\n     for n in 0..10 {\n         let n = n.to_string();\n-        check_dup(&n, &mut errors);\n+        check_dup(Span::call_site(), &n, &mut errors);\n         prefill_stream.extend(quote! {\n             #n,\n         });\n-        digits_stream.extend(quote! {\n-            Symbol::new(#counter),\n-        });\n-        counter += 1;\n     }\n+    let _ = counter; // for future use\n \n-    if !errors.is_empty() {\n-        for error in errors.into_iter() {\n-            eprintln!(\"error: {}\", error)\n-        }\n-        panic!(\"errors in `Keywords` and/or `Symbols`\");\n-    }\n+    let output = quote! {\n+        const SYMBOL_DIGITS_BASE: u32 = #digits_base;\n \n-    let tt = TokenStream::from(quote! {\n-        macro_rules! keywords {\n-            () => {\n-                #keyword_stream\n-            }\n+        #[doc(hidden)]\n+        #[allow(non_upper_case_globals)]\n+        mod kw_generated {\n+            use super::Symbol;\n+            #keyword_stream\n         }\n \n-        macro_rules! define_symbols {\n-            () => {\n-                #symbols_stream\n-\n-                #[allow(non_upper_case_globals)]\n-                pub const digits_array: &[Symbol; 10] = &[\n-                    #digits_stream\n-                ];\n-            }\n+        #[allow(rustc::default_hash_types)]\n+        #[allow(non_upper_case_globals)]\n+        #[doc(hidden)]\n+        pub mod sym_generated {\n+            use super::Symbol;\n+            #symbols_stream\n         }\n \n         impl Interner {\n@@ -184,11 +222,16 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n                 ])\n             }\n         }\n-    });\n+    };\n \n-    // To see the generated code generated, uncomment this line, recompile, and\n-    // run the resulting output through `rustfmt`.\n-    //eprintln!(\"{}\", tt);\n+    (output, errors.list)\n \n-    tt\n+    // To see the generated code, use the \"cargo expand\" command.\n+    // Do this once to install:\n+    //      cargo install cargo-expand\n+    //\n+    // Then, cd to rustc_span and run:\n+    //      cargo expand > /tmp/rustc_span_expanded.rs\n+    //\n+    // and read that file.\n }"}, {"sha": "82b4b876978f248abe50058bef19e491ed9061c9", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,102 @@\n+use super::*;\n+\n+// This test is mainly here for interactive development. Use this test while\n+// you're working on the proc-macro defined in this file.\n+#[test]\n+fn test_symbols() {\n+    // We textually include the symbol.rs file, which contains the list of all\n+    // symbols, keywords, and common words. Then we search for the\n+    // `symbols! { ... }` call.\n+\n+    static SYMBOL_RS_FILE: &str = include_str!(\"../../../rustc_span/src/symbol.rs\");\n+\n+    let file = syn::parse_file(SYMBOL_RS_FILE).unwrap();\n+    let symbols_path: syn::Path = syn::parse_quote!(symbols);\n+\n+    let m: &syn::ItemMacro = file\n+        .items\n+        .iter()\n+        .filter_map(|i| {\n+            if let syn::Item::Macro(m) = i {\n+                if m.mac.path == symbols_path { Some(m) } else { None }\n+            } else {\n+                None\n+            }\n+        })\n+        .next()\n+        .expect(\"did not find `symbols!` macro invocation.\");\n+\n+    let body_tokens = m.mac.tokens.clone();\n+\n+    test_symbols_macro(body_tokens, &[]);\n+}\n+\n+fn test_symbols_macro(input: TokenStream, expected_errors: &[&str]) {\n+    let (output, found_errors) = symbols_with_errors(input);\n+\n+    // It should always parse.\n+    let _parsed_file = syn::parse2::<syn::File>(output).unwrap();\n+\n+    assert_eq!(\n+        found_errors.len(),\n+        expected_errors.len(),\n+        \"Macro generated a different number of errors than expected\"\n+    );\n+\n+    for (found_error, &expected_error) in found_errors.iter().zip(expected_errors.iter()) {\n+        let found_error_str = format!(\"{}\", found_error);\n+        assert_eq!(found_error_str, expected_error);\n+    }\n+}\n+\n+#[test]\n+fn check_dup_keywords() {\n+    let input = quote! {\n+        Keywords {\n+            Crate: \"crate\",\n+            Crate: \"crate\",\n+        }\n+        Symbols {}\n+    };\n+    test_symbols_macro(input, &[\"Symbol `crate` is duplicated\", \"location of previous definition\"]);\n+}\n+\n+#[test]\n+fn check_dup_symbol() {\n+    let input = quote! {\n+        Keywords {}\n+        Symbols {\n+            splat,\n+            splat,\n+        }\n+    };\n+    test_symbols_macro(input, &[\"Symbol `splat` is duplicated\", \"location of previous definition\"]);\n+}\n+\n+#[test]\n+fn check_dup_symbol_and_keyword() {\n+    let input = quote! {\n+        Keywords {\n+            Splat: \"splat\",\n+        }\n+        Symbols {\n+            splat,\n+        }\n+    };\n+    test_symbols_macro(input, &[\"Symbol `splat` is duplicated\", \"location of previous definition\"]);\n+}\n+\n+#[test]\n+fn check_symbol_order() {\n+    let input = quote! {\n+        Keywords {}\n+        Symbols {\n+            zebra,\n+            aardvark,\n+        }\n+    };\n+    test_symbols_macro(\n+        input,\n+        &[\"Symbol `aardvark` must precede `zebra`\", \"location of previous symbol `zebra`\"],\n+    );\n+}"}, {"sha": "019ca5174a22386986ca6f0f6f5ca89b492e432c", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -706,14 +706,21 @@ impl<'a> CrateLoader<'a> {\n         self.inject_dependency_if(cnum, \"a panic runtime\", &|data| data.needs_panic_runtime());\n     }\n \n-    fn inject_profiler_runtime(&mut self) {\n+    fn inject_profiler_runtime(&mut self, krate: &ast::Crate) {\n         if (self.sess.opts.debugging_opts.instrument_coverage\n             || self.sess.opts.debugging_opts.profile\n             || self.sess.opts.cg.profile_generate.enabled())\n             && !self.sess.opts.debugging_opts.no_profiler_runtime\n         {\n             info!(\"loading profiler\");\n \n+            if self.sess.contains_name(&krate.attrs, sym::no_core) {\n+                self.sess.err(\n+                    \"`profiler_builtins` crate (required by compiler options) \\\n+                               is not compatible with crate attribute `#![no_core]`\",\n+                );\n+            }\n+\n             let name = sym::profiler_builtins;\n             let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n             let data = self.cstore.get_crate_data(cnum);\n@@ -879,7 +886,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn postprocess(&mut self, krate: &ast::Crate) {\n-        self.inject_profiler_runtime();\n+        self.inject_profiler_runtime(krate);\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n "}, {"sha": "744fdc83a91ec8d3089ce74ebf634062a7b2a62a", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -132,7 +132,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n impl Collector<'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLib) {\n-        if lib.name.as_ref().map(|&s| s == kw::Invalid).unwrap_or(false) {\n+        if lib.name.as_ref().map(|&s| s == kw::Empty).unwrap_or(false) {\n             match span {\n                 Some(span) => {\n                     struct_span_err!("}, {"sha": "4dfe3e8487762d631820ed6a32435051fd67c880", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -319,10 +319,6 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n         self.opaque.position()\n     }\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n         &mut self.type_shorthands\n     }\n@@ -663,7 +659,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n             panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n             profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n-            symbol_mangling_version: tcx.sess.opts.debugging_opts.symbol_mangling_version,\n+            symbol_mangling_version: tcx.sess.opts.debugging_opts.get_symbol_mangling_version(),\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "47b7768b410a1eb15b2eaf99072de4ad30390396", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -30,3 +30,4 @@ chalk-ir = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "728bfef9f467373bf7cf712f62547afb819c20ea", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefPathHash, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n@@ -91,9 +91,9 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n     type StableHashingContext = StableHashingContext<'tcx>;\n \n-    fn register_reused_dep_path_hash(&self, hash: DefPathHash) {\n+    fn register_reused_dep_node(&self, dep_node: &DepNode) {\n         if let Some(cache) = self.queries.on_disk_cache.as_ref() {\n-            cache.register_reused_dep_path_hash(hash)\n+            cache.register_reused_dep_node(*self, dep_node)\n         }\n     }\n "}, {"sha": "9d392c7b26bf7f7606bc8bbe96a786799e3c4dba", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -42,37 +42,25 @@ trait MaybeFnLike {\n \n impl MaybeFnLike for hir::Item<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ItemKind::Fn(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ItemKind::Fn(..))\n     }\n }\n \n impl MaybeFnLike for hir::ImplItem<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ImplItemKind::Fn(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ImplItemKind::Fn(..))\n     }\n }\n \n impl MaybeFnLike for hir::TraitItem<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)))\n     }\n }\n \n impl MaybeFnLike for hir::Expr<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ExprKind::Closure(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ExprKind::Closure(..))\n     }\n }\n "}, {"sha": "09d5b102103120aebae9b7084e1aaf7f5c055547", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -379,7 +379,7 @@ impl<'hir> Map<'hir> {\n     pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n         self.body(id).params.iter().map(|arg| match arg.pat.kind {\n             PatKind::Binding(_, _, ident, _) => ident,\n-            _ => Ident::new(kw::Invalid, rustc_span::DUMMY_SP),\n+            _ => Ident::new(kw::Empty, rustc_span::DUMMY_SP),\n         })\n     }\n "}, {"sha": "00db19019c480d690023a13d2ecd605f23762d51", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,21 +4,43 @@ use crate::ty::Ty;\n use rustc_hir::HirId;\n use rustc_target::abi::VariantIdx;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum PlaceBase {\n-    /// A temporary variable\n+    /// A temporary variable.\n     Rvalue,\n-    /// A named `static` item\n+    /// A named `static` item.\n     StaticItem,\n-    /// A named local variable\n+    /// A named local variable.\n     Local(HirId),\n-    /// An upvar referenced by closure env\n+    /// An upvar referenced by closure env.\n     Upvar(ty::UpvarId),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum ProjectionKind {\n-    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type.\n     Deref,\n \n     /// `B.F` where `B` is the base expression and `F` is\n@@ -36,19 +58,30 @@ pub enum ProjectionKind {\n     Subslice,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct Projection<'tcx> {\n-    /// Type after the projection is being applied.\n+    /// Type after the projection is applied.\n     pub ty: Ty<'tcx>,\n \n-    /// Defines the type of access\n+    /// Defines the kind of access made by the projection.\n     pub kind: ProjectionKind,\n }\n \n /// A `Place` represents how a value is located in memory.\n ///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+/// This is an HIR version of [`rustc_middle::mir::Place`].\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n     pub base_ty: Ty<'tcx>,\n@@ -60,13 +93,13 @@ pub struct Place<'tcx> {\n \n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+/// This is an HIR version of [`rustc_middle::mir::Place`].\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,\n \n-    /// Information about the `Place`\n+    /// Information about the `Place`.\n     pub place: Place<'tcx>,\n }\n \n@@ -77,10 +110,7 @@ impl<'tcx> PlaceWithHirId<'tcx> {\n         base: PlaceBase,\n         projections: Vec<Projection<'tcx>>,\n     ) -> PlaceWithHirId<'tcx> {\n-        PlaceWithHirId {\n-            hir_id: hir_id,\n-            place: Place { base_ty: base_ty, base: base, projections: projections },\n-        }\n+        PlaceWithHirId { hir_id, place: Place { base_ty, base, projections } }\n     }\n }\n "}, {"sha": "573b514e8445f5acb7d4bee0ae1fa2fef662b161", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -70,16 +70,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::ReEmpty(universe) => {\n                 universe.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BrAnon(i)) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BrNamed(def_id, name)) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name) }) => {\n                 db.hash_stable(hcx, hasher);\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BrEnv) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv }) => {\n                 db.hash_stable(hcx, hasher);\n             }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {"}, {"sha": "e106db38b2c9a3f4d9a6905486a9dadf18819623", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -323,9 +323,10 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     GenericArgKind::Type(..) => {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n                     }\n-                    GenericArgKind::Lifetime(..) => tcx\n-                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n-                        .into(),\n+                    GenericArgKind::Lifetime(..) => {\n+                        let br = ty::BoundRegion { kind: ty::BrAnon(i) };\n+                        tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+                    }\n                     GenericArgKind::Const(ct) => tcx\n                         .mk_const(ty::Const {\n                             ty: ct.ty,"}, {"sha": "6ae83a7f667504a70c31e19fd84eb75f1ee87deb", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -8,7 +8,7 @@\n //! - **MIR.** The \"mid-level (M) intermediate representation (IR)\" is\n //!   defined in the `mir` module. This module contains only the\n //!   *definition* of the MIR; the passes that transform and operate\n-//!   on MIR are found in `librustc_mir` crate.\n+//!   on MIR are found in `rustc_mir` crate.\n //! - **Types.** The internal representation of types used in rustc is\n //!   defined in the `ty` module. This includes the **type context**\n //!   (or `tcx`), which is the central context during most of"}, {"sha": "64d850192f4493b8e0d51fe609d5be3ec39ffce6", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -13,7 +13,7 @@ use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n \n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n-pub enum LintSource {\n+pub enum LintLevelSource {\n     /// Lint is at the default level as declared\n     /// in rustc or a plugin.\n     Default,\n@@ -22,30 +22,31 @@ pub enum LintSource {\n     Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n \n     /// Lint level was set by a command-line flag.\n-    /// The provided `Level` is the level specified on the command line -\n-    /// the actual level may be lower due to `--cap-lints`\n+    /// The provided `Level` is the level specified on the command line.\n+    /// (The actual level may be lower due to `--cap-lints`.)\n     CommandLine(Symbol, Level),\n }\n \n-impl LintSource {\n+impl LintLevelSource {\n     pub fn name(&self) -> Symbol {\n         match *self {\n-            LintSource::Default => symbol::kw::Default,\n-            LintSource::Node(name, _, _) => name,\n-            LintSource::CommandLine(name, _) => name,\n+            LintLevelSource::Default => symbol::kw::Default,\n+            LintLevelSource::Node(name, _, _) => name,\n+            LintLevelSource::CommandLine(name, _) => name,\n         }\n     }\n \n     pub fn span(&self) -> Span {\n         match *self {\n-            LintSource::Default => DUMMY_SP,\n-            LintSource::Node(_, span, _) => span,\n-            LintSource::CommandLine(_, _) => DUMMY_SP,\n+            LintLevelSource::Default => DUMMY_SP,\n+            LintLevelSource::Node(_, span, _) => span,\n+            LintLevelSource::CommandLine(_, _) => DUMMY_SP,\n         }\n     }\n }\n \n-pub type LevelSource = (Level, LintSource);\n+/// A tuple of a lint level and its source.\n+pub type LevelSource = (Level, LintLevelSource);\n \n pub struct LintLevelSets {\n     pub list: Vec<LintSet>,\n@@ -113,7 +114,7 @@ impl LintLevelSets {\n         id: LintId,\n         mut idx: u32,\n         aux: Option<&FxHashMap<LintId, LevelSource>>,\n-    ) -> (Option<Level>, LintSource) {\n+    ) -> (Option<Level>, LintLevelSource) {\n         if let Some(specs) = aux {\n             if let Some(&(level, src)) = specs.get(&id) {\n                 return (Some(level), src);\n@@ -125,7 +126,7 @@ impl LintLevelSets {\n                     if let Some(&(level, src)) = specs.get(&id) {\n                         return (Some(level), src);\n                     }\n-                    return (None, LintSource::Default);\n+                    return (None, LintLevelSource::Default);\n                 }\n                 LintSet::Node { ref specs, parent } => {\n                     if let Some(&(level, src)) = specs.get(&id) {\n@@ -213,7 +214,7 @@ pub fn struct_lint_level<'s, 'd>(\n     sess: &'s Session,\n     lint: &'static Lint,\n     level: Level,\n-    src: LintSource,\n+    src: LintLevelSource,\n     span: Option<MultiSpan>,\n     decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>) + 'd,\n ) {\n@@ -223,7 +224,7 @@ pub fn struct_lint_level<'s, 'd>(\n         sess: &'s Session,\n         lint: &'static Lint,\n         level: Level,\n-        src: LintSource,\n+        src: LintLevelSource,\n         span: Option<MultiSpan>,\n         decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n     ) {\n@@ -274,14 +275,14 @@ pub fn struct_lint_level<'s, 'd>(\n \n         let name = lint.name_lower();\n         match src {\n-            LintSource::Default => {\n+            LintLevelSource::Default => {\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n                     &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n                 );\n             }\n-            LintSource::CommandLine(lint_flag_val, orig_level) => {\n+            LintLevelSource::CommandLine(lint_flag_val, orig_level) => {\n                 let flag = match orig_level {\n                     Level::Warn => \"-W\",\n                     Level::Deny => \"-D\",\n@@ -310,7 +311,7 @@ pub fn struct_lint_level<'s, 'd>(\n                     );\n                 }\n             }\n-            LintSource::Node(lint_attr_name, src, reason) => {\n+            LintLevelSource::Node(lint_attr_name, src, reason) => {\n                 if let Some(rationale) = reason {\n                     err.note(&rationale.as_str());\n                 }"}, {"sha": "54188985d7c5f18f56c24980d5f7ed37140d9e7a", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -8,7 +8,9 @@ use rustc_macros::HashStable;\n use std::fmt;\n use std::hash::Hash;\n \n-// Accessibility levels, sorted in ascending order\n+/// Represents the levels of accessibility an item can have.\n+///\n+/// The variants are sorted in ascending order of accessibility.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum AccessLevel {\n     /// Superset of `AccessLevel::Reachable` used to mark impl Trait items.\n@@ -18,13 +20,13 @@ pub enum AccessLevel {\n     /// public, then type `T` is reachable. Its values can be obtained by other crates\n     /// even if the type itself is not nameable.\n     Reachable,\n-    /// Public items + items accessible to other crates with help of `pub use` re-exports\n+    /// Public items + items accessible to other crates with the help of `pub use` re-exports.\n     Exported,\n-    /// Items accessible to other crates directly, without help of re-exports\n+    /// Items accessible to other crates directly, without the help of re-exports.\n     Public,\n }\n \n-// Accessibility levels for reachable HIR nodes\n+/// Holds a map of accessibility levels for reachable HIR nodes.\n #[derive(Clone)]\n pub struct AccessLevels<Id = HirId> {\n     pub map: FxHashMap<Id, AccessLevel>,"}, {"sha": "eb48198991c294dd08cf0864999d31bad36adf80", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -332,7 +332,7 @@ pub struct ScopeTree {\n pub struct YieldData {\n     /// The `Span` of the yield.\n     pub span: Span,\n-    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n+    /// The number of expressions and patterns appearing before the `yield` in the body, plus one.\n     pub expr_and_pat_count: usize,\n     pub source: hir::YieldSource,\n }\n@@ -449,9 +449,7 @@ impl ScopeTree {\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n-    /// returns `Some((span, expr_count))` with the span of a yield we found and\n-    /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n-    /// If there a are multiple yields in a scope, the one with the highest number is returned.\n+    /// returns `Some(YieldData)`. If not, returns `None`.\n     pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n         self.yield_in_scope.get(&scope).cloned()\n     }"}, {"sha": "4f08057a7e3235cf7724499911f8b67b1f3bfb3a", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -132,37 +132,37 @@ pub fn report_unstable(\n /// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>) -> bool {\n-    let since = if let Some(since) = since {\n-        if is_since_rustc_version {\n-            since\n-        } else {\n-            // We assume that the deprecation is in effect if it's not a\n-            // rustc version.\n-            return true;\n-        }\n-    } else {\n-        // If since attribute is not set, then we're definitely in effect.\n-        return true;\n-    };\n     fn parse_version(ver: &str) -> Vec<u32> {\n         // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n-    if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n-        let since: Vec<u32> = parse_version(&since);\n-        let rustc: Vec<u32> = parse_version(rustc);\n-        // We simply treat invalid `since` attributes as relating to a previous\n-        // Rust version, thus always displaying the warning.\n-        if since.len() != 3 {\n-            return true;\n-        }\n-        since <= rustc\n-    } else {\n-        // By default, a deprecation warning applies to\n-        // the current version of the compiler.\n-        true\n+    if !is_since_rustc_version {\n+        // The `since` field doesn't have semantic purpose in the stable `deprecated`\n+        // attribute, only in `rustc_deprecated`.\n+        return true;\n     }\n+\n+    if let Some(since) = since {\n+        if since == \"TBD\" {\n+            return false;\n+        }\n+\n+        if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n+            let since: Vec<u32> = parse_version(&since);\n+            let rustc: Vec<u32> = parse_version(rustc);\n+            // We simply treat invalid `since` attributes as relating to a previous\n+            // Rust version, thus always displaying the warning.\n+            if since.len() != 3 {\n+                return true;\n+            }\n+            return since <= rustc;\n+        }\n+    };\n+\n+    // Assume deprecation is in effect if \"since\" field is missing\n+    // or if we can't determine the current Rust version.\n+    true\n }\n \n pub fn deprecation_suggestion(\n@@ -182,19 +182,24 @@ pub fn deprecation_suggestion(\n }\n \n pub fn deprecation_message(depr: &Deprecation, kind: &str, path: &str) -> (String, &'static Lint) {\n-    let (message, lint) = if deprecation_in_effect(\n-        depr.is_since_rustc_version,\n-        depr.since.map(Symbol::as_str).as_deref(),\n-    ) {\n+    let since = depr.since.map(Symbol::as_str);\n+    let (message, lint) = if deprecation_in_effect(depr.is_since_rustc_version, since.as_deref()) {\n         (format!(\"use of deprecated {} `{}`\", kind, path), DEPRECATED)\n     } else {\n         (\n-            format!(\n-                \"use of {} `{}` that will be deprecated in future version {}\",\n-                kind,\n-                path,\n-                depr.since.unwrap()\n-            ),\n+            if since.as_deref() == Some(\"TBD\") {\n+                format!(\n+                    \"use of {} `{}` that will be deprecated in a future Rust version\",\n+                    kind, path\n+                )\n+            } else {\n+                format!(\n+                    \"use of {} `{}` that will be deprecated in future version {}\",\n+                    kind,\n+                    path,\n+                    since.unwrap()\n+                )\n+            },\n             DEPRECATED_IN_FUTURE,\n         )\n     };"}, {"sha": "95096d0fb719c314c6d8e9df8e81ce450df39a16", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -118,17 +118,11 @@ impl CoverageKind {\n     }\n \n     pub fn is_counter(&self) -> bool {\n-        match self {\n-            Self::Counter { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::Counter { .. })\n     }\n \n     pub fn is_expression(&self) -> bool {\n-        match self {\n-            Self::Expression { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::Expression { .. })\n     }\n \n     pub fn is_unreachable(&self) -> bool {"}, {"sha": "5f028975bd0e31ad0d67197ec0d3f79441014b01", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,62 @@\n+use rustc_data_structures::graph::{\n+    self, DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors,\n+};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::OnceCell;\n+use rustc_serialize as serialize;\n+\n+/// Helper type to cache the result of `graph::is_cyclic`.\n+#[derive(Clone, Debug)]\n+pub(super) struct GraphIsCyclicCache {\n+    cache: OnceCell<bool>,\n+}\n+\n+impl GraphIsCyclicCache {\n+    #[inline]\n+    pub(super) fn new() -> Self {\n+        GraphIsCyclicCache { cache: OnceCell::new() }\n+    }\n+\n+    pub(super) fn is_cyclic<G>(&self, graph: &G) -> bool\n+    where\n+        G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n+    {\n+        *self.cache.get_or_init(|| graph::is_cyclic(graph))\n+    }\n+\n+    /// Invalidates the cache.\n+    #[inline]\n+    pub(super) fn invalidate(&mut self) {\n+        // Invalidating the cache requires mutating the MIR, which in turn requires a unique\n+        // reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+        // callers of `invalidate` have a unique reference to the MIR and thus to the\n+        // cache. This means we never need to do synchronization when `invalidate` is called,\n+        // we can simply reinitialize the `OnceCell`.\n+        self.cache = OnceCell::new();\n+    }\n+}\n+\n+impl<S: serialize::Encoder> serialize::Encodable<S> for GraphIsCyclicCache {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl<D: serialize::Decoder> serialize::Decodable<D> for GraphIsCyclicCache {\n+    #[inline]\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for GraphIsCyclicCache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    GraphIsCyclicCache,\n+}"}, {"sha": "80b58642136eeaf1db1097a803f5571ed0afa6b3", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -132,7 +132,6 @@ pub use self::pointer::{Pointer, PointerArithmetic};\n /// Uniquely identifies one of the following:\n /// - A constant\n /// - A static\n-/// - A const fn where all arguments (if any) are zero-sized types\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct GlobalId<'tcx> {"}, {"sha": "a69555fd1a8cec34ceb0cfb2a534511aaa45bd9e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -35,11 +35,13 @@ use std::ops::{ControlFlow, Index, IndexMut};\n use std::slice;\n use std::{iter, mem, option};\n \n+use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n pub mod abstract_const;\n pub mod coverage;\n+mod graph_cyclic_cache;\n pub mod interpret;\n pub mod mono;\n mod predecessors;\n@@ -227,6 +229,7 @@ pub struct Body<'tcx> {\n     pub is_polymorphic: bool,\n \n     predecessor_cache: PredecessorCache,\n+    is_cyclic: GraphIsCyclicCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -267,6 +270,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n         body\n@@ -296,6 +300,7 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n         body\n@@ -309,11 +314,12 @@ impl<'tcx> Body<'tcx> {\n     #[inline]\n     pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         // Because the user could mutate basic block terminators via this reference, we need to\n-        // invalidate the predecessor cache.\n+        // invalidate the caches.\n         //\n         // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n-        // invalidate the predecessor cache.\n+        // invalidate the caches.\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         &mut self.basic_blocks\n     }\n \n@@ -322,6 +328,7 @@ impl<'tcx> Body<'tcx> {\n         &mut self,\n     ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls)\n     }\n \n@@ -334,13 +341,14 @@ impl<'tcx> Body<'tcx> {\n         &mut Vec<VarDebugInfo<'tcx>>,\n     ) {\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n     }\n \n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n-        graph::is_cyclic(self)\n+        self.is_cyclic.is_cyclic(self)\n     }\n \n     #[inline]\n@@ -1060,6 +1068,23 @@ impl<'tcx> LocalDecl<'tcx> {\n     }\n }\n \n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n+pub enum VarDebugInfoContents<'tcx> {\n+    /// NOTE(eddyb) There's an unenforced invariant that this `Place` is\n+    /// based on a `Local`, not a `Static`, and contains no indexing.\n+    Place(Place<'tcx>),\n+    Const(Constant<'tcx>),\n+}\n+\n+impl<'tcx> Debug for VarDebugInfoContents<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        match self {\n+            VarDebugInfoContents::Const(c) => write!(fmt, \"{}\", c),\n+            VarDebugInfoContents::Place(p) => write!(fmt, \"{:?}\", p),\n+        }\n+    }\n+}\n+\n /// Debug information pertaining to a user variable.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct VarDebugInfo<'tcx> {\n@@ -1071,9 +1096,7 @@ pub struct VarDebugInfo<'tcx> {\n     pub source_info: SourceInfo,\n \n     /// Where the data for this user variable is to be found.\n-    /// NOTE(eddyb) There's an unenforced invariant that this `Place` is\n-    /// based on a `Local`, not a `Static`, and contains no indexing.\n-    pub place: Place<'tcx>,\n+    pub value: VarDebugInfoContents<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -1741,6 +1764,21 @@ impl<'tcx> Place<'tcx> {\n     pub fn as_ref(&self) -> PlaceRef<'tcx> {\n         PlaceRef { local: self.local, projection: &self.projection }\n     }\n+\n+    /// Iterate over the projections in evaluation order, i.e., the first element is the base with\n+    /// its projection and then subsequently more projections are added.\n+    /// As a concrete example, given the place a.b.c, this would yield:\n+    /// - (a, .b)\n+    /// - (a.b, .c)\n+    /// Given a place without projections, the iterator is empty.\n+    pub fn iter_projections(\n+        self,\n+    ) -> impl Iterator<Item = (PlaceRef<'tcx>, PlaceElem<'tcx>)> + DoubleEndedIterator {\n+        self.projection.iter().enumerate().map(move |(i, proj)| {\n+            let base = PlaceRef { local: self.local, projection: &self.projection[..i] };\n+            (base, proj)\n+        })\n+    }\n }\n \n impl From<Local> for Place<'_> {"}, {"sha": "89a93096f1c22689727a164454c5bc7651996396", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -46,7 +46,7 @@ pub enum UnsafetyViolationDetails {\n     UseOfMutableStatic,\n     UseOfExternStatic,\n     DerefOfRawPointer,\n-    AssignToNonCopyUnionField,\n+    AssignToDroppingUnionField,\n     AccessToUnionField,\n     MutationOfLayoutConstrainedField,\n     BorrowOfLayoutConstrainedField,\n@@ -94,8 +94,8 @@ impl UnsafetyViolationDetails {\n                 \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n                  and cause data races: all of these are undefined behavior\",\n             ),\n-            AssignToNonCopyUnionField => (\n-                \"assignment to non-`Copy` union field\",\n+            AssignToDroppingUnionField => (\n+                \"assignment to union field that might need dropping\",\n                 \"the previous content of the field will be dropped, which causes undefined \\\n                  behavior if the field was not properly initialized\",\n             ),"}, {"sha": "1b2c1076a6880317b30a613a889d8592e5a1b93c", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -136,6 +136,15 @@ impl<'tcx> Place<'tcx> {\n     }\n }\n \n+impl<'tcx> PlaceRef<'tcx> {\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n+    {\n+        Place::ty_from(self.local, &self.projection, local_decls, tcx)\n+    }\n+}\n+\n pub enum RvalueInitializationState {\n     Shallow,\n     Deep,"}, {"sha": "023555d91cc920d71d29e53fcf9c79738f5cc562", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -306,13 +306,13 @@ macro_rules! make_mir_visitor {\n \n                 let mut index = 0;\n                 for statement in statements {\n-                    let location = Location { block: block, statement_index: index };\n+                    let location = Location { block, statement_index: index };\n                     self.visit_statement(statement, location);\n                     index += 1;\n                 }\n \n                 if let Some(terminator) = terminator {\n-                    let location = Location { block: block, statement_index: index };\n+                    let location = Location { block, statement_index: index };\n                     self.visit_terminator(terminator, location);\n                 }\n             }\n@@ -829,16 +829,20 @@ macro_rules! make_mir_visitor {\n                 let VarDebugInfo {\n                     name: _,\n                     source_info,\n-                    place,\n+                    value,\n                 } = var_debug_info;\n \n                 self.visit_source_info(source_info);\n                 let location = START_BLOCK.start_location();\n-                self.visit_place(\n-                    place,\n-                    PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n-                    location,\n-                );\n+                match value {\n+                    VarDebugInfoContents::Const(c) => self.visit_constant(c, location),\n+                    VarDebugInfoContents::Place(place) =>\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n+                            location\n+                        ),\n+                }\n             }\n \n             fn super_source_scope(&mut self,"}, {"sha": "1e836d0a8425363e3b56ccb158fefa2a71f75920", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -576,11 +576,13 @@ rustc_queries! {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n-        query impl_trait_ref(key: DefId) -> Option<ty::TraitRef<'tcx>> {\n-            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(key) }\n+        /// Given an `impl_id`, return the trait it implements.\n+        /// Return `None` if this is an inherent impl.\n+        query impl_trait_ref(impl_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n+            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(impl_id) }\n         }\n-        query impl_polarity(key: DefId) -> ty::ImplPolarity {\n-            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(key) }\n+        query impl_polarity(impl_id: DefId) -> ty::ImplPolarity {\n+            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(impl_id) }\n         }\n \n         query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n@@ -917,8 +919,10 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query trait_of_item(def_id: DefId) -> Option<DefId> {\n-            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(def_id) }\n+        /// Given an `associated_item`, find the trait it belongs to.\n+        /// Return `None` if the `DefId` is not an associated item.\n+        query trait_of_item(associated_item: DefId) -> Option<DefId> {\n+            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(associated_item) }\n         }\n     }\n \n@@ -948,27 +952,37 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query all_local_trait_impls(key: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n+        /// Return all `impl` blocks in the current crate.\n+        ///\n+        /// To allow caching this between crates, you must pass in [`LOCAL_CRATE`] as the crate number.\n+        /// Passing in any other crate will cause an ICE.\n+        ///\n+        /// [`LOCAL_CRATE`]: rustc_hir::def_id::LOCAL_CRATE\n+        query all_local_trait_impls(local_crate: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n             desc { \"local trait impls\" }\n         }\n-        query trait_impls_of(key: DefId) -> ty::trait_def::TraitImpls {\n+\n+        /// Given a trait `trait_id`, return all known `impl` blocks.\n+        query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n+            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n         }\n-        query specialization_graph_of(key: DefId) -> specialization_graph::Graph {\n+\n+        query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n+            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n             cache_on_disk_if { true }\n         }\n-        query object_safety_violations(key: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n-            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n+        query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n+            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n         }\n \n         /// Gets the ParameterEnvironment for a given item; this environment\n         /// will be in \"user-facing\" mode, meaning that it is suitable for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n         /// unless you are doing MIR optimizations, in which case you\n+        /// might want to use `reveal_all()` method to change modes.\n         query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n             desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n         }\n@@ -1229,10 +1243,15 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n+        /// Given a crate and a trait, look up all impls of that trait in the crate.\n+        /// Return `(impl_id, self_ty)`.\n         query implementations_of_trait(_: (CrateNum, DefId))\n             -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n+\n+        /// Given a crate, look up all trait impls in that crate.\n+        /// Return `(impl_id, self_ty)`.\n         query all_trait_implementations(_: CrateNum)\n             -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up all (?) trait implementations\" }"}, {"sha": "a5962e3b3ba5726bc98e9f7bab27adca2a0755d2", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -118,6 +118,6 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }"}, {"sha": "df594690215bd767639d9c79f12c00a24e02326a", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -69,7 +69,6 @@ impl OpaqueEncoder for rustc_serialize::opaque::Encoder {\n pub trait TyEncoder<'tcx>: Encoder {\n     const CLEAR_CROSS_CRATE: bool;\n \n-    fn tcx(&self) -> TyCtxt<'tcx>;\n     fn position(&self) -> usize;\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n     fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize>;\n@@ -321,10 +320,14 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n+    for ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+{\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         let len = decoder.read_usize()?;\n-        Ok(decoder.tcx().mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+        Ok(decoder\n+            .tcx()\n+            .mk_poly_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n     }\n }\n \n@@ -373,7 +376,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n-    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     &'tcx Allocation,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,"}, {"sha": "b2db09cbc80652fdf1ba2f6d092461d8bd6e80b5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,7 +5,7 @@ use crate::dep_graph::{self, DepGraph, DepKind, DepNode, DepNodeExt};\n use crate::hir::exports::ExportMap;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintSource};\n+use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle;\n use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n@@ -87,7 +87,7 @@ pub struct CtxtInterners<'tcx> {\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind>,\n-    existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n+    poly_existential_predicates: InternedSet<'tcx, List<ty::Binder<ExistentialPredicate<'tcx>>>>,\n     predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n@@ -103,7 +103,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             type_list: Default::default(),\n             substs: Default::default(),\n             region: Default::default(),\n-            existential_predicates: Default::default(),\n+            poly_existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n             predicate: Default::default(),\n             predicates: Default::default(),\n@@ -299,6 +299,7 @@ pub struct ResolvedOpaqueTy<'tcx> {\n /// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n /// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n #[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TypeFoldable)]\n pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Type of the captured binding.\n     pub ty: Ty<'tcx>,\n@@ -423,7 +424,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n+    pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern  in which they are used.\n@@ -455,7 +456,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n-            generator_interior_types: Default::default(),\n+            generator_interior_types: ty::Binder::dummy(Default::default()),\n             treat_byte_string_as_slice: Default::default(),\n         }\n     }\n@@ -624,6 +625,19 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n     }\n \n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: DefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n@@ -876,7 +890,7 @@ pub struct FreeRegionInfo {\n     // `LocalDefId` corresponding to FreeRegion\n     pub def_id: LocalDefId,\n     // the bound region corresponding to FreeRegion\n-    pub boundregion: ty::BoundRegion,\n+    pub boundregion: ty::BoundRegionKind,\n     // checks if bound region is in Impl Item\n     pub is_impl_item: bool,\n }\n@@ -1372,7 +1386,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn lazy_normalization(self) -> bool {\n         let features = self.features();\n-        // Note: We do not enable lazy normalization for `features.min_const_generics`.\n+        // Note: We do not enable lazy normalization for `min_const_generics`.\n         features.const_generics || features.lazy_normalization_consts\n     }\n \n@@ -1398,15 +1412,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n+    // Returns the `DefId` and the `BoundRegionKind` corresponding to the given region.\n     pub fn is_suitable_region(self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => {\n                 (free_region.scope.expect_local(), free_region.bound_region)\n             }\n             ty::ReEarlyBound(ref ebr) => (\n                 self.parent(ebr.def_id).unwrap().expect_local(),\n-                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+                ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region\n         };\n@@ -1610,7 +1624,7 @@ nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n-nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n+nop_list_lift! {poly_existential_predicates; ty::Binder<ExistentialPredicate<'a>> => ty::Binder<ExistentialPredicate<'tcx>>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n@@ -2051,7 +2065,8 @@ slice_interners!(\n     type_list: _intern_type_list(Ty<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n-    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n+    poly_existential_predicates:\n+        _intern_poly_existential_predicates(ty::Binder<ExistentialPredicate<'tcx>>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n@@ -2282,7 +2297,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_dynamic(\n         self,\n-        obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n+        obj: &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>,\n     ) -> Ty<'tcx> {\n         self.mk_ty(Dynamic(obj, reg))\n@@ -2412,13 +2427,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         Place { local: place.local, projection: self.intern_place_elems(&projection) }\n     }\n \n-    pub fn intern_existential_predicates(\n+    pub fn intern_poly_existential_predicates(\n         self,\n-        eps: &[ExistentialPredicate<'tcx>],\n-    ) -> &'tcx List<ExistentialPredicate<'tcx>> {\n+        eps: &[ty::Binder<ExistentialPredicate<'tcx>>],\n+    ) -> &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>> {\n         assert!(!eps.is_empty());\n-        assert!(eps.array_windows().all(|[a, b]| a.stable_cmp(self, b) != Ordering::Greater));\n-        self._intern_existential_predicates(eps)\n+        assert!(\n+            eps.array_windows()\n+                .all(|[a, b]| a.skip_binder().stable_cmp(self, &b.skip_binder())\n+                    != Ordering::Greater)\n+        );\n+        self._intern_poly_existential_predicates(eps)\n     }\n \n     pub fn intern_predicates(self, preds: &[Predicate<'tcx>]) -> &'tcx List<Predicate<'tcx>> {\n@@ -2475,13 +2494,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn mk_existential_predicates<\n-        I: InternAs<[ExistentialPredicate<'tcx>], &'tcx List<ExistentialPredicate<'tcx>>>,\n+    pub fn mk_poly_existential_predicates<\n+        I: InternAs<\n+            [ty::Binder<ExistentialPredicate<'tcx>>],\n+            &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n+        >,\n     >(\n         self,\n         iter: I,\n     ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_existential_predicates(xs))\n+        iter.intern_with(|xs| self.intern_poly_existential_predicates(xs))\n     }\n \n     pub fn mk_predicates<I: InternAs<[Predicate<'tcx>], &'tcx List<Predicate<'tcx>>>>(\n@@ -2537,7 +2559,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         lint: &'static Lint,\n         mut id: hir::HirId,\n-    ) -> (Level, LintSource) {\n+    ) -> (Level, LintLevelSource) {\n         let sets = self.lint_levels(LOCAL_CRATE);\n         loop {\n             if let Some(pair) = sets.level_and_source(lint, id, self.sess) {"}, {"sha": "fe20925b38798b246765626fed97bac695ed403a", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n-use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_ast as ast;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n@@ -42,8 +42,8 @@ pub enum TypeError<'tcx> {\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n-    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n+    RegionsInsufficientlyPolymorphic(BoundRegionKind, Region<'tcx>),\n+    RegionsOverlyPolymorphic(BoundRegionKind, Region<'tcx>),\n     RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n@@ -58,7 +58,7 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     CyclicConst(&'tcx ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>>),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n \n@@ -94,7 +94,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         }\n \n-        let br_string = |br: ty::BoundRegion| match br {\n+        let br_string = |br: ty::BoundRegionKind| match br {\n             ty::BrNamed(_, name) => format!(\" {}\", name),\n             _ => String::new(),\n         };\n@@ -647,14 +647,11 @@ impl<T> Trait<T> for X {\n         let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n \n         // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n-        let callable_scope = match body_owner {\n-            Some(\n+        let callable_scope = matches!(body_owner, Some(\n                 hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n                 | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n-            ) => true,\n-            _ => false,\n-        };\n+            ));\n         let impl_comparison = matches!(\n             cause_code,\n             ObligationCauseCode::CompareImplMethodObligation { .. }"}, {"sha": "4de3d15924862cbdbfe4a19a3d2d68b6fea645e2", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -160,19 +160,15 @@ impl FlagComputation {\n             }\n \n             &ty::Dynamic(obj, r) => {\n-                self.bound_computation(obj, |computation, obj| {\n-                    for predicate in obj.iter() {\n-                        match predicate {\n-                            ty::ExistentialPredicate::Trait(tr) => {\n-                                computation.add_substs(tr.substs)\n-                            }\n-                            ty::ExistentialPredicate::Projection(p) => {\n-                                computation.add_existential_projection(&p);\n-                            }\n-                            ty::ExistentialPredicate::AutoTrait(_) => {}\n+                for predicate in obj.iter() {\n+                    self.bound_computation(predicate, |computation, predicate| match predicate {\n+                        ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n+                        ty::ExistentialPredicate::Projection(p) => {\n+                            computation.add_existential_projection(&p);\n                         }\n-                    }\n-                });\n+                        ty::ExistentialPredicate::AutoTrait(_) => {}\n+                    });\n+                }\n \n                 self.add_region(r);\n             }"}, {"sha": "382f3708c3d4bd7f7e3464844ce9a2fd5fd58ed3", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -534,8 +534,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n     /// binder is removed in the return type. The closure is invoked\n-    /// once for each unique `BoundRegion`; multiple references to the\n-    /// same `BoundRegion` will reuse the previous result. A map is\n+    /// once for each unique `BoundRegionKind`; multiple references to the\n+    /// same `BoundRegionKind` will reuse the previous result. A map is\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n     ///\n@@ -544,7 +544,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n         value: Binder<T>,\n-        fld_r: F,\n+        mut fld_r: F,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n@@ -555,7 +555,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         let fld_c = |bound_ct, ty| {\n             self.mk_const(ty::Const { val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct), ty })\n         };\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        let mut region_map = BTreeMap::new();\n+        let real_fld_r = |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let value = self.replace_escaping_bound_vars(value.skip_binder(), real_fld_r, fld_t, fld_c);\n+        (value, region_map)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n@@ -567,34 +570,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         mut fld_r: F,\n         mut fld_t: G,\n         mut fld_c: H,\n-    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    ) -> T\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        use rustc_data_structures::fx::FxHashMap;\n-\n-        let mut region_map = BTreeMap::new();\n-        let mut type_map = FxHashMap::default();\n-        let mut const_map = FxHashMap::default();\n-\n         if !value.has_escaping_bound_vars() {\n-            (value, region_map)\n+            value\n         } else {\n-            let mut real_fld_r = |br| *region_map.entry(br).or_insert_with(|| fld_r(br));\n-\n-            let mut real_fld_t =\n-                |bound_ty| *type_map.entry(bound_ty).or_insert_with(|| fld_t(bound_ty));\n-\n-            let mut real_fld_c =\n-                |bound_ct, ty| *const_map.entry(bound_ct).or_insert_with(|| fld_c(bound_ct, ty));\n-\n-            let mut replacer =\n-                BoundVarReplacer::new(self, &mut real_fld_r, &mut real_fld_t, &mut real_fld_c);\n-            let result = value.fold_with(&mut replacer);\n-            (result, region_map)\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t, &mut fld_c);\n+            value.fold_with(&mut replacer)\n         }\n     }\n \n@@ -604,7 +591,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn replace_bound_vars<T, F, G, H>(\n         self,\n         value: Binder<T>,\n-        fld_r: F,\n+        mut fld_r: F,\n         fld_t: G,\n         fld_c: H,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n@@ -614,7 +601,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        let mut region_map = BTreeMap::new();\n+        let real_fld_r = |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let value = self.replace_escaping_bound_vars(value.skip_binder(), real_fld_r, fld_t, fld_c);\n+        (value, region_map)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n@@ -626,7 +616,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.replace_late_bound_regions(value, |br| {\n             self.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope,\n-                bound_region: br,\n+                bound_region: br.kind,\n             }))\n         })\n         .0\n@@ -639,7 +629,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn collect_constrained_late_bound_regions<T>(\n         self,\n         value: &Binder<T>,\n-    ) -> FxHashSet<ty::BoundRegion>\n+    ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -650,7 +640,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn collect_referenced_late_bound_regions<T>(\n         self,\n         value: &Binder<T>,\n-    ) -> FxHashSet<ty::BoundRegion>\n+    ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -661,7 +651,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         value: &Binder<T>,\n         just_constraint: bool,\n-    ) -> FxHashSet<ty::BoundRegion>\n+    ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -695,7 +685,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut counter = 0;\n         Binder::bind(\n             self.replace_late_bound_regions(sig, |_| {\n-                let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(counter)));\n+                let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+                let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n                 counter += 1;\n                 r\n             })\n@@ -955,7 +946,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n /// into a hash set.\n struct LateBoundRegionsCollector {\n     current_index: ty::DebruijnIndex,\n-    regions: FxHashSet<ty::BoundRegion>,\n+    regions: FxHashSet<ty::BoundRegionKind>,\n \n     /// `true` if we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n@@ -1014,7 +1005,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if let ty::ReLateBound(debruijn, br) = *r {\n             if debruijn == self.current_index {\n-                self.regions.insert(br);\n+                self.regions.insert(br.kind);\n             }\n         }\n         ControlFlow::CONTINUE"}, {"sha": "d9aebfc8293b6ef504f466fe0e038af7f13951b9", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -17,7 +17,7 @@ pub struct DefIdForest {\n     /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n     /// of B, then only B will be in `root_ids`.\n     /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n-    /// its rare that this will contain even two IDs.\n+    /// it's rare that this will contain even two IDs.\n     root_ids: SmallVec<[DefId; 1]>,\n }\n "}, {"sha": "4475d4e9f2deac8421494998ecdbb44ab7975a0b", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1634,7 +1634,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         let layout = tcx.intern_layout(Layout {\n             variants: Variants::Multiple {\n-                tag: tag,\n+                tag,\n                 tag_encoding: TagEncoding::Direct,\n                 tag_field: tag_index,\n                 variants,\n@@ -2455,7 +2455,8 @@ impl<'tcx> ty::Instance<'tcx> {\n             ty::Generator(_, substs, _) => {\n                 let sig = substs.as_generator().poly_sig();\n \n-                let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+                let br = ty::BoundRegion { kind: ty::BrEnv };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n                 let pin_did = tcx.require_lang_item(LangItem::Pin, None);"}, {"sha": "e657088a5e4655ac7a2b8e3a5e86d621e766f01d", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -24,7 +24,7 @@ extern \"C\" {\n /// This means we can use pointer for both\n /// equality comparisons and hashing.\n ///\n-/// Unlike slices, The types contained in `List` are expected to be `Copy`\n+/// Unlike slices, the types contained in `List` are expected to be `Copy`\n /// and iterating over a `List` returns `T` instead of a reference.\n ///\n /// Note: `Slice` was already taken by the `Ty`."}, {"sha": "1fe1400fabecf820404535217cb8261d860ea234", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 58, "deletions": 112, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,3 +1,14 @@\n+//! Defines how the compiler represents types internally.\n+//!\n+//! Two important entities in this module are:\n+//!\n+//! - [`rustc_middle::ty::Ty`], used to represent the semantics of a type.\n+//! - [`rustc_middle::ty::TyCtxt`], the central data structure in the compiler.\n+//!\n+//! For more information, see [\"The `ty` module: representing types\"] in the ructc-dev-guide.\n+//!\n+//! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n+\n // ignore-tidy-filelength\n pub use self::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n pub use self::AssocItemContainer::*;\n@@ -51,13 +62,13 @@ use std::ops::{ControlFlow, Range};\n use std::ptr;\n use std::str;\n \n-pub use self::sty::BoundRegion::*;\n+pub use self::sty::BoundRegionKind::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n-pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n-pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n+pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar};\n+pub use self::sty::{BoundRegion, BoundRegionKind, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n@@ -67,6 +78,7 @@ pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n+pub use rustc_type_ir::{DebruijnIndex, TypeFlags, INNERMOST};\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -497,91 +509,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-bitflags! {\n-    /// Flags that we track on types. These flags are propagated upwards\n-    /// through the type during type construction, so that we can quickly check\n-    /// whether the type has various kinds of types in it without recursing\n-    /// over the type itself.\n-    pub struct TypeFlags: u32 {\n-        // Does this have parameters? Used to determine whether substitution is\n-        // required.\n-        /// Does this have [Param]?\n-        const HAS_TY_PARAM                = 1 << 0;\n-        /// Does this have [ReEarlyBound]?\n-        const HAS_RE_PARAM                = 1 << 1;\n-        /// Does this have [ConstKind::Param]?\n-        const HAS_CT_PARAM                = 1 << 2;\n-\n-        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_RE_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits;\n-\n-        /// Does this have [Infer]?\n-        const HAS_TY_INFER                = 1 << 3;\n-        /// Does this have [ReVar]?\n-        const HAS_RE_INFER                = 1 << 4;\n-        /// Does this have [ConstKind::Infer]?\n-        const HAS_CT_INFER                = 1 << 5;\n-\n-        /// Does this have inference variables? Used to determine whether\n-        /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_RE_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits;\n-\n-        /// Does this have [Placeholder]?\n-        const HAS_TY_PLACEHOLDER          = 1 << 6;\n-        /// Does this have [RePlaceholder]?\n-        const HAS_RE_PLACEHOLDER          = 1 << 7;\n-        /// Does this have [ConstKind::Placeholder]?\n-        const HAS_CT_PLACEHOLDER          = 1 << 8;\n-\n-        /// `true` if there are \"names\" of regions and so forth\n-        /// that are local to a particular fn/inferctxt\n-        const HAS_FREE_LOCAL_REGIONS      = 1 << 9;\n-\n-        /// `true` if there are \"names\" of types and regions and so forth\n-        /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES        = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits\n-                                          | TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits\n-                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n-\n-        /// Does this have [Projection]?\n-        const HAS_TY_PROJECTION           = 1 << 10;\n-        /// Does this have [Opaque]?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n-        /// Does this have [ConstKind::Unevaluated]?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n-\n-        /// Could this type be normalized further?\n-        const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n-                                          | TypeFlags::HAS_CT_PROJECTION.bits;\n-\n-        /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n-\n-        /// Does this have any region that \"appears free\" in the type?\n-        /// Basically anything but [ReLateBound] and [ReErased].\n-        const HAS_FREE_REGIONS            = 1 << 14;\n-\n-        /// Does this have any [ReLateBound] regions? Used to check\n-        /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n-\n-        /// Does this have any [ReErased] regions?\n-        const HAS_RE_ERASED               = 1 << 16;\n-\n-        /// Does this value have parameters/placeholders/inference variables which could be\n-        /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n-    }\n-}\n-\n #[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n@@ -672,15 +599,26 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n@@ -692,7 +630,7 @@ impl UpvarId {\n     }\n }\n \n-#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -746,7 +684,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -763,7 +701,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -790,7 +728,7 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n /// A `Place` and the corresponding `CaptureInfo`.\n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n     pub place: HirPlace<'tcx>,\n     pub info: CaptureInfo<'tcx>,\n@@ -799,7 +737,7 @@ pub struct CapturedPlace<'tcx> {\n /// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n@@ -1222,17 +1160,16 @@ pub enum PredicateAtom<'tcx> {\n     TypeWellFormedFromEnv(Ty<'tcx>),\n }\n \n-impl<'tcx> PredicateAtom<'tcx> {\n+impl<'tcx> Binder<PredicateAtom<'tcx>> {\n     /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n     pub fn potentially_quantified(\n         self,\n         tcx: TyCtxt<'tcx>,\n         qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n     ) -> Predicate<'tcx> {\n-        if self.has_escaping_bound_vars() {\n-            qualifier(Binder::bind(self))\n-        } else {\n-            PredicateKind::Atom(self)\n+        match self.no_bound_vars() {\n+            Some(atom) => PredicateKind::Atom(atom),\n+            None => qualifier(self),\n         }\n         .to_predicate(tcx)\n     }\n@@ -1325,7 +1262,11 @@ impl<'tcx> Predicate<'tcx> {\n         let substs = trait_ref.skip_binder().substs;\n         let pred = self.skip_binders();\n         let new = pred.subst(tcx, substs);\n-        if new != pred { new.potentially_quantified(tcx, PredicateKind::ForAll) } else { self }\n+        if new != pred {\n+            ty::Binder::bind(new).potentially_quantified(tcx, PredicateKind::ForAll)\n+        } else {\n+            self\n+        }\n     }\n }\n \n@@ -1352,6 +1293,10 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }\n+\n+    pub fn self_ty(self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound(|trait_ref| trait_ref.self_ty())\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n@@ -1476,37 +1421,39 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::Trait(self.value.skip_binder(), self.constness)\n+        self.value\n+            .map_bound(|value| PredicateAtom::Trait(value, self.constness))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::RegionOutlives(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::RegionOutlives(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::TypeOutlives(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::TypeOutlives(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::Projection(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::Projection(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<ConstnessAnd<PolyTraitRef<'tcx>>> {\n-        match self.skip_binders() {\n+        let predicate = self.bound_atom();\n+        match predicate.skip_binder() {\n             PredicateAtom::Trait(t, constness) => {\n-                Some(ConstnessAnd { constness, value: ty::Binder::bind(t.trait_ref) })\n+                Some(ConstnessAnd { constness, value: predicate.rebind(t.trait_ref) })\n             }\n             PredicateAtom::Projection(..)\n             | PredicateAtom::Subtype(..)\n@@ -1522,8 +1469,9 @@ impl<'tcx> Predicate<'tcx> {\n     }\n \n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match self.skip_binders() {\n-            PredicateAtom::TypeOutlives(data) => Some(ty::Binder::bind(data)),\n+        let predicate = self.bound_atom();\n+        match predicate.skip_binder() {\n+            PredicateAtom::TypeOutlives(data) => Some(predicate.rebind(data)),\n             PredicateAtom::Trait(..)\n             | PredicateAtom::Projection(..)\n             | PredicateAtom::Subtype(..)\n@@ -1670,7 +1618,7 @@ where\n     }\n }\n \n-pub type PlaceholderRegion = Placeholder<BoundRegion>;\n+pub type PlaceholderRegion = Placeholder<BoundRegionKind>;\n \n pub type PlaceholderType = Placeholder<BoundVar>;\n \n@@ -1690,8 +1638,6 @@ pub type PlaceholderConst<'tcx> = Placeholder<BoundConst<'tcx>>;\n /// which cause cycle errors.\n ///\n /// ```rust\n-/// #![feature(const_generics)]\n-///\n /// struct A;\n /// impl A {\n ///     fn foo<const N: usize>(&self) -> [u8; N] { [0; N] }"}, {"sha": "c79e06b7fdd323c3c16a384c5022b11af81c1919", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -63,7 +63,7 @@ pub trait Printer<'tcx>: Sized {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n     fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n@@ -343,7 +343,9 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n+    for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+{\n     type Output = P::DynExistential;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {"}, {"sha": "893572785f76b0dde108da22218cc9de28b4dfb5", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 112, "deletions": 69, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -125,13 +125,13 @@ pub struct RegionHighlightMode {\n     highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n \n     /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n+    /// the given `ty::BoundRegionKind`, print it as \"`'1`\". Free regions that would ordinarily\n     /// have names print as normal.\n     ///\n     /// This is used when you have a signature like `fn foo(x: &u32,\n     /// y: &'a u32)` and we want to give a name to the region of the\n     /// reference `x`.\n-    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+    highlight_bound_region: Option<(ty::BoundRegionKind, usize)>,\n }\n \n impl RegionHighlightMode {\n@@ -175,7 +175,7 @@ impl RegionHighlightMode {\n     /// Highlight the given bound region.\n     /// We can only highlight one bound region at a time. See\n     /// the field `highlight_bound_region` for more detailed notes.\n-    pub fn highlighting_bound_region(&mut self, br: ty::BoundRegion, number: usize) {\n+    pub fn highlighting_bound_region(&mut self, br: ty::BoundRegionKind, number: usize) {\n         assert!(self.highlight_bound_region.is_none());\n         self.highlight_bound_region = Some((br, number));\n     }\n@@ -209,6 +209,17 @@ pub trait PrettyPrinter<'tcx>:\n         value.as_ref().skip_binder().print(self)\n     }\n \n+    fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+        self,\n+        value: &ty::Binder<T>,\n+        f: F,\n+    ) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n+    {\n+        f(value.as_ref().skip_binder(), self)\n+    }\n+\n     /// Prints comma-separated elements.\n     fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n     where\n@@ -753,72 +764,77 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n-        define_scoped_cx!(self);\n-\n         // Generate the main trait ref, including associated types.\n         let mut first = true;\n \n         if let Some(principal) = predicates.principal() {\n-            p!(print_def_path(principal.def_id, &[]));\n-\n-            let mut resugared = false;\n-\n-            // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n-            if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n-                if let ty::Tuple(ref args) = principal.substs.type_at(0).kind() {\n-                    let mut projections = predicates.projection_bounds();\n-                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                        let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n-                        p!(pretty_fn_sig(&tys, false, proj.ty));\n-                        resugared = true;\n+            self = self.wrap_binder(&principal, |principal, mut cx| {\n+                define_scoped_cx!(cx);\n+                p!(print_def_path(principal.def_id, &[]));\n+\n+                let mut resugared = false;\n+\n+                // Special-case `Fn(...) -> ...` and resugar it.\n+                let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n+                if !cx.tcx().sess.verbose() && fn_trait_kind.is_some() {\n+                    if let ty::Tuple(ref args) = principal.substs.type_at(0).kind() {\n+                        let mut projections = predicates.projection_bounds();\n+                        if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                            let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n+                            p!(pretty_fn_sig(&tys, false, proj.skip_binder().ty));\n+                            resugared = true;\n+                        }\n                     }\n                 }\n-            }\n \n-            // HACK(eddyb) this duplicates `FmtPrinter`'s `path_generic_args`,\n-            // in order to place the projections inside the `<...>`.\n-            if !resugared {\n-                // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = self.tcx().mk_ty_infer(ty::FreshTy(0));\n-                let principal = principal.with_self_ty(self.tcx(), dummy_self);\n+                // HACK(eddyb) this duplicates `FmtPrinter`'s `path_generic_args`,\n+                // in order to place the projections inside the `<...>`.\n+                if !resugared {\n+                    // Use a type that can't appear in defaults of type parameters.\n+                    let dummy_cx = cx.tcx().mk_ty_infer(ty::FreshTy(0));\n+                    let principal = principal.with_self_ty(cx.tcx(), dummy_cx);\n+\n+                    let args = cx.generic_args_to_print(\n+                        cx.tcx().generics_of(principal.def_id),\n+                        principal.substs,\n+                    );\n+\n+                    // Don't print `'_` if there's no unerased regions.\n+                    let print_regions = args.iter().any(|arg| match arg.unpack() {\n+                        GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n+                        _ => false,\n+                    });\n+                    let mut args = args.iter().cloned().filter(|arg| match arg.unpack() {\n+                        GenericArgKind::Lifetime(_) => print_regions,\n+                        _ => true,\n+                    });\n+                    let mut projections = predicates.projection_bounds();\n \n-                let args = self.generic_args_to_print(\n-                    self.tcx().generics_of(principal.def_id),\n-                    principal.substs,\n-                );\n+                    let arg0 = args.next();\n+                    let projection0 = projections.next();\n+                    if arg0.is_some() || projection0.is_some() {\n+                        let args = arg0.into_iter().chain(args);\n+                        let projections = projection0.into_iter().chain(projections);\n \n-                // Don't print `'_` if there's no unerased regions.\n-                let print_regions = args.iter().any(|arg| match arg.unpack() {\n-                    GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n-                    _ => false,\n-                });\n-                let mut args = args.iter().cloned().filter(|arg| match arg.unpack() {\n-                    GenericArgKind::Lifetime(_) => print_regions,\n-                    _ => true,\n-                });\n-                let mut projections = predicates.projection_bounds();\n-\n-                let arg0 = args.next();\n-                let projection0 = projections.next();\n-                if arg0.is_some() || projection0.is_some() {\n-                    let args = arg0.into_iter().chain(args);\n-                    let projections = projection0.into_iter().chain(projections);\n-\n-                    p!(generic_delimiters(|mut cx| {\n-                        cx = cx.comma_sep(args)?;\n-                        if arg0.is_some() && projection0.is_some() {\n-                            write!(cx, \", \")?;\n-                        }\n-                        cx.comma_sep(projections)\n-                    }));\n+                        p!(generic_delimiters(|mut cx| {\n+                            cx = cx.comma_sep(args)?;\n+                            if arg0.is_some() && projection0.is_some() {\n+                                write!(cx, \", \")?;\n+                            }\n+                            cx.comma_sep(projections)\n+                        }));\n+                    }\n                 }\n-            }\n+                Ok(cx)\n+            })?;\n+\n             first = false;\n         }\n \n+        define_scoped_cx!(self);\n+\n         // Builtin bounds.\n         // FIXME(eddyb) avoid printing twice (needed to ensure\n         // that the auto traits are sorted *and* printed via cx).\n@@ -1391,7 +1407,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n@@ -1465,7 +1481,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n         let name = disambiguated_data.data.name();\n-        if name != DefPathDataName::Named(kw::Invalid) {\n+        if name != DefPathDataName::Named(kw::Empty) {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n@@ -1537,6 +1553,17 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.pretty_in_binder(value)\n     }\n \n+    fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n+        self,\n+        value: &ty::Binder<T>,\n+        f: C,\n+    ) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n+    {\n+        self.pretty_wrap_binder(value, f)\n+    }\n+\n     fn typed_value(\n         mut self,\n         f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n@@ -1581,14 +1608,14 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name != kw::Invalid && data.name != kw::UnderscoreLifetime\n+                data.name != kw::Empty && data.name != kw::UnderscoreLifetime\n             }\n \n-            ty::ReLateBound(_, br)\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != kw::Invalid && name != kw::UnderscoreLifetime {\n+                    if name != kw::Empty && name != kw::UnderscoreLifetime {\n                         return true;\n                     }\n                 }\n@@ -1658,16 +1685,16 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name != kw::Invalid {\n+                if data.name != kw::Empty {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n             }\n-            ty::ReLateBound(_, br)\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != kw::Invalid && name != kw::UnderscoreLifetime {\n+                    if name != kw::Empty && name != kw::UnderscoreLifetime {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }\n@@ -1752,10 +1779,10 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         let mut region_index = self.region_index;\n         let new_value = self.tcx.replace_late_bound_regions(value.clone(), |br| {\n             let _ = start_or_continue(&mut self, \"for<\", \", \");\n-            let br = match br {\n+            let kind = match br.kind {\n                 ty::BrNamed(_, name) => {\n                     let _ = write!(self, \"{}\", name);\n-                    br\n+                    br.kind\n                 }\n                 ty::BrAnon(_) | ty::BrEnv => {\n                     let name = loop {\n@@ -1769,7 +1796,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                     ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n                 }\n             };\n-            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind }))\n         });\n         start_or_continue(&mut self, \"\", \"> \")?;\n \n@@ -1790,14 +1817,30 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok(inner)\n     }\n \n+    pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+        self,\n+        value: &ty::Binder<T>,\n+        f: C,\n+    ) -> Result<Self, fmt::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n+    {\n+        let old_region_index = self.region_index;\n+        let (new, new_value) = self.name_all_regions(value)?;\n+        let mut inner = f(&new_value.0, new)?;\n+        inner.region_index = old_region_index;\n+        inner.binder_depth -= 1;\n+        Ok(inner)\n+    }\n+\n     fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let ty::ReLateBound(_, ty::BrNamed(_, name)) = *r {\n+                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) = *r {\n                     self.0.insert(name);\n                 }\n                 r.super_visit_with(self)\n@@ -1906,12 +1949,12 @@ impl ty::Binder<ty::TraitRef<'tcx>> {\n \n forward_display_to_print! {\n     Ty<'tcx>,\n-    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'tcx>` isn't possible yet.\n-    ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+    ty::Binder<ty::ExistentialPredicate<'tcx>>,\n     ty::Binder<ty::TraitRef<'tcx>>,\n     ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>>,\n     ty::Binder<ty::FnSig<'tcx>>,"}, {"sha": "8a1165bbd647a296bf8fc19ff2fdb387976e959c", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use crate::mir::{self, interpret};\n use crate::ty::codec::{OpaqueEncoder, RefDecodable, TyDecoder, TyEncoder};\n@@ -264,6 +264,13 @@ impl<'sess> OnDiskCache<'sess> {\n                 (file_to_file_index, file_index_to_stable_id)\n             };\n \n+            // Register any dep nodes that we reused from the previous session,\n+            // but didn't `DepNode::construct` in this session. This ensures\n+            // that their `DefPathHash` to `RawDefId` mappings are registered\n+            // in 'latest_foreign_def_path_hashes' if necessary, since that\n+            // normally happens in `DepNode::construct`.\n+            tcx.dep_graph.register_reused_dep_nodes(tcx);\n+\n             // Load everything into memory so we can write it out to the on-disk\n             // cache. The vast majority of cacheable query results should already\n             // be in memory, so this should be a cheap operation.\n@@ -454,6 +461,7 @@ impl<'sess> OnDiskCache<'sess> {\n     fn try_remap_cnum(&self, tcx: TyCtxt<'_>, cnum: u32) -> Option<CrateNum> {\n         let cnum_map =\n             self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n+        debug!(\"try_remap_cnum({}): cnum_map={:?}\", cnum, cnum_map);\n \n         cnum_map[CrateNum::from_u32(cnum)]\n     }\n@@ -466,9 +474,33 @@ impl<'sess> OnDiskCache<'sess> {\n             .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n     }\n \n-    pub fn register_reused_dep_path_hash(&self, hash: DefPathHash) {\n-        if let Some(old_id) = self.foreign_def_path_hashes.get(&hash) {\n-            self.latest_foreign_def_path_hashes.lock().insert(hash, *old_id);\n+    /// If the given `dep_node`'s hash still exists in the current compilation,\n+    /// and its current `DefId` is foreign, calls `store_foreign_def_id` with it.\n+    ///\n+    /// Normally, `store_foreign_def_id_hash` can be called directly by\n+    /// the dependency graph when we construct a `DepNode`. However,\n+    /// when we re-use a deserialized `DepNode` from the previous compilation\n+    /// session, we only have the `DefPathHash` available. This method is used\n+    /// to that any `DepNode` that we re-use has a `DefPathHash` -> `RawId` written\n+    /// out for usage in the next compilation session.\n+    pub fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n+        // For reused dep nodes, we only need to store the mapping if the node\n+        // is one whose query key we can reconstruct from the hash. We use the\n+        // mapping to aid that reconstruction in the next session. While we also\n+        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n+        // they're already registered during `DefId` encoding.\n+        if dep_node.kind.can_reconstruct_query_key() {\n+            let hash = DefPathHash(dep_node.hash.into());\n+\n+            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n+            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n+            // changed in the current compilation session (e.g. we've added/removed crates,\n+            // or added/removed definitions before/after the target definition).\n+            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n+                if !def_id.is_local() {\n+                    self.store_foreign_def_id_hash(def_id, hash);\n+                }\n+            }\n         }\n     }\n \n@@ -592,6 +624,7 @@ impl<'sess> OnDiskCache<'sess> {\n         match cache.entry(hash) {\n             Entry::Occupied(e) => *e.get(),\n             Entry::Vacant(e) => {\n+                debug!(\"def_path_hash_to_def_id({:?})\", hash);\n                 // Check if the `DefPathHash` corresponds to a definition in the current\n                 // crate\n                 if let Some(def_id) = self.local_def_path_hash_to_def_id.get(&hash).cloned() {\n@@ -605,9 +638,11 @@ impl<'sess> OnDiskCache<'sess> {\n                 // current compilation session, the crate is guaranteed to be the same\n                 // (otherwise, we would compute a different `DefPathHash`).\n                 let raw_def_id = self.get_raw_def_id(&hash)?;\n+                debug!(\"def_path_hash_to_def_id({:?}): raw_def_id = {:?}\", hash, raw_def_id);\n                 // If the owning crate no longer exists, the corresponding definition definitely\n                 // no longer exists.\n                 let krate = self.try_remap_cnum(tcx, raw_def_id.krate)?;\n+                debug!(\"def_path_hash_to_def_id({:?}): krate = {:?}\", hash, krate);\n                 // If our `DefPathHash` corresponded to a definition in the local crate,\n                 // we should have either found it in `local_def_path_hash_to_def_id`, or\n                 // never attempted to load it in the first place. Any query result or `DepNode`\n@@ -621,6 +656,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 // Try to find a definition in the current session, using the previous `DefIndex`\n                 // as an initial guess.\n                 let opt_def_id = tcx.cstore.def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n+                debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n                 e.insert(opt_def_id);\n                 opt_def_id\n             }\n@@ -630,7 +666,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n //- DECODING -------------------------------------------------------------------\n \n-/// A decoder that can read from the incr. comp. cache. It is similar to the one\n+/// A decoder that can read from the incremental compilation cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and eventually\n /// will also handle things that contain `Ty` instances.\n crate struct CacheDecoder<'a, 'tcx> {\n@@ -918,7 +954,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n \n //- ENCODING -------------------------------------------------------------------\n \n-/// An encoder that can write the incr. comp. cache.\n+/// An encoder that can write to the incremental compilation cache.\n struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n@@ -1026,9 +1062,6 @@ where\n {\n     const CLEAR_CROSS_CRATE: bool = false;\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n     fn position(&self) -> usize {\n         self.encoder.encoder_position()\n     }"}, {"sha": "293b3c6b0470a923a8214ab0ba2193568017fbe9", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -33,6 +33,15 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n+    /// Whether we should look into the substs of unevaluated constants\n+    /// even if `feature(const_evaluatable_checked)` is active.\n+    ///\n+    /// This is needed in `combine` to prevent accidentially creating\n+    /// infinite types as we abuse `TypeRelation` to walk a type there.\n+    fn visit_ct_substs(&self) -> bool {\n+        false\n+    }\n+\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -579,7 +588,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         (\n             ty::ConstKind::Unevaluated(a_def, a_substs, None),\n             ty::ConstKind::Unevaluated(b_def, b_substs, None),\n-        ) if tcx.features().const_evaluatable_checked => {\n+        ) if tcx.features().const_evaluatable_checked && !relation.visit_ct_substs() => {\n             if tcx.try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs))) {\n                 Ok(a.val)\n             } else {\n@@ -603,7 +612,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     new_const_val.map(|val| tcx.mk_const(ty::Const { val, ty: a.ty }))\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Self,\n@@ -616,24 +625,29 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         // in `a`.\n         let mut a_v: Vec<_> = a.into_iter().collect();\n         let mut b_v: Vec<_> = b.into_iter().collect();\n-        a_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n+        // `skip_binder` here is okay because `stable_cmp` doesn't look at binders\n+        a_v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));\n         a_v.dedup();\n-        b_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n+        b_v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));\n         b_v.dedup();\n         if a_v.len() != b_v.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n         let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n-            match (ep_a, ep_b) {\n-                (Trait(a), Trait(b)) => Ok(Trait(relation.relate(a, b)?)),\n-                (Projection(a), Projection(b)) => Ok(Projection(relation.relate(a, b)?)),\n-                (AutoTrait(a), AutoTrait(b)) if a == b => Ok(AutoTrait(a)),\n+            match (ep_a.skip_binder(), ep_b.skip_binder()) {\n+                (Trait(a), Trait(b)) => Ok(ty::Binder::bind(Trait(\n+                    relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n+                ))),\n+                (Projection(a), Projection(b)) => Ok(ty::Binder::bind(Projection(\n+                    relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n+                ))),\n+                (AutoTrait(a), AutoTrait(b)) if a == b => Ok(ep_a.rebind(AutoTrait(a))),\n                 _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b))),\n             }\n         });\n-        Ok(tcx.mk_existential_predicates(v)?)\n+        Ok(tcx.mk_poly_existential_predicates(v)?)\n     }\n }\n "}, {"sha": "7a1ca6a6c2bfc21a657a156cf4fb47253e9ece1d", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -65,7 +65,7 @@ impl fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     }\n }\n \n-impl fmt::Debug for ty::BoundRegion {\n+impl fmt::Debug for ty::BoundRegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n@@ -308,13 +308,13 @@ TrivialTypeFoldableAndLiftImpls! {\n     crate::traits::Reveal,\n     crate::ty::adjustment::AutoBorrowMutability,\n     crate::ty::AdtKind,\n-    // Including `BoundRegion` is a *bit* dubious, but direct\n+    // Including `BoundRegionKind` is a *bit* dubious, but direct\n     // references to bound region appear in `ty::Error`, and aren't\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n-    crate::ty::BoundRegion,\n+    crate::ty::BoundRegionKind,\n     crate::ty::AssocItem,\n-    crate::ty::Placeholder<crate::ty::BoundRegion>,\n+    crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,\n     crate::ty::InferTy,\n@@ -843,9 +843,9 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_existential_predicates(v))\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "744c7a541a53c58e2abcb802be2bc1012aea351f", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 123, "deletions": 183, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -40,12 +40,12 @@ pub struct TypeAndMut<'tcx> {\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n     pub scope: DefId,\n-    pub bound_region: BoundRegion,\n+    pub bound_region: BoundRegionKind,\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, TyEncodable, TyDecodable, Copy)]\n #[derive(HashStable)]\n-pub enum BoundRegion {\n+pub enum BoundRegionKind {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n \n@@ -60,26 +60,36 @@ pub enum BoundRegion {\n     BrEnv,\n }\n \n-impl BoundRegion {\n-    pub fn is_named(&self) -> bool {\n-        match *self {\n-            BoundRegion::BrNamed(_, name) => name != kw::UnderscoreLifetime,\n-            _ => false,\n-        }\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n+#[derive(HashStable)]\n+pub struct BoundRegion {\n+    pub kind: BoundRegionKind,\n+}\n \n+impl BoundRegion {\n     /// When canonicalizing, we replace unbound inference variables and free\n     /// regions with anonymous late bound regions. This method asserts that\n     /// we have an anonymous late bound region, which hence may refer to\n     /// a canonical variable.\n     pub fn assert_bound_var(&self) -> BoundVar {\n-        match *self {\n-            BoundRegion::BrAnon(var) => BoundVar::from_u32(var),\n+        match self.kind {\n+            BoundRegionKind::BrAnon(var) => BoundVar::from_u32(var),\n             _ => bug!(\"bound region is not anonymous\"),\n         }\n     }\n }\n \n+impl BoundRegionKind {\n+    pub fn is_named(&self) -> bool {\n+        match *self {\n+            BoundRegionKind::BrNamed(_, name) => name != kw::UnderscoreLifetime,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Defines the kinds of types.\n+///\n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `librustc_ast/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n@@ -102,7 +112,7 @@ pub enum TyKind<'tcx> {\n     /// A primitive floating-point type. For example, `f64`.\n     Float(ast::FloatTy),\n \n-    /// Structures, enumerations and unions.\n+    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n     ///\n     /// InternalSubsts here, possibly against intuition, *may* contain `Param`s.\n     /// That is, even after substitution it is possible that there are type\n@@ -152,7 +162,7 @@ pub enum TyKind<'tcx> {\n     FnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    Dynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    Dynamic(&'tcx List<Binder<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -162,11 +172,11 @@ pub enum TyKind<'tcx> {\n     /// `|a| yield a`.\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n \n-    /// A type representin the types stored inside a generator.\n+    /// A type representing the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n     GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n \n-    /// The never type `!`\n+    /// The never type `!`.\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n@@ -205,10 +215,7 @@ pub enum TyKind<'tcx> {\n impl TyKind<'tcx> {\n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        match self {\n-            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n-            _ => false,\n-        }\n+        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n     }\n \n     /// Get the article (\"a\" or \"an\") to use with this type.\n@@ -762,7 +769,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> List<ExistentialPredicate<'tcx>> {\n+impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n@@ -788,64 +795,42 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     /// is `{Send, Sync}`, while there is no principal. These trait objects\n     /// have a \"trivial\" vtable consisting of just the size, alignment,\n     /// and destructor.\n-    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n-        match self[0] {\n-            ExistentialPredicate::Trait(tr) => Some(tr),\n-            _ => None,\n-        }\n+    pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n+        self[0]\n+            .map_bound(|this| match this {\n+                ExistentialPredicate::Trait(tr) => Some(tr),\n+                _ => None,\n+            })\n+            .transpose()\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n-        self.principal().map(|trait_ref| trait_ref.def_id)\n+        self.principal().map(|trait_ref| trait_ref.skip_binder().def_id)\n     }\n \n     #[inline]\n     pub fn projection_bounds<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = ExistentialProjection<'tcx>> + 'a {\n-        self.iter().filter_map(|predicate| match predicate {\n-            ExistentialPredicate::Projection(projection) => Some(projection),\n-            _ => None,\n+    ) -> impl Iterator<Item = ty::Binder<ExistentialProjection<'tcx>>> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            predicate\n+                .map_bound(|pred| match pred {\n+                    ExistentialPredicate::Projection(projection) => Some(projection),\n+                    _ => None,\n+                })\n+                .transpose()\n         })\n     }\n \n     #[inline]\n     pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.iter().filter_map(|predicate| match predicate {\n+        self.iter().filter_map(|predicate| match predicate.skip_binder() {\n             ExistentialPredicate::AutoTrait(did) => Some(did),\n             _ => None,\n         })\n     }\n }\n \n-impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n-    pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n-        self.map_bound(|b| b.principal()).transpose()\n-    }\n-\n-    pub fn principal_def_id(&self) -> Option<DefId> {\n-        self.skip_binder().principal_def_id()\n-    }\n-\n-    #[inline]\n-    pub fn projection_bounds<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = PolyExistentialProjection<'tcx>> + 'a {\n-        self.skip_binder().projection_bounds().map(Binder::bind)\n-    }\n-\n-    #[inline]\n-    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.skip_binder().auto_traits()\n-    }\n-\n-    pub fn iter<'a>(\n-        &'a self,\n-    ) -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n-        self.skip_binder().iter().map(Binder::bind)\n-    }\n-}\n-\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where-clause:\n ///\n@@ -1289,53 +1274,6 @@ impl<'tcx> ParamConst {\n     }\n }\n \n-rustc_index::newtype_index! {\n-    /// A [De Bruijn index][dbi] is a standard means of representing\n-    /// regions (and perhaps later types) in a higher-ranked setting. In\n-    /// particular, imagine a type like this:\n-    ///\n-    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-    ///     ^          ^            |          |           |\n-    ///     |          |            |          |           |\n-    ///     |          +------------+ 0        |           |\n-    ///     |                                  |           |\n-    ///     +----------------------------------+ 1         |\n-    ///     |                                              |\n-    ///     +----------------------------------------------+ 0\n-    ///\n-    /// In this type, there are two binders (the outer fn and the inner\n-    /// fn). We need to be able to determine, for any given region, which\n-    /// fn type it is bound by, the inner or the outer one. There are\n-    /// various ways you can do this, but a De Bruijn index is one of the\n-    /// more convenient and has some nice properties. The basic idea is to\n-    /// count the number of binders, inside out. Some examples should help\n-    /// clarify what I mean.\n-    ///\n-    /// Let's start with the reference type `&'b isize` that is the first\n-    /// argument to the inner function. This region `'b` is assigned a De\n-    /// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n-    /// fn). The region `'a` that appears in the second argument type (`&'a\n-    /// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n-    /// second-innermost binder\". (These indices are written on the arrays\n-    /// in the diagram).\n-    ///\n-    /// What is interesting is that De Bruijn index attached to a particular\n-    /// variable will vary depending on where it appears. For example,\n-    /// the final type `&'a char` also refers to the region `'a` declared on\n-    /// the outermost fn. But this time, this reference is not nested within\n-    /// any other binders (i.e., it is not an argument to the inner fn, but\n-    /// rather the outer one). Therefore, in this case, it is assigned a\n-    /// De Bruijn index of 0, because the innermost binder in that location\n-    /// is the outer fn.\n-    ///\n-    /// [dbi]: https://en.wikipedia.org/wiki/De_Bruijn_index\n-    #[derive(HashStable)]\n-    pub struct DebruijnIndex {\n-        DEBUG_FORMAT = \"DebruijnIndex({})\",\n-        const INNERMOST = 0,\n-    }\n-}\n-\n pub type Region<'tcx> = &'tcx RegionKind;\n \n /// Representation of regions. Note that the NLL checker uses a distinct\n@@ -1450,7 +1388,7 @@ pub enum RegionKind {\n \n     /// Region bound in a function scope, which will be substituted when the\n     /// function is called.\n-    ReLateBound(DebruijnIndex, BoundRegion),\n+    ReLateBound(ty::DebruijnIndex, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n@@ -1486,28 +1424,33 @@ pub struct EarlyBoundRegion {\n     pub name: Symbol,\n }\n \n+/// A **ty**pe **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n+/// A **`const`** **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n+/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct IntVid {\n     pub index: u32,\n }\n \n+/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct FloatVid {\n     pub index: u32,\n }\n \n rustc_index::newtype_index! {\n+    /// A **region** (lifetime) **v**ariable **ID**.\n     pub struct RegionVid {\n         DEBUG_FORMAT = custom,\n     }\n@@ -1519,18 +1462,40 @@ impl Atom for RegionVid {\n     }\n }\n \n+/// A placeholder for a type that hasn't been inferred yet.\n+///\n+/// E.g., if we have an empty array (`[]`), then we create a fresh\n+/// type variable for the element type since we won't know until it's\n+/// used what the element type is supposed to be.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum InferTy {\n+    /// A type variable.\n     TyVar(TyVid),\n+    /// An integral type variable (`{integer}`).\n+    ///\n+    /// These are created when the compiler sees an integer literal like\n+    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n     IntVar(IntVid),\n+    /// A floating-point type variable (`{float}`).\n+    ///\n+    /// These are created when the compiler sees an float literal like\n+    /// `1.0` that could be either an `f32` or an `f64`.\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n     FloatVar(FloatVid),\n \n-    /// A `FreshTy` is one that is generated as a replacement for an\n-    /// unbound type variable. This is convenient for caching etc. See\n-    /// `infer::freshen` for more details.\n+    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n+    /// for an unbound type variable. This is convenient for caching etc. See\n+    /// `rustc_infer::infer::freshen` for more details.\n+    ///\n+    /// Compare with [`TyVar`][Self::TyVar].\n     FreshTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n     FreshIntTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n     FreshFloatTy(u32),\n }\n \n@@ -1614,72 +1579,13 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n     }\n }\n \n-impl DebruijnIndex {\n-    /// Returns the resulting index when this value is moved into\n-    /// `amount` number of new binders. So, e.g., if you had\n-    ///\n-    ///    for<'a> fn(&'a x)\n-    ///\n-    /// and you wanted to change it to\n-    ///\n-    ///    for<'a> fn(for<'b> fn(&'a x))\n-    ///\n-    /// you would need to shift the index for `'a` into a new binder.\n-    #[must_use]\n-    pub fn shifted_in(self, amount: u32) -> DebruijnIndex {\n-        DebruijnIndex::from_u32(self.as_u32() + amount)\n-    }\n-\n-    /// Update this index in place by shifting it \"in\" through\n-    /// `amount` number of binders.\n-    pub fn shift_in(&mut self, amount: u32) {\n-        *self = self.shifted_in(amount);\n-    }\n-\n-    /// Returns the resulting index when this value is moved out from\n-    /// `amount` number of new binders.\n-    #[must_use]\n-    pub fn shifted_out(self, amount: u32) -> DebruijnIndex {\n-        DebruijnIndex::from_u32(self.as_u32() - amount)\n-    }\n-\n-    /// Update in place by shifting out from `amount` binders.\n-    pub fn shift_out(&mut self, amount: u32) {\n-        *self = self.shifted_out(amount);\n-    }\n-\n-    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n-    /// innermost binder. That is, if we have something bound at `to_binder`,\n-    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n-    /// when moving a region out from inside binders:\n-    ///\n-    /// ```\n-    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n-    /// // Binder:  D3           D2        D1            ^^\n-    /// ```\n-    ///\n-    /// Here, the region `'a` would have the De Bruijn index D3,\n-    /// because it is the bound 3 binders out. However, if we wanted\n-    /// to refer to that region `'a` in the second argument (the `_`),\n-    /// those two binders would not be in scope. In that case, we\n-    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// De Bruijn index of `'a` to D1 (the innermost binder).\n-    ///\n-    /// If we invoke `shift_out_to_binder` and the region is in fact\n-    /// bound by one of the binders we are shifting out of, that is an\n-    /// error (and should fail an assertion failure).\n-    pub fn shifted_out_to_binder(self, to_binder: DebruijnIndex) -> Self {\n-        self.shifted_out(to_binder.as_u32() - INNERMOST.as_u32())\n-    }\n-}\n-\n /// Region utilities\n impl RegionKind {\n     /// Is this region named by the user?\n     pub fn has_name(&self) -> bool {\n         match *self {\n             RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n-            RegionKind::ReLateBound(_, br) => br.is_named(),\n+            RegionKind::ReLateBound(_, br) => br.kind.is_named(),\n             RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n@@ -1690,20 +1596,14 @@ impl RegionKind {\n     }\n \n     pub fn is_late_bound(&self) -> bool {\n-        match *self {\n-            ty::ReLateBound(..) => true,\n-            _ => false,\n-        }\n+        matches!(*self, ty::ReLateBound(..))\n     }\n \n     pub fn is_placeholder(&self) -> bool {\n-        match *self {\n-            ty::RePlaceholder(..) => true,\n-            _ => false,\n-        }\n+        matches!(*self, ty::RePlaceholder(..))\n     }\n \n-    pub fn bound_at_or_above_binder(&self, index: DebruijnIndex) -> bool {\n+    pub fn bound_at_or_above_binder(&self, index: ty::DebruijnIndex) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn >= index,\n             _ => false,\n@@ -2174,6 +2074,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Get the `i`-th element of a tuple.\n+    /// Panics when called on anything but a tuple.\n+    pub fn tuple_element_ty(&self, i: usize) -> Option<Ty<'tcx>> {\n+        match self.kind() {\n+            Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n+            _ => bug!(\"tuple_fields called on non-tuple\"),\n+        }\n+    }\n+\n     /// If the type contains variants, returns the valid range of variant indices.\n     //\n     // FIXME: This requires the optimized MIR in the case of generators.\n@@ -2213,13 +2122,44 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// Returns the type of the discriminant of this type.\n-    pub fn discriminant_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn discriminant_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n-            _ => {\n-                // This can only be `0`, for now, so `u8` will suffice.\n-                tcx.types.u8\n+\n+            ty::Param(_) | ty::Projection(_) | ty::Opaque(..) | ty::Infer(ty::TyVar(_)) => {\n+                let assoc_items =\n+                    tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n+                let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n+                tcx.mk_projection(discriminant_def_id, tcx.mk_substs([self.into()].iter()))\n+            }\n+\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(..)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Error(_)\n+            | ty::Infer(IntVar(_) | FloatVar(_)) => tcx.types.u8,\n+\n+            ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"`discriminant_ty` applied to unexpected type: {:?}\", self)\n             }\n         }\n     }"}, {"sha": "a64580336ad62f71e5436437d1e919a4bf5a1146", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -503,7 +503,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Option<ty::Binder<Ty<'tcx>>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n-        let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+        let br = ty::BoundRegion { kind: ty::BrEnv };\n+        let env_region = ty::ReLateBound(ty::INNERMOST, br);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {"}, {"sha": "e79adcdb545988885030842b59ce92fef2b31fe2", "filename": "compiler/rustc_middle/src/util/bug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -21,6 +21,7 @@ pub fn span_bug_fmt<S: Into<MultiSpan>>(span: S, args: fmt::Arguments<'_>) -> !\n     opt_span_bug_fmt(Some(span), args, Location::caller());\n }\n \n+#[track_caller]\n fn opt_span_bug_fmt<S: Into<MultiSpan>>(\n     span: Option<S>,\n     args: fmt::Arguments<'_>,"}, {"sha": "10dbf35fedcc9a14cb3a58cdc3a4896290843534", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -10,6 +10,7 @@ doctest = false\n [dependencies]\n either = \"1.5.0\"\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n+gsgdt = \"0.1.2\"\n itertools = \"0.9\"\n tracing = \"0.1\"\n polonius-engine = \"0.12.0\""}, {"sha": "4ebc1cdca60597ec83d4c2c54a3639fc5197c505", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -496,7 +496,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.kind() {\n             ty::Ref(\n-                ty::RegionKind::ReLateBound(_, br)\n+                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n@@ -517,7 +517,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let region = match ty.kind() {\n             ty::Ref(region, _, _) => {\n                 match region {\n-                    ty::RegionKind::ReLateBound(_, br)\n+                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n                     | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n                         printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n                     }\n@@ -954,7 +954,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         def_id: DefId,\n         target_place: PlaceRef<'tcx>,\n-        places: &Vec<Operand<'tcx>>,\n+        places: &[Operand<'tcx>],\n     ) -> Option<(Span, Option<GeneratorKind>, Span)> {\n         debug!(\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\","}, {"sha": "78da43c31c0fbc134c991ff97ad52f99abcf6998", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n     fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n-            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n+            if let ty::BoundRegionKind::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(_, substs) =\n                     self.regioncx.universal_regions().defining_ty\n                 {"}, {"sha": "cbca012824f82358d27b8f116cb9db0afb21b0ab", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -281,7 +281,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             }\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n-                ty::BoundRegion::BrNamed(region_def_id, name) => {\n+                ty::BoundRegionKind::BrNamed(region_def_id, name) => {\n                     // Get the span to point to, even if we don't use the name.\n                     let span = tcx.hir().span_if_local(region_def_id).unwrap_or(DUMMY_SP);\n                     debug!(\n@@ -307,7 +307,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     }\n                 }\n \n-                ty::BoundRegion::BrEnv => {\n+                ty::BoundRegionKind::BrEnv => {\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -349,7 +349,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     }\n                 }\n \n-                ty::BoundRegion::BrAnon(_) => None,\n+                ty::BoundRegionKind::BrAnon(_) => None,\n             },\n \n             ty::ReLateBound(..)"}, {"sha": "44044d55532deb8b6578e20170ee6c954beacc46", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -9,9 +9,10 @@ use rustc_hir::{HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n-    PlaceRef,\n+    PlaceRef, VarDebugInfoContents,\n };\n use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -75,6 +76,7 @@ crate use region_infer::RegionInferenceContext;\n crate struct Upvar {\n     name: Symbol,\n \n+    // FIXME(project-rfc-2229#8): This should use Place or something similar\n     var_hir_id: HirId,\n \n     /// If true, the capture is behind a reference.\n@@ -133,19 +135,21 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n-        if let Some(local) = var_debug_info.place.as_local() {\n-            if let Some(prev_name) = local_names[local] {\n-                if var_debug_info.name != prev_name {\n-                    span_bug!(\n-                        var_debug_info.source_info.span,\n-                        \"local {:?} has many names (`{}` vs `{}`)\",\n-                        local,\n-                        prev_name,\n-                        var_debug_info.name\n-                    );\n+        if let VarDebugInfoContents::Place(place) = var_debug_info.value {\n+            if let Some(local) = place.as_local() {\n+                if let Some(prev_name) = local_names[local] {\n+                    if var_debug_info.name != prev_name {\n+                        span_bug!(\n+                            var_debug_info.source_info.span,\n+                            \"local {:?} has many names (`{}` vs `{}`)\",\n+                            local,\n+                            prev_name,\n+                            var_debug_info.name\n+                        );\n+                    }\n                 }\n+                local_names[local] = Some(var_debug_info.name);\n             }\n-            local_names[local] = Some(var_debug_info.name);\n         }\n     }\n \n@@ -155,13 +159,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n-        .closure_captures\n-        .get(&def.did.to_def_id())\n-        .into_iter()\n-        .flat_map(|v| v.values())\n-        .map(|upvar_id| {\n-            let var_hir_id = upvar_id.var_path.hir_id;\n-            let capture = tables.upvar_capture(*upvar_id);\n+        .closure_min_captures_flattened(def.did.to_def_id())\n+        .map(|captured_place| {\n+            let var_hir_id = match captured_place.place.base {\n+                HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                _ => bug!(\"Expected upvar\"),\n+            };\n+            let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,"}, {"sha": "9d45f6fd0d348878f92e0bdb7c17181391ae6a50", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1145,8 +1145,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n             debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            // The upper bound of two non-static regions is static: this\n+            // means we know nothing about the relationship between these\n+            // two regions. Pick a 'better' one to use when constructing\n+            // a diagnostic\n             if ur != static_r && lub != static_r && new_lub == static_r {\n-                lub = std::cmp::min(ur, lub);\n+                // Prefer the region with an `external_name` - this\n+                // indicates that the region is early-bound, so working with\n+                // it can produce a nicer error.\n+                if self.region_definition(ur).external_name.is_some() {\n+                    lub = ur;\n+                } else if self.region_definition(lub).external_name.is_some() {\n+                    // Leave lub unchanged\n+                } else {\n+                    // If we get here, we don't have any reason to prefer\n+                    // one region over the other. Just pick the\n+                    // one with the lower index for now.\n+                    lub = std::cmp::min(ur, lub);\n+                }\n             } else {\n                 lub = new_lub;\n             }"}, {"sha": "7e8a33efe114ef6fb6a275c5a1b2a1fb70c170a2", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -58,11 +58,7 @@ impl vll::LinkElem for Appearance {\n }\n \n impl LocalUseMap {\n-    crate fn build(\n-        live_locals: &Vec<Local>,\n-        elements: &RegionValueElements,\n-        body: &Body<'_>,\n-    ) -> Self {\n+    crate fn build(live_locals: &[Local], elements: &RegionValueElements, body: &Body<'_>) -> Self {\n         let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),"}, {"sha": "42cd050abc5dd47e92701c13f96e41a45bb841f3", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -749,7 +749,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     (&adt_def.variants[VariantIdx::new(0)], substs)\n                 }\n                 ty::Closure(_, substs) => {\n-                    return match substs.as_closure().upvar_tys().nth(field.index()) {\n+                    return match substs\n+                        .as_closure()\n+                        .tupled_upvars_ty()\n+                        .tuple_element_ty(field.index())\n+                    {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.as_closure().upvar_tys().count(),\n@@ -1984,44 +1988,48 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // If the length is larger than 1, the repeat expression will need to copy the\n                 // element, so we require the `Copy` trait.\n                 if len.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n-                    if let Operand::Move(_) = operand {\n-                        // While this is located in `nll::typeck` this error is not an NLL error, it's\n-                        // a required check to make sure that repeated elements implement `Copy`.\n-                        let span = body.source_info(location).span;\n-                        let ty = operand.ty(body, tcx);\n-                        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                            let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n-                            // To determine if `const_in_array_repeat_expressions` feature gate should\n-                            // be mentioned, need to check if the rvalue is promotable.\n-                            let should_suggest =\n-                                should_suggest_const_in_array_repeat_expressions_attribute(\n-                                    &ccx, operand,\n-                                );\n-                            debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n-\n-                            let def_id = body.source.def_id().expect_local();\n-                            self.infcx.report_selection_error(\n-                                &traits::Obligation::new(\n-                                    ObligationCause::new(\n-                                        span,\n-                                        self.tcx().hir().local_def_id_to_hir_id(def_id),\n-                                        traits::ObligationCauseCode::RepeatVec(should_suggest),\n-                                    ),\n-                                    self.param_env,\n-                                    ty::Binder::bind(ty::TraitRef::new(\n-                                        self.tcx().require_lang_item(\n-                                            LangItem::Copy,\n-                                            Some(self.last_span),\n+                    match operand {\n+                        Operand::Copy(..) | Operand::Constant(..) => {\n+                            // These are always okay: direct use of a const, or a value that can evidently be copied.\n+                        }\n+                        Operand::Move(_) => {\n+                            // Make sure that repeated elements implement `Copy`.\n+                            let span = body.source_info(location).span;\n+                            let ty = operand.ty(body, tcx);\n+                            if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                                let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n+                                // To determine if `const_in_array_repeat_expressions` feature gate should\n+                                // be mentioned, need to check if the rvalue is promotable.\n+                                let should_suggest =\n+                                    should_suggest_const_in_array_repeat_expressions_attribute(\n+                                        &ccx, operand,\n+                                    );\n+                                debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n+\n+                                let def_id = body.source.def_id().expect_local();\n+                                self.infcx.report_selection_error(\n+                                    &traits::Obligation::new(\n+                                        ObligationCause::new(\n+                                            span,\n+                                            self.tcx().hir().local_def_id_to_hir_id(def_id),\n+                                            traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                         ),\n-                                        tcx.mk_substs_trait(ty, &[]),\n-                                    ))\n-                                    .without_const()\n-                                    .to_predicate(self.tcx()),\n-                                ),\n-                                &traits::SelectionError::Unimplemented,\n-                                false,\n-                                false,\n-                            );\n+                                        self.param_env,\n+                                        ty::Binder::bind(ty::TraitRef::new(\n+                                            self.tcx().require_lang_item(\n+                                                LangItem::Copy,\n+                                                Some(self.last_span),\n+                                            ),\n+                                            tcx.mk_substs_trait(ty, &[]),\n+                                        ))\n+                                        .without_const()\n+                                        .to_predicate(self.tcx()),\n+                                    ),\n+                                    &traits::SelectionError::Unimplemented,\n+                                    false,\n+                                    false,\n+                                );\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "c1a0d9856b7ea79e4ae7ebaa0e973a04768e03b6", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -700,7 +700,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope.to_def_id(),\n-                bound_region: br,\n+                bound_region: br.kind,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n@@ -795,7 +795,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,\n-                bound_region: ty::BoundRegion::BrNamed(region_def_id.to_def_id(), name),\n+                bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);\n         }"}, {"sha": "0e610e3755222744912037e98e0fe7658b1d5002", "filename": "compiler/rustc_mir/src/const_eval/error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -20,6 +20,7 @@ pub enum ConstEvalErrKind {\n     ModifiedGlobal,\n     AssertFailure(AssertKind<ConstInt>),\n     Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n+    Abort(String),\n }\n \n // The errors become `MachineStop` with plain strings when being raised.\n@@ -46,6 +47,7 @@ impl fmt::Display for ConstEvalErrKind {\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n             }\n+            Abort(ref msg) => write!(f, \"{}\", msg),\n         }\n     }\n }"}, {"sha": "df163f6562842d1be5387996021df23c8c2fed46", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -31,6 +31,19 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n     let tcx = *ecx.tcx;\n+    assert!(\n+        cid.promoted.is_some()\n+            || matches!(\n+                ecx.tcx.def_kind(cid.instance.def_id()),\n+                DefKind::Const\n+                    | DefKind::Static\n+                    | DefKind::ConstParam\n+                    | DefKind::AnonConst\n+                    | DefKind::AssocConst\n+            ),\n+        \"Unexpected DefKind: {:?}\",\n+        ecx.tcx.def_kind(cid.instance.def_id())\n+    );\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -40,15 +53,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n \n-    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n-    // make sense if the body is expecting nontrivial arguments.\n-    // (The alternative would be to use `eval_fn_call` with an args slice.)\n-    for arg in body.args_iter() {\n-        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n-        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n-        assert!(layout.is_zst())\n-    }\n-\n     ecx.push_stack_frame(\n         cid.instance,\n         body,\n@@ -379,25 +383,19 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         Ok(mplace) => {\n             // Since evaluation had no errors, valiate the resulting constant:\n             let validation = try {\n-                // FIXME do not validate promoteds until a decision on\n-                // https://github.com/rust-lang/rust/issues/67465 and\n-                // https://github.com/rust-lang/rust/issues/67534 is made.\n-                // Promoteds can contain unexpected `UnsafeCell` and reference `static`s, but their\n-                // otherwise restricted form ensures that this is still sound. We just lose the\n-                // extra safety net of some of the dynamic checks. They can also contain invalid\n-                // values, but since we do not usually check intermediate results of a computation\n-                // for validity, it might be surprising to do that here.\n-                if cid.promoted.is_none() {\n-                    let mut ref_tracking = RefTracking::new(mplace);\n-                    let mut inner = false;\n-                    while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                        let mode = match tcx.static_mutability(cid.instance.def_id()) {\n-                            Some(_) => CtfeValidationMode::Regular, // a `static`\n-                            None => CtfeValidationMode::Const { inner },\n-                        };\n-                        ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n-                        inner = true;\n-                    }\n+                let mut ref_tracking = RefTracking::new(mplace);\n+                let mut inner = false;\n+                while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+                    let mode = match tcx.static_mutability(cid.instance.def_id()) {\n+                        Some(_) if cid.promoted.is_some() => {\n+                            // Promoteds in statics are allowed to point to statics.\n+                            CtfeValidationMode::Const { inner, allow_static_ptrs: true }\n+                        }\n+                        Some(_) => CtfeValidationMode::Regular, // a `static`\n+                        None => CtfeValidationMode::Const { inner, allow_static_ptrs: false },\n+                    };\n+                    ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                    inner = true;\n                 }\n             };\n             if let Err(error) = validation {"}, {"sha": "72912dd76ff521e13d6cc17420e7f6a96e869ab9", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,6 +1,4 @@\n use rustc_middle::mir;\n-use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::InstanceDef;\n use rustc_middle::ty::{self, Ty};\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n@@ -17,60 +15,13 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n-    InterpResult, Memory, OpTy, PlaceTy, Pointer, Scalar,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, Memory,\n+    OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n \n impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n-    /// The evaluation is memoized thanks to the query system.\n-    ///\n-    /// Returns `true` if the call has been evaluated.\n-    fn try_eval_const_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, bool> {\n-        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n-        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-        // perform this optimization on items tagged with it.\n-        if instance.def.requires_caller_location(self.tcx()) {\n-            return Ok(false);\n-        }\n-        // Only memoize instrinsics. This was added in #79594 while adding the `const_allocate` intrinsic.\n-        // We only memoize intrinsics because it would be unsound to memoize functions\n-        // which might interact with the heap.\n-        // Additionally, const_allocate intrinsic is impure and thus should not be memoized;\n-        // it will not be memoized because it has non-ZST args\n-        if !matches!(instance.def, InstanceDef::Intrinsic(_)) {\n-            return Ok(false);\n-        }\n-        // For the moment we only do this for functions which take no arguments\n-        // (or all arguments are ZSTs) so that we don't memoize too much.\n-        if args.iter().any(|a| !a.layout.is_zst()) {\n-            return Ok(false);\n-        }\n-\n-        let dest = match ret {\n-            Some((dest, _)) => dest,\n-            // Don't memoize diverging function calls.\n-            None => return Ok(false),\n-        };\n-\n-        let gid = GlobalId { instance, promoted: None };\n-\n-        let place = self.eval_to_allocation(gid)?;\n-\n-        self.copy_op(place.into(), dest)?;\n-\n-        self.return_to_block(ret.map(|r| r.1))?;\n-        trace!(\"{:?}\", self.dump_place(*dest));\n-        Ok(true)\n-    }\n-\n     /// \"Intercept\" a function call to a panic-related function\n     /// because we have something special to do for it.\n     /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n@@ -253,7 +204,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -263,13 +214,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here.  But we can at least rule out functions that are not const\n             // at all.\n-            if ecx.tcx.is_const_fn_raw(def.did) {\n-                // If this function is a `const fn` then under certain circumstances we\n-                // can evaluate call via the query system, thus memoizing all future calls.\n-                if ecx.try_eval_const_fn_call(instance, ret, args)? {\n-                    return Ok(None);\n-                }\n-            } else {\n+            if !ecx.tcx.is_const_fn_raw(def.did) {\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!\n                 ecx.hook_panic_fn(instance, args)?;\n@@ -384,6 +329,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::AssertFailure(err).into())\n     }\n \n+    fn abort(_ecx: &mut InterpCx<'mir, 'tcx, Self>, msg: String) -> InterpResult<'tcx, !> {\n+        Err(ConstEvalErrKind::Abort(msg).into())\n+    }\n+\n     fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n     }"}, {"sha": "85aaff5ab7293ba0ab60e23110f5e68148c70aac", "filename": "compiler/rustc_mir/src/dataflow/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -11,7 +11,7 @@ use crate::dataflow::{AnalysisDomain, Backward, GenKill, GenKillAnalysis};\n /// exist. See [this `mir-dataflow` test][flow-test] for an example. You almost never want to use\n /// this analysis without also looking at the results of [`MaybeBorrowedLocals`].\n ///\n-/// [`MaybeBorrowedLocals`]: ../struct.MaybeBorrowedLocals.html\n+/// [`MaybeBorrowedLocals`]: super::MaybeBorrowedLocals\n /// [flow-test]: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n pub struct MaybeLiveLocals;"}, {"sha": "3d955576f0ff27775bbc9b5660d3617a70d65f22", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -840,36 +840,31 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Mark a storage as live, killing the previous content and returning it.\n-    /// Remember to deallocate that!\n-    pub fn storage_live(\n-        &mut self,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, LocalValue<M::PointerTag>> {\n+    /// Mark a storage as live, killing the previous content.\n+    pub fn storage_live(&mut self, local: mir::Local) -> InterpResult<'tcx> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n         let local_val = LocalValue::Uninitialized;\n-        // StorageLive *always* kills the value that's currently stored.\n-        // However, we do not error if the variable already is live;\n-        // see <https://github.com/rust-lang/rust/issues/42371>.\n-        Ok(mem::replace(&mut self.frame_mut().locals[local].value, local_val))\n+        // StorageLive expects the local to be dead, and marks it live.\n+        let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n+        if !matches!(old, LocalValue::Dead) {\n+            throw_ub_format!(\"StorageLive on a local that was already live\");\n+        }\n+        Ok(())\n     }\n \n-    /// Returns the old value of the local.\n-    /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> InterpResult<'tcx> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead)\n+        // It is entirely okay for this local to be already dead (at least that's how we currently generate MIR)\n+        let old = mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead);\n+        self.deallocate_local(old)?;\n+        Ok(())\n     }\n \n-    pub(super) fn deallocate_local(\n-        &mut self,\n-        local: LocalValue<M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        // FIXME: should we tell the user that there was a local which was never written to?\n+    fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> InterpResult<'tcx> {\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type."}, {"sha": "58858c09f44ef0079afd6c30465995a7e1a07631", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -61,12 +61,11 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::Slice { data: alloc, start: 0, end: alloc.len() }\n         }\n         sym::needs_drop => ConstValue::from_bool(tp_ty.needs_drop(tcx, param_env)),\n-        sym::size_of | sym::min_align_of | sym::pref_align_of => {\n+        sym::min_align_of | sym::pref_align_of => {\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n             let n = match name {\n                 sym::pref_align_of => layout.align.pref.bytes(),\n                 sym::min_align_of => layout.align.abi.bytes(),\n-                sym::size_of => layout.size.bytes(),\n                 _ => bug!(),\n             };\n             ConstValue::from_machine_usize(n, &tcx)\n@@ -125,8 +124,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (dest, ret) = match ret {\n             None => match intrinsic_name {\n                 sym::transmute => throw_ub_format!(\"transmuting to uninhabited type\"),\n-                sym::unreachable => throw_ub!(Unreachable),\n-                sym::abort => M::abort(self)?,\n+                sym::abort => M::abort(self, \"the program aborted execution\".to_owned())?,\n                 // Unsupported diverging intrinsic.\n                 _ => return Ok(false),\n             },\n@@ -143,9 +141,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             sym::min_align_of_val | sym::size_of_val => {\n-                let place = self.deref_operand(args[0])?;\n+                // Avoid `deref_operand` -- this is not a deref, the ptr does not have to be\n+                // dereferencable!\n+                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let (size, align) = self\n-                    .size_and_align_of(place.meta, place.layout)?\n+                    .size_and_align_of_mplace(place)?\n                     .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n \n                 let result = match intrinsic_name {\n@@ -160,13 +160,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::min_align_of\n             | sym::pref_align_of\n             | sym::needs_drop\n-            | sym::size_of\n             | sym::type_id\n             | sym::type_name\n             | sym::variant_count => {\n                 let gid = GlobalId { instance, promoted: None };\n                 let ty = match intrinsic_name {\n-                    sym::min_align_of | sym::pref_align_of | sym::size_of | sym::variant_count => {\n+                    sym::min_align_of | sym::pref_align_of | sym::variant_count => {\n                         self.tcx.types.usize\n                     }\n                     sym::needs_drop => self.tcx.types.bool,\n@@ -212,28 +211,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let out_val = numeric_intrinsic(intrinsic_name, bits, kind)?;\n                 self.write_scalar(out_val, dest)?;\n             }\n-            sym::wrapping_add\n-            | sym::wrapping_sub\n-            | sym::wrapping_mul\n-            | sym::add_with_overflow\n-            | sym::sub_with_overflow\n-            | sym::mul_with_overflow => {\n+            sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n-                let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    sym::wrapping_add => (BinOp::Add, true),\n-                    sym::wrapping_sub => (BinOp::Sub, true),\n-                    sym::wrapping_mul => (BinOp::Mul, true),\n-                    sym::add_with_overflow => (BinOp::Add, false),\n-                    sym::sub_with_overflow => (BinOp::Sub, false),\n-                    sym::mul_with_overflow => (BinOp::Mul, false),\n+                let bin_op = match intrinsic_name {\n+                    sym::add_with_overflow => BinOp::Add,\n+                    sym::sub_with_overflow => BinOp::Sub,\n+                    sym::mul_with_overflow => BinOp::Mul,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n-                if ignore_overflow {\n-                    self.binop_ignore_overflow(bin_op, lhs, rhs, dest)?;\n-                } else {\n-                    self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n-                }\n+                self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n             }\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(args[0])?;\n@@ -337,6 +324,29 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = Scalar::from_uint(truncated_bits, layout.size);\n                 self.write_scalar(result, dest)?;\n             }\n+            sym::copy | sym::copy_nonoverlapping => {\n+                let elem_ty = instance.substs.type_at(0);\n+                let elem_layout = self.layout_of(elem_ty)?;\n+                let count = self.read_scalar(args[2])?.to_machine_usize(self)?;\n+                let elem_align = elem_layout.align.abi;\n+\n+                let size = elem_layout.size.checked_mul(count, self).ok_or_else(|| {\n+                    err_ub_format!(\"overflow computing total size of `{}`\", intrinsic_name)\n+                })?;\n+                let src = self.read_scalar(args[0])?.check_init()?;\n+                let src = self.memory.check_ptr_access(src, size, elem_align)?;\n+                let dest = self.read_scalar(args[1])?.check_init()?;\n+                let dest = self.memory.check_ptr_access(dest, size, elem_align)?;\n+\n+                if let (Some(src), Some(dest)) = (src, dest) {\n+                    self.memory.copy(\n+                        src,\n+                        dest,\n+                        size,\n+                        intrinsic_name == sym::copy_nonoverlapping,\n+                    )?;\n+                }\n+            }\n             sym::offset => {\n                 let ptr = self.read_scalar(args[0])?.check_init()?;\n                 let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n@@ -407,6 +417,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::transmute => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n+            sym::assert_inhabited => {\n+                let ty = instance.substs.type_at(0);\n+                let layout = self.layout_of(ty)?;\n+\n+                if layout.abi.is_uninhabited() {\n+                    // The run-time intrinsic panics just to get a good backtrace; here we abort\n+                    // since there is no problem showing a backtrace even for aborts.\n+                    M::abort(\n+                        self,\n+                        format!(\n+                            \"aborted execution: attempted to instantiate uninhabited type `{}`\",\n+                            ty\n+                        ),\n+                    )?;\n+                }\n+            }\n             sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];"}, {"sha": "e1ec4cc5e973cc4c27c47424a9164446f5585fc2", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = true;\n         for p in predicates {"}, {"sha": "f50cc6c16ea16b7a6bac788ba547dd1664e787e5", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -9,6 +9,7 @@ use std::hash::Hash;\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::def_id::DefId;\n+use rustc_target::abi::Size;\n \n use super::{\n     AllocId, Allocation, AllocationExtra, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult,\n@@ -176,7 +177,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx>;\n \n     /// Called to evaluate `Abort` MIR terminator.\n-    fn abort(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, !> {\n+    fn abort(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _msg: String) -> InterpResult<'tcx, !> {\n         throw_unsup_format!(\"aborting execution is not supported\")\n     }\n \n@@ -299,6 +300,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n+    /// Called after initializing static memory using the interpreter.\n+    fn after_static_mem_initialized(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n+    ) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Executes a retagging operation\n     #[inline]\n     fn retag("}, {"sha": "95738db1f553c0bc0506cdd0a591d0857d0088bf", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -95,14 +95,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.storage_live(*local)?;\n-                self.deallocate_local(old_val)?;\n+                self.storage_live(*local)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.storage_dead(*local);\n-                self.deallocate_local(old_val)?;\n+                self.storage_dead(*local)?;\n             }\n \n             // No dynamic semantics attached to `FakeRead`; MIR"}, {"sha": "a2931325a28636cdc7287d2b0a07c641945f4d24", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -110,7 +110,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Abort => {\n-                M::abort(self)?;\n+                M::abort(self, \"the program aborted execution\".to_owned())?;\n             }\n \n             // When we encounter Resume, we've finished unwinding"}, {"sha": "09ce6bc0fb754b18c09183f8f651ff4084db1651", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -56,11 +56,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n-        let vtable = self.memory.allocate(\n-            ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap(),\n-            ptr_align,\n-            MemoryKind::Vtable,\n-        );\n+        let vtable_size = ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap();\n+        let vtable = self.memory.allocate(vtable_size, ptr_align, MemoryKind::Vtable);\n \n         let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n@@ -93,6 +90,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n+        M::after_static_mem_initialized(self, vtable, vtable_size)?;\n+\n         self.memory.mark_immutable(vtable.alloc_id)?;\n         assert!(self.vtables.insert((ty, poly_trait_ref), vtable).is_none());\n "}, {"sha": "423d1270ac8652709ecfe67f1474c65f7439a421", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -117,11 +117,12 @@ pub enum PathElem {\n pub enum CtfeValidationMode {\n     /// Regular validation, nothing special happening.\n     Regular,\n-    /// Validation of a `const`. `inner` says if this is an inner, indirect allocation (as opposed\n-    /// to the top-level const allocation).\n-    /// Being an inner allocation makes a difference because the top-level allocation of a `const`\n-    /// is copied for each use, but the inner allocations are implicitly shared.\n-    Const { inner: bool },\n+    /// Validation of a `const`.\n+    /// `inner` says if this is an inner, indirect allocation (as opposed to the top-level const\n+    /// allocation). Being an inner allocation makes a difference because the top-level allocation\n+    /// of a `const` is copied for each use, but the inner allocations are implicitly shared.\n+    /// `allow_static_ptrs` says if pointers to statics are permitted (which is the case for promoteds in statics).\n+    Const { inner: bool, allow_static_ptrs: bool },\n }\n \n /// State for tracking recursive validation of references\n@@ -152,7 +153,7 @@ impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH>\n }\n \n /// Format a path\n-fn write_path(out: &mut String, path: &Vec<PathElem>) {\n+fn write_path(out: &mut String, path: &[PathElem]) {\n     use self::PathElem::*;\n \n     for elem in path.iter() {\n@@ -390,7 +391,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // Make sure this is dereferenceable and all.\n         let size_and_align = try_validation!(\n-            self.ecx.size_and_align_of(place.meta, place.layout),\n+            self.ecx.size_and_align_of_mplace(place),\n             self.path,\n             err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n         );\n@@ -437,7 +438,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n-                    if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. })) {\n+                    if matches!(\n+                        self.ctfe_mode,\n+                        Some(CtfeValidationMode::Const { allow_static_ptrs: false, .. })\n+                    ) {\n                         // See const_eval::machine::MemoryExtra::can_access_statics for why\n                         // this check is so important.\n                         // This check is reachable when the const just referenced the static,\n@@ -742,9 +746,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n-        // Special check preventing `UnsafeCell` in constants\n+        // Special check preventing `UnsafeCell` in the inner part of constants\n         if let Some(def) = op.layout.ty.ty_adt_def() {\n-            if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true }))\n+            if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. }))\n                 && Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type()\n             {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });"}, {"sha": "e6d822086f52180b0c6d36a93c044c7cdedd3108", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -28,6 +28,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(or_patterns)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n+#![feature(str_split_once)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e2d50ba034ad3f65f80633fed0e848a40c90a72f", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -66,12 +66,14 @@ impl<'a, 'tcx> ConstMutationChecker<'a, 'tcx> {\n         location: Location,\n         decorate: impl for<'b> FnOnce(LintDiagnosticBuilder<'b>) -> DiagnosticBuilder<'b>,\n     ) {\n-        // Don't lint on borrowing/assigning to a dereference\n-        // e.g:\n+        // Don't lint on borrowing/assigning when a dereference is involved.\n+        // If we 'leave' the temporary via a dereference, we must\n+        // be modifying something else\n         //\n         // `unsafe { *FOO = 0; *BAR.field = 1; }`\n         // `unsafe { &mut *FOO }`\n-        if !matches!(place.projection.last(), Some(PlaceElem::Deref)) {\n+        // `unsafe { (*ARRAY)[0] = val; }\n+        if !place.projection.iter().any(|p| matches!(p, PlaceElem::Deref)) {\n             let source_info = self.body.source_info(location);\n             let lint_root = self.body.source_scopes[source_info.scope]\n                 .local_data"}, {"sha": "90688ebbd0acbf0d8d097b52bfc6850713317034", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -722,17 +722,16 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n-        match statement.kind {\n-            StatementKind::Assign(..) | StatementKind::SetDiscriminant { .. } => {\n-                self.super_statement(statement, location);\n-            }\n+        self.super_statement(statement, location);\n \n+        match statement.kind {\n             StatementKind::LlvmInlineAsm { .. } => {\n-                self.super_statement(statement, location);\n                 self.check_op(ops::InlineAsm);\n             }\n \n-            StatementKind::FakeRead(..)\n+            StatementKind::Assign(..)\n+            | StatementKind::SetDiscriminant { .. }\n+            | StatementKind::FakeRead(..)\n             | StatementKind::StorageLive(_)\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag { .. }"}, {"sha": "e64955c4986cee0f57fea664ac64d0990b9cd049", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 93, "deletions": 72, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -181,6 +181,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n+        // Check for borrows to packed fields.\n+        // `is_disaligned` already traverses the place to consider all projections after the last\n+        // `Deref`, so this only needs to be called once at the top level.\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 self.require_unsafe(\n@@ -190,87 +193,105 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n         }\n \n-        for (i, elem) in place.projection.iter().enumerate() {\n-            let proj_base = &place.projection[..i];\n-            if context.is_borrow() {\n-                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n+        // Some checks below need the extra metainfo of the local declaration.\n+        let decl = &self.body.local_decls[place.local];\n+\n+        // Check the base local: it might be an unsafe-to-access static. We only check derefs of the\n+        // temporary holding the static pointer to avoid duplicate errors\n+        // <https://github.com/rust-lang/rust/pull/78068#issuecomment-731753506>.\n+        if decl.internal && place.projection.first() == Some(&ProjectionElem::Deref) {\n+            // If the projection root is an artifical local that we introduced when\n+            // desugaring `static`, give a more specific error message\n+            // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n+            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+                if self.tcx.is_mutable_static(def_id) {\n                     self.require_unsafe(\n-                        UnsafetyViolationKind::BorrowPacked,\n-                        UnsafetyViolationDetails::BorrowOfPackedField,\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfMutableStatic,\n                     );\n+                    return;\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfExternStatic,\n+                    );\n+                    return;\n                 }\n             }\n-            let source_info = self.source_info;\n-            if let [] = proj_base {\n-                let decl = &self.body.local_decls[place.local];\n-                if decl.internal {\n-                    // If the projection root is an artifical local that we introduced when\n-                    // desugaring `static`, give a more specific error message\n-                    // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n-                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n-                        if self.tcx.is_mutable_static(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfMutableStatic,\n-                            );\n-                            return;\n-                        } else if self.tcx.is_foreign_item(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfExternStatic,\n-                            );\n-                            return;\n-                        }\n-                    } else {\n-                        // Internal locals are used in the `move_val_init` desugaring.\n-                        // We want to check unsafety against the source info of the\n-                        // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[place.local].source_info;\n-                    }\n+        }\n+\n+        // Check for raw pointer `Deref`.\n+        for (base, proj) in place.iter_projections() {\n+            if proj == ProjectionElem::Deref {\n+                let source_info = self.source_info; // Backup source_info so we can restore it later.\n+                if base.projection.is_empty() && decl.internal {\n+                    // Internal locals are used in the `move_val_init` desugaring.\n+                    // We want to check unsafety against the source info of the\n+                    // desugaring, rather than the source info of the RHS.\n+                    self.source_info = self.body.local_decls[place.local].source_info;\n+                }\n+                let base_ty = base.ty(self.body, self.tcx).ty;\n+                if base_ty.is_unsafe_ptr() {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::DerefOfRawPointer,\n+                    )\n                 }\n+                self.source_info = source_info; // Restore backed-up source_info.\n             }\n-            let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-            match base_ty.kind() {\n-                ty::RawPtr(..) => self.require_unsafe(\n-                    UnsafetyViolationKind::GeneralAndConstFn,\n-                    UnsafetyViolationDetails::DerefOfRawPointer,\n-                ),\n-                ty::Adt(adt, _) => {\n-                    if adt.is_union() {\n-                        if context == PlaceContext::MutatingUse(MutatingUseContext::Store)\n-                            || context == PlaceContext::MutatingUse(MutatingUseContext::Drop)\n-                            || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n-                        {\n-                            let elem_ty = match elem {\n-                                ProjectionElem::Field(_, ty) => ty,\n-                                _ => span_bug!(\n-                                    self.source_info.span,\n-                                    \"non-field projection {:?} from union?\",\n-                                    place\n-                                ),\n-                            };\n-                            if !elem_ty.is_copy_modulo_regions(\n-                                self.tcx.at(self.source_info.span),\n-                                self.param_env,\n-                            ) {\n-                                self.require_unsafe(\n-                                    UnsafetyViolationKind::GeneralAndConstFn,\n-                                    UnsafetyViolationDetails::AssignToNonCopyUnionField,\n-                                )\n-                            } else {\n-                                // write to non-move union, safe\n-                            }\n-                        } else {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::GeneralAndConstFn,\n-                                UnsafetyViolationDetails::AccessToUnionField,\n-                            )\n-                        }\n+        }\n+\n+        // Check for union fields. For this we traverse right-to-left, as the last `Deref` changes\n+        // whether we *read* the union field or potentially *write* to it (if this place is being assigned to).\n+        let mut saw_deref = false;\n+        for (base, proj) in place.iter_projections().rev() {\n+            if proj == ProjectionElem::Deref {\n+                saw_deref = true;\n+                continue;\n+            }\n+\n+            let base_ty = base.ty(self.body, self.tcx).ty;\n+            if base_ty.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+                // If we did not hit a `Deref` yet and the overall place use is an assignment, the\n+                // rules are different.\n+                let assign_to_field = !saw_deref\n+                    && matches!(\n+                        context,\n+                        PlaceContext::MutatingUse(\n+                            MutatingUseContext::Store\n+                                | MutatingUseContext::Drop\n+                                | MutatingUseContext::AsmOutput\n+                        )\n+                    );\n+                // If this is just an assignment, determine if the assigned type needs dropping.\n+                if assign_to_field {\n+                    // We have to check the actual type of the assignment, as that determines if the\n+                    // old value is being dropped.\n+                    let assigned_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+                    // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n+                    let manually_drop = assigned_ty\n+                        .ty_adt_def()\n+                        .map_or(false, |adt_def| adt_def.is_manually_drop());\n+                    let nodrop = manually_drop\n+                        || assigned_ty.is_copy_modulo_regions(\n+                            self.tcx.at(self.source_info.span),\n+                            self.param_env,\n+                        );\n+                    if !nodrop {\n+                        self.require_unsafe(\n+                            UnsafetyViolationKind::GeneralAndConstFn,\n+                            UnsafetyViolationDetails::AssignToDroppingUnionField,\n+                        );\n+                    } else {\n+                        // write to non-drop union field, safe\n                     }\n+                } else {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::AccessToUnionField,\n+                    )\n                 }\n-                _ => {}\n             }\n-            self.source_info = source_info;\n         }\n     }\n }"}, {"sha": "3cdaf4c7dcd47a5ef4458f9a501423457c93c019", "filename": "compiler/rustc_mir/src/transform/const_debuginfo.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_debuginfo.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,102 @@\n+//! Finds locals which are assigned once to a const and unused except for debuginfo and converts\n+//! their debuginfo to use the const directly, allowing the local to be removed.\n+\n+use rustc_middle::{\n+    mir::{\n+        visit::{PlaceContext, Visitor},\n+        Body, Constant, Local, Location, Operand, Rvalue, StatementKind, VarDebugInfoContents,\n+    },\n+    ty::TyCtxt,\n+};\n+\n+use crate::transform::MirPass;\n+use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+\n+pub struct ConstDebugInfo;\n+\n+impl<'tcx> MirPass<'tcx> for ConstDebugInfo {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if !tcx.sess.opts.debugging_opts.unsound_mir_opts {\n+            return;\n+        }\n+\n+        trace!(\"running ConstDebugInfo on {:?}\", body.source);\n+\n+        for (local, constant) in find_optimization_oportunities(body) {\n+            for debuginfo in &mut body.var_debug_info {\n+                if let VarDebugInfoContents::Place(p) = debuginfo.value {\n+                    if p.local == local && p.projection.is_empty() {\n+                        trace!(\n+                            \"changing debug info for {:?} from place {:?} to constant {:?}\",\n+                            debuginfo.name,\n+                            p,\n+                            constant\n+                        );\n+                        debuginfo.value = VarDebugInfoContents::Const(constant);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct LocalUseVisitor {\n+    local_mutating_uses: IndexVec<Local, u8>,\n+    local_assignment_locations: IndexVec<Local, Option<Location>>,\n+}\n+\n+fn find_optimization_oportunities<'tcx>(body: &Body<'tcx>) -> Vec<(Local, Constant<'tcx>)> {\n+    let mut visitor = LocalUseVisitor {\n+        local_mutating_uses: IndexVec::from_elem(0, &body.local_decls),\n+        local_assignment_locations: IndexVec::from_elem(None, &body.local_decls),\n+    };\n+\n+    visitor.visit_body(body);\n+\n+    let mut locals_to_debuginfo = BitSet::new_empty(body.local_decls.len());\n+    for debuginfo in &body.var_debug_info {\n+        if let VarDebugInfoContents::Place(p) = debuginfo.value {\n+            if let Some(l) = p.as_local() {\n+                locals_to_debuginfo.insert(l);\n+            }\n+        }\n+    }\n+\n+    let mut eligable_locals = Vec::new();\n+    for (local, mutating_uses) in visitor.local_mutating_uses.drain_enumerated(..) {\n+        if mutating_uses != 1 || !locals_to_debuginfo.contains(local) {\n+            continue;\n+        }\n+\n+        if let Some(location) = visitor.local_assignment_locations[local] {\n+            let bb = &body[location.block];\n+\n+            // The value is assigned as the result of a call, not a constant\n+            if bb.statements.len() == location.statement_index {\n+                continue;\n+            }\n+\n+            if let StatementKind::Assign(box (p, Rvalue::Use(Operand::Constant(box c)))) =\n+                &bb.statements[location.statement_index].kind\n+            {\n+                if let Some(local) = p.as_local() {\n+                    eligable_locals.push((local, *c));\n+                }\n+            }\n+        }\n+    }\n+\n+    eligable_locals\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LocalUseVisitor {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, location: Location) {\n+        if context.is_mutating_use() {\n+            self.local_mutating_uses[*local] = self.local_mutating_uses[*local].saturating_add(1);\n+\n+            if context.is_place_assignment() {\n+                self.local_assignment_locations[*local] = Some(location);\n+            }\n+        }\n+    }\n+}"}, {"sha": "b5921aac561437326c851914cdb1baa68f0dd0a6", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -140,7 +140,7 @@ impl<'a> BcbCounters<'a> {\n     /// message for subsequent debugging.\n     fn make_bcb_counters(\n         &mut self,\n-        coverage_spans: &Vec<CoverageSpan>,\n+        coverage_spans: &[CoverageSpan],\n     ) -> Result<Vec<CoverageKind>, Error> {\n         debug!(\"make_bcb_counters(): adding a counter or expression to each BasicCoverageBlock\");\n         let num_bcbs = self.basic_coverage_blocks.num_nodes();\n@@ -465,7 +465,7 @@ impl<'a> BcbCounters<'a> {\n     fn choose_preferred_expression_branch(\n         &self,\n         traversal: &TraverseCoverageGraphWithLoops,\n-        branches: &Vec<BcbBranch>,\n+        branches: &[BcbBranch],\n     ) -> BcbBranch {\n         let branch_needs_a_counter =\n             |branch: &BcbBranch| branch.counter(&self.basic_coverage_blocks).is_none();\n@@ -509,7 +509,7 @@ impl<'a> BcbCounters<'a> {\n     fn find_some_reloop_branch(\n         &self,\n         traversal: &TraverseCoverageGraphWithLoops,\n-        branches: &Vec<BcbBranch>,\n+        branches: &[BcbBranch],\n     ) -> Option<BcbBranch> {\n         let branch_needs_a_counter =\n             |branch: &BcbBranch| branch.counter(&self.basic_coverage_blocks).is_none();"}, {"sha": "b66e37436a663bfe0a8f161803a95968836f588d", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -148,40 +148,46 @@ impl DebugOptions {\n \n         if let Ok(env_debug_options) = std::env::var(RUSTC_COVERAGE_DEBUG_OPTIONS) {\n             for setting_str in env_debug_options.replace(\" \", \"\").replace(\"-\", \"_\").split(',') {\n-                let mut setting = setting_str.splitn(2, '=');\n-                match setting.next() {\n-                    Some(option) if option == \"allow_unused_expressions\" => {\n-                        allow_unused_expressions = bool_option_val(option, setting.next());\n+                let (option, value) = match setting_str.split_once('=') {\n+                    None => (setting_str, None),\n+                    Some((k, v)) => (k, Some(v)),\n+                };\n+                match option {\n+                    \"allow_unused_expressions\" => {\n+                        allow_unused_expressions = bool_option_val(option, value);\n                         debug!(\n                             \"{} env option `allow_unused_expressions` is set to {}\",\n                             RUSTC_COVERAGE_DEBUG_OPTIONS, allow_unused_expressions\n                         );\n                     }\n-                    Some(option) if option == \"counter_format\" => {\n-                        if let Some(strval) = setting.next() {\n-                            counter_format = counter_format_option_val(strval);\n-                            debug!(\n-                                \"{} env option `counter_format` is set to {:?}\",\n-                                RUSTC_COVERAGE_DEBUG_OPTIONS, counter_format\n-                            );\n-                        } else {\n-                            bug!(\n-                                \"`{}` option in environment variable {} requires one or more \\\n-                                plus-separated choices (a non-empty subset of \\\n-                                `id+block+operation`)\",\n-                                option,\n-                                RUSTC_COVERAGE_DEBUG_OPTIONS\n-                            );\n-                        }\n+                    \"counter_format\" => {\n+                        match value {\n+                            None => {\n+                                bug!(\n+                                    \"`{}` option in environment variable {} requires one or more \\\n+                                    plus-separated choices (a non-empty subset of \\\n+                                    `id+block+operation`)\",\n+                                    option,\n+                                    RUSTC_COVERAGE_DEBUG_OPTIONS\n+                                );\n+                            }\n+                            Some(val) => {\n+                                counter_format = counter_format_option_val(val);\n+                                debug!(\n+                                    \"{} env option `counter_format` is set to {:?}\",\n+                                    RUSTC_COVERAGE_DEBUG_OPTIONS, counter_format\n+                                );\n+                            }\n+                        };\n                     }\n-                    Some(\"\") => {}\n-                    Some(invalid) => bug!(\n-                        \"Unsupported setting `{}` in environment variable {}\",\n-                        invalid,\n-                        RUSTC_COVERAGE_DEBUG_OPTIONS\n-                    ),\n-                    None => {}\n-                }\n+                    _ => {\n+                        bug!(\n+                            \"Unsupported setting `{}` in environment variable {}\",\n+                            option,\n+                            RUSTC_COVERAGE_DEBUG_OPTIONS\n+                        )\n+                    }\n+                };\n             }\n         }\n \n@@ -279,7 +285,7 @@ impl DebugCounters {\n                 ),\n             };\n             counters\n-                .insert(id.into(), DebugCounter::new(counter_kind.clone(), some_block_label))\n+                .insert(id, DebugCounter::new(counter_kind.clone(), some_block_label))\n                 .expect_none(\n                     \"attempt to add the same counter_kind to DebugCounters more than once\",\n                 );\n@@ -334,7 +340,7 @@ impl DebugCounters {\n         if self.some_counters.is_some() && (counter_format.block || !counter_format.id) {\n             let counters = self.some_counters.as_ref().unwrap();\n             if let Some(DebugCounter { some_block_label: Some(block_label), .. }) =\n-                counters.get(&id.into())\n+                counters.get(&id)\n             {\n                 return if counter_format.id {\n                     format!(\"{}#{}\", block_label, id.index())"}, {"sha": "b1a1bb957e79d68b8eab687e3f0f428dd3d0eae2", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -32,24 +32,28 @@ impl CoverageGraph {\n \n         // Pre-transform MIR `BasicBlock` successors and predecessors into the BasicCoverageBlock\n         // equivalents. Note that since the BasicCoverageBlock graph has been fully simplified, the\n-        // each predecessor of a BCB leader_bb should be in a unique BCB, and each successor of a\n-        // BCB last_bb should be in its own unique BCB. Therefore, collecting the BCBs using\n-        // `bb_to_bcb` should work without requiring a deduplication step.\n+        // each predecessor of a BCB leader_bb should be in a unique BCB. It is possible for a\n+        // `SwitchInt` to have multiple targets to the same destination `BasicBlock`, so\n+        // de-duplication is required. This is done without reordering the successors.\n \n+        let bcbs_len = bcbs.len();\n+        let mut seen = IndexVec::from_elem_n(false, bcbs_len);\n         let successors = IndexVec::from_fn_n(\n             |bcb| {\n+                for b in seen.iter_mut() {\n+                    *b = false;\n+                }\n                 let bcb_data = &bcbs[bcb];\n-                let bcb_successors =\n+                let mut bcb_successors = Vec::new();\n+                for successor in\n                     bcb_filtered_successors(&mir_body, &bcb_data.terminator(mir_body).kind)\n                         .filter_map(|&successor_bb| bb_to_bcb[successor_bb])\n-                        .collect::<Vec<_>>();\n-                debug_assert!({\n-                    let mut sorted = bcb_successors.clone();\n-                    sorted.sort_unstable();\n-                    let initial_len = sorted.len();\n-                    sorted.dedup();\n-                    sorted.len() == initial_len\n-                });\n+                {\n+                    if !seen[successor] {\n+                        seen[successor] = true;\n+                        bcb_successors.push(successor);\n+                    }\n+                }\n                 bcb_successors\n             },\n             bcbs.len(),"}, {"sha": "93133e9b7f06364b52f3b549b7714fae78d858ea", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n+use rustc_span::source_map::SourceMap;\n use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n@@ -78,6 +79,14 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             return;\n         }\n \n+        match mir_body.basic_blocks()[mir::START_BLOCK].terminator().kind {\n+            TerminatorKind::Unreachable => {\n+                trace!(\"InstrumentCoverage skipped for unreachable `START_BLOCK`\");\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n         Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n@@ -302,8 +311,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             inject_statement(\n                 self.mir_body,\n                 counter_kind,\n-                self.bcb_last_bb(bcb),\n-                Some(make_code_region(file_name, &self.source_file, span, body_span)),\n+                self.bcb_leader_bb(bcb),\n+                Some(make_code_region(source_map, file_name, &self.source_file, span, body_span)),\n             );\n         }\n     }\n@@ -462,7 +471,7 @@ fn inject_statement(\n             code_region: some_code_region,\n         }),\n     };\n-    data.statements.push(statement);\n+    data.statements.insert(0, statement);\n }\n \n // Non-code expressions are injected into the coverage map, without generating executable code.\n@@ -481,6 +490,7 @@ fn inject_intermediate_expression(mir_body: &mut mir::Body<'tcx>, expression: Co\n \n /// Convert the Span into its file name, start line and column, and end line and column\n fn make_code_region(\n+    source_map: &SourceMap,\n     file_name: Symbol,\n     source_file: &Lrc<SourceFile>,\n     span: Span,\n@@ -500,6 +510,8 @@ fn make_code_region(\n     } else {\n         source_file.lookup_file_pos(span.hi())\n     };\n+    let start_line = source_map.doctest_offset_line(&source_file.name, start_line);\n+    let end_line = source_map.doctest_offset_line(&source_file.name, end_line);\n     CodeRegion {\n         file_name,\n         start_line: start_line as u32,"}, {"sha": "eda1ced001cadf8158ef67295530126be85ec264", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -7,6 +7,3 @@ edition = \"2018\"\n [lib]\n proc-macro = true\n doctest = false\n-\n-[dependencies]\n-proc-macro2 = \"1\""}, {"sha": "b16a99d7f0dcaee9b7b0634d040653d5c1b9346f", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -216,9 +216,10 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n         let discr = self.find_switch_discriminant_info(bb, switch)?;\n \n         // go through each target, finding a discriminant read, and a switch\n-        let results = discr.targets_with_values.iter().map(|(value, target)| {\n-            self.find_discriminant_switch_pairing(&discr, target.clone(), value.clone())\n-        });\n+        let results = discr\n+            .targets_with_values\n+            .iter()\n+            .map(|(value, target)| self.find_discriminant_switch_pairing(&discr, *target, *value));\n \n         // if the optimization did not apply for one of the targets, then abort\n         if results.clone().any(|x| x.is_none()) || results.len() == 0 {\n@@ -283,6 +284,33 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n                 return None;\n             }\n \n+            // when the second place is a projection of the first one, it's not safe to calculate their discriminant values sequentially.\n+            // for example, this should not be optimized:\n+            //\n+            // ```rust\n+            // enum E<'a> { Empty, Some(&'a E<'a>), }\n+            // let Some(Some(_)) = e;\n+            // ```\n+            //\n+            // ```mir\n+            // bb0: {\n+            //   _2 = discriminant(*_1)\n+            //   switchInt(_2) -> [...]\n+            // }\n+            // bb1: {\n+            //   _3 = discriminant(*(((*_1) as Some).0: &E))\n+            //   switchInt(_3) -> [...]\n+            // }\n+            // ```\n+            let discr_place = discr_info.place_of_adt_discr_read;\n+            let this_discr_place = this_bb_discr_info.place_of_adt_discr_read;\n+            if discr_place.local == this_discr_place.local\n+                && this_discr_place.projection.starts_with(discr_place.projection)\n+            {\n+                trace!(\"NO: one target is the projection of another\");\n+                return None;\n+            }\n+\n             // if we reach this point, the optimization applies, and we should be able to optimize this case\n             // store the info that is needed to apply the optimization\n "}, {"sha": "7c8c349da1d6c55544d01e2b49d9e888394267cf", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n         &self,\n         def_id: DefId,\n         substs_ref: SubstsRef<'tcx>,\n-        args: &Vec<Operand<'tcx>>,\n+        args: &[Operand<'tcx>],\n         source_info: SourceInfo,\n     ) {\n         let param_env = self.tcx.param_env(def_id);\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n             .unwrap_or(None)\n     }\n \n-    fn nth_arg_span(&self, args: &Vec<Operand<'tcx>>, n: usize) -> Span {\n+    fn nth_arg_span(&self, args: &[Operand<'tcx>], n: usize) -> Span {\n         match &args[n] {\n             Operand::Copy(place) | Operand::Move(place) => {\n                 self.body.local_decls[place.local].source_info.span"}, {"sha": "6e7575c1d71bb3b1a3766ff9729f5213087720b4", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -41,14 +41,6 @@ impl<'tcx> MirPass<'tcx> for Inline {\n             return;\n         }\n \n-        if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // The current implementation of source code coverage injects code region counters\n-            // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n-            // based function.\n-            debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n-            return;\n-        }\n-\n         if inline(tcx, body) {\n             debug!(\"running simplify cfg on {:?}\", body.source);\n             CfgSimplifier::new(body).simplify();"}, {"sha": "990ca313c5ddceaba6eb143d66cb27effee64e9d", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -29,8 +29,10 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n             optimization_finder.optimizations\n         };\n \n-        // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n+        if !optimizations.is_empty() {\n+            // Then carry out those optimizations.\n+            MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n+        }\n     }\n }\n \n@@ -95,7 +97,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             }\n         }\n \n-        self.super_rvalue(rvalue, location)\n+        // We do not call super_rvalue as we are not interested in any other parts of the tree\n     }\n }\n \n@@ -299,7 +301,7 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n \n         self.find_unneeded_equality_comparison(rvalue, location);\n \n-        self.super_rvalue(rvalue, location)\n+        // We do not call super_rvalue as we are not interested in any other parts of the tree\n     }\n }\n \n@@ -310,3 +312,21 @@ struct OptimizationList<'tcx> {\n     unneeded_equality_comparison: FxHashMap<Location, Operand<'tcx>>,\n     unneeded_deref: FxHashMap<Location, Place<'tcx>>,\n }\n+\n+impl<'tcx> OptimizationList<'tcx> {\n+    fn is_empty(&self) -> bool {\n+        match self {\n+            OptimizationList {\n+                and_stars,\n+                arrays_lengths,\n+                unneeded_equality_comparison,\n+                unneeded_deref,\n+            } => {\n+                and_stars.is_empty()\n+                    && arrays_lengths.is_empty()\n+                    && unneeded_equality_comparison.is_empty()\n+                    && unneeded_deref.is_empty()\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5968532eb39695d0700f24ab26863afcc416a52", "filename": "compiler/rustc_mir/src/transform/lower_intrinsics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flower_intrinsics.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -83,6 +83,21 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::discriminant_value => {\n+                        if let (Some((destination, target)), Some(arg)) =\n+                            (*destination, args[0].place())\n+                        {\n+                            let arg = tcx.mk_place_deref(arg);\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(box (\n+                                    destination,\n+                                    Rvalue::Discriminant(arg),\n+                                )),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n+                    }\n                     _ => {}\n                 }\n             }"}, {"sha": "7f3b421cf76f62c3cf02d930caa3bb2f58018771", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -21,6 +21,7 @@ pub mod check_consts;\n pub mod check_packed_ref;\n pub mod check_unsafety;\n pub mod cleanup_post_borrowck;\n+pub mod const_debuginfo;\n pub mod const_prop;\n pub mod coverage;\n pub mod deaggregator;\n@@ -363,6 +364,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // `AddRetag` needs to run after `ElaborateDrops`. Otherwise it should run fairly late,\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n+        &lower_intrinsics::LowerIntrinsics,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n         // `Deaggregator` is conceptually part of MIR building, some backends rely on it happening\n         // and it can help optimizations.\n@@ -391,7 +393,6 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     // The main optimizations that we do on MIR.\n     let optimizations: &[&dyn MirPass<'tcx>] = &[\n-        &lower_intrinsics::LowerIntrinsics,\n         &remove_unneeded_drops::RemoveUnneededDrops,\n         &match_branches::MatchBranchSimplification,\n         // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n@@ -408,6 +409,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &nrvo::RenameReturnPlace,\n+        &const_debuginfo::ConstDebugInfo,\n         &simplify::SimplifyLocals,\n         &multiple_return_terminators::MultipleReturnTerminators,\n     ];"}, {"sha": "ea92e23e9bffb6e03fe4a59ec07964720c39a425", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -90,7 +90,7 @@ pub enum TempState {\n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n         debug!(\"is_promotable: self={:?}\", self);\n-        matches!(self, TempState::Defined { .. } )\n+        matches!(self, TempState::Defined { .. })\n     }\n }\n \n@@ -309,50 +309,26 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        match kind {\n-                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n-\n-                            // FIXME(eddyb) these aren't promoted here but *could*\n-                            // be promoted as part of a larger value because\n-                            // `validate_rvalue`  doesn't check them, need to\n-                            // figure out what is the intended behavior.\n-                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n-                        }\n-\n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n                         self.validate_local(place.local)?;\n \n+                        // The reference operation itself must be promotable.\n+                        // (Needs to come after `validate_local` to avoid ICEs.)\n+                        self.validate_ref(*kind, place)?;\n+\n+                        // We do not check all the projections (they do not get promoted anyway),\n+                        // but we do stay away from promoting anything involving a dereference.\n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n \n-                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n-                        let has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                        if has_mut_interior {\n+                        // We cannot promote things that need dropping, since the promoted value\n+                        // would not get dropped.\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n-\n-                            // In theory, any zero-sized value could be borrowed\n-                            // mutably without consequences. However, only &mut []\n-                            // is allowed right now.\n-                            if let ty::Array(_, len) = ty.kind() {\n-                                match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) => {}\n-                                    _ => return Err(Unpromotable),\n-                                }\n-                            } else {\n-                                return Err(Unpromotable);\n-                            }\n-                        }\n-\n                         Ok(())\n                     }\n                     _ => bug!(),\n@@ -572,58 +548,115 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n-                    // ptr-to-int casts are not possible in consts and thus not promotable\n+    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+        match kind {\n+            // Reject these borrow types just to be safe.\n+            // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n+            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+\n+            BorrowKind::Shared => {\n+                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n+                if has_mut_interior {\n                     return Err(Unpromotable);\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n-                    assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n-                    );\n+            BorrowKind::Mut { .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n \n-                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                // In theory, any zero-sized value could be borrowed\n+                // mutably without consequences. However, only &mut []\n+                // is allowed right now.\n+                if let ty::Array(_, len) = ty.kind() {\n+                    match len.try_eval_usize(self.tcx, self.param_env) {\n+                        Some(0) => {}\n+                        _ => return Err(Unpromotable),\n+                    }\n+                } else {\n                     return Err(Unpromotable);\n                 }\n             }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n-\n-            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n-            _ => {}\n         }\n \n+        Ok(())\n+    }\n+\n+    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match rvalue {\n-            Rvalue::ThreadLocalRef(_) => Err(Unpromotable),\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, operand) => {\n+                self.validate_operand(operand)?;\n+            }\n \n-            Rvalue::NullaryOp(..) => Ok(()),\n+            Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n+                self.validate_place(place.as_ref())?\n+            }\n \n-            Rvalue::Discriminant(place) | Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+            Rvalue::ThreadLocalRef(_) => return Err(Unpromotable),\n \n-            Rvalue::Use(operand)\n-            | Rvalue::Repeat(operand, _)\n-            | Rvalue::UnaryOp(_, operand)\n-            | Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n+            Rvalue::Cast(kind, operand, cast_ty) => {\n+                if matches!(kind, CastKind::Misc) {\n+                    let operand_ty = operand.ty(self.body, self.tcx);\n+                    let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n+                        // ptr-to-int casts are not possible in consts and thus not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    // int-to-ptr casts are fine, they just use the integer value at pointer type.\n+                }\n+\n+                self.validate_operand(operand)?;\n+            }\n+\n+            Rvalue::BinaryOp(op, lhs, rhs) | Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let op = *op;\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n+                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                    assert!(matches!(\n+                        op,\n+                        BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                    ));\n+                    return Err(Unpromotable);\n+                }\n+\n+                match op {\n+                    // FIXME: reject operations that can fail -- namely, division and modulo.\n+                    BinOp::Eq\n+                    | BinOp::Ne\n+                    | BinOp::Le\n+                    | BinOp::Lt\n+                    | BinOp::Ge\n+                    | BinOp::Gt\n+                    | BinOp::Offset\n+                    | BinOp::Add\n+                    | BinOp::Sub\n+                    | BinOp::Mul\n+                    | BinOp::Div\n+                    | BinOp::Rem\n+                    | BinOp::BitXor\n+                    | BinOp::BitAnd\n+                    | BinOp::BitOr\n+                    | BinOp::Shl\n+                    | BinOp::Shr => {}\n+                }\n \n-            Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n                 self.validate_operand(lhs)?;\n-                self.validate_operand(rhs)\n+                self.validate_operand(rhs)?;\n             }\n \n+            Rvalue::NullaryOp(op, _) => match op {\n+                NullOp::Box => return Err(Unpromotable),\n+                NullOp::SizeOf => {}\n+            },\n+\n             Rvalue::AddressOf(_, place) => {\n                 // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n                 // no problem, only using it is.\n@@ -636,53 +669,36 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         });\n                     }\n                 }\n-                Err(Unpromotable)\n+                return Err(Unpromotable);\n             }\n \n             Rvalue::Ref(_, kind, place) => {\n-                if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now.\n-                    if let ty::Array(_, len) = ty.kind() {\n-                        match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) => {}\n-                            _ => return Err(Unpromotable),\n-                        }\n-                    } else {\n-                        return Err(Unpromotable);\n-                    }\n-                }\n-\n                 // Special-case reborrows to be more like a copy of the reference.\n-                let mut place = place.as_ref();\n-                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                let mut place_simplified = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n+                    let base_ty =\n+                        Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place = PlaceRef { local: place.local, projection: proj_base };\n+                        place_simplified =\n+                            PlaceRef { local: place_simplified.local, projection: proj_base };\n                     }\n                 }\n \n-                self.validate_place(place)?;\n-\n-                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                if has_mut_interior {\n-                    return Err(Unpromotable);\n-                }\n+                self.validate_place(place_simplified)?;\n \n-                Ok(())\n+                // Check that the reference is fine (using the original place!).\n+                // (Needs to come after `validate_place` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n             }\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for o in operands {\n                     self.validate_operand(o)?;\n                 }\n-\n-                Ok(())\n             }\n         }\n+\n+        Ok(())\n     }\n \n     fn validate_call("}, {"sha": "7598be4e4a11d8e9c51c2085f479058efe8c0da8", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -92,7 +92,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n /// \"rustc_peek: bit not set\".\n ///\n /// The intention is that one can write unit tests for dataflow by\n-/// putting code into a compile-fail test and using `rustc_peek` to\n+/// putting code into an UI test and using `rustc_peek` to\n /// make observations about the results of dataflow static analyses.\n ///\n /// (If there are any calls to `rustc_peek` that do not match the"}, {"sha": "a3459887a9a7596700bb6b92c44a869204ba7668", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -246,14 +246,19 @@ fn get_arm_identity_info<'a, 'tcx>(\n         tmp_assigned_vars.insert(*r);\n     }\n \n-    let dbg_info_to_adjust: Vec<_> =\n-        debug_info\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(i, var_info)| {\n-                if tmp_assigned_vars.contains(var_info.place.local) { Some(i) } else { None }\n-            })\n-            .collect();\n+    let dbg_info_to_adjust: Vec<_> = debug_info\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(i, var_info)| {\n+            if let VarDebugInfoContents::Place(p) = var_info.value {\n+                if tmp_assigned_vars.contains(p.local) {\n+                    return Some(i);\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect();\n \n     Some(ArmIdentityInfo {\n         local_temp_0: local_tmp_s0,\n@@ -301,7 +306,7 @@ fn optimization_applies<'tcx>(\n         return false;\n     }\n \n-    // Verify the assigment chain consists of the form b = a; c = b; d = c; etc...\n+    // Verify the assignment chain consists of the form b = a; c = b; d = c; etc...\n     if opt_info.field_tmp_assignments.is_empty() {\n         trace!(\"NO: no assignments found\");\n         return false;\n@@ -340,9 +345,11 @@ fn optimization_applies<'tcx>(\n     // Check that debug info only points to full Locals and not projections.\n     for dbg_idx in &opt_info.dbg_info_to_adjust {\n         let dbg_info = &var_debug_info[*dbg_idx];\n-        if !dbg_info.place.projection.is_empty() {\n-            trace!(\"NO: debug info for {:?} had a projection {:?}\", dbg_info.name, dbg_info.place);\n-            return false;\n+        if let VarDebugInfoContents::Place(p) = dbg_info.value {\n+            if !p.projection.is_empty() {\n+                trace!(\"NO: debug info for {:?} had a projection {:?}\", dbg_info.name, p);\n+                return false;\n+            }\n         }\n     }\n \n@@ -423,9 +430,15 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n                 // Fix the debug info to point to the right local\n                 for dbg_index in opt_info.dbg_info_to_adjust {\n                     let dbg_info = &mut debug_info[dbg_index];\n-                    assert!(dbg_info.place.projection.is_empty());\n-                    dbg_info.place.local = opt_info.local_0;\n-                    dbg_info.place.projection = opt_info.dbg_projection;\n+                    assert!(\n+                        matches!(dbg_info.value, VarDebugInfoContents::Place(_)),\n+                        \"value was not a Place\"\n+                    );\n+                    if let VarDebugInfoContents::Place(p) = &mut dbg_info.value {\n+                        assert!(p.projection.is_empty());\n+                        p.local = opt_info.local_0;\n+                        p.projection = opt_info.dbg_projection;\n+                    }\n                 }\n \n                 trace!(\"block is now {:?}\", bb.statements);"}, {"sha": "56d8045813c425c2d7cb67a8cbdf8eec88d6b549", "filename": "compiler/rustc_mir/src/util/borrowck_errors.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -68,9 +68,10 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(\n                 new_loan_span,\n                 format!(\n-                    \"mutable borrow starts here in previous \\\n-                     iteration of loop{}\",\n-                    opt_via\n+                    \"{}{} was mutably borrowed here in the previous iteration of the loop{}\",\n+                    desc,\n+                    via(opt_via),\n+                    opt_via,\n                 ),\n             );\n             if let Some(old_load_end_span) = old_load_end_span {"}, {"sha": "6ce305a482114b00d6fdabffef319c06bda74e5a", "filename": "compiler/rustc_mir/src/util/generic_graph.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -0,0 +1,70 @@\n+use gsgdt::{Edge, Graph, Node, NodeStyle};\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::Idx;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+\n+/// Convert an MIR function into a gsgdt Graph\n+pub fn mir_fn_to_generic_graph<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Graph {\n+    let def_id = body.source.def_id();\n+    let def_name = graphviz_safe_def_name(def_id);\n+    let graph_name = format!(\"Mir_{}\", def_name);\n+    let dark_mode = tcx.sess.opts.debugging_opts.graphviz_dark_mode;\n+\n+    // Nodes\n+    let nodes: Vec<Node> = body\n+        .basic_blocks()\n+        .iter_enumerated()\n+        .map(|(block, _)| bb_to_graph_node(block, body, dark_mode))\n+        .collect();\n+\n+    // Edges\n+    let mut edges = Vec::new();\n+    for (source, _) in body.basic_blocks().iter_enumerated() {\n+        let def_id = body.source.def_id();\n+        let terminator = body[source].terminator();\n+        let labels = terminator.kind.fmt_successor_labels();\n+\n+        for (&target, label) in terminator.successors().zip(labels) {\n+            let src = node(def_id, source);\n+            let trg = node(def_id, target);\n+            edges.push(Edge::new(src, trg, label.to_string()));\n+        }\n+    }\n+\n+    Graph::new(graph_name, nodes, edges)\n+}\n+\n+fn bb_to_graph_node(block: BasicBlock, body: &Body<'_>, dark_mode: bool) -> Node {\n+    let def_id = body.source.def_id();\n+    let data = &body[block];\n+    let label = node(def_id, block);\n+\n+    let (title, bgcolor) = if data.is_cleanup {\n+        let color = if dark_mode { \"royalblue\" } else { \"lightblue\" };\n+        (format!(\"{} (cleanup)\", block.index()), color)\n+    } else {\n+        let color = if dark_mode { \"dimgray\" } else { \"gray\" };\n+        (format!(\"{}\", block.index()), color)\n+    };\n+\n+    let style = NodeStyle { title_bg: Some(bgcolor.to_owned()), ..Default::default() };\n+    let mut stmts: Vec<String> = data.statements.iter().map(|x| format!(\"{:?}\", x)).collect();\n+\n+    // add the terminator to the stmts, gsgdt can print it out seperately\n+    let mut terminator_head = String::new();\n+    data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n+    stmts.push(terminator_head);\n+\n+    Node::new(stmts, label, title, style)\n+}\n+\n+// Must match `[0-9A-Za-z_]*`. This does not appear in the rendered graph, so\n+// it does not have to be user friendly.\n+pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n+    format!(\"{}_{}\", def_id.krate.index(), def_id.index.index(),)\n+}\n+\n+fn node(def_id: DefId, block: BasicBlock) -> String {\n+    format!(\"bb{}__{}\", block.index(), graphviz_safe_def_name(def_id))\n+}"}, {"sha": "37498e50c0eb106a710d38f6306c8c20eb64a767", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 17, "deletions": 132, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,11 +1,12 @@\n+use gsgdt::GraphvizSettings;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use std::fmt::Debug;\n use std::io::{self, Write};\n \n+use super::generic_graph::mir_fn_to_generic_graph;\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n@@ -32,12 +33,6 @@ where\n     Ok(())\n }\n \n-// Must match `[0-9A-Za-z_]*`. This does not appear in the rendered graph, so\n-// it does not have to be user friendly.\n-pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n-    format!(\"{}_{}\", def_id.krate.index(), def_id.index.index(),)\n-}\n-\n /// Write a graphviz DOT graph of the MIR.\n pub fn write_mir_fn_graphviz<'tcx, W>(\n     tcx: TyCtxt<'tcx>,\n@@ -48,12 +43,6 @@ pub fn write_mir_fn_graphviz<'tcx, W>(\n where\n     W: Write,\n {\n-    let def_id = body.source.def_id();\n-    let kind = if subgraph { \"subgraph\" } else { \"digraph\" };\n-    let cluster = if subgraph { \"cluster_\" } else { \"\" }; // Prints a border around MIR\n-    let def_name = graphviz_safe_def_name(def_id);\n-    writeln!(w, \"{} {}Mir_{} {{\", kind, cluster, def_name)?;\n-\n     // Global graph properties\n     let font = format!(r#\"fontname=\"{}\"\"#, tcx.sess.opts.debugging_opts.graphviz_font);\n     let mut graph_attrs = vec![&font[..]];\n@@ -67,131 +56,31 @@ where\n         content_attrs.push(r#\"fontcolor=\"white\"\"#);\n     }\n \n-    writeln!(w, r#\"    graph [{}];\"#, graph_attrs.join(\" \"))?;\n-    let content_attrs_str = content_attrs.join(\" \");\n-    writeln!(w, r#\"    node [{}];\"#, content_attrs_str)?;\n-    writeln!(w, r#\"    edge [{}];\"#, content_attrs_str)?;\n-\n     // Graph label\n-    write_graph_label(tcx, body, w)?;\n-\n-    // Nodes\n-    for (block, _) in body.basic_blocks().iter_enumerated() {\n-        write_node(block, body, dark_mode, w)?;\n-    }\n-\n-    // Edges\n-    for (source, _) in body.basic_blocks().iter_enumerated() {\n-        write_edges(source, body, w)?;\n-    }\n-    writeln!(w, \"}}\")\n-}\n-\n-/// Write a graphviz HTML-styled label for the given basic block, with\n-/// all necessary escaping already performed. (This is suitable for\n-/// emitting directly, as is done in this module, or for use with the\n-/// LabelText::HtmlStr from librustc_graphviz.)\n-///\n-/// `init` and `fini` are callbacks for emitting additional rows of\n-/// data (using HTML enclosed with `<tr>` in the emitted text).\n-pub fn write_node_label<W: Write, INIT, FINI>(\n-    block: BasicBlock,\n-    body: &Body<'_>,\n-    dark_mode: bool,\n-    w: &mut W,\n-    num_cols: u32,\n-    init: INIT,\n-    fini: FINI,\n-) -> io::Result<()>\n-where\n-    INIT: Fn(&mut W) -> io::Result<()>,\n-    FINI: Fn(&mut W) -> io::Result<()>,\n-{\n-    let data = &body[block];\n-\n-    write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n-\n-    // Basic block number at the top.\n-    let (blk, bgcolor) = if data.is_cleanup {\n-        let color = if dark_mode { \"royalblue\" } else { \"lightblue\" };\n-        (format!(\"{} (cleanup)\", block.index()), color)\n-    } else {\n-        let color = if dark_mode { \"dimgray\" } else { \"gray\" };\n-        (format!(\"{}\", block.index()), color)\n+    let mut label = String::from(\"\");\n+    // FIXME: remove this unwrap\n+    write_graph_label(tcx, body, &mut label).unwrap();\n+    let g = mir_fn_to_generic_graph(tcx, body);\n+    let settings = GraphvizSettings {\n+        graph_attrs: Some(graph_attrs.join(\" \")),\n+        node_attrs: Some(content_attrs.join(\" \")),\n+        edge_attrs: Some(content_attrs.join(\" \")),\n+        graph_label: Some(label),\n     };\n-    write!(\n-        w,\n-        r#\"<tr><td bgcolor=\"{bgcolor}\" {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n-        attrs = r#\"align=\"center\"\"#,\n-        colspan = num_cols,\n-        blk = blk,\n-        bgcolor = bgcolor\n-    )?;\n-\n-    init(w)?;\n-\n-    // List of statements in the middle.\n-    if !data.statements.is_empty() {\n-        write!(w, r#\"<tr><td align=\"left\" balign=\"left\">\"#)?;\n-        for statement in &data.statements {\n-            write!(w, \"{}<br/>\", escape(statement))?;\n-        }\n-        write!(w, \"</td></tr>\")?;\n-    }\n-\n-    // Terminator head at the bottom, not including the list of successor blocks. Those will be\n-    // displayed as labels on the edges between blocks.\n-    let mut terminator_head = String::new();\n-    data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n-    write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head))?;\n-\n-    fini(w)?;\n-\n-    // Close the table\n-    write!(w, \"</table>\")\n-}\n-\n-/// Write a graphviz DOT node for the given basic block.\n-fn write_node<W: Write>(\n-    block: BasicBlock,\n-    body: &Body<'_>,\n-    dark_mode: bool,\n-    w: &mut W,\n-) -> io::Result<()> {\n-    let def_id = body.source.def_id();\n-    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n-    write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(def_id, block))?;\n-    write_node_label(block, body, dark_mode, w, 1, |_| Ok(()), |_| Ok(()))?;\n-    // Close the node label and the node itself.\n-    writeln!(w, \">];\")\n-}\n-\n-/// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n-fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::Result<()> {\n-    let def_id = body.source.def_id();\n-    let terminator = body[source].terminator();\n-    let labels = terminator.kind.fmt_successor_labels();\n-\n-    for (&target, label) in terminator.successors().zip(labels) {\n-        let src = node(def_id, source);\n-        let trg = node(def_id, target);\n-        writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, src, trg, label)?;\n-    }\n-\n-    Ok(())\n+    g.to_dot(w, &settings, subgraph)\n }\n \n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'tcx, W: Write>(\n+fn write_graph_label<'tcx, W: std::fmt::Write>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'_>,\n     w: &mut W,\n-) -> io::Result<()> {\n+) -> std::fmt::Result {\n     let def_id = body.source.def_id();\n \n-    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n+    write!(w, \"fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types.\n     for (i, arg) in body.args_iter().enumerate() {\n@@ -220,15 +109,11 @@ fn write_graph_label<'tcx, W: Write>(\n             w,\n             r#\"debug {} =&gt; {};<br align=\"left\"/>\"#,\n             var_debug_info.name,\n-            escape(&var_debug_info.place)\n+            escape(&var_debug_info.value),\n         )?;\n     }\n \n-    writeln!(w, \">;\")\n-}\n-\n-fn node(def_id: DefId, block: BasicBlock) -> String {\n-    format!(\"bb{}__{}\", block.index(), graphviz_safe_def_name(def_id))\n+    Ok(())\n }\n \n fn escape<T: Debug>(t: &T) -> String {"}, {"sha": "b7b702431bc2a9a0d050e9d0a6556af3412851bf", "filename": "compiler/rustc_mir/src/util/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -7,6 +7,7 @@ pub mod storage;\n mod alignment;\n pub mod collect_writes;\n mod find_self_call;\n+mod generic_graph;\n pub(crate) mod generic_graphviz;\n mod graphviz;\n pub(crate) mod pretty;\n@@ -15,6 +16,6 @@ pub(crate) mod spanview;\n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::find_self_call::find_self_call;\n-pub use self::graphviz::write_node_label as write_graphviz_node_label;\n-pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n+pub use self::generic_graph::graphviz_safe_def_name;\n+pub use self::graphviz::write_mir_graphviz;\n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};"}, {"sha": "89ce29bd101297af402590bf072f26ea60ec78d7", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{self, TyCtxt, TyS, TypeFoldable, TypeVisitor};\n use rustc_target::abi::Size;\n use std::ops::ControlFlow;\n \n@@ -408,6 +408,18 @@ impl ExtraComments<'tcx> {\n     }\n }\n \n+fn use_verbose(ty: &&TyS<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n+        // Unit type\n+        ty::Tuple(g_args) if g_args.is_empty() => false,\n+        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(&g_arg.expect_ty())),\n+        ty::Array(ty, _) => use_verbose(ty),\n+        ty::FnDef(..) => false,\n+        _ => true,\n+    }\n+}\n+\n impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n@@ -430,16 +442,10 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n         let ty::Const { ty, val, .. } = constant;\n-        match ty.kind() {\n-            ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => {}\n-            // Unit type\n-            ty::Tuple(tys) if tys.is_empty() => {}\n-            ty::FnDef(..) => {}\n-            _ => {\n-                self.push(\"ty::Const\");\n-                self.push(&format!(\"+ ty: {:?}\", ty));\n-                self.push(&format!(\"+ val: {:?}\", val));\n-            }\n+        if use_verbose(ty) {\n+            self.push(\"ty::Const\");\n+            self.push(&format!(\"+ ty: {:?}\", ty));\n+            self.push(&format!(\"+ val: {:?}\", val));\n         }\n     }\n \n@@ -495,7 +501,7 @@ fn write_scope_tree(\n \n         let indented_debug_info = format!(\n             \"{0:1$}debug {2} => {3:?};\",\n-            INDENT, indent, var_debug_info.name, var_debug_info.place,\n+            INDENT, indent, var_debug_info.name, var_debug_info.value,\n         );\n \n         writeln!("}, {"sha": "cf2e4e8916d0a397c5f8b320f8acf39951417687", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 319, "deletions": 80, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,29 +4,303 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_middle::middle::region;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n+/// The \"outermost\" place that holds this value.\n+#[derive(Copy, Clone)]\n+crate enum PlaceBase {\n+    /// Denotes the start of a `Place`.\n+    Local(Local),\n+\n+    /// When building place for an expression within a closure, the place might start off a\n+    /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n+    /// index (within the desugared closure) of the captured path until most of the projections\n+    /// are applied. We use `PlaceBase::Upvar` to keep track of the root variable off of which the\n+    /// captured path starts, the closure the capture belongs to and the trait the closure\n+    /// implements.\n+    ///\n+    /// Once we have figured out the capture index, we can convert the place builder to start from\n+    /// `PlaceBase::Local`.\n+    ///\n+    /// Consider the following example\n+    /// ```rust\n+    /// let t = (10, (10, (10, 10)));\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\", t.0.0.0);\n+    /// };\n+    /// ```\n+    /// Here the THIR expression for `t.0.0.0` will be something like\n+    ///\n+    /// ```\n+    /// * Field(0)\n+    ///     * Field(0)\n+    ///         * Field(0)\n+    ///             * UpvarRef(t)\n+    /// ```\n+    ///\n+    /// When `capture_disjoint_fields` is enabled, `t.0.0.0` is captured and we won't be able to\n+    /// figure out that it is captured until all the `Field` projections are applied.\n+    Upvar {\n+        /// HirId of the upvar\n+        var_hir_id: HirId,\n+        /// DefId of the closure\n+        closure_def_id: DefId,\n+        /// The trait closure implements, `Fn`, `FnMut`, `FnOnce`\n+        closure_kind: ty::ClosureKind },\n+}\n+\n /// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n /// place by pushing more and more projections onto the end, and then convert the final set into a\n /// place using the `into_place` method.\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n-struct PlaceBuilder<'tcx> {\n-    local: Local,\n+crate struct PlaceBuilder<'tcx> {\n+    base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n+/// Given a list of MIR projections, convert them to list of HIR ProjectionKind.\n+/// The projections are truncated to represent a path that might be captured by a\n+/// closure/generator. This implies the vector returned from this function doesn't contain\n+/// ProjectionElems `Downcast`, `ConstantIndex`, `Index`, or `Subslice` because those will never be\n+/// part of a path that is captued by a closure. We stop applying projections once we see the first\n+/// projection that isn't captured by a closure.\n+fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n+    mir_projections: &[PlaceElem<'tcx>],\n+) -> Vec<HirProjectionKind> {\n+\n+    let mut hir_projections  = Vec::new();\n+\n+    for mir_projection in mir_projections {\n+        let hir_projection = match mir_projection {\n+            ProjectionElem::Deref => HirProjectionKind::Deref,\n+            ProjectionElem::Field(field, _) => {\n+                // We will never encouter this for multivariant enums,\n+                // read the comment for `Downcast`.\n+                HirProjectionKind::Field(field.index() as u32, VariantIdx::new(0))\n+            },\n+            ProjectionElem::Downcast(..) => {\n+                // This projections exist only for enums that have\n+                // multiple variants. Since such enums that are captured\n+                // completely, we can stop here.\n+                break\n+            },\n+            ProjectionElem::Index(..)\n+            | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. } => {\n+                // We don't capture array-access projections.\n+                // We can stop here as arrays are captured completely.\n+                break\n+            },\n+        };\n+\n+        hir_projections.push(hir_projection);\n+    }\n+\n+    hir_projections\n+}\n+\n+/// Return true if the `proj_possible_ancestor` represents an ancestor path\n+/// to `proj_capture` or `proj_possible_ancestor` is same as `proj_capture`,\n+/// assuming they both start off of the same root variable.\n+///\n+/// **Note:** It's the caller's responsibility to ensure that both lists of projections\n+///           start off of the same root variable.\n+///\n+/// Eg: 1. `foo.x` which is represented using `projections=[Field(x)]` is an ancestor of\n+///        `foo.x.y` which is represented using `projections=[Field(x), Field(y)]`.\n+///        Note both `foo.x` and `foo.x.y` start off of the same root variable `foo`.\n+///     2. Since we only look at the projections here function will return `bar.x` as an a valid\n+///        ancestor of `foo.x.y`. It's the caller's responsibility to ensure that both projections\n+///        list are being applied to the same root variable.\n+fn is_ancestor_or_same_capture(\n+    proj_possible_ancestor: &Vec<HirProjectionKind>,\n+    proj_capture: &[HirProjectionKind],\n+) -> bool {\n+    // We want to make sure `is_ancestor_or_same_capture(\"x.0.0\", \"x.0\")` to return false.\n+    // Therefore we can't just check if all projections are same in the zipped iterator below.\n+    if proj_possible_ancestor.len() > proj_capture.len() {\n+        return false;\n+    }\n+\n+    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n+}\n+\n+/// Computes the index of a capture within the desugared closure provided the closure's\n+/// `closure_min_captures` and the capture's index of the capture in the\n+/// `ty::MinCaptureList` of the root variable `var_hir_id`.\n+fn compute_capture_idx<'tcx>(\n+    closure_min_captures: &ty::RootVariableMinCaptureList<'tcx>,\n+    var_hir_id: HirId,\n+    root_var_idx: usize,\n+) -> usize {\n+    let mut res = 0;\n+    for (var_id, capture_list) in closure_min_captures {\n+        if *var_id == var_hir_id {\n+            res += root_var_idx;\n+            break;\n+        } else {\n+            res += capture_list.len();\n+        }\n+    }\n+\n+    res\n+}\n+\n+/// Given a closure, returns the index of a capture within the desugared closure struct and the\n+/// `ty::CapturedPlace` which is the ancestor of the Place represented using the `var_hir_id`\n+/// and `projection`.\n+///\n+/// Note there will be at most one ancestor for any given Place.\n+///\n+/// Returns None, when the ancestor is not found.\n+fn find_capture_matching_projections<'a, 'tcx>(\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    var_hir_id: HirId,\n+    closure_def_id: DefId,\n+    projections: &[PlaceElem<'tcx>],\n+) -> Option<(usize, &'a ty::CapturedPlace<'tcx>)> {\n+    let closure_min_captures = typeck_results.closure_min_captures.get(&closure_def_id)?;\n+    let root_variable_min_captures = closure_min_captures.get(&var_hir_id)?;\n+\n+    let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n+\n+    // If an ancestor is found, `idx` is the index within the list of captured places\n+    // for root variable `var_hir_id` and `capture` is the `ty::CapturedPlace` itself.\n+    let (idx, capture) = root_variable_min_captures.iter().enumerate().find(|(_, capture)| {\n+            let possible_ancestor_proj_kinds =\n+                capture.place.projections.iter().map(|proj| proj.kind).collect();\n+            is_ancestor_or_same_capture(&possible_ancestor_proj_kinds, &hir_projections)\n+    })?;\n+\n+    // Convert index to be from the presepective of the entire closure_min_captures map\n+    // instead of just the root variable capture list\n+    Some((compute_capture_idx(closure_min_captures, var_hir_id, idx), capture))\n+}\n+\n+/// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n+/// `PlaceBuilder` now starts from `PlaceBase::Local`.\n+///\n+/// Returns a Result with the error being the HirId of the Upvar that was not found.\n+fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+    from_builder: PlaceBuilder<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> Result<PlaceBuilder<'tcx>, HirId> {\n+    match from_builder.base {\n+        PlaceBase::Local(_) => Ok(from_builder),\n+        PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n+            // Captures are represented using fields inside a structure.\n+            // This represents accessing self in the closure structure\n+            let mut upvar_resolved_place_builder = PlaceBuilder::from(Local::new(1));\n+            match closure_kind {\n+                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                    upvar_resolved_place_builder = upvar_resolved_place_builder.deref();\n+                }\n+                ty::ClosureKind::FnOnce => {}\n+            }\n+\n+            let (capture_index, capture) =\n+                if let Some(capture_details) = find_capture_matching_projections(\n+                    typeck_results,\n+                    var_hir_id,\n+                    closure_def_id,\n+                    &from_builder.projection,\n+                ) {\n+                    capture_details\n+                } else {\n+                    if !tcx.features().capture_disjoint_fields {\n+                        bug!(\n+                            \"No associated capture found for {:?}[{:#?}] even though \\\n+                            capture_disjoint_fields isn't enabled\",\n+                            var_hir_id,\n+                            from_builder.projection\n+                        )\n+                    } else {\n+                        // FIXME(project-rfc-2229#24): Handle this case properly\n+                        debug!(\n+                            \"No associated capture found for {:?}[{:#?}]\",\n+                            var_hir_id,\n+                            from_builder.projection,\n+                        );\n+                    }\n+                    return Err(var_hir_id);\n+                };\n+\n+            let closure_ty =\n+                typeck_results.node_type(tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local()));\n+\n+            let substs = match closure_ty.kind() {\n+                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+                _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty),\n+            };\n+\n+            // Access the capture by accessing the field within the Closure struct.\n+            //\n+            // We must have inferred the capture types since we are building MIR, therefore\n+            // it's safe to call `tuple_element_ty` and we can unwrap here because\n+            // we know that the capture exists and is the `capture_index`-th capture.\n+            let var_ty = substs.tupled_upvars_ty().tuple_element_ty(capture_index).unwrap();\n+\n+            upvar_resolved_place_builder = upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);\n+\n+            // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n+            // we need to deref it\n+            upvar_resolved_place_builder = match capture.info.capture_kind {\n+                ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n+                ty::UpvarCapture::ByValue(_) => upvar_resolved_place_builder,\n+            };\n+\n+            let next_projection = capture.place.projections.len();\n+            let mut curr_projections = from_builder.projection;\n+\n+            // We used some of the projections to build the capture itself,\n+            // now we apply the remaining to the upvar resolved place.\n+            upvar_resolved_place_builder.projection.extend(\n+                curr_projections.drain(next_projection..));\n+\n+            Ok(upvar_resolved_place_builder)\n+        }\n+    }\n+}\n+\n impl<'tcx> PlaceBuilder<'tcx> {\n-    fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n+    crate fn into_place<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> Place<'tcx> {\n+        if let PlaceBase::Local(local) = self.base {\n+            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+        } else {\n+            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+        }\n+    }\n+\n+    fn expect_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n+    }\n+\n+    crate fn base(&self) -> PlaceBase {\n+        self.base\n     }\n \n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n@@ -49,7 +323,13 @@ impl<'tcx> PlaceBuilder<'tcx> {\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { local, projection: Vec::new() }\n+        Self { base: PlaceBase::Local(local), projection: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase) -> Self {\n+        Self { base, projection: Vec::new() }\n     }\n }\n \n@@ -71,12 +351,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n+    crate fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -98,7 +378,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -161,27 +441,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 source_info,\n             ),\n             ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n-                let capture = this\n-                    .hir\n-                    .typeck_results\n-                    .closure_captures\n-                    .get(&closure_def_id)\n-                    .and_then(|captures| captures.get_full(&var_hir_id));\n-\n-                if capture.is_none() {\n-                    if !this.hir.tcx().features().capture_disjoint_fields {\n-                        bug!(\n-                            \"No associated capture found for {:?} even though \\\n-                            capture_disjoint_fields isn't enabled\",\n-                            expr.kind\n-                        )\n-                    }\n-                    // FIXME(project-rfc-2229#24): Handle this case properly\n-                }\n-\n-                // Unwrap until the FIXME has been resolved\n-                let (capture_index, _, upvar_id) = capture.unwrap();\n-                this.lower_closure_capture(block, capture_index, *upvar_id)\n+                let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n+                this.lower_captured_upvar(block, upvar_id)\n             }\n \n             ExprKind::VarRef { id } => {\n@@ -208,7 +469,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.hir.tcx());\n+                    let place =\n+                        place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -293,59 +555,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Lower a closure/generator capture by representing it as a field\n-    /// access within the desugared closure/generator.\n-    ///\n-    /// `capture_index` is the index of the capture within the desugared\n-    /// closure/generator.\n-    fn lower_closure_capture(\n+    /// Lower a captured upvar. Note we might not know the actual capture index,\n+    /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n+    /// once all projections that allow us to indentify a capture have been applied.\n+    fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n-        capture_index: usize,\n         upvar_id: ty::UpvarId,\n-    )  -> BlockAnd<PlaceBuilder<'tcx>> {\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty = self\n             .hir\n             .typeck_results()\n             .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n-        // Captures are represented using fields inside a structure.\n-        // This represents accessing self in the closure structure\n-        let mut place_builder = PlaceBuilder::from(Local::new(1));\n-\n-        // In case of Fn/FnMut closures we must deref to access the fields\n-        // Generators are considered FnOnce, so we ignore this step for them.\n-        if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            match self.hir.infcx().closure_kind(closure_substs).unwrap() {\n-                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                    place_builder = place_builder.deref();\n-                }\n-                ty::ClosureKind::FnOnce => {}\n-            }\n-        }\n-\n-        let substs = match closure_ty.kind() {\n-            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-            _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty)\n+        let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n+            self.hir.infcx().closure_kind(closure_substs).unwrap()\n+        } else {\n+            // Generators are considered FnOnce.\n+            ty::ClosureKind::FnOnce\n         };\n \n-        // Access the capture by accessing the field within the Closure struct.\n-        //\n-        // We must have inferred the capture types since we are building MIR, therefore\n-        // it's safe to call `upvar_tys` and we can unwrap here because\n-        // we know that the capture exists and is the `capture_index`-th capture.\n-        let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n-        place_builder = place_builder.field(Field::new(capture_index), var_ty);\n-\n-        // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n-        // we need to deref it\n-        match self.hir.typeck_results.upvar_capture(upvar_id) {\n-            ty::UpvarCapture::ByRef(_) => {\n-                block.and(place_builder.deref())\n-            }\n-            ty::UpvarCapture::ByValue(_) => block.and(place_builder),\n-        }\n+        block.and(PlaceBuilder::from(PlaceBase::Upvar {\n+            var_hir_id: upvar_id.var_path.hir_id,\n+            closure_def_id: upvar_id.closure_expr_id.to_def_id(),\n+            closure_kind,\n+        }))\n     }\n \n     /// Lower an index expression\n@@ -373,7 +607,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n-        let base_place =\n+        let mut base_place =\n             unpack!(block = self.expr_as_place(block, lhs, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n@@ -383,7 +617,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         block = self.bounds_check(\n             block,\n-            base_place.clone().into_place(self.hir.tcx()),\n+            base_place.clone().into_place(self.hir.tcx(), self.hir.typeck_results()),\n             idx,\n             expr_span,\n             source_info,\n@@ -392,6 +626,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n+            base_place = base_place.expect_upvars_resolved(self.hir.tcx(), self.hir.typeck_results());\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -441,8 +676,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.hir.tcx();\n-        let place_ty =\n-            Place::ty_from(base_place.local, &base_place.projection, &self.local_decls, tcx);\n+        let local = match base_place.base {\n+            PlaceBase::Local(local) => local,\n+            PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\")\n+        };\n+\n+        let place_ty = Place::ty_from(local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -452,7 +691,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -470,14 +709,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { local: base_place.local, projection },\n+                                Place { local, projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "3f381f3f15e8e0907c5e379e2bdf32c1a4fce077", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,6 +4,7 @@ use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n+use crate::build::expr::as_place::PlaceBase;\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n@@ -393,51 +394,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         this.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });\n \n-        let arg_place = unpack!(block = this.as_place(block, arg));\n-\n-        let mutability = match arg_place.as_ref() {\n-            PlaceRef { local, projection: &[] } => this.local_decls[local].mutability,\n-            PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n-                debug_assert!(\n-                    this.local_decls[local].is_ref_for_guard(),\n-                    \"Unexpected capture place\",\n-                );\n-                this.local_decls[local].mutability\n-            }\n-            PlaceRef {\n-                local,\n-                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n-            }\n-            | PlaceRef {\n-                local,\n-                projection:\n-                    &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n-            } => {\n-                let place = PlaceRef { local, projection: proj_base };\n-\n-                // Not projected from the implicit `self` in a closure.\n-                debug_assert!(\n-                    match place.local_or_deref_local() {\n-                        Some(local) => local == Local::new(1),\n-                        None => false,\n-                    },\n-                    \"Unexpected capture place\"\n-                );\n-                // Not in a closure\n-                debug_assert!(\n-                    this.upvar_mutbls.len() > upvar_index.index(),\n-                    \"Unexpected capture place\"\n-                );\n-                this.upvar_mutbls[upvar_index.index()]\n+        let arg_place_builder = unpack!(block = this.as_place_builder(block, arg));\n+\n+        let mutability = match arg_place_builder.base() {\n+            // We are capturing a path that starts off a local variable in the parent.\n+            // The mutability of the current capture is same as the mutability\n+            // of the local declaration in the parent.\n+            PlaceBase::Local(local) =>  this.local_decls[local].mutability,\n+            // Parent is a closure and we are capturing a path that is captured\n+            // by the parent itself. The mutability of the current capture\n+            // is same as that of the capture in the parent closure.\n+            PlaceBase::Upvar { .. } => {\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n+                match enclosing_upvars_resolved.as_ref() {\n+                    PlaceRef { local, projection: &[ProjectionElem::Field(upvar_index, _), ..] }\n+                    | PlaceRef {\n+                        local,\n+                        projection: &[ProjectionElem::Deref, ProjectionElem::Field(upvar_index, _), ..] } => {\n+                            // Not in a closure\n+                            debug_assert!(\n+                                local == Local::new(1),\n+                                \"Expected local to be Local(1), found {:?}\",\n+                                local\n+                            );\n+                            // Not in a closure\n+                            debug_assert!(\n+                                this.upvar_mutbls.len() > upvar_index.index(),\n+                                \"Unexpected capture place, upvar_mutbls={:#?}, upvar_index={:?}\",\n+                                this.upvar_mutbls, upvar_index\n+                            );\n+                            this.upvar_mutbls[upvar_index.index()]\n+                        }\n+                    _ => bug!(\"Unexpected capture place\"),\n+                }\n             }\n-            _ => bug!(\"Unexpected capture place\"),\n         };\n \n         let borrow_kind = match mutability {\n             Mutability::Not => BorrowKind::Unique,\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n+        let arg_place = arg_place_builder.into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n         this.cfg.push_assign(\n             block,\n             source_info,"}, {"sha": "09281799041eeb11ec761aede42467a7ebac201f", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -40,11 +40,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n-        let expr_is_block_or_scope = match expr.kind {\n-            ExprKind::Block { .. } => true,\n-            ExprKind::Scope { .. } => true,\n-            _ => false,\n-        };\n+        let expr_is_block_or_scope = matches!(expr.kind, ExprKind::Block { .. } | ExprKind::Scope { .. });\n \n         let schedule_drop = move |this: &mut Self| {\n             if let Some(drop_scope) = scope {"}, {"sha": "2e108d480932a1cce9e4352e7d6b0db65b1a0597", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -228,6 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         guard: Option<&Guard<'tcx>>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        arm_span: Option<Span>,\n         arm_scope: Option<region::Scope>,\n     ) -> BasicBlock {\n         if candidate.subcandidates.is_empty() {\n@@ -239,6 +240,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 guard,\n                 fake_borrow_temps,\n                 scrutinee_span,\n+                arm_span,\n                 true,\n             )\n         } else {\n@@ -274,6 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         guard,\n                         &fake_borrow_temps,\n                         scrutinee_span,\n+                        arm_span,\n                         schedule_drops,\n                     );\n                     if arm_scope.is_none() {\n@@ -436,6 +439,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             &fake_borrow_temps,\n             irrefutable_pat.span,\n             None,\n+            None,\n         )\n         .unit()\n     }\n@@ -817,11 +821,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// For an example of a case where we set `otherwise_block`, even for an\n     /// exhaustive match consider:\n     ///\n+    /// ```rust\n     /// match x {\n     ///     (true, true) => (),\n     ///     (_, false) => (),\n     ///     (false, true) => (),\n     /// }\n+    /// ```\n     ///\n     /// For this match, we check if `x.0` matches `true` (for the first\n     /// arm). If that's false, we check `x.1`. If it's `true` we check if\n@@ -935,11 +941,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Link up matched candidates. For example, if we have something like\n     /// this:\n     ///\n+    /// ```rust\n     /// ...\n     /// Some(x) if cond => ...\n     /// Some(x) => ...\n     /// Some(x) if cond => ...\n     /// ...\n+    /// ```\n     ///\n     /// We generate real edges from:\n     /// * `start_block` to the `prebinding_block` of the first pattern,\n@@ -1517,7 +1525,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Initializes each of the bindings from the candidate by\n     /// moving/copying/ref'ing the source as appropriate. Tests the guard, if\n     /// any, and then branches to the arm. Returns the block for the case where\n-    /// the guard fails.\n+    /// the guard succeeds.\n     ///\n     /// Note: we do not check earlier that if there is a guard,\n     /// there cannot be move bindings. We avoid a use-after-move by only\n@@ -1529,6 +1537,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         guard: Option<&Guard<'tcx>>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        arm_span: Option<Span>,\n         schedule_drops: bool,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n@@ -1659,15 +1668,42 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_assign(block, scrutinee_source_info, Place::from(temp), borrow);\n             }\n \n-            // the block to branch to if the guard fails; if there is no\n-            // guard, this block is simply unreachable\n-            let guard = match guard {\n-                Guard::If(e) => self.hir.mirror(e.clone()),\n+            let (guard_span, (post_guard_block, otherwise_post_guard_block)) = match guard {\n+                Guard::If(e) => {\n+                    let e = self.hir.mirror(e.clone());\n+                    let source_info = self.source_info(e.span);\n+                    (e.span, self.test_bool(block, e, source_info))\n+                },\n+                Guard::IfLet(pat, scrutinee) => {\n+                    let scrutinee_span = scrutinee.span();\n+                    let scrutinee_place = unpack!(block = self.lower_scrutinee(block, scrutinee.clone(), scrutinee_span));\n+                    let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n+                    let wildcard = Pat::wildcard_from_ty(pat.ty);\n+                    let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);\n+                    let fake_borrow_temps =\n+                        self.lower_match_tree(block, pat.span, false, &mut [&mut guard_candidate, &mut otherwise_candidate]);\n+                    self.declare_bindings(\n+                        None,\n+                        pat.span.to(arm_span.unwrap()),\n+                        pat,\n+                        ArmHasGuard(false),\n+                        Some((Some(&scrutinee_place), scrutinee.span())),\n+                    );\n+                    let post_guard_block = self.bind_pattern(\n+                        self.source_info(pat.span),\n+                        guard_candidate,\n+                        None,\n+                        &fake_borrow_temps,\n+                        scrutinee.span(),\n+                        None,\n+                        None,\n+                    );\n+                    let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n+                    (scrutinee_span, (post_guard_block, otherwise_post_guard_block))\n+                }\n             };\n-            let source_info = self.source_info(guard.span);\n-            let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n-            let (post_guard_block, otherwise_post_guard_block) =\n-                self.test_bool(block, guard, source_info);\n+            let source_info = self.source_info(guard_span);\n+            let guard_end = self.source_info(tcx.sess.source_map().end_point(guard_span));\n             let guard_frame = self.guard_context.pop().unwrap();\n             debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n \n@@ -1925,7 +1961,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.var_debug_info.push(VarDebugInfo {\n             name,\n             source_info: debug_source_info,\n-            place: for_arm_body.into(),\n+            value: VarDebugInfoContents::Place(for_arm_body.into()),\n         });\n         let locals = if has_guard.0 {\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n@@ -1944,7 +1980,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info.push(VarDebugInfo {\n                 name,\n                 source_info: debug_source_info,\n-                place: ref_for_guard.into(),\n+                value: VarDebugInfoContents::Place(ref_for_guard.into()),\n             });\n             LocalsForNode::ForGuard { ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "996615995259d58bf77b17dd8d987516585a5394", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n@@ -808,7 +809,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.var_debug_info.push(VarDebugInfo {\n                         name: ident.name,\n                         source_info,\n-                        place: arg_local.into(),\n+                        value: VarDebugInfoContents::Place(arg_local.into()),\n                     });\n                 }\n             }\n@@ -823,7 +824,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`.\n-        if let Some(upvars) = hir_typeck_results.closure_captures.get(&fn_def_id) {\n+        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;\n@@ -836,15 +837,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n                 _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n             };\n-            let upvar_tys = upvar_substs.upvar_tys();\n-            let upvars_with_tys = upvars.iter().zip(upvar_tys);\n-            self.upvar_mutbls = upvars_with_tys\n+            let capture_tys = upvar_substs.upvar_tys();\n+            let captures_with_tys = hir_typeck_results\n+                .closure_min_captures_flattened(fn_def_id)\n+                .zip(capture_tys);\n+\n+            self.upvar_mutbls = captures_with_tys\n                 .enumerate()\n-                .map(|(i, ((&var_id, &upvar_id), ty))| {\n-                    let capture = hir_typeck_results.upvar_capture(upvar_id);\n+                .map(|(i, (captured_place, ty))| {\n+                    let capture = captured_place.info.capture_kind;\n+                    let var_id = match captured_place.place.base {\n+                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                        _ => bug!(\"Expected an upvar\")\n+                    };\n \n                     let mut mutability = Mutability::Not;\n-                    let mut name = kw::Invalid;\n+\n+                    // FIXME(project-rfc-2229#8): Store more precise information\n+                    let mut name = kw::Empty;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;\n@@ -872,10 +882,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.var_debug_info.push(VarDebugInfo {\n                         name,\n                         source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n-                        place: Place {\n+                        value: VarDebugInfoContents::Place(Place {\n                             local: closure_env_arg,\n                             projection: tcx.intern_place_elems(&projs),\n-                        },\n+                        }),\n                     });\n \n                     mutability"}, {"sha": "62d2212d10962e815c09940665d442cef1d2b15f", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -616,8 +616,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n                 unpack!(block = self.into(destination, dest_scope, block, value));\n-                dest_scope\n-                    .map(|scope| self.unschedule_drop(scope, destination.as_local().unwrap()));\n+                if let Some(scope) = dest_scope {\n+                    self.unschedule_drop(scope, destination.as_local().unwrap())\n+                };\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n@@ -1196,6 +1197,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         arm.guard.as_ref(),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n+                        Some(arm.span),\n                         Some(arm.scope),\n                     );\n "}, {"sha": "417f9bded09884901516a4942c34214de12e4db0", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -6,6 +6,8 @@ use crate::thir::*;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::ty::adjustment::{\n@@ -386,14 +388,12 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n+\n             let upvars = cx\n                 .typeck_results()\n-                .closure_captures\n-                .get(&def_id)\n-                .iter()\n-                .flat_map(|upvars| upvars.iter())\n+                .closure_min_captures_flattened(def_id)\n                 .zip(substs.upvar_tys())\n-                .map(|((&var_hir_id, _), ty)| capture_upvar(cx, expr, var_hir_id, ty))\n+                .map(|(captured_place, ty)| capture_upvar(cx, expr, captured_place, ty))\n                 .collect();\n             ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n         }\n@@ -776,10 +776,10 @@ impl ToBorrowKind for hir::Mutability {\n fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n     Arm {\n         pattern: cx.pattern_from_hir(&arm.pat),\n-        guard: match arm.guard {\n-            Some(hir::Guard::If(ref e)) => Some(Guard::If(e.to_ref())),\n-            _ => None,\n-        },\n+        guard: arm.guard.as_ref().map(|g| match g {\n+            hir::Guard::If(ref e) => Guard::If(e.to_ref()),\n+            hir::Guard::IfLet(ref pat, ref e) => Guard::IfLet(cx.pattern_from_hir(pat), e.to_ref()),\n+        }),\n         body: arm.body.to_ref(),\n         lint_level: LintLevel::Explicit(arm.hir_id),\n         scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n@@ -981,27 +981,55 @@ fn overloaded_place<'a, 'tcx>(\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_upvar<'tcx>(\n+fn capture_upvar<'a, 'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n     closure_expr: &'tcx hir::Expr<'tcx>,\n-    var_hir_id: hir::HirId,\n+    captured_place: &'a ty::CapturedPlace<'tcx>,\n     upvar_ty: Ty<'tcx>,\n ) -> ExprRef<'tcx> {\n-    let upvar_id = ty::UpvarId {\n-        var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n-    };\n-    let upvar_capture = cx.typeck_results().upvar_capture(upvar_id);\n+    let upvar_capture = captured_place.info.capture_kind;\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = cx.typeck_results().node_type(var_hir_id);\n-    let captured_var = Expr {\n+    let var_ty = captured_place.place.base_ty;\n+\n+    // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+    // as it's seen for use within the closure and not at the time of closure creation.\n+    //\n+    // That is we see expect to see it start from a captured upvar and not something that is local\n+    // to the closure's parent.\n+    let var_hir_id = match captured_place.place.base {\n+        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+        base => bug!(\"Expected an upvar, found {:?}\", base),\n+    };\n+\n+    let mut captured_place_expr = Expr {\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n         kind: convert_var(cx, var_hir_id),\n     };\n+\n+    for proj in captured_place.place.projections.iter() {\n+        let kind = match proj.kind {\n+            HirProjectionKind::Deref => ExprKind::Deref { arg: captured_place_expr.to_ref() },\n+            HirProjectionKind::Field(field, ..) => {\n+                // Variant index will always be 0, because for multi-variant\n+                // enums, we capture the enum entirely.\n+                ExprKind::Field {\n+                    lhs: captured_place_expr.to_ref(),\n+                    name: Field::new(field as usize),\n+                }\n+            }\n+            HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                // We don't capture these projections, so we can ignore them here\n+                continue;\n+            }\n+        };\n+\n+        captured_place_expr = Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+    }\n+\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),\n+        ty::UpvarCapture::ByValue(_) => captured_place_expr.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n@@ -1012,7 +1040,7 @@ fn capture_upvar<'tcx>(\n                 temp_lifetime,\n                 ty: upvar_ty,\n                 span: closure_expr.span,\n-                kind: ExprKind::Borrow { borrow_kind, arg: captured_var.to_ref() },\n+                kind: ExprKind::Borrow { borrow_kind, arg: captured_place_expr.to_ref() },\n             }\n             .to_ref()\n         }"}, {"sha": "ace9cad4d299673a9672a77a212c92381087fd06", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -344,6 +344,7 @@ crate struct Arm<'tcx> {\n #[derive(Clone, Debug)]\n crate enum Guard<'tcx> {\n     If(ExprRef<'tcx>),\n+    IfLet(Pat<'tcx>, ExprRef<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "db817b378f97c2aa77e68a2b393cc5ef0fc30494", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -164,10 +164,20 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         for arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n             self.check_patterns(&arm.pat);\n+            if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n+                self.check_patterns(pat);\n+            }\n         }\n \n         let mut cx = self.new_cx(scrut.hir_id);\n \n+        for arm in arms {\n+            if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n+                let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n+                check_if_let_guard(&mut cx, &tpat, pat.hir_id);\n+            }\n+        }\n+\n         let mut have_errors = false;\n \n         let arms: Vec<_> = arms\n@@ -360,12 +370,28 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::\n         let msg = match source {\n             hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n             hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+            hir::MatchSource::IfLetGuardDesugar => \"irrefutable if-let guard\",\n             _ => bug!(),\n         };\n         lint.build(msg).emit()\n     });\n }\n \n+fn check_if_let_guard<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    pat: &'p super::Pat<'tcx>,\n+    pat_id: HirId,\n+) {\n+    let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n+    let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty);\n+    report_arm_reachability(&cx, &report, hir::MatchSource::IfLetGuardDesugar);\n+\n+    if report.non_exhaustiveness_witnesses.is_empty() {\n+        // The match is exhaustive, i.e. the if let pattern is irrefutable.\n+        irrefutable_let_pattern(cx.tcx, pat.span, pat_id, hir::MatchSource::IfLetGuardDesugar)\n+    }\n+}\n+\n /// Report unreachable arms, if any.\n fn report_arm_reachability<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -390,6 +416,11 @@ fn report_arm_reachability<'p, 'tcx>(\n                         }\n                     }\n \n+                    hir::MatchSource::IfLetGuardDesugar => {\n+                        assert_eq!(arm_index, 0);\n+                        unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, None);\n+                    }\n+\n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n                         unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, catchall);\n                     }\n@@ -402,7 +433,7 @@ fn report_arm_reachability<'p, 'tcx>(\n             Useful(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.iter().flatten().copied().collect();\n+                let mut unreachables: Vec<_> = unreachables.iter().collect();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {"}, {"sha": "db2fa5730a338b2e6129dbaf66d38273ae9fe34b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 580, "deletions": 514, "changes": 1094, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,6 +1,47 @@\n-//! This module provides functions to deconstruct and reconstruct patterns into a constructor\n-//! applied to some fields. This is used by the `_match` module to compute pattern\n-//! usefulness/exhaustiveness.\n+//! [`super::usefulness`] explains most of what is happening in this file. As explained there,\n+//! values and patterns are made from constructors applied to fields. This file defines a\n+//! `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert\n+//! them from/to patterns.\n+//!\n+//! There's one idea that is not detailed in [`super::usefulness`] because the details are not\n+//! needed there: _constructor splitting_.\n+//!\n+//! # Constructor splitting\n+//!\n+//! The idea is as follows: given a constructor `c` and a matrix, we want to specialize in turn\n+//! with all the value constructors that are covered by `c`, and compute usefulness for each.\n+//! Instead of listing all those constructors (which is intractable), we group those value\n+//! constructors together as much as possible. Example:\n+//!\n+//! ```\n+//! match (0, false) {\n+//!     (0 ..=100, true) => {} // `p_1`\n+//!     (50..=150, false) => {} // `p_2`\n+//!     (0 ..=200, _) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! The naive approach would try all numbers in the range `0..=200`. But we can be a lot more\n+//! clever: `0` and `1` for example will match the exact same rows, and return equivalent\n+//! witnesses. In fact all of `0..50` would. We can thus restrict our exploration to 4\n+//! constructors: `0..50`, `50..=100`, `101..=150` and `151..=200`. That is enough and infinitely\n+//! more tractable.\n+//!\n+//! We capture this idea in a function `split(p_1 ... p_n, c)` which returns a list of constructors\n+//! `c'` covered by `c`. Given such a `c'`, we require that all value ctors `c''` covered by `c'`\n+//! return an equivalent set of witnesses after specializing and computing usefulness.\n+//! In the example above, witnesses for specializing by `c''` covered by `0..50` will only differ\n+//! in their first element.\n+//!\n+//! We usually also ask that the `c'` together cover all of the original `c`. However we allow\n+//! skipping some constructors as long as it doesn't change whether the resulting list of witnesses\n+//! is empty of not. We use this in the wildcard `_` case.\n+//!\n+//! Splitting is implemented in the [`Constructor::split`] function. We don't do splitting for\n+//! or-patterns; instead we just try the alternatives one-by-one. For details on splitting\n+//! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`]; for slices, see\n+//! [`SplitVarLenSlice`].\n+\n use self::Constructor::*;\n use self::SliceKind::*;\n \n@@ -24,7 +65,7 @@ use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n use std::cmp::{self, max, min, Ordering};\n-use std::iter::IntoIterator;\n+use std::iter::{once, IntoIterator};\n use std::ops::RangeInclusive;\n \n /// An inclusive interval, used for precise integer exhaustiveness checking.\n@@ -161,7 +202,7 @@ impl IntRange {\n         // 2       --------   // 2 -------\n         let (lo, hi) = self.boundaries();\n         let (other_lo, other_hi) = other.boundaries();\n-        lo == other_hi || hi == other_lo\n+        (lo == other_hi || hi == other_lo) && !self.is_singleton() && !other.is_singleton()\n     }\n \n     fn to_pat<'tcx>(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n@@ -183,143 +224,56 @@ impl IntRange {\n         Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n \n-    /// For exhaustive integer matching, some constructors are grouped within other constructors\n-    /// (namely integer typed values are grouped within ranges). However, when specialising these\n-    /// constructors, we want to be specialising for the underlying constructors (the integers), not\n-    /// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n-    /// mean creating a separate constructor for every single value in the range, which is clearly\n-    /// impractical. However, observe that for some ranges of integers, the specialisation will be\n-    /// identical across all values in that range (i.e., there are equivalence classes of ranges of\n-    /// constructors based on their `U(S(c, P), S(c, p))` outcome). These classes are grouped by\n-    /// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n-    /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n-    /// change.\n-    /// Our solution, therefore, is to split the range constructor into subranges at every single point\n-    /// the group of intersecting patterns changes (using the method described below).\n-    /// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n-    /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n-    /// number of rows in the matrix (i.e., the number of cases in the `match` statement), so we don't\n-    /// need to be worried about matching over gargantuan ranges.\n-    ///\n-    /// Essentially, given the first column of a matrix representing ranges, looking like the following:\n-    ///\n-    /// |------|  |----------| |-------|    ||\n-    ///    |-------| |-------|            |----| ||\n-    ///       |---------|\n-    ///\n-    /// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n-    ///\n-    /// |--|--|||-||||--||---|||-------|  |-|||| ||\n-    ///\n-    /// The logic for determining how to split the ranges is fairly straightforward: we calculate\n-    /// boundaries for each interval range, sort them, then create constructors for each new interval\n-    /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n-    /// merging operation depicted above.)\n-    fn split<'p, 'tcx>(\n+    /// Lint on likely incorrect range patterns (#63987)\n+    pub(super) fn lint_overlapping_range_endpoints<'a, 'tcx: 'a>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        hir_id: Option<HirId>,\n-    ) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        /// Represents a border between 2 integers. Because the intervals spanning borders\n-        /// must be able to cover every integer, we need to be able to represent\n-        /// 2^128 + 1 such borders.\n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-        enum Border {\n-            JustBefore(u128),\n-            AfterMax,\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = (&'a Constructor<'tcx>, Span)>,\n+        column_count: usize,\n+        hir_id: HirId,\n+    ) {\n+        if self.is_singleton() {\n+            return;\n         }\n \n-        // A function for extracting the borders of an integer interval.\n-        fn range_borders(r: IntRange) -> impl Iterator<Item = Border> {\n-            let (lo, hi) = r.range.into_inner();\n-            let from = Border::JustBefore(lo);\n-            let to = match hi.checked_add(1) {\n-                Some(m) => Border::JustBefore(m),\n-                None => Border::AfterMax,\n-            };\n-            vec![from, to].into_iter()\n+        if column_count != 1 {\n+            // FIXME: for now, only check for overlapping ranges on simple range\n+            // patterns. Otherwise with the current logic the following is detected\n+            // as overlapping:\n+            // ```\n+            // match (0u8, true) {\n+            //   (0 ..= 125, false) => {}\n+            //   (125 ..= 255, true) => {}\n+            //   _ => {}\n+            // }\n+            // ```\n+            return;\n         }\n \n-        // Collect the span and range of all the intersecting ranges to lint on likely\n-        // incorrect range patterns. (#63987)\n-        let mut overlaps = vec![];\n-        let row_len = pcx.matrix.column_count().unwrap_or(0);\n-        // `borders` is the set of borders between equivalence classes: each equivalence\n-        // class lies between 2 borders.\n-        let row_borders = pcx\n-            .matrix\n-            .head_ctors_and_spans(pcx.cx)\n+        let overlaps: Vec<_> = ctors\n             .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n-            .filter_map(|(range, span)| {\n-                let intersection = self.intersection(&range);\n-                let should_lint = self.suspicious_intersection(&range);\n-                if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n-                    // FIXME: for now, only check for overlapping ranges on simple range\n-                    // patterns. Otherwise with the current logic the following is detected\n-                    // as overlapping:\n-                    // ```\n-                    // match (0u8, true) {\n-                    //   (0 ..= 125, false) => {}\n-                    //   (125 ..= 255, true) => {}\n-                    //   _ => {}\n-                    // }\n-                    // ```\n-                    overlaps.push((range.clone(), span));\n-                }\n-                intersection\n-            })\n-            .flat_map(range_borders);\n-        let self_borders = range_borders(self.clone());\n-        let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n-        borders.sort_unstable();\n-\n-        self.lint_overlapping_patterns(pcx, hir_id, overlaps);\n-\n-        // We're going to iterate through every adjacent pair of borders, making sure that\n-        // each represents an interval of nonnegative length, and convert each such\n-        // interval into a constructor.\n-        borders\n-            .array_windows()\n-            .filter_map(|&pair| match pair {\n-                [Border::JustBefore(n), Border::JustBefore(m)] => {\n-                    if n < m {\n-                        Some(n..=(m - 1))\n-                    } else {\n-                        None\n-                    }\n-                }\n-                [Border::JustBefore(n), Border::AfterMax] => Some(n..=u128::MAX),\n-                [Border::AfterMax, _] => None,\n-            })\n-            .map(|range| IntRange { range })\n-            .map(IntRange)\n-            .collect()\n-    }\n+            .filter(|(range, _)| self.suspicious_intersection(range))\n+            .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n+            .collect();\n \n-    fn lint_overlapping_patterns(\n-        &self,\n-        pcx: PatCtxt<'_, '_, '_>,\n-        hir_id: Option<HirId>,\n-        overlaps: Vec<(IntRange, Span)>,\n-    ) {\n-        if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+        if !overlaps.is_empty() {\n             pcx.cx.tcx.struct_span_lint_hir(\n-                lint::builtin::OVERLAPPING_PATTERNS,\n+                lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n                 pcx.span,\n                 |lint| {\n-                    let mut err = lint.build(\"multiple patterns covering the same range\");\n-                    err.span_label(pcx.span, \"overlapping patterns\");\n+                    let mut err = lint.build(\"multiple patterns overlap on their endpoints\");\n                     for (int_range, span) in overlaps {\n-                        // Use the real type for user display of the ranges:\n                         err.span_label(\n                             span,\n                             &format!(\n-                                \"this range overlaps on `{}`\",\n-                                int_range.to_pat(pcx.cx.tcx, pcx.ty),\n+                                \"this range overlaps on `{}`...\",\n+                                int_range.to_pat(pcx.cx.tcx, pcx.ty)\n                             ),\n                         );\n                     }\n+                    err.span_label(pcx.span, \"... with this range\");\n+                    err.note(\"you likely meant to write mutually exclusive ranges\");\n                     err.emit();\n                 },\n             );\n@@ -339,6 +293,101 @@ impl IntRange {\n     }\n }\n \n+/// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n+/// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum IntBorder {\n+    JustBefore(u128),\n+    AfterMax,\n+}\n+\n+/// A range of integers that is partitioned into disjoint subranges. This does constructor\n+/// splitting for integer ranges as explained at the top of the file.\n+///\n+/// This is fed multiple ranges, and returns an output that covers the input, but is split so that\n+/// the only intersections between an output range and a seen range are inclusions. No output range\n+/// straddles the boundary of one of the inputs.\n+///\n+/// The following input:\n+/// ```\n+///   |-------------------------| // `self`\n+/// |------|  |----------|   |----|\n+///    |-------| |-------|\n+/// ```\n+/// would be iterated over as follows:\n+/// ```\n+///   ||---|--||-|---|---|---|--|\n+/// ```\n+#[derive(Debug, Clone)]\n+struct SplitIntRange {\n+    /// The range we are splitting\n+    range: IntRange,\n+    /// The borders of ranges we have seen. They are all contained within `range`. This is kept\n+    /// sorted.\n+    borders: Vec<IntBorder>,\n+}\n+\n+impl SplitIntRange {\n+    fn new(range: IntRange) -> Self {\n+        SplitIntRange { range, borders: Vec::new() }\n+    }\n+\n+    /// Internal use\n+    fn to_borders(r: IntRange) -> [IntBorder; 2] {\n+        use IntBorder::*;\n+        let (lo, hi) = r.boundaries();\n+        let lo = JustBefore(lo);\n+        let hi = match hi.checked_add(1) {\n+            Some(m) => JustBefore(m),\n+            None => AfterMax,\n+        };\n+        [lo, hi]\n+    }\n+\n+    /// Add ranges relative to which we split.\n+    fn split(&mut self, ranges: impl Iterator<Item = IntRange>) {\n+        let this_range = &self.range;\n+        let included_ranges = ranges.filter_map(|r| this_range.intersection(&r));\n+        let included_borders = included_ranges.flat_map(|r| {\n+            let borders = Self::to_borders(r);\n+            once(borders[0]).chain(once(borders[1]))\n+        });\n+        self.borders.extend(included_borders);\n+        self.borders.sort_unstable();\n+    }\n+\n+    /// Iterate over the contained ranges.\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = IntRange> + Captures<'a> {\n+        use IntBorder::*;\n+\n+        let self_range = Self::to_borders(self.range.clone());\n+        // Start with the start of the range.\n+        let mut prev_border = self_range[0];\n+        self.borders\n+            .iter()\n+            .copied()\n+            // End with the end of the range.\n+            .chain(once(self_range[1]))\n+            // List pairs of adjacent borders.\n+            .map(move |border| {\n+                let ret = (prev_border, border);\n+                prev_border = border;\n+                ret\n+            })\n+            // Skip duplicates.\n+            .filter(|(prev_border, border)| prev_border != border)\n+            // Finally, convert to ranges.\n+            .map(|(prev_border, border)| {\n+                let range = match (prev_border, border) {\n+                    (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n+                    (JustBefore(n), AfterMax) => n..=u128::MAX,\n+                    _ => unreachable!(), // Ruled out by the sorting and filtering we did\n+                };\n+                IntRange { range }\n+            })\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n@@ -391,129 +440,141 @@ impl Slice {\n         self.kind.arity()\n     }\n \n-    /// The exhaustiveness-checking paper does not include any details on\n-    /// checking variable-length slice patterns. However, they may be\n-    /// matched by an infinite collection of fixed-length array patterns.\n-    ///\n-    /// Checking the infinite set directly would take an infinite amount\n-    /// of time. However, it turns out that for each finite set of\n-    /// patterns `P`, all sufficiently large array lengths are equivalent:\n-    ///\n-    /// Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-    /// to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-    /// `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-    /// the same subset of `P`.\n-    ///\n-    /// Because of that, each witness for reachability-checking of one\n-    /// of the sufficiently-large lengths can be transformed to an\n-    /// equally-valid witness of any other length, so we only have\n-    /// to check slices of the \"minimal sufficiently-large length\"\n-    /// and less.\n-    ///\n-    /// Note that the fact that there is a *single* `s\u2098` for each `m`\n-    /// not depending on the specific pattern in `P` is important: if\n-    /// you look at the pair of patterns\n-    ///     `[true, ..]`\n-    ///     `[.., false]`\n-    /// Then any slice of length \u22651 that matches one of these two\n-    /// patterns can be trivially turned to a slice of any\n-    /// other length \u22651 that matches them and vice-versa,\n-    /// but the slice of length 2 `[false, true]` that matches neither\n-    /// of these patterns can't be turned to a slice from length 1 that\n-    /// matches neither of these patterns, so we have to consider\n-    /// slices from length 2 there.\n-    ///\n-    /// Now, to see that that length exists and find it, observe that slice\n-    /// patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-    /// \"variable-length\" patterns (`[_, .., _]`).\n-    ///\n-    /// For fixed-length patterns, all slices with lengths *longer* than\n-    /// the pattern's length have the same outcome (of not matching), so\n-    /// as long as `L` is greater than the pattern's length we can pick\n-    /// any `s\u2098` from that length and get the same result.\n-    ///\n-    /// For variable-length patterns, the situation is more complicated,\n-    /// because as seen above the precise value of `s\u2098` matters.\n-    ///\n-    /// However, for each variable-length pattern `p` with a prefix of length\n-    /// `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-    /// `sl\u209a` elements are examined.\n-    ///\n-    /// Therefore, as long as `L` is positive (to avoid concerns about empty\n-    /// types), all elements after the maximum prefix length and before\n-    /// the maximum suffix length are not examined by any variable-length\n-    /// pattern, and therefore can be added/removed without affecting\n-    /// them - creating equivalent patterns from any sufficiently-large\n-    /// length.\n-    ///\n-    /// Of course, if fixed-length patterns exist, we must be sure\n-    /// that our length is large enough to miss them all, so\n-    /// we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n-    ///\n-    /// for example, with the above pair of patterns, all elements\n-    /// but the first and last can be added/removed, so any\n-    /// witness of length \u22652 (say, `[false, false, true]`) can be\n-    /// turned to a witness from any other length \u22652.\n-    fn split<'p, 'tcx>(self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let (self_prefix, self_suffix) = match self.kind {\n-            VarLen(self_prefix, self_suffix) => (self_prefix, self_suffix),\n-            _ => return smallvec![Slice(self)],\n-        };\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(self, other: Self) -> bool {\n+        other.kind.covers_length(self.arity())\n+    }\n+}\n+\n+/// This computes constructor splitting for variable-length slices, as explained at the top of the\n+/// file.\n+///\n+/// A slice pattern `[x, .., y]` behaves like the infinite or-pattern `[x, y] | [x, _, y] | [x, _,\n+/// _, y] | ...`. The corresponding value constructors are fixed-length array constructors above a\n+/// given minimum length. We obviously can't list this infinitude of constructors. Thankfully,\n+/// it turns out that for each finite set of slice patterns, all sufficiently large array lengths\n+/// are equivalent.\n+///\n+/// Let's look at an example, where we are trying to split the last pattern:\n+/// ```\n+/// match x {\n+///     [true, true, ..] => {}\n+///     [.., false, false] => {}\n+///     [..] => {}\n+/// }\n+/// ```\n+/// Here are the results of specialization for the first few lengths:\n+/// ```\n+/// // length 0\n+/// [] => {}\n+/// // length 1\n+/// [_] => {}\n+/// // length 2\n+/// [true, true] => {}\n+/// [false, false] => {}\n+/// [_, _] => {}\n+/// // length 3\n+/// [true, true,  _    ] => {}\n+/// [_,    false, false] => {}\n+/// [_,    _,     _    ] => {}\n+/// // length 4\n+/// [true, true, _,     _    ] => {}\n+/// [_,    _,    false, false] => {}\n+/// [_,    _,    _,     _    ] => {}\n+/// // length 5\n+/// [true, true, _, _,     _    ] => {}\n+/// [_,    _,    _, false, false] => {}\n+/// [_,    _,    _, _,     _    ] => {}\n+/// ```\n+///\n+/// If we went above length 5, we would simply be inserting more columns full of wildcards in the\n+/// middle. This means that the set of witnesses for length `l >= 5` if equivalent to the set for\n+/// any other `l' >= 5`: simply add or remove wildcards in the middle to convert between them.\n+///\n+/// This applies to any set of slice patterns: there will be a length `L` above which all lengths\n+/// behave the same. This is exactly what we need for constructor splitting. Therefore a\n+/// variable-length slice can be split into a variable-length slice of minimal length `L`, and many\n+/// fixed-length slices of lengths `< L`.\n+///\n+/// For each variable-length pattern `p` with a prefix of length `pl\u209a` and suffix of length `sl\u209a`,\n+/// only the first `pl\u209a` and the last `sl\u209a` elements are examined. Therefore, as long as `L` is\n+/// positive (to avoid concerns about empty types), all elements after the maximum prefix length\n+/// and before the maximum suffix length are not examined by any variable-length pattern, and\n+/// therefore can be added/removed without affecting them - creating equivalent patterns from any\n+/// sufficiently-large length.\n+///\n+/// Of course, if fixed-length patterns exist, we must be sure that our length is large enough to\n+/// miss them all, so we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n+///\n+/// `max_slice` below will be made to have arity `L`.\n+#[derive(Debug)]\n+struct SplitVarLenSlice {\n+    /// If the type is an array, this is its size.\n+    array_len: Option<u64>,\n+    /// The arity of the input slice.\n+    arity: u64,\n+    /// The smallest slice bigger than any slice seen. `max_slice.arity()` is the length `L`\n+    /// described above.\n+    max_slice: SliceKind,\n+}\n \n-        let head_ctors = pcx.matrix.head_ctors(pcx.cx).filter(|c| !c.is_wildcard());\n+impl SplitVarLenSlice {\n+    fn new(prefix: u64, suffix: u64, array_len: Option<u64>) -> Self {\n+        SplitVarLenSlice { array_len, arity: prefix + suffix, max_slice: VarLen(prefix, suffix) }\n+    }\n \n-        let mut max_prefix_len = self_prefix;\n-        let mut max_suffix_len = self_suffix;\n+    /// Pass a set of slices relative to which to split this one.\n+    fn split(&mut self, slices: impl Iterator<Item = SliceKind>) {\n+        let (max_prefix_len, max_suffix_len) = match &mut self.max_slice {\n+            VarLen(prefix, suffix) => (prefix, suffix),\n+            FixedLen(_) => return, // No need to split\n+        };\n+        // We grow `self.max_slice` to be larger than all slices encountered, as described above.\n+        // For diagnostics, we keep the prefix and suffix lengths separate, but grow them so that\n+        // `L = max_prefix_len + max_suffix_len`.\n         let mut max_fixed_len = 0;\n-\n-        for ctor in head_ctors {\n-            if let Slice(slice) = ctor {\n-                match slice.kind {\n-                    FixedLen(len) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, len);\n-                    }\n-                    VarLen(prefix, suffix) => {\n-                        max_prefix_len = cmp::max(max_prefix_len, prefix);\n-                        max_suffix_len = cmp::max(max_suffix_len, suffix);\n-                    }\n+        for slice in slices {\n+            match slice {\n+                FixedLen(len) => {\n+                    max_fixed_len = cmp::max(max_fixed_len, len);\n+                }\n+                VarLen(prefix, suffix) => {\n+                    *max_prefix_len = cmp::max(*max_prefix_len, prefix);\n+                    *max_suffix_len = cmp::max(*max_suffix_len, suffix);\n                 }\n-            } else {\n-                bug!(\"unexpected ctor for slice type: {:?}\", ctor);\n             }\n         }\n-\n-        // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n-        // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n-        // so that `L = max_prefix_len + max_suffix_len`.\n-        if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n+        // We want `L = max(L, max_fixed_len + 1)`, modulo the fact that we keep prefix and\n+        // suffix separate.\n+        if max_fixed_len + 1 >= *max_prefix_len + *max_suffix_len {\n             // The subtraction can't overflow thanks to the above check.\n-            // The new `max_prefix_len` is also guaranteed to be larger than its previous\n-            // value.\n-            max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n+            // The new `max_prefix_len` is larger than its previous value.\n+            *max_prefix_len = max_fixed_len + 1 - *max_suffix_len;\n         }\n \n-        let final_slice = VarLen(max_prefix_len, max_suffix_len);\n-        let final_slice = Slice::new(self.array_len, final_slice);\n+        // We cap the arity of `max_slice` at the array size.\n         match self.array_len {\n-            Some(_) => smallvec![Slice(final_slice)],\n-            None => {\n-                // `self` originally covered the range `(self.arity()..infinity)`. We split that\n-                // range into two: lengths smaller than `final_slice.arity()` are treated\n-                // independently as fixed-lengths slices, and lengths above are captured by\n-                // `final_slice`.\n-                let smaller_lengths = (self.arity()..final_slice.arity()).map(FixedLen);\n-                smaller_lengths\n-                    .map(|kind| Slice::new(self.array_len, kind))\n-                    .chain(Some(final_slice))\n-                    .map(Slice)\n-                    .collect()\n-            }\n+            Some(len) if self.max_slice.arity() >= len => self.max_slice = FixedLen(len),\n+            _ => {}\n         }\n     }\n \n-    /// See `Constructor::is_covered_by`\n-    fn is_covered_by(self, other: Self) -> bool {\n-        other.kind.covers_length(self.arity())\n+    /// Iterate over the partition of this slice.\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Slice> + Captures<'a> {\n+        let smaller_lengths = match self.array_len {\n+            // The only admissible fixed-length slice is one of the array size. Whether `max_slice`\n+            // is fixed-length or variable-length, it will be the only relevant slice to output\n+            // here.\n+            Some(_) => (0..0), // empty range\n+            // We cover all arities in the range `(self.arity..infinity)`. We split that range into\n+            // two: lengths smaller than `max_slice.arity()` are treated independently as\n+            // fixed-lengths slices, and lengths above are captured by `max_slice`.\n+            None => self.arity..self.max_slice.arity(),\n+        };\n+        smaller_lengths\n+            .map(FixedLen)\n+            .chain(once(self.max_slice))\n+            .map(move |kind| Slice::new(self.array_len, kind))\n     }\n }\n \n@@ -546,6 +607,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively. Also used\n     /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n     NonExhaustive,\n+    /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n+    /// for [`SplitWildcard`].\n+    Missing,\n     /// Wildcard pattern.\n     Wildcard,\n }\n@@ -652,48 +716,41 @@ impl<'tcx> Constructor<'tcx> {\n     /// This function may discard some irrelevant constructors if this preserves behavior and\n     /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n     /// matrix, unless all of them are.\n-    ///\n-    /// `hir_id` is `None` when we're evaluating the wildcard pattern. In that case we do not want\n-    /// to lint for overlapping ranges.\n-    pub(super) fn split<'p>(\n+    pub(super) fn split<'a>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        hir_id: Option<HirId>,\n-    ) -> SmallVec<[Self; 1]> {\n-        debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n+    ) -> SmallVec<[Self; 1]>\n+    where\n+        'tcx: 'a,\n+    {\n+        debug!(\"Constructor::split({:#?})\", self);\n \n         match self {\n-            Wildcard => Constructor::split_wildcard(pcx),\n+            Wildcard => {\n+                let mut split_wildcard = SplitWildcard::new(pcx);\n+                split_wildcard.split(pcx, ctors);\n+                split_wildcard.into_ctors(pcx)\n+            }\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n-            IntRange(ctor_range) if !ctor_range.is_singleton() => ctor_range.split(pcx, hir_id),\n-            Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(pcx),\n+            IntRange(ctor_range) if !ctor_range.is_singleton() => {\n+                let mut split_range = SplitIntRange::new(ctor_range.clone());\n+                let int_ranges = ctors.filter_map(|ctor| ctor.as_int_range());\n+                split_range.split(int_ranges.cloned());\n+                split_range.iter().map(IntRange).collect()\n+            }\n+            &Slice(Slice { kind: VarLen(self_prefix, self_suffix), array_len }) => {\n+                let mut split_self = SplitVarLenSlice::new(self_prefix, self_suffix, array_len);\n+                let slices = ctors.filter_map(|c| c.as_slice()).map(|s| s.kind);\n+                split_self.split(slices);\n+                split_self.iter().map(Slice).collect()\n+            }\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n         }\n     }\n \n-    /// For wildcards, there are two groups of constructors: there are the constructors actually\n-    /// present in the matrix (`head_ctors`), and the constructors not present (`missing_ctors`).\n-    /// Two constructors that are not in the matrix will either both be caught (by a wildcard), or\n-    /// both not be caught. Therefore we can keep the missing constructors grouped together.\n-    fn split_wildcard<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n-        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n-        // current column. We only fully construct them on-demand, because they're rarely used and\n-        // can be big.\n-        let missing_ctors = MissingConstructors::new(pcx);\n-        if missing_ctors.is_empty(pcx) {\n-            // All the constructors are present in the matrix, so we just go through them all.\n-            // We must also split them first.\n-            missing_ctors.all_ctors\n-        } else {\n-            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n-            // which will stand for those constructors that are missing, and behaves like any of\n-            // them.\n-            smallvec![Wildcard]\n-        }\n-    }\n-\n     /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n     /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n@@ -704,8 +761,8 @@ impl<'tcx> Constructor<'tcx> {\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n-            // Wildcards are only covered by wildcards\n-            (Wildcard, _) => false,\n+            // The missing ctors are not covered by anything in the matrix except wildcards.\n+            (Missing | Wildcard, _) => false,\n \n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n@@ -778,247 +835,253 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n                 span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n     }\n }\n \n-/// This determines the set of all possible constructors of a pattern matching\n-/// values of type `left_ty`. For vectors, this would normally be an infinite set\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n+/// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n+/// at the top of the file.\n ///\n-/// We make sure to omit constructors that are statically impossible. E.g., for\n-/// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n-/// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n-/// `cx.is_uninhabited()`).\n-fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tcx>> {\n-    debug!(\"all_constructors({:?})\", pcx.ty);\n-    let cx = pcx.cx;\n-    let make_range = |start, end| {\n-        IntRange(\n-            // `unwrap()` is ok because we know the type is an integer.\n-            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n-        )\n-    };\n-    match pcx.ty.kind() {\n-        ty::Bool => vec![make_range(0, 1)],\n-        ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n-            let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n-            } else {\n-                vec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n-            }\n-        }\n-        // Treat arrays of a constant but unknown length like slices.\n-        ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n-            let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n-            vec![Slice(Slice::new(None, kind))]\n-        }\n-        ty::Adt(def, substs) if def.is_enum() => {\n-            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n-            // additional \"unknown\" constructor.\n-            // There is no point in enumerating all possible variants, because the user can't\n-            // actually match against them all themselves. So we always return only the fictitious\n-            // constructor.\n-            // E.g., in an example like:\n-            //\n-            // ```\n-            //     let err: io::ErrorKind = ...;\n-            //     match err {\n-            //         io::ErrorKind::NotFound => {},\n-            //     }\n-            // ```\n-            //\n-            // we don't want to show every possible IO error, but instead have only `_` as the\n-            // witness.\n-            let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n-\n-            // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n-            // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n-            // exception is if the pattern is at the top level, because we want empty matches to be\n-            // considered exhaustive.\n-            let is_secretly_empty = def.variants.is_empty()\n-                && !cx.tcx.features().exhaustive_patterns\n-                && !pcx.is_top_level;\n-\n-            if is_secretly_empty || is_declared_nonexhaustive {\n-                vec![NonExhaustive]\n-            } else if cx.tcx.features().exhaustive_patterns {\n-                // If `exhaustive_patterns` is enabled, we exclude variants known to be\n-                // uninhabited.\n-                def.variants\n-                    .iter()\n-                    .filter(|v| {\n-                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n-                            .contains(cx.tcx, cx.module)\n-                    })\n-                    .map(|v| Variant(v.def_id))\n-                    .collect()\n-            } else {\n-                def.variants.iter().map(|v| Variant(v.def_id)).collect()\n-            }\n-        }\n-        ty::Char => {\n-            vec![\n-                // The valid Unicode Scalar Value ranges.\n-                make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n-                make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n-            ]\n-        }\n-        ty::Int(_) | ty::Uint(_)\n-            if pcx.ty.is_ptr_sized_integral()\n-                && !cx.tcx.features().precise_pointer_size_matching =>\n-        {\n-            // `usize`/`isize` are not allowed to be matched exhaustively unless the\n-            // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n-            // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n-            vec![NonExhaustive]\n-        }\n-        &ty::Int(ity) => {\n-            let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n-            let min = 1u128 << (bits - 1);\n-            let max = min - 1;\n-            vec![make_range(min, max)]\n-        }\n-        &ty::Uint(uty) => {\n-            let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n-            let max = size.truncate(u128::MAX);\n-            vec![make_range(0, max)]\n-        }\n-        // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n-        // expose its emptiness. The exception is if the pattern is at the top level, because we\n-        // want empty matches to be considered exhaustive.\n-        ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n-            vec![NonExhaustive]\n-        }\n-        ty::Never => vec![],\n-        _ if cx.is_uninhabited(pcx.ty) => vec![],\n-        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n-        // This type is one for which we cannot list constructors, like `str` or `f64`.\n-        _ => vec![NonExhaustive],\n-    }\n-}\n-\n-// A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+/// A constructor that is not present in the matrix rows will only be covered by the rows that have\n+/// wildcards. Thus we can group all of those constructors together; we call them \"missing\n+/// constructors\". Splitting a wildcard would therefore list all present constructors individually\n+/// (or grouped if they are integers or slices), and then all missing constructors together as a\n+/// group.\n+///\n+/// However we can go further: since any constructor will match the wildcard rows, and having more\n+/// rows can only reduce the amount of usefulness witnesses, we can skip the present constructors\n+/// and only try the missing ones.\n+/// This will not preserve the whole list of witnesses, but will preserve whether the list is empty\n+/// or not. In fact this is quite natural from the point of view of diagnostics too. This is done\n+/// in `to_ctors`: in some cases we only return `Missing`.\n #[derive(Debug)]\n-pub(super) struct MissingConstructors<'tcx> {\n+pub(super) struct SplitWildcard<'tcx> {\n+    /// Constructors seen in the matrix.\n+    matrix_ctors: Vec<Constructor<'tcx>>,\n+    /// All the constructors for this type\n     all_ctors: SmallVec<[Constructor<'tcx>; 1]>,\n-    used_ctors: Vec<Constructor<'tcx>>,\n }\n \n-impl<'tcx> MissingConstructors<'tcx> {\n+impl<'tcx> SplitWildcard<'tcx> {\n     pub(super) fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n-        let used_ctors: Vec<Constructor<'_>> =\n-            pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n-        // Since `all_ctors` never contains wildcards, this won't recurse further.\n-        let all_ctors =\n-            all_constructors(pcx).into_iter().flat_map(|ctor| ctor.split(pcx, None)).collect();\n+        debug!(\"SplitWildcard::new({:?})\", pcx.ty);\n+        let cx = pcx.cx;\n+        let make_range = |start, end| {\n+            IntRange(\n+                // `unwrap()` is ok because we know the type is an integer.\n+                IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n+            )\n+        };\n+        // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n+        // arrays and slices we use ranges and variable-length slices when appropriate.\n+        //\n+        // If the `exhaustive_patterns` feature is enabled, we make sure to omit constructors that\n+        // are statically impossible. E.g., for `Option<!>`, we do not include `Some(_)` in the\n+        // returned list of constructors.\n+        // Invariant: this is empty if and only if the type is uninhabited (as determined by\n+        // `cx.is_uninhabited()`).\n+        let all_ctors = match pcx.ty.kind() {\n+            ty::Bool => smallvec![make_range(0, 1)],\n+            ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n+                let len = len.eval_usize(cx.tcx, cx.param_env);\n+                if len != 0 && cx.is_uninhabited(sub_ty) {\n+                    smallvec![]\n+                } else {\n+                    smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n+                }\n+            }\n+            // Treat arrays of a constant but unknown length like slices.\n+            ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n+                let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+                smallvec![Slice(Slice::new(None, kind))]\n+            }\n+            ty::Adt(def, substs) if def.is_enum() => {\n+                // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+                // additional \"unknown\" constructor.\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them all themselves. So we always return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                //\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                //\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n+\n+                // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n+                // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n+                // exception is if the pattern is at the top level, because we want empty matches to be\n+                // considered exhaustive.\n+                let is_secretly_empty = def.variants.is_empty()\n+                    && !cx.tcx.features().exhaustive_patterns\n+                    && !pcx.is_top_level;\n+\n+                if is_secretly_empty || is_declared_nonexhaustive {\n+                    smallvec![NonExhaustive]\n+                } else if cx.tcx.features().exhaustive_patterns {\n+                    // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                    // uninhabited.\n+                    def.variants\n+                        .iter()\n+                        .filter(|v| {\n+                            !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n+                                .contains(cx.tcx, cx.module)\n+                        })\n+                        .map(|v| Variant(v.def_id))\n+                        .collect()\n+                } else {\n+                    def.variants.iter().map(|v| Variant(v.def_id)).collect()\n+                }\n+            }\n+            ty::Char => {\n+                smallvec![\n+                    // The valid Unicode Scalar Value ranges.\n+                    make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n+                    make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n+                ]\n+            }\n+            ty::Int(_) | ty::Uint(_)\n+                if pcx.ty.is_ptr_sized_integral()\n+                    && !cx.tcx.features().precise_pointer_size_matching =>\n+            {\n+                // `usize`/`isize` are not allowed to be matched exhaustively unless the\n+                // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n+                // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n+                smallvec![NonExhaustive]\n+            }\n+            &ty::Int(ity) => {\n+                let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n+                let min = 1u128 << (bits - 1);\n+                let max = min - 1;\n+                smallvec![make_range(min, max)]\n+            }\n+            &ty::Uint(uty) => {\n+                let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n+                let max = size.truncate(u128::MAX);\n+                smallvec![make_range(0, max)]\n+            }\n+            // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n+            // expose its emptiness. The exception is if the pattern is at the top level, because we\n+            // want empty matches to be considered exhaustive.\n+            ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n+                smallvec![NonExhaustive]\n+            }\n+            ty::Never => smallvec![],\n+            _ if cx.is_uninhabited(pcx.ty) => smallvec![],\n+            ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => smallvec![Single],\n+            // This type is one for which we cannot list constructors, like `str` or `f64`.\n+            _ => smallvec![NonExhaustive],\n+        };\n+        SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n+    }\n \n-        MissingConstructors { all_ctors, used_ctors }\n+    /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n+    /// do what you want.\n+    pub(super) fn split<'a>(\n+        &mut self,\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n+    ) where\n+        'tcx: 'a,\n+    {\n+        // Since `all_ctors` never contains wildcards, this won't recurse further.\n+        self.all_ctors =\n+            self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx, ctors.clone())).collect();\n+        self.matrix_ctors = ctors.filter(|c| !c.is_wildcard()).cloned().collect();\n     }\n \n-    fn is_empty<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> bool {\n-        self.iter(pcx).next().is_none()\n+    /// Whether there are any value constructors for this type that are not present in the matrix.\n+    fn any_missing(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+        self.iter_missing(pcx).next().is_some()\n     }\n \n-    /// Iterate over all_ctors \\ used_ctors\n-    fn iter<'a, 'p>(\n+    /// Iterate over the constructors for this type that are not present in the matrix.\n+    pub(super) fn iter_missing<'a, 'p>(\n         &'a self,\n         pcx: PatCtxt<'a, 'p, 'tcx>,\n     ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n-        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.used_ctors))\n+        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n     }\n \n-    /// List the patterns corresponding to the missing constructors. In some cases, instead of\n-    /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    pub(super) fn report_patterns<'p>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-    ) -> SmallVec<[Pat<'tcx>; 1]> {\n-        // There are 2 ways we can report a witness here.\n-        // Commonly, we can report all the \"free\"\n-        // constructors as witnesses, e.g., if we have:\n-        //\n-        // ```\n-        //     enum Direction { N, S, E, W }\n-        //     let Direction::N = ...;\n-        // ```\n-        //\n-        // we can report 3 witnesses: `S`, `E`, and `W`.\n-        //\n-        // However, there is a case where we don't want\n-        // to do this and instead report a single `_` witness:\n-        // if the user didn't actually specify a constructor\n-        // in this arm, e.g., in\n-        //\n-        // ```\n-        //     let x: (Direction, Direction, bool) = ...;\n-        //     let (_, _, false) = x;\n-        // ```\n-        //\n-        // we don't want to show all 16 possible witnesses\n-        // `(<direction-1>, <direction-2>, true)` - we are\n-        // satisfied with `(_, _, true)`. In this case,\n-        // `used_ctors` is empty.\n-        // The exception is: if we are at the top-level, for example in an empty match, we\n-        // sometimes prefer reporting the list of constructors instead of just `_`.\n-        let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n-        if self.used_ctors.is_empty() && !report_when_all_missing {\n-            // All constructors are unused. Report only a wildcard\n-            // rather than each individual constructor.\n-            smallvec![Pat::wildcard_from_ty(pcx.ty)]\n-        } else {\n-            // Construct for each missing constructor a \"wild\" version of this\n-            // constructor, that matches everything that can be built with\n-            // it. For example, if `ctor` is a `Constructor::Variant` for\n-            // `Option::Some`, we get the pattern `Some(_)`.\n-            self.iter(pcx)\n-                .map(|missing_ctor| Fields::wildcards(pcx, &missing_ctor).apply(pcx, missing_ctor))\n-                .collect()\n+    /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n+    /// top of the file, if any constructors are missing we can ignore the present ones.\n+    fn into_ctors(self, pcx: PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n+        if self.any_missing(pcx) {\n+            // Some constructors are missing, thus we can specialize with the special `Missing`\n+            // constructor, which stands for those constructors that are not seen in the matrix,\n+            // and matches the same rows as any of them (namely the wildcard rows). See the top of\n+            // the file for details.\n+            // However, when all constructors are missing we can also specialize with the full\n+            // `Wildcard` constructor. The difference will depend on what we want in diagnostics.\n+\n+            // If some constructors are missing, we typically want to report those constructors,\n+            // e.g.:\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, if the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses `(<direction-1>, <direction-2>,\n+            // true)` - we are satisfied with `(_, _, true)`. So if all constructors are missing we\n+            // prefer to report just a wildcard `_`.\n+            //\n+            // The exception is: if we are at the top-level, for example in an empty match, we\n+            // sometimes prefer reporting the list of constructors instead of just `_`.\n+            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n+            let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n+                Missing\n+            } else {\n+                Wildcard\n+            };\n+            return smallvec![ctor];\n         }\n+\n+        // All the constructors are present in the matrix, so we just go through them all.\n+        self.all_ctors\n     }\n }\n \n /// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n-/// `Fields` struct. This struct represents such a potentially-hidden field. When a field is hidden\n-/// we still keep its type around.\n+/// `Fields` struct. This struct represents such a potentially-hidden field.\n #[derive(Debug, Copy, Clone)]\n pub(super) enum FilteredField<'p, 'tcx> {\n     Kept(&'p Pat<'tcx>),\n-    Hidden(Ty<'tcx>),\n+    Hidden,\n }\n \n impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n     fn kept(self) -> Option<&'p Pat<'tcx>> {\n         match self {\n             FilteredField::Kept(p) => Some(p),\n-            FilteredField::Hidden(_) => None,\n-        }\n-    }\n-\n-    fn to_pattern(self) -> Pat<'tcx> {\n-        match self {\n-            FilteredField::Kept(p) => p.clone(),\n-            FilteredField::Hidden(ty) => Pat::wildcard_from_ty(ty),\n+            FilteredField::Hidden => None,\n         }\n     }\n }\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+/// This is constructed from a constructor using [`Fields::wildcards()`].\n ///\n /// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n-/// uninhabited. For that, we filter these fields out of the matrix. This is subtle because we\n-/// still need to have those fields back when going to/from a `Pat`. Most of this is handled\n-/// automatically in `Fields`, but when constructing or deconstructing `Fields` you need to be\n-/// careful. As a rule, when going to/from the matrix, use the filtered field list; when going\n-/// to/from `Pat`, use the full field list.\n-/// This filtering is uncommon in practice, because uninhabited fields are rarely used, so we avoid\n-/// it when possible to preserve performance.\n+/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n+/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n+/// so we avoid it when possible to preserve performance.\n #[derive(Debug, Clone)]\n pub(super) enum Fields<'p, 'tcx> {\n     /// Lists of patterns that don't contain any filtered fields.\n@@ -1027,21 +1090,19 @@ pub(super) enum Fields<'p, 'tcx> {\n     /// have not measured if it really made a difference.\n     Slice(&'p [Pat<'tcx>]),\n     Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden. `kept_count` caches the number of\n-    /// non-hidden fields.\n+    /// Patterns where some of the fields need to be hidden. For all intents and purposes we only\n+    /// care about the non-hidden fields. We need to keep the real field index for those fields;\n+    /// we're morally storing a `Vec<(usize, &Pat)>` but what we do is more convenient.\n+    /// `len` counts the number of non-hidden fields\n     Filtered {\n         fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n-        kept_count: usize,\n+        len: usize,\n     },\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n-    fn empty() -> Self {\n-        Fields::Slice(&[])\n-    }\n-\n-    /// Construct a new `Fields` from the given pattern. Must not be used if the pattern is a field\n-    /// of a struct/tuple/variant.\n+    /// Internal use. Use `Fields::wildcards()` instead.\n+    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n     fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n@@ -1086,7 +1147,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         if has_no_hidden_fields {\n                             Fields::wildcards_from_tys(cx, field_tys)\n                         } else {\n-                            let mut kept_count = 0;\n+                            let mut len = 0;\n                             let fields = variant\n                                 .fields\n                                 .iter()\n@@ -1101,14 +1162,14 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                                     // order not to reveal the uninhabitedness of the whole\n                                     // variant.\n                                     if is_uninhabited && (!is_visible || is_non_exhaustive) {\n-                                        FilteredField::Hidden(ty)\n+                                        FilteredField::Hidden\n                                     } else {\n-                                        kept_count += 1;\n+                                        len += 1;\n                                         FilteredField::Kept(wildcard_from_ty(ty))\n                                     }\n                                 })\n                                 .collect();\n-                            Fields::Filtered { fields, kept_count }\n+                            Fields::Filtered { fields, len }\n                         }\n                     }\n                 }\n@@ -1121,9 +1182,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Wildcard => {\n-                Fields::empty()\n-            }\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n+            | Wildcard => Fields::Slice(&[]),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1145,14 +1205,16 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     /// `self`: `[false]`\n     /// returns `Some(false)`\n     pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n-        let mut subpatterns = self.all_patterns();\n+        let subpatterns_and_indices = self.patterns_and_indices();\n+        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p).cloned();\n \n         let pat = match ctor {\n             Single | Variant(_) => match pcx.ty.kind() {\n                 ty::Adt(..) | ty::Tuple(..) => {\n-                    let subpatterns = subpatterns\n-                        .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                    // We want the real indices here.\n+                    let subpatterns = subpatterns_and_indices\n+                        .iter()\n+                        .map(|&(field, p)| FieldPat { field, pattern: p.clone() })\n                         .collect();\n \n                     if let ty::Adt(adt, substs) = pcx.ty.kind() {\n@@ -1207,48 +1269,52 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n             NonExhaustive => PatKind::Wild,\n+            Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n-            Wildcard => bug!(\n-                \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n+            Missing => bug!(\n+                \"trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n             ),\n         };\n \n         Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Returns the number of patterns from the viewpoint of match-checking, i.e. excluding hidden\n-    /// fields. This is what we want in most cases in this file, the only exception being\n-    /// conversion to/from `Pat`.\n+    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n+    /// construct `self`.\n     pub(super) fn len(&self) -> usize {\n         match self {\n             Fields::Slice(pats) => pats.len(),\n             Fields::Vec(pats) => pats.len(),\n-            Fields::Filtered { kept_count, .. } => *kept_count,\n+            Fields::Filtered { len, .. } => *len,\n         }\n     }\n \n-    /// Returns the complete list of patterns, including hidden fields.\n-    fn all_patterns(self) -> impl Iterator<Item = Pat<'tcx>> {\n-        let pats: SmallVec<[_; 2]> = match self {\n-            Fields::Slice(pats) => pats.iter().cloned().collect(),\n-            Fields::Vec(pats) => pats.into_iter().cloned().collect(),\n+    /// Returns the list of patterns along with the corresponding field indices.\n+    fn patterns_and_indices(&self) -> SmallVec<[(Field, &'p Pat<'tcx>); 2]> {\n+        match self {\n+            Fields::Slice(pats) => {\n+                pats.iter().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n+            }\n+            Fields::Vec(pats) => {\n+                pats.iter().copied().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n+            }\n             Fields::Filtered { fields, .. } => {\n-                // We don't skip any fields here.\n-                fields.into_iter().map(|p| p.to_pattern()).collect()\n+                // Indices must be relative to the full list of patterns\n+                fields\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(i, p)| Some((Field::new(i), p.kept()?)))\n+                    .collect()\n             }\n-        };\n-        pats.into_iter()\n+        }\n     }\n \n-    /// Returns the filtered list of patterns, not including hidden fields.\n-    pub(super) fn filtered_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n+    /// Returns the list of patterns.\n+    pub(super) fn into_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n         match self {\n             Fields::Slice(pats) => pats.iter().collect(),\n             Fields::Vec(pats) => pats,\n-            Fields::Filtered { fields, .. } => {\n-                // We skip hidden fields here\n-                fields.into_iter().filter_map(|p| p.kept()).collect()\n-            }\n+            Fields::Filtered { fields, .. } => fields.iter().filter_map(|p| p.kept()).collect(),\n         }\n     }\n \n@@ -1264,10 +1330,10 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     }\n \n     /// Overrides some of the fields with the provided patterns. This is used when a pattern\n-    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start with a\n-    /// `Fields` that is just one wildcard per field of the `Foo` struct, and override the entry\n-    /// corresponding to `field1` with the pattern `Some(_)`. This is also used for slice patterns\n-    /// for the same reason.\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n+    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n+    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n+    /// patterns for the same reason.\n     fn replace_fields_indexed(\n         &self,\n         new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n@@ -1295,8 +1361,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         fields\n     }\n \n-    /// Replaces contained fields with the given filtered list of patterns, e.g. taken from the\n-    /// matrix. There must be `len()` patterns in `pats`.\n+    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n+    /// in `pats`.\n     pub(super) fn replace_fields(\n         &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1305,7 +1371,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n \n         match self {\n-            Fields::Filtered { fields, kept_count } => {\n+            Fields::Filtered { fields, len } => {\n                 let mut pats = pats.iter();\n                 let mut fields = fields.clone();\n                 for f in &mut fields {\n@@ -1314,7 +1380,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         *p = pats.next().unwrap();\n                     }\n                 }\n-                Fields::Filtered { fields, kept_count: *kept_count }\n+                Fields::Filtered { fields, len: *len }\n             }\n             _ => Fields::Slice(pats),\n         }"}, {"sha": "83fee380ccce7196038d4e1d438596990112cb9f", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 465, "deletions": 395, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,306 +12,282 @@\n //!\n //! -----\n //!\n-//! This file includes the logic for exhaustiveness and usefulness checking for\n-//! pattern-matching. Specifically, given a list of patterns for a type, we can\n-//! tell whether:\n-//! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n-//! (b) each pattern is necessary (usefulness)\n-//!\n-//! The algorithm implemented here is a modified version of the one described in\n-//! [this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html).\n-//! However, to save future implementors from reading the original paper, we\n-//! summarise the algorithm here to hopefully save time and be a little clearer\n-//! (without being so rigorous).\n-//!\n-//! # Premise\n-//!\n-//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-//! uncovered values of the type).\n-//!\n-//! If we have this predicate, then we can easily compute both exhaustiveness of an\n-//! entire set of patterns and the individual usefulness of each one.\n-//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-//! match doesn't increase the number of values we're matching)\n-//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-//! pattern to those that have come before it doesn't increase the number of values\n-//! we're matching).\n-//!\n-//! # Core concept\n-//!\n-//! The idea that powers everything that is done in this file is the following: a value is made\n-//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n-//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n-//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n-//!\n-//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n-//! arguments. This is part of what makes constructors so general: we will consider plain values\n-//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n-//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n-//! made up from a tree of constructors, each having a given number of children. For example:\n-//! `(None, Ok(0))` is made from 4 different constructors.\n-//!\n-//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n-//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n-//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n-//! wildcard `_` captures all values of the given type starting with any of the constructors for\n-//! that type.\n-//!\n-//! We use this to compute whether different patterns might capture a same value. Do the patterns\n-//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n-//! captures only values starting with the `Ok` constructor and the second only values starting\n-//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n-//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n-//! `Some` constructor and continue asking the question. This is the main idea behind the\n-//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n-//! figure out if some new pattern might capture a value that hadn't been captured by previous\n-//! patterns.\n-//!\n-//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n-//! Most of the complexity of this file resides in transforming between patterns and\n-//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n-//!\n-//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n-//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n-//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n-//!\n-//!\n-//! # Algorithm\n-//!\n-//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n-//! adding a new pattern `p` will cover previously-uncovered values of the type.\n-//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n-//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-//! new pattern `p`.\n-//!\n-//! For example, say we have the following:\n+//! This file includes the logic for exhaustiveness and reachability checking for pattern-matching.\n+//! Specifically, given a list of patterns for a type, we can tell whether:\n+//! (a) each pattern is reachable (reachability)\n+//! (b) the patterns cover every possible value for the type (exhaustiveness)\n //!\n+//! The algorithm implemented here is a modified version of the one described in [this\n+//! paper](http://moscova.inria.fr/~maranget/papers/warn/index.html). We have however generalized\n+//! it to accommodate the variety of patterns that Rust supports. We thus explain our version here,\n+//! without being as rigorous.\n+//!\n+//!\n+//! # Summary\n+//!\n+//! The core of the algorithm is the notion of \"usefulness\". A pattern `q` is said to be *useful*\n+//! relative to another pattern `p` of the same type if there is a value that is matched by `q` and\n+//! not matched by `p`. This generalizes to many `p`s: `q` is useful w.r.t. a list of patterns\n+//! `p_1 .. p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n+//! `usefulness(p_1 .. p_n, q)` for a function that returns a list of such values. The aim of this\n+//! file is to compute it efficiently.\n+//!\n+//! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n+//! is useful w.r.t. the patterns above it:\n+//! ```rust\n+//! match x {\n+//!     Some(_) => ...,\n+//!     None => ..., // reachable: `None` is matched by this but not the branch above\n+//!     Some(0) => ..., // unreachable: all the values this matches are already matched by\n+//!                     // `Some(_)` above\n+//! }\n //! ```\n-//! // x: (Option<bool>, Result<()>)\n+//!\n+//! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n+//! pattern is _not_ useful w.r.t. the patterns in the match. The values returned by `usefulness`\n+//! are used to tell the user which values are missing.\n+//! ```rust\n //! match x {\n-//!     (Some(true), _) => {}\n-//!     (None, Err(())) => {}\n-//!     (None, Err(_)) => {}\n+//!     Some(0) => ...,\n+//!     None => ...,\n+//!     // not exhaustive: `_` is useful because it matches `Some(1)`\n //! }\n //! ```\n //!\n-//! Here, the matrix `P` starts as:\n+//! The entrypoint of this file is the [`compute_match_usefulness`] function, which computes\n+//! reachability for each match branch and exhaustiveness for the whole match.\n //!\n-//! ```\n-//! [\n-//!     [(Some(true), _)],\n-//!     [(None, Err(()))],\n-//!     [(None, Err(_))],\n-//! ]\n-//! ```\n //!\n-//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-//! all the values it covers are already covered by row 2.\n-//!\n-//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-//! To match the paper, the top of the stack is at the beginning / on the left.\n-//!\n-//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!\n-//! 1. We can pop a given constructor off the top of a stack. This operation is called\n-//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!    `None`) and `p` a pattern-stack.\n-//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!    Otherwise the pattern-stack is discarded.\n-//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!    discards the others.\n-//!\n-//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!    nothing back.\n-//!\n-//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!    on top of the stack, and we have four cases:\n-//!\n-//!      1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!           push onto the stack the arguments of this constructor, and return the result:\n-//!              `r_1, .., r_a, p_2, .., p_n`\n-//!\n-//!      1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!           return nothing.\n-//!\n-//!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!              arguments (its arity), and return the resulting stack:\n-//!                 `_, .., _, p_2, .., p_n`\n-//!\n-//!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!              stack:\n-//!                 - `S(c, (r_1, p_2, .., p_n))`\n-//!                 - `S(c, (r_2, p_2, .., p_n))`\n-//!\n-//! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n-//!    a pattern-stack. Note: the paper calls this `D(p)`.\n-//!    This is used when we know there are missing constructor cases, but there might be\n-//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!    all its *other* components.\n-//!\n-//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!    and we have three cases:\n-//!         2.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!         2.2. `p_1 = _`. We return the rest of the stack:\n-//!                 p_2, .., p_n\n-//!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!           stack.\n-//!                 - `S(_, (r_1, p_2, .., p_n))`\n-//!                 - `S(_, (r_2, p_2, .., p_n))`\n-//!\n-//! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//! exhaustive integer matching rules, so they're written here for posterity.\n-//!\n-//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-//!\n-//!\n-//! The algorithm for computing `U`\n-//! -------------------------------\n-//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-//! That means we're going to check the components from left-to-right, so the algorithm\n-//! operates principally on the first component of the matrix and new pattern-stack `p`.\n-//! This algorithm is realised in the `is_useful` function.\n-//!\n-//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n-//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-//!       then `U(P, p)` is false.\n-//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-//!\n-//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n-//!                  [which may then be expanded into further columns later])\n-//! We're going to match on the top of the new pattern-stack, `p_1`.\n-//!     - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//! Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//! we ignore all the patterns in the first column of `P` that involve other constructors.\n-//! This is where `S(c, P)` comes in:\n-//! `U(P, p) := U(S(c, P), S(c, p))`\n-//!\n-//! For example, if `P` is:\n+//! # Constructors and fields\n+//!\n+//! Note: we will often abbreviate \"constructor\" as \"ctor\".\n+//!\n+//! The idea that powers everything that is done in this file is the following: a (matcheable)\n+//! value is made from a constructor applied to a number of subvalues. Examples of constructors are\n+//! `Some`, `None`, `(,)` (the 2-tuple constructor), `Foo {..}` (the constructor for a struct\n+//! `Foo`), and `2` (the constructor for the number `2`). This is natural when we think of\n+//! pattern-matching, and this is the basis for what follows.\n+//!\n+//! Some of the ctors listed above might feel weird: `None` and `2` don't take any arguments.\n+//! That's ok: those are ctors that take a list of 0 arguments; they are the simplest case of\n+//! ctors. We treat `2` as a ctor because `u64` and other number types behave exactly like a huge\n+//! `enum`, with one variant for each number. This allows us to see any matcheable value as made up\n+//! from a tree of ctors, each having a set number of children. For example: `Foo { bar: None,\n+//! baz: Ok(0) }` is made from 4 different ctors, namely `Foo{..}`, `None`, `Ok` and `0`.\n+//!\n+//! This idea can be extended to patterns: they are also made from constructors applied to fields.\n+//! A pattern for a given type is allowed to use all the ctors for values of that type (which we\n+//! call \"value constructors\"), but there are also pattern-only ctors. The most important one is\n+//! the wildcard (`_`), and the others are integer ranges (`0..=10`), variable-length slices (`[x,\n+//! ..]`), and or-patterns (`Ok(0) | Err(_)`). Examples of valid patterns are `42`, `Some(_)`, `Foo\n+//! { bar: Some(0) | None, baz: _ }`. Note that a binder in a pattern (e.g. `Some(x)`) matches the\n+//! same values as a wildcard (e.g. `Some(_)`), so we treat both as wildcards.\n+//!\n+//! From this deconstruction we can compute whether a given value matches a given pattern; we\n+//! simply look at ctors one at a time. Given a pattern `p` and a value `v`, we want to compute\n+//! `matches!(v, p)`. It's mostly straightforward: we compare the head ctors and when they match\n+//! we compare their fields recursively. A few representative examples:\n+//!\n+//! - `matches!(v, _) := true`\n+//! - `matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Foo { bar: v0, baz: v1 }, Foo { bar: p0, baz: p1 }) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)`\n+//! - `matches!(Ok(v0), Err(p0)) := false` (incompatible variants)\n+//! - `matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)`\n+//! - `matches!([v0], [p0, .., p1]) := false` (incompatible lengths)\n+//! - `matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) && matches!(v2, p1)`\n+//! - `matches!(v, p0 | p1) := matches!(v, p0) || matches!(v, p1)`\n+//!\n+//! Constructors, fields and relevant operations are defined in the [`super::deconstruct_pat`] module.\n+//!\n+//! Note: this constructors/fields distinction may not straightforwardly apply to every Rust type.\n+//! For example a value of type `Rc<u64>` can't be deconstructed that way, and `&str` has an\n+//! infinitude of constructors. There are also subtleties with visibility of fields and\n+//! uninhabitedness and various other things. The constructors idea can be extended to handle most\n+//! of these subtleties though; caveats are documented where relevant throughout the code.\n+//!\n+//! Whether constructors cover each other is computed by [`Constructor::is_covered_by`].\n+//!\n //!\n+//! # Specialization\n+//!\n+//! Recall that we wish to compute `usefulness(p_1 .. p_n, q)`: given a list of patterns `p_1 ..\n+//! p_n` and a pattern `q`, all of the same type, we want to find a list of values (called\n+//! \"witnesses\") that are matched by `q` and by none of the `p_i`. We obviously don't just\n+//! enumerate all possible values. From the discussion above we see that we can proceed\n+//! ctor-by-ctor: for each value ctor of the given type, we ask \"is there a value that starts with\n+//! this constructor and matches `q` and none of the `p_i`?\". As we saw above, there's a lot we can\n+//! say from knowing only the first constructor of our candidate value.\n+//!\n+//! Let's take the following example:\n //! ```\n-//! [\n-//!     [Some(true), _],\n-//!     [None, 0],\n-//! ]\n+//! match x {\n+//!     Enum::Variant1(_) => {} // `p1`\n+//!     Enum::Variant2(None, 0) => {} // `p2`\n+//!     Enum::Variant2(Some(_), 0) => {} // `q`\n+//! }\n //! ```\n //!\n-//! and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n-//! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//! arguments of `Some` to know whether some new value is covered. So we compute\n-//! `U([[true, _]], [false, 0])`.\n+//! We can easily see that if our candidate value `v` starts with `Variant1` it will not match `q`.\n+//! If `v = Variant2(v0, v1)` however, whether or not it matches `p2` and `q` will depend on `v0`\n+//! and `v1`. In fact, such a `v` will be a witness of usefulness of `q` exactly when the tuple\n+//! `(v0, v1)` is a witness of usefulness of `q'` in the following reduced match:\n //!\n-//!   - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-//! component of the rows of `P`:\n-//!   + If there are some constructors that aren't present, then we might think that the\n-//! wildcard `_` is useful, since it covers those constructors that weren't covered\n-//! before.\n-//! That's almost correct, but only works if there were no wildcards in those first\n-//! components. So we need to check that `p` is useful with respect to the rows that\n-//! start with a wildcard, if there are any. This is where `S(_, x)` comes in:\n-//! `U(P, p) := U(S(_, P), S(_, p))`\n+//! ```\n+//! match x {\n+//!     (None, 0) => {} // `p2'`\n+//!     (Some(_), 0) => {} // `q'`\n+//! }\n+//! ```\n //!\n-//! For example, if `P` is:\n+//! This motivates a new step in computing usefulness, that we call _specialization_.\n+//! Specialization consist of filtering a list of patterns for those that match a constructor, and\n+//! then looking into the constructor's fields. This enables usefulness to be computed recursively.\n //!\n+//! Instead of acting on a single pattern in each row, we will consider a list of patterns for each\n+//! row, and we call such a list a _pattern-stack_. The idea is that we will specialize the\n+//! leftmost pattern, which amounts to popping the constructor and pushing its fields, which feels\n+//! like a stack. We note a pattern-stack simply with `[p_1 ... p_n]`.\n+//! Here's a sequence of specializations of a list of pattern-stacks, to illustrate what's\n+//! happening:\n //! ```\n-//! [\n-//!     [_, true, _],\n-//!     [None, false, 1],\n-//! ]\n+//! [Enum::Variant1(_)]\n+//! [Enum::Variant2(None, 0)]\n+//! [Enum::Variant2(Some(_), 0)]\n+//! //==>> specialize with `Variant2`\n+//! [None, 0]\n+//! [Some(_), 0]\n+//! //==>> specialize with `Some`\n+//! [_, 0]\n+//! //==>> specialize with `true` (say the type was `bool`)\n+//! [0]\n+//! //==>> specialize with `0`\n+//! []\n //! ```\n //!\n-//! and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n-//! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//! The function `specialize(c, p)` takes a value constructor `c` and a pattern `p`, and returns 0\n+//! or more pattern-stacks. If `c` does not match the head constructor of `p`, it returns nothing;\n+//! otherwise if returns the fields of the constructor. This only returns more than one\n+//! pattern-stack if `p` has a pattern-only constructor.\n+//!\n+//! - Specializing for the wrong constructor returns nothing\n+//!\n+//!   `specialize(None, Some(p0)) := []`\n+//!\n+//! - Specializing for the correct constructor returns a single row with the fields\n+//!\n+//!   `specialize(Variant1, Variant1(p0, p1, p2)) := [[p0, p1, p2]]`\n+//!\n+//!   `specialize(Foo{..}, Foo { bar: p0, baz: p1 }) := [[p0, p1]]`\n+//!\n+//! - For or-patterns, we specialize each branch and concatenate the results\n+//!\n+//!   `specialize(c, p0 | p1) := specialize(c, p0) ++ specialize(c, p1)`\n+//!\n+//! - We treat the other pattern constructors as if they were a large or-pattern of all the\n+//!   possibilities:\n+//!\n+//!   `specialize(c, _) := specialize(c, Variant1(_) | Variant2(_, _) | ...)`\n+//!\n+//!   `specialize(c, 1..=100) := specialize(c, 1 | ... | 100)`\n+//!\n+//!   `specialize(c, [p0, .., p1]) := specialize(c, [p0, p1] | [p0, _, p1] | [p0, _, _, p1] | ...)`\n //!\n-//!   + Otherwise, all possible constructors (for the relevant type) are present. In this\n-//! case we must check whether the wildcard pattern covers any unmatched value. For\n-//! that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//! possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//! example. The wildcard pattern is useful in this case if it is useful when\n-//! specialized to one of the possible constructors. So we compute:\n-//! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//! - If `c` is a pattern-only constructor, `specialize` is defined on a case-by-case basis. See\n+//!   the discussion about constructor splitting in [`super::deconstruct_pat`].\n //!\n-//! For example, if `P` is:\n //!\n+//! We then extend this function to work with pattern-stacks as input, by acting on the first\n+//! column and keeping the other columns untouched.\n+//!\n+//! Specialization for the whole matrix is done in [`Matrix::specialize_constructor`]. Note that\n+//! or-patterns in the first column are expanded before being stored in the matrix. Specialization\n+//! for a single patstack is done from a combination of [`Constructor::is_covered_by`] and\n+//! [`PatStack::pop_head_constructor`]. The internals of how it's done mostly live in the\n+//! [`Fields`] struct.\n+//!\n+//!\n+//! # Computing usefulness\n+//!\n+//! We now have all we need to compute usefulness. The inputs to usefulness are a list of\n+//! pattern-stacks `p_1 ... p_n` (one per row), and a new pattern_stack `q`. The paper and this\n+//! file calls the list of patstacks a _matrix_. They must all have the same number of columns and\n+//! the patterns in a given column must all have the same type. `usefulness` returns a (possibly\n+//! empty) list of witnesses of usefulness. These witnesses will also be pattern-stacks.\n+//!\n+//! - base case: `n_columns == 0`.\n+//!     Since a pattern-stack functions like a tuple of patterns, an empty one functions like the\n+//!     unit type. Thus `q` is useful iff there are no rows above it, i.e. if `n == 0`.\n+//!\n+//! - inductive case: `n_columns > 0`.\n+//!     We need a way to list the constructors we want to try. We will be more clever in the next\n+//!     section but for now assume we list all value constructors for the type of the first column.\n+//!\n+//!     - for each such ctor `c`:\n+//!\n+//!         - for each `q'` returned by `specialize(c, q)`:\n+//!\n+//!             - we compute `usefulness(specialize(c, p_1) ... specialize(c, p_n), q')`\n+//!\n+//!         - for each witness found, we revert specialization by pushing the constructor `c` on top.\n+//!\n+//!     - We return the concatenation of all the witnesses found, if any.\n+//!\n+//! Example:\n //! ```\n-//! [\n-//!     [Some(true), _],\n-//!     [None, false],\n-//! ]\n+//! [Some(true)] // p_1\n+//! [None] // p_2\n+//! [Some(_)] // q\n+//! //==>> try `None`: `specialize(None, q)` returns nothing\n+//! //==>> try `Some`: `specialize(Some, q)` returns a single row\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `true`: `specialize(true, q')` returns a single row\n+//! [] // p_1''\n+//! [] // q''\n+//! //==>> base case; `n != 0` so `q''` is not useful.\n+//! //==>> go back up a step\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `false`: `specialize(false, q')` returns a single row\n+//! [] // q''\n+//! //==>> base case; `n == 0` so `q''` is useful. We return the single witness `[]`\n+//! witnesses:\n+//! []\n+//! //==>> undo the specialization with `false`\n+//! witnesses:\n+//! [false]\n+//! //==>> undo the specialization with `Some`\n+//! witnesses:\n+//! [Some(false)]\n+//! //==>> we have tried all the constructors. The output is the single witness `[Some(false)]`.\n //! ```\n //!\n-//! and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n-//! components of `P`. We will therefore try popping both constructors in turn: we\n-//! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n-//! [false])` for the `None` constructor. The first case returns true, so we know that\n-//! `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//! before.\n-//!\n-//!   - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//! `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!  || U(P, (r_2, p_2, .., p_n))`\n-//!\n-//! Modifications to the algorithm\n-//! ------------------------------\n-//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n-//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n-//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n-//! accounted for, though.\n-//!\n-//! Exhaustive integer matching\n-//! ---------------------------\n-//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n-//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n-//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n-//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n-//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n-//! through all the inductive step rules above, deriving how the ranges would be treated as\n-//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n-//! There are really only four special cases here:\n-//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n-//!   an OR-pattern.\n-//!     + It turns out that we can simply extend the case for single-value patterns in\n-//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n-//!      constructor.\n-//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n-//!       the pattern range coincide with values in the constructor range, which is precisely\n-//!       intersection.\n-//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n-//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n-//!   we can simply use intersection to test usefulness.\n-//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n-//!   wildcard.\n-//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n-//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n-//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n-//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n-//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n-//!       detail in `Constructor::split`.\n-//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n-//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n-//!       can't span wildcards using ranges).\n+//! This computation is done in [`is_useful`]. In practice we don't care about the list of\n+//! witnesses when computing reachability; we only need to know whether any exist. We do keep the\n+//! witnesses when computing exhaustiveness to report them to the user.\n+//!\n+//!\n+//! # Making usefulness tractable: constructor splitting\n+//!\n+//! We're missing one last detail: which constructors do we list? Naively listing all value\n+//! constructors cannot work for types like `u64` or `&str`, so we need to be more clever. The\n+//! first obvious insight is that we only want to list constructors that are covered by the head\n+//! constructor of `q`. If it's a value constructor, we only try that one. If it's a pattern-only\n+//! constructor, we use the final clever idea for this algorithm: _constructor splitting_, where we\n+//! group together constructors that behave the same.\n+//!\n+//! The details are not necessary to understand this file, so we explain them in\n+//! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n \n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use super::deconstruct_pat::{Constructor, Fields, MissingConstructors};\n+use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::OnceCell;\n \n use rustc_arena::TypedArena;\n@@ -359,8 +335,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n #[derive(Copy, Clone)]\n pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     pub(super) cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    /// Current state of the matrix.\n-    pub(super) matrix: &'a Matrix<'p, 'tcx>,\n     /// Type of the current column under investigation.\n     pub(super) ty: Ty<'tcx>,\n     /// Span of the current pattern under investigation.\n@@ -474,7 +448,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n         let mut new_fields =\n-            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).filtered_patterns();\n+            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).into_patterns();\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -539,7 +513,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub(super) fn head_ctors<'a>(\n         &'a self,\n         cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> + Clone {\n         self.patterns.iter().map(move |r| r.head_ctor(cx))\n     }\n \n@@ -626,11 +600,82 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n+/// Represents a set of `Span`s closed under the containment relation. That is, if a `Span` is\n+/// contained in the set then all `Span`s contained in it are also implicitly contained in the set.\n+/// In particular this means that when intersecting two sets, taking the intersection of some span\n+/// and one of its subspans returns the subspan, whereas a simple `HashSet` would have returned an\n+/// empty intersection.\n+/// It is assumed that two spans don't overlap without one being contained in the other; in other\n+/// words, that the inclusion structure forms a tree and not a DAG.\n+/// Intersection is not very efficient. It compares everything pairwise. If needed it could be made\n+/// faster by sorting the `Span`s and merging cleverly.\n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct SpanSet {\n+    /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n+    /// the `SpanSet`, and A is a descendant of B, then only B will be in `root_spans`.\n+    /// Invariant: the spans are disjoint.\n+    root_spans: Vec<Span>,\n+}\n+\n+impl SpanSet {\n+    /// Creates an empty set.\n+    fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    /// Tests whether the set is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        self.root_spans.is_empty()\n+    }\n+\n+    /// Iterate over the disjoint list of spans at the roots of this set.\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = Span> + Captures<'a> {\n+        self.root_spans.iter().copied()\n+    }\n+\n+    /// Tests whether the set contains a given Span.\n+    fn contains(&self, span: Span) -> bool {\n+        self.iter().any(|root_span| root_span.contains(span))\n+    }\n+\n+    /// Add a span to the set if we know the span has no intersection in this set.\n+    fn push_nonintersecting(&mut self, new_span: Span) {\n+        self.root_spans.push(new_span);\n+    }\n+\n+    fn intersection_mut(&mut self, other: &Self) {\n+        if self.is_empty() || other.is_empty() {\n+            *self = Self::new();\n+            return;\n+        }\n+        // Those that were in `self` but not contained in `other`\n+        let mut leftover = SpanSet::new();\n+        // We keep the elements in `self` that are also in `other`.\n+        self.root_spans.retain(|span| {\n+            let retain = other.contains(*span);\n+            if !retain {\n+                leftover.root_spans.push(*span);\n+            }\n+            retain\n+        });\n+        // We keep the elements in `other` that are also in the original `self`. You might think\n+        // this is not needed because `self` already contains the intersection. But those aren't\n+        // just sets of things. If `self = [a]`, `other = [b]` and `a` contains `b`, then `b`\n+        // belongs in the intersection but we didn't catch it in the filtering above. We look at\n+        // `leftover` instead of the full original `self` to avoid duplicates.\n+        for span in other.iter() {\n+            if leftover.contains(span) {\n+                self.root_spans.push(span);\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx> {\n-    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n-    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n-    Useful(Vec<FxHashSet<Span>>),\n+    /// Pontentially carries a set of sub-branches that have been found to be unreachable. Used\n+    /// only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(SpanSet),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n@@ -640,25 +685,119 @@ impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful(vec![]),\n+            LeaveOutWitness => Useful(Default::default()),\n+        }\n+    }\n+\n+    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n+    /// results together.\n+    fn merge(usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        // If we have detected some unreachable sub-branches, we only want to keep them when they\n+        // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n+        // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n+        // to lint that it is unreachable.\n+        // ```\n+        // match (true, true) {\n+        //     (true, true) => {}\n+        //     (false | true, false | true) => {}\n+        // }\n+        // ```\n+        // Here however we _do_ want to lint that the last `false` is unreachable. So we don't want\n+        // to intersect the spans that come directly from the or-pattern, since each branch of the\n+        // or-pattern brings a new disjoint pattern.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n+        // sets are only non-empty in the presence of or-patterns.\n+        let mut unreachables: Option<SpanSet> = None;\n+        // Witnesses of usefulness, if any.\n+        let mut witnesses = Vec::new();\n+\n+        for u in usefulnesses {\n+            match u {\n+                Useful(spans) if spans.is_empty() => {\n+                    // Once we reach the empty set, more intersections won't change the result.\n+                    return Useful(SpanSet::new());\n+                }\n+                Useful(spans) => {\n+                    if let Some(unreachables) = &mut unreachables {\n+                        if !unreachables.is_empty() {\n+                            unreachables.intersection_mut(&spans);\n+                        }\n+                        if unreachables.is_empty() {\n+                            return Useful(SpanSet::new());\n+                        }\n+                    } else {\n+                        unreachables = Some(spans);\n+                    }\n+                }\n+                NotUseful => {}\n+                UsefulWithWitness(wits) => {\n+                    witnesses.extend(wits);\n+                }\n+            }\n+        }\n+\n+        if !witnesses.is_empty() {\n+            UsefulWithWitness(witnesses)\n+        } else if let Some(unreachables) = unreachables {\n+            Useful(unreachables)\n+        } else {\n+            NotUseful\n         }\n     }\n \n-    fn is_useful(&self) -> bool {\n-        !matches!(*self, NotUseful)\n+    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n+    /// usefulness mergeable with those from the other branches.\n+    fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n+        match self {\n+            Useful(mut spans) => {\n+                // We register the spans of the other branches of this or-pattern as being\n+                // unreachable from this one. This ensures that intersecting together the sets of\n+                // spans returns what we want.\n+                // Until we optimize `SpanSet` however, intersecting this entails a number of\n+                // comparisons quadratic in the number of branches.\n+                for &span in or_pat_spans {\n+                    if span != this_span {\n+                        spans.push_nonintersecting(span);\n+                    }\n+                }\n+                Useful(spans)\n+            }\n+            x => x,\n+        }\n     }\n \n+    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n+    /// with the results of specializing with the other constructors.\n     fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n+        matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let new_witnesses = if ctor.is_wildcard() {\n-                    let missing_ctors = MissingConstructors::new(pcx);\n-                    let new_patterns = missing_ctors.report_patterns(pcx);\n+                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n+                    let mut split_wildcard = SplitWildcard::new(pcx);\n+                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    // Construct for each missing constructor a \"wild\" version of this\n+                    // constructor, that matches everything that can be built with\n+                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                    // `Option::Some`, we get the pattern `Some(_)`.\n+                    let new_patterns: Vec<_> = split_wildcard\n+                        .iter_missing(pcx)\n+                        .map(|missing_ctor| {\n+                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                        })\n+                        .collect();\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -677,23 +816,6 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 UsefulWithWitness(new_witnesses)\n             }\n-            Useful(mut unreachables) => {\n-                if !unreachables.is_empty() {\n-                    // When we apply a constructor, there are `arity` columns of the matrix that\n-                    // corresponded to its arguments. All the unreachables found in these columns\n-                    // will, after `apply`, come from the first column. So we take the union of all\n-                    // the corresponding sets and put them in the first column.\n-                    // Note that `arity` may be 0, in which case we just push a new empty set.\n-                    let len = unreachables.len();\n-                    let arity = ctor_wild_subpatterns.len();\n-                    let mut unioned = FxHashSet::default();\n-                    for set in unreachables.drain((len - arity)..) {\n-                        unioned.extend(set)\n-                    }\n-                    unreachables.push(unioned);\n-                }\n-                Useful(unreachables)\n-            }\n             x => x,\n         }\n     }\n@@ -730,10 +852,10 @@ enum WitnessPreference {\n /// We'll perform the following steps:\n /// 1. Start with an empty witness\n ///     `Witness(vec![])`\n-/// 2. Push a witness `Some(_)` against the `None`\n-///     `Witness(vec![Some(_)])`\n-/// 3. Push a witness `true` against the `false`\n-///     `Witness(vec![Some(_), true])`\n+/// 2. Push a witness `true` against the `false`\n+///     `Witness(vec![true])`\n+/// 3. Push a witness `Some(_)` against the `None`\n+///     `Witness(vec![true, Some(_)])`\n /// 4. Apply the `Pair` constructor to the witnesses\n ///     `Witness(vec![Pair(Some(_), true)])`\n ///\n@@ -829,120 +951,67 @@ fn is_useful<'p, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n+    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n+    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n+\n+    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n+\n     // If the first pattern is an or-pattern, expand it.\n-    if let Some(vs) = v.expand_or_pat() {\n+    let ret = if let Some(vs) = v.expand_or_pat() {\n+        let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n-        //\n-        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n-        // they were detected in columns that are not the current one, we want to keep only the\n-        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n-        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n-        // Therefore we don't want to lint that it is unreachable.\n-        //\n-        // ```\n-        // match (true, true) {\n-        //     (true, true) => {}\n-        //     (false | true, false | true) => {}\n-        // }\n-        // ```\n-        // If however the sub-branches come from the current column, they come from the inside of\n-        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n-        // to lint that the last `false` is unreachable.\n-        // ```\n-        // match None {\n-        //     Some(false) => {}\n-        //     None | Some(true | false) => {}\n-        // }\n-        // ```\n-\n         let mut matrix = matrix.clone();\n-        // We keep track of sub-branches separately depending on whether they come from this column\n-        // or from others.\n-        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n-        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n-        // Whether at least one branch is reachable.\n-        let mut any_is_useful = false;\n-\n-        for v in vs {\n-            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            match res {\n-                Useful(unreachables) => {\n-                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n-                        // We keep the union of unreachables found in the first column.\n-                        unreachables_this_column.extend(this_column);\n-                        // We keep the intersection of unreachables found in other columns.\n-                        if unreachables_other_columns.is_empty() {\n-                            unreachables_other_columns = other_columns.to_vec();\n-                        } else {\n-                            unreachables_other_columns = unreachables_other_columns\n-                                .into_iter()\n-                                .zip(other_columns)\n-                                .map(|(x, y)| x.intersection(&y).copied().collect())\n-                                .collect();\n-                        }\n-                    }\n-                    any_is_useful = true;\n-                }\n-                NotUseful => {\n-                    unreachables_this_column.insert(v.head().span);\n-                }\n-                UsefulWithWitness(_) => bug!(\n-                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n-                ),\n-            }\n-\n+        let usefulnesses = vs.into_iter().map(|v| {\n+            let v_span = v.head().span;\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n+            usefulness.unsplit_or_pat(v_span, &subspans)\n+        });\n+        Usefulness::merge(usefulnesses)\n+    } else {\n+        let v_ctor = v.head_ctor(cx);\n+        if let Constructor::IntRange(ctor_range) = &v_ctor {\n+            // Lint on likely incorrect range patterns (#63987)\n+            ctor_range.lint_overlapping_range_endpoints(\n+                pcx,\n+                matrix.head_ctors_and_spans(cx),\n+                matrix.column_count().unwrap_or(0),\n+                hir_id,\n+            )\n         }\n-\n-        return if any_is_useful {\n-            let mut unreachables = if unreachables_other_columns.is_empty() {\n-                let n_columns = v.len();\n-                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n-            } else {\n-                unreachables_other_columns\n-            };\n-            unreachables.push(unreachables_this_column);\n-            Useful(unreachables)\n-        } else {\n-            NotUseful\n-        };\n-    }\n-\n-    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n-    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n-\n-    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n-\n-    let ret = v\n-        .head_ctor(cx)\n-        .split(pcx, Some(hir_id))\n-        .into_iter()\n-        .map(|ctor| {\n+        // We split the head constructor of `v`.\n+        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        // For each constructor, we compute whether there's a value that starts with it that would\n+        // witness the usefulness of `v`.\n+        let start_matrix = &matrix;\n+        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n-            let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+            let spec_matrix =\n+                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n-                is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n-        })\n-        .find(|result| result.is_useful())\n-        .unwrap_or(NotUseful);\n+                is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n+        });\n+        Usefulness::merge(usefulnesses)\n+    };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n     ret\n }\n \n /// The arm of a match expression.\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n-    /// The pattern must have been lowered through `MatchVisitor::lower_pattern`.\n+    /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n     crate pat: &'p super::Pat<'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n@@ -960,7 +1029,8 @@ crate struct UsefulnessReport<'p, 'tcx> {\n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n /// of its arms are reachable.\n ///\n-/// Note: the input patterns must have been lowered through `MatchVisitor::lower_pattern`.\n+/// Note: the input patterns must have been lowered through\n+/// `check_match::MatchVisitor::lower_pattern`.\n crate fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],"}, {"sha": "9abffbacfc3b3671b92182e3b6b04bcc0c6f2ad6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 31, "deletions": 359, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -7,22 +7,18 @@\n \n use rustc_ast as ast;\n use rustc_ast::attr::HasAttrs;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, LazyTokenStream, TokenStream, TokenTree};\n+use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::{symbol::kw, FileName, SourceFile, Span, DUMMY_SP};\n+use rustc_span::{FileName, SourceFile, Span};\n \n-use smallvec::SmallVec;\n-use std::cell::RefCell;\n-use std::mem;\n use std::path::Path;\n use std::str;\n \n-use tracing::{debug, info};\n+use tracing::debug;\n \n pub const MACRO_ARGUMENTS: Option<&str> = Some(\"macro arguments\");\n \n@@ -237,7 +233,12 @@ pub fn parse_in<'a, T>(\n // NOTE(Centril): The following probably shouldn't be here but it acknowledges the\n // fact that architecturally, we are using parsing (read on below to understand why).\n \n-pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> TokenStream {\n+pub fn nt_to_tokenstream(\n+    nt: &Nonterminal,\n+    sess: &ParseSess,\n+    span: Span,\n+    synthesize_tokens: CanSynthesizeMissingTokens,\n+) -> TokenStream {\n     // A `Nonterminal` is often a parsed AST item. At this point we now\n     // need to convert the parsed AST to an actual token stream, e.g.\n     // un-parse it basically.\n@@ -255,9 +256,11 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n         |tokens: Option<&LazyTokenStream>| tokens.as_ref().map(|t| t.create_token_stream());\n \n     let tokens = match *nt {\n-        Nonterminal::NtItem(ref item) => prepend_attrs(&item.attrs, item.tokens.as_ref()),\n+        Nonterminal::NtItem(ref item) => {\n+            prepend_attrs(sess, &item.attrs, nt, span, item.tokens.as_ref())\n+        }\n         Nonterminal::NtBlock(ref block) => convert_tokens(block.tokens.as_ref()),\n-        Nonterminal::NtStmt(ref stmt) => prepend_attrs(stmt.attrs(), stmt.tokens()),\n+        Nonterminal::NtStmt(ref stmt) => prepend_attrs(sess, stmt.attrs(), nt, span, stmt.tokens()),\n         Nonterminal::NtPat(ref pat) => convert_tokens(pat.tokens.as_ref()),\n         Nonterminal::NtTy(ref ty) => convert_tokens(ty.tokens.as_ref()),\n         Nonterminal::NtIdent(ident, is_raw) => {\n@@ -274,376 +277,45 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n             if expr.tokens.is_none() {\n                 debug!(\"missing tokens for expr {:?}\", expr);\n             }\n-            prepend_attrs(&expr.attrs, expr.tokens.as_ref())\n+            prepend_attrs(sess, &expr.attrs, nt, span, expr.tokens.as_ref())\n         }\n     };\n \n-    // Caches the stringification of 'good' `TokenStreams` which passed\n-    // `tokenstream_probably_equal_for_proc_macro`. This allows us to avoid\n-    // repeatedly stringifying and comparing the same `TokenStream` for deeply\n-    // nested nonterminals.\n-    //\n-    // We cache by the strinification instead of the `TokenStream` to avoid\n-    // needing to implement `Hash` for `TokenStream`. Note that it's possible to\n-    // have two distinct `TokenStream`s that stringify to the same result\n-    // (e.g. if they differ only in hygiene information). However, any\n-    // information lost during the stringification process is also intentionally\n-    // ignored by `tokenstream_probably_equal_for_proc_macro`, so it's fine\n-    // that a single cache entry may 'map' to multiple distinct `TokenStream`s.\n-    //\n-    // This is a temporary hack to prevent compilation blowup on certain inputs.\n-    // The entire pretty-print/retokenize process will be removed soon.\n-    thread_local! {\n-        static GOOD_TOKEN_CACHE: RefCell<FxHashSet<String>> = Default::default();\n-    }\n-\n-    // FIXME(#43081): Avoid this pretty-print + reparse hack\n-    // Pretty-print the AST struct without inserting any parenthesis\n-    // beyond those explicitly written by the user (e.g. `ExpnKind::Paren`).\n-    // The resulting stream may have incorrect precedence, but it's only\n-    // ever used for a comparison against the capture tokenstream.\n-    let source = pprust::nonterminal_to_string_no_extra_parens(nt);\n-    let filename = FileName::macro_expansion_source_code(&source);\n-    let reparsed_tokens = parse_stream_from_source_str(filename, source.clone(), sess, Some(span));\n-\n-    // During early phases of the compiler the AST could get modified\n-    // directly (e.g., attributes added or removed) and the internal cache\n-    // of tokens my not be invalidated or updated. Consequently if the\n-    // \"lossless\" token stream disagrees with our actual stringification\n-    // (which has historically been much more battle-tested) then we go\n-    // with the lossy stream anyway (losing span information).\n-    //\n-    // Note that the comparison isn't `==` here to avoid comparing spans,\n-    // but it *also* is a \"probable\" equality which is a pretty weird\n-    // definition. We mostly want to catch actual changes to the AST\n-    // like a `#[cfg]` being processed or some weird `macro_rules!`\n-    // expansion.\n-    //\n-    // What we *don't* want to catch is the fact that a user-defined\n-    // literal like `0xf` is stringified as `15`, causing the cached token\n-    // stream to not be literal `==` token-wise (ignoring spans) to the\n-    // token stream we got from stringification.\n-    //\n-    // Instead the \"probably equal\" check here is \"does each token\n-    // recursively have the same discriminant?\" We basically don't look at\n-    // the token values here and assume that such fine grained token stream\n-    // modifications, including adding/removing typically non-semantic\n-    // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if GOOD_TOKEN_CACHE.with(|cache| cache.borrow().contains(&source)) {\n-            return tokens;\n-        }\n-\n-        // Compare with a non-relaxed delim match to start.\n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess, false) {\n-            GOOD_TOKEN_CACHE.with(|cache| cache.borrow_mut().insert(source.clone()));\n-            return tokens;\n-        }\n-\n-        // The check failed. This time, we pretty-print the AST struct with parenthesis\n-        // inserted to preserve precedence. This may cause `None`-delimiters in the captured\n-        // token stream to match up with inserted parenthesis in the reparsed stream.\n-        let source_with_parens = pprust::nonterminal_to_string(nt);\n-        let filename_with_parens = FileName::macro_expansion_source_code(&source_with_parens);\n-\n-        if GOOD_TOKEN_CACHE.with(|cache| cache.borrow().contains(&source_with_parens)) {\n-            return tokens;\n-        }\n-\n-        let reparsed_tokens_with_parens = parse_stream_from_source_str(\n-            filename_with_parens,\n-            source_with_parens,\n-            sess,\n-            Some(span),\n-        );\n-\n-        // Compare with a relaxed delim match - we want inserted parenthesis in the\n-        // reparsed stream to match `None`-delimiters in the original stream.\n-        if tokenstream_probably_equal_for_proc_macro(\n-            &tokens,\n-            &reparsed_tokens_with_parens,\n-            sess,\n-            true,\n-        ) {\n-            GOOD_TOKEN_CACHE.with(|cache| cache.borrow_mut().insert(source.clone()));\n-            return tokens;\n-        }\n-\n-        info!(\n-            \"cached tokens found, but they're not \\\"probably equal\\\", \\\n-                going with stringified version\"\n-        );\n-        info!(\"cached   tokens: {}\", pprust::tts_to_string(&tokens));\n-        info!(\"reparsed tokens: {}\", pprust::tts_to_string(&reparsed_tokens_with_parens));\n-\n-        info!(\"cached   tokens debug: {:?}\", tokens);\n-        info!(\"reparsed tokens debug: {:?}\", reparsed_tokens_with_parens);\n-    }\n-    reparsed_tokens\n-}\n-\n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-//\n-// This is otherwise the same as `eq_unspanned`, only recursing with a\n-// different method.\n-pub fn tokenstream_probably_equal_for_proc_macro(\n-    tokens: &TokenStream,\n-    reparsed_tokens: &TokenStream,\n-    sess: &ParseSess,\n-    relaxed_delim_match: bool,\n-) -> bool {\n-    // When checking for `probably_eq`, we ignore certain tokens that aren't\n-    // preserved in the AST. Because they are not preserved, the pretty\n-    // printer arbitrarily adds or removes them when printing as token\n-    // streams, making a comparison between a token stream generated from an\n-    // AST and a token stream which was parsed into an AST more reliable.\n-    fn semantic_tree(tree: &TokenTree) -> bool {\n-        if let TokenTree::Token(token) = tree {\n-            if let\n-                // The pretty printer tends to add trailing commas to\n-                // everything, and in particular, after struct fields.\n-                | token::Comma\n-                // The pretty printer collapses many semicolons into one.\n-                | token::Semi\n-                // We don't preserve leading `|` tokens in patterns, so\n-                // we ignore them entirely\n-                | token::BinOp(token::BinOpToken::Or)\n-                // We don't preserve trailing '+' tokens in trait bounds,\n-                // so we ignore them entirely\n-                | token::BinOp(token::BinOpToken::Plus)\n-                // The pretty printer can turn `$crate` into `::crate_name`\n-                | token::ModSep = token.kind {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n-    //\n-    // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n-    // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n-    // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n-    // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n-    // when determining if two `TokenStream`s are 'probably equal'.\n-    //\n-    // Therefore, we use `break_two_token_op` to convert all tokens\n-    // to the 'unglued' form (if it exists). This ensures that two\n-    // `TokenStream`s which differ only in how their tokens are glued\n-    // will be considered 'probably equal', which allows us to keep spans.\n-    //\n-    // This is important when the original `TokenStream` contained\n-    // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n-    // will be omitted when we pretty-print, which can cause the original\n-    // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n-    // leading to some tokens being 'glued' together in one stream but not\n-    // the other. See #68489 for more details.\n-    fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n-        // In almost all cases, we should have either zero or one levels\n-        // of 'unglueing'. However, in some unusual cases, we may need\n-        // to iterate breaking tokens mutliple times. For example:\n-        // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n-        let mut token_trees: SmallVec<[_; 2]>;\n-        if let TokenTree::Token(token) = tree {\n-            let mut out = SmallVec::<[_; 2]>::new();\n-            out.push(token);\n-            // Iterate to fixpoint:\n-            // * We start off with 'out' containing our initial token, and `temp` empty\n-            // * If we are able to break any tokens in `out`, then `out` will have\n-            //   at least one more element than 'temp', so we will try to break tokens\n-            //   again.\n-            // * If we cannot break any tokens in 'out', we are done\n-            loop {\n-                let mut temp = SmallVec::<[_; 2]>::new();\n-                let mut changed = false;\n-\n-                for token in out.into_iter() {\n-                    if let Some((first, second)) = token.kind.break_two_token_op() {\n-                        temp.push(Token::new(first, DUMMY_SP));\n-                        temp.push(Token::new(second, DUMMY_SP));\n-                        changed = true;\n-                    } else {\n-                        temp.push(token);\n-                    }\n-                }\n-                out = temp;\n-                if !changed {\n-                    break;\n-                }\n-            }\n-            token_trees = out.into_iter().map(TokenTree::Token).collect();\n-        } else {\n-            token_trees = SmallVec::new();\n-            token_trees.push(tree);\n-        }\n-        token_trees.into_iter()\n-    }\n-\n-    fn expand_token(tree: TokenTree, sess: &ParseSess) -> impl Iterator<Item = TokenTree> {\n-        // When checking tokenstreams for 'probable equality', we are comparing\n-        // a captured (from parsing) `TokenStream` to a reparsed tokenstream.\n-        // The reparsed Tokenstream will never have `None`-delimited groups,\n-        // since they are only ever inserted as a result of macro expansion.\n-        // Therefore, inserting a `None`-delimtied group here (when we\n-        // convert a nested `Nonterminal` to a tokenstream) would cause\n-        // a mismatch with the reparsed tokenstream.\n-        //\n-        // Note that we currently do not handle the case where the\n-        // reparsed stream has a `Parenthesis`-delimited group\n-        // inserted. This will cause a spurious mismatch:\n-        // issue #75734 tracks resolving this.\n-\n-        let expanded: SmallVec<[_; 1]> =\n-            if let TokenTree::Token(Token { kind: TokenKind::Interpolated(nt), span }) = &tree {\n-                nt_to_tokenstream(nt, sess, *span)\n-                    .into_trees()\n-                    .flat_map(|t| expand_token(t, sess))\n-                    .collect()\n-            } else {\n-                // Filter before and after breaking tokens,\n-                // since we may want to ignore both glued and unglued tokens.\n-                std::iter::once(tree)\n-                    .filter(semantic_tree)\n-                    .flat_map(break_tokens)\n-                    .filter(semantic_tree)\n-                    .collect()\n-            };\n-        expanded.into_iter()\n-    }\n-\n-    // Break tokens after we expand any nonterminals, so that we break tokens\n-    // that are produced as a result of nonterminal expansion.\n-    let tokens = tokens.trees().flat_map(|t| expand_token(t, sess));\n-    let reparsed_tokens = reparsed_tokens.trees().flat_map(|t| expand_token(t, sess));\n-\n-    tokens.eq_by(reparsed_tokens, |t, rt| {\n-        tokentree_probably_equal_for_proc_macro(&t, &rt, sess, relaxed_delim_match)\n-    })\n-}\n-\n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-//\n-// This is otherwise the same as `eq_unspanned`, only recursing with a\n-// different method.\n-pub fn tokentree_probably_equal_for_proc_macro(\n-    token: &TokenTree,\n-    reparsed_token: &TokenTree,\n-    sess: &ParseSess,\n-    relaxed_delim_match: bool,\n-) -> bool {\n-    match (token, reparsed_token) {\n-        (TokenTree::Token(token), TokenTree::Token(reparsed_token)) => {\n-            token_probably_equal_for_proc_macro(token, reparsed_token)\n-        }\n-        (\n-            TokenTree::Delimited(_, delim, tokens),\n-            TokenTree::Delimited(_, reparsed_delim, reparsed_tokens),\n-        ) if delim == reparsed_delim => tokenstream_probably_equal_for_proc_macro(\n-            tokens,\n-            reparsed_tokens,\n-            sess,\n-            relaxed_delim_match,\n-        ),\n-        (TokenTree::Delimited(_, DelimToken::NoDelim, tokens), reparsed_token) => {\n-            if relaxed_delim_match {\n-                if let TokenTree::Delimited(_, DelimToken::Paren, reparsed_tokens) = reparsed_token\n-                {\n-                    if tokenstream_probably_equal_for_proc_macro(\n-                        tokens,\n-                        reparsed_tokens,\n-                        sess,\n-                        relaxed_delim_match,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            tokens.len() == 1\n-                && tokentree_probably_equal_for_proc_macro(\n-                    &tokens.trees().next().unwrap(),\n-                    reparsed_token,\n-                    sess,\n-                    relaxed_delim_match,\n-                )\n-        }\n-        _ => false,\n+        return tokens;\n+    } else if matches!(synthesize_tokens, CanSynthesizeMissingTokens::Yes) {\n+        return fake_token_stream(sess, nt, span);\n+    } else {\n+        let pretty = rustc_ast_pretty::pprust::nonterminal_to_string_no_extra_parens(&nt);\n+        panic!(\"Missing tokens at {:?} for nt {:?}\", span, pretty);\n     }\n }\n \n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n-    if mem::discriminant(&first.kind) != mem::discriminant(&other.kind) {\n-        return false;\n-    }\n-    use rustc_ast::token::TokenKind::*;\n-    match (&first.kind, &other.kind) {\n-        (&Eq, &Eq)\n-        | (&Lt, &Lt)\n-        | (&Le, &Le)\n-        | (&EqEq, &EqEq)\n-        | (&Ne, &Ne)\n-        | (&Ge, &Ge)\n-        | (&Gt, &Gt)\n-        | (&AndAnd, &AndAnd)\n-        | (&OrOr, &OrOr)\n-        | (&Not, &Not)\n-        | (&Tilde, &Tilde)\n-        | (&At, &At)\n-        | (&Dot, &Dot)\n-        | (&DotDot, &DotDot)\n-        | (&DotDotDot, &DotDotDot)\n-        | (&DotDotEq, &DotDotEq)\n-        | (&Comma, &Comma)\n-        | (&Semi, &Semi)\n-        | (&Colon, &Colon)\n-        | (&ModSep, &ModSep)\n-        | (&RArrow, &RArrow)\n-        | (&LArrow, &LArrow)\n-        | (&FatArrow, &FatArrow)\n-        | (&Pound, &Pound)\n-        | (&Dollar, &Dollar)\n-        | (&Question, &Question)\n-        | (&Eof, &Eof) => true,\n-\n-        (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n-\n-        (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n-\n-        (&DocComment(a1, a2, a3), &DocComment(b1, b2, b3)) => a1 == b1 && a2 == b2 && a3 == b3,\n-\n-        (&Literal(a), &Literal(b)) => a == b,\n-\n-        (&Lifetime(a), &Lifetime(b)) => a == b,\n-        (&Ident(a, b), &Ident(c, d)) => {\n-            b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n-        }\n-\n-        (&Interpolated(..), &Interpolated(..)) => panic!(\"Unexpanded Interpolated!\"),\n-\n-        _ => panic!(\"forgot to add a token?\"),\n-    }\n+pub fn fake_token_stream(sess: &ParseSess, nt: &Nonterminal, span: Span) -> TokenStream {\n+    let source = pprust::nonterminal_to_string(nt);\n+    let filename = FileName::macro_expansion_source_code(&source);\n+    parse_stream_from_source_str(filename, source, sess, Some(span))\n }\n \n fn prepend_attrs(\n+    sess: &ParseSess,\n     attrs: &[ast::Attribute],\n+    nt: &Nonterminal,\n+    span: Span,\n     tokens: Option<&tokenstream::LazyTokenStream>,\n ) -> Option<tokenstream::TokenStream> {\n-    let tokens = tokens?.create_token_stream();\n     if attrs.is_empty() {\n-        return Some(tokens);\n+        return Some(tokens?.create_token_stream());\n     }\n     let mut builder = tokenstream::TokenStreamBuilder::new();\n     for attr in attrs {\n         // FIXME: Correctly handle tokens for inner attributes.\n         // For now, we fall back to reparsing the original AST node\n         if attr.style == ast::AttrStyle::Inner {\n-            return None;\n+            return Some(fake_token_stream(sess, nt, span));\n         }\n         builder.push(attr.tokens());\n     }\n-    builder.push(tokens);\n+    builder.push(tokens?.create_token_stream());\n     Some(builder.build())\n }"}, {"sha": "98c7b9a63a55f60d8f54c0933e0bebdebd04bde8", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1912,4 +1912,22 @@ impl<'a> Parser<'a> {\n         *self = snapshot;\n         Err(err)\n     }\n+\n+    /// Get the diagnostics for the cases where `move async` is found.\n+    ///\n+    /// `move_async_span` starts at the 'm' of the move keyword and ends with the 'c' of the async keyword\n+    pub(super) fn incorrect_move_async_order_found(\n+        &self,\n+        move_async_span: Span,\n+    ) -> DiagnosticBuilder<'a> {\n+        let mut err =\n+            self.struct_span_err(move_async_span, \"the order of `move` and `async` is incorrect\");\n+        err.span_suggestion_verbose(\n+            move_async_span,\n+            \"try switching the order\",\n+            \"async move\".to_owned(),\n+            Applicability::MaybeIncorrect,\n+        );\n+        err\n+    }\n }"}, {"sha": "b147f42fada25bfdf368c1ad27e66bba6d280cd5", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,5 +1,5 @@\n-use super::pat::{GateOr, PARAM_EXPECTED};\n-use super::ty::{AllowPlus, RecoverQPath};\n+use super::pat::{GateOr, RecoverComma, PARAM_EXPECTED};\n+use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{BlockMode, Parser, PathStyle, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n@@ -1603,7 +1603,7 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::async_closure, span);\n         }\n \n-        let capture_clause = self.parse_capture_clause();\n+        let capture_clause = self.parse_capture_clause()?;\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_token.span;\n         let body = match decl.output {\n@@ -1626,8 +1626,18 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an optional `move` prefix to a closure-like construct.\n-    fn parse_capture_clause(&mut self) -> CaptureBy {\n-        if self.eat_keyword(kw::Move) { CaptureBy::Value } else { CaptureBy::Ref }\n+    fn parse_capture_clause(&mut self) -> PResult<'a, CaptureBy> {\n+        if self.eat_keyword(kw::Move) {\n+            // Check for `move async` and recover\n+            if self.check_keyword(kw::Async) {\n+                let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n+                Err(self.incorrect_move_async_order_found(move_async_span))\n+            } else {\n+                Ok(CaptureBy::Value)\n+            }\n+        } else {\n+            Ok(CaptureBy::Ref)\n+        }\n     }\n \n     /// Parses the `|arg, arg|` header of a closure.\n@@ -1647,7 +1657,8 @@ impl<'a> Parser<'a> {\n             self.expect_or()?;\n             args\n         };\n-        let output = self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes)?;\n+        let output =\n+            self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes, RecoverReturnSign::Yes)?;\n \n         Ok(P(FnDecl { inputs, output }))\n     }\n@@ -1728,7 +1739,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n@@ -1791,7 +1802,7 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let pat = self.parse_top_pat(GateOr::Yes)?;\n+        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n@@ -1901,7 +1912,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        let pat = self.parse_top_pat(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n         let guard = if self.eat_keyword(kw::If) {\n             let if_span = self.prev_token.span;\n             let cond = self.parse_expr()?;\n@@ -2018,7 +2029,7 @@ impl<'a> Parser<'a> {\n     fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n-        let capture_clause = self.parse_capture_clause();\n+        let capture_clause = self.parse_capture_clause()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);"}, {"sha": "860e63020bb0644715d485160dbbdb1d79e8bb92", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::{\n     self as ast, Attribute, GenericBounds, GenericParam, GenericParamKind, WhereClause,\n };\n use rustc_errors::PResult;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::kw;\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -56,8 +56,6 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.gate(sym::min_const_generics, const_span.to(self.prev_token.span));\n-\n         Ok(GenericParam {\n             ident,\n             id: ast::DUMMY_NODE_ID,\n@@ -240,7 +238,7 @@ impl<'a> Parser<'a> {\n \n         // Parse type with mandatory colon and (possibly empty) bounds,\n         // or with mandatory equality sign and the second type.\n-        let ty = self.parse_ty()?;\n+        let ty = self.parse_ty_for_where_clause()?;\n         if self.eat(&token::Colon) {\n             let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n             Ok(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {"}, {"sha": "c6669f0468296cb3217fdf2ed1c083f422b26ac6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,5 +1,5 @@\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n-use super::ty::{AllowPlus, RecoverQPath};\n+use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n@@ -247,9 +247,14 @@ impl<'a> Parser<'a> {\n             (ident, ItemKind::Static(ty, m, expr))\n         } else if let Const::Yes(const_span) = self.parse_constness() {\n             // CONST ITEM\n-            self.recover_const_mut(const_span);\n-            let (ident, ty, expr) = self.parse_item_global(None)?;\n-            (ident, ItemKind::Const(def(), ty, expr))\n+            if self.token.is_keyword(kw::Impl) {\n+                // recover from `const impl`, suggest `impl const`\n+                self.recover_const_impl(const_span, attrs, def())?\n+            } else {\n+                self.recover_const_mut(const_span);\n+                let (ident, ty, expr) = self.parse_item_global(None)?;\n+                (ident, ItemKind::Const(def(), ty, expr))\n+            }\n         } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n             // TRAIT ITEM\n             self.parse_item_trait(attrs, lo)?\n@@ -489,7 +494,7 @@ impl<'a> Parser<'a> {\n         let polarity = self.parse_polarity();\n \n         // Parse both types and traits as a type, then reinterpret if necessary.\n-        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n+        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Empty, span));\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n             let span = self.prev_token.span.between(self.token.span);\n@@ -988,6 +993,36 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover on `const impl` with `const` already eaten.\n+    fn recover_const_impl(\n+        &mut self,\n+        const_span: Span,\n+        attrs: &mut Vec<Attribute>,\n+        defaultness: Defaultness,\n+    ) -> PResult<'a, ItemInfo> {\n+        let impl_span = self.token.span;\n+        let mut err = self.expected_ident_found();\n+        let mut impl_info = self.parse_item_impl(attrs, defaultness)?;\n+        match impl_info.1 {\n+            // only try to recover if this is implementing a trait for a type\n+            ItemKind::Impl { of_trait: Some(ref trai), ref mut constness, .. } => {\n+                *constness = Const::Yes(const_span);\n+\n+                let before_trait = trai.path.span.shrink_to_lo();\n+                let const_up_to_impl = const_span.with_hi(impl_span.lo());\n+                err.multipart_suggestion(\n+                    \"you might have meant to write a const trait impl\",\n+                    vec![(const_up_to_impl, \"\".to_owned()), (before_trait, \"const \".to_owned())],\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+            }\n+            ItemKind::Impl { .. } => return Err(err),\n+            _ => unreachable!(),\n+        }\n+        Ok(impl_info)\n+    }\n+\n     /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty (= $expr)?` with\n     /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n     ///\n@@ -1514,7 +1549,7 @@ impl<'a> Parser<'a> {\n         let header = self.parse_fn_front_matter()?; // `const ... fn`\n         let ident = self.parse_ident()?; // `foo`\n         let mut generics = self.parse_generics()?; // `<'a, T, ...>`\n-        let decl = self.parse_fn_decl(req_name, AllowPlus::Yes)?; // `(p: u8, ...)`\n+        let decl = self.parse_fn_decl(req_name, AllowPlus::Yes, RecoverReturnSign::Yes)?; // `(p: u8, ...)`\n         generics.where_clause = self.parse_where_clause()?; // `where T: Ord`\n \n         let mut sig_hi = self.prev_token.span;\n@@ -1645,10 +1680,11 @@ impl<'a> Parser<'a> {\n         &mut self,\n         req_name: ReqName,\n         ret_allow_plus: AllowPlus,\n+        recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n             inputs: self.parse_fn_params(req_name)?,\n-            output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?,\n+            output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes, recover_return_sign)?,\n         }))\n     }\n \n@@ -1663,7 +1699,7 @@ impl<'a> Parser<'a> {\n                 // Skip every token until next possible arg or end.\n                 p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n                 // Create a placeholder argument for proper arg count (issue #34264).\n-                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_token.span))))\n+                Ok(dummy_arg(Ident::new(kw::Empty, lo.to(p.prev_token.span))))\n             });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n             first_param = false;\n@@ -1723,7 +1759,7 @@ impl<'a> Parser<'a> {\n             }\n             match ty {\n                 Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_token.span);\n+                    let ident = Ident::new(kw::Empty, self.prev_token.span);\n                     let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)"}, {"sha": "073e62c41d311cb82791c96ca1f5dbfe2599bc0e", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -17,7 +17,7 @@ pub use path::PathStyle;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{self, DelimSpan, LazyTokenStream, Spacing};\n-use rustc_ast::tokenstream::{CreateTokenStream, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{CreateTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacDelimiter, Mutability, StrLit};\n@@ -132,6 +132,28 @@ struct TokenCursor {\n     // Counts the number of calls to `next` or `next_desugared`,\n     // depending on whether `desugar_doc_comments` is set.\n     num_next_calls: usize,\n+    // During parsing, we may sometimes need to 'unglue' a\n+    // glued token into two component tokens\n+    // (e.g. '>>' into '>' and '>), so that the parser\n+    // can consume them one at a time. This process\n+    // bypasses the normal capturing mechanism\n+    // (e.g. `num_next_calls` will not be incremented),\n+    // since the 'unglued' tokens due not exist in\n+    // the original `TokenStream`.\n+    //\n+    // If we end up consuming both unglued tokens,\n+    // then this is not an issue - we'll end up\n+    // capturing the single 'glued' token.\n+    //\n+    // However, in certain circumstances, we may\n+    // want to capture just the first 'unglued' token.\n+    // For example, capturing the `Vec<u8>`\n+    // in `Option<Vec<u8>>` requires us to unglue\n+    // the trailing `>>` token. The `append_unglued_token`\n+    // field is used to track this token - it gets\n+    // appended to the captured stream when\n+    // we evaluate a `LazyTokenStream`\n+    append_unglued_token: Option<TreeAndSpacing>,\n }\n \n #[derive(Clone)]\n@@ -336,6 +358,7 @@ impl<'a> Parser<'a> {\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n+                append_unglued_token: None,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n@@ -359,6 +382,10 @@ impl<'a> Parser<'a> {\n             self.token_cursor.next()\n         };\n         self.token_cursor.num_next_calls += 1;\n+        // We've retrieved an token from the underlying\n+        // cursor, so we no longer need to worry about\n+        // an unglued token. See `break_and_eat` for more details\n+        self.token_cursor.append_unglued_token = None;\n         if next.span.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n             next.span = fallback_span.with_ctxt(next.span.ctxt());\n@@ -555,6 +582,14 @@ impl<'a> Parser<'a> {\n                 let first_span = self.sess.source_map().start_point(self.token.span);\n                 let second_span = self.token.span.with_lo(first_span.hi());\n                 self.token = Token::new(first, first_span);\n+                // Keep track of this token - if we end token capturing now,\n+                // we'll want to append this token to the captured stream.\n+                //\n+                // If we consume any additional tokens, then this token\n+                // is not needed (we'll capture the entire 'glued' token),\n+                // and `next_tok` will set this field to `None`\n+                self.token_cursor.append_unglued_token =\n+                    Some((TokenTree::Token(self.token.clone()), Spacing::Alone));\n                 // Use the spacing of the glued token as the spacing\n                 // of the unglued second token.\n                 self.bump_with((Token::new(second, second_span), self.token_spacing));\n@@ -685,13 +720,9 @@ impl<'a> Parser<'a> {\n                                 Ok(t) => {\n                                     // Parsed successfully, therefore most probably the code only\n                                     // misses a separator.\n-                                    let mut exp_span = self.sess.source_map().next_point(sp);\n-                                    if self.sess.source_map().is_multiline(exp_span) {\n-                                        exp_span = sp;\n-                                    }\n                                     expect_err\n                                         .span_suggestion_short(\n-                                            exp_span,\n+                                            sp,\n                                             &format!(\"missing `{}`\", token_str),\n                                             token_str,\n                                             Applicability::MaybeIncorrect,\n@@ -1230,6 +1261,7 @@ impl<'a> Parser<'a> {\n             num_calls: usize,\n             desugar_doc_comments: bool,\n             trailing_semi: bool,\n+            append_unglued_token: Option<TreeAndSpacing>,\n         }\n         impl CreateTokenStream for LazyTokenStreamImpl {\n             fn create_token_stream(&self) -> TokenStream {\n@@ -1253,12 +1285,18 @@ impl<'a> Parser<'a> {\n                     }))\n                     .take(num_calls);\n \n-                make_token_stream(tokens)\n+                make_token_stream(tokens, self.append_unglued_token.clone())\n             }\n             fn add_trailing_semi(&self) -> Box<dyn CreateTokenStream> {\n                 if self.trailing_semi {\n                     panic!(\"Called `add_trailing_semi` twice!\");\n                 }\n+                if self.append_unglued_token.is_some() {\n+                    panic!(\n+                        \"Cannot call `add_trailing_semi` when we have an unglued token {:?}\",\n+                        self.append_unglued_token\n+                    );\n+                }\n                 let mut new = self.clone();\n                 new.trailing_semi = true;\n                 Box::new(new)\n@@ -1271,6 +1309,7 @@ impl<'a> Parser<'a> {\n             cursor_snapshot,\n             desugar_doc_comments: self.desugar_doc_comments,\n             trailing_semi: false,\n+            append_unglued_token: self.token_cursor.append_unglued_token.clone(),\n         };\n         Ok((ret, Some(LazyTokenStream::new(lazy_impl))))\n     }\n@@ -1325,7 +1364,10 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n /// Converts a flattened iterator of tokens (including open and close delimiter tokens)\n /// into a `TokenStream`, creating a `TokenTree::Delimited` for each matching pair\n /// of open and close delims.\n-fn make_token_stream(tokens: impl Iterator<Item = (Token, Spacing)>) -> TokenStream {\n+fn make_token_stream(\n+    tokens: impl Iterator<Item = (Token, Spacing)>,\n+    append_unglued_token: Option<TreeAndSpacing>,\n+) -> TokenStream {\n     #[derive(Debug)]\n     struct FrameData {\n         open: Span,\n@@ -1348,14 +1390,17 @@ fn make_token_stream(tokens: impl Iterator<Item = (Token, Spacing)>) -> TokenStr\n                     .inner\n                     .push((delimited, Spacing::Alone));\n             }\n-            token => stack\n-                .last_mut()\n-                .expect(\"Bottom token frame is missing!\")\n-                .inner\n-                .push((TokenTree::Token(token), spacing)),\n+            token => {\n+                stack\n+                    .last_mut()\n+                    .expect(\"Bottom token frame is missing!\")\n+                    .inner\n+                    .push((TokenTree::Token(token), spacing));\n+            }\n         }\n     }\n-    let final_buf = stack.pop().expect(\"Missing final buf!\");\n+    let mut final_buf = stack.pop().expect(\"Missing final buf!\");\n+    final_buf.inner.extend(append_unglued_token);\n     assert!(stack.is_empty(), \"Stack should be empty: final_buf={:?} stack={:?}\", final_buf, stack);\n     TokenStream::new(final_buf.inner)\n }"}, {"sha": "eb5d7075f0081e6c8f75facd8db5b52041858aa3", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,6 +4,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n+use crate::parser::pat::{GateOr, RecoverComma};\n use crate::parser::{FollowedByType, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n@@ -27,6 +28,8 @@ impl<'a> Parser<'a> {\n                 token.can_begin_expr()\n                 // This exception is here for backwards compatibility.\n                 && !token.is_keyword(kw::Let)\n+                // This exception is here for backwards compatibility.\n+                && !token.is_keyword(kw::Const)\n             }\n             NonterminalKind::Ty => token.can_begin_type(),\n             NonterminalKind::Ident => get_macro_ident(token).is_some(),\n@@ -55,7 +58,7 @@ impl<'a> Parser<'a> {\n                 },\n                 _ => false,\n             },\n-            NonterminalKind::Pat => match token.kind {\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => match token.kind {\n                 token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n                 token::OpenDelim(token::Paren) |    // tuple pattern\n                 token::OpenDelim(token::Bracket) |  // slice pattern\n@@ -68,6 +71,8 @@ impl<'a> Parser<'a> {\n                 token::ModSep |                     // path\n                 token::Lt |                         // path (UFCS constant)\n                 token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                // leading vert `|` or-pattern\n+                token::BinOp(token::Or) =>  matches!(kind, NonterminalKind::Pat2021 {..}),\n                 token::Interpolated(ref nt) => may_be_ident(nt),\n                 _ => false,\n             },\n@@ -84,6 +89,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse a non-terminal (e.g. MBE `:pat` or `:ident`).\n     pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n         // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n         // needs to have them force-captured here.\n@@ -127,8 +133,14 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-            NonterminalKind::Pat => {\n-                let (mut pat, tokens) = self.collect_tokens(|this| this.parse_pat(None))?;\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => {\n+                let (mut pat, tokens) = self.collect_tokens(|this| match kind {\n+                    NonterminalKind::Pat2018 { .. } => this.parse_pat(None),\n+                    NonterminalKind::Pat2021 { .. } => {\n+                        this.parse_top_pat(GateOr::Yes, RecoverComma::No)\n+                    }\n+                    _ => unreachable!(),\n+                })?;\n                 // We have have eaten an NtPat, which could already have tokens\n                 if pat.tokens.is_none() {\n                     pat.tokens = tokens;"}, {"sha": "456e32680fe5024dc4fc00b5b448a2faca8b8c94", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -26,7 +26,7 @@ pub(super) enum GateOr {\n \n /// Whether or not to recover a `,` when parsing or-patterns.\n #[derive(PartialEq, Copy, Clone)]\n-enum RecoverComma {\n+pub(super) enum RecoverComma {\n     Yes,\n     No,\n }\n@@ -43,13 +43,17 @@ impl<'a> Parser<'a> {\n \n     /// Entry point to the main pattern parser.\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n-    pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {\n+    pub(super) fn parse_top_pat(\n+        &mut self,\n+        gate_or: GateOr,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n         let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n         let leading_vert_span = self.prev_token.span;\n \n         // Parse the possibly-or-pattern.\n-        let pat = self.parse_pat_with_or(None, gate_or, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_with_or(None, gate_or, rc)?;\n \n         // If we parsed a leading `|` which should be gated,\n         // and no other gated or-pattern has been parsed thus far,"}, {"sha": "60a47ca12b868c4958880e84c5bb0ee0b13c84a6", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,4 +1,4 @@\n-use super::ty::{AllowPlus, RecoverQPath};\n+use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_ast::ptr::P;\n@@ -231,7 +231,8 @@ impl<'a> Parser<'a> {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                     let span = ident.span.to(self.prev_token.span);\n-                    let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No)?;\n+                    let output =\n+                        self.parse_ret_ty(AllowPlus::No, RecoverQPath::No, RecoverReturnSign::No)?;\n                     ParenthesizedArgs { inputs, output, span }.into()\n                 };\n \n@@ -500,10 +501,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn expr_is_valid_const_arg(&self, expr: &P<rustc_ast::Expr>) -> bool {\n         match &expr.kind {\n             ast::ExprKind::Block(_, _) | ast::ExprKind::Lit(_) => true,\n-            ast::ExprKind::Unary(ast::UnOp::Neg, expr) => match &expr.kind {\n-                ast::ExprKind::Lit(_) => true,\n-                _ => false,\n-            },\n+            ast::ExprKind::Unary(ast::UnOp::Neg, expr) => {\n+                matches!(expr.kind, ast::ExprKind::Lit(_))\n+            }\n             // We can only resolve single-segment paths at the moment, because multi-segment paths\n             // require type-checking: see `visit_generic_arg` in `src/librustc_resolve/late.rs`.\n             ast::ExprKind::Path(None, path)"}, {"sha": "2942747991a1db30da9059dca7977ed84060231c", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,7 +1,7 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n-use super::pat::GateOr;\n+use super::pat::{GateOr, RecoverComma};\n use super::path::PathStyle;\n use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n@@ -185,7 +185,7 @@ impl<'a> Parser<'a> {\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::Yes)?;\n+        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "9553f5d09e83bec5afb6143a16c6ef63e00a081f", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -43,6 +43,37 @@ pub(super) enum RecoverQPath {\n     No,\n }\n \n+/// Signals whether parsing a type should recover `->`.\n+///\n+/// More specifically, when parsing a function like:\n+/// ```rust\n+/// fn foo() => u8 { 0 }\n+/// fn bar(): u8 { 0 }\n+/// ```\n+/// The compiler will try to recover interpreting `foo() => u8` as `foo() -> u8` when calling\n+/// `parse_ty` with anything except `RecoverReturnSign::No`, and it will try to recover `bar(): u8`\n+/// as `bar() -> u8` when passing `RecoverReturnSign::Yes` to `parse_ty`\n+#[derive(Copy, Clone, PartialEq)]\n+pub(super) enum RecoverReturnSign {\n+    Yes,\n+    OnlyFatArrow,\n+    No,\n+}\n+\n+impl RecoverReturnSign {\n+    /// [RecoverReturnSign::Yes] allows for recovering `fn foo() => u8` and `fn foo(): u8`,\n+    /// [RecoverReturnSign::OnlyFatArrow] allows for recovering only `fn foo() => u8` (recovering\n+    /// colons can cause problems when parsing where clauses), and\n+    /// [RecoverReturnSign::No] doesn't allow for any recovery of the return type arrow\n+    fn can_recover(self, token: &TokenKind) -> bool {\n+        match self {\n+            Self::Yes => matches!(token, token::FatArrow | token::Colon),\n+            Self::OnlyFatArrow => matches!(token, token::FatArrow),\n+            Self::No => false,\n+        }\n+    }\n+}\n+\n // Is `...` (`CVarArgs`) legal at this level of type parsing?\n #[derive(PartialEq)]\n enum AllowCVariadic {\n@@ -62,14 +93,24 @@ fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n impl<'a> Parser<'a> {\n     /// Parses a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::No)\n+        self.parse_ty_common(\n+            AllowPlus::Yes,\n+            AllowCVariadic::No,\n+            RecoverQPath::Yes,\n+            RecoverReturnSign::Yes,\n+        )\n     }\n \n     /// Parse a type suitable for a function or function pointer parameter.\n     /// The difference from `parse_ty` is that this version allows `...`\n     /// (`CVarArgs`) at the top level of the type.\n     pub(super) fn parse_ty_for_param(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::Yes)\n+        self.parse_ty_common(\n+            AllowPlus::Yes,\n+            AllowCVariadic::Yes,\n+            RecoverQPath::Yes,\n+            RecoverReturnSign::Yes,\n+        )\n     }\n \n     /// Parses a type in restricted contexts where `+` is not permitted.\n@@ -79,18 +120,58 @@ impl<'a> Parser<'a> {\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n     pub(super) fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(AllowPlus::No, RecoverQPath::Yes, AllowCVariadic::No)\n+        self.parse_ty_common(\n+            AllowPlus::No,\n+            AllowCVariadic::No,\n+            RecoverQPath::Yes,\n+            RecoverReturnSign::Yes,\n+        )\n+    }\n+\n+    /// Parse a type without recovering `:` as `->` to avoid breaking code such as `where fn() : for<'a>`\n+    pub(super) fn parse_ty_for_where_clause(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(\n+            AllowPlus::Yes,\n+            AllowCVariadic::Yes,\n+            RecoverQPath::Yes,\n+            RecoverReturnSign::OnlyFatArrow,\n+        )\n     }\n \n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     pub(super) fn parse_ret_ty(\n         &mut self,\n         allow_plus: AllowPlus,\n         recover_qpath: RecoverQPath,\n+        recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, FnRetTy> {\n         Ok(if self.eat(&token::RArrow) {\n             // FIXME(Centril): Can we unconditionally `allow_plus`?\n-            let ty = self.parse_ty_common(allow_plus, recover_qpath, AllowCVariadic::No)?;\n+            let ty = self.parse_ty_common(\n+                allow_plus,\n+                AllowCVariadic::No,\n+                recover_qpath,\n+                recover_return_sign,\n+            )?;\n+            FnRetTy::Ty(ty)\n+        } else if recover_return_sign.can_recover(&self.token.kind) {\n+            // Don't `eat` to prevent `=>` from being added as an expected token which isn't\n+            // actually expected and could only confuse users\n+            self.bump();\n+            self.struct_span_err(self.prev_token.span, \"return types are denoted using `->`\")\n+                .span_suggestion_short(\n+                    self.prev_token.span,\n+                    \"use `->` instead\",\n+                    \"->\".to_string(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            let ty = self.parse_ty_common(\n+                allow_plus,\n+                AllowCVariadic::No,\n+                recover_qpath,\n+                recover_return_sign,\n+            )?;\n             FnRetTy::Ty(ty)\n         } else {\n             FnRetTy::Default(self.token.span.shrink_to_lo())\n@@ -100,8 +181,9 @@ impl<'a> Parser<'a> {\n     fn parse_ty_common(\n         &mut self,\n         allow_plus: AllowPlus,\n-        recover_qpath: RecoverQPath,\n         allow_c_variadic: AllowCVariadic,\n+        recover_qpath: RecoverQPath,\n+        recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -129,14 +211,14 @@ impl<'a> Parser<'a> {\n             TyKind::Infer\n         } else if self.check_fn_front_matter() {\n             // Function pointer type\n-            self.parse_ty_bare_fn(lo, Vec::new())?\n+            self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.check_fn_front_matter() {\n-                self.parse_ty_bare_fn(lo, lifetime_defs)?\n+                self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n                 let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n@@ -338,9 +420,14 @@ impl<'a> Parser<'a> {\n     /// Function Style    ABI  Parameter types\n     /// ```\n     /// We actually parse `FnHeader FnDecl`, but we error on `const` and `async` qualifiers.\n-    fn parse_ty_bare_fn(&mut self, lo: Span, params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n+    fn parse_ty_bare_fn(\n+        &mut self,\n+        lo: Span,\n+        params: Vec<GenericParam>,\n+        recover_return_sign: RecoverReturnSign,\n+    ) -> PResult<'a, TyKind> {\n         let ast::FnHeader { ext, unsafety, constness, asyncness } = self.parse_fn_front_matter()?;\n-        let decl = self.parse_fn_decl(|_| false, AllowPlus::No)?;\n+        let decl = self.parse_fn_decl(|_| false, AllowPlus::No, recover_return_sign)?;\n         let whole_span = lo.to(self.prev_token.span);\n         if let ast::Const::Yes(span) = constness {\n             self.error_fn_ptr_bad_qualifier(whole_span, span, \"const\");"}, {"sha": "aeaa862f5fd631e1c544f1504b4541d784cc6f53", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -882,6 +882,18 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_item(self, item)\n     }\n \n+    fn visit_generic_param(&mut self, generic_param: &'tcx hir::GenericParam<'tcx>) {\n+        let target = Target::from_generic_param(generic_param);\n+        self.check_attributes(\n+            generic_param.hir_id,\n+            generic_param.attrs,\n+            &generic_param.span,\n+            target,\n+            None,\n+        );\n+        intravisit::walk_generic_param(self, generic_param)\n+    }\n+\n     fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n         let target = Target::from_trait_item(trait_item);\n         self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);"}, {"sha": "2d6bbff460d7fb6ea61eb613b91f2dfc44996957", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -45,6 +45,8 @@ impl NonConstExpr {\n                 return None;\n             }\n \n+            Self::Match(IfLetGuardDesugar) => bug!(\"if-let guard outside a `match` expression\"),\n+\n             // All other expressions are allowed.\n             Self::Loop(Loop | While | WhileLet)\n             | Self::Match("}, {"sha": "c4fb0cf5b28dc6bdb5bfc98eeee6ea5852034fbb", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -23,18 +23,18 @@ use rustc_span::symbol::{sym, Symbol};\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n-    match tcx.hir().find(hir_id) {\n+    matches!(\n+        tcx.hir().find(hir_id),\n         Some(\n             Node::Item(..)\n-            | Node::ImplItem(..)\n-            | Node::ForeignItem(..)\n-            | Node::TraitItem(..)\n-            | Node::Variant(..)\n-            | Node::AnonConst(..)\n-            | Node::Pat(..),\n-        ) => true,\n-        _ => false,\n-    }\n+                | Node::ImplItem(..)\n+                | Node::ForeignItem(..)\n+                | Node::TraitItem(..)\n+                | Node::Variant(..)\n+                | Node::AnonConst(..)\n+                | Node::Pat(..),\n+        )\n+    )\n }\n \n struct MarkSymbolVisitor<'tcx> {\n@@ -500,16 +500,16 @@ struct DeadVisitor<'tcx> {\n \n impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item<'_>) -> bool {\n-        let should_warn = match item.kind {\n+        let should_warn = matches!(\n+            item.kind,\n             hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Union(..) => true,\n-            _ => false,\n-        };\n+                | hir::ItemKind::Const(..)\n+                | hir::ItemKind::Fn(..)\n+                | hir::ItemKind::TyAlias(..)\n+                | hir::ItemKind::Enum(..)\n+                | hir::ItemKind::Struct(..)\n+                | hir::ItemKind::Union(..)\n+        );\n         should_warn && !self.symbol_is_live(item.hir_id)\n     }\n "}, {"sha": "fcea1b29ec367528f47b0d429bd3694caa1a47b8", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -360,14 +360,14 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         self.add_from_pat(&arm.pat);\n+        if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n+            self.add_from_pat(pat);\n+        }\n         intravisit::walk_arm(self, arm);\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        let is_shorthand = match param.pat.kind {\n-            rustc_hir::PatKind::Struct(..) => true,\n-            _ => false,\n-        };\n+        let is_shorthand = matches!(param.pat.kind, rustc_hir::PatKind::Struct(..));\n         param.pat.each_binding(|_bm, hir_id, _x, ident| {\n             let var = if is_shorthand {\n                 Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })\n@@ -866,10 +866,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 for arm in arms {\n                     let body_succ = self.propagate_through_expr(&arm.body, succ);\n \n-                    let guard_succ = self.propagate_through_opt_expr(\n-                        arm.guard.as_ref().map(|hir::Guard::If(e)| *e),\n-                        body_succ,\n-                    );\n+                    let guard_succ = arm.guard.as_ref().map_or(body_succ, |g| match g {\n+                        hir::Guard::If(e) => self.propagate_through_expr(e, body_succ),\n+                        hir::Guard::IfLet(pat, e) => {\n+                            let let_bind = self.define_bindings_in_pat(pat, body_succ);\n+                            self.propagate_through_expr(e, let_bind)\n+                        }\n+                    });\n                     let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n                     self.merge_from_succ(ln, arm_succ);\n                 }\n@@ -1379,7 +1382,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name == kw::Invalid {\n+        if name == kw::Empty {\n             return None;\n         }\n         let name: &str = &name.as_str();"}, {"sha": "3c2462aab26b7feeeff193a4fe79b5293981bc66", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -182,28 +182,32 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 for (dep_v, stab_v) in\n                     dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n                 {\n-                    if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n-                        match dep_v.cmp(&stab_v) {\n-                            Ordering::Less => {\n-                                self.tcx.sess.span_err(\n-                                    item_sp,\n-                                    \"An API can't be stabilized \\\n-                                                                 after it is deprecated\",\n-                                );\n+                    match stab_v.parse::<u64>() {\n+                        Err(_) => {\n+                            self.tcx.sess.span_err(item_sp, \"Invalid stability version found\");\n+                            break;\n+                        }\n+                        Ok(stab_vp) => match dep_v.parse::<u64>() {\n+                            Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n+                                Ordering::Less => {\n+                                    self.tcx.sess.span_err(\n+                                        item_sp,\n+                                        \"An API can't be stabilized after it is deprecated\",\n+                                    );\n+                                    break;\n+                                }\n+                                Ordering::Equal => continue,\n+                                Ordering::Greater => break,\n+                            },\n+                            Err(_) => {\n+                                if dep_v != \"TBD\" {\n+                                    self.tcx\n+                                        .sess\n+                                        .span_err(item_sp, \"Invalid deprecation version found\");\n+                                }\n                                 break;\n                             }\n-                            Ordering::Equal => continue,\n-                            Ordering::Greater => break,\n-                        }\n-                    } else {\n-                        // Act like it isn't less because the question is now nonsensical,\n-                        // and this makes us not do anything else interesting.\n-                        self.tcx.sess.span_err(\n-                            item_sp,\n-                            \"Invalid stability or deprecation \\\n-                                                         version found\",\n-                        );\n-                        break;\n+                        },\n                     }\n                 }\n             }"}, {"sha": "1bcfdf0faf66a8850000c99443a9daf909090507", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -184,8 +184,8 @@ where\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors.\n-                for predicate in predicates.skip_binder() {\n-                    let trait_ref = match predicate {\n+                for predicate in predicates {\n+                    let trait_ref = match predicate.skip_binder() {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n                         ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n                         ty::ExistentialPredicate::AutoTrait(def_id) => {\n@@ -842,11 +842,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         let macro_module_def_id =\n             ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id).to_def_id())\n                 .unwrap();\n-        // FIXME(#71104) Should really be using just `as_local_hir_id` but\n-        // some `DefId` do not seem to have a corresponding HirId.\n         let hir_id = macro_module_def_id\n             .as_local()\n-            .and_then(|def_id| self.tcx.hir().opt_local_def_id_to_hir_id(def_id));\n+            .map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id));\n         let mut module_id = match hir_id {\n             Some(module_id) if self.tcx.hir().is_hir_id_module(module_id) => module_id,\n             // `module_id` doesn't correspond to a `mod`, return early (#63164, #65252).\n@@ -959,7 +957,7 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         in_update_syntax: bool,\n     ) {\n         // definition of the field\n-        let ident = Ident::new(kw::Invalid, use_ctxt);\n+        let ident = Ident::new(kw::Empty, use_ctxt);\n         let current_hir = self.current_item.unwrap();\n         let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {"}, {"sha": "ff52fdab19c50775f25b8e763faa5aff2c8d4732", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -60,9 +60,8 @@ pub struct DepNode<K> {\n     // * When a `DepNode::construct` is called, `arg.to_fingerprint()`\n     //   is responsible for calling `OnDiskCache::store_foreign_def_id_hash`\n     //   if needed\n-    // * When a `DepNode` is loaded from the `PreviousDepGraph`,\n-    //   then `PreviousDepGraph::index_to_node` is responsible for calling\n-    //   `tcx.register_reused_dep_path_hash`\n+    // * When we serialize the on-disk cache, `OnDiskCache::serialize` is\n+    //   responsible for calling `DepGraph::register_reused_dep_nodes`.\n     //\n     // FIXME: Enforce this by preventing manual construction of `DefNode`\n     // (e.g. add a `_priv: ()` field)"}, {"sha": "605d7ae4af67832eae5f495fad624add4ce0811f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 689, "deletions": 246, "changes": 935, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -15,6 +15,7 @@ use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n+use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n use super::debug::EdgeFilter;\n@@ -68,7 +69,7 @@ struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n-    /// current one anymore.\n+    /// current one anymore, but we do reference shared data to save space.\n     current: CurrentDepGraph<K>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n@@ -134,17 +135,61 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn query(&self) -> DepGraphQuery<K> {\n-        let data = self.data.as_ref().unwrap().current.data.lock();\n-        let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n-        let mut edges = Vec::new();\n-        for (from, edge_targets) in data.iter().map(|d| (d.node, &d.edges)) {\n-            for &edge_target in edge_targets.iter() {\n-                let to = data[edge_target].node;\n-                edges.push((from, to));\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n+        let data = data.current.data.lock();\n+        let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n+\n+        let mut nodes = Vec::with_capacity(node_count);\n+        let mut edge_list_indices = Vec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // See `serialize` for notes on the approach used here.\n+\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            match hybrid_index.into() {\n+                HybridIndex::New(new_index) => {\n+                    nodes.push(data.new.nodes[new_index]);\n+                    let edges = &data.new.edges[new_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::Red(red_index) => {\n+                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n+                    let edges = &data.red.edges[red_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::LightGreen(lg_index) => {\n+                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n+                    let edges = &data.light_green.edges[lg_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n+\n+                    let start = edge_list_data.len();\n+                    edge_list_data.extend(edges_iter);\n+                    let end = edge_list_data.len();\n+                    edge_list_indices.push((start, end));\n+                }\n             }\n         }\n \n-        DepGraphQuery::new(&nodes[..], &edges[..])\n+        debug_assert_eq!(nodes.len(), node_count);\n+        debug_assert_eq!(edge_list_indices.len(), node_count);\n+        debug_assert_eq!(edge_list_data.len(), edge_count);\n+\n+        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -201,7 +246,6 @@ impl<K: DepKind> DepGraph<K> {\n             key,\n             cx,\n             arg,\n-            false,\n             task,\n             |_key| {\n                 Some(TaskDeps {\n@@ -212,7 +256,6 @@ impl<K: DepKind> DepGraph<K> {\n                     phantom_data: PhantomData,\n                 })\n             },\n-            |data, key, fingerprint, task| data.complete_task(key, task.unwrap(), fingerprint),\n             hash_result,\n         )\n     }\n@@ -222,66 +265,69 @@ impl<K: DepKind> DepGraph<K> {\n         key: DepNode<K>,\n         cx: Ctxt,\n         arg: A,\n-        no_tcx: bool,\n         task: fn(Ctxt, A) -> R,\n         create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n-        finish_task_and_alloc_depnode: fn(\n-            &CurrentDepGraph<K>,\n-            DepNode<K>,\n-            Fingerprint,\n-            Option<TaskDeps<K>>,\n-        ) -> DepNodeIndex,\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n+            let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n+            let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n-            // In incremental mode, hash the result of the task. We don't\n-            // do anything with the hash yet, but we are computing it\n-            // anyway so that\n-            //  - we make sure that the infrastructure works and\n-            //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.create_stable_hashing_context();\n-\n-            let result = if no_tcx {\n-                task(cx, arg)\n-            } else {\n-                K::with_deps(task_deps.as_ref(), || task(cx, arg))\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n-            let dep_node_index = finish_task_and_alloc_depnode(\n-                &data.current,\n-                key,\n-                current_fingerprint.unwrap_or(Fingerprint::ZERO),\n-                task_deps.map(|lock| lock.into_inner()),\n-            );\n-\n             let print_status = cfg!(debug_assertions) && cx.debug_dep_tasks();\n \n-            // Determine the color of the new DepNode.\n-            if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n-                let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n-\n-                let color = if let Some(current_fingerprint) = current_fingerprint {\n-                    if current_fingerprint == prev_fingerprint {\n+            // Intern the new `DepNode`.\n+            let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n+                // Determine the color and index of the new `DepNode`.\n+                let (color, dep_node_index) = if let Some(current_fingerprint) = current_fingerprint\n+                {\n+                    if current_fingerprint == data.previous.fingerprint_by_index(prev_index) {\n                         if print_status {\n                             eprintln!(\"[task::green] {:?}\", key);\n                         }\n-                        DepNodeColor::Green(dep_node_index)\n+\n+                        // This is a light green node: it existed in the previous compilation,\n+                        // its query was re-executed, and it has the same result as before.\n+                        let dep_node_index =\n+                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n+\n+                        (DepNodeColor::Green(dep_node_index), dep_node_index)\n                     } else {\n                         if print_status {\n                             eprintln!(\"[task::red] {:?}\", key);\n                         }\n-                        DepNodeColor::Red\n+\n+                        // This is a red node: it existed in the previous compilation, its query\n+                        // was re-executed, but it has a different result from before.\n+                        let dep_node_index = data.current.intern_red_node(\n+                            &data.previous,\n+                            prev_index,\n+                            edges,\n+                            current_fingerprint,\n+                        );\n+\n+                        (DepNodeColor::Red, dep_node_index)\n                     }\n                 } else {\n                     if print_status {\n                         eprintln!(\"[task::unknown] {:?}\", key);\n                     }\n-                    // Mark the node as Red if we can't hash the result\n-                    DepNodeColor::Red\n+\n+                    // This is a red node, effectively: it existed in the previous compilation\n+                    // session, its query was re-executed, but it doesn't compute a result hash\n+                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                    // whether or not the result was the same as before.\n+                    let dep_node_index = data.current.intern_red_node(\n+                        &data.previous,\n+                        prev_index,\n+                        edges,\n+                        Fingerprint::ZERO,\n+                    );\n+\n+                    (DepNodeColor::Red, dep_node_index)\n                 };\n \n                 debug_assert!(\n@@ -292,12 +338,27 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-            } else if print_status {\n-                eprintln!(\"[task::new] {:?}\", key);\n-            }\n+                dep_node_index\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::new] {:?}\", key);\n+                }\n+\n+                // This is a new node: it didn't exist in the previous compilation session.\n+                data.current.intern_new_node(\n+                    &data.previous,\n+                    key,\n+                    edges,\n+                    current_fingerprint.unwrap_or(Fingerprint::ZERO),\n+                )\n+            };\n \n             (result, dep_node_index)\n         } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n             (task(cx, arg), self.next_virtual_depnode_index())\n         }\n     }\n@@ -308,13 +369,36 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n+        debug_assert!(!dep_kind.is_eval_always());\n+\n         if let Some(ref data) = self.data {\n             let task_deps = Lock::new(TaskDeps::default());\n-\n             let result = K::with_deps(Some(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n \n-            let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n+            // The dep node indices are hashed here instead of hashing the dep nodes of the\n+            // dependencies. These indices may refer to different nodes per session, but this isn't\n+            // a problem here because we that ensure the final dep node hash is per session only by\n+            // combining it with the per session random number `anon_id_seed`. This hash only need\n+            // to map the dependencies to a single value on a per session basis.\n+            let mut hasher = StableHasher::new();\n+            task_deps.reads.hash(&mut hasher);\n+\n+            let target_dep_node = DepNode {\n+                kind: dep_kind,\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+            };\n+\n+            let dep_node_index = data.current.intern_new_node(\n+                &data.previous,\n+                target_dep_node,\n+                task_deps.reads,\n+                Fingerprint::ZERO,\n+            );\n+\n             (result, dep_node_index)\n         } else {\n             (op(), self.next_virtual_depnode_index())\n@@ -331,69 +415,106 @@ impl<K: DepKind> DepGraph<K> {\n         task: fn(Ctxt, A) -> R,\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        self.with_task_impl(\n-            key,\n-            cx,\n-            arg,\n-            false,\n-            task,\n-            |_| None,\n-            |data, key, fingerprint, _| data.alloc_node(key, smallvec![], fingerprint),\n-            hash_result,\n-        )\n+        self.with_task_impl(key, cx, arg, task, |_| None, hash_result)\n     }\n \n     #[inline]\n-    pub fn read(&self, v: DepNode<K>) {\n+    pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n-            if let Some(dep_node_index) = map.get(&v).copied() {\n-                std::mem::drop(map);\n-                data.read_index(dep_node_index);\n-            } else {\n-                panic!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n-            }\n+            K::read_deps(|task_deps| {\n+                if let Some(task_deps) = task_deps {\n+                    let mut task_deps = task_deps.lock();\n+                    let task_deps = &mut *task_deps;\n+                    if cfg!(debug_assertions) {\n+                        data.current.total_read_count.fetch_add(1, Relaxed);\n+                    }\n+\n+                    // As long as we only have a low number of reads we can avoid doing a hash\n+                    // insert and potentially allocating/reallocating the hashmap\n+                    let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n+                        task_deps.reads.iter().all(|other| *other != dep_node_index)\n+                    } else {\n+                        task_deps.read_set.insert(dep_node_index)\n+                    };\n+                    if new_read {\n+                        task_deps.reads.push(dep_node_index);\n+                        if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n+                            // Fill `read_set` with what we have so far so we can use the hashset\n+                            // next time\n+                            task_deps.read_set.extend(task_deps.reads.iter().copied());\n+                        }\n+\n+                        #[cfg(debug_assertions)]\n+                        {\n+                            if let Some(target) = task_deps.node {\n+                                if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n+                                    let src = self.dep_node_of(dep_node_index);\n+                                    if forbidden_edge.test(&src, &target) {\n+                                        panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    } else if cfg!(debug_assertions) {\n+                        data.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n+                    }\n+                }\n+            })\n         }\n     }\n \n     #[inline]\n-    pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n-        if let Some(ref data) = self.data {\n-            data.read_index(dep_node_index);\n-        }\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n+        self.dep_node_index_of_opt(dep_node).unwrap()\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n-        self.data\n-            .as_ref()\n-            .unwrap()\n-            .current\n-            .node_to_node_index\n-            .get_shard_by_value(dep_node)\n-            .lock()\n-            .get(dep_node)\n-            .cloned()\n-            .unwrap()\n+    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n+        let data = self.data.as_ref().unwrap();\n+        let current = &data.current;\n+\n+        if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n+            current.prev_index_to_index.lock()[prev_index]\n+        } else {\n+            current.new_node_to_index.get_shard_by_value(dep_node).lock().get(dep_node).copied()\n+        }\n     }\n \n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        if let Some(ref data) = self.data {\n-            data.current\n-                .node_to_node_index\n-                .get_shard_by_value(&dep_node)\n-                .lock()\n-                .contains_key(dep_node)\n-        } else {\n-            false\n+        self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n+    }\n+\n+    #[inline]\n+    pub fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+        let data = data.current.data.lock();\n+\n+        match data.hybrid_indices[dep_node_index].into() {\n+            HybridIndex::New(new_index) => data.new.nodes[new_index],\n+            HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.index_to_node(data.light_green.node_indices[light_green_index])\n+            }\n+            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n         }\n     }\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let data = self.data.as_ref().expect(\"dep graph enabled\").current.data.lock();\n-        data[dep_node_index].fingerprint\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+        let data = data.current.data.lock();\n+\n+        match data.hybrid_indices[dep_node_index].into() {\n+            HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n+            HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n+            }\n+            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n+        }\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n@@ -443,30 +564,95 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph<K> {\n-        let data = self.data.as_ref().unwrap().current.data.lock();\n+    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n \n-        let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n-            data.iter().map(|d| d.fingerprint).collect();\n-        let nodes: IndexVec<SerializedDepNodeIndex, _> = data.iter().map(|d| d.node).collect();\n+        let mut edge_count = node_data.unshared_edges.len();\n \n-        let total_edge_count: usize = data.iter().map(|d| d.edges.len()).sum();\n+        for &hybrid_index in node_data.hybrid_indices.iter() {\n+            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n+                edge_count += previous.edge_targets_from(prev_index).len()\n+            }\n+        }\n \n-        let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n-        let mut edge_list_data = Vec::with_capacity(total_edge_count);\n+        edge_count\n+    }\n \n-        for (current_dep_node_index, edges) in data.iter_enumerated().map(|(i, d)| (i, &d.edges)) {\n-            let start = edge_list_data.len() as u32;\n-            // This should really just be a memcpy :/\n-            edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n-            let end = edge_list_data.len() as u32;\n+    pub fn serialize(&self) -> SerializedDepGraph<K> {\n+        type SDNI = SerializedDepNodeIndex;\n \n-            debug_assert_eq!(current_dep_node_index.index(), edge_list_indices.len());\n-            edge_list_indices.push((start, end));\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n+        let data = data.current.data.lock();\n+        let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n+\n+        let mut nodes = IndexVec::with_capacity(node_count);\n+        let mut fingerprints = IndexVec::with_capacity(node_count);\n+        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be in\n+        // `DepNodeIndex` order. The edges in `edge_list_data`, on the other\n+        // hand, don't need to be in a particular order, as long as each node\n+        // can reference its edges as a contiguous range within it. This is why\n+        // we're able to copy `unshared_edges` directly into `edge_list_data`.\n+        // It meets the above requirements, and each non-dark-green node already\n+        // knows the range of edges to reference within it, which they'll push\n+        // onto `edge_list_indices`. Dark green nodes, however, don't have their\n+        // edges in `unshared_edges`, so need to add them to `edge_list_data`.\n+\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| SDNI::new(i.index())));\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            match hybrid_index.into() {\n+                HybridIndex::New(i) => {\n+                    let new = &data.new;\n+                    nodes.push(new.nodes[i]);\n+                    fingerprints.push(new.fingerprints[i]);\n+                    let edges = &new.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::Red(i) => {\n+                    let red = &data.red;\n+                    nodes.push(previous.index_to_node(red.node_indices[i]));\n+                    fingerprints.push(red.fingerprints[i]);\n+                    let edges = &red.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::LightGreen(i) => {\n+                    let lg = &data.light_green;\n+                    nodes.push(previous.index_to_node(lg.node_indices[i]));\n+                    fingerprints.push(previous.fingerprint_by_index(lg.node_indices[i]));\n+                    let edges = &lg.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+                    fingerprints.push(previous.fingerprint_by_index(prev_index));\n+\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| prev_index_to_index[dst].as_ref().unwrap());\n+\n+                    let start = edge_list_data.len() as u32;\n+                    edge_list_data.extend(edges_iter.map(|i| SDNI::new(i.index())));\n+                    let end = edge_list_data.len() as u32;\n+                    edge_list_indices.push((start, end));\n+                }\n+            }\n         }\n \n+        debug_assert_eq!(nodes.len(), node_count);\n+        debug_assert_eq!(fingerprints.len(), node_count);\n+        debug_assert_eq!(edge_list_indices.len(), node_count);\n+        debug_assert_eq!(edge_list_data.len(), edge_count);\n         debug_assert!(edge_list_data.len() <= u32::MAX as usize);\n-        debug_assert_eq!(edge_list_data.len(), total_edge_count);\n \n         SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n     }\n@@ -540,41 +726,31 @@ impl<K: DepKind> DepGraph<K> {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(\n-                !data\n-                    .current\n-                    .node_to_node_index\n-                    .get_shard_by_value(dep_node)\n-                    .lock()\n-                    .contains_key(dep_node)\n-            );\n+            debug_assert!(!self.dep_node_exists(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n         // We never try to mark eval_always nodes as green\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n-        data.previous.debug_assert_eq(prev_dep_node_index, *dep_node);\n+        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n-        let mut current_deps = SmallVec::new();\n-\n         for &dep_dep_node_index in prev_deps {\n             let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n             match dep_dep_node_color {\n-                Some(DepNodeColor::Green(node_index)) => {\n+                Some(DepNodeColor::Green(_)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n                     debug!(\n                         \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n                             be immediately green\",\n                         dep_node,\n-                        data.previous.debug_dep_node(dep_dep_node_index),\n+                        data.previous.index_to_node(dep_dep_node_index)\n                     );\n-                    current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n                     // We found a dependency the value of which has changed\n@@ -585,20 +761,20 @@ impl<K: DepKind> DepGraph<K> {\n                         \"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n                             immediately red\",\n                         dep_node,\n-                        data.previous.debug_dep_node(dep_dep_node_index)\n+                        data.previous.index_to_node(dep_dep_node_index)\n                     );\n                     return None;\n                 }\n                 None => {\n-                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index, tcx);\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n \n                     // We don't know the state of this dependency. If it isn't\n                     // an eval_always node, let's try to mark it green recursively.\n                     if !dep_dep_node.kind.is_eval_always() {\n                         debug!(\n-                            \"try_mark_previous_green({:?}) --- state of dependency {:?} \\\n+                            \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n                                  is unknown, trying to mark it green\",\n-                            dep_node, dep_dep_node\n+                            dep_node, dep_dep_node, dep_dep_node.hash,\n                         );\n \n                         let node_index = self.try_mark_previous_green(\n@@ -607,13 +783,12 @@ impl<K: DepKind> DepGraph<K> {\n                             dep_dep_node_index,\n                             dep_dep_node,\n                         );\n-                        if let Some(node_index) = node_index {\n+                        if node_index.is_some() {\n                             debug!(\n                                 \"try_mark_previous_green({:?}) --- managed to MARK \\\n                                     dependency {:?} as green\",\n                                 dep_node, dep_dep_node\n                             );\n-                            current_deps.push(node_index);\n                             continue;\n                         }\n                     }\n@@ -628,13 +803,12 @@ impl<K: DepKind> DepGraph<K> {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n-                            Some(DepNodeColor::Green(node_index)) => {\n+                            Some(DepNodeColor::Green(_)) => {\n                                 debug!(\n                                     \"try_mark_previous_green({:?}) --- managed to \\\n                                         FORCE dependency {:?} to green\",\n                                     dep_node, dep_dep_node\n                                 );\n-                                current_deps.push(node_index);\n                             }\n                             Some(DepNodeColor::Red) => {\n                                 debug!(\n@@ -690,13 +864,9 @@ impl<K: DepKind> DepGraph<K> {\n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n         let dep_node_index = {\n-            // Copy the fingerprint from the previous graph,\n-            // so we don't have to recompute it\n-            let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n-\n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_node(*dep_node, current_deps, fingerprint)\n+            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -801,7 +971,7 @@ impl<K: DepKind> DepGraph<K> {\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n-                    let dep_node = data.previous.index_to_node(prev_index, tcx);\n+                    let dep_node = data.previous.index_to_node(prev_index);\n                     tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n@@ -813,6 +983,20 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    // Register reused dep nodes (i.e. nodes we've marked red or green) with the context.\n+    pub fn register_reused_dep_nodes<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+        let data = self.data.as_ref().unwrap();\n+        for prev_index in data.colors.values.indices() {\n+            match data.colors.get(prev_index) {\n+                Some(DepNodeColor::Red) | Some(DepNodeColor::Green(_)) => {\n+                    let dep_node = data.previous.index_to_node(prev_index);\n+                    tcx.register_reused_dep_node(&dep_node);\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+\n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)\n@@ -857,31 +1041,234 @@ pub struct WorkProduct {\n     pub saved_file: Option<String>,\n }\n \n-#[derive(Clone)]\n+// The maximum value of the follow index types leaves the upper two bits unused\n+// so that we can store multiple index types in `CompressedHybridIndex`, and use\n+// those bits to encode which index type it contains.\n+\n+// Index type for `NewDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct NewDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+// Index type for `RedDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct RedDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+// Index type for `LightGreenDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct LightGreenDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+/// Compressed representation of `HybridIndex` enum. Bits unused by the\n+/// contained index types are used to encode which index type it contains.\n+#[derive(Copy, Clone)]\n+struct CompressedHybridIndex(u32);\n+\n+impl CompressedHybridIndex {\n+    const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n+    const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n+    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n+    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n+\n+    const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n+    const INDEX_MASK: u32 = !Self::TAG_MASK;\n+}\n+\n+impl From<NewDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: NewDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::NEW_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<RedDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: RedDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::RED_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: LightGreenDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: SerializedDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n+    }\n+}\n+\n+/// Contains an index into one of several node data collections. Elsewhere, we\n+/// store `CompressedHyridIndex` instead of this to save space, but convert to\n+/// this type during processing to take advantage of the enum match ergonomics.\n+enum HybridIndex {\n+    New(NewDepNodeIndex),\n+    Red(RedDepNodeIndex),\n+    LightGreen(LightGreenDepNodeIndex),\n+    DarkGreen(SerializedDepNodeIndex),\n+}\n+\n+impl From<CompressedHybridIndex> for HybridIndex {\n+    #[inline]\n+    fn from(hybrid_index: CompressedHybridIndex) -> Self {\n+        let index = hybrid_index.0 & CompressedHybridIndex::INDEX_MASK;\n+\n+        match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n+            CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n+            CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n+            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n+                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n+            }\n+            CompressedHybridIndex::DARK_GREEN_TAG => {\n+                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+// Index type for `DepNodeData`'s edges.\n+rustc_index::newtype_index! {\n+    struct EdgeIndex { .. }\n+}\n+\n+/// Data for nodes in the current graph, divided into different collections\n+/// based on their presence in the previous graph, and if present, their color.\n+/// We divide nodes this way because different types of nodes are able to share\n+/// more or less data with the previous graph.\n+///\n+/// To enable more sharing, we distinguish between two kinds of green nodes.\n+/// Light green nodes are nodes in the previous graph that have been marked\n+/// green because we re-executed their queries and the results were the same as\n+/// in the previous session. Dark green nodes are nodes in the previous graph\n+/// that have been marked green because we were able to mark all of their\n+/// dependencies green.\n+///\n+/// Both light and dark green nodes can share the dep node and fingerprint with\n+/// the previous graph, but for light green nodes, we can't be sure that the\n+/// edges may be shared without comparing them against the previous edges, so we\n+/// store them directly (an approach in which we compare edges with the previous\n+/// edges to see if they can be shared was evaluated, but was not found to be\n+/// very profitable).\n+///\n+/// For dark green nodes, we can share everything with the previous graph, which\n+/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n+/// node in the previous graph, and why we don't have a separate collection for\n+/// dark green node data--the collection is the `PreviousDepGraph` itself.\n+///\n+/// (Note that for dark green nodes, the edges in the previous graph\n+/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n+/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n+/// can perform this conversion. It should always be possible, as by definition,\n+/// a dark green node is one whose dependencies from the previous session have\n+/// all been marked green--which means `prev_index_to_index` contains them.)\n+///\n+/// Node data is stored in parallel vectors to eliminate the padding between\n+/// elements that would be needed to satisfy alignment requirements of the\n+/// structure that would contain all of a node's data. We could group tightly\n+/// packing subsets of node data together and use fewer vectors, but for\n+/// consistency's sake, we use separate vectors for each piece of data.\n struct DepNodeData<K> {\n-    node: DepNode<K>,\n-    edges: EdgesVec,\n-    fingerprint: Fingerprint,\n+    /// Data for nodes not in previous graph.\n+    new: NewDepNodeData<K>,\n+\n+    /// Data for nodes in previous graph that have been marked red.\n+    red: RedDepNodeData,\n+\n+    /// Data for nodes in previous graph that have been marked light green.\n+    light_green: LightGreenDepNodeData,\n+\n+    // Edges for all nodes other than dark-green ones. Edges for each node\n+    // occupy a contiguous region of this collection, which a node can reference\n+    // using two indices. Storing edges this way rather than using an `EdgesVec`\n+    // for each node reduces memory consumption by a not insignificant amount\n+    // when compiling large crates. The downside is that we have to copy into\n+    // this collection the edges from the `EdgesVec`s that are built up during\n+    // query execution. But this is mostly balanced out by the more efficient\n+    // implementation of `DepGraph::serialize` enabled by this representation.\n+    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n+\n+    /// Mapping from `DepNodeIndex` to an index into a collection above.\n+    /// Indicates which of the above collections contains a node's data.\n+    ///\n+    /// This collection is wasteful in time and space during incr-full builds,\n+    /// because for those, all nodes are new. However, the waste is relatively\n+    /// small, and the maintenance cost of avoiding using this for incr-full\n+    /// builds is somewhat high and prone to bugginess. It does not seem worth\n+    /// it at the time of this writing, but we may want to revisit the idea.\n+    hybrid_indices: IndexVec<DepNodeIndex, CompressedHybridIndex>,\n+}\n+\n+/// Data for nodes not in previous graph. Since we cannot share any data with\n+/// the previous graph, so we must store all of such a node's data here.\n+struct NewDepNodeData<K> {\n+    nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n+    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n+    fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n }\n \n-/// `CurrentDepGraph` stores the dependency graph for the current session.\n-/// It will be populated as we run queries or tasks.\n+/// Data for nodes in previous graph that have been marked red. We can share the\n+/// dep node with the previous graph, but the edges may be different, and the\n+/// fingerprint is known to be different, so we store the latter two directly.\n+struct RedDepNodeData {\n+    node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n+    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n+    fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n+}\n+\n+/// Data for nodes in previous graph that have been marked green because we\n+/// re-executed their queries and the results were the same as in the previous\n+/// session. We can share the dep node and the fingerprint with the previous\n+/// graph, but the edges may be different, so we store them directly.\n+struct LightGreenDepNodeData {\n+    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n+    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n+}\n+\n+/// `CurrentDepGraph` stores the dependency graph for the current session. It\n+/// will be populated as we run queries or tasks. We never remove nodes from the\n+/// graph: they are only added.\n ///\n-/// The nodes in it are identified by an index (`DepNodeIndex`).\n-/// The data for each node is stored in its `DepNodeData`, found in the `data` field.\n+/// The nodes in it are identified by a `DepNodeIndex`. Internally, this maps to\n+/// a `HybridIndex`, which identifies which collection in the `data` field\n+/// contains a node's data. Which collection is used for a node depends on\n+/// whether the node was present in the `PreviousDepGraph`, and if so, the color\n+/// of the node. Each type of node can share more or less data with the previous\n+/// graph. When possible, we can store just the index of the node in the\n+/// previous graph, rather than duplicating its data in our own collections.\n+/// This is important, because these graph structures are some of the largest in\n+/// the compiler.\n ///\n-/// We never remove nodes from the graph: they are only added.\n+/// For the same reason, we also avoid storing `DepNode`s more than once as map\n+/// keys. The `new_node_to_index` map only contains nodes not in the previous\n+/// graph, and we map nodes in the previous graph to indices via a two-step\n+/// mapping. `PreviousDepGraph` maps from `DepNode` to `SerializedDepNodeIndex`,\n+/// and the `prev_index_to_index` vector (which is more compact and faster than\n+/// using a map) maps from `SerializedDepNodeIndex` to `DepNodeIndex`.\n ///\n-/// This struct uses two locks internally. The `data` and `node_to_node_index` fields are\n-/// locked separately. Operations that take a `DepNodeIndex` typically just access\n-/// the data field.\n+/// This struct uses three locks internally. The `data`, `new_node_to_index`,\n+/// and `prev_index_to_index` fields are locked separately. Operations that take\n+/// a `DepNodeIndex` typically just access the `data` field.\n ///\n-/// The only operation that must manipulate both locks is adding new nodes, in which case\n-/// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n-/// acquire the lock on `data.`\n+/// We only need to manipulate at most two locks simultaneously:\n+/// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n+/// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n+/// first, and `data` second.\n pub(super) struct CurrentDepGraph<K> {\n-    data: Lock<IndexVec<DepNodeIndex, DepNodeData<K>>>,\n-    node_to_node_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n+    data: Lock<DepNodeData<K>>,\n+    new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n+    prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -930,135 +1317,191 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n         // Pre-allocate the dep node structures. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n-        // session. The over-allocation is 2% plus a small constant to account\n-        // for the fact that in very small crates 2% might not be enough.\n-        let new_node_count_estimate = (prev_graph_node_count * 102) / 100 + 200;\n+        // session. The over-allocation for new nodes is 2% plus a small\n+        // constant to account for the fact that in very small crates 2% might\n+        // not be enough. The allocation for red and green node data doesn't\n+        // include a constant, as we don't want to allocate anything for these\n+        // structures during full incremental builds, where they aren't used.\n+        //\n+        // These estimates are based on the distribution of node and edge counts\n+        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n+        // fact that these benchmarks aren't perfectly representative.\n+        //\n+        // FIXME Use a collection type that doesn't copy node and edge data and\n+        // grow multiplicatively on reallocation. Without such a collection or\n+        // solution having the same effect, there is a performance hazard here\n+        // in both time and space, as growing these collections means copying a\n+        // large amount of data and doubling already large buffer capacities. A\n+        // solution for this will also mean that it's less important to get\n+        // these estimates right.\n+        let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n+        let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n+        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n+        let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n+\n+        let average_edges_per_node_estimate = 6;\n+        let unshared_edge_count_estimate = average_edges_per_node_estimate\n+            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n+\n+        // We store a large collection of these in `prev_index_to_index` during\n+        // non-full incremental builds, and want to ensure that the element size\n+        // doesn't inadvertently increase.\n+        static_assert_size!(Option<DepNodeIndex>, 4);\n \n         CurrentDepGraph {\n-            data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n-            node_to_node_index: Sharded::new(|| {\n+            data: Lock::new(DepNodeData {\n+                new: NewDepNodeData {\n+                    nodes: IndexVec::with_capacity(new_node_count_estimate),\n+                    edges: IndexVec::with_capacity(new_node_count_estimate),\n+                    fingerprints: IndexVec::with_capacity(new_node_count_estimate),\n+                },\n+                red: RedDepNodeData {\n+                    node_indices: IndexVec::with_capacity(red_node_count_estimate),\n+                    edges: IndexVec::with_capacity(red_node_count_estimate),\n+                    fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n+                },\n+                light_green: LightGreenDepNodeData {\n+                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n+                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n+                },\n+                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n+                hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n+            }),\n+            new_node_to_index: Sharded::new(|| {\n                 FxHashMap::with_capacity_and_hasher(\n                     new_node_count_estimate / sharded::SHARDS,\n                     Default::default(),\n                 )\n             }),\n+            prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n-    fn complete_task(\n+    fn intern_new_node(\n         &self,\n-        node: DepNode<K>,\n-        task_deps: TaskDeps<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        dep_node: DepNode<K>,\n+        edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        self.alloc_node(node, task_deps.reads, fingerprint)\n-    }\n-\n-    fn complete_anon_task(&self, kind: K, task_deps: TaskDeps<K>) -> DepNodeIndex {\n-        debug_assert!(!kind.is_eval_always());\n-\n-        let mut hasher = StableHasher::new();\n-\n-        // The dep node indices are hashed here instead of hashing the dep nodes of the\n-        // dependencies. These indices may refer to different nodes per session, but this isn't\n-        // a problem here because we that ensure the final dep node hash is per session only by\n-        // combining it with the per session random number `anon_id_seed`. This hash only need\n-        // to map the dependencies to a single value on a per session basis.\n-        task_deps.reads.hash(&mut hasher);\n-\n-        let target_dep_node = DepNode {\n-            kind,\n-\n-            // Fingerprint::combine() is faster than sending Fingerprint\n-            // through the StableHasher (at least as long as StableHasher\n-            // is so slow).\n-            hash: self.anon_id_seed.combine(hasher.finish()).into(),\n-        };\n+        debug_assert!(\n+            prev_graph.node_to_index_opt(&dep_node).is_none(),\n+            \"node in previous graph should be interned using one \\\n+            of `intern_red_node`, `intern_light_green_node`, etc.\"\n+        );\n \n-        self.intern_node(target_dep_node, task_deps.reads, Fingerprint::ZERO)\n+        match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                let data = &mut *self.data.lock();\n+                let new_index = data.new.nodes.push(dep_node);\n+                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n+                data.new.fingerprints.push(fingerprint);\n+                let dep_node_index = data.hybrid_indices.push(new_index.into());\n+                entry.insert(dep_node_index);\n+                dep_node_index\n+            }\n+        }\n     }\n \n-    fn alloc_node(\n+    fn intern_red_node(\n         &self,\n-        dep_node: DepNode<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        debug_assert!(\n-            !self.node_to_node_index.get_shard_by_value(&dep_node).lock().contains_key(&dep_node)\n-        );\n-        self.intern_node(dep_node, edges, fingerprint)\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let data = &mut *self.data.lock();\n+                let red_index = data.red.node_indices.push(prev_index);\n+                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n+                data.red.fingerprints.push(fingerprint);\n+                let dep_node_index = data.hybrid_indices.push(red_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n+                dep_node_index\n+            }\n+        }\n     }\n \n-    fn intern_node(\n+    fn intern_light_green_node(\n         &self,\n-        dep_node: DepNode<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n-            Entry::Occupied(entry) => *entry.get(),\n-            Entry::Vacant(entry) => {\n-                let mut data = self.data.lock();\n-                let dep_node_index = DepNodeIndex::new(data.len());\n-                data.push(DepNodeData { node: dep_node, edges, fingerprint });\n-                entry.insert(dep_node_index);\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let data = &mut *self.data.lock();\n+                let light_green_index = data.light_green.node_indices.push(prev_index);\n+                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n+                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n                 dep_node_index\n             }\n         }\n     }\n-}\n \n-impl<K: DepKind> DepGraphData<K> {\n-    #[inline(never)]\n-    fn read_index(&self, source: DepNodeIndex) {\n-        K::read_deps(|task_deps| {\n-            if let Some(task_deps) = task_deps {\n-                let mut task_deps = task_deps.lock();\n-                let task_deps = &mut *task_deps;\n-                if cfg!(debug_assertions) {\n-                    self.current.total_read_count.fetch_add(1, Relaxed);\n-                }\n+    fn intern_dark_green_node(\n+        &self,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n+    ) -> DepNodeIndex {\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n \n-                // As long as we only have a low number of reads we can avoid doing a hash\n-                // insert and potentially allocating/reallocating the hashmap\n-                let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n-                    task_deps.reads.iter().all(|other| *other != source)\n-                } else {\n-                    task_deps.read_set.insert(source)\n-                };\n-                if new_read {\n-                    task_deps.reads.push(source);\n-                    if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n-                        // Fill `read_set` with what we have so far so we can use the hashset next\n-                        // time\n-                        task_deps.read_set.extend(task_deps.reads.iter().copied());\n-                    }\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n \n-                    #[cfg(debug_assertions)]\n-                    {\n-                        if let Some(target) = task_deps.node {\n-                            let data = self.current.data.lock();\n-                            if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n-                                let source = data[source].node;\n-                                if forbidden_edge.test(&source, &target) {\n-                                    panic!(\"forbidden edge {:?} -> {:?} created\", source, target)\n-                                }\n-                            }\n-                        }\n-                    }\n-                } else if cfg!(debug_assertions) {\n-                    self.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n-                }\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let mut data = self.data.lock();\n+                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n+                dep_node_index\n             }\n-        })\n+        }\n+    }\n+\n+    #[inline]\n+    fn debug_assert_not_in_new_nodes(\n+        &self,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n+    ) {\n+        let node = &prev_graph.index_to_node(prev_index);\n+        debug_assert!(\n+            !self.new_node_to_index.get_shard_by_value(node).lock().contains_key(node),\n+            \"node from previous graph present in new node collection\"\n+        );\n     }\n }\n \n+#[inline]\n+fn add_edges<I: Idx>(\n+    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n+    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n+    new_edges: EdgesVec,\n+) {\n+    let start = edges.next_index();\n+    edges.extend(new_edges);\n+    let end = edges.next_index();\n+    edge_indices.push(start..end);\n+}\n+\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;"}, {"sha": "da0b5aad6c811493e3a7954925f11469c76eee4a", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -15,7 +15,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_span::def_id::DefPathHash;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -33,7 +32,7 @@ pub trait DepContext: Copy {\n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n \n-    fn register_reused_dep_path_hash(&self, hash: DefPathHash);\n+    fn register_reused_dep_node(&self, dep_node: &DepNode<Self::DepKind>);\n \n     /// Return whether the current session is tainted by errors.\n     fn has_errors_or_delayed_span_bugs(&self) -> bool;"}, {"sha": "29357ce9449ce26f48df11c3ac0c12c743efa0a2", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,9 +1,7 @@\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::{DepKind, DepNode};\n-use crate::dep_graph::DepContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::def_id::DefPathHash;\n \n #[derive(Debug, Encodable, Decodable)]\n pub struct PreviousDepGraph<K: DepKind> {\n@@ -33,44 +31,7 @@ impl<K: DepKind> PreviousDepGraph<K> {\n     }\n \n     #[inline]\n-    pub fn index_to_node<CTX: DepContext<DepKind = K>>(\n-        &self,\n-        dep_node_index: SerializedDepNodeIndex,\n-        tcx: CTX,\n-    ) -> DepNode<K> {\n-        let dep_node = self.data.nodes[dep_node_index];\n-        // We have just loaded a deserialized `DepNode` from the previous\n-        // compilation session into the current one. If this was a foreign `DefId`,\n-        // then we stored additional information in the incr comp cache when we\n-        // initially created its fingerprint (see `DepNodeParams::to_fingerprint`)\n-        // We won't be calling `to_fingerprint` again for this `DepNode` (we no longer\n-        // have the original value), so we need to copy over this additional information\n-        // from the old incremental cache into the new cache that we serialize\n-        // and the end of this compilation session.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            tcx.register_reused_dep_path_hash(DefPathHash(dep_node.hash.into()));\n-        }\n-        dep_node\n-    }\n-\n-    /// When debug assertions are enabled, asserts that the dep node at `dep_node_index` is equal to `dep_node`.\n-    /// This method should be preferred over manually calling `index_to_node`.\n-    /// Calls to `index_to_node` may affect global state, so gating a call\n-    /// to `index_to_node` on debug assertions could cause behavior changes when debug assertions\n-    /// are enabled.\n-    #[inline]\n-    pub fn debug_assert_eq(&self, dep_node_index: SerializedDepNodeIndex, dep_node: DepNode<K>) {\n-        debug_assert_eq!(self.data.nodes[dep_node_index], dep_node);\n-    }\n-\n-    /// Obtains a debug-printable version of the `DepNode`.\n-    /// See `debug_assert_eq` for why this should be preferred over manually\n-    /// calling `dep_node_index`\n-    pub fn debug_dep_node(&self, dep_node_index: SerializedDepNodeIndex) -> impl std::fmt::Debug {\n-        // We're returning the `DepNode` without calling `register_reused_dep_path_hash`,\n-        // but `impl Debug` return type means that it can only be used for debug printing.\n-        // So, there's no risk of calls trying to create new dep nodes that have this\n-        // node as a dependency\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n         self.data.nodes[dep_node_index]\n     }\n "}, {"sha": "cc25d08cb54f43797fe4f526ed772db7b3e8c833", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -9,17 +9,23 @@ pub struct DepGraphQuery<K> {\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(nodes: &[DepNode<K>], edges: &[(DepNode<K>, DepNode<K>)]) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n+    pub fn new(\n+        nodes: &[DepNode<K>],\n+        edge_list_indices: &[(usize, usize)],\n+        edge_list_data: &[usize],\n+    ) -> DepGraphQuery<K> {\n+        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n             indices.insert(*node, graph.add_node(*node));\n         }\n \n-        for &(ref source, ref target) in edges {\n-            let source = indices[source];\n-            let target = indices[target];\n-            graph.add_edge(source, target, ());\n+        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n+            for &target in &edge_list_data[start..end] {\n+                let source = indices[&nodes[source]];\n+                let target = indices[&nodes[target]];\n+                graph.add_edge(source, target, ());\n+            }\n         }\n \n         DepGraphQuery { graph, indices }"}, {"sha": "28e074069185206d840ae103d25930c1fe10defc", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,8 +4,13 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n+// The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n+// unused so that we can store multiple index types in `CompressedHybridIndex`,\n+// and use those bits to encode which index type it contains.\n rustc_index::newtype_index! {\n-    pub struct SerializedDepNodeIndex { .. }\n+    pub struct SerializedDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n }\n \n /// Data for use when recompiling the **current crate**."}, {"sha": "c5f783e84a91ec610c20166c8ccba9c13ac7242e", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -185,15 +185,15 @@ impl<'a> Resolver<'a> {\n \n     crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         match res {\n-            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n+            Res::Def(DefKind::Macro(..), def_id) => Some(self.get_macro_by_def_id(def_id)),\n             Res::NonMacroAttr(attr_kind) => Some(self.non_macro_attr(attr_kind.is_used())),\n             _ => None,\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n-            return Some(ext.clone());\n+            return ext.clone();\n         }\n \n         let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n         });\n \n         self.macro_map.insert(def_id, ext.clone());\n-        Some(ext)\n+        ext\n     }\n \n     crate fn build_reduced_graph(\n@@ -258,7 +258,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 Ok(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)))\n             }\n             ast::VisibilityKind::Inherited => {\n-                Ok(ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id))\n+                if matches!(self.parent_scope.module.kind, ModuleKind::Def(DefKind::Enum, _, _)) {\n+                    // Any inherited visibility resolved directly inside an enum\n+                    // (e.g. variants or fields) inherits from the visibility of the enum.\n+                    let parent_enum = self.parent_scope.module.def_id().unwrap().expect_local();\n+                    Ok(self.r.visibilities[&parent_enum])\n+                } else {\n+                    // If it's not in an enum, its visibility is restricted to the `mod` item\n+                    // that it's defined in.\n+                    Ok(ty::Visibility::Restricted(self.parent_scope.module.normal_ancestor_id))\n+                }\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -333,7 +342,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let field_names = vdata\n             .fields()\n             .iter()\n-            .map(|field| respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name)))\n+            .map(|field| respan(field.span, field.ident.map_or(kw::Empty, |ident| ident.name)))\n             .collect();\n         self.insert_field_names(def_id, field_names);\n     }\n@@ -516,9 +525,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n-                        // in `source` breaks `src/test/compile-fail/import-crate-var.rs`,\n+                        // in `source` breaks `src/test/ui/imports/import-crate-var.rs`,\n                         // while the current crate doesn't have a valid `crate_name`.\n-                        if crate_name != kw::Invalid {\n+                        if crate_name != kw::Empty {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident { name: kw::PathRoot, span: source.ident.span },\n@@ -647,7 +656,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &'b Item) {\n-        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Invalid {\n+        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Empty {\n             // Fake crate root item from expand.\n             return;\n         }"}, {"sha": "48bce88439424524a678b10dd90abe0c60a6893e", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         // information we encapsulate into, the better\n         let def_data = match &i.kind {\n             ItemKind::Impl { .. } => DefPathData::Impl,\n-            ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n+            ItemKind::Mod(..) if i.ident.name == kw::Empty => {\n                 // Fake crate root item from expand.\n                 return visit::walk_item(self, i);\n             }"}, {"sha": "dd1874debbd96afe9a2c55def400e5925c084371", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -29,7 +29,7 @@ use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n-use std::collections::BTreeSet;\n+use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n use tracing::debug;\n \n@@ -953,8 +953,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             });\n                         };\n \n-                        for item in trait_items {\n-                            this.with_trait_items(trait_items, |this| {\n+                        this.with_trait_items(trait_items, |this| {\n+                            for item in trait_items {\n                                 match &item.kind {\n                                     AssocItemKind::Const(_, ty, default) => {\n                                         this.visit_ty(ty);\n@@ -983,8 +983,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         panic!(\"unexpanded macro in resolve!\")\n                                     }\n                                 };\n-                            });\n-                        }\n+                            }\n+                        });\n                     });\n                 });\n             }\n@@ -1060,36 +1060,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 continue;\n             }\n \n-            let def_kind = match param.kind {\n-                GenericParamKind::Type { .. } => DefKind::TyParam,\n-                GenericParamKind::Const { .. } => DefKind::ConstParam,\n-                _ => unreachable!(),\n-            };\n-\n             let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n-            if seen_bindings.contains_key(&ident) {\n-                let span = seen_bindings.get(&ident).unwrap();\n-                let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, *span);\n-                self.report_error(param.ident.span, err);\n+            match seen_bindings.entry(ident) {\n+                Entry::Occupied(entry) => {\n+                    let span = *entry.get();\n+                    let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n+                    self.report_error(param.ident.span, err);\n+                }\n+                Entry::Vacant(entry) => {\n+                    entry.insert(param.ident.span);\n+                }\n             }\n-            seen_bindings.entry(ident).or_insert(param.ident.span);\n \n             // Plain insert (no renaming).\n-            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n-\n-            match param.kind {\n-                GenericParamKind::Type { .. } => {\n-                    function_type_rib.bindings.insert(ident, res);\n-                    self.r.record_partial_res(param.id, PartialRes::new(res));\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    function_value_rib.bindings.insert(ident, res);\n-                    self.r.record_partial_res(param.id, PartialRes::new(res));\n-                }\n+            let (rib, def_kind) = match param.kind {\n+                GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n+                GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n                 _ => unreachable!(),\n-            }\n+            };\n+            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n+            self.r.record_partial_res(param.id, PartialRes::new(res));\n+            rib.bindings.insert(ident, res);\n         }\n \n         self.ribs[ValueNS].push(function_value_rib);\n@@ -1158,13 +1151,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// When evaluating a `trait` use its associated types' idents for suggestions in E0412.\n     fn with_trait_items<T>(\n         &mut self,\n-        trait_items: &'ast Vec<P<AssocItem>>,\n+        trait_items: &'ast [P<AssocItem>],\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n-        let trait_assoc_items = replace(\n-            &mut self.diagnostic_metadata.current_trait_assoc_items,\n-            Some(&trait_items[..]),\n-        );\n+        let trait_assoc_items =\n+            replace(&mut self.diagnostic_metadata.current_trait_assoc_items, Some(&trait_items));\n         let result = f(self);\n         self.diagnostic_metadata.current_trait_assoc_items = trait_assoc_items;\n         result\n@@ -1648,7 +1639,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n \n         // Record as bound if it's valid:\n-        let ident_valid = ident.name != kw::Invalid;\n+        let ident_valid = ident.name != kw::Empty;\n         if ident_valid {\n             bindings.last_mut().unwrap().1.insert(ident);\n         }\n@@ -1778,7 +1769,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             path\n         );\n         let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n@@ -1881,7 +1871,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             crate_lint,\n         ) {\n             Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n-                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                if source.is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err\n+                {\n                     partial_res\n                 } else {\n                     report_errors(self, Some(partial_res.base_res()))\n@@ -1898,11 +1889,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n-\n-                std_path.extend(path);\n-\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                    let mut std_path = Vec::with_capacity(1 + path.len());\n+\n+                    std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n+                    std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n                         self.resolve_path(&std_path, Some(ns), false, span, CrateLint::No)\n                     {\n@@ -1983,7 +1974,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n \n-        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n+        for (i, &ns) in [primary_ns, TypeNS, ValueNS].iter().enumerate() {\n             if i == 0 || ns != primary_ns {\n                 match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n                     Some(partial_res)\n@@ -1993,7 +1984,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     }\n                     partial_res => {\n                         if fin_res.is_none() {\n-                            fin_res = partial_res\n+                            fin_res = partial_res;\n                         }\n                     }\n                 }"}, {"sha": "7d8f112af8a51d46696dc1bb27658d2b01746bce", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -542,6 +542,26 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 err.span_label(base_span, fallback_label);\n             }\n         }\n+        if let Some(err_code) = &err.code {\n+            if err_code == &rustc_errors::error_code!(E0425) {\n+                for label_rib in &self.label_ribs {\n+                    for (label_ident, _) in &label_rib.bindings {\n+                        if format!(\"'{}\", ident) == label_ident.to_string() {\n+                            let msg = \"a label with a similar name exists\";\n+                            // FIXME: consider only emitting this suggestion if a label would be valid here\n+                            // which is pretty much only the case for `break` expressions.\n+                            err.span_suggestion(\n+                                span,\n+                                &msg,\n+                                label_ident.name.to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         (err, candidates)\n     }\n \n@@ -1633,17 +1653,14 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         for missing in &self.missing_named_lifetime_spots {\n             match missing {\n                 MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) =\n-                        generics.params.iter().find(|p| match p.kind {\n-                            hir::GenericParamKind::Type {\n-                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                ..\n-                            } => false,\n-                            hir::GenericParamKind::Lifetime {\n-                                kind: hir::LifetimeParamKind::Elided,\n-                            } => false,\n-                            _ => true,\n-                        }) {\n+                    let (span, sugg) = if let Some(param) = generics.params.iter().find(|p| {\n+                        !matches!(p.kind, hir::GenericParamKind::Type {\n+                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                            ..\n+                        } | hir::GenericParamKind::Lifetime {\n+                            kind: hir::LifetimeParamKind::Elided,\n+                        })\n+                    }) {\n                         (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n                     } else {\n                         suggests_in_band = true;\n@@ -1965,8 +1982,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n     }\n \n-    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics` so\n-    /// this function will emit an error if `min_const_generics` is enabled, the body identified by\n+    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n+    /// This function will emit an error if `const_generics` is not enabled, the body identified by\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n     crate fn maybe_emit_forbidden_non_static_lifetime_error(\n         &self,\n@@ -1982,7 +1999,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             hir::LifetimeName::Implicit | hir::LifetimeName::Static | hir::LifetimeName::Underscore\n         );\n \n-        if self.tcx.features().min_const_generics && is_anon_const && !is_allowed_lifetime {\n+        if !self.tcx.lazy_normalization() && is_anon_const && !is_allowed_lifetime {\n             feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::const_generics,"}, {"sha": "d5ba6f3b53b211b968a4600c86262a7a1903dbf0", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1769,8 +1769,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let result = loop {\n             match *scope {\n                 Scope::Body { id, s } => {\n-                    // Non-static lifetimes are prohibited in anonymous constants under\n-                    // `min_const_generics`.\n+                    // Non-static lifetimes are prohibited in anonymous constants without\n+                    // `const_generics`.\n                     self.maybe_emit_forbidden_non_static_lifetime_error(id, lifetime_ref);\n \n                     outermost_body = Some(id);"}, {"sha": "ca30d90e6ad1d6a9c228ebe172d8e3030e3a08aa", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -403,6 +403,7 @@ enum PathResult<'a> {\n     },\n }\n \n+#[derive(Debug)]\n enum ModuleKind {\n     /// An anonymous module; e.g., just a block.\n     ///\n@@ -1181,12 +1182,12 @@ impl<'a> Resolver<'a> {\n     ) -> Resolver<'a> {\n         let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n         let root_def_id = root_local_def_id.to_def_id();\n-        let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n+        let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n-        let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n+        let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n         let empty_module = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: true,\n             ..ModuleData::new(\n@@ -1796,7 +1797,7 @@ impl<'a> Resolver<'a> {\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n-        if ident.name == kw::Invalid {\n+        if ident.name == kw::Empty {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n         let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n@@ -1990,14 +1991,13 @@ impl<'a> Resolver<'a> {\n             {\n                 // The macro is a proc macro derive\n                 if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                    if let Some(ext) = self.get_macro_by_def_id(def_id) {\n-                        if !ext.is_builtin\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n-                        {\n-                            *poisoned = Some(node_id);\n-                            return module.parent;\n-                        }\n+                    let ext = self.get_macro_by_def_id(def_id);\n+                    if !ext.is_builtin\n+                        && ext.macro_kind() == MacroKind::Derive\n+                        && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n+                    {\n+                        *poisoned = Some(node_id);\n+                        return module.parent;\n                     }\n                 }\n             }\n@@ -2415,7 +2415,10 @@ impl<'a> Resolver<'a> {\n                     } else if i == 0 {\n                         if ident\n                             .name\n-                            .with(|n| n.chars().next().map_or(false, |c| c.is_ascii_uppercase()))\n+                            .as_str()\n+                            .chars()\n+                            .next()\n+                            .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n                             (format!(\"use of undeclared type `{}`\", ident), None)\n                         } else {\n@@ -2623,8 +2626,12 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                         ConstantItemRibKind(trivial) => {\n+                            let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !trivial && self.session.features_untracked().min_const_generics {\n+                            if !(trivial\n+                                || features.const_generics\n+                                || features.lazy_normalization_consts)\n+                            {\n                                 // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n                                 // we can't easily tell if it's generic at this stage, so we instead remember\n                                 // this and then enforce the self type to be concrete later on.\n@@ -2712,8 +2719,12 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                         ConstantItemRibKind(trivial) => {\n+                            let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !trivial && self.session.features_untracked().min_const_generics {\n+                            if !(trivial\n+                                || features.const_generics\n+                                || features.lazy_normalization_consts)\n+                            {\n                                 if record_used {\n                                     self.report_error(\n                                         span,"}, {"sha": "5ad7c83ca36afd8b140730a2640bf503632e84d7", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -160,7 +160,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         hygiene::update_dollar_crate_names(|ctxt| {\n             let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));\n             match self.resolve_crate_root(ident).kind {\n-                ModuleKind::Def(.., name) if name != kw::Invalid => name,\n+                ModuleKind::Def(.., name) if name != kw::Empty => name,\n                 _ => kw::Crate,\n             }\n         });"}, {"sha": "056c0b3d9d513f8fa5813f76af3dae424f9e44ae", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -825,7 +825,7 @@ impl<'tcx> SaveContext<'tcx> {\n         for attr in attrs {\n             if let Some(val) = attr.doc_str() {\n                 // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n-                result.push_str(&beautify_doc_string(val));\n+                result.push_str(&beautify_doc_string(val).as_str());\n                 result.push('\\n');\n             } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 if let Some(meta_list) = attr.meta_item_list() {"}, {"sha": "ac1cdc6ad45f20338a8ad3ba8d55bed26304ab11", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -13,7 +13,7 @@ Core encoding and decoding interfaces.\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n-#![feature(min_const_generics)]\n+#![cfg_attr(bootstrap, feature(min_const_generics))]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]\n "}, {"sha": "c9ddcbdb5f5cc71bc4158e091b561ce90d867d69", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 135, "deletions": 63, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -221,6 +221,23 @@ pub enum DebugInfo {\n     Full,\n }\n \n+/// Some debuginfo requires link-time relocation and some does not. LLVM can partition the debuginfo\n+/// into sections depending on whether or not it requires link-time relocation. Split DWARF\n+/// provides a mechanism which allows the linker to skip the sections which don't require link-time\n+/// relocation - either by putting those sections into DWARF object files, or keeping them in the\n+/// object file in such a way that the linker will skip them.\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n+pub enum SplitDwarfKind {\n+    /// Disabled.\n+    None,\n+    /// Sections which do not require relocation are written into the object file but ignored\n+    /// by the linker.\n+    Single,\n+    /// Sections which do not require relocation are written into a DWARF object (`.dwo`) file,\n+    /// which is skipped by the linker by virtue of being a different file.\n+    Split,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n #[derive(Encodable, Decodable)]\n pub enum OutputType {\n@@ -533,6 +550,7 @@ impl_stable_hash_via_hash!(OutputFilenames);\n \n pub const RLINK_EXT: &str = \"rlink\";\n pub const RUST_CGU_EXT: &str = \"rcgu\";\n+pub const DWARF_OBJECT_EXT: &str = \"dwo\";\n \n impl OutputFilenames {\n     pub fn new(\n@@ -566,7 +584,12 @@ impl OutputFilenames {\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n \n-    /// Like temp_path, but also supports things where there is no corresponding\n+    /// Like `temp_path`, but specifically for dwarf objects.\n+    pub fn temp_path_dwo(&self, codegen_unit_name: Option<&str>) -> PathBuf {\n+        self.temp_path_ext(DWARF_OBJECT_EXT, codegen_unit_name)\n+    }\n+\n+    /// Like `temp_path`, but also supports things where there is no corresponding\n     /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let mut extension = String::new();\n@@ -593,6 +616,37 @@ impl OutputFilenames {\n         path.set_extension(extension);\n         path\n     }\n+\n+    /// Returns the name of the Split DWARF file - this can differ depending on which Split DWARF\n+    /// mode is being used, which is the logic that this function is intended to encapsulate.\n+    pub fn split_dwarf_filename(\n+        &self,\n+        split_dwarf_kind: SplitDwarfKind,\n+        cgu_name: Option<&str>,\n+    ) -> Option<PathBuf> {\n+        self.split_dwarf_path(split_dwarf_kind, cgu_name)\n+            .map(|path| path.strip_prefix(&self.out_directory).unwrap_or(&path).to_path_buf())\n+    }\n+\n+    /// Returns the path for the Split DWARF file - this can differ depending on which Split DWARF\n+    /// mode is being used, which is the logic that this function is intended to encapsulate.\n+    pub fn split_dwarf_path(\n+        &self,\n+        split_dwarf_kind: SplitDwarfKind,\n+        cgu_name: Option<&str>,\n+    ) -> Option<PathBuf> {\n+        let obj_out = self.temp_path(OutputType::Object, cgu_name);\n+        let dwo_out = self.temp_path_dwo(cgu_name);\n+        match split_dwarf_kind {\n+            SplitDwarfKind::None => None,\n+            // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n+            // (pointing at the path which is being determined here). Use the path to the current\n+            // object file.\n+            SplitDwarfKind::Single => Some(obj_out),\n+            // Split mode emits the DWARF into a different file, use that path.\n+            SplitDwarfKind::Split => Some(dwo_out),\n+        }\n+    }\n }\n \n pub fn host_triple() -> &'static str {\n@@ -692,6 +746,10 @@ impl DebuggingOptions {\n             deduplicate_diagnostics: self.deduplicate_diagnostics,\n         }\n     }\n+\n+    pub fn get_symbol_mangling_version(&self) -> SymbolManglingVersion {\n+        self.symbol_mangling_version.unwrap_or(SymbolManglingVersion::Legacy)\n+    }\n }\n \n // The type of entry function, so users can have their own entry functions\n@@ -1296,8 +1354,10 @@ fn parse_output_types(\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n             for output_type in list.split(',') {\n-                let mut parts = output_type.splitn(2, '=');\n-                let shorthand = parts.next().unwrap();\n+                let (shorthand, path) = match output_type.split_once('=') {\n+                    None => (output_type, None),\n+                    Some((shorthand, path)) => (shorthand, Some(PathBuf::from(path))),\n+                };\n                 let output_type = OutputType::from_shorthand(shorthand).unwrap_or_else(|| {\n                     early_error(\n                         error_format,\n@@ -1308,7 +1368,6 @@ fn parse_output_types(\n                         ),\n                     )\n                 });\n-                let path = parts.next().map(PathBuf::from);\n                 output_types.insert(output_type, path);\n             }\n         }\n@@ -1432,7 +1491,7 @@ fn parse_target_triple(matches: &getopts::Matches, error_format: ErrorOutputType\n                 early_error(error_format, &format!(\"target file {:?} does not exist\", path))\n             })\n         }\n-        Some(target) => TargetTriple::TargetTriple(target),\n+        Some(target) => TargetTriple::from_alias(target),\n         _ => TargetTriple::from_triple(host_triple()),\n     }\n }\n@@ -1452,11 +1511,10 @@ fn parse_opt_level(\n     let max_c = matches\n         .opt_strs_pos(\"C\")\n         .into_iter()\n-        .flat_map(\n-            |(i, s)| {\n-                if let Some(\"opt-level\") = s.splitn(2, '=').next() { Some(i) } else { None }\n-            },\n-        )\n+        .flat_map(|(i, s)| {\n+            // NB: This can match a string without `=`.\n+            if let Some(\"opt-level\") = s.splitn(2, '=').next() { Some(i) } else { None }\n+        })\n         .max();\n     if max_o > max_c {\n         OptLevel::Default\n@@ -1491,11 +1549,10 @@ fn select_debuginfo(\n     let max_c = matches\n         .opt_strs_pos(\"C\")\n         .into_iter()\n-        .flat_map(\n-            |(i, s)| {\n-                if let Some(\"debuginfo\") = s.splitn(2, '=').next() { Some(i) } else { None }\n-            },\n-        )\n+        .flat_map(|(i, s)| {\n+            // NB: This can match a string without `=`.\n+            if let Some(\"debuginfo\") = s.splitn(2, '=').next() { Some(i) } else { None }\n+        })\n         .max();\n     if max_g > max_c {\n         DebugInfo::Full\n@@ -1528,23 +1585,26 @@ fn parse_libs(\n         .map(|s| {\n             // Parse string of the form \"[KIND=]lib[:new_name]\",\n             // where KIND is one of \"dylib\", \"framework\", \"static\".\n-            let mut parts = s.splitn(2, '=');\n-            let kind = parts.next().unwrap();\n-            let (name, kind) = match (parts.next(), kind) {\n-                (None, name) => (name, NativeLibKind::Unspecified),\n-                (Some(name), \"dylib\") => (name, NativeLibKind::Dylib),\n-                (Some(name), \"framework\") => (name, NativeLibKind::Framework),\n-                (Some(name), \"static\") => (name, NativeLibKind::StaticBundle),\n-                (Some(name), \"static-nobundle\") => (name, NativeLibKind::StaticNoBundle),\n-                (_, s) => {\n-                    early_error(\n-                        error_format,\n-                        &format!(\n-                            \"unknown library kind `{}`, expected \\\n-                             one of dylib, framework, or static\",\n-                            s\n-                        ),\n-                    );\n+            let (name, kind) = match s.split_once('=') {\n+                None => (s, NativeLibKind::Unspecified),\n+                Some((kind, name)) => {\n+                    let kind = match kind {\n+                        \"dylib\" => NativeLibKind::Dylib,\n+                        \"framework\" => NativeLibKind::Framework,\n+                        \"static\" => NativeLibKind::StaticBundle,\n+                        \"static-nobundle\" => NativeLibKind::StaticNoBundle,\n+                        s => {\n+                            early_error(\n+                                error_format,\n+                                &format!(\n+                                    \"unknown library kind `{}`, expected \\\n+                                     one of dylib, framework, or static\",\n+                                    s\n+                                ),\n+                            );\n+                        }\n+                    };\n+                    (name.to_string(), kind)\n                 }\n             };\n             if kind == NativeLibKind::StaticNoBundle\n@@ -1556,10 +1616,11 @@ fn parse_libs(\n                      accepted on the nightly compiler\",\n                 );\n             }\n-            let mut name_parts = name.splitn(2, ':');\n-            let name = name_parts.next().unwrap();\n-            let new_name = name_parts.next();\n-            (name.to_owned(), new_name.map(|n| n.to_owned()), kind)\n+            let (name, new_name) = match name.split_once(':') {\n+                None => (name, None),\n+                Some((name, new_name)) => (name.to_string(), Some(new_name.to_owned())),\n+            };\n+            (name, new_name, kind)\n         })\n         .collect()\n }\n@@ -1580,20 +1641,13 @@ pub fn parse_externs(\n     let is_unstable_enabled = debugging_opts.unstable_options;\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n     for arg in matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts\n-            .next()\n-            .unwrap_or_else(|| early_error(error_format, \"--extern value must not be empty\"));\n-        let path = parts.next().map(|s| s.to_string());\n-\n-        let mut name_parts = name.splitn(2, ':');\n-        let first_part = name_parts.next();\n-        let second_part = name_parts.next();\n-        let (options, name) = match (first_part, second_part) {\n-            (Some(opts), Some(name)) => (Some(opts), name),\n-            (Some(name), None) => (None, name),\n-            (None, None) => early_error(error_format, \"--extern name must not be empty\"),\n-            _ => unreachable!(),\n+        let (name, path) = match arg.split_once('=') {\n+            None => (arg, None),\n+            Some((name, path)) => (name.to_string(), Some(path.to_string())),\n+        };\n+        let (options, name) = match name.split_once(':') {\n+            None => (None, name),\n+            Some((opts, name)) => (Some(opts), name.to_string()),\n         };\n \n         let entry = externs.entry(name.to_owned());\n@@ -1682,17 +1736,12 @@ fn parse_remap_path_prefix(\n     matches\n         .opt_strs(\"remap-path-prefix\")\n         .into_iter()\n-        .map(|remap| {\n-            let mut parts = remap.rsplitn(2, '='); // reverse iterator\n-            let to = parts.next();\n-            let from = parts.next();\n-            match (from, to) {\n-                (Some(from), Some(to)) => (PathBuf::from(from), PathBuf::from(to)),\n-                _ => early_error(\n-                    error_format,\n-                    \"--remap-path-prefix must contain '=' between FROM and TO\",\n-                ),\n-            }\n+        .map(|remap| match remap.rsplit_once('=') {\n+            None => early_error(\n+                error_format,\n+                \"--remap-path-prefix must contain '=' between FROM and TO\",\n+            ),\n+            Some((from, to)) => (PathBuf::from(from), PathBuf::from(to)),\n         })\n         .collect()\n }\n@@ -1766,7 +1815,30 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         // and reversible name mangling. Note, LLVM coverage tools can analyze coverage over\n         // multiple runs, including some changes to source code; so mangled names must be consistent\n         // across compilations.\n-        debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+        match debugging_opts.symbol_mangling_version {\n+            None => {\n+                debugging_opts.symbol_mangling_version = Some(SymbolManglingVersion::V0);\n+            }\n+            Some(SymbolManglingVersion::Legacy) => {\n+                early_warn(\n+                    error_format,\n+                    \"-Z instrument-coverage requires symbol mangling version `v0`, \\\n+                    but `-Z symbol-mangling-version=legacy` was specified\",\n+                );\n+            }\n+            Some(SymbolManglingVersion::V0) => {}\n+        }\n+\n+        if debugging_opts.mir_opt_level > 1 {\n+            early_warn(\n+                error_format,\n+                &format!(\n+                    \"`-Z mir-opt-level={}` (any level > 1) enables function inlining, which \\\n+                    limits the effectiveness of `-Z instrument-coverage`.\",\n+                    debugging_opts.mir_opt_level,\n+                ),\n+            );\n+        }\n     }\n \n     if let Ok(graphviz_font) = std::env::var(\"RUSTC_GRAPHVIZ_FONT\") {\n@@ -2171,7 +2243,7 @@ crate mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n     impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n-    impl_dep_tracking_hash_via_hash!(SymbolManglingVersion);\n+    impl_dep_tracking_hash_via_hash!(Option<SymbolManglingVersion>);\n     impl_dep_tracking_hash_via_hash!(Option<SourceFileHashAlgorithm>);\n     impl_dep_tracking_hash_via_hash!(TrimmedDefPaths);\n "}, {"sha": "3a757e5f0075d468b77e1f5d02873231d0e51a0c", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -76,7 +76,7 @@ impl<'a> FileSearch<'a> {\n     pub fn new(\n         sysroot: &'a Path,\n         triple: &'a str,\n-        search_paths: &'a Vec<SearchPath>,\n+        search_paths: &'a [SearchPath],\n         tlib_path: &'a SearchPath,\n         kind: PathKind,\n     ) -> FileSearch<'a> {"}, {"sha": "36bf8634c6eeceff97229d50152f2ffc33ae53ff", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,6 +1,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(once_cell)]\n #![feature(or_patterns)]\n+#![feature(str_split_once)]\n \n #[macro_use]\n extern crate bitflags;"}, {"sha": "81f79f4b0e0fbd51f98fbc137f6dfb6a1fd294f1", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -179,9 +179,10 @@ macro_rules! options {\n     {\n         let mut op = $defaultfn();\n         for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(2, '=');\n-            let key = iter.next().unwrap();\n-            let value = iter.next();\n+            let (key, value) = match option.split_once('=') {\n+                None => (option, None),\n+                Some((k, v)) => (k.to_string(), Some(v)),\n+            };\n             let option_to_lookup = key.replace(\"-\", \"_\");\n             let mut found = false;\n             for &(candidate, setter, type_desc, _) in $stat {\n@@ -268,6 +269,7 @@ macro_rules! options {\n         pub const parse_switch_with_opt_path: &str =\n             \"an optional path to the profiling data output directory\";\n         pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n+        pub const parse_split_dwarf_kind: &str = \"one of: `none`, `single` or `split`\";\n         pub const parse_symbol_mangling_version: &str = \"either `legacy` or `v0` (RFC 2603)\";\n         pub const parse_src_file_hash: &str = \"either `md5` or `sha1`\";\n         pub const parse_relocation_model: &str =\n@@ -675,13 +677,26 @@ macro_rules! options {\n             true\n         }\n \n+        fn parse_split_dwarf_kind(\n+            slot: &mut SplitDwarfKind,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"none\") => SplitDwarfKind::None,\n+                Some(\"split\") => SplitDwarfKind::Split,\n+                Some(\"single\") => SplitDwarfKind::Single,\n+                _ => return false,\n+            };\n+            true\n+        }\n+\n         fn parse_symbol_mangling_version(\n-            slot: &mut SymbolManglingVersion,\n+            slot: &mut Option<SymbolManglingVersion>,\n             v: Option<&str>,\n         ) -> bool {\n             *slot = match v {\n-                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n-                Some(\"v0\") => SymbolManglingVersion::V0,\n+                Some(\"legacy\") => Some(SymbolManglingVersion::Legacy),\n+                Some(\"v0\") => Some(SymbolManglingVersion::V0),\n                 _ => return false,\n             };\n             true\n@@ -1087,9 +1102,14 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n-    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n+    split_dwarf: SplitDwarfKind = (SplitDwarfKind::None, parse_split_dwarf_kind, [UNTRACKED],\n+        \"enable generation of split dwarf\"),\n+    split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n+        \"provide minimal debug info in the object/executable to facilitate online \\\n+         symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n+    symbol_mangling_version: Option<SymbolManglingVersion> = (None,\n         parse_symbol_mangling_version, [TRACKED],\n-        \"which mangling version to use for symbol names\"),\n+        \"which mangling version to use for symbol names ('legacy' (default) or 'v0')\"),\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help (default: no)\"),\n     terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],"}, {"sha": "b1a48342417308dae140af911f2f8491c396db34", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -119,6 +119,7 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub edition: Edition,\n+    pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// Used to determine and report recursive module inclusions.\n@@ -152,6 +153,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(None),\n             config: FxHashSet::default(),\n             edition: ExpnId::root().expn_data().edition,\n+            missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,"}, {"sha": "93675303035d14a65dce9d5ab6a8e7b86add278d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1109,10 +1109,7 @@ impl Session {\n     }\n \n     pub fn link_dead_code(&self) -> bool {\n-        match self.opts.cg.link_dead_code {\n-            Some(explicitly_set) => explicitly_set,\n-            None => false,\n-        }\n+        self.opts.cg.link_dead_code.unwrap_or(false)\n     }\n \n     pub fn mark_attr_known(&self, attr: &Attribute) {"}, {"sha": "efbb0a23a6f012a679f80ed764775d90c1bf9b7e", "filename": "compiler/rustc_span/src/edition.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedition.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -4,24 +4,25 @@ use std::str::FromStr;\n \n use rustc_macros::HashStable_Generic;\n \n-/// The edition of the compiler (RFC 2052)\n+/// The edition of the compiler. (See [RFC 2052](https://github.com/rust-lang/rfcs/blob/master/text/2052-epochs.md).)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, Encodable, Decodable, Eq)]\n #[derive(HashStable_Generic)]\n pub enum Edition {\n-    // editions must be kept in order, oldest to newest\n+    // When adding new editions, be sure to do the following:\n+    //\n+    // - update the `ALL_EDITIONS` const\n+    // - update the `EDITION_NAME_LIST` const\n+    // - add a `rust_####()` function to the session\n+    // - update the enum in Cargo's sources as well\n+    //\n+    // Editions *must* be kept in order, oldest to newest.\n     /// The 2015 edition\n     Edition2015,\n     /// The 2018 edition\n     Edition2018,\n-    // when adding new editions, be sure to update:\n-    //\n-    // - Update the `ALL_EDITIONS` const\n-    // - Update the EDITION_NAME_LIST const\n-    // - add a `rust_####()` function to the session\n-    // - update the enum in Cargo's sources as well\n }\n \n-// must be in order from oldest to newest\n+// Must be in order from oldest to newest.\n pub const ALL_EDITIONS: &[Edition] = &[Edition::Edition2015, Edition::Edition2018];\n \n pub const EDITION_NAME_LIST: &str = \"2015|2018\";"}, {"sha": "fdc0d225bb82d9f1f98b06cfc5052a5a5a88b500", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1065,7 +1065,7 @@ pub fn decode_syntax_context<\n             parent: SyntaxContext::root(),\n             opaque: SyntaxContext::root(),\n             opaque_and_semitransparent: SyntaxContext::root(),\n-            dollar_crate_name: kw::Invalid,\n+            dollar_crate_name: kw::Empty,\n         });\n         let mut ctxts = outer_ctxts.lock();\n         let new_len = raw_id as usize + 1;\n@@ -1092,7 +1092,7 @@ pub fn decode_syntax_context<\n             ctxt_data,\n         );\n         // Make sure nothing weird happening while `decode_data` was running\n-        assert_eq!(dummy.dollar_crate_name, kw::Invalid);\n+        assert_eq!(dummy.dollar_crate_name, kw::Empty);\n     });\n \n     Ok(new_ctxt)"}, {"sha": "cea7871923bc689dc44ca295518c64f8c502eeac", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,10 +1,16 @@\n+//! Levenshtein distances.\n+//!\n+//! The [Levenshtein distance] is a metric for measuring the difference between two strings.\n+//!\n+//! [Levenshtein distance]: https://en.wikipedia.org/wiki/Levenshtein_distance\n+\n use crate::symbol::Symbol;\n use std::cmp;\n \n #[cfg(test)]\n mod tests;\n \n-/// Finds the Levenshtein distance between two strings\n+/// Finds the Levenshtein distance between two strings.\n pub fn lev_distance(a: &str, b: &str) -> usize {\n     // cases which don't require further computation\n     if a.is_empty() {\n@@ -35,14 +41,14 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n     dcol[t_last + 1]\n }\n \n-/// Finds the best match for a given word in the given iterator\n+/// Finds the best match for a given word in the given iterator.\n ///\n /// As a loose rule to avoid the obviously incorrect suggestions, it takes\n /// an optional limit for the maximum allowable edit distance, which defaults\n /// to one-third of the given word.\n ///\n-/// Besides Levenshtein, we use case insensitive comparison to improve accuracy on an edge case with\n-/// a lower(upper)case letters mismatch.\n+/// Besides Levenshtein, we use case insensitive comparison to improve accuracy\n+/// on an edge case with a lower(upper)case letters mismatch.\n #[cold]\n pub fn find_best_match_for_name(\n     name_vec: &[Symbol],\n@@ -98,7 +104,7 @@ fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Sym\n \n fn sort_by_words(name: &str) -> String {\n     let mut split_words: Vec<&str> = name.split('_').collect();\n-    // We are sorting primitive &strs and can use unstable sort here\n+    // We are sorting primitive &strs and can use unstable sort here.\n     split_words.sort_unstable();\n     split_words.join(\"_\")\n }"}, {"sha": "8009530717566370f18e0d2448af299c5c769469", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,4 +1,13 @@\n-//! The source positions and related helper functions.\n+//! Source positions and related helper functions.\n+//!\n+//! Important concepts in this module include:\n+//!\n+//! - the *span*, represented by [`SpanData`] and related types;\n+//! - source code as represented by a [`SourceMap`]; and\n+//! - interned strings, represented by [`Symbol`]s, with some common symbols available statically in the [`sym`] module.\n+//!\n+//! Unlike most compilers, the span contains not only the position in the source code, but also various other metadata,\n+//! such as the edition and macro hygiene. This metadata is stored in [`SyntaxContext`] and [`ExpnData`].\n //!\n //! ## Note\n //!\n@@ -124,7 +133,7 @@ pub enum RealFileName {\n \n impl RealFileName {\n     /// Returns the path suitable for reading from the file system on the local host.\n-    /// Avoid embedding this in build artifacts; see `stable_name` for that.\n+    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n     pub fn local_path(&self) -> &Path {\n         match self {\n             RealFileName::Named(p)\n@@ -133,7 +142,7 @@ impl RealFileName {\n     }\n \n     /// Returns the path suitable for reading from the file system on the local host.\n-    /// Avoid embedding this in build artifacts; see `stable_name` for that.\n+    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n     pub fn into_local_path(self) -> PathBuf {\n         match self {\n             RealFileName::Named(p)\n@@ -143,7 +152,7 @@ impl RealFileName {\n \n     /// Returns the path suitable for embedding into build artifacts. Note that\n     /// a virtualized path will not correspond to a valid file system path; see\n-    /// `local_path` for something that is more likely to return paths into the\n+    /// `local_path()` for something that is more likely to return paths into the\n     /// local host file system.\n     pub fn stable_name(&self) -> &Path {\n         match self {\n@@ -173,7 +182,7 @@ pub enum FileName {\n     /// Custom sources for explicit parser calls from plugins and drivers.\n     Custom(String),\n     DocTest(PathBuf, isize),\n-    /// Post-substitution inline assembly from LLVM\n+    /// Post-substitution inline assembly from LLVM.\n     InlineAsm(u64),\n }\n \n@@ -182,7 +191,7 @@ impl std::fmt::Display for FileName {\n         use FileName::*;\n         match *self {\n             Real(RealFileName::Named(ref path)) => write!(fmt, \"{}\", path.display()),\n-            // FIXME: might be nice to display both compoments of Devirtualized.\n+            // FIXME: might be nice to display both components of Devirtualized.\n             // But for now (to backport fix for issue #70924), best to not\n             // perturb diagnostics so its obvious test suite still works.\n             Real(RealFileName::Devirtualized { ref local_path, virtual_name: _ }) => {\n@@ -266,14 +275,17 @@ impl FileName {\n     }\n }\n \n+/// Represents a span.\n+///\n /// Spans represent a region of code, used for error reporting. Positions in spans\n-/// are *absolute* positions from the beginning of the source_map, not positions\n-/// relative to `SourceFile`s. Methods on the `SourceMap` can be used to relate spans back\n+/// are *absolute* positions from the beginning of the [`SourceMap`], not positions\n+/// relative to [`SourceFile`]s. Methods on the `SourceMap` can be used to relate spans back\n /// to the original source.\n-/// You must be careful if the span crosses more than one file - you will not be\n+///\n+/// You must be careful if the span crosses more than one file, since you will not be\n /// able to use many of the functions on spans in source_map and you cannot assume\n-/// that the length of the `span = hi - lo`; there may be space in the `BytePos`\n-/// range between files.\n+/// that the length of the span is equal to `span.hi - span.lo`; there may be space in the\n+/// [`BytePos`] range between files.\n ///\n /// `SpanData` is public because `Span` uses a thread-local interner and can't be\n /// sent to other threads, but some pieces of performance infra run in a separate thread.\n@@ -384,7 +396,7 @@ impl Span {\n         Span::new(lo, hi, SyntaxContext::root())\n     }\n \n-    /// Returns a new span representing an empty span at the beginning of this span\n+    /// Returns a new span representing an empty span at the beginning of this span.\n     #[inline]\n     pub fn shrink_to_lo(self) -> Span {\n         let span = self.data();\n@@ -398,7 +410,7 @@ impl Span {\n     }\n \n     #[inline]\n-    /// Returns true if hi == lo\n+    /// Returns `true` if `hi == lo`.\n     pub fn is_empty(&self) -> bool {\n         let span = self.data();\n         span.hi == span.lo\n@@ -512,7 +524,7 @@ impl Span {\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n-    /// can be used without triggering the `unsafe_code` lint\n+    /// can be used without triggering the `unsafe_code` lint.\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n         self.ctxt().outer_expn_data().allow_internal_unsafe\n@@ -700,6 +712,7 @@ impl Span {\n     }\n }\n \n+/// A span together with some additional data.\n #[derive(Clone, Debug)]\n pub struct SpanLabel {\n     /// The span we are going to include in the final snippet.\n@@ -743,7 +756,7 @@ impl<D: Decoder> Decodable<D> for Span {\n /// any spans that are debug-printed during the closure's execution.\n ///\n /// Normally, the global `TyCtxt` is used to retrieve the `SourceMap`\n-/// (see `rustc_interface::callbacks::span_debug1). However, some parts\n+/// (see `rustc_interface::callbacks::span_debug1`). However, some parts\n /// of the compiler (e.g. `rustc_parse`) may debug-print `Span`s before\n /// a `TyCtxt` is available. In this case, we fall back to\n /// the `SourceMap` provided to this function. If that is not available,\n@@ -994,9 +1007,9 @@ pub enum ExternalSource {\n     Unneeded,\n     Foreign {\n         kind: ExternalSourceKind,\n-        /// This SourceFile's byte-offset within the source_map of its original crate\n+        /// This SourceFile's byte-offset within the source_map of its original crate.\n         original_start_pos: BytePos,\n-        /// The end of this SourceFile within the source_map of its original crate\n+        /// The end of this SourceFile within the source_map of its original crate.\n         original_end_pos: BytePos,\n     },\n }\n@@ -1099,7 +1112,7 @@ impl SourceFileHash {\n     }\n }\n \n-/// A single source in the `SourceMap`.\n+/// A single source in the [`SourceMap`].\n #[derive(Clone)]\n pub struct SourceFile {\n     /// The name of the file that the source came from. Source that doesn't\n@@ -1580,7 +1593,7 @@ fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n \n /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n ///\n-/// Returns error if there's a lone `\\r` in the string\n+/// Returns error if there's a lone `\\r` in the string.\n fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if !src.as_bytes().contains(&b'\\r') {\n         return;\n@@ -1705,13 +1718,16 @@ macro_rules! impl_pos {\n }\n \n impl_pos! {\n-    /// A byte offset. Keep this small (currently 32-bits), as AST contains\n-    /// a lot of them.\n+    /// A byte offset.\n+    ///\n+    /// Keep this small (currently 32-bits), as AST contains a lot of them.\n     #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n     pub struct BytePos(pub u32);\n \n-    /// A character offset. Because of multibyte UTF-8 characters, a byte offset\n-    /// is not equivalent to a character offset. The `SourceMap` will convert `BytePos`\n+    /// A character offset.\n+    ///\n+    /// Because of multibyte UTF-8 characters, a byte offset\n+    /// is not equivalent to a character offset. The [`SourceMap`] will convert [`BytePos`]\n     /// values to `CharPos` values as necessary.\n     #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n     pub struct CharPos(pub usize);\n@@ -1835,8 +1851,9 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n }\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n-/// This is a hack to allow using the `HashStable_Generic` derive macro\n-/// instead of implementing everything in librustc_middle.\n+///\n+/// This is a hack to allow using the [`HashStable_Generic`] derive macro\n+/// instead of implementing everything in rustc_middle.\n pub trait HashStableContext {\n     fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n     fn hash_crate_num(&mut self, _: CrateNum, hasher: &mut StableHasher);\n@@ -1856,6 +1873,7 @@ where\n     /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n     /// triple, which stays the same even if the containing `SourceFile` has moved\n     /// within the `SourceMap`.\n+    ///\n     /// Also note that we are hashing byte offsets for the column, not unicode\n     /// codepoint offsets. For the purpose of the hash that's sufficient.\n     /// Also, hashing filenames is expensive so we avoid doing it twice when the"}, {"sha": "fefc0cb48ddd8efea9b86f5346d4b2555ebcd75c", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -1,9 +1,11 @@\n-//! The `SourceMap` tracks all the source code used within a single crate, mapping\n+//! Types for tracking pieces of source code within a crate.\n+//!\n+//! The [`SourceMap`] tracks all the source code used within a single crate, mapping\n //! from integer byte positions to the original source code location. Each bit\n //! of source parsed during crate parsing (typically files, in-memory strings,\n //! or various bits of macro expansion) cover a continuous range of bytes in the\n-//! `SourceMap` and are represented by `SourceFile`s. Byte positions are stored in\n-//! `Span` and used pervasively in the compiler. They are absolute positions\n+//! `SourceMap` and are represented by [`SourceFile`]s. Byte positions are stored in\n+//! [`Span`] and used pervasively in the compiler. They are absolute positions\n //! within the `SourceMap`, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n "}, {"sha": "ceb9b59b13ad1609489eab9cd8ef03307a42b25f", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxIndexSet;\n \n /// A compressed span.\n ///\n-/// `SpanData` is 12 bytes, which is a bit too big to stick everywhere. `Span`\n+/// Whereas [`SpanData`] is 12 bytes, which is a bit too big to stick everywhere, `Span`\n /// is a form that only takes up 8 bytes, with less space for the length and\n /// context. The vast majority (99.9%+) of `SpanData` instances will fit within\n /// those 8 bytes; any `SpanData` whose fields don't fit into a `Span` are\n@@ -42,13 +42,11 @@ use rustc_data_structures::fx::FxIndexSet;\n /// - `base` is 32 bits in both `Span` and `SpanData`, which means that `base`\n ///   values never cause interning. The number of bits needed for `base`\n ///   depends on the crate size. 32 bits allows up to 4 GiB of code in a crate.\n-///   `script-servo` is the largest crate in `rustc-perf`, requiring 26 bits\n-///   for some spans.\n /// - `len` is 15 bits in `Span` (a u16, minus 1 bit for the tag) and 32 bits\n ///   in `SpanData`, which means that large `len` values will cause interning.\n ///   The number of bits needed for `len` does not depend on the crate size.\n-///   The most common number of bits for `len` are 0--7, with a peak usually at\n-///   3 or 4, and then it drops off quickly from 8 onwards. 15 bits is enough\n+///   The most common numbers of bits for `len` are from 0 to 7, with a peak usually\n+///   at 3 or 4, and then it drops off quickly from 8 onwards. 15 bits is enough\n ///   for 99.99%+ of cases, but larger values (sometimes 20+ bits) might occur\n ///   dozens of times in a typical crate.\n /// - `ctxt` is 16 bits in `Span` and 32 bits in `SpanData`, which means that"}, {"sha": "382b7a4f2db713cfd69058f76f9cba7fe0589a00", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "6356a7e7832558d47de76459d7776d0b924f5690", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "7f8cded0ac0ec54d471af01e16c5c8463baa59d8", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "7b6e6ad0696a15f153f3f8436f05b7c54cba38b5", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "3c65c84b0de41b7fe0d5198018a1ddf1e699b45f", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "1ad57582ebafbbce87fb1a5e126b057dc791e260", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "88422395216437fba0678fcf8dc7d06df5171b8d", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "8d72df6850fc297aa270f5645631192084032c7b", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "da66fbc8587d7ac498a6d6b92ec8d27e12df07d5", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "fc6a9a7f20972ffe1fd1c4695c202ebbcfee63f7", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "99b96f609647687bb7c4da8155a3c3aa1372e177", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "1d82e732907ba29ee31320c39891169f885aca0f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "69f66f6e6b1aa6c0372fa04e931dce10e56e4174", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "79fea83a6674d3021b6e19122e4bd7ad8f62b346", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "9c894e99a389a684b4106447e78cdc47f7d48205", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}, {"sha": "8b6e30f34fd4a64f7bfb6e9c334dc693faaa0697", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d482de30ea70d537dced8ec04a3903e3264cf106/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d482de30ea70d537dced8ec04a3903e3264cf106"}]}