{"sha": "29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZWE4NzU0MmY4ZDM5OTZlMmJkZTlhNDA2YzRiZjdiMmFjNjhhZjQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-15T10:08:05Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-15T10:08:05Z"}, "message": "Tuple fields are immutable", "tree": {"sha": "4369fb3cc0389a9e19faedf812063cce77c73f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4369fb3cc0389a9e19faedf812063cce77c73f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "html_url": "https://github.com/rust-lang/rust/commit/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "html_url": "https://github.com/rust-lang/rust/commit/9538b0036358acc1e1d9ca8b00128bc0fa9940b2"}], "stats": {"total": 231, "additions": 93, "deletions": 138}, "files": [{"sha": "479f6db699f9c674c356e7deb1510e69d1533348", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -239,7 +239,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       'T' {\n         assert (next(st) as char == '[');\n         let params = ~[];\n-        while peek(st) as char != ']' { params += ~[parse_mt(st, sd)]; }\n+        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }"}, {"sha": "ce8c760da99d4ceba0faba12d709c23afa797253", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -120,9 +120,9 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         for t: ty::t  in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n-      ty::ty_tup(mts) {\n+      ty::ty_tup(ts) {\n         w.write_str(\"T[\");\n-        for mt in mts { enc_mt(w, cx, mt); }\n+        for t in ts { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }"}, {"sha": "eecea8bf029a9f1ed6114d9552abe018b2c67f01", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -678,9 +678,9 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n             }\n             ret false;\n           }\n-          ty::ty_tup(mts) {\n-            for mt in mts {\n-                if helper(tcx, needle, mt.ty, get_mut(mut, mt)) {\n+          ty::ty_tup(ts) {\n+            for t in ts {\n+                if helper(tcx, needle, t, mut) {\n                     ret true;\n                 }\n             }"}, {"sha": "401ae47c4c826ba24ac568529f0ed0e48fdf02bb", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -48,7 +48,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n         }\n         ty::ty_tup(elts) {\n             for elt in elts {\n-                if type_is_gc_relevant(cx, elt.ty) { ret true; }\n+                if type_is_gc_relevant(cx, elt) { ret true; }\n             }\n             ret false;\n         }"}, {"sha": "38ec5246ba8b81fa21d62be00ead058904163c20", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -174,7 +174,7 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n     ret result;\n }\n \n-// Computes the static size of a tag, without using mk_imm_tup(), which is\n+// Computes the static size of a tag, without using mk_tup(), which is\n // bad for performance.\n //\n // TODO: Migrate trans over to use this.\n@@ -374,7 +374,7 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n       ty::ty_tup(elts) {\n         s += ~[shape_struct];\n         let sub = ~[];\n-        for elt in elts { sub += shape_of(ccx, elt.ty); }\n+        for elt in elts { sub += shape_of(ccx, elt); }\n         add_substr(s, sub);\n       }\n "}, {"sha": "cf9e8252538bbf3be3064fe407c48bc30d4c8af3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -256,7 +256,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       ty::ty_tup(elts) {\n         let tys = ~[];\n         for elt in elts {\n-            tys += ~[type_of_inner(cx, sp, elt.ty)];\n+            tys += ~[type_of_inner(cx, sp, elt)];\n         }\n         llty = T_struct(tys);\n       }\n@@ -490,20 +490,20 @@ fn simplify_type(ccx: &@crate_ctxt, typ: &ty::t) -> ty::t {\n           ty::ty_uniq(_) { ret ty::mk_uniq(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n           ty::ty_vec(_) { ret ty::mk_imm_vec(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n           ty::ty_fn(_, _, _, _, _) {\n-            ret ty::mk_imm_tup(ccx.tcx,\n-                               ~[ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n-                                 ty::mk_imm_box(ccx.tcx,\n-                                                ty::mk_nil(ccx.tcx))]);\n+            ret ty::mk_tup(ccx.tcx,\n+                           ~[ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n+                             ty::mk_imm_box(ccx.tcx,\n+                                            ty::mk_nil(ccx.tcx))]);\n           }\n           ty::ty_obj(_) {\n-            ret ty::mk_imm_tup(ccx.tcx,\n+            ret ty::mk_tup(ccx.tcx,\n                                ~[ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n                                  ty::mk_imm_box(ccx.tcx,\n                                                 ty::mk_nil(ccx.tcx))]);\n           }\n           ty::ty_res(_, sub, tps) {\n             let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n-            ret ty::mk_imm_tup(ccx.tcx,\n+            ret ty::mk_tup(ccx.tcx,\n                                ~[ty::mk_int(ccx.tcx),\n                                  simplify_type(ccx, sub1)]);\n           }\n@@ -530,7 +530,7 @@ fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> uint {\n         let variants = ty::tag_variants(cx.tcx, tid);\n         for variant: ty::variant_info  in variants {\n             let tup_ty =\n-                simplify_type(cx, ty::mk_imm_tup(cx.tcx, variant.args));\n+                simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n \n             tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n@@ -586,7 +586,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n       }\n       ty::ty_tup(elts) {\n         let tys = ~[];\n-        for mt in elts { tys += ~[mt.ty]; }\n+        for tp in elts { tys += ~[tp]; }\n         ret align_elements(cx, tys);\n       }\n       ty::ty_tag(tid, tps) {\n@@ -661,7 +661,7 @@ fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n         let a = C_int(1);\n         let bcx = cx;\n         for e in elts {\n-            let align = align_of(bcx, e.ty);\n+            let align = align_of(bcx, e);\n             bcx = align.bcx;\n             a = umax(bcx, a, align.val);\n         }\n@@ -766,7 +766,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n \n     let args = ~[];\n     for typ: ty::t  in s.prefix { args += ~[typ]; }\n-    let prefix_ty = ty::mk_imm_tup(bcx_tcx(cx), args);\n+    let prefix_ty = ty::mk_tup(bcx_tcx(cx), args);\n \n     let bcx = cx;\n     let sz = size_of(bcx, prefix_ty);\n@@ -795,7 +795,7 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n         if i == ix { elem_ty = arg_ty; }\n         i += 1;\n     }\n-    let tup_ty = ty::mk_imm_tup(bcx_tcx(cx), true_arg_tys);\n+    let tup_ty = ty::mk_tup(bcx_tcx(cx), true_arg_tys);\n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n \n@@ -858,7 +858,7 @@ fn trans_malloc_boxed_raw(cx: &@block_ctxt, t: ty::t) -> result {\n     // The mk_int here is the space being\n     // reserved for the refcount.\n     let boxed_body =\n-        ty::mk_imm_tup(bcx_tcx(cx), ~[ty::mk_int(bcx_tcx(cx)), t]);\n+        ty::mk_tup(bcx_tcx(cx), ~[ty::mk_int(bcx_tcx(cx)), t]);\n     let box_ptr = ty::mk_imm_box(bcx_tcx(cx), t);\n     let sz = size_of(cx, boxed_body);\n \n@@ -1497,7 +1497,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n                   inner_t: ty::t, tps: &[ty::t]) -> result {\n     let ccx = bcx_ccx(cx);\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n-    let tup_ty = ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n+    let tup_ty = ty::mk_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n     let drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n \n@@ -1846,16 +1846,15 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n         for arg in args {\n             r = GEP_tup_like(r.bcx, t, av, ~[0, i]);\n             let llfld_a = r.val;\n-            r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, arg.ty),\n-                  arg.ty);\n+            r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, arg), arg);\n             i += 1;\n         }\n       }\n       ty::ty_res(_, inner, tps) {\n         let tcx = bcx_tcx(cx);\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n         let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n-        let tup_t = ty::mk_imm_tup(tcx, ~[ty::mk_int(tcx), inner_t_s]);\n+        let tup_t = ty::mk_tup(tcx, ~[ty::mk_int(tcx), inner_t_s]);\n         r = GEP_tup_like(r.bcx, tup_t, av, ~[0, 1]);\n         let llfld_a = r.val;\n         r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner1), inner1);\n@@ -3516,7 +3515,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // First, synthesize a tuple type containing the types of all the\n     // bound expressions.\n     // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n-    let bindings_ty: ty::t = ty::mk_imm_tup(bcx_tcx(bcx), bound_tys);\n+    let bindings_ty: ty::t = ty::mk_tup(bcx_tcx(bcx), bound_tys);\n \n     // NB: keep this in sync with T_closure_ptr; we're making\n     // a ty::t structure that has the same \"shape\" as the LLVM type\n@@ -3536,17 +3535,17 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // closure_tys = [tydesc_ty, [bound_ty1, bound_ty2, ...], [tydesc_ty,\n     // tydesc_ty, ...]]\n     let closure_tys: [ty::t] =\n-        ~[tydesc_ty, bindings_ty, ty::mk_imm_tup(bcx_tcx(bcx), captured_tys)];\n+        ~[tydesc_ty, bindings_ty, ty::mk_tup(bcx_tcx(bcx), captured_tys)];\n \n     // Finally, synthesize a type for that whole vector.\n-    let closure_ty: ty::t = ty::mk_imm_tup(bcx_tcx(bcx), closure_tys);\n+    let closure_ty: ty::t = ty::mk_tup(bcx_tcx(bcx), closure_tys);\n \n     // Allocate a box that can hold something closure-sized.\n     let r = if copying {\n         trans_malloc_boxed(bcx, closure_ty)\n     } else {\n         // We need to dummy up a box on the stack\n-        let ty = ty::mk_imm_tup(bcx_tcx(bcx),\n+        let ty = ty::mk_tup(bcx_tcx(bcx),\n                                 ~[ty::mk_int(bcx_tcx(bcx)), closure_ty]);\n         let r = alloc_ty(bcx, ty);\n         let body = GEPi(bcx, r.val, ~[0, abi::box_rc_field_body]);\n@@ -4769,7 +4768,7 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n     ret rslt(bcx, retval);\n }\n \n-fn trans_tup(cx: &@block_ctxt, elts: &[ast::elt], id: ast::node_id)\n+fn trans_tup(cx: &@block_ctxt, elts: &[@ast::expr], id: ast::node_id)\n     -> result {\n     let bcx = cx;\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n@@ -4779,8 +4778,8 @@ fn trans_tup(cx: &@block_ctxt, elts: &[ast::elt], id: ast::node_id)\n     add_clean_temp(cx, tup_val, t);\n     let i: int = 0;\n     for e in elts {\n-        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n-        let src = trans_lval(bcx, e.expr);\n+        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+        let src = trans_lval(bcx, e);\n         bcx = src.res.bcx;\n         let dst_res = GEP_tup_like(bcx, t, tup_val, ~[0, i]);\n         bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty).bcx;\n@@ -4813,7 +4812,7 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     add_clean_temp(bcx, vec_val, t);\n     let body = bcx.build.GEP(vec_val, ~[C_int(0), C_int(abi::vec_elt_data)]);\n     let pseudo_tup_ty =\n-        ty::mk_imm_tup(bcx_tcx(cx),\n+        ty::mk_tup(bcx_tcx(cx),\n                        std::ivec::init_elt[ty::t](unit_ty,\n                                                   std::ivec::len(args)));\n     let i: int = 0;\n@@ -5958,7 +5957,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n \n-    let fields_tup_ty = ty::mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n+    let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n     let n_typarams = std::ivec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(*bcx_ccx(bcx), n_typarams);\n     let box_cell =\n@@ -6128,7 +6127,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     let arg_t = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n-    let tup_t = ty::mk_imm_tup(cx.ccx.tcx, ~[ty::mk_int(cx.ccx.tcx), arg_t]);\n+    let tup_t = ty::mk_tup(cx.ccx.tcx, ~[ty::mk_int(cx.ccx.tcx), arg_t]);\n     let arg;\n     alt fcx.llargs.find(dtor.decl.inputs.(0).id) {\n       some(x) { arg = load_if_immediate(bcx, x, arg_t); }"}, {"sha": "019461b0fc766f771f875940194b26eba3ea7217", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -122,7 +122,7 @@ fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n     }\n     // Make the tuple.\n \n-    let args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n+    let args_ty = ty::mk_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n     // Allocate and fill the tuple.\n \n     let llargs = alloc_ty(bcx, args_ty);"}, {"sha": "00134f784f2f2ae895a7ce8376bff61ef8bb03d8", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -152,7 +152,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                          ~[0, abi::obj_body_elt_typarams]);\n         bcx = body_typarams.bcx;\n         // TODO: can we just get typarams_ty out of body_ty instead?\n-        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n+        let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n         let i: int = 0;\n         for tp: ast::ty_param  in ty_params {\n             let typaram = bcx.fcx.lltydescs.(i);\n@@ -174,7 +174,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n               some(arg1) {\n                 let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n                 // TODO: can we just get fields_ty out of body_ty instead?\n-                let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n+                let fields_ty: ty::t = ty::mk_tup(ccx.tcx, obj_fields);\n                 let field =\n                     GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n                 bcx = field.bcx;\n@@ -347,7 +347,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             // have additional field exprs in the AST.\n             load_if_immediate(bcx, additional_field_vals.(i).val,\n                               additional_field_tys.(i));\n-            let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx,\n+            let fields_ty: ty::t = ty::mk_tup(ccx.tcx,\n                                                   additional_field_tys);\n             let field =\n                 GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n@@ -895,18 +895,18 @@ fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n                            maybe_inner_obj_ty: option::t[ty::t]) -> ty::t {\n \n     let tydesc_ty: ty::t = ty::mk_type(tcx);\n-    let typarams_ty_tup: ty::t = ty::mk_imm_tup(tcx, typarams_ty);\n-    let fields_ty_tup: ty::t = ty::mk_imm_tup(tcx, fields_ty);\n+    let typarams_ty_tup: ty::t = ty::mk_tup(tcx, typarams_ty);\n+    let fields_ty_tup: ty::t = ty::mk_tup(tcx, fields_ty);\n \n     let body_ty: ty::t;\n     alt maybe_inner_obj_ty {\n       some(inner_obj_ty) {\n-        body_ty = ty::mk_imm_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n-                                        fields_ty_tup, inner_obj_ty]);\n+        body_ty = ty::mk_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n+                                    fields_ty_tup, inner_obj_ty]);\n       }\n       none {\n-        body_ty = ty::mk_imm_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n-                                        fields_ty_tup]);\n+        body_ty = ty::mk_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n+                                    fields_ty_tup]);\n       }\n     }\n "}, {"sha": "23843274a6a1c9f7af3b777d93136e1d04dba4d7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -35,7 +35,6 @@ import std::map::new_int_hash;\n import util::common::new_def_hash;\n import util::common::log_expr;\n import util::common::log_fn;\n-import util::common::elt_exprs;\n import util::common::field_exprs;\n import util::common::has_nonlocal_exits;\n import util::common::log_stmt;\n@@ -405,7 +404,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n       expr_tup(elts) {\n-        find_pre_post_exprs(fcx, elt_exprs(elts), e.id);\n+        find_pre_post_exprs(fcx, elts, e.id);\n       }\n       expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n       expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }"}, {"sha": "de367a256af4830a2e3a0694dc95a5466a5056ad", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -23,7 +23,6 @@ import util::common::log_expr;\n import util::common::log_block;\n import util::common::log_block_err;\n import util::common::log_fn;\n-import util::common::elt_exprs;\n import util::common::field_exprs;\n import util::common::has_nonlocal_exits;\n import util::common::log_stmt;\n@@ -392,7 +391,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n                                       ivec::init_elt(init_assign,\n                                                      ivec::len(elts)),\n-                                      elt_exprs(elts), return);\n+                                      elts, return);\n       }\n       expr_move(lhs, rhs) {\n         ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);"}, {"sha": "ca9095999e765d536ba44d0617b5aadc41846c22", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -70,7 +70,6 @@ export mk_float;\n export mk_fn;\n export mk_imm_box;\n export mk_mut_ptr;\n-export mk_imm_tup;\n export mk_imm_vec;\n export mk_int;\n export mk_istr;\n@@ -282,7 +281,7 @@ tag sty {\n     ty_native_fn(ast::native_abi, [arg], t);\n     ty_obj([method]);\n     ty_res(def_id, t, [t]);\n-    ty_tup([mt]);\n+    ty_tup([t]);\n     ty_var(int); // type variable\n \n     ty_param(uint, ast::kind); // fn/tag type param\n@@ -306,7 +305,6 @@ tag type_err {\n     terr_box_mutability;\n     terr_vec_mutability;\n     terr_tuple_size(uint, uint);\n-    terr_tuple_mutability;\n     terr_record_size(uint, uint);\n     terr_record_mutability;\n     terr_record_fields(ast::ident, ast::ident);\n@@ -491,9 +489,9 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n             derive_flags_mt(cx, has_params, has_vars, f.mt);\n         }\n       }\n-      ty_tup(mts) {\n-        for m in mts {\n-            derive_flags_mt(cx, has_params, has_vars, m);\n+      ty_tup(ts) {\n+        for tt in ts {\n+            derive_flags_t(cx, has_params, has_vars, tt);\n         }\n       }\n       ty_fn(_, args, tt, _, _) {\n@@ -605,14 +603,7 @@ fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n \n-fn mk_tup(cx: &ctxt, tms: &[mt]) -> t { ret gen_ty(cx, ty_tup(tms)); }\n-\n-fn mk_imm_tup(cx: &ctxt, tys: &[t]) -> t {\n-    // TODO: map\n-    let mts = ~[];\n-    for typ in tys { mts += ~[{ty: typ, mut: ast::imm}]; }\n-    ret mk_tup(cx, mts);\n-}\n+fn mk_tup(cx: &ctxt, ts: &[t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n \n fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: &t,\n          cf: &controlflow, constrs: &[@constr]) -> t {\n@@ -687,8 +678,8 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_rec(fields) {\n         for fl: field  in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n-      ty_tup(mts) {\n-        for tm in mts { walk_ty(cx, walker, tm.ty); }\n+      ty_tup(ts) {\n+        for tt in ts { walk_ty(cx, walker, tt); }\n       }\n       ty_fn(proto, args, ret_ty, _, _) {\n         for a: arg  in args { walk_ty(cx, walker, a.ty); }\n@@ -775,13 +766,12 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n         }\n         ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n       }\n-      ty_tup(mts) {\n-        let new_mts = ~[];\n-        for tm in mts {\n-            let new_subty = fold_ty(cx, fld, tm.ty);\n-            new_mts += ~[{ty: new_subty, mut: tm.mut}];\n+      ty_tup(ts) {\n+        let new_ts = ~[];\n+        for tt in ts {\n+            new_ts += ~[fold_ty(cx, fld, tt)];\n         }\n-        ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n+        ty = copy_cname(cx, mk_tup(cx, new_ts), ty);\n       }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n         let new_args: [arg] = ~[];\n@@ -956,7 +946,7 @@ fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n fn get_element_type(cx: &ctxt, ty: &t, i: uint) -> t {\n     alt struct(cx, ty) {\n       ty_rec(flds) { ret flds.(i).mt.ty; }\n-      ty_tup(mts) { ret mts.(i).ty; }\n+      ty_tup(ts) { ret ts.(i); }\n       _ {\n         cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n                         \" - expected a \\\n@@ -1032,7 +1022,7 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n       }\n       ty_tup(elts) {\n         for m in elts {\n-            if type_has_pointers(cx, m.ty) { result = true; }\n+            if type_has_pointers(cx, m) { result = true; }\n         }\n       }\n       ty_tag(did, tps) {\n@@ -1225,11 +1215,9 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n         }\n         ret false;\n       }\n-      ty_tup(mts) {\n-        let i = 0u;\n-        while i < ivec::len(mts) {\n-            if type_has_dynamic_size(cx, mts.(i).ty) { ret true; }\n-            i += 1u;\n+      ty_tup(ts) {\n+        for tt in ts {\n+            if type_has_dynamic_size(cx, tt) { ret true; }\n         }\n         ret false;\n       }\n@@ -1356,7 +1344,7 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       }\n       ty_tup(elts) {\n         for m in elts {\n-            if type_owns_heap_mem(cx, m.ty) { result = true; }\n+            if type_owns_heap_mem(cx, m) { result = true; }\n         }\n       }\n       ty_res(_, inner, tps) {\n@@ -1397,7 +1385,7 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n         ty_tag(did, tps) {\n             let variants = tag_variants(cx, did);\n             for variant : variant_info in variants {\n-                let tup_ty = mk_imm_tup(cx, variant.args);\n+                let tup_ty = mk_tup(cx, variant.args);\n \n                 // Perform any type parameter substitutions.\n                 tup_ty = substitute_type_params(cx, tps, tup_ty);\n@@ -1411,7 +1399,7 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n         }\n         ty_tup(elts) {\n             for elt in elts {\n-                if !type_is_pod(cx, elt.ty) { result = false; }\n+                if !type_is_pod(cx, elt) { result = false; }\n             }\n         }\n         ty_res(_, inner, tps) {\n@@ -1563,9 +1551,9 @@ fn hash_type_structure(st: &sty) -> uint {\n         for f: field  in fields { h += h << 5u + hash_ty(f.mt.ty); }\n         ret h;\n       }\n-      ty_tup(mts) {\n+      ty_tup(ts) {\n         let h = 25u;\n-        for tm in mts { h += h << 5u + hash_ty(tm.ty); }\n+        for tt in ts { h += h << 5u + hash_ty(tt); }\n         ret h;\n       }\n \n@@ -1749,14 +1737,14 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n           _ { ret false; }\n         }\n       }\n-      ty_tup(mts_a) {\n+      ty_tup(ts_a) {\n         alt (b) {\n-          ty_tup(mts_b) {\n-            let len = ivec::len(mts_a);\n-            if len != ivec::len(mts_b) { ret false; }\n+          ty_tup(ts_b) {\n+            let len = ivec::len(ts_a);\n+            if len != ivec::len(ts_b) { ret false; }\n             let i = 0u;\n             while i < len {\n-                if !equal_mt(mts_a.(i), mts_b.(i)) { ret false; }\n+                if !eq_ty(ts_a.(i), ts_b.(i)) { ret false; }\n                 i += 1u;\n             }\n             ret true;\n@@ -2743,17 +2731,11 @@ mod unify {\n                 while i < expected_len {\n                     let expected_elem = expected_elems.(i);\n                     let actual_elem = actual_elems.(i);\n-                    let mut;\n-                    alt unify_mut(expected_elem.mut, actual_elem.mut) {\n-                      none. { ret ures_err(terr_tuple_mutability); }\n-                      some(m) { mut = m; }\n-                    }\n-                    let result = unify_step(cx, expected_elem.ty,\n-                                            actual_elem.ty);\n+                    let result = unify_step(cx, expected_elem,\n+                                            actual_elem);\n                     alt result {\n                       ures_ok(rty) {\n-                        let mt = {ty: rty, mut: mut};\n-                        result_elems += ~[mt];\n+                        result_elems += ~[rty];\n                       }\n                       _ { ret result; }\n                     }\n@@ -2912,9 +2894,6 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n             \" elements but found one with \" + uint::to_str(a_sz, 10u)\n             + \" elements\";\n       }\n-      terr_tuple_mutability. {\n-        ret \"tuple elements differ in mutability\";\n-      }\n       terr_record_size(e_sz, a_sz) {\n         ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n                 \" fields but found one with \" + uint::to_str(a_sz, 10u) +"}, {"sha": "6d10a6adaee653eefdf37bd7f04d4cfdcab4c78f", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -340,7 +340,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n       }\n       ast::ty_tup(fields) {\n-        let flds = ivec::map(bind ast_mt_to_mt(tcx, getter, _), fields);\n+        let flds = ivec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n@@ -2178,14 +2178,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_tup(elts) {\n-        let elts_mt = ~[];\n-        ivec::reserve(elts_mt, ivec::len(elts));\n+        let elt_ts = ~[];\n+        ivec::reserve(elt_ts, ivec::len(elts));\n         for e in elts {\n-            check_expr(fcx, e.expr);\n-            let ety = expr_ty(fcx.ccx.tcx, e.expr);\n-            elts_mt += ~[{ty: ety, mut: e.mut}];\n+            check_expr(fcx, e);\n+            let ety = expr_ty(fcx.ccx.tcx, e);\n+            elt_ts += ~[ety];\n         }\n-        let typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n+        let typ = ty::mk_tup(fcx.ccx.tcx, elt_ts);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {"}, {"sha": "bedb2cad64d1d829e9f70cc974a381a6081c5bfa", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -273,8 +273,6 @@ tag decl_ { decl_local([@local]); decl_item(@item); }\n \n type arm = {pats: [@pat], block: blk};\n \n-type elt = {mut: mutability, expr: @expr};\n-\n type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n type field = spanned[field_];\n@@ -292,7 +290,7 @@ tag expr_ {\n     expr_vec([@expr], mutability, seq_kind);\n     expr_rec([field], option::t[@expr]);\n     expr_call(@expr, [@expr]);\n-    expr_tup([elt]);\n+    expr_tup([@expr]);\n     expr_self_method(ident);\n     expr_bind(@expr, [option::t[@expr]]);\n     expr_spawn(spawn_dom, option::t[str], @expr, [@expr]);\n@@ -448,7 +446,7 @@ tag ty_ {\n     ty_rec([ty_field]);\n     ty_fn(proto, [ty_arg], @ty, controlflow, [@constr]);\n     ty_obj([ty_method]);\n-    ty_tup([mt]);\n+    ty_tup([@ty]);\n     ty_path(path, node_id);\n     ty_type;\n     ty_constr(@ty, [@ty_constr]);"}, {"sha": "177e05fa0917b59aa31c367b717c9718e81a6ba1", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -339,11 +339,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n                      option::map(fld.fold_expr, maybe_expr))\n           }\n           expr_tup(elts) {\n-            let elts_ = ~[];\n-            for elt in elts {\n-                elts_ += ~[{mut: elt.mut, expr: fld.fold_expr(elt.expr)}];\n-            }\n-            expr_tup(elts_)\n+            expr_tup(ivec::map(fld.fold_expr, elts))\n           }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))"}, {"sha": "569a5ad136a5e6bc5fc776c873a7926a5126ad95", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -324,7 +324,7 @@ fn print_type(s: &ps, ty: &ast::ty) {\n       }\n       ast::ty_tup(elts) {\n           popen(s);\n-          commasep(s, inconsistent, elts, print_mt);\n+          commasep(s, inconsistent, elts, print_boxed_type);\n           pclose(s);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n@@ -753,15 +753,8 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         word(s.s, \"}\");\n       }\n       ast::expr_tup(exprs) {\n-        fn printElt(s: &ps, elt: &ast::elt) {\n-            ibox(s, indent_unit);\n-            if elt.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n-            print_expr(s, elt.expr);\n-            end(s);\n-        }\n-        fn get_span(elt: &ast::elt) -> codemap::span { ret elt.expr.span; }\n         popen(s);\n-        commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n+        commasep_exprs(s, inconsistent, exprs);\n         pclose(s);\n       }\n       ast::expr_call(func, args) {"}, {"sha": "3fbca6238ee45f88eadb5baf36386a444f4038df", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -133,8 +133,8 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n       ty_rec(flds) {\n         for f: ty_field  in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n-      ty_tup(mts) {\n-        for mt in mts { v.visit_ty(mt.ty, e, v); }\n+      ty_tup(ts) {\n+        for tt in ts { v.visit_ty(tt, e, v); }\n       }\n       ty_fn(_, args, out, _, constrs) {\n         for a: ty_arg  in args { v.visit_ty(a.node.ty, e, v); }\n@@ -248,7 +248,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n         visit_expr_opt(base, e, v);\n       }\n       expr_tup(elts) {\n-        for el in elts { v.visit_expr(el.expr, e, v); }\n+        for el in elts { v.visit_expr(el, e, v); }\n       }\n       expr_call(callee, args) {\n         v.visit_expr(callee, e, v);"}, {"sha": "d77088d876164ae743c3bd67b6cdc045f2b5aadd", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -47,14 +47,6 @@ fn new_def_hash[@V]() -> std::map::hashmap[ast::def_id, V] {\n     ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);\n }\n \n-fn elt_expr(e: &ast::elt) -> @ast::expr { ret e.expr; }\n-\n-fn elt_exprs(elts: &[ast::elt]) -> [@ast::expr] {\n-    let es = ~[];\n-    for e: ast::elt  in elts { es += ~[e.expr]; }\n-    ret es;\n-}\n-\n fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: &[ast::field]) -> [@ast::expr] {"}, {"sha": "50d2799d7f0fc5ce8d855fdc3d6d407297f63b52", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea87542f8d3996e2bde9a406c4bf7b2ac68af4/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=29ea87542f8d3996e2bde9a406c4bf7b2ac68af4", "patch": "@@ -105,7 +105,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       }\n       ty_tup(elems) {\n         let strs = ~[];\n-        for tm in elems { strs += ~[mt_to_str(cx, tm)]; }\n+        for elem in elems { strs += ~[ty_to_str(cx, elem)]; }\n         s += \"(\" + str::connect(strs, \",\") + \")\";\n       }\n       ty_tag(id, tps) {"}]}