{"sha": "3f5b2219cc893b30863f9136703166f306fcc684", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNWIyMjE5Y2M4OTNiMzA4NjNmOTEzNjcwMzE2NmYzMDZmY2M2ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-24T21:26:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-24T21:26:15Z"}, "message": "auto merge of #9901 : alexcrichton/rust/unix-sockets, r=brson\n\nLarge topics:\r\n\r\n* Implemented `rt::io::net::unix`. We've got an implementation backed by \"named pipes\" for windows for free from libuv, so I'm not sure if these should be `cfg(unix)` or whether they'd be better placed in `rt::io::pipe` (which is currently kinda useless), or to leave in `unix`. Regardless, we probably shouldn't deny windows of functionality which it certainly has.\r\n* Fully implemented `net::addrinfo`, or at least fully implemented in the sense of making the best attempt to wrap libuv's `getaddrinfo` api\r\n* Moved standard I/O to a libuv TTY instead of just a plain old file descriptor. I found that this interacted better when closing stdin, and it has the added bonus of getting things like terminal dimentions (someone should make a progress bar now!)\r\n* Migrate to `~Trait` instead of a typedef'd object where possible. There are only two more types which are blocked on this, and those are traits which have a method which takes by-value self (there's an open issue on this)\r\n* Drop `rt::io::support::PathLike` in favor of just `ToCStr`. We recently had a lot of Path work done, but it still wasn't getting passed down to libuv (there was an intermediate string conversion), and this allows true paths to work all the way down to libuv (and anything else that can become a C string).\r\n* Removes `extra::fileinput` and `extra::io_util`\r\n\r\n\r\nCloses #9895 \r\nCloses #9975\r\nCloses #8330\r\nCloses #6850 (ported lots of libraries away from std::io)\r\ncc #4248 (implemented unix/dns)\r\ncc #9128 (made everything truly trait objects)", "tree": {"sha": "d7267619b1909f2deaf319c560a64d667d141d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7267619b1909f2deaf319c560a64d667d141d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f5b2219cc893b30863f9136703166f306fcc684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5b2219cc893b30863f9136703166f306fcc684", "html_url": "https://github.com/rust-lang/rust/commit/3f5b2219cc893b30863f9136703166f306fcc684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f5b2219cc893b30863f9136703166f306fcc684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "url": "https://api.github.com/repos/rust-lang/rust/commits/61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "html_url": "https://github.com/rust-lang/rust/commit/61f8c059c4c6082683d78b2ee3d963f65fa1eb98"}, {"sha": "188e471339dfe652b8ff9f3bbe4cc262a040c584", "url": "https://api.github.com/repos/rust-lang/rust/commits/188e471339dfe652b8ff9f3bbe4cc262a040c584", "html_url": "https://github.com/rust-lang/rust/commit/188e471339dfe652b8ff9f3bbe4cc262a040c584"}], "stats": {"total": 9388, "additions": 3937, "deletions": 5451}, "files": [{"sha": "056d967ae6ca8ad3b9de23ca0b6ad4f6a2e1cc67", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -43,7 +43,7 @@ $ ./example numbers.txt\n \n An example program that does this task reads like this:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -430,7 +430,7 @@ To trap a condition, use `Condition::trap` in some caller of the site that calls\n For example, this version of the program traps the `malformed_line` condition\n and replaces bad input lines with the pair `(-1,-1)`:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -507,7 +507,7 @@ In the example program, the first form of the `malformed_line` API implicitly as\n This assumption may not be correct; some callers may wish to skip malformed lines, for example.\n Changing the condition's return type from `(int,int)` to `Option<(int,int)>` will suffice to support this type of recovery:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -594,7 +594,7 @@ until all relevant combinations encountered in practice are encoded.\n In the example, suppose a third possible recovery form arose: reusing the previous value read.\n This can be encoded in the handler API by introducing a helper type: `enum MalformedLineFix`.\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -720,7 +720,7 @@ task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libs\n To make the program robust -- or at least flexible -- in the face of this potential failure,\n a second condition and a helper function will suffice:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;"}, {"sha": "4983a5af3e5abc04d93f005f4d87436d08b9b016", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -69,7 +69,6 @@ calling the `spawn` function with a closure argument. `spawn` executes the\n closure in the new task.\n \n ~~~~\n-# use std::io::println;\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function"}, {"sha": "f9f110c122b28673e207abda2199f3b0266af26b", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -2907,12 +2907,12 @@ you just have to import it with an `use` statement.\n For example, it re-exports `println` which is defined in `std::io::println`:\n \n ~~~\n-use puts = std::io::println;\n+use puts = std::rt::io::stdio::println;\n \n fn main() {\n     println(\"println is imported per default.\");\n     puts(\"Doesn't hinder you from importing it under an different name yourself.\");\n-    ::std::io::println(\"Or from not using the automatic import.\");\n+    ::std::rt::io::stdio::println(\"Or from not using the automatic import.\");\n }\n ~~~\n "}, {"sha": "4ae9ad81daff6220aac720ec12e00be33db86f15", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -21,7 +21,10 @@ use util;\n use util::logv;\n \n use std::cell::Cell;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n use std::os;\n use std::str;\n use std::task::{spawn_sched, SingleThreaded};\n@@ -60,7 +63,7 @@ pub fn run(config: config, testfile: ~str) {\n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(\"\\n\\n\");\n+        print!(\"\\n\\n\");\n     }\n     let testfile = Path::new(testfile);\n     debug!(\"running {}\", testfile.display());\n@@ -170,7 +173,9 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let mut srcs = ~[io::read_whole_file_str(testfile).unwrap()];\n+    let src = testfile.open_reader(io::Open).read_to_end();\n+    let src = str::from_utf8_owned(src);\n+    let mut srcs = ~[src];\n \n     let mut round = 0;\n     while round < rounds {\n@@ -190,7 +195,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            io::read_whole_file_str(&filepath).unwrap()\n+            let s = filepath.open_reader(io::Open).read_to_end();\n+            str::from_utf8_owned(s)\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n         };\n@@ -228,8 +234,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n-            let msg =\n-                format!(\"\\n\\\n+            println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n {}\\n\\\n@@ -240,7 +245,6 @@ actual:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n                      expected, actual);\n-            io::stdout().write_str(msg);\n             fail!();\n         }\n     }\n@@ -741,9 +745,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer =\n-        io::file_writer(&outfile, [io::Create, io::Truncate]).unwrap();\n-    writer.write_str(out);\n+    outfile.open_writer(io::CreateOrTruncate).write(out.as_bytes());\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -771,24 +773,20 @@ fn output_base_name(config: &config, testfile: &Path) -> Path {\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n-        let sep1 = format!(\"------{}------------------------------\", \"stdout\");\n-        let sep2 = format!(\"------{}------------------------------\", \"stderr\");\n-        let sep3 = ~\"------------------------------------------\";\n-        io::stdout().write_line(sep1);\n-        io::stdout().write_line(out);\n-        io::stdout().write_line(sep2);\n-        io::stdout().write_line(err);\n-        io::stdout().write_line(sep3);\n+        println!(\"------{}------------------------------\", \"stdout\");\n+        println!(\"{}\", out);\n+        println!(\"------{}------------------------------\", \"stderr\");\n+        println!(\"{}\", err);\n+        println!(\"------------------------------------------\");\n     }\n }\n \n-fn error(err: ~str) { io::stdout().write_line(format!(\"\\nerror: {}\", err)); }\n+fn error(err: ~str) { println!(\"\\nerror: {}\", err); }\n \n fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n-    let msg =\n-        format!(\"\\n\\\n+    print!(\"\\n\\\n error: {}\\n\\\n command: {}\\n\\\n stdout:\\n\\\n@@ -801,7 +799,6 @@ stderr:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n              err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n-    io::stdout().write_str(msg);\n     fail!();\n }\n \n@@ -821,9 +818,9 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n-        io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n+        println!(\"push ({}) {} {} {}\",\n             config.target, args.prog,\n-            copy_result.out, copy_result.err));\n+            copy_result.out, copy_result.err);\n     }\n \n     logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n@@ -913,9 +910,9 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {\n-                io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n+                println!(\"push ({}) {} {} {}\",\n                     config.target, file.display(),\n-                    copy_result.out, copy_result.err));\n+                    copy_result.out, copy_result.err);\n             }\n         }\n     }\n@@ -999,7 +996,8 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_extension(\"ll\")).unwrap();\n+    let x = p.with_extension(\"ll\").open_reader(io::Open).read_to_end();\n+    let x = str::from_utf8_owned(x);\n     x.line_iter().len()\n }\n "}, {"sha": "ae4a25b80084c20d9887be0483c62675647f3edf", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,7 +10,6 @@\n \n use common::config;\n \n-use std::io;\n use std::os::getenv;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n@@ -64,5 +63,5 @@ pub fn path_div() -> ~str { ~\";\" }\n \n pub fn logv(config: &config, s: ~str) {\n     debug!(\"{}\", s);\n-    if config.verbose { io::println(s); }\n+    if config.verbose { println(s); }\n }"}, {"sha": "dc5e11dabdf6822080a5dae22ebbf60a72905f81", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -56,15 +56,15 @@ def scrub(b):\n d.write(\"extern mod extra;\\n\")\n d.write(\"extern mod run_pass_stage2;\\n\")\n d.write(\"use run_pass_stage2::*;\\n\")\n-d.write(\"use std::io::WriterUtil;\\n\");\n-d.write(\"use std::io;\\n\");\n+d.write(\"use std::rt::io;\\n\");\n+d.write(\"use std::rt::io::Writer;\\n\");\n d.write(\"fn main() {\\n\");\n-d.write(\"    let out = io::stdout();\\n\");\n+d.write(\"    let mut out = io::stdout();\\n\");\n i = 0\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write(\\\"run-pass [stage2]: %s\\\\n\\\".as_bytes());\\n\" % p)\n     d.write(\"    t_%d::main();\\n\" % i)\n     i += 1\n d.write(\"}\\n\")"}, {"sha": "f577ed55f9750cef212332ffd9b94bdfbe2d3f02", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -96,16 +96,8 @@ pub mod reader {\n \n     use std::cast::transmute;\n     use std::int;\n-    use std::io;\n     use std::option::{None, Option, Some};\n-\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"x86_64\")]\n-    use std::ptr::offset;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"x86_64\")]\n-    use std::unstable::intrinsics::bswap32;\n+    use std::rt::io::extensions::u64_from_be_bytes;\n \n     // ebml reading\n \n@@ -144,6 +136,9 @@ pub mod reader {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+        use std::ptr::offset;\n+        use std::unstable::intrinsics::bswap32;\n+\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -178,8 +173,7 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n+    #[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n         vuint_at_slow(data, start)\n     }\n@@ -265,17 +259,17 @@ pub mod reader {\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        io::u64_from_be_bytes(*d.data, d.start, 8u)\n+        u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -614,11 +608,15 @@ pub mod writer {\n \n     use std::cast;\n     use std::clone::Clone;\n-    use std::io;\n+    use std::rt::io;\n+    use std::rt::io::{Writer, Seek};\n+    use std::rt::io::mem::MemWriter;\n+    use std::rt::io::extensions::u64_to_be_bytes;\n \n     // ebml writing\n     pub struct Encoder {\n-        writer: @io::Writer,\n+        // FIXME(#5665): this should take a trait object\n+        writer: @mut MemWriter,\n         priv size_positions: ~[uint],\n     }\n \n@@ -631,7 +629,7 @@ pub mod writer {\n         }\n     }\n \n-    fn write_sized_vuint(w: @io::Writer, n: uint, size: uint) {\n+    fn write_sized_vuint(w: @mut MemWriter, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -643,15 +641,15 @@ pub mod writer {\n         };\n     }\n \n-    fn write_vuint(w: @io::Writer, n: uint) {\n+    fn write_vuint(w: @mut MemWriter, n: uint) {\n         if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n         fail!(\"vint to write too big: {}\", n);\n     }\n \n-    pub fn Encoder(w: @io::Writer) -> Encoder {\n+    pub fn Encoder(w: @mut MemWriter) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n@@ -668,18 +666,18 @@ pub mod writer {\n             write_vuint(self.writer, tag_id);\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(self.writer.tell());\n+            self.size_positions.push(self.writer.tell() as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n             self.writer.write(zeroes);\n         }\n \n         pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n-            self.writer.seek(last_size_pos as int, io::SeekSet);\n-            let size = (cur_pos - last_size_pos - 4u);\n-            write_sized_vuint(self.writer, size, 4u);\n-            self.writer.seek(cur_pos as int, io::SeekSet);\n+            self.writer.seek(last_size_pos as i64, io::SeekSet);\n+            let size = (cur_pos as uint - last_size_pos - 4);\n+            write_sized_vuint(self.writer, size as uint, 4u);\n+            self.writer.seek(cur_pos as i64, io::SeekSet);\n \n             debug!(\"End tag (size = {})\", size);\n         }\n@@ -697,19 +695,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            do io::u64_to_be_bytes(v, 8u) |v| {\n+            do u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n@@ -719,19 +717,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            do io::u64_to_be_bytes(v as u64, 8u) |v| {\n+            do u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n@@ -963,18 +961,18 @@ mod tests {\n     use serialize::Encodable;\n     use serialize;\n \n-    use std::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n     use std::option::{None, Option, Some};\n \n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {:?}\", v);\n-            let bytes = do io::with_bytes_writer |wr| {\n-                let mut ebml_w = writer::Encoder(wr);\n-                v.encode(&mut ebml_w)\n-            };\n-            let ebml_doc = reader::Doc(@bytes);\n+            let wr = @mut MemWriter::new();\n+            let mut ebml_w = writer::Encoder(wr);\n+            v.encode(&mut ebml_w);\n+            let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == {:?}\", v1);"}, {"sha": "3ea164fb456f86d7ac1d875193133bf6329773f3", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -45,7 +45,6 @@ pub use std::os;\n // Utility modules\n \n pub mod c_vec;\n-pub mod io_util;\n \n // Concurrency\n \n@@ -104,7 +103,6 @@ pub mod rational;\n pub mod complex;\n pub mod stats;\n pub mod semver;\n-pub mod fileinput;\n pub mod flate;\n pub mod hex;\n pub mod uuid;"}, {"sha": "49072dab6d025c76ada29125361f0d86affecf8e", "filename": "src/libextra/fileinput.rs", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "patch": "@@ -1,629 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-A library for iterating through the lines in a series of\n-files. Very similar to [the Python module of the same\n-name](http://docs.python.org/3.3/library/fileinput.html).\n-\n-It allows the programmer to automatically take filenames from the\n-command line arguments (via `input` and `input_state`), as well as\n-specify them as a vector directly (`input_vec` and\n-`input_vec_state`). The files are opened as necessary, so any files\n-that can't be opened only cause an error when reached in the\n-iteration.\n-\n-On the command line, `stdin` is represented by a filename of `-` (a\n-single hyphen) and in the functions that take a vector directly\n-(e.g. `input_vec`) it is represented by `None`. Note `stdin` is *not*\n-reset once it has been finished, so attempting to iterate on `[None,\n-None]` will only take input once unless `io::stdin().seek(0, SeekSet)`\n-is called between.\n-\n-The `make_path_option_vec` function handles converting a list of file paths as\n-strings to the appropriate format, including the (optional) conversion\n-of `\"-\"` to `stdin`.\n-\n-# Basic\n-\n-In many cases, one can use the `input_*` functions without having\n-to handle any `FileInput` structs. E.g. a simple `cat` program\n-\n-    for input |line| {\n-        io::println(line)\n-    }\n-\n-or a program that numbers lines after concatenating two files\n-\n-    for input_vec_state(make_path_option_vec([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n-        io::println(format!(\"{}: %s\", state.line_num,\n-                                   line));\n-    }\n-\n-The two `input_vec*` functions take a vec of file names (where empty\n-means read from `stdin`), the other two functions use the command line\n-arguments.\n-\n-# Advanced\n-\n-For more complicated uses (e.g. if one needs to pause iteration and\n-resume it later), a `FileInput` instance can be constructed via the\n-`from_vec`, `from_vec_raw` and `from_args` functions.\n-\n-Once created, the `each_line` (from the `std::io::ReaderUtil` trait)\n-and `each_line_state` methods allow one to iterate on the lines; the\n-latter provides more information about the position within the\n-iteration to the caller.\n-\n-It is possible (and safe) to skip lines and files using the\n-`read_line` and `next_file` methods. Also, `FileInput` implements\n-`std::io::Reader`, and the state will be updated correctly while\n-using any of those methods.\n-\n-E.g. the following program reads until an empty line, pauses for user\n-input, skips the current file and then numbers the remaining lines\n-(where the numbers are from the start of each file, rather than the\n-total line count).\n-\n-    let input = FileInput::from_vec(pathify([~\"a.txt\", ~\"b.txt\", ~\"c.txt\"],\n-                                             true));\n-\n-    for input.each_line |line| {\n-        if line.is_empty() {\n-            break\n-        }\n-        io::println(line);\n-    }\n-\n-    io::println(\"Continue?\");\n-\n-    if io::stdin().read_line() == ~\"yes\" {\n-        input.next_file(); // skip!\n-\n-        for input.each_line_state |line, state| {\n-           io::println(format!(\"{}: %s\", state.line_num_file,\n-                                      line))\n-        }\n-    }\n-*/\n-\n-#[allow(missing_doc)];\n-\n-\n-use std::io::ReaderUtil;\n-use std::io;\n-use std::os;\n-\n-/**\n-A summary of the internal state of a `FileInput` object. `line_num`\n-and `line_num_file` represent the number of lines read in total and in\n-the current file respectively. `current_path` is `None` if the current\n-file is `stdin`.\n-*/\n-#[deriving(Clone)]\n-pub struct FileInputState {\n-    current_path: Option<Path>,\n-    line_num: uint,\n-    line_num_file: uint\n-}\n-\n-impl FileInputState {\n-    fn is_stdin(&self) -> bool {\n-        self.current_path.is_none()\n-    }\n-\n-    fn is_first_line(&self) -> bool {\n-        self.line_num_file == 1\n-    }\n-}\n-\n-struct FileInput_ {\n-    /**\n-    `Some(path)` is the file represented by `path`, `None` is\n-    `stdin`. Consumed as the files are read.\n-    */\n-    files: ~[Option<Path>],\n-    /**\n-    The current file: `Some(r)` for an open file, `None` before\n-    starting and after reading everything.\n-    */\n-    current_reader: Option<@io::Reader>,\n-    state: FileInputState,\n-\n-    /**\n-    Used to keep track of whether we need to insert the newline at the\n-    end of a file that is missing it, which is needed to separate the\n-    last and first lines.\n-    */\n-    previous_was_newline: bool\n-}\n-\n-\n-// FIXME #5723: remove this when Reader has &mut self.\n-// Removing it would mean giving read_byte in the Reader impl for\n-// FileInput &mut self, which in turn means giving most of the\n-// io::Reader trait methods &mut self. That can't be done right now\n-// because of io::with_bytes_reader and #5723.\n-// Should be removable via\n-// \"self.fi\" -> \"self.\" and renaming FileInput_. Documentation above\n-// will likely have to be updated to use `let mut in = ...`.\n-pub struct FileInput  {\n-    priv fi: @mut FileInput_\n-}\n-\n-impl FileInput {\n-    /**\n-    Create a `FileInput` object from a vec of files. An empty\n-    vec means lines are read from `stdin` (use `from_vec_raw` to stop\n-    this behaviour). Any occurrence of `None` represents `stdin`.\n-    */\n-    pub fn from_vec(files: ~[Option<Path>]) -> FileInput {\n-        FileInput::from_vec_raw(\n-            if files.is_empty() {\n-                ~[None]\n-            } else {\n-                files\n-            })\n-    }\n-\n-    /**\n-    Identical to `from_vec`, but an empty `files` vec stays\n-    empty. (`None` is `stdin`.)\n-    */\n-    pub fn from_vec_raw(files: ~[Option<Path>])\n-                                         -> FileInput {\n-        FileInput{\n-            fi: @mut FileInput_ {\n-                files: files,\n-                current_reader: None,\n-                state: FileInputState {\n-                    current_path: None,\n-                    line_num: 0,\n-                    line_num_file: 0\n-                },\n-                // there was no previous unended line\n-                previous_was_newline: true\n-            }\n-        }\n-    }\n-\n-    /**\n-    Create a `FileInput` object from the command line\n-    arguments. `\"-\"` represents `stdin`.\n-    */\n-    pub fn from_args() -> FileInput {\n-        let args = os::args();\n-        let pathed = make_path_option_vec(args.tail(), true);\n-        FileInput::from_vec(pathed)\n-    }\n-\n-    fn current_file_eof(&self) -> bool {\n-        match self.fi.current_reader {\n-            None => false,\n-            Some(r) => r.eof()\n-        }\n-    }\n-\n-    /**\n-    Skip to the next file in the queue. Can `fail` when opening\n-    a file.\n-\n-    Returns `false` if there is no more files, and `true` when it\n-    successfully opens the next file.\n-    */\n-\n-    pub fn next_file(&self) -> bool {\n-        // No more files\n-\n-        if self.fi.files.is_empty() {\n-            self.fi.current_reader = None;\n-            return false;\n-        }\n-\n-        let path_option = self.fi.files.shift();\n-        let file = match path_option {\n-            None => io::stdin(),\n-            Some(ref path) => io::file_reader(path).unwrap()\n-        };\n-\n-        self.fi.current_reader = Some(file);\n-        self.fi.state.current_path = path_option;\n-        self.fi.state.line_num_file = 0;\n-        true\n-    }\n-\n-    /**\n-    Attempt to open the next file if there is none currently open,\n-    or if the current one is EOF'd.\n-\n-    Returns `true` if it had to move to the next file and did\n-    so successfully.\n-    */\n-    fn next_file_if_eof(&self) -> bool {\n-        match self.fi.current_reader {\n-            None => self.next_file(),\n-            Some(r) => {\n-                if r.eof() {\n-                    self.next_file()\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-    Apply `f` to each line successively, along with some state\n-    (line numbers and file names, see documentation for\n-    `FileInputState`). Otherwise identical to `lines_each`.\n-    */\n-    pub fn each_line_state(&self,\n-                            f: &fn(&str, FileInputState) -> bool) -> bool {\n-         self.each_line(|line| f(line, self.fi.state.clone()))\n-    }\n-\n-\n-    /**\n-    Retrieve the current `FileInputState` information.\n-    */\n-    pub fn state(&self) -> FileInputState {\n-        self.fi.state.clone()\n-    }\n-}\n-\n-impl io::Reader for FileInput {\n-    fn read_byte(&self) -> int {\n-        loop {\n-            let stepped = self.next_file_if_eof();\n-\n-            // if we moved to the next file, and the previous\n-            // character wasn't \\n, then there is an unfinished line\n-            // from the previous file. This library models\n-            // line-by-line processing and the trailing line of the\n-            // previous file and the leading of the current file\n-            // should be considered different, so we need to insert a\n-            // fake line separator\n-            if stepped && !self.fi.previous_was_newline {\n-                self.fi.state.line_num += 1;\n-                self.fi.state.line_num_file += 1;\n-                self.fi.previous_was_newline = true;\n-                return '\\n' as int;\n-            }\n-\n-            match self.fi.current_reader {\n-                None => return -1,\n-                Some(r) => {\n-                    let b = r.read_byte();\n-\n-                    if b < 0 {\n-                        continue;\n-                    }\n-\n-                    if b == '\\n' as int {\n-                        self.fi.state.line_num += 1;\n-                        self.fi.state.line_num_file += 1;\n-                        self.fi.previous_was_newline = true;\n-                    } else {\n-                        self.fi.previous_was_newline = false;\n-                    }\n-\n-                    return b;\n-                }\n-            }\n-        }\n-    }\n-    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n-        let mut count = 0;\n-        while count < len {\n-            let b = self.read_byte();\n-            if b < 0 { break }\n-\n-            buf[count] = b as u8;\n-            count += 1;\n-        }\n-\n-        count\n-    }\n-    fn eof(&self) -> bool {\n-        // we've run out of files, and current_reader is either None or eof.\n-\n-        self.fi.files.is_empty() &&\n-            match self.fi.current_reader { None => true, Some(r) => r.eof() }\n-\n-    }\n-    fn seek(&self, offset: int, whence: io::SeekStyle) {\n-        match self.fi.current_reader {\n-            None => {},\n-            Some(r) => r.seek(offset, whence)\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        match self.fi.current_reader {\n-            None => 0,\n-            Some(r) => r.tell()\n-        }\n-    }\n-}\n-\n-/**\n-Convert a list of strings to an appropriate form for a `FileInput`\n-instance. `stdin_hyphen` controls whether `-` represents `stdin` or\n-a literal `-`.\n-*/\n-pub fn make_path_option_vec(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec.iter().map(|s| {\n-        if stdin_hyphen && \"-\" == *s {\n-            None\n-        } else {\n-            Some(Path::new(s.as_slice()))\n-        }\n-    }).collect()\n-}\n-\n-/**\n-Iterate directly over the command line arguments (no arguments implies\n-reading from `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input(f: &fn(&str) -> bool) -> bool {\n-    let i = FileInput::from_args();\n-    i.each_line(f)\n-}\n-\n-/**\n-Iterate directly over the command line arguments (no arguments\n-implies reading from `stdin`) with the current state of the iteration\n-provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_state(f: &fn(&str, FileInputState) -> bool) -> bool {\n-    let i = FileInput::from_args();\n-    i.each_line_state(f)\n-}\n-\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) -> bool {\n-    let i = FileInput::from_vec(files);\n-    i.each_line(f)\n-}\n-\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`)\n-with the current state of the iteration provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_vec_state(files: ~[Option<Path>],\n-                       f: &fn(&str, FileInputState) -> bool) -> bool {\n-    let i = FileInput::from_vec(files);\n-    i.each_line_state(f)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{FileInput, make_path_option_vec, input_vec, input_vec_state};\n-\n-    use std::rt::io;\n-    use std::rt::io::Writer;\n-    use std::rt::io::file;\n-    use std::vec;\n-\n-    fn make_file(path : &Path, contents: &[~str]) {\n-        let mut file = file::open(path, io::CreateOrTruncate, io::Write).unwrap();\n-\n-        for str in contents.iter() {\n-            file.write(str.as_bytes());\n-            file.write(['\\n' as u8]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_make_path_option_vec() {\n-        let strs = [~\"some/path\",\n-                    ~\"some/other/path\"];\n-        let paths = ~[Some(Path::new(\"some/path\")),\n-                      Some(Path::new(\"some/other/path\"))];\n-\n-        assert_eq!(make_path_option_vec(strs, true), paths.clone());\n-        assert_eq!(make_path_option_vec(strs, false), paths);\n-\n-        assert_eq!(make_path_option_vec([~\"-\"], true), ~[None]);\n-        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path::new(\"-\"))]);\n-    }\n-\n-    #[test]\n-    fn test_fileinput_read_byte() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-byte-{}.tmp\", i)), true);\n-\n-        // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n-        }\n-\n-        let fi = FileInput::from_vec(filenames.clone());\n-\n-        for (line, c) in \"012\".iter().enumerate() {\n-            assert_eq!(fi.read_byte(), c as int);\n-            assert_eq!(fi.state().line_num, line);\n-            assert_eq!(fi.state().line_num_file, 0);\n-            assert_eq!(fi.read_byte(), '\\n' as int);\n-            assert_eq!(fi.state().line_num, line + 1);\n-            assert_eq!(fi.state().line_num_file, 1);\n-\n-            assert_eq!(fi.state().current_path.clone(), filenames[line].clone());\n-        }\n-\n-        assert_eq!(fi.read_byte(), -1);\n-        assert!(fi.eof());\n-        assert_eq!(fi.state().line_num, 3)\n-\n-    }\n-\n-    #[test]\n-    fn test_fileinput_read() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-{}.tmp\", i)), true);\n-\n-        // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n-        }\n-\n-        let fi = FileInput::from_vec(filenames);\n-        let mut buf : ~[u8] = vec::from_elem(6, 0u8);\n-        let count = fi.read(buf, 10);\n-        assert_eq!(count, 6);\n-        assert_eq!(buf, \"0\\n1\\n2\\n\".as_bytes().to_owned());\n-        assert!(fi.eof())\n-        assert_eq!(fi.state().line_num, 3);\n-    }\n-\n-    #[test]\n-    fn test_input_vec() {\n-        let mut all_lines = ~[];\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-input-vec-{}.tmp\", i)), true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents =\n-                vec::from_fn(3, |j| format!(\"{} {}\", i, j));\n-            make_file(filename.get_ref(), contents);\n-            debug!(\"contents={:?}\", contents);\n-            all_lines.push_all(contents);\n-        }\n-\n-        let mut read_lines = ~[];\n-        do input_vec(filenames) |line| {\n-            read_lines.push(line.to_owned());\n-            true\n-        };\n-        assert_eq!(read_lines, all_lines);\n-    }\n-\n-    #[test]\n-    fn test_input_vec_state() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-input-vec-state-{}.tmp\", i)),true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents =\n-                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n-            make_file(filename.get_ref(), contents);\n-        }\n-\n-        do input_vec_state(filenames) |line, state| {\n-            let nums: ~[&str] = line.split_iter(' ').collect();\n-            let file_num = from_str::<uint>(nums[0]).unwrap();\n-            let line_num = from_str::<uint>(nums[1]).unwrap();\n-            assert_eq!(line_num, state.line_num_file);\n-            assert_eq!(file_num * 3 + line_num, state.line_num);\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    fn test_empty_files() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-empty-files-{}.tmp\", i)),true);\n-\n-        make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n-        make_file(filenames[1].get_ref(), []);\n-        make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n-\n-        let mut count = 0;\n-        do input_vec_state(filenames.clone()) |line, state| {\n-            let expected_path = match line {\n-                \"1\" | \"2\" => filenames[0].clone(),\n-                \"3\" | \"4\" => filenames[2].clone(),\n-                _ => fail!(\"unexpected line\")\n-            };\n-            assert_eq!(state.current_path.clone(), expected_path);\n-            count += 1;\n-            true\n-        };\n-        assert_eq!(count, 4);\n-    }\n-\n-    #[test]\n-    fn test_no_trailing_newline() {\n-        let f1 =\n-            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n-        let f2 =\n-            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n-\n-        {\n-            let mut wr = file::open(f1.get_ref(), io::CreateOrTruncate,\n-                                    io::Write).unwrap();\n-            wr.write(\"1\\n2\".as_bytes());\n-            let mut wr = file::open(f2.get_ref(), io::CreateOrTruncate,\n-                                    io::Write).unwrap();\n-            wr.write(\"3\\n4\".as_bytes());\n-        }\n-\n-        let mut lines = ~[];\n-        do input_vec(~[f1, f2]) |line| {\n-            lines.push(line.to_owned());\n-            true\n-        };\n-        assert_eq!(lines, ~[~\"1\", ~\"2\", ~\"3\", ~\"4\"]);\n-    }\n-\n-\n-    #[test]\n-    fn test_next_file() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-next-file-{}.tmp\", i)),true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents = vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n-            make_file(filename.get_ref(), contents);\n-        }\n-\n-        let input = FileInput::from_vec(filenames);\n-\n-        // read once from 0\n-        assert_eq!(input.read_line(), ~\"0 1\");\n-        input.next_file(); // skip the rest of 1\n-\n-        // read all lines from 1 (but don't read any from 2),\n-        for i in range(1u, 4) {\n-            assert_eq!(input.read_line(), format!(\"1 {}\", i));\n-        }\n-        // 1 is finished, but 2 hasn't been started yet, so this will\n-        // just \"skip\" to the beginning of 2 (Python's fileinput does\n-        // the same)\n-        input.next_file();\n-\n-        assert_eq!(input.read_line(), ~\"2 1\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_input_vec_missing_file() {\n-        do input_vec(make_path_option_vec([~\"this/file/doesnt/exist\"], true)) |line| {\n-            println(line);\n-            true\n-        };\n-    }\n-}"}, {"sha": "27a09be3a625b81fd1122fcc236317daeca59652", "filename": "src/libextra/io_util.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::io::{Reader, BytesReader};\n-use std::io;\n-use std::cast;\n-\n-/// An implementation of the io::Reader interface which reads a buffer of bytes\n-pub struct BufReader {\n-    /// The buffer of bytes to read\n-    priv buf: ~[u8],\n-    /// The current position in the buffer of bytes\n-    priv pos: @mut uint\n-}\n-\n-impl BufReader {\n-    /// Creates a new buffer reader for the specified buffer\n-    pub fn new(v: ~[u8]) -> BufReader {\n-        BufReader {\n-            buf: v,\n-            pos: @mut 0\n-        }\n-    }\n-\n-    fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n-        // FIXME(#5723)\n-        let bytes = ::std::util::id::<&[u8]>(self.buf);\n-        let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n-        // Recreating the BytesReader state every call since\n-        // I can't get the borrowing to work correctly\n-        let bytes_reader = BytesReader {\n-            bytes: bytes,\n-            pos: @mut *self.pos\n-        };\n-\n-        let res = f(&bytes_reader);\n-\n-        // FIXME #4429: This isn't correct if f fails\n-        *self.pos = *bytes_reader.pos;\n-\n-        return res;\n-    }\n-}\n-\n-impl Reader for BufReader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.as_bytes_reader(|r| r.read(bytes, len) )\n-    }\n-    fn read_byte(&self) -> int {\n-        self.as_bytes_reader(|r| r.read_byte() )\n-    }\n-    fn eof(&self) -> bool {\n-        self.as_bytes_reader(|r| r.eof() )\n-    }\n-    fn seek(&self, offset: int, whence: io::SeekStyle) {\n-        self.as_bytes_reader(|r| r.seek(offset, whence) )\n-    }\n-    fn tell(&self) -> uint {\n-        self.as_bytes_reader(|r| r.tell() )\n-    }\n-}"}, {"sha": "0aab7b743ba73648147c77bf118c744b2a999573", "filename": "src/libextra/json.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -20,8 +20,10 @@ use std::char;\n use std::cast::transmute;\n use std::f64;\n use std::hashmap::HashMap;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Decorator;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::mem::MemWriter;\n use std::num;\n use std::str;\n use std::to_str;\n@@ -86,19 +88,17 @@ fn spaces(n: uint) -> ~str {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder {\n-    priv wr: @io::Writer,\n+    priv wr: @mut io::Writer,\n }\n \n /// Creates a new JSON encoder whose output will be written to the writer\n /// specified.\n-pub fn Encoder(wr: @io::Writer) -> Encoder {\n-    Encoder {\n-        wr: wr\n-    }\n+pub fn Encoder(wr: @mut io::Writer) -> Encoder {\n+    Encoder { wr: wr }\n }\n \n impl serialize::Encoder for Encoder {\n-    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -114,17 +114,21 @@ impl serialize::Encoder for Encoder {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            self.wr.write_str(\"true\");\n+            write!(self.wr, \"true\");\n         } else {\n-            self.wr.write_str(\"false\");\n+            write!(self.wr, \"false\");\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f64(&mut self, v: f64) {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+    }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)) }\n+    fn emit_str(&mut self, v: &str) {\n+        write!(self.wr, \"{}\", escape_str(v))\n+    }\n \n     fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n \n@@ -137,23 +141,19 @@ impl serialize::Encoder for Encoder {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n+            write!(self.wr, \"{}\", escape_str(name));\n         } else {\n-            self.wr.write_char('{');\n-            self.wr.write_str(\"\\\"variant\\\"\");\n-            self.wr.write_char(':');\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_char(',');\n-            self.wr.write_str(\"\\\"fields\\\"\");\n-            self.wr.write_str(\":[\");\n+            write!(self.wr, \"\\\\{\\\"variant\\\":\");\n+            write!(self.wr, \"{}\", escape_str(name));\n+            write!(self.wr, \",\\\"fields\\\":[\");\n             f(self);\n-            self.wr.write_str(\"]}\");\n+            write!(self.wr, \"]\\\\}\");\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n         if idx != 0 {\n-            self.wr.write_char(',');\n+            write!(self.wr, \",\");\n         }\n         f(self);\n     }\n@@ -174,18 +174,17 @@ impl serialize::Encoder for Encoder {\n     }\n \n     fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('{');\n+        write!(self.wr, r\"\\{\");\n         f(self);\n-        self.wr.write_char('}');\n+        write!(self.wr, r\"\\}\");\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: &fn(&mut Encoder)) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_char(':');\n+        if idx != 0 { write!(self.wr, \",\") }\n+        write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n@@ -211,52 +210,52 @@ impl serialize::Encoder for Encoder {\n     fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n \n     fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('[');\n+        write!(self.wr, \"[\");\n         f(self);\n-        self.wr.write_char(']');\n+        write!(self.wr, \"]\");\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n         if idx != 0 {\n-            self.wr.write_char(',');\n+            write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('{');\n+        write!(self.wr, r\"\\{\");\n         f(self);\n-        self.wr.write_char('}');\n+        write!(self.wr, r\"\\}\");\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n-        if idx != 0 { self.wr.write_char(','); }\n+        if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char(':');\n+        write!(self.wr, \":\");\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder {\n-    priv wr: @io::Writer,\n+    priv wr: @mut io::Writer,\n     priv indent: uint,\n }\n \n /// Creates a new encoder whose output will be written to the specified writer\n-pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n+pub fn PrettyEncoder(wr: @mut io::Writer) -> PrettyEncoder {\n     PrettyEncoder {\n         wr: wr,\n         indent: 0,\n     }\n }\n \n impl serialize::Encoder for PrettyEncoder {\n-    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -272,17 +271,19 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            self.wr.write_str(\"true\");\n+            write!(self.wr, \"true\");\n         } else {\n-            self.wr.write_str(\"false\");\n+            write!(self.wr, \"false\");\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f64(&mut self, v: f64) {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+    }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)); }\n+    fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n     fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n         f(self)\n@@ -294,29 +295,23 @@ impl serialize::Encoder for PrettyEncoder {\n                          cnt: uint,\n                          f: &fn(&mut PrettyEncoder)) {\n         if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n+            write!(self.wr, \"{}\", escape_str(name));\n         } else {\n-            self.wr.write_char('[');\n             self.indent += 2;\n-            self.wr.write_char('\\n');\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent), escape_str(name));\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: &fn(&mut PrettyEncoder)) {\n         if idx != 0 {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self)\n     }\n \n@@ -341,15 +336,13 @@ impl serialize::Encoder for PrettyEncoder {\n                    len: uint,\n                    f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n-            self.wr.write_char('{');\n+            write!(self.wr, \"\\\\{\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n         }\n     }\n \n@@ -358,13 +351,11 @@ impl serialize::Encoder for PrettyEncoder {\n                          idx: uint,\n                          f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n+        write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name));\n         f(self);\n     }\n \n@@ -393,54 +384,50 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"[]\");\n+            write!(self.wr, \"[]\");\n         } else {\n-            self.wr.write_char('[');\n+            write!(self.wr, \"[\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n         }\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self)\n     }\n \n     fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n-            self.wr.write_char('{');\n+            write!(self.wr, \"\\\\{\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n         }\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self);\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n-        self.wr.write_str(\": \");\n+        write!(self.wr, \": \");\n         f(self);\n     }\n }\n@@ -460,21 +447,23 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: @io::Writer) {\n+    pub fn to_writer(&self, wr: @mut io::Writer) {\n         let mut encoder = Encoder(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: @io::Writer) {\n+    pub fn to_pretty_writer(&self, wr: @mut io::Writer) {\n         let mut encoder = PrettyEncoder(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n-        io::with_str_writer(|wr| self.to_pretty_writer(wr))\n+        let s = @mut MemWriter::new();\n+        self.to_pretty_writer(s as @mut io::Writer);\n+        str::from_utf8(s.inner_ref().as_slice())\n     }\n }\n \n@@ -853,9 +842,9 @@ impl<T : Iterator<char>> Parser<T> {\n     }\n }\n \n-/// Decodes a json value from an @io::Reader\n-pub fn from_reader(rdr: @io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8(rdr.read_whole_stream());\n+/// Decodes a json value from an `&mut io::Reader`\n+pub fn from_reader(mut rdr: &mut io::Reader) -> Result<Json, Error> {\n+    let s = str::from_utf8(rdr.read_to_end());\n     let mut parser = Parser(~s.iter());\n     parser.parse()\n }\n@@ -1306,7 +1295,9 @@ impl<A:ToJson> ToJson for Option<A> {\n impl to_str::ToStr for Json {\n     /// Encodes a json value into a string\n     fn to_str(&self) -> ~str {\n-      io::with_str_writer(|wr| self.to_writer(wr))\n+        let s = @mut MemWriter::new();\n+        self.to_writer(s as @mut io::Writer);\n+        str::from_utf8(s.inner_ref().as_slice())\n     }\n }\n \n@@ -1321,8 +1312,7 @@ mod tests {\n \n     use super::*;\n \n-    use std::io;\n-\n+    use std::rt::io;\n     use serialize::Decodable;\n     use treemap::TreeMap;\n \n@@ -1493,18 +1483,28 @@ mod tests {\n         assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n     }\n \n+    fn with_str_writer(f: &fn(@mut io::Writer)) -> ~str {\n+        use std::rt::io::mem::MemWriter;\n+        use std::rt::io::Decorator;\n+        use std::str;\n+\n+        let m = @mut MemWriter::new();\n+        f(m as @mut io::Writer);\n+        str::from_utf8(*m.inner_ref())\n+    }\n+\n     #[test]\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n             },\n@@ -1513,14 +1513,14 @@ mod tests {\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n             },\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n             },\n@@ -1536,14 +1536,14 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = PrettyEncoder(wr);\n             value.encode(&mut encoder);\n         };\n@@ -1553,13 +1553,13 @@ mod tests {\n     #[test]\n     fn test_write_none() {\n         let value: Option<~str> = None;\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n \n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };"}, {"sha": "0ab38cdb5df83ff01b70be38a2485a5095d124a9", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -30,8 +30,6 @@\n \n use std::char;\n use std::cmp;\n-use std::io::{ReaderUtil};\n-use std::io;\n use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n \n@@ -147,14 +145,19 @@ condition! {\n     bad_parse: () -> ();\n }\n \n-fn take_nonempty_prefix(rdr: @io::Reader,\n-                        ch: char,\n-                        pred: &fn(char) -> bool) -> (~str, char) {\n+fn take_nonempty_prefix<T: Iterator<char>>(rdr: &mut T,\n+                        pred: &fn(char) -> bool) -> (~str, Option<char>) {\n     let mut buf = ~\"\";\n-    let mut ch = ch;\n-    while pred(ch) {\n-        buf.push_char(ch);\n-        ch = rdr.read_char();\n+    let mut ch = rdr.next();\n+    loop {\n+        match ch {\n+            None => break,\n+            Some(c) if !pred(c) => break,\n+            Some(c) => {\n+                buf.push_char(c);\n+                ch = rdr.next();\n+            }\n+        }\n     }\n     if buf.is_empty() {\n         bad_parse::cond.raise(())\n@@ -163,16 +166,16 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     (buf, ch)\n }\n \n-fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n-    let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n+fn take_num<T: Iterator<char>>(rdr: &mut T) -> (uint, Option<char>) {\n+    let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n     match from_str::<uint>(s) {\n         None => { bad_parse::cond.raise(()); (0, ch) },\n         Some(i) => (i, ch)\n     }\n }\n \n-fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n-    let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n+fn take_ident<T: Iterator<char>>(rdr: &mut T) -> (Identifier, Option<char>) {\n+    let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n     if s.iter().all(char::is_digit) {\n         match from_str::<uint>(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n@@ -183,38 +186,38 @@ fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     }\n }\n \n-fn expect(ch: char, c: char) {\n-    if ch != c {\n+fn expect(ch: Option<char>, c: char) {\n+    if ch != Some(c) {\n         bad_parse::cond.raise(())\n     }\n }\n \n-fn parse_reader(rdr: @io::Reader) -> Version {\n-    let (major, ch) = take_num(rdr, rdr.read_char());\n+fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Version {\n+    let (major, ch) = take_num(rdr);\n     expect(ch, '.');\n-    let (minor, ch) = take_num(rdr, rdr.read_char());\n+    let (minor, ch) = take_num(rdr);\n     expect(ch, '.');\n-    let (patch, ch) = take_num(rdr, rdr.read_char());\n+    let (patch, ch) = take_num(rdr);\n \n     let mut pre = ~[];\n     let mut build = ~[];\n \n     let mut ch = ch;\n-    if ch == '-' {\n+    if ch == Some('-') {\n         loop {\n-            let (id, c) = take_ident(rdr, rdr.read_char());\n+            let (id, c) = take_ident(rdr);\n             pre.push(id);\n             ch = c;\n-            if ch != '.' { break; }\n+            if ch != Some('.') { break; }\n         }\n     }\n \n-    if ch == '+' {\n+    if ch == Some('+') {\n         loop {\n-            let (id, c) = take_ident(rdr, rdr.read_char());\n+            let (id, c) = take_ident(rdr);\n             build.push(id);\n             ch = c;\n-            if ch != '.' { break; }\n+            if ch != Some('.') { break; }\n         }\n     }\n \n@@ -236,13 +239,11 @@ pub fn parse(s: &str) -> Option<Version> {\n     let s = s.trim();\n     let mut bad = false;\n     do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n-        do io::with_str_reader(s) |rdr| {\n-            let v = parse_reader(rdr);\n-            if bad || v.to_str() != s.to_owned() {\n-                None\n-            } else {\n-                Some(v)\n-            }\n+        let v = parse_iter(&mut s.iter());\n+        if bad || v.to_str() != s.to_owned() {\n+            None\n+        } else {\n+            Some(v)\n         }\n     }\n }"}, {"sha": "497145ca7c992c6468422c775e45aa205df5ef5b", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,7 +13,7 @@\n use sort;\n use std::cmp;\n use std::hashmap;\n-use std::io;\n+use std::rt::io;\n use std::num;\n \n // NB: this can probably be rewritten in terms of num::Num\n@@ -273,14 +273,14 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n+pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n     let (q1,q2,q3) = s.quartiles;\n-    w.write_str(format!(\"(min={}, q1={}, med={}, q3={}, max={})\",\n+    write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n                      s.min,\n                      q1,\n                      q2,\n                      q3,\n-                     s.max));\n+                     s.max);\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n@@ -295,7 +295,7 @@ pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n ///   10 |        [--****#******----------]          | 40\n /// ~~~~\n \n-pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n+pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n \n     let (q1,q2,q3) = s.quartiles;\n \n@@ -325,52 +325,48 @@ pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n     let range_width = width_hint - overhead_width;;\n     let char_step = range / (range_width as f64);\n \n-    w.write_str(lostr);\n-    w.write_char(' ');\n-    w.write_char('|');\n+    write!(w, \"{} |\", lostr);\n \n     let mut c = 0;\n     let mut v = lo;\n \n     while c < range_width && v < s.min {\n-        w.write_char(' ');\n+        write!(w, \" \");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char('[');\n+    write!(w, \"[\");\n     c += 1;\n     while c < range_width && v < q1 {\n-        w.write_char('-');\n+        write!(w, \"-\");\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n-        w.write_char('*');\n+        write!(w, \"*\");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char('#');\n+    write!(w, r\"\\#\");\n     c += 1;\n     while c < range_width && v < q3 {\n-        w.write_char('*');\n+        write!(w, \"*\");\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n-        w.write_char('-');\n+        write!(w, \"-\");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char(']');\n+    write!(w, \"]\");\n     while c < range_width {\n-        w.write_char(' ');\n+        write!(w, \" \");\n         v += char_step;\n         c += 1;\n     }\n \n-    w.write_char('|');\n-    w.write_char(' ');\n-    w.write_str(histr);\n+    write!(w, \"| {}\", histr);\n }\n \n /// Returns a HashMap with the number of occurrences of every element in the\n@@ -392,18 +388,20 @@ mod tests {\n     use stats::Summary;\n     use stats::write_5_number_summary;\n     use stats::write_boxplot;\n-    use std::io;\n+    use std::rt::io;\n+    use std::str;\n \n     fn check(samples: &[f64], summ: &Summary) {\n \n         let summ2 = Summary::new(samples);\n \n-        let w = io::stdout();\n-        w.write_char('\\n');\n+        let mut w = io::stdout();\n+        let w = &mut w as &mut io::Writer;\n+        write!(w, \"\\n\");\n         write_5_number_summary(w, &summ2);\n-        w.write_char('\\n');\n+        write!(w, \"\\n\");\n         write_boxplot(w, &summ2, 50);\n-        w.write_char('\\n');\n+        write!(w, \"\\n\");\n \n         assert_eq!(summ.sum, summ2.sum);\n         assert_eq!(summ.min, summ2.min);\n@@ -944,10 +942,11 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         fn t(s: &Summary, expected: ~str) {\n-            let out = do io::with_str_writer |w|  {\n-                write_boxplot(w, s, 30)\n-            };\n-\n+            use std::rt::io::mem::MemWriter;\n+            use std::rt::io::Decorator;\n+            let mut m = MemWriter::new();\n+            write_boxplot(&mut m as &mut io::Writer, s, 30);\n+            let out = str::from_utf8_owned(m.inner());\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "22ce833ea24d9b97d4351eda4298a3587b8f7bd2", "filename": "src/libextra/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,7 +13,7 @@\n #[allow(missing_doc)];\n \n \n-use std::io;\n+use std::rt::io;\n \n #[cfg(not(target_os = \"win32\"))] use std::os;\n #[cfg(not(target_os = \"win32\"))] use terminfo::*;\n@@ -96,19 +96,19 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n     priv num_colors: u16,\n-    priv out: @io::Writer,\n+    priv out: @mut io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n     priv num_colors: u16,\n-    priv out: @io::Writer,\n+    priv out: @mut io::Writer,\n }\n \n #[cfg(not(target_os = \"win32\"))]\n impl Terminal {\n-    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n         let term = os::getenv(\"TERM\");\n         if term.is_none() {\n             return Err(~\"TERM environment variable undefined\");\n@@ -243,7 +243,7 @@ impl Terminal {\n \n #[cfg(target_os = \"win32\")]\n impl Terminal {\n-    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n         return Ok(Terminal {out: out, num_colors: 0});\n     }\n "}, {"sha": "0020f432114dd882c9197b2aed0f45d607994b86", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -14,8 +14,9 @@\n \n \n use std::{vec, str};\n-use std::io::Reader;\n use std::hashmap::HashMap;\n+use std::rt::io;\n+use std::rt::io::extensions::{ReaderByteConversions, ReaderUtil};\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -160,7 +161,8 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n+pub fn parse(mut file: &mut io::Reader,\n+             longnames: bool) -> Result<~TermInfo, ~str> {\n     let bnames;\n     let snames;\n     let nnames;\n@@ -176,17 +178,17 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     }\n \n     // Check magic number\n-    let magic = file.read_le_u16();\n+    let magic = file.read_le_u16_();\n     if (magic != 0x011A) {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = file.read_le_i16() as int;\n-    let bools_bytes          = file.read_le_i16() as int;\n-    let numbers_count        = file.read_le_i16() as int;\n-    let string_offsets_count = file.read_le_i16() as int;\n-    let string_table_bytes   = file.read_le_i16() as int;\n+    let names_bytes          = file.read_le_i16_() as int;\n+    let bools_bytes          = file.read_le_i16_() as int;\n+    let numbers_count        = file.read_le_i16_() as int;\n+    let string_offsets_count = file.read_le_i16_() as int;\n+    let string_table_bytes   = file.read_le_i16_() as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -224,7 +226,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n-            let b = file.read_byte();\n+            let b = file.read_byte().unwrap();\n             if b < 0 {\n                 error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n@@ -245,7 +247,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = file.read_le_u16();\n+            let n = file.read_le_u16_();\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -260,7 +262,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(file.read_le_u16());\n+            string_offsets.push(file.read_le_u16_());\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);"}, {"sha": "8dff53f14a159b54d5336878779517f8ad097743", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,7 +13,8 @@\n \n use std::{os, str};\n use std::os::getenv;\n-use std::io::{file_reader, Reader};\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -73,9 +74,9 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<@Reader, ~str> {\n+pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => file_reader(x),\n+        Some(x) => Ok(@mut x.open_reader(io::Open).unwrap() as @mut io::Reader),\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "457f7868e237ae9c93f41d937d04bcd1d5c02cc0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -30,8 +30,8 @@ use treemap::TreeMap;\n \n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n-use std::io;\n-use std::result;\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -336,8 +336,8 @@ pub enum TestResult {\n }\n \n struct ConsoleTestState {\n-    out: @io::Writer,\n-    log_out: Option<@io::Writer>,\n+    out: @mut io::Writer,\n+    log_out: Option<@mut io::Writer>,\n     term: Option<term::Terminal>,\n     use_color: bool,\n     total: uint,\n@@ -353,17 +353,13 @@ struct ConsoleTestState {\n impl ConsoleTestState {\n     pub fn new(opts: &TestOpts) -> ConsoleTestState {\n         let log_out = match opts.logfile {\n-            Some(ref path) => match io::file_writer(path,\n-                                                    [io::Create,\n-                                                     io::Truncate]) {\n-                result::Ok(w) => Some(w),\n-                result::Err(ref s) => {\n-                    fail!(\"can't open output file: {}\", *s)\n-                }\n+            Some(ref path) => {\n+                let out = path.open_writer(io::CreateOrTruncate);\n+                Some(@mut out as @mut io::Writer)\n             },\n             None => None\n         };\n-        let out = io::stdout();\n+        let out = @mut io::stdio::stdout() as @mut io::Writer;\n         let term = match term::Terminal::new(out) {\n             Err(_) => None,\n             Ok(t) => Some(t)\n@@ -424,12 +420,12 @@ impl ConsoleTestState {\n                         word: &str,\n                         color: term::color::Color) {\n         match self.term {\n-            None => self.out.write_str(word),\n+            None => self.out.write(word.as_bytes()),\n             Some(ref t) => {\n                 if self.use_color {\n                     t.fg(color);\n                 }\n-                self.out.write_str(word);\n+                self.out.write(word.as_bytes());\n                 if self.use_color {\n                     t.reset();\n                 }\n@@ -440,12 +436,12 @@ impl ConsoleTestState {\n     pub fn write_run_start(&mut self, len: uint) {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n+        write!(self.out, \"\\nrunning {} {}\\n\", len, noun);\n     }\n \n     pub fn write_test_start(&self, test: &TestDesc, align: NamePadding) {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.out.write_str(format!(\"test {} ... \", name));\n+        write!(self.out, \"test {} ... \", name);\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -455,41 +451,40 @@ impl ConsoleTestState {\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n                 self.write_metric();\n-                self.out.write_str(\": \" + fmt_metrics(mm));\n+                write!(self.out, \": {}\", fmt_metrics(mm));\n             }\n             TrBench(ref bs) => {\n                 self.write_bench();\n-                self.out.write_str(\": \" + fmt_bench_samples(bs))\n+                write!(self.out, \": {}\", fmt_bench_samples(bs));\n             }\n         }\n-        self.out.write_str(&\"\\n\");\n+        write!(self.out, \"\\n\");\n     }\n \n     pub fn write_log(&self, test: &TestDesc, result: &TestResult) {\n         match self.log_out {\n             None => (),\n             Some(out) => {\n-                out.write_line(format!(\"{} {}\",\n-                                    match *result {\n+                write!(out, \"{} {}\",match *result {\n                                         TrOk => ~\"ok\",\n                                         TrFailed => ~\"failed\",\n                                         TrIgnored => ~\"ignored\",\n                                         TrMetrics(ref mm) => fmt_metrics(mm),\n                                         TrBench(ref bs) => fmt_bench_samples(bs)\n-                                    }, test.name.to_str()));\n+                                    }, test.name.to_str());\n             }\n         }\n     }\n \n     pub fn write_failures(&self) {\n-        self.out.write_line(\"\\nfailures:\");\n+        write!(self.out, \"\\nfailures:\\n\");\n         let mut failures = ~[];\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         sort::tim_sort(failures);\n         for name in failures.iter() {\n-            self.out.write_line(format!(\"    {}\", name.to_str()));\n+            writeln!(self.out, \"    {}\", name.to_str());\n         }\n     }\n \n@@ -506,36 +501,34 @@ impl ConsoleTestState {\n                 MetricAdded => {\n                     added += 1;\n                     self.write_added();\n-                    self.out.write_line(format!(\": {}\", *k));\n+                    writeln!(self.out, \": {}\", *k);\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     self.write_removed();\n-                    self.out.write_line(format!(\": {}\", *k));\n+                    writeln!(self.out, \": {}\", *k);\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    self.out.write_str(*k);\n-                    self.out.write_str(\": \");\n+                    write!(self.out, \"{}: \", *k);\n                     self.write_improved();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n+                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    self.out.write_str(*k);\n-                    self.out.write_str(\": \");\n+                    write!(self.out, \"{}: \", *k);\n                     self.write_regressed();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n+                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n                 }\n             }\n         }\n-        self.out.write_line(format!(\"result of ratchet: {} matrics added, {} removed, \\\n-                                  {} improved, {} regressed, {} noise\",\n-                                 added, removed, improved, regressed, noise));\n+        writeln!(self.out, \"result of ratchet: {} matrics added, {} removed, \\\n+                            {} improved, {} regressed, {} noise\",\n+                            added, removed, improved, regressed, noise);\n         if regressed == 0 {\n-            self.out.write_line(\"updated ratchet file\")\n+            writeln!(self.out, \"updated ratchet file\");\n         } else {\n-            self.out.write_line(\"left ratchet file untouched\")\n+            writeln!(self.out, \"left ratchet file untouched\");\n         }\n     }\n \n@@ -547,12 +540,12 @@ impl ConsoleTestState {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.display()));\n+                write!(self.out, \"\\nusing metrics ratcher: {}\\n\", pth.display());\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                    self.out.write_str(format!(\"with noise-tolerance forced to: {}%%\\n\",\n-                                            pct as f64))\n+                        writeln!(self.out, \"with noise-tolerance forced to: {}%\",\n+                                 pct)\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n                 self.write_metric_diff(&diff);\n@@ -567,15 +560,15 @@ impl ConsoleTestState {\n \n         let success = ratchet_success && test_success;\n \n-        self.out.write_str(\"\\ntest result: \");\n+        write!(self.out, \"\\ntest result: \");\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n             self.write_ok();\n         } else {\n             self.write_failed();\n         }\n-        self.out.write_str(format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n-                                self.passed, self.failed, self.ignored, self.measured));\n+        write!(self.out, \". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n+               self.passed, self.failed, self.ignored, self.measured);\n         return success;\n     }\n }\n@@ -659,47 +652,51 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.display()));\n+            write!(st.out, \"\\nmetrics saved to: {}\", pth.display());\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n }\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n+    use std::rt::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::str;\n     fn dummy() {}\n \n-    let s = do io::with_str_writer |wr| {\n-        let test_a = TestDesc {\n-            name: StaticTestName(\"a\"),\n-            ignore: false,\n-            should_fail: false\n-        };\n-\n-        let test_b = TestDesc {\n-            name: StaticTestName(\"b\"),\n-            ignore: false,\n-            should_fail: false\n-        };\n+    let m = @mut MemWriter::new();\n+    let test_a = TestDesc {\n+        name: StaticTestName(\"a\"),\n+        ignore: false,\n+        should_fail: false\n+    };\n \n-        let st = @ConsoleTestState {\n-            out: wr,\n-            log_out: None,\n-            term: None,\n-            use_color: false,\n-            total: 0u,\n-            passed: 0u,\n-            failed: 0u,\n-            ignored: 0u,\n-            measured: 0u,\n-            metrics: MetricMap::new(),\n-            failures: ~[test_b, test_a],\n-            max_name_len: 0u,\n-        };\n+    let test_b = TestDesc {\n+        name: StaticTestName(\"b\"),\n+        ignore: false,\n+        should_fail: false\n+    };\n \n-        st.write_failures();\n+    let st = @ConsoleTestState {\n+        out: m as @mut io::Writer,\n+        log_out: None,\n+        term: None,\n+        use_color: false,\n+        total: 0u,\n+        passed: 0u,\n+        failed: 0u,\n+        ignored: 0u,\n+        measured: 0u,\n+        max_name_len: 10u,\n+        metrics: MetricMap::new(),\n+        failures: ~[test_b, test_a]\n     };\n \n+    st.write_failures();\n+    let s = str::from_utf8(*m.inner_ref());\n+\n     let apos = s.find_str(\"a\").unwrap();\n     let bpos = s.find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n@@ -939,15 +936,15 @@ impl MetricMap {\n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n-        let f = io::file_reader(p).unwrap();\n+        let f = @mut p.open_reader(io::Open) as @mut io::Reader;\n         let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        let f = io::file_writer(p, [io::Create, io::Truncate]).unwrap();\n-        self.to_json().to_pretty_writer(f);\n+        let f = @mut p.open_writer(io::CreateOrTruncate);\n+        self.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "2950f02ad19ddcd846d485ae128af18d3c5c6f4e", "filename": "src/libextra/time.rs", "status": "modified", "additions": 75, "deletions": 58, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,7 +10,8 @@\n \n #[allow(missing_doc)];\n \n-use std::io;\n+use std::rt::io::Reader;\n+use std::rt::io::mem::BufReader;\n use std::num;\n use std::str;\n \n@@ -666,61 +667,69 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    do io::with_str_reader(format) |rdr| {\n-        let mut tm = Tm {\n-            tm_sec: 0_i32,\n-            tm_min: 0_i32,\n-            tm_hour: 0_i32,\n-            tm_mday: 0_i32,\n-            tm_mon: 0_i32,\n-            tm_year: 0_i32,\n-            tm_wday: 0_i32,\n-            tm_yday: 0_i32,\n-            tm_isdst: 0_i32,\n-            tm_gmtoff: 0_i32,\n-            tm_zone: ~\"\",\n-            tm_nsec: 0_i32,\n-        };\n-        let mut pos = 0u;\n-        let len = s.len();\n-        let mut result = Err(~\"Invalid time\");\n+    let mut rdr = BufReader::new(format.as_bytes());\n+    let mut tm = Tm {\n+        tm_sec: 0_i32,\n+        tm_min: 0_i32,\n+        tm_hour: 0_i32,\n+        tm_mday: 0_i32,\n+        tm_mon: 0_i32,\n+        tm_year: 0_i32,\n+        tm_wday: 0_i32,\n+        tm_yday: 0_i32,\n+        tm_isdst: 0_i32,\n+        tm_gmtoff: 0_i32,\n+        tm_zone: ~\"\",\n+        tm_nsec: 0_i32,\n+    };\n+    let mut pos = 0u;\n+    let len = s.len();\n+    let mut result = Err(~\"Invalid time\");\n \n-        while !rdr.eof() && pos < len {\n-            let range = s.char_range_at(pos);\n-            let ch = range.ch;\n-            let next = range.next;\n-\n-            match rdr.read_char() {\n-                '%' => {\n-                    match parse_type(s, pos, rdr.read_char(), &mut tm) {\n-                        Ok(next) => pos = next,\n-                        Err(e) => { result = Err(e); break; }\n-                    }\n-                },\n-                c => {\n-                    if c != ch { break }\n-                    pos = next;\n+    while pos < len {\n+        let range = s.char_range_at(pos);\n+        let ch = range.ch;\n+        let next = range.next;\n+\n+        let mut buf = [0];\n+        let c = match rdr.read(buf) {\n+            Some(*) => buf[0] as u8 as char,\n+            None => break\n+        };\n+        match c {\n+            '%' => {\n+                let ch = match rdr.read(buf) {\n+                    Some(*) => buf[0] as u8 as char,\n+                    None => break\n+                };\n+                match parse_type(s, pos, ch, &mut tm) {\n+                    Ok(next) => pos = next,\n+                    Err(e) => { result = Err(e); break; }\n                 }\n+            },\n+            c => {\n+                if c != ch { break }\n+                pos = next;\n             }\n         }\n-\n-        if pos == len && rdr.eof() {\n-            Ok(Tm {\n-                tm_sec: tm.tm_sec,\n-                tm_min: tm.tm_min,\n-                tm_hour: tm.tm_hour,\n-                tm_mday: tm.tm_mday,\n-                tm_mon: tm.tm_mon,\n-                tm_year: tm.tm_year,\n-                tm_wday: tm.tm_wday,\n-                tm_yday: tm.tm_yday,\n-                tm_isdst: tm.tm_isdst,\n-                tm_gmtoff: tm.tm_gmtoff,\n-                tm_zone: tm.tm_zone.clone(),\n-                tm_nsec: tm.tm_nsec,\n-            })\n-        } else { result }\n     }\n+\n+    if pos == len && rdr.eof() {\n+        Ok(Tm {\n+            tm_sec: tm.tm_sec,\n+            tm_min: tm.tm_min,\n+            tm_hour: tm.tm_hour,\n+            tm_mday: tm.tm_mday,\n+            tm_mon: tm.tm_mon,\n+            tm_year: tm.tm_year,\n+            tm_wday: tm.tm_wday,\n+            tm_yday: tm.tm_yday,\n+            tm_isdst: tm.tm_isdst,\n+            tm_gmtoff: tm.tm_gmtoff,\n+            tm_zone: tm.tm_zone.clone(),\n+            tm_nsec: tm.tm_nsec,\n+        })\n+    } else { result }\n }\n \n /// Formats the time according to the format string.\n@@ -929,18 +938,26 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    let mut buf = ~\"\";\n+    let mut buf = ~[];\n \n-    do io::with_str_reader(format) |rdr| {\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-                '%' => buf.push_str(parse_type(rdr.read_char(), tm)),\n-                ch => buf.push_char(ch)\n+    let mut rdr = BufReader::new(format.as_bytes());\n+    loop {\n+        let mut b = [0];\n+        let ch = match rdr.read(b) {\n+            Some(*) => b[0],\n+            None => break,\n+        };\n+        match ch as char {\n+            '%' => {\n+                rdr.read(b);\n+                let s = parse_type(b[0] as char, tm);\n+                buf.push_all(s.as_bytes());\n             }\n+            ch => buf.push(ch as u8)\n         }\n     }\n \n-    buf\n+    str::from_utf8_owned(buf)\n }\n \n #[cfg(test)]"}, {"sha": "d268b106e5cb676d882a3d33743da5deaf9a47c5", "filename": "src/libextra/url.rs", "status": "modified", "additions": 159, "deletions": 135, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,10 +12,9 @@\n \n #[allow(missing_doc)];\n \n-\n+use std::rt::io::{Reader, Seek};\n+use std::rt::io::mem::BufReader;\n use std::cmp::Eq;\n-use std::io::{Reader, ReaderUtil};\n-use std::io;\n use std::hashmap::HashMap;\n use std::to_bytes;\n use std::uint;\n@@ -68,42 +67,46 @@ impl UserInfo {\n }\n \n fn encode_inner(s: &str, full_url: bool) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            let ch = rdr.read_byte() as u8 as char;\n-            match ch {\n-              // unreserved:\n-              'A' .. 'Z' |\n-              'a' .. 'z' |\n-              '0' .. '9' |\n-              '-' | '.' | '_' | '~' => {\n-                out.push_char(ch);\n-              }\n-              _ => {\n-                  if full_url {\n-                    match ch {\n-                      // gen-delims:\n-                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                      // sub-delims:\n-                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' => {\n-                        out.push_char(ch);\n-                      }\n-\n-                      _ => out.push_str(format!(\"%{:X}\", ch as uint))\n-                    }\n-                } else {\n-                    out.push_str(format!(\"%{:X}\", ch as uint));\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            None => break,\n+            Some(*) => buf[0] as char,\n+        };\n+\n+        match ch {\n+          // unreserved:\n+          'A' .. 'Z' |\n+          'a' .. 'z' |\n+          '0' .. '9' |\n+          '-' | '.' | '_' | '~' => {\n+            out.push_char(ch);\n+          }\n+          _ => {\n+              if full_url {\n+                match ch {\n+                  // gen-delims:\n+                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                  // sub-delims:\n+                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                  '+' | ',' | ';' | '=' => {\n+                    out.push_char(ch);\n+                  }\n+\n+                  _ => out.push_str(format!(\"%{:X}\", ch as uint))\n                 }\n-              }\n+            } else {\n+                out.push_str(format!(\"%{:X}\", ch as uint));\n             }\n+          }\n         }\n-\n-        out\n     }\n+\n+    out\n }\n \n /**\n@@ -128,41 +131,49 @@ pub fn encode_component(s: &str) -> ~str {\n }\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-              '%' => {\n-                let bytes = rdr.read_bytes(2u);\n-                let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n-\n-                if full_url {\n-                    // Only decode some characters:\n-                    match ch {\n-                      // gen-delims:\n-                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                      // sub-delims:\n-                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' => {\n-                        out.push_char('%');\n-                        out.push_char(bytes[0u] as char);\n-                        out.push_char(bytes[1u] as char);\n-                      }\n-\n-                      ch => out.push_char(ch)\n-                    }\n-                } else {\n-                      out.push_char(ch);\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            None => break,\n+            Some(*) => buf[0] as char\n+        };\n+        match ch {\n+          '%' => {\n+            let mut bytes = [0, 0];\n+            match rdr.read(bytes) {\n+                Some(2) => {}\n+                _ => fail!() // XXX: malformed url?\n+            }\n+            let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n+\n+            if full_url {\n+                // Only decode some characters:\n+                match ch {\n+                  // gen-delims:\n+                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                  // sub-delims:\n+                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                  '+' | ',' | ';' | '=' => {\n+                    out.push_char('%');\n+                    out.push_char(bytes[0u] as char);\n+                    out.push_char(bytes[1u] as char);\n+                  }\n+\n+                  ch => out.push_char(ch)\n                 }\n-              }\n-              ch => out.push_char(ch)\n+            } else {\n+                  out.push_char(ch);\n             }\n+          }\n+          ch => out.push_char(ch)\n         }\n-\n-        out\n     }\n+\n+    out\n }\n \n /**\n@@ -182,22 +193,25 @@ pub fn decode_component(s: &str) -> ~str {\n }\n \n fn encode_plus(s: &str) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            let ch = rdr.read_byte() as u8 as char;\n-            match ch {\n-              'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                out.push_char(ch);\n-              }\n-              ' ' => out.push_char('+'),\n-              _ => out.push_str(format!(\"%{:X}\", ch as uint))\n-            }\n-        }\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n \n-        out\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        match ch {\n+          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n+            out.push_char(ch);\n+          }\n+          ' ' => out.push_char('+'),\n+          _ => out.push_str(format!(\"%{:X}\", ch as uint))\n+        }\n     }\n+\n+    out\n }\n \n /**\n@@ -230,78 +244,88 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n  * type into a hashmap.\n  */\n pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n-    do io::with_bytes_reader(s) |rdr| {\n-        let mut m = HashMap::new();\n-        let mut key = ~\"\";\n-        let mut value = ~\"\";\n-        let mut parsing_key = true;\n-\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-                '&' | ';' => {\n-                    if key != ~\"\" && value != ~\"\" {\n-                        let mut values = match m.pop(&key) {\n-                            Some(values) => values,\n-                            None => ~[],\n-                        };\n-\n-                        values.push(value);\n-                        m.insert(key, values);\n-                    }\n+    let mut rdr = BufReader::new(s);\n+    let mut m = HashMap::new();\n+    let mut key = ~\"\";\n+    let mut value = ~\"\";\n+    let mut parsing_key = true;\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        match ch {\n+            '&' | ';' => {\n+                if key != ~\"\" && value != ~\"\" {\n+                    let mut values = match m.pop(&key) {\n+                        Some(values) => values,\n+                        None => ~[],\n+                    };\n \n-                    parsing_key = true;\n-                    key = ~\"\";\n-                    value = ~\"\";\n+                    values.push(value);\n+                    m.insert(key, values);\n                 }\n-                '=' => parsing_key = false,\n-                ch => {\n-                    let ch = match ch {\n-                        '%' => {\n-                            let bytes = rdr.read_bytes(2u);\n-                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                        }\n-                        '+' => ' ',\n-                        ch => ch\n-                    };\n \n-                    if parsing_key {\n-                        key.push_char(ch)\n-                    } else {\n-                        value.push_char(ch)\n+                parsing_key = true;\n+                key = ~\"\";\n+                value = ~\"\";\n+            }\n+            '=' => parsing_key = false,\n+            ch => {\n+                let ch = match ch {\n+                    '%' => {\n+                        let mut bytes = [0, 0];\n+                        match rdr.read(bytes) {\n+                            Some(2) => {}\n+                            _ => fail!() // XXX: malformed?\n+                        }\n+                        uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                     }\n+                    '+' => ' ',\n+                    ch => ch\n+                };\n+\n+                if parsing_key {\n+                    key.push_char(ch)\n+                } else {\n+                    value.push_char(ch)\n                 }\n             }\n         }\n+    }\n \n-        if key != ~\"\" && value != ~\"\" {\n-            let mut values = match m.pop(&key) {\n-                Some(values) => values,\n-                None => ~[],\n-            };\n-\n-            values.push(value);\n-            m.insert(key, values);\n-        }\n+    if key != ~\"\" && value != ~\"\" {\n+        let mut values = match m.pop(&key) {\n+            Some(values) => values,\n+            None => ~[],\n+        };\n \n-        m\n+        values.push(value);\n+        m.insert(key, values);\n     }\n+\n+    m\n }\n \n \n fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n-    do io::with_str_reader(s) |rdr| {\n-        let mut ch;\n-        while !rdr.eof() {\n-            ch = rdr.read_byte() as u8 as char;\n-            if ch == c {\n-                // found a match, adjust markers\n-                index = rdr.tell()-1;\n-                mat = 1;\n-                break;\n-            }\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        if ch == c {\n+            // found a match, adjust markers\n+            index = (rdr.tell() as uint) - 1;\n+            mat = 1;\n+            break;\n         }\n     }\n     if index+mat == len {"}, {"sha": "b94b74a696cc26552ca2ec07fcc7a49b2558c16d", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -522,6 +522,8 @@ mod test {\n     use std::str;\n     use std::rand;\n     use std::num::Zero;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n \n     #[test]\n     fn test_new_nil() {\n@@ -795,10 +797,10 @@ mod test {\n         use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n-        let bytes = do std::io::with_bytes_writer |wr| {\n-            u.encode(&mut ebml::writer::Encoder(wr));\n-        };\n-        let u2 = Decodable::decode(&mut ebml::reader::Decoder(ebml::reader::Doc(@bytes)));\n+        let wr = @mut MemWriter::new();\n+        u.encode(&mut ebml::writer::Encoder(wr));\n+        let doc = ebml::reader::Doc(@wr.inner_ref().to_owned());\n+        let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n         assert_eq!(u, u2);\n     }\n }"}, {"sha": "30efecde37f9185bda6037f98f925205ed3eb264", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -19,7 +19,13 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::{io, os, task};\n+use std::{os, str, task};\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::Decorator;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::file::FileInfo;\n \n /**\n *\n@@ -174,19 +180,19 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = io::file_writer(&self.db_filename, [io::Create, io::Truncate]).unwrap();\n-        self.db_cache.to_json().to_pretty_writer(f);\n+        let f = @mut self.db_filename.open_writer(io::CreateOrTruncate);\n+        self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n         assert!(os::path_exists(&self.db_filename));\n-        let f = io::file_reader(&self.db_filename);\n+        let f = self.db_filename.open_reader(io::Open);\n         match f {\n-            Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n-                            self.db_filename.display(), e.to_str()),\n-            Ok(r) =>\n-                match json::from_reader(r) {\n+            None => fail!(\"Couldn't load workcache database {}\",\n+                          self.db_filename.display()),\n+            Some(r) =>\n+                match json::from_reader(@mut r as @mut io::Reader) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n@@ -256,20 +262,18 @@ enum Work<'self, T> {\n }\n \n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let mut encoder = json::Encoder(wr);\n-        t.encode(&mut encoder);\n-    }\n+    let writer = @mut MemWriter::new();\n+    let mut encoder = json::Encoder(writer as @mut io::Writer);\n+    t.encode(&mut encoder);\n+    str::from_utf8(writer.inner_ref().as_slice())\n }\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n-    do io::with_str_reader(s) |rdr| {\n-        let j = json::from_reader(rdr).unwrap();\n-        let mut decoder = json::Decoder(j);\n-        Decodable::decode(&mut decoder)\n-    }\n+    let j = json::from_str(s).unwrap();\n+    let mut decoder = json::Decoder(j);\n+    Decodable::decode(&mut decoder)\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n@@ -280,8 +284,8 @@ fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n fn digest_file(path: &Path) -> ~str {\n     let mut sha = ~Sha1::new();\n-    let s = io::read_whole_file_str(path);\n-    (*sha).input_str(s.unwrap());\n+    let s = path.open_reader(io::Open).read_to_end();\n+    (*sha).input(s);\n     (*sha).result_str()\n }\n \n@@ -492,7 +496,6 @@ impl<'self, T:Send +\n \n #[test]\n fn test() {\n-    use std::io::WriterUtil;\n     use std::{os, run};\n \n     // Create a path to a new file 'filename' in the directory in which\n@@ -507,8 +510,7 @@ fn test() {\n \n     let pth = make_path(~\"foo.c\");\n     {\n-        let r = io::file_writer(&pth, [io::Create]);\n-        r.unwrap().write_str(\"int main() { return 0; }\");\n+        pth.open_writer(io::Create).write(bytes!(\"int main() { return 0; }\"));\n     }\n \n     let db_path = make_path(~\"db.json\");\n@@ -539,5 +541,5 @@ fn test() {\n         }\n     };\n \n-    io::println(s);\n+    println(s);\n }"}, {"sha": "1b9cb10f1dcfdcb1dcd0715cdce16ac5220bf505", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -26,7 +26,6 @@ use std::c_str::ToCStr;\n use std::char;\n use std::hash::Streaming;\n use std::hash;\n-use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::os;\n use std::ptr;\n@@ -930,7 +929,7 @@ pub fn link_binary(sess: Session,\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n     debug!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(format!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \")));\n+        println!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     }\n \n     // We run 'cc' here"}, {"sha": "d2b0dad80f656401fb0b8885af15e6596e29315f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -26,7 +26,8 @@ use util::common::time;\n use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n@@ -552,17 +553,16 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n-    do io::with_str_reader(src) |rdr| {\n-        pprust::print_crate(sess.codemap,\n-                            token::get_ident_interner(),\n-                            sess.span_diagnostic,\n-                            &crate,\n-                            source_name(input),\n-                            rdr,\n-                            io::stdout(),\n-                            annotation,\n-                            is_expanded);\n-    }\n+    let rdr = @mut MemReader::new(src.as_bytes().to_owned());\n+    pprust::print_crate(sess.codemap,\n+                        token::get_ident_interner(),\n+                        sess.span_diagnostic,\n+                        &crate,\n+                        source_name(input),\n+                        rdr as @mut io::Reader,\n+                        @mut io::stdout() as @mut io::Writer,\n+                        annotation,\n+                        is_expanded);\n }\n \n pub fn get_os(triple: &str) -> Option<session::Os> {\n@@ -1048,7 +1048,7 @@ pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n     fail!();\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path, out: @mut io::Writer) {\n     metadata::loader::list_file_metadata(\n         token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "aca41f5f4cbb9364ebc13c4def1041f57b11b875", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -27,8 +27,8 @@ use middle::astencode::vtable_decoder_helpers;\n \n \n use std::u64;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::extensions::u64_from_be_bytes;\n use std::option;\n use std::str;\n use std::vec;\n@@ -56,14 +56,14 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n+    let pos = u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n@@ -78,7 +78,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        return io::u64_from_be_bytes(\n+        return u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n@@ -1254,7 +1254,7 @@ fn family_names_type(fam: Family) -> bool {\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n     do reader::with_doc_data(d) |desc| {\n-        let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n+        let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n         let pathbytes = desc.slice(4u, desc.len());\n         let path = str::from_utf8(pathbytes);\n \n@@ -1353,23 +1353,23 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n \n fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n-                   out: @io::Writer) {\n+                   out: @mut io::Writer) {\n     let r = get_meta_items(meta_items);\n     for mi in r.iter() {\n-        out.write_str(format!(\"{}\\n\", pprust::meta_item_to_str(*mi, intr)));\n+        write!(out, \"{}\\n\", pprust::meta_item_to_str(*mi, intr));\n     }\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n-                         out: @io::Writer) {\n-    out.write_str(format!(\"=Crate Attributes ({})=\\n\", hash));\n+                         out: @mut io::Writer) {\n+    write!(out, \"=Crate Attributes ({})=\\n\", hash);\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        out.write_str(format!(\"{}\\n\", pprust::attribute_to_str(attr, intr)));\n+        write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr));\n     }\n \n-    out.write_str(\"\\n\\n\");\n+    write!(out, \"\\n\\n\");\n }\n \n pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n@@ -1404,17 +1404,16 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n-    out.write_str(\"=External Dependencies=\\n\");\n+fn list_crate_deps(data: @~[u8], out: @mut io::Writer) {\n+    write!(out, \"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n-        out.write_str(\n-            format!(\"{} {}-{}-{}\\n\",\n-                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n+        write!(out, \"{} {}-{}-{}\\n\",\n+                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers);\n     }\n \n-    out.write_str(\"\\n\");\n+    write!(out, \"\\n\");\n }\n \n pub fn get_crate_hash(data: @~[u8]) -> @str {\n@@ -1434,7 +1433,7 @@ pub fn get_crate_vers(data: @~[u8]) -> @str {\n }\n \n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n-                           out: @io::Writer) {\n+                           out: @mut io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);"}, {"sha": "d64820332a5d959ef96cd5e1e389e6adce393db9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -22,12 +22,16 @@ use middle::typeck;\n use middle;\n \n use std::hashmap::{HashMap, HashSet};\n-use std::io;\n+use std::rt::io::extensions::WriterByteConversions;\n+use std::rt::io::{Writer, Seek, Decorator};\n+use std::rt::io::mem::MemWriter;\n use std::str;\n use std::vec;\n+\n use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n+\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n@@ -68,17 +72,17 @@ pub struct EncodeParams<'self> {\n }\n \n struct Stats {\n-    inline_bytes: uint,\n-    attr_bytes: uint,\n-    dep_bytes: uint,\n-    lang_item_bytes: uint,\n-    link_args_bytes: uint,\n-    impl_bytes: uint,\n-    misc_bytes: uint,\n-    item_bytes: uint,\n-    index_bytes: uint,\n-    zero_bytes: uint,\n-    total_bytes: uint,\n+    inline_bytes: u64,\n+    attr_bytes: u64,\n+    dep_bytes: u64,\n+    lang_item_bytes: u64,\n+    link_args_bytes: u64,\n+    impl_bytes: u64,\n+    misc_bytes: u64,\n+    item_bytes: u64,\n+    index_bytes: u64,\n+    zero_bytes: u64,\n+    total_bytes: u64,\n \n     n_inlines: uint\n }\n@@ -133,7 +137,7 @@ fn encode_region_param(ecx: &EncodeContext,\n #[deriving(Clone)]\n struct entry<T> {\n     val: T,\n-    pos: uint\n+    pos: u64\n }\n \n fn add_to_index(ebml_w: &mut writer::Encoder,\n@@ -1395,19 +1399,21 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: &fn(@io::Writer, &T)) {\n-    let writer = ebml_w.writer;\n+                write_fn: &fn(@mut MemWriter, &T)) {\n     ebml_w.start_tag(tag_index);\n-    let mut bucket_locs: ~[uint] = ~[];\n+    let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n-            writer.write_be_u32(elt.pos as u32);\n-            write_fn(writer, &elt.val);\n+            {\n+                let wr: &mut MemWriter = ebml_w.writer;\n+                wr.write_be_u32_(elt.pos as u32);\n+            }\n+            write_fn(ebml_w.writer, &elt.val);\n             ebml_w.end_tag();\n         }\n         ebml_w.end_tag();\n@@ -1416,19 +1422,21 @@ fn encode_index<T:'static>(\n     ebml_w.start_tag(tag_index_table);\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n-        writer.write_be_u32(*pos as u32);\n+        let wr: &mut MemWriter = ebml_w.writer;\n+        wr.write_be_u32_(*pos as u32);\n     }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, s: ~str) {\n-    writer.write_str(s);\n+fn write_str(writer: @mut MemWriter, s: ~str) {\n+    writer.write(s.as_bytes());\n }\n \n-fn write_i64(writer: @io::Writer, &n: &i64) {\n+fn write_i64(writer: @mut MemWriter, &n: &i64) {\n+    let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n-    writer.write_be_u32(n as u32);\n+    wr.write_be_u32_(n as u32);\n }\n \n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n@@ -1581,11 +1589,17 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n                 ebml_w.start_tag(tag_lang_items_item);\n \n                 ebml_w.start_tag(tag_lang_items_item_id);\n-                ebml_w.writer.write_be_u32(i as u32);\n+                {\n+                    let wr: &mut MemWriter = ebml_w.writer;\n+                    wr.write_be_u32_(i as u32);\n+                }\n                 ebml_w.end_tag();   // tag_lang_items_item_id\n \n                 ebml_w.start_tag(tag_lang_items_item_node_id);\n-                ebml_w.writer.write_be_u32(id.node as u32);\n+                {\n+                    let wr: &mut MemWriter = ebml_w.writer;\n+                    wr.write_be_u32_(id.node as u32);\n+                }\n                 ebml_w.end_tag();   // tag_lang_items_item_node_id\n \n                 ebml_w.end_tag();   // tag_lang_items_item\n@@ -1602,7 +1616,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     let link_args = cstore::get_used_link_args(ecx.cstore);\n     for link_arg in link_args.iter() {\n         ebml_w.start_tag(tag_link_args_arg);\n-        ebml_w.writer.write_str(link_arg.to_str());\n+        ebml_w.writer.write(link_arg.as_bytes());\n         ebml_w.end_tag();\n     }\n \n@@ -1720,7 +1734,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n-    let wr = @io::BytesWriter::new();\n+    let wr = @mut MemWriter::new();\n     let stats = Stats {\n         inline_bytes: 0,\n         attr_bytes: 0,\n@@ -1765,61 +1779,61 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         reachable: reachable,\n      };\n \n-    let mut ebml_w = writer::Encoder(wr as @io::Writer);\n+    let mut ebml_w = writer::Encoder(wr);\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n-    let mut i = *wr.pos;\n+    let mut i = wr.tell();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = *wr.pos - i;\n+    ecx.stats.attr_bytes = wr.tell() - i;\n \n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = *wr.pos - i;\n+    ecx.stats.dep_bytes = wr.tell() - i;\n \n     // Encode the language items.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = *wr.pos - i;\n+    ecx.stats.lang_item_bytes = wr.tell() - i;\n \n     // Encode the link args.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_link_args(&ecx, &mut ebml_w);\n-    ecx.stats.link_args_bytes = *wr.pos - i;\n+    ecx.stats.link_args_bytes = wr.tell() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes = *wr.pos - i;\n+    ecx.stats.impl_bytes = wr.tell() - i;\n \n     // Encode miscellaneous info.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes = *wr.pos - i;\n+    ecx.stats.misc_bytes = wr.tell() - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = *wr.pos;\n+    i = wr.tell();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = *wr.pos - i;\n+    ecx.stats.item_bytes = wr.tell() - i;\n \n-    i = *wr.pos;\n+    i = wr.tell();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes = *wr.pos - i;\n+    ecx.stats.index_bytes = wr.tell() - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = *wr.pos;\n+    ecx.stats.total_bytes = wr.tell();\n \n     if (tcx.sess.meta_stats()) {\n-        for e in wr.bytes.iter() {\n+        for e in wr.inner_ref().iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n         }\n \n-        io::println(\"metadata stats:\");\n+        println(\"metadata stats:\");\n         println!(\"    inline bytes: {}\", ecx.stats.inline_bytes);\n         println!(\" attribute bytes: {}\", ecx.stats.attr_bytes);\n         println!(\"       dep bytes: {}\", ecx.stats.dep_bytes);\n@@ -1837,7 +1851,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     // remaining % 4 bytes.\n     wr.write(&[0u8, 0u8, 0u8, 0u8]);\n \n-    let writer_bytes: &mut ~[u8] = wr.bytes;\n+    let writer_bytes: &mut ~[u8] = wr.inner_mut_ref();\n \n     metadata_encoding_version.to_owned() +\n         flate::deflate_bytes(*writer_bytes)\n@@ -1850,7 +1864,7 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: tyencode::ac_no_abbrevs};\n-    do io::with_str_writer |wr| {\n-        tyencode::enc_ty(wr, cx, t);\n-    }\n+    let wr = @mut MemWriter::new();\n+    tyencode::enc_ty(wr, cx, t);\n+    str::from_utf8(*wr.inner_ref())\n }"}, {"sha": "34eb387a3f5d4c47df12b2d945ade5b4dd07a565", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -25,7 +25,7 @@ use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n use std::cast;\n-use std::io;\n+use std::rt::io;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -271,11 +271,11 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(intr: @ident_interner,\n                           os: Os,\n                           path: &Path,\n-                          out: @io::Writer) {\n+                          out: @mut io::Writer) {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(format!(\"could not find metadata in {}.\\n\", path.display()))\n+        write!(out, \"could not find metadata in {}.\\n\", path.display())\n       }\n     }\n }"}, {"sha": "7fb33c881156b17ff0d334e63e276d0ed3fed942", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 207, "deletions": 245, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,19 +10,26 @@\n \n // Type encoding\n \n+use std::hashmap::HashMap;\n+use std::rt::io;\n+use std::rt::io::{Decorator, Writer, Seek};\n+use std::rt::io::mem::MemWriter;\n+use std::str;\n+use std::fmt;\n \n use middle::ty::param_ty;\n use middle::ty;\n \n-use std::hashmap::HashMap;\n-use std::io::WriterUtil;\n-use std::io;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n \n+macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n+    format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n+) )\n+\n pub struct ctxt {\n     diag: @mut span_handler,\n     // Def -> str Callback:\n@@ -46,350 +53,308 @@ pub enum abbrev_ctxt {\n     ac_use_abbrevs(@mut HashMap<ty::t, ty_abbrev>),\n }\n \n+fn mywrite(w: @mut MemWriter, fmt: &fmt::Arguments) {\n+    fmt::write(&mut *w as &mut io::Writer, fmt);\n+}\n+\n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     match cx.abbrevs {\n       ac_no_abbrevs => return false,\n       ac_use_abbrevs(_) => return true\n     }\n }\n \n-pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(&t) {\n             Some(&s) => s,\n             None => {\n-                let s = do io::with_str_writer |wr| {\n-                    enc_sty(wr, cx, &ty::get(t).sty);\n-                }.to_managed();\n+                let wr = @mut MemWriter::new();\n+                enc_sty(wr, cx, &ty::get(t).sty);\n+                let s = str::from_utf8(*wr.inner_ref()).to_managed();\n                 cx.tcx.short_names_cache.insert(t, s);\n                 s\n           }\n         };\n-        w.write_str(result_str);\n+        w.write(result_str.as_bytes());\n       }\n       ac_use_abbrevs(abbrevs) => {\n           match abbrevs.find(&t) {\n-              Some(a) => { w.write_str(a.s); return; }\n+              Some(a) => { w.write(a.s.as_bytes()); return; }\n               None => {}\n           }\n           let pos = w.tell();\n           enc_sty(w, cx, &ty::get(t).sty);\n           let end = w.tell();\n           let len = end - pos;\n-          fn estimate_sz(u: uint) -> uint {\n+          fn estimate_sz(u: u64) -> u64 {\n               let mut n = u;\n-              let mut len = 0u;\n-              while n != 0u { len += 1u; n = n >> 4u; }\n+              let mut len = 0;\n+              while n != 0 { len += 1; n = n >> 4; }\n               return len;\n           }\n-          let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n+          let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n               let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len).to_managed();\n-              let a = ty_abbrev { pos: pos, len: len, s: s };\n+              let a = ty_abbrev { pos: pos as uint,\n+                                  len: len as uint,\n+                                  s: s };\n               abbrevs.insert(t, a);\n           }\n           return;\n       }\n     }\n }\n \n-fn enc_mutability(w: @io::Writer, mt: ast::Mutability) {\n+fn enc_mutability(w: @mut MemWriter, mt: ast::Mutability) {\n     match mt {\n-      MutImmutable => (),\n-      MutMutable => w.write_char('m'),\n+        MutImmutable => (),\n+        MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: @io::Writer, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @io::Writer, t: Option<T>, enc_f: &fn(T)) {\n+fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: &fn(T)) {\n     match t {\n-      None => w.write_char('n'),\n-      Some(v) => {\n-        w.write_char('s');\n-        enc_f(v);\n-      }\n+        None => mywrite!(w, \"n\"),\n+        Some(v) => {\n+            mywrite!(w, \"s\");\n+            enc_f(v);\n+        }\n     }\n }\n \n-fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n+fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n-    w.write_char('[');\n+    mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n-    w.write_char(']');\n+    mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: @io::Writer, cx: @ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     match *substs {\n         ty::ErasedRegions => {\n-            w.write_char('e');\n+            mywrite!(w, \"e\");\n         }\n         ty::NonerasedRegions(ref regions) => {\n-            w.write_char('n');\n+            mywrite!(w, \"n\");\n             for &r in regions.iter() {\n                 enc_region(w, cx, r);\n             }\n-            w.write_char('.');\n+            mywrite!(w, \".\");\n         }\n     }\n }\n \n-fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n-      ty::re_bound(br) => {\n-        w.write_char('b');\n-        enc_bound_region(w, cx, br);\n-      }\n-      ty::re_free(ref fr) => {\n-        w.write_char('f');\n-        w.write_char('[');\n-        w.write_int(fr.scope_id);\n-        w.write_char('|');\n-        enc_bound_region(w, cx, fr.bound_region);\n-        w.write_char(']');\n-      }\n-      ty::re_scope(nid) => {\n-        w.write_char('s');\n-        w.write_int(nid);\n-        w.write_char('|');\n-      }\n-      ty::re_static => {\n-        w.write_char('t');\n-      }\n-      ty::re_empty => {\n-        w.write_char('e');\n-      }\n-      ty::re_infer(_) => {\n-        // these should not crop up after typeck\n-        cx.diag.handler().bug(\"Cannot encode region variables\");\n-      }\n+        ty::re_bound(br) => {\n+            mywrite!(w, \"b\");\n+            enc_bound_region(w, cx, br);\n+        }\n+        ty::re_free(ref fr) => {\n+            mywrite!(w, \"f[{}|\", fr.scope_id);\n+            enc_bound_region(w, cx, fr.bound_region);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::re_scope(nid) => mywrite!(w, \"s{}|\", nid),\n+        ty::re_static => mywrite!(w, \"t\"),\n+        ty::re_empty => mywrite!(w, \"e\"),\n+        ty::re_infer(_) => {\n+            // these should not crop up after typeck\n+            cx.diag.handler().bug(\"Cannot encode region variables\");\n+        }\n     }\n }\n \n-fn enc_bound_region(w: @io::Writer, cx: @ctxt, br: ty::bound_region) {\n+fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::bound_region) {\n     match br {\n-      ty::br_self => w.write_char('s'),\n-      ty::br_anon(idx) => {\n-        w.write_char('a');\n-        w.write_uint(idx);\n-        w.write_char('|');\n-      }\n-      ty::br_named(s) => {\n-        w.write_char('[');\n-        w.write_str(cx.tcx.sess.str_of(s));\n-        w.write_char(']')\n-      }\n-      ty::br_cap_avoid(id, br) => {\n-        w.write_char('c');\n-        w.write_int(id);\n-        w.write_char('|');\n-        enc_bound_region(w, cx, *br);\n-      }\n-      ty::br_fresh(id) => {\n-        w.write_uint(id);\n-      }\n+        ty::br_self => mywrite!(w, \"s\"),\n+        ty::br_anon(idx) => mywrite!(w, \"a{}|\", idx),\n+        ty::br_named(s) => mywrite!(w, \"[{}]\", cx.tcx.sess.str_of(s)),\n+        ty::br_cap_avoid(id, br) => {\n+            mywrite!(w, \"c{}|\", id);\n+            enc_bound_region(w, cx, *br);\n+        }\n+        ty::br_fresh(id) => mywrite!(w, \"{}\", id),\n     }\n }\n \n-pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n-    w.write_char('/');\n+pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n+    mywrite!(w, \"/\");\n     match v {\n-      ty::vstore_fixed(u) => {\n-        w.write_uint(u);\n-        w.write_char('|');\n-      }\n-      ty::vstore_uniq => {\n-        w.write_char('~');\n-      }\n-      ty::vstore_box => {\n-        w.write_char('@');\n-      }\n-      ty::vstore_slice(r) => {\n-        w.write_char('&');\n-        enc_region(w, cx, r);\n-      }\n+        ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n+        ty::vstore_uniq => mywrite!(w, \"~\"),\n+        ty::vstore_box => mywrite!(w, \"@\"),\n+        ty::vstore_slice(r) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+        }\n     }\n }\n \n-pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n-    w.write_str((cx.ds)(s.def_id));\n-    w.write_char('|');\n+pub fn enc_trait_ref(w: @mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n+    mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n-        ty::UniqTraitStore => w.write_char('~'),\n-        ty::BoxTraitStore => w.write_char('@'),\n+        ty::UniqTraitStore => mywrite!(w, \"~\"),\n+        ty::BoxTraitStore => mywrite!(w, \"@\"),\n         ty::RegionTraitStore(re) => {\n-            w.write_char('&');\n+            mywrite!(w, \"&\");\n             enc_region(w, cx, re);\n         }\n     }\n }\n \n-fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n+fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     match *st {\n-      ty::ty_nil => w.write_char('n'),\n-      ty::ty_bot => w.write_char('z'),\n-      ty::ty_bool => w.write_char('b'),\n-      ty::ty_char => w.write_char('c'),\n-      ty::ty_int(t) => {\n-        match t {\n-          ty_i => w.write_char('i'),\n-          ty_i8 => w.write_str(&\"MB\"),\n-          ty_i16 => w.write_str(&\"MW\"),\n-          ty_i32 => w.write_str(&\"ML\"),\n-          ty_i64 => w.write_str(&\"MD\")\n+        ty::ty_nil => mywrite!(w, \"n\"),\n+        ty::ty_bot => mywrite!(w, \"z\"),\n+        ty::ty_bool => mywrite!(w, \"b\"),\n+        ty::ty_char => mywrite!(w, \"c\"),\n+        ty::ty_int(t) => {\n+            match t {\n+                ty_i => mywrite!(w, \"i\"),\n+                ty_i8 => mywrite!(w, \"MB\"),\n+                ty_i16 => mywrite!(w, \"MW\"),\n+                ty_i32 => mywrite!(w, \"ML\"),\n+                ty_i64 => mywrite!(w, \"MD\")\n+            }\n         }\n-      }\n-      ty::ty_uint(t) => {\n-        match t {\n-          ty_u => w.write_char('u'),\n-          ty_u8 => w.write_str(&\"Mb\"),\n-          ty_u16 => w.write_str(&\"Mw\"),\n-          ty_u32 => w.write_str(&\"Ml\"),\n-          ty_u64 => w.write_str(&\"Md\")\n+        ty::ty_uint(t) => {\n+            match t {\n+                ty_u => mywrite!(w, \"u\"),\n+                ty_u8 => mywrite!(w, \"Mb\"),\n+                ty_u16 => mywrite!(w, \"Mw\"),\n+                ty_u32 => mywrite!(w, \"Ml\"),\n+                ty_u64 => mywrite!(w, \"Md\")\n+            }\n         }\n-      }\n-      ty::ty_float(t) => {\n-        match t {\n-          ty_f32 => w.write_str(&\"Mf\"),\n-          ty_f64 => w.write_str(&\"MF\"),\n+        ty::ty_float(t) => {\n+            match t {\n+                ty_f32 => mywrite!(w, \"Mf\"),\n+                ty_f64 => mywrite!(w, \"MF\"),\n+            }\n         }\n-      }\n-      ty::ty_enum(def, ref substs) => {\n-        w.write_str(&\"t[\");\n-        w.write_str((cx.ds)(def));\n-        w.write_char('|');\n-        enc_substs(w, cx, substs);\n-        w.write_char(']');\n-      }\n-      ty::ty_trait(def, ref substs, store, mt, bounds) => {\n-        w.write_str(&\"x[\");\n-        w.write_str((cx.ds)(def));\n-        w.write_char('|');\n-        enc_substs(w, cx, substs);\n-        enc_trait_store(w, cx, store);\n-        enc_mutability(w, mt);\n-        let bounds = ty::ParamBounds {builtin_bounds: bounds,\n-                                      trait_bounds: ~[]};\n-        enc_bounds(w, cx, &bounds);\n-        w.write_char(']');\n-      }\n-      ty::ty_tup(ref ts) => {\n-        w.write_str(&\"T[\");\n-        for t in ts.iter() { enc_ty(w, cx, *t); }\n-        w.write_char(']');\n-      }\n-      ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n-      ty::ty_uniq(mt) => { w.write_char('~'); enc_mt(w, cx, mt); }\n-      ty::ty_ptr(mt) => { w.write_char('*'); enc_mt(w, cx, mt); }\n-      ty::ty_rptr(r, mt) => {\n-        w.write_char('&');\n-        enc_region(w, cx, r);\n-        enc_mt(w, cx, mt);\n-      }\n-      ty::ty_evec(mt, v) => {\n-        w.write_char('V');\n-        enc_mt(w, cx, mt);\n-        enc_vstore(w, cx, v);\n-      }\n-      ty::ty_estr(v) => {\n-        w.write_char('v');\n-        enc_vstore(w, cx, v);\n-      }\n-      ty::ty_unboxed_vec(mt) => { w.write_char('U'); enc_mt(w, cx, mt); }\n-      ty::ty_closure(ref f) => {\n-        w.write_char('f');\n-        enc_closure_ty(w, cx, f);\n-      }\n-      ty::ty_bare_fn(ref f) => {\n-        w.write_char('F');\n-        enc_bare_fn_ty(w, cx, f);\n-      }\n-      ty::ty_infer(_) => {\n-        cx.diag.handler().bug(\"Cannot encode inference variable types\");\n-      }\n-      ty::ty_param(param_ty {idx: id, def_id: did}) => {\n-        w.write_char('p');\n-        w.write_str((cx.ds)(did));\n-        w.write_char('|');\n-        w.write_str(id.to_str());\n-      }\n-      ty::ty_self(did) => {\n-        w.write_char('s');\n-        w.write_str((cx.ds)(did));\n-        w.write_char('|');\n-      }\n-      ty::ty_type => w.write_char('Y'),\n-      ty::ty_opaque_closure_ptr(p) => {\n-          w.write_str(&\"C&\");\n-          enc_sigil(w, p);\n-      }\n-      ty::ty_opaque_box => w.write_char('B'),\n-      ty::ty_struct(def, ref substs) => {\n-          debug!(\"~~~~ {}\", \"a[\");\n-          w.write_str(&\"a[\");\n-          let s = (cx.ds)(def);\n-          debug!(\"~~~~ {}\", s);\n-          w.write_str(s);\n-          debug!(\"~~~~ {}\", \"|\");\n-          w.write_char('|');\n-          enc_substs(w, cx, substs);\n-          debug!(\"~~~~ {}\", \"]\");\n-          w.write_char(']');\n-      }\n-      ty::ty_err => fail!(\"Shouldn't encode error type\")\n+        ty::ty_enum(def, ref substs) => {\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_trait(def, ref substs, store, mt, bounds) => {\n+            mywrite!(w, \"x[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            enc_trait_store(w, cx, store);\n+            enc_mutability(w, mt);\n+            let bounds = ty::ParamBounds {builtin_bounds: bounds,\n+                                          trait_bounds: ~[]};\n+            enc_bounds(w, cx, &bounds);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_tup(ref ts) => {\n+            mywrite!(w, \"T[\");\n+            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_box(mt) => { mywrite!(w, \"@\"); enc_mt(w, cx, mt); }\n+        ty::ty_uniq(mt) => { mywrite!(w, \"~\"); enc_mt(w, cx, mt); }\n+        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::ty_rptr(r, mt) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+            enc_mt(w, cx, mt);\n+        }\n+        ty::ty_evec(mt, v) => {\n+            mywrite!(w, \"V\");\n+            enc_mt(w, cx, mt);\n+            enc_vstore(w, cx, v);\n+        }\n+        ty::ty_estr(v) => {\n+            mywrite!(w, \"v\");\n+            enc_vstore(w, cx, v);\n+        }\n+        ty::ty_unboxed_vec(mt) => { mywrite!(w, \"U\"); enc_mt(w, cx, mt); }\n+        ty::ty_closure(ref f) => {\n+            mywrite!(w, \"f\");\n+            enc_closure_ty(w, cx, f);\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            mywrite!(w, \"F\");\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_infer(_) => {\n+            cx.diag.handler().bug(\"Cannot encode inference variable types\");\n+        }\n+        ty::ty_param(param_ty {idx: id, def_id: did}) => {\n+            mywrite!(w, \"p{}|{}\", (cx.ds)(did), id);\n+        }\n+        ty::ty_self(did) => {\n+            mywrite!(w, \"s{}|\", (cx.ds)(did));\n+        }\n+        ty::ty_type => mywrite!(w, \"Y\"),\n+        ty::ty_opaque_closure_ptr(p) => {\n+            mywrite!(w, \"C&\");\n+            enc_sigil(w, p);\n+        }\n+        ty::ty_opaque_box => mywrite!(w, \"B\"),\n+        ty::ty_struct(def, ref substs) => {\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_err => fail!(\"Shouldn't encode error type\")\n     }\n }\n \n-fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n+fn enc_sigil(w: @mut MemWriter, sigil: Sigil) {\n     match sigil {\n-        ManagedSigil => w.write_str(\"@\"),\n-        OwnedSigil => w.write_str(\"~\"),\n-        BorrowedSigil => w.write_str(\"&\"),\n+        ManagedSigil => mywrite!(w, \"@\"),\n+        OwnedSigil => mywrite!(w, \"~\"),\n+        BorrowedSigil => mywrite!(w, \"&\"),\n     }\n }\n \n-fn enc_purity(w: @io::Writer, p: purity) {\n+fn enc_purity(w: @mut MemWriter, p: purity) {\n     match p {\n-      impure_fn => w.write_char('i'),\n-      unsafe_fn => w.write_char('u'),\n-      extern_fn => w.write_char('c')\n+        impure_fn => mywrite!(w, \"i\"),\n+        unsafe_fn => mywrite!(w, \"u\"),\n+        extern_fn => mywrite!(w, \"c\")\n     }\n }\n \n-fn enc_abi_set(w: @io::Writer, abis: AbiSet) {\n-    w.write_char('[');\n+fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n+    mywrite!(w, \"[\");\n     do abis.each |abi| {\n-        w.write_str(abi.name());\n-        w.write_char(',');\n+        mywrite!(w, \"{},\", abi.name());\n         true\n     };\n-    w.write_char(']')\n+    mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: @io::Writer, o: Onceness) {\n+fn enc_onceness(w: @mut MemWriter, o: Onceness) {\n     match o {\n-        Once => w.write_char('o'),\n-        Many => w.write_char('m')\n+        Once => mywrite!(w, \"o\"),\n+        Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n@@ -400,37 +365,34 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n-    w.write_char('[');\n+fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n+    mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n-    w.write_char(']');\n+    mywrite!(w, \"]\");\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n-            ty::BoundSend => w.write_char('S'),\n-            ty::BoundFreeze => w.write_char('K'),\n-            ty::BoundStatic => w.write_char('O'),\n-            ty::BoundSized => w.write_char('Z'),\n+            ty::BoundSend => mywrite!(w, \"S\"),\n+            ty::BoundFreeze => mywrite!(w, \"K\"),\n+            ty::BoundStatic => mywrite!(w, \"O\"),\n+            ty::BoundSized => mywrite!(w, \"Z\"),\n         }\n     }\n \n     for &tp in bs.trait_bounds.iter() {\n-        w.write_char('I');\n+        mywrite!(w, \"I\");\n         enc_trait_ref(w, cx, tp);\n     }\n \n-    w.write_char('.');\n+    mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: @io::Writer, cx: @ctxt, v: &ty::TypeParameterDef) {\n-    w.write_str(cx.tcx.sess.str_of(v.ident));\n-    w.write_char(':');\n-    w.write_str((cx.ds)(v.def_id));\n-    w.write_char('|');\n+pub fn enc_type_param_def(w: @mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n+    mywrite!(w, \"{}:{}|\", cx.tcx.sess.str_of(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n }"}, {"sha": "cb8c7b3262fbf2ecfb195cfbe60cf7556b9bb585", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -23,13 +23,6 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use std::at_vec;\n-use std::libc;\n-use extra::ebml::reader;\n-use extra::ebml;\n-use extra::serialize;\n-use extra::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n-use extra::serialize::{Decoder, Decodable};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::inlined_item_utils;\n@@ -40,9 +33,18 @@ use syntax::fold::*;\n use syntax::fold;\n use syntax::parse::token;\n use syntax;\n-use writer = extra::ebml::writer;\n \n+use std::at_vec;\n+use std::libc;\n use std::cast;\n+use std::rt::io::Seek;\n+\n+use extra::ebml::reader;\n+use extra::ebml;\n+use extra::serialize;\n+use extra::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n+use extra::serialize::{Decoder, Decodable};\n+use writer = extra::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n@@ -1319,14 +1321,14 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n-    use std::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n-    let bytes = do io::with_bytes_writer |wr| {\n-        let mut ebml_w = writer::Encoder(wr);\n-        encode_item_ast(&mut ebml_w, in_item);\n-    };\n-    let ebml_doc = reader::Doc(@bytes);\n+    let wr = @mut MemWriter::new();\n+    let mut ebml_w = writer::Encoder(wr);\n+    encode_item_ast(&mut ebml_w, in_item);\n+    let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n     let out_item = decode_item_ast(ebml_doc);\n \n     assert_eq!(in_item, out_item);"}, {"sha": "55daff90e62e2e2b965748269cf42eeef8f5a062", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -21,7 +21,6 @@ use util::common::stmt_set;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::hashmap::{HashSet, HashMap};\n-use std::io;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n@@ -99,7 +98,7 @@ pub fn check_crate(\n     visit::walk_crate(bccx, crate, ());\n \n     if tcx.sess.borrowck_stats() {\n-        io::println(\"--- borrowck stats ---\");\n+        println(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n                  bccx.stats.guaranteed_paths);\n         println!(\"paths requiring loans     : {}\","}, {"sha": "7ad55936b9ed737a0ab698a1e94ce43952e82b19", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,7 +18,7 @@\n \n \n use std::cast;\n-use std::io;\n+use std::rt::io;\n use std::uint;\n use std::vec;\n use std::hashmap::HashMap;\n@@ -349,12 +349,12 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n             let this = @(*self).clone();\n-            this.pretty_print_to(io::stderr(), blk);\n+            this.pretty_print_to(@mut io::stderr() as @mut io::Writer, blk);\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::Block) {\n+    fn pretty_print_to(@self, wr: @mut io::Writer, blk: &ast::Block) {\n         let ps = pprust::rust_printer_annotated(wr,\n                                                 self.tcx.sess.intr(),\n                                                 self as @pprust::pp_ann);"}, {"sha": "695f4a6fd13b5a1ef04571a7d9b8607fb7e8cf76", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -111,7 +111,8 @@ use middle::moves;\n \n use std::cast::transmute;\n use std::hashmap::HashMap;\n-use std::io;\n+use std::rt::io;\n+use std::str;\n use std::to_str;\n use std::uint;\n use std::vec;\n@@ -739,15 +740,14 @@ impl Liveness {\n     }\n \n     pub fn write_vars(&self,\n-                      wr: @io::Writer,\n+                      wr: &mut io::Writer,\n                       ln: LiveNode,\n                       test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                wr.write_str(\" \");\n-                wr.write_str(Variable(var_idx).to_str());\n+                write!(wr, \" {}\", Variable(var_idx).to_str());\n             }\n         }\n     }\n@@ -784,20 +784,14 @@ impl Liveness {\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n-        do io::with_str_writer |wr| {\n-            wr.write_str(\"[ln(\");\n-            wr.write_uint(*ln);\n-            wr.write_str(\") of kind \");\n-            wr.write_str(format!(\"{:?}\", self.ir.lnks[*ln]));\n-            wr.write_str(\" reads\");\n+        str::from_utf8_owned(do io::mem::with_mem_writer |wr| {\n+            let wr = wr as &mut io::Writer;\n+            write!(wr, \"[ln({}) of kind {:?} reads\", *ln, self.ir.lnks[*ln]);\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n-            wr.write_str(\"  writes\");\n+            write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n-            wr.write_str(\" \");\n-            wr.write_str(\" precedes \");\n-            wr.write_str((self.successors[*ln]).to_str());\n-            wr.write_str(\"]\");\n-        }\n+            write!(wr, \"  precedes {}]\", self.successors[*ln].to_str());\n+        })\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "8b5167b7e8fa5257fbb636a36ce4836079c4cef3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -70,7 +70,6 @@ use middle::trans::type_::Type;\n use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::HashMap;\n-use std::io;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n@@ -3163,7 +3162,7 @@ pub fn trans_crate(sess: session::Session,\n     // Translate the metadata.\n     write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n-        io::println(\"--- trans stats ---\");\n+        println(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);\n         println!(\"n_glues_created: {}\", ccx.stats.n_glues_created);\n         println!(\"n_null_glues: {}\", ccx.stats.n_null_glues);\n@@ -3173,7 +3172,7 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_monos: {}\", ccx.stats.n_monos);\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n-        io::println(\"fn stats:\");\n+        println(\"fn stats:\");\n         do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n         }"}, {"sha": "ce50397d00322528679ebeed5b595b0efdaa45e7", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -36,7 +36,8 @@ use driver::session;\n use middle::lint;\n \n use std::comm;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n use std::num;\n use std::os;\n use std::result;\n@@ -181,7 +182,7 @@ Available lint options:\n                  lint::level_to_str(spec.default),\n                  spec.desc);\n     }\n-    io::println(\"\");\n+    println(\"\");\n }\n \n pub fn describe_debug_flags() {\n@@ -247,7 +248,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if \"-\" == ifile {\n-            let src = str::from_utf8(io::stdin().read_whole_stream());\n+            let src = str::from_utf8(io::stdin().read_to_end());\n             str_input(src.to_managed())\n         } else {\n             file_input(Path::new(ifile))\n@@ -275,7 +276,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     if ls {\n         match input {\n           file_input(ref ifile) => {\n-            list_metadata(sess, &(*ifile), io::stdout());\n+            list_metadata(sess, &(*ifile), @mut io::stdout() as @mut io::Writer);\n           }\n           str_input(_) => {\n             early_error(demitter, \"can not list metadata for stdin\");"}, {"sha": "c0fab1ad98f2f6288823f387a8d4f272422bff48", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -28,6 +28,9 @@ use std::local_data;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n use std::rt::io;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::Decorator;\n+use std::str;\n use extra::getopts;\n use extra::getopts::groups;\n use extra::json;\n@@ -257,11 +260,11 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match ::std::io::file_reader(&Path::new(input)) {\n-        Ok(i) => i,\n-        Err(s) => return Err(s),\n+    let input = match Path::new(input).open_reader(io::Open) {\n+        Some(f) => f,\n+        None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n-    match json::from_reader(input) {\n+    match json::from_reader(@mut input as @mut io::Reader) {\n         Err(s) => Err(s.to_str()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n@@ -306,8 +309,10 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n-    let crate_json_str = do std::io::with_str_writer |w| {\n-        crate.encode(&mut json::Encoder(w));\n+    let crate_json_str = {\n+        let w = @mut MemWriter::new();\n+        crate.encode(&mut json::Encoder(w as @mut io::Writer));\n+        str::from_utf8(*w.inner_ref())\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "bee21d70b2d8744c8984e7ec773d0bf45f6933a1", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,7 +10,7 @@\n \n // Context data structure used by rustpkg\n \n-use std::{io, os};\n+use std::os;\n use extra::workcache;\n use rustc::driver::session::{OptLevel, No};\n \n@@ -243,43 +243,43 @@ pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n     };\n \n     if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --linker option can only be used with the build or install commands.\");\n+        println(\"The --linker option can only be used with the build or install commands.\");\n         return true;\n     }\n     if flags.link_args.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --link-args option can only be used with the build or install commands.\");\n+        println(\"The --link-args option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     if !cfgs.is_empty() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --cfg option can only be used with the build or install commands.\");\n+        println(\"The --cfg option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     if user_supplied_opt_level && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The -O and --opt-level options can only be used with the build \\\n+        println(\"The -O and --opt-level options can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n     if flags.save_temps  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --save-temps option can only be used with the build \\\n+        println(\"The --save-temps option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n     if flags.target.is_some()  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --target option can only be used with the build \\\n+        println(\"The --target option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n     if flags.target_cpu.is_some()  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --target-cpu option can only be used with the build \\\n+        println(\"The --target-cpu option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n     if flags.experimental_features.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The -Z option can only be used with the build or install commands.\");\n+        println(\"The -Z option can only be used with the build or install commands.\");\n         return true;\n     }\n "}, {"sha": "79c8ff794ab5613475cbde76a56c7e3ad92b41c7", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -9,31 +9,38 @@\n // except according to those terms.\n \n use extra::term;\n-use std::io;\n+use std::rt::io;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color::GREEN, io::stdout())\n+    pretty_message(msg, \"note: \", term::color::GREEN,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color::YELLOW, io::stdout())\n+    pretty_message(msg, \"warning: \", term::color::YELLOW,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color::RED, io::stdout())\n+    pretty_message(msg, \"error: \", term::color::RED,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n-fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: term::color::Color, out: @io::Writer) {\n+fn pretty_message<'a>(msg: &'a str,\n+                      prefix: &'a str,\n+                      color: term::color::Color,\n+                      out: @mut io::Writer) {\n     let term = term::Terminal::new(out);\n     match term {\n         Ok(ref t) => {\n             t.fg(color);\n-            out.write_str(prefix);\n+            out.write(prefix.as_bytes());\n             t.reset();\n         },\n         _ => {\n-            out.write_str(prefix);\n+            out.write(prefix.as_bytes());\n         }\n     }\n-    out.write_line(msg);\n+    out.write(msg.as_bytes());\n+    out.write(['\\n' as u8]);\n }"}, {"sha": "bd3a1b2f672821aa565b9141592700c38d56bee8", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -24,7 +24,7 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{io, os, result, run, str, task};\n+use std::{os, result, run, str, task};\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -346,7 +346,7 @@ impl CtxMethods for BuildContext {\n                 }\n             }\n             \"list\" => {\n-                io::println(\"Installed packages:\");\n+                println(\"Installed packages:\");\n                 do installed_packages::list_installed_packages |pkg_id| {\n                     do pkg_id.path.display().with_str |s| {\n                         println(s);\n@@ -726,7 +726,7 @@ impl CtxMethods for BuildContext {\n }\n \n pub fn main() {\n-    io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n+    println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n     os::set_exit_status(main_args(os::args()));\n }\n "}, {"sha": "c3e4205dfc972385a18a508776a2bf6fb11277db", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,7 +10,7 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{io, os, run, str};\n+use std::{os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use extra::tempfile::TempDir;\n use version::*;\n@@ -36,8 +36,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                                                    source.as_str().unwrap().to_owned(),\n                                                    target.as_str().unwrap().to_owned()]);\n             if outp.status != 0 {\n-                io::println(str::from_utf8_owned(outp.output.clone()));\n-                io::println(str::from_utf8_owned(outp.error));\n+                println(str::from_utf8_owned(outp.output.clone()));\n+                println(str::from_utf8_owned(outp.error));\n                 return DirToUse(target.clone());\n             }\n                 else {\n@@ -52,8 +52,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                              format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                              ~\"checkout\", format!(\"{}\", *s)]);\n                         if outp.status != 0 {\n-                            io::println(str::from_utf8_owned(outp.output.clone()));\n-                            io::println(str::from_utf8_owned(outp.error));\n+                            println(str::from_utf8_owned(outp.output.clone()));\n+                            println(str::from_utf8_owned(outp.error));\n                             return DirToUse(target.clone());\n                         }\n                     }"}, {"sha": "ce5e81d41092384aba0f417d1731eb1b8ea9a1cc", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,7 +11,10 @@\n // rustpkg unit tests\n \n use context::{BuildContext, Context, RustcFlags};\n-use std::{io, os, run, str, task};\n+use std::{os, run, str, task};\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -81,8 +84,9 @@ fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let out = io::file_writer(file_path, [io::Create, io::Truncate]).unwrap();\n-    out.write_line(contents);\n+    let mut out = file_path.open_writer(io::CreateOrTruncate);\n+    out.write(contents.as_bytes());\n+    out.write(['\\n' as u8]);\n }\n \n fn mk_emptier_workspace(tag: &str) -> TempDir {\n@@ -550,10 +554,11 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     debug!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n-            let w = io::file_writer(p, &[io::Append]);\n-            match w {\n-                Err(s) => { let _ = cond.raise((p.clone(), format!(\"Bad path: {}\", s))); }\n-                Ok(w)  => w.write_line(\"/* hi */\")\n+            do io::io_error::cond.trap(|e| {\n+                cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n+            }).inside {\n+                let mut w = p.open_writer(io::Append);\n+                w.write(bytes!(\"/* hi */\\n\"));\n             }\n         }\n         None => fail!(\"frob_source_file failed to find a source file in {}\","}, {"sha": "6c9a63fe7bd8a6c8973df812b190a25a4a0b293e", "filename": "src/librustpkg/testsuite/fail/src/no-inferred-crates/src/zzyzx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -15,8 +15,6 @@ The test runner should check that, after `rustpkg build hello-world`:\n   * testsuite/hello-world/build/ does not contain a library\n */\n \n-use std::io;\n-\n fn main() {\n-    io::println(~\"Hello world!\");\n+    println(~\"Hello world!\");\n }"}, {"sha": "016635339a9d900a7ebfdadbe27ed3742be5fd82", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,7 +11,7 @@\n extern mod rustpkg;\n extern mod rustc;\n \n-use std::{io, os, task};\n+use std::{os, task};\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n use rustpkg::workcache_support::digest_file_with_date;\n@@ -36,7 +36,7 @@ pub fn main() {\n     }\n \n     if args[2] != ~\"install\" {\n-        io::println(format!(\"Warning: I don't know how to {}\", args[2]));\n+        println(format!(\"Warning: I don't know how to {}\", args[2]));\n         return;\n     }\n "}, {"sha": "f82c585b1d156745e67484bd967a329fb084d1cc", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,7 +11,10 @@\n extern mod rustpkg;\n extern mod rustc;\n \n-use std::{io, os};\n+use std::os;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n@@ -42,9 +45,9 @@ pub fn main() {\n     let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n     debug!(\"Writing file\");\n-    let file = io::file_writer(&out_path.join(\"generated.rs\"), [io::Create]).unwrap();\n-    file.write_str(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n-                   for _ in xs.iter() { assert!(true); } }\");\n+    let mut file = out_path.join(\"generated.rs\").open_writer(io::Create);\n+    file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n+                for _ in xs.iter() { assert!(true); } }\".as_bytes());\n \n     let context = api::default_context(sysroot, api::default_workspace());\n     api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);"}, {"sha": "d4c65954fe6298ee5258767a7a78f4043f94534e", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,8 +18,6 @@ The test runner should check that, after `rustpkg build hello-world`:\n   * testsuite/pass/hello-world/build is empty\n */\n \n-use std::io;\n-\n fn main() {\n-    io::println(~\"Hello world!\");\n+    println(~\"Hello world!\");\n }"}, {"sha": "ef6ac485b7294f80cf91a67bec7c6604daf43c30", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n pub fn general() {\n-    io::println(\"Usage: rustpkg [options] <cmd> [args..]\n+    println(\"Usage: rustpkg [options] <cmd> [args..]\n \n Where <cmd> is one of:\n     build, clean, do, info, install, list, prefer, test, uninstall, unprefer\n@@ -24,7 +22,7 @@ Options:\n }\n \n pub fn build() {\n-    io::println(\"rustpkg build [options..] [package-ID]\n+    println(\"rustpkg build [options..] [package-ID]\n \n Build the given package ID if specified. With no package ID argument,\n build the package in the current directory. In that case, the current\n@@ -50,21 +48,21 @@ Options:\n }\n \n pub fn clean() {\n-    io::println(\"rustpkg clean\n+    println(\"rustpkg clean\n \n Remove all build files in the work cache for the package in the current\n directory.\");\n }\n \n pub fn do_cmd() {\n-    io::println(\"rustpkg do <cmd>\n+    println(\"rustpkg do <cmd>\n \n Runs a command in the package script. You can listen to a command\n by tagging a function with the attribute `#[pkg_do(cmd)]`.\");\n }\n \n pub fn info() {\n-    io::println(\"rustpkg [options..] info\n+    println(\"rustpkg [options..] info\n \n Probe the package script in the current directory for information.\n \n@@ -73,13 +71,13 @@ Options:\n }\n \n pub fn list() {\n-    io::println(\"rustpkg list\n+    println(\"rustpkg list\n \n List all installed packages.\");\n }\n \n pub fn install() {\n-    io::println(\"rustpkg install [options..] [package-ID]\n+    println(\"rustpkg install [options..] [package-ID]\n \n Install the given package ID if specified. With no package ID\n argument, install the package in the current directory.\n@@ -105,14 +103,14 @@ Options:\n }\n \n pub fn uninstall() {\n-    io::println(\"rustpkg uninstall <id|name>[@version]\n+    println(\"rustpkg uninstall <id|name>[@version]\n \n Remove a package by id or name and optionally version. If the package(s)\n is/are depended on by another package then they cannot be removed.\");\n }\n \n pub fn prefer() {\n-    io::println(\"rustpkg [options..] prefer <id|name>[@version]\n+    println(\"rustpkg [options..] prefer <id|name>[@version]\n \n By default all binaries are given a unique name so that multiple versions can\n coexist. The prefer command will symlink the uniquely named binary to\n@@ -130,7 +128,7 @@ Example:\n }\n \n pub fn unprefer() {\n-    io::println(\"rustpkg [options..] unprefer <id|name>[@version]\n+    println(\"rustpkg [options..] unprefer <id|name>[@version]\n \n Remove all symlinks from the store to the binary directory for a package\n name and optionally version. If version is not supplied, the latest version\n@@ -139,7 +137,7 @@ information.\");\n }\n \n pub fn test() {\n-    io::println(\"rustpkg [options..] test\n+    println(\"rustpkg [options..] test\n \n Build all test crates in the current directory with the test flag.\n Then, run all the resulting test executables, redirecting the output\n@@ -150,7 +148,7 @@ Options:\n }\n \n pub fn init() {\n-    io::println(\"rustpkg init\n+    println(\"rustpkg init\n \n This will turn the current working directory into a workspace. The first\n command you run when starting off a new project."}, {"sha": "b68e42d8ebe2423dcc63ba757d3ebd597ef17851", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,33 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+\n use extra::sha1::Sha1;\n use extra::digest::Digest;\n use extra::workcache;\n-use std::io;\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n     use cond1 = conditions::bad_stat::cond;\n \n-    let s = io::read_whole_file_str(path);\n-    match s {\n-        Ok(s) => {\n+    let mut err = None;\n+    let bytes = do io::io_error::cond.trap(|e| err = Some(e)).inside {\n+        path.open_reader(io::Open).read_to_end()\n+    };\n+    match err {\n+        None => {\n             let mut sha = Sha1::new();\n-            sha.input_str(s);\n+            sha.input(bytes);\n             let st = match path.stat() {\n                 Some(st) => st,\n                 None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n             };\n             sha.input_str(st.modified.to_str());\n             sha.result_str()\n         }\n-        Err(e) => {\n-            let path = cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e)));\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            // XXX: I'm pretty sure this is the wrong return value\n-            path.as_str().unwrap().to_owned()\n+        Some(e) => {\n+            cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e.desc)));\n+            ~\"\"\n         }\n     }\n }"}, {"sha": "b2e68c8d20fa741e1fdc37cca63c07f906b6ac81", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -348,12 +348,57 @@ impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n     }\n }\n \n+/// Parses a C \"multistring\", eg windows env values or\n+/// the req->ptr result in a uv_fs_readdir() call.\n+///\n+/// Optionally, a `count` can be passed in, limiting the\n+/// parsing to only being done `count`-times.\n+///\n+/// The specified closure is invoked with each string that\n+/// is found, and the number of strings found is returned.\n+pub unsafe fn from_c_multistring(buf: *libc::c_char,\n+                                 count: Option<uint>,\n+                                 f: &fn(&CString)) -> uint {\n+\n+    let mut curr_ptr: uint = buf as uint;\n+    let mut ctr = 0;\n+    let (limited_count, limit) = match count {\n+        Some(limit) => (true, limit),\n+        None => (false, 0)\n+    };\n+    while ((limited_count && ctr < limit) || !limited_count)\n+          && *(curr_ptr as *libc::c_char) != 0 as libc::c_char {\n+        let cstr = CString::new(curr_ptr as *libc::c_char, false);\n+        f(&cstr);\n+        curr_ptr += cstr.len() + 1;\n+        ctr += 1;\n+    }\n+    return ctr;\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use libc;\n     use ptr;\n     use option::{Some, None};\n+    use vec;\n+\n+    #[test]\n+    fn test_str_multistring_parsing() {\n+        unsafe {\n+            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n+            let ptr = vec::raw::to_ptr(input);\n+            let expected = [\"zero\", \"one\"];\n+            let mut it = expected.iter();\n+            let result = do from_c_multistring(ptr as *libc::c_char, None) |c| {\n+                let cbytes = c.as_bytes().slice_to(c.len());\n+                assert_eq!(cbytes, it.next().unwrap().as_bytes());\n+            };\n+            assert_eq!(result, 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n \n     #[test]\n     fn test_str_to_c_str() {"}, {"sha": "4e55c5fe60eb50c8741a59698039eeb7b85d959d", "filename": "src/libstd/io.rs", "status": "removed", "additions": 0, "deletions": 2181, "changes": 2181, "blob_url": "https://github.com/rust-lang/rust/blob/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "patch": "@@ -1,2181 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `io` module contains basic input and output routines.\n-\n-A quick summary:\n-\n-## `Reader` and `Writer` traits\n-\n-These traits define the minimal set of methods that anything that can do\n-input and output should implement.\n-\n-## `ReaderUtil` and `WriterUtil` traits\n-\n-Richer methods that allow you to do more. `Reader` only lets you read a certain\n-number of bytes into a buffer, while `ReaderUtil` allows you to read a whole\n-line, for example.\n-\n-Generally, these richer methods are probably the ones you want to actually\n-use in day-to-day Rust.\n-\n-Furthermore, because there is an implementation of `ReaderUtil` for\n-`<T: Reader>`, when your input or output code implements `Reader`, you get\n-all of these methods for free.\n-\n-## `print` and `println`\n-\n-These very useful functions are defined here. You generally don't need to\n-import them, though, as the prelude already does.\n-\n-## `stdin`, `stdout`, and `stderr`\n-\n-These functions return references to the classic three file descriptors. They\n-implement `Reader` and `Writer`, where appropriate.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use cast;\n-use cast::transmute;\n-use clone::Clone;\n-use c_str::ToCStr;\n-use container::Container;\n-use int;\n-use iter::Iterator;\n-use libc::consts::os::posix88::*;\n-use libc::{c_int, c_void, size_t};\n-use libc;\n-use num;\n-use ops::Drop;\n-use option::{Some, None};\n-use os;\n-use path::{Path,GenericPath};\n-use ptr;\n-use result::{Result, Ok, Err};\n-use str::{StrSlice, OwnedStr};\n-use str;\n-use to_str::ToStr;\n-use uint;\n-use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n-use vec;\n-\n-#[allow(non_camel_case_types)] // not sure what to do about this\n-pub type fd_t = c_int;\n-\n-pub mod rustrt {\n-    use libc;\n-\n-    #[link_name = \"rustrt\"]\n-    extern {\n-        pub fn rust_get_stdin() -> *libc::FILE;\n-        pub fn rust_get_stdout() -> *libc::FILE;\n-        pub fn rust_get_stderr() -> *libc::FILE;\n-    }\n-}\n-\n-// Reading\n-\n-// FIXME (#2004): This is all buffered. We might need an unbuffered variant\n-// as well\n-/**\n-* The SeekStyle enum describes the relationship between the position\n-* we'd like to seek to from our current position. It's used as an argument\n-* to the `seek` method defined on the `Reader` trait.\n-*\n-* There are three seek styles:\n-*\n-* 1. `SeekSet` means that the new position should become our position.\n-* 2. `SeekCur` means that we should seek from the current position.\n-* 3. `SeekEnd` means that we should seek from the end.\n-*\n-* # Examples\n-*\n-* None right now.\n-*/\n-pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n-\n-\n-/**\n-* The core Reader trait. All readers must implement this trait.\n-*\n-* # Examples\n-*\n-* None right now.\n-*/\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    // FIXME (#2982): This should probably return an error.\n-    /**\n-    * Reads bytes and puts them into `bytes`, advancing the cursor. Returns the\n-    * number of bytes read.\n-    *\n-    * The number of bytes to be read is `len` or the end of the file,\n-    * whichever comes first.\n-    *\n-    * The buffer must be at least `len` bytes long.\n-    *\n-    * `read` is conceptually similar to C's `fread` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n-\n-    /**\n-    * Reads a single byte, advancing the cursor.\n-    *\n-    * In the case of an EOF or an error, returns a negative value.\n-    *\n-    * `read_byte` is conceptually similar to C's `getc` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_byte(&self) -> int;\n-\n-    /**\n-    * Returns a boolean value: are we currently at EOF?\n-    *\n-    * Note that stream position may be already at the end-of-file point,\n-    * but `eof` returns false until an attempt to read at that position.\n-    *\n-    * `eof` is conceptually similar to C's `feof` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn eof(&self) -> bool;\n-\n-    /**\n-    * Seek to a given `position` in the stream.\n-    *\n-    * Takes an optional SeekStyle, which affects how we seek from the\n-    * position. See `SeekStyle` docs for more details.\n-    *\n-    * `seek` is conceptually similar to C's `fseek` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn seek(&self, position: int, style: SeekStyle);\n-\n-    /**\n-    * Returns the current position within the stream.\n-    *\n-    * `tell` is conceptually similar to C's `ftell` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn tell(&self) -> uint;\n-}\n-\n-impl Reader for @Reader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.read(bytes, len)\n-    }\n-    fn read_byte(&self) -> int {\n-        self.read_byte()\n-    }\n-    fn eof(&self) -> bool {\n-        self.eof()\n-    }\n-    fn seek(&self, position: int, style: SeekStyle) {\n-        self.seek(position, style)\n-    }\n-    fn tell(&self) -> uint {\n-        self.tell()\n-    }\n-}\n-\n-/**\n-* The `ReaderUtil` trait is a home for many of the utility functions\n-* a particular Reader should implement.\n-*\n-* The default `Reader` trait is focused entirely on bytes. `ReaderUtil` is based\n-* on higher-level concepts like 'chars' and 'lines.'\n-*\n-* # Examples:\n-*\n-* None right now.\n-*/\n-pub trait ReaderUtil {\n-\n-    /**\n-    * Reads `len` number of bytes, and gives you a new vector back.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_bytes(&self, len: uint) -> ~[u8];\n-\n-    /**\n-    * Reads up until a specific byte is seen or EOF.\n-    *\n-    * The `include` parameter specifies if the character should be included\n-    * in the returned string.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_until(&self, c: u8, include: bool) -> ~str;\n-\n-    /**\n-    * Reads up until the first '\\n' or EOF.\n-    *\n-    * The '\\n' is not included in the result.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_line(&self) -> ~str;\n-\n-    /**\n-    * Reads `n` chars.\n-    *\n-    * Assumes that those chars are UTF-8 encoded.\n-    *\n-    * The '\\n' is not included in the result.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_chars(&self, n: uint) -> ~[char];\n-\n-    /**\n-    * Reads a single UTF-8 encoded char.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_char(&self) -> char;\n-\n-    /**\n-    * Reads up until the first null byte or EOF.\n-    *\n-    * The null byte is not returned.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_c_str(&self) -> ~str;\n-\n-    /**\n-    * Reads all remaining data in the stream.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_whole_stream(&self) -> ~[u8];\n-\n-    /**\n-    * Iterate over every byte until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_byte(&self, it: &fn(int) -> bool) -> bool;\n-\n-    /**\n-    * Iterate over every char until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n-\n-    /**\n-    * Iterate over every line until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_line(&self, it: &fn(&str) -> bool) -> bool;\n-\n-    /**\n-    * Reads all of the lines in the stream.\n-    *\n-    * Returns a vector of those lines.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_lines(&self) -> ~[~str];\n-\n-    /**\n-    * Reads `n` little-endian unsigned integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_uint_n(&self, nbytes: uint) -> u64;\n-\n-    /**\n-    * Reads `n` little-endian signed integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_int_n(&self, nbytes: uint) -> i64;\n-\n-    /**\n-    * Reads `n` big-endian unsigned integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_uint_n(&self, nbytes: uint) -> u64;\n-\n-    /**\n-    * Reads `n` big-endian signed integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_int_n(&self, nbytes: uint) -> i64;\n-\n-    /**\n-    * Reads a little-endian unsigned integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_uint(&self) -> uint;\n-\n-    /**\n-    * Reads a little-endian integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_int(&self) -> int;\n-\n-    /**\n-    * Reads a big-endian unsigned integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_uint(&self) -> uint;\n-\n-    /**\n-    * Reads a big-endian integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_int(&self) -> int;\n-\n-    /**\n-    * Reads a big-endian `u64`.\n-    *\n-    * `u64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u64(&self) -> u64;\n-\n-    /**\n-    * Reads a big-endian `u32`.\n-    *\n-    * `u32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u32(&self) -> u32;\n-\n-    /**\n-    * Reads a big-endian `u16`.\n-    *\n-    * `u16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u16(&self) -> u16;\n-\n-    /**\n-    * Reads a big-endian `i64`.\n-    *\n-    * `i64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i64(&self) -> i64;\n-\n-    /**\n-    * Reads a big-endian `i32`.\n-    *\n-    * `i32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i32(&self) -> i32;\n-\n-    /**\n-    * Reads a big-endian `i16`.\n-    *\n-    * `i16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i16(&self) -> i16;\n-\n-    /**\n-    * Reads a big-endian `f64`.\n-    *\n-    * `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_f64(&self) -> f64;\n-\n-    /**\n-    * Reads a big-endian `f32`.\n-    *\n-    * `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_f32(&self) -> f32;\n-\n-    /**\n-    * Reads a little-endian `u64`.\n-    *\n-    * `u64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u64(&self) -> u64;\n-\n-    /**\n-    * Reads a little-endian `u32`.\n-    *\n-    * `u32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u32(&self) -> u32;\n-\n-    /**\n-    * Reads a little-endian `u16`.\n-    *\n-    * `u16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u16(&self) -> u16;\n-\n-    /**\n-    * Reads a little-endian `i64`.\n-    *\n-    * `i64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i64(&self) -> i64;\n-\n-    /**\n-    * Reads a little-endian `i32`.\n-    *\n-    * `i32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i32(&self) -> i32;\n-\n-    /**\n-    * Reads a little-endian `i16`.\n-    *\n-    * `i16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i16(&self) -> i16;\n-\n-    /**\n-    * Reads a little-endian `f64`.\n-    *\n-    * `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_f64(&self) -> f64;\n-\n-    /**\n-    * Reads a little-endian `f32`.\n-    *\n-    * `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_f32(&self) -> f32;\n-\n-    /**\n-    * Read a u8.\n-    *\n-    * `u8`s are 1 byte.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_u8(&self) -> u8;\n-\n-    /**\n-    * Read an i8.\n-    *\n-    * `i8`s are 1 byte.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_i8(&self) -> i8;\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(&self, len: uint) -> ~[u8] {\n-        let mut bytes = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(&mut bytes, len); }\n-\n-        let count = self.read(bytes, len);\n-\n-        unsafe { vec::raw::set_len(&mut bytes, count); }\n-        bytes\n-    }\n-\n-    fn read_until(&self, c: u8, include: bool) -> ~str {\n-        let mut bytes = ~[];\n-        loop {\n-            let ch = self.read_byte();\n-            if ch == -1 || ch == c as int {\n-                if include && ch == c as int {\n-                    bytes.push(ch as u8);\n-                }\n-                break;\n-            }\n-            bytes.push(ch as u8);\n-        }\n-        str::from_utf8(bytes)\n-    }\n-\n-    fn read_line(&self) -> ~str {\n-        self.read_until('\\n' as u8, false)\n-    }\n-\n-    fn read_chars(&self, n: uint) -> ~[char] {\n-        // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_utf8<T:Reader>(bytes: &~[u8], chars: &mut ~[char])\n-            -> (uint, uint) {\n-            let mut i = 0;\n-            let bytes_len = bytes.len();\n-            while i < bytes_len {\n-                let b0 = bytes[i];\n-                let w = str::utf8_char_width(b0);\n-                let end = i + w;\n-                i += 1;\n-                assert!((w > 0));\n-                if w == 1 {\n-                    unsafe {\n-                        chars.push(transmute(b0 as u32));\n-                    }\n-                    continue;\n-                }\n-                // can't satisfy this char with the existing data\n-                if end > bytes_len {\n-                    return (i - 1, end - bytes_len);\n-                }\n-                let mut val = 0;\n-                while i < end {\n-                    let next = bytes[i] as int;\n-                    i += 1;\n-                    assert!((next > -1));\n-                    assert_eq!(next & 192, 128);\n-                    val <<= 6;\n-                    val += (next & 63) as uint;\n-                }\n-                // See str::StrSlice::char_at\n-                val += ((b0 << ((w + 1) as u8)) as uint)\n-                    << (w - 1) * 6 - w - 1u;\n-                unsafe {\n-                    chars.push(transmute(val as u32));\n-                }\n-            }\n-            return (i, 0);\n-        }\n-        let mut bytes = ~[];\n-        let mut chars = ~[];\n-        // might need more bytes, but reading n will never over-read\n-        let mut nbread = n;\n-        while nbread > 0 {\n-            let data = self.read_bytes(nbread);\n-            if data.is_empty() {\n-                // eof - FIXME (#2004): should we do something if\n-                // we're split in a unicode char?\n-                break;\n-            }\n-            bytes.push_all(data);\n-            let (offset, nbreq) = chars_from_utf8::<T>(&bytes, &mut chars);\n-            let ncreq = n - chars.len();\n-            // again we either know we need a certain number of bytes\n-            // to complete a character, or we make sure we don't\n-            // over-read by reading 1-byte per char needed\n-            nbread = if ncreq > nbreq { ncreq } else { nbreq };\n-            if nbread > 0 {\n-                bytes = bytes.slice(offset, bytes.len()).to_owned();\n-            }\n-        }\n-        chars\n-    }\n-\n-    fn read_char(&self) -> char {\n-        let c = self.read_chars(1);\n-        if c.len() == 0 {\n-            return unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n-        }\n-        assert_eq!(c.len(), 1);\n-        return c[0];\n-    }\n-\n-    fn read_c_str(&self) -> ~str {\n-        self.read_until(0u8, false)\n-    }\n-\n-    fn read_whole_stream(&self) -> ~[u8] {\n-        let mut bytes: ~[u8] = ~[];\n-        while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n-        bytes\n-    }\n-\n-    fn each_byte(&self, it: &fn(int) -> bool) -> bool {\n-        loop {\n-            match self.read_byte() {\n-                -1 => break,\n-                ch => if !it(ch) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool {\n-        // FIXME: #8971: unsound\n-        let eof: char = unsafe { transmute(-1u32) };\n-        loop {\n-            match self.read_char() {\n-                c if c == eof => break,\n-                ch => if !it(ch) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_line(&self, it: &fn(s: &str) -> bool) -> bool {\n-        while !self.eof() {\n-            // include the \\n, so that we can distinguish an entirely empty\n-            // line read after \"...\\n\", and the trailing empty line in\n-            // \"...\\n\\n\".\n-            let mut line = self.read_until('\\n' as u8, true);\n-\n-            // blank line at the end of the reader is ignored\n-            if self.eof() && line.is_empty() { break; }\n-\n-            // trim the \\n, so that each_line is consistent with read_line\n-            let n = line.len();\n-            if line[n-1] == '\\n' as u8 {\n-                unsafe { str::raw::set_len(&mut line, n-1); }\n-            }\n-\n-            if !it(line) { return false; }\n-        }\n-        return true;\n-    }\n-\n-    fn read_lines(&self) -> ~[~str] {\n-        do vec::build(None) |push| {\n-            do self.each_line |line| {\n-                push(line.to_owned());\n-                true\n-            };\n-        }\n-    }\n-\n-    // FIXME int reading methods need to deal with eof - issue #2004\n-\n-    fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        val\n-    }\n-\n-    fn read_le_int_n(&self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n-    }\n-\n-    fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n-        }\n-        val\n-    }\n-\n-    fn read_be_int_n(&self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n-    }\n-\n-    fn read_le_uint(&self) -> uint {\n-        self.read_le_uint_n(uint::bytes) as uint\n-    }\n-\n-    fn read_le_int(&self) -> int {\n-        self.read_le_int_n(int::bytes) as int\n-    }\n-\n-    fn read_be_uint(&self) -> uint {\n-        self.read_be_uint_n(uint::bytes) as uint\n-    }\n-\n-    fn read_be_int(&self) -> int {\n-        self.read_be_int_n(int::bytes) as int\n-    }\n-\n-    fn read_be_u64(&self) -> u64 {\n-        self.read_be_uint_n(8) as u64\n-    }\n-\n-    fn read_be_u32(&self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n-    }\n-\n-    fn read_be_u16(&self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n-    }\n-\n-    fn read_be_i64(&self) -> i64 {\n-        self.read_be_int_n(8) as i64\n-    }\n-\n-    fn read_be_i32(&self) -> i32 {\n-        self.read_be_int_n(4) as i32\n-    }\n-\n-    fn read_be_i16(&self) -> i16 {\n-        self.read_be_int_n(2) as i16\n-    }\n-\n-    fn read_be_f64(&self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n-        }\n-    }\n-\n-    fn read_be_f32(&self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n-        }\n-    }\n-\n-    fn read_le_u64(&self) -> u64 {\n-        self.read_le_uint_n(8) as u64\n-    }\n-\n-    fn read_le_u32(&self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n-    }\n-\n-    fn read_le_u16(&self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n-    }\n-\n-    fn read_le_i64(&self) -> i64 {\n-        self.read_le_int_n(8) as i64\n-    }\n-\n-    fn read_le_i32(&self) -> i32 {\n-        self.read_le_int_n(4) as i32\n-    }\n-\n-    fn read_le_i16(&self) -> i16 {\n-        self.read_le_int_n(2) as i16\n-    }\n-\n-    fn read_le_f64(&self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n-        }\n-    }\n-\n-    fn read_le_f32(&self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n-        }\n-    }\n-\n-    fn read_u8(&self) -> u8 {\n-        self.read_byte() as u8\n-    }\n-\n-    fn read_i8(&self) -> i8 {\n-        self.read_byte() as i8\n-    }\n-}\n-\n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n-// Reader implementations\n-\n-fn convert_whence(whence: SeekStyle) -> i32 {\n-    return match whence {\n-      SeekSet => 0i32,\n-      SeekCur => 1i32,\n-      SeekEnd => 2i32\n-    };\n-}\n-\n-impl Reader for *libc::FILE {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            do bytes.as_mut_buf |buf_p, buf_len| {\n-                assert!(buf_len >= len);\n-\n-                let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n-                                        len as size_t, *self) as uint;\n-                if count < len {\n-                  match libc::ferror(*self) {\n-                    0 => (),\n-                    _ => {\n-                      error!(\"error reading buffer: {}\", os::last_os_error());\n-                      fail!();\n-                    }\n-                  }\n-                }\n-\n-                count\n-            }\n-        }\n-    }\n-    fn read_byte(&self) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fgetc(*self) as int\n-        }\n-    }\n-    fn eof(&self) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            return libc::feof(*self) != 0 as c_int;\n-        }\n-    }\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            assert!(libc::fseek(*self,\n-                                     offset as libc::c_long,\n-                                     convert_whence(whence)) == 0 as c_int);\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            return libc::ftell(*self) as uint;\n-        }\n-    }\n-}\n-\n-struct Wrapper<T, C> {\n-    base: T,\n-    cleanup: C,\n-}\n-\n-// A forwarding impl of reader that also holds on to a resource for the\n-// duration of its lifetime.\n-// FIXME there really should be a better way to do this // #2004\n-impl<R:Reader,C> Reader for Wrapper<R, C> {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.base.read(bytes, len)\n-    }\n-    fn read_byte(&self) -> int { self.base.read_byte() }\n-    fn eof(&self) -> bool { self.base.eof() }\n-    fn seek(&self, off: int, whence: SeekStyle) {\n-        self.base.seek(off, whence)\n-    }\n-    fn tell(&self) -> uint { self.base.tell() }\n-}\n-\n-pub struct FILERes {\n-    priv f: *libc::FILE,\n-}\n-\n-impl FILERes {\n-    pub fn new(f: *libc::FILE) -> FILERes {\n-        FILERes { f: f }\n-    }\n-}\n-\n-impl Drop for FILERes {\n-    fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fclose(self.f);\n-        }\n-    }\n-}\n-\n-pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n-    if cleanup {\n-        @Wrapper { base: f, cleanup: FILERes::new(f) } as @Reader\n-    } else {\n-        @f as @Reader\n-    }\n-}\n-\n-// FIXME (#2004): this should either be an trait-less impl, a set of\n-// top-level functions that take a reader, or a set of default methods on\n-// reader (which can then be called reader)\n-\n-/**\n-* Gives a `Reader` that allows you to read values from standard input.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stdin = std::io::stdin();\n-* let line = stdin.read_line();\n-* std::io::print(line);\n-* ```\n-*/\n-pub fn stdin() -> @Reader {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        @rustrt::rust_get_stdin() as @Reader\n-    }\n-}\n-\n-pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let f = do path.with_c_str |pathbuf| {\n-        do \"rb\".with_c_str |modebuf| {\n-            unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n-        }\n-    };\n-\n-    if f as uint == 0u {\n-        do path.display().with_str |p| {\n-            Err(~\"error opening \" + p)\n-        }\n-    } else {\n-        Ok(FILE_reader(f, true))\n-    }\n-}\n-\n-\n-// Byte readers\n-pub struct BytesReader {\n-    // FIXME(#5723) see other FIXME below\n-    // FIXME(#7268) this should also be parameterized over <'self>\n-    bytes: &'static [u8],\n-    pos: @mut uint\n-}\n-\n-impl Reader for BytesReader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        let count = num::min(len, self.bytes.len() - *self.pos);\n-\n-        let view = self.bytes.slice(*self.pos, self.bytes.len());\n-        vec::bytes::copy_memory(bytes, view, count);\n-\n-        *self.pos += count;\n-\n-        count\n-    }\n-\n-    fn read_byte(&self) -> int {\n-        if *self.pos == self.bytes.len() {\n-            return -1;\n-        }\n-\n-        let b = self.bytes[*self.pos];\n-        *self.pos += 1u;\n-        b as int\n-    }\n-\n-    fn eof(&self) -> bool {\n-        *self.pos == self.bytes.len()\n-    }\n-\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = *self.pos;\n-        *self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n-    }\n-\n-    fn tell(&self) -> uint {\n-        *self.pos\n-    }\n-}\n-\n-pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n-    // XXX XXX XXX this is glaringly unsound\n-    // FIXME(#5723) Use a &Reader for the callback's argument. Should be:\n-    // fn with_bytes_reader<'r, T>(bytes: &'r [u8], f: &fn(&'r Reader) -> T) -> T\n-    let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n-    f(@BytesReader {\n-        bytes: bytes,\n-        pos: @mut 0\n-    } as @Reader)\n-}\n-\n-pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n-    // FIXME(#5723): As above.\n-    with_bytes_reader(s.as_bytes(), f)\n-}\n-\n-// Writing\n-pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n-\n-// What type of writer are we?\n-#[deriving(Eq)]\n-pub enum WriterType { Screen, File }\n-\n-// FIXME (#2004): Seekable really should be orthogonal.\n-// FIXME (#2004): eventually u64\n-/// The raw underlying writer trait. All writers must implement this.\n-pub trait Writer {\n-\n-    /// Write all of the given bytes.\n-    fn write(&self, v: &[u8]);\n-\n-    /// Move the current position within the stream. The second parameter\n-    /// determines the position that the first parameter is relative to.\n-    fn seek(&self, int, SeekStyle);\n-\n-    /// Return the current position within the stream.\n-    fn tell(&self) -> uint;\n-\n-    /// Flush the output buffer for this stream (if there is one).\n-    fn flush(&self) -> int;\n-\n-    /// Determine if this Writer is writing to a file or not.\n-    fn get_type(&self) -> WriterType;\n-}\n-\n-impl Writer for @Writer {\n-    fn write(&self, v: &[u8]) { self.write(v) }\n-    fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n-    fn tell(&self) -> uint { self.tell() }\n-    fn flush(&self) -> int { self.flush() }\n-    fn get_type(&self) -> WriterType { self.get_type() }\n-}\n-\n-impl<W:Writer,C> Writer for Wrapper<W, C> {\n-    fn write(&self, bs: &[u8]) { self.base.write(bs); }\n-    fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n-    fn tell(&self) -> uint { self.base.tell() }\n-    fn flush(&self) -> int { self.base.flush() }\n-    fn get_type(&self) -> WriterType { File }\n-}\n-\n-impl Writer for *libc::FILE {\n-    fn write(&self, v: &[u8]) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            do v.as_imm_buf |vbuf, len| {\n-                let nout = libc::fwrite(vbuf as *c_void,\n-                                        1,\n-                                        len as size_t,\n-                                        *self);\n-                if nout != len as size_t {\n-                    error!(\"error writing buffer: {}\", os::last_os_error());\n-                    fail!();\n-                }\n-            }\n-        }\n-    }\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            assert!(libc::fseek(*self,\n-                                     offset as libc::c_long,\n-                                     convert_whence(whence)) == 0 as c_int);\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::ftell(*self) as uint\n-        }\n-    }\n-    fn flush(&self) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fflush(*self) as int\n-        }\n-    }\n-    fn get_type(&self) -> WriterType {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let fd = libc::fileno(*self);\n-            if libc::isatty(fd) == 0 { File   }\n-            else                     { Screen }\n-        }\n-    }\n-}\n-\n-impl Writer for fd_t {\n-    fn write(&self, v: &[u8]) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        #[cfg(windows)]\n-        type IoSize = libc::c_uint;\n-        #[cfg(windows)]\n-        type IoRet = c_int;\n-\n-        #[cfg(unix)]\n-        type IoSize = size_t;\n-        #[cfg(unix)]\n-        type IoRet = libc::ssize_t;\n-\n-        unsafe {\n-            let mut count = 0u;\n-            do v.as_imm_buf |vbuf, len| {\n-                while count < len {\n-                    let vb = ptr::offset(vbuf, count as int) as *c_void;\n-                    let nout = libc::write(*self, vb, len as IoSize);\n-                    if nout < 0 as IoRet {\n-                        error!(\"error writing buffer: {}\", os::last_os_error());\n-                        fail!();\n-                    }\n-                    count += nout as uint;\n-                }\n-            }\n-        }\n-    }\n-    fn seek(&self, _offset: int, _whence: SeekStyle) {\n-        error!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail!();\n-    }\n-    fn tell(&self) -> uint {\n-        error!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail!();\n-    }\n-    fn flush(&self) -> int { 0 }\n-    fn get_type(&self) -> WriterType {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            if libc::isatty(*self) == 0 { File } else { Screen }\n-        }\n-    }\n-}\n-\n-pub struct FdRes {\n-    priv fd: fd_t,\n-}\n-\n-impl FdRes {\n-    pub fn new(fd: fd_t) -> FdRes {\n-        FdRes { fd: fd }\n-    }\n-}\n-\n-impl Drop for FdRes {\n-    fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::close(self.fd);\n-        }\n-    }\n-}\n-\n-pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n-    if cleanup {\n-        @Wrapper { base: fd, cleanup: FdRes::new(fd) } as @Writer\n-    } else {\n-        @fd as @Writer\n-    }\n-}\n-\n-\n-pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<@Writer, ~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    #[cfg(windows)]\n-    fn wb() -> c_int {\n-      (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n-    }\n-\n-    #[cfg(unix)]\n-    fn wb() -> c_int { O_WRONLY as c_int }\n-\n-    let mut fflags: c_int = wb();\n-    for f in flags.iter() {\n-        match *f {\n-          Append => fflags |= O_APPEND as c_int,\n-          Create => fflags |= O_CREAT as c_int,\n-          Truncate => fflags |= O_TRUNC as c_int,\n-          NoFlag => ()\n-        }\n-    }\n-    let fd = unsafe {\n-        do path.with_c_str |pathbuf| {\n-            libc::open(pathbuf, fflags, (S_IRUSR | S_IWUSR) as c_int)\n-        }\n-    };\n-    if fd < (0 as c_int) {\n-        Err(format!(\"error opening {}: {}\", path.display(), os::last_os_error()))\n-    } else {\n-        Ok(fd_writer(fd, true))\n-    }\n-}\n-\n-pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: &fn(v: &[u8]) -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[n as u8,\n-              (n >> 8) as u8]),\n-      4u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8]),\n-      8u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8,\n-              (n >> 32) as u8,\n-              (n >> 40) as u8,\n-              (n >> 48) as u8,\n-              (n >> 56) as u8]),\n-      _ => {\n-\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        let mut n = n;\n-        while i > 0u {\n-            bytes.push((n & 255_u64) as u8);\n-            n >>= 8_u64;\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: &fn(v: &[u8]) -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[(n >> 8) as u8,\n-              n as u8]),\n-      4u => f(&[(n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      8u => f(&[(n >> 56) as u8,\n-              (n >> 48) as u8,\n-              (n >> 40) as u8,\n-              (n >> 32) as u8,\n-              (n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      _ => {\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        while i > 0u {\n-            let shift = ((i - 1u) * 8u) as u64;\n-            bytes.push((n >> shift) as u8);\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_from_be_bytes(data: &[u8],\n-                         start: uint,\n-                         size: uint)\n-                      -> u64 {\n-    let mut sz = size;\n-    assert!((sz <= 8u));\n-    let mut val = 0_u64;\n-    let mut pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data[pos] as u64) << ((sz * 8u) as u64);\n-        pos += 1u;\n-    }\n-    return val;\n-}\n-\n-// FIXME: #3048 combine trait+impl (or just move these to\n-// default methods on writer)\n-/// Generic utility functions defined on writers.\n-pub trait WriterUtil {\n-\n-    /// Write a single utf-8 encoded char.\n-    fn write_char(&self, ch: char);\n-\n-    /// Write every char in the given str, encoded as utf-8.\n-    fn write_str(&self, s: &str);\n-\n-    /// Write the given str, as utf-8, followed by '\\n'.\n-    fn write_line(&self, s: &str);\n-\n-    /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&self, n: int);\n-\n-    /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&self, n: uint);\n-\n-    /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&self, n: uint);\n-\n-    /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&self, n: int);\n-\n-    /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&self, n: uint);\n-\n-    /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&self, n: int);\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&self, n: u64);\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&self, n: u32);\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&self, n: u16);\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&self, n: i64);\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&self, n: i32);\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&self, n: i16);\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&self, f: f64);\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&self, f: f32);\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&self, n: u64);\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&self, n: u32);\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&self, n: u16);\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&self, n: i64);\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&self, n: i32);\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&self, n: i16);\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    fn write_le_f64(&self, f: f64);\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    fn write_le_f32(&self, f: f32);\n-\n-    /// Write a u8 (1 byte).\n-    fn write_u8(&self, n: u8);\n-\n-    /// Write a i8 (1 byte).\n-    fn write_i8(&self, n: i8);\n-}\n-\n-impl<T:Writer> WriterUtil for T {\n-    fn write_char(&self, ch: char) {\n-        if (ch as uint) < 128u {\n-            self.write(&[ch as u8]);\n-        } else {\n-            self.write_str(str::from_char(ch));\n-        }\n-    }\n-    fn write_str(&self, s: &str) { self.write(s.as_bytes()) }\n-    fn write_line(&self, s: &str) {\n-        self.write_str(s);\n-        self.write_str(&\"\\n\");\n-    }\n-    fn write_int(&self, n: int) {\n-        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-    fn write_uint(&self, n: uint) {\n-        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-    fn write_le_uint(&self, n: uint) {\n-        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-    fn write_le_int(&self, n: int) {\n-        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-    fn write_be_uint(&self, n: uint) {\n-        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-    fn write_be_int(&self, n: int) {\n-        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-    fn write_be_u64(&self, n: u64) {\n-        u64_to_be_bytes(n, 8u, |v| self.write(v))\n-    }\n-    fn write_be_u32(&self, n: u32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_be_u16(&self, n: u16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_be_i64(&self, n: i64) {\n-        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-    fn write_be_i32(&self, n: i32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_be_i16(&self, n: i16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_be_f64(&self, f:f64) {\n-        unsafe {\n-            self.write_be_u64(cast::transmute(f))\n-        }\n-    }\n-    fn write_be_f32(&self, f:f32) {\n-        unsafe {\n-            self.write_be_u32(cast::transmute(f))\n-        }\n-    }\n-    fn write_le_u64(&self, n: u64) {\n-        u64_to_le_bytes(n, 8u, |v| self.write(v))\n-    }\n-    fn write_le_u32(&self, n: u32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_le_u16(&self, n: u16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_le_i64(&self, n: i64) {\n-        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-    fn write_le_i32(&self, n: i32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_le_i16(&self, n: i16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_le_f64(&self, f:f64) {\n-        unsafe {\n-            self.write_le_u64(cast::transmute(f))\n-        }\n-    }\n-    fn write_le_f32(&self, f:f32) {\n-        unsafe {\n-            self.write_le_u32(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_u8(&self, n: u8) { self.write([n]) }\n-    fn write_i8(&self, n: i8) { self.write([n as u8]) }\n-\n-}\n-\n-pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n-    mk_file_writer(path, flags).and_then(|w| Ok(w))\n-}\n-\n-// FIXME (#2004) it would be great if this could be a const\n-// FIXME (#2004) why are these different from the way stdin() is\n-// implemented?\n-\n-\n-/**\n-* Gives a `Writer` which allows you to write to the standard output.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stdout = std::io::stdout();\n-* stdout.write_str(\"hello\\n\");\n-* ```\n-*/\n-pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-\n-/**\n-* Gives a `Writer` which allows you to write to standard error.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stderr = std::io::stderr();\n-* stderr.write_str(\"hello\\n\");\n-* ```\n-*/\n-pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n-\n-/**\n-* Prints a string to standard output.\n-*\n-* This string will not have an implicit newline at the end. If you want\n-* an implicit newline, please see `println`.\n-*\n-* # Example\n-*\n-* ```rust\n-* // print is imported into the prelude, and so is always available.\n-* print(\"hello\");\n-* ```\n-*/\n-pub fn print(s: &str) {\n-    stdout().write_str(s);\n-}\n-\n-/**\n-* Prints a string to standard output, followed by a newline.\n-*\n-* If you do not want an implicit newline, please see `print`.\n-*\n-* # Example\n-*\n-* ```rust\n-* // println is imported into the prelude, and so is always available.\n-* println(\"hello\");\n-* ```\n-*/\n-pub fn println(s: &str) {\n-    stdout().write_line(s);\n-}\n-\n-pub struct BytesWriter {\n-    bytes: @mut ~[u8],\n-    pos: @mut uint,\n-}\n-\n-impl BytesWriter {\n-    pub fn new() -> BytesWriter {\n-        BytesWriter {\n-            bytes: @mut ~[],\n-            pos: @mut 0\n-        }\n-    }\n-}\n-\n-impl Writer for BytesWriter {\n-    fn write(&self, v: &[u8]) {\n-        let v_len = v.len();\n-\n-        let bytes = &mut *self.bytes;\n-        let count = num::max(bytes.len(), *self.pos + v_len);\n-        bytes.reserve(count);\n-\n-        unsafe {\n-            vec::raw::set_len(bytes, count);\n-\n-            let view = bytes.mut_slice(*self.pos, count);\n-            vec::bytes::copy_memory(view, v, v_len);\n-        }\n-\n-        *self.pos += v_len;\n-    }\n-\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = *self.pos;\n-        let len = self.bytes.len();\n-        *self.pos = seek_in_buf(offset, pos, len, whence);\n-    }\n-\n-    fn tell(&self) -> uint {\n-        *self.pos\n-    }\n-\n-    fn flush(&self) -> int {\n-        0\n-    }\n-\n-    fn get_type(&self) -> WriterType {\n-        File\n-    }\n-}\n-\n-pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n-    let wr = @BytesWriter::new();\n-    f(wr as @Writer);\n-    let @BytesWriter { bytes, _ } = wr;\n-    (*bytes).clone()\n-}\n-\n-pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n-    str::from_utf8(with_bytes_writer(f))\n-}\n-\n-// Utility functions\n-pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n-   uint {\n-    let mut bpos = pos as int;\n-    let blen = len as int;\n-    match whence {\n-      SeekSet => bpos = offset,\n-      SeekCur => bpos += offset,\n-      SeekEnd => bpos = blen + offset\n-    }\n-    if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n-    return bpos as uint;\n-}\n-\n-pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    do read_whole_file(file).and_then |bytes| {\n-        if str::is_utf8(bytes) {\n-            Ok(str::from_utf8(bytes))\n-        } else {\n-            Err(file.display().to_str() + \" is not UTF-8\")\n-        }\n-    }\n-}\n-\n-// FIXME (#2004): implement this in a low-level way. Going through the\n-// abstractions is pointless.\n-pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    do file_reader(file).and_then |rdr| {\n-        Ok(rdr.read_whole_stream())\n-    }\n-}\n-\n-// fsync related\n-\n-pub mod fsync {\n-    use io::{FILERes, FdRes, fd_t};\n-    use libc;\n-    use ops::Drop;\n-    use option::{None, Option, Some};\n-    use os;\n-\n-    pub enum Level {\n-        // whatever fsync does on that platform\n-        FSync,\n-\n-        // fdatasync on linux, similiar or more on other platforms\n-        FDataSync,\n-\n-        // full fsync\n-        //\n-        // You must additionally sync the parent directory as well!\n-        FullFSync,\n-    }\n-\n-\n-    // Artifacts that need to fsync on destruction\n-    pub struct Res<t> {\n-        priv arg: Arg<t>,\n-    }\n-\n-    impl <t> Res<t> {\n-        pub fn new(arg: Arg<t>) -> Res<t> {\n-            Res { arg: arg }\n-        }\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<T> Drop for Res<T> {\n-        fn drop(&mut self) {\n-            match self.arg.opt_level {\n-                None => (),\n-                Some(level) => {\n-                  // fail hard if not succesful\n-                  assert!(((self.arg.fsync_fn)(&self.arg.val, level) != -1));\n-                }\n-            }\n-        }\n-    }\n-\n-    pub struct Arg<t> {\n-        priv val: t,\n-        priv opt_level: Option<Level>,\n-        priv fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n-    }\n-\n-    // fsync file after executing blk\n-    // FIXME (#2004) find better way to create resources within lifetime of\n-    // outer res\n-    pub fn FILE_res_sync(file: &FILERes,\n-                         opt_level: Option<Level>,\n-                         blk: &fn(v: Res<*libc::FILE>)) {\n-        blk(Res::new(Arg {\n-            val: file.f,\n-            opt_level: opt_level,\n-            fsync_fn: fsync_FILE,\n-        }));\n-\n-        fn fileno(stream: *libc::FILE) -> libc::c_int {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe { libc::fileno(stream) }\n-        }\n-\n-        fn fsync_FILE(stream: &*libc::FILE, level: Level) -> int {\n-            fsync_fd(fileno(*stream), level)\n-        }\n-    }\n-\n-    // fsync fd after executing blk\n-    pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                       blk: &fn(v: Res<fd_t>)) {\n-        blk(Res::new(Arg {\n-            val: fd.fd,\n-            opt_level: opt_level,\n-            fsync_fn: fsync_fd_helper,\n-        }));\n-    }\n-\n-    fn fsync_fd(fd: libc::c_int, level: Level) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        os::fsync_fd(fd, level) as int\n-    }\n-\n-    fn fsync_fd_helper(fd_ptr: &libc::c_int, level: Level) -> int {\n-        fsync_fd(*fd_ptr, level)\n-    }\n-\n-    // Type of objects that may want to fsync\n-    pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n-\n-    // Call o.fsync after executing blk\n-    pub fn obj_sync(o: @FSyncable, opt_level: Option<Level>,\n-                    blk: &fn(v: Res<@FSyncable>)) {\n-        blk(Res::new(Arg {\n-            val: o,\n-            opt_level: opt_level,\n-            fsync_fn: obj_fsync_fn,\n-        }));\n-    }\n-\n-    fn obj_fsync_fn(o: &@FSyncable, level: Level) -> int {\n-        (*o).fsync(level)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use i32;\n-    use io::{BytesWriter, SeekCur, SeekEnd, SeekSet};\n-    use io;\n-    use path::Path;\n-    use result::{Ok, Err};\n-    use u64;\n-    use vec;\n-    use cast::transmute;\n-\n-    #[test]\n-    fn test_simple() {\n-        let tmpfile = &Path::new(\"tmp/lib-io-test-simple.tmp\");\n-        debug!(\"{}\", tmpfile.display());\n-        let frood: ~str =\n-            ~\"A hoopy frood who really knows where his towel is.\";\n-        debug!(\"{}\", frood.clone());\n-        {\n-            let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n-            out.write_str(frood);\n-        }\n-        let inp = io::file_reader(tmpfile).unwrap();\n-        let frood2: ~str = inp.read_c_str();\n-        debug!(\"{}\", frood2.clone());\n-        assert_eq!(frood, frood2);\n-    }\n-\n-    #[test]\n-    fn test_each_byte_each_char_file() {\n-        // Issue #5056 -- shouldn't include trailing EOF.\n-        let path = Path::new(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n-\n-        {\n-            // create empty, enough to reproduce a problem\n-            io::file_writer(&path, [io::Create]).unwrap();\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            do file.each_byte() |_| {\n-                fail!(\"must be empty\")\n-            };\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            do file.each_char() |_| {\n-                fail!(\"must be empty\")\n-            };\n-        }\n-    }\n-\n-    #[test]\n-    fn test_readchars_empty() {\n-        do io::with_str_reader(\"\") |inp| {\n-            let res : ~[char] = inp.read_chars(128);\n-            assert_eq!(res.len(), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_line_utf8() {\n-        do io::with_str_reader(\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n-            let line = inp.read_line();\n-            assert_eq!(line, ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_lines() {\n-        do io::with_str_reader(\"a\\nb\\nc\\n\") |inp| {\n-            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n-        }\n-\n-        do io::with_str_reader(\"a\\nb\\nc\") |inp| {\n-            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n-        }\n-\n-        do io::with_str_reader(\"\") |inp| {\n-            assert!(inp.read_lines().is_empty());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_readchars_wide() {\n-        let wide_test = ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n-        let ivals : ~[int] = ~[\n-            29983, 38152, 30340, 27748,\n-            21273, 20999, 32905, 27748,\n-            104, 101, 108, 108, 111,\n-            29983, 38152, 30340, 27748,\n-            21273, 20999, 32905, 27748];\n-        fn check_read_ln(len : uint, s: &str, ivals: &[int]) {\n-            do io::with_str_reader(s) |inp| {\n-                let res : ~[char] = inp.read_chars(len);\n-                if len <= ivals.len() {\n-                    assert_eq!(res.len(), len);\n-                }\n-                for (iv, c) in ivals.iter().zip(res.iter()) {\n-                    assert!(*iv == *c as int)\n-                }\n-            }\n-        }\n-        let mut i = 0;\n-        while i < 8 {\n-            check_read_ln(i, wide_test, ivals);\n-            i += 1;\n-        }\n-        // check a long read for good measure\n-        check_read_ln(128, wide_test, ivals);\n-    }\n-\n-    #[test]\n-    fn test_readchar() {\n-        do io::with_str_reader(\"\u751f\") |inp| {\n-            let res = inp.read_char();\n-            assert_eq!(res as int, 29983);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_readchar_empty() {\n-        do io::with_str_reader(\"\") |inp| {\n-            let res = inp.read_char();\n-            assert_eq!(res, unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n-        }\n-    }\n-\n-    #[test]\n-    fn file_reader_not_exist() {\n-        match io::file_reader(&Path::new(\"not a file\")) {\n-          Err(e) => {\n-            assert_eq!(e, ~\"error opening not a file\");\n-          }\n-          Ok(_) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_read_buffer_too_small() {\n-        let path = &Path::new(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n-        // ensure the file exists\n-        io::file_writer(path, [io::Create]).unwrap();\n-\n-        let file = io::file_reader(path).unwrap();\n-        let mut buf = vec::from_elem(5, 0u8);\n-        file.read(buf, 6); // this should fail because buf is too small\n-    }\n-\n-    #[test]\n-    fn test_read_buffer_big_enough() {\n-        let path = &Path::new(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n-        // ensure the file exists\n-        io::file_writer(path, [io::Create]).unwrap();\n-\n-        let file = io::file_reader(path).unwrap();\n-        let mut buf = vec::from_elem(5, 0u8);\n-        file.read(buf, 4); // this should succeed because buf is big enough\n-    }\n-\n-    #[test]\n-    fn test_write_empty() {\n-        let file = io::file_writer(&Path::new(\"tmp/lib-io-test-write-empty.tmp\"),\n-                                   [io::Create]).unwrap();\n-        file.write([]);\n-    }\n-\n-    #[test]\n-    fn file_writer_bad_name() {\n-        match io::file_writer(&Path::new(\"?/?\"), []) {\n-          Err(e) => {\n-            assert!(e.starts_with(\"error opening\"));\n-          }\n-          Ok(_) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn bytes_buffer_overwrite() {\n-        let wr = BytesWriter::new();\n-        wr.write([0u8, 1u8, 2u8, 3u8]);\n-        assert!(*wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n-        wr.seek(-2, SeekCur);\n-        wr.write([4u8, 5u8, 6u8, 7u8]);\n-        assert!(*wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n-        wr.seek(-2, SeekEnd);\n-        wr.write([8u8]);\n-        wr.seek(1, SeekSet);\n-        wr.write([9u8]);\n-        assert!(*wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n-    }\n-\n-    #[test]\n-    fn test_read_write_le() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-le.tmp\");\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in uints.iter() {\n-                file.write_le_u64(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in uints.iter() {\n-                assert_eq!(file.read_le_u64(), *i);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_write_be() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-be.tmp\");\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in uints.iter() {\n-                file.write_be_u64(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in uints.iter() {\n-                assert_eq!(file.read_be_u64(), *i);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_be_int_n() {\n-        let path = Path::new(\"tmp/lib-io-test-read-be-int-n.tmp\");\n-        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in ints.iter() {\n-                file.write_be_i32(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in ints.iter() {\n-                // this tests that the sign extension is working\n-                // (comparing the values as i32 would not test this)\n-                assert_eq!(file.read_be_int_n(4), *i as i64);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_f32() {\n-        let path = Path::new(\"tmp/lib-io-test-read-f32.tmp\");\n-        //big-endian floating-point 8.1250\n-        let buf = ~[0x41, 0x02, 0x00, 0x00];\n-\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            file.write(buf);\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            let f = file.read_be_f32();\n-            assert_eq!(f, 8.1250);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_write_f32() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-f32.tmp\");\n-        let f:f32 = 8.1250;\n-\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            file.write_be_f32(f);\n-            file.write_le_f32(f);\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            assert_eq!(file.read_be_f32(), 8.1250);\n-            assert_eq!(file.read_le_f32(), 8.1250);\n-        }\n-    }\n-}"}, {"sha": "35a3ca3cff05d7572794903d18c20717596199c1", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -112,7 +112,7 @@ pub fn log(_level: u32, args: &fmt::Arguments) {\n             }\n             None => {\n                 // There is no logger anywhere, just write to stderr\n-                let mut logger = StdErrLogger;\n+                let mut logger = StdErrLogger::new();\n                 logger.log(args);\n             }\n         }"}, {"sha": "1f32c6a0a35efd97c2caa117bc45dc4a2375c2d3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -32,7 +32,6 @@\n use c_str::CString;\n use clone::Clone;\n use container::Container;\n-use io;\n use iter::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n@@ -62,7 +61,7 @@ pub fn close(fd: c_int) -> c_int {\n // which are for Windows and for non-Windows, if necessary.\n // See https://github.com/mozilla/rust/issues/9822 for more information.\n \n-pub mod rustrt {\n+mod rustrt {\n     use libc::{c_char, c_int};\n     use libc;\n \n@@ -190,6 +189,8 @@ pub fn env() -> ~[(~str,~str)] {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n             #[fixed_stack_segment]; #[inline(never)];\n+            use c_str;\n+            use str::StrSlice;\n \n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsA,\n@@ -200,7 +201,10 @@ pub fn env() -> ~[(~str,~str)] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let result = str::raw::from_c_multistring(ch as *libc::c_char, None);\n+            let mut result = ~[];\n+            do c_str::from_c_multistring(ch as *libc::c_char, None) |cstr| {\n+                result.push(cstr.as_str().unwrap().to_owned());\n+            };\n             FreeEnvironmentStringsA(ch);\n             result\n         }\n@@ -353,64 +357,6 @@ pub fn fdopen(fd: c_int) -> *FILE {\n     }\n }\n \n-\n-// fsync related\n-\n-#[cfg(windows)]\n-pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        use libc::funcs::extra::msvcrt::*;\n-        return commit(fd);\n-    }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        use libc::funcs::posix01::unistd::*;\n-        match level {\n-          io::fsync::FSync\n-          | io::fsync::FullFSync => return fsync(fd),\n-          io::fsync::FDataSync => return fdatasync(fd)\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        use libc::consts::os::extra::*;\n-        use libc::funcs::posix88::fcntl::*;\n-        use libc::funcs::posix01::unistd::*;\n-        match level {\n-          io::fsync::FSync => return fsync(fd),\n-          _ => {\n-            // According to man fnctl, the ok retval is only specified to be\n-            // !=-1\n-            if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n-                { return -1 as c_int; }\n-            else\n-                { return 0 as c_int; }\n-          }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        use libc::funcs::posix01::unistd::*;\n-        return fsync(fd);\n-    }\n-}\n-\n pub struct Pipe {\n     input: c_int,\n     out: c_int"}, {"sha": "bb8e6674b464b15d387a69a9d0d5878d8ddd57e3", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -53,7 +53,6 @@ pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use default::Default;\n pub use from_str::FromStr;\n pub use hash::Hash;\n-pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, ClonableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};"}, {"sha": "4b16f0bc0e1833681ff1f88b4c04726e6ac5fad3", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 101, "deletions": 20, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,11 +18,10 @@ use int;\n use iter::Iterator;\n use vec;\n use rt::io::{Reader, Writer, Decorator};\n-use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n+use rt::io::{io_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n use cast;\n-use io::{u64_to_le_bytes, u64_to_be_bytes};\n \n pub trait ReaderUtil {\n \n@@ -41,17 +40,17 @@ pub trait ReaderUtil {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the same conditions as `read`. Additionally raises `read_error`\n-    /// on EOF. If `read_error` is handled then `push_bytes` may push less\n+    /// Raises the same conditions as `read`. Additionally raises `io_error`\n+    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n     /// than the requested number of bytes.\n     fn push_bytes(&mut self, buf: &mut ~[u8], len: uint);\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`\n     ///\n     /// # Failure\n     ///\n-    /// Raises the same conditions as `read`. Additionally raises `read_error`\n-    /// on EOF. If `read_error` is handled then the returned vector may\n+    /// Raises the same conditions as `read`. Additionally raises `io_error`\n+    /// on EOF. If `io_error` is handled then the returned vector may\n     /// contain less than the requested number of bytes.\n     fn read_bytes(&mut self, len: uint) -> ~[u8];\n \n@@ -314,7 +313,7 @@ impl<T: Reader> ReaderUtil for T {\n                             total_read += nread;\n                         }\n                         None => {\n-                            read_error::cond.raise(standard_error(EndOfFile));\n+                            io_error::cond.raise(standard_error(EndOfFile));\n                             break;\n                         }\n                     }\n@@ -334,11 +333,11 @@ impl<T: Reader> ReaderUtil for T {\n     fn read_to_end(&mut self) -> ~[u8] {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         let mut keep_reading = true;\n-        do read_error::cond.trap(|e| {\n+        do io_error::cond.trap(|e| {\n             if e.kind == EndOfFile {\n                 keep_reading = false;\n             } else {\n-                read_error::cond.raise(e)\n+                io_error::cond.raise(e)\n             }\n         }).inside {\n             while keep_reading {\n@@ -634,14 +633,96 @@ fn extend_sign(val: u64, nbytes: uint) -> i64 {\n     (val << shift) as i64 >> shift\n }\n \n+pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n+                          f: &fn(v: &[u8]) -> T) -> T {\n+    assert!(size <= 8u);\n+    match size {\n+      1u => f(&[n as u8]),\n+      2u => f(&[n as u8,\n+              (n >> 8) as u8]),\n+      4u => f(&[n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8]),\n+      8u => f(&[n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8,\n+              (n >> 32) as u8,\n+              (n >> 40) as u8,\n+              (n >> 48) as u8,\n+              (n >> 56) as u8]),\n+      _ => {\n+\n+        let mut bytes: ~[u8] = ~[];\n+        let mut i = size;\n+        let mut n = n;\n+        while i > 0u {\n+            bytes.push((n & 255_u64) as u8);\n+            n >>= 8_u64;\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n+    }\n+}\n+\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n+                           f: &fn(v: &[u8]) -> T) -> T {\n+    assert!(size <= 8u);\n+    match size {\n+      1u => f(&[n as u8]),\n+      2u => f(&[(n >> 8) as u8,\n+              n as u8]),\n+      4u => f(&[(n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]),\n+      8u => f(&[(n >> 56) as u8,\n+              (n >> 48) as u8,\n+              (n >> 40) as u8,\n+              (n >> 32) as u8,\n+              (n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]),\n+      _ => {\n+        let mut bytes: ~[u8] = ~[];\n+        let mut i = size;\n+        while i > 0u {\n+            let shift = ((i - 1u) * 8u) as u64;\n+            bytes.push((n >> shift) as u8);\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n+    }\n+}\n+\n+pub fn u64_from_be_bytes(data: &[u8],\n+                         start: uint,\n+                         size: uint)\n+                      -> u64 {\n+    let mut sz = size;\n+    assert!((sz <= 8u));\n+    let mut val = 0_u64;\n+    let mut pos = start;\n+    while sz > 0u {\n+        sz -= 1u;\n+        val += (data[pos] as u64) << ((sz * 8u) as u64);\n+        pos += 1u;\n+    }\n+    return val;\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::ReaderUtil;\n     use option::{Some, None};\n     use cell::Cell;\n     use rt::io::mem::{MemReader, MemWriter};\n     use rt::io::mock::MockReader;\n-    use rt::io::{read_error, placeholder_error};\n+    use rt::io::{io_error, placeholder_error};\n \n     #[test]\n     fn read_byte() {\n@@ -681,10 +762,10 @@ mod test {\n     fn read_byte_error() {\n         let mut reader = MockReader::new();\n         reader.read = |_| {\n-            read_error::cond.raise(placeholder_error());\n+            io_error::cond.raise(placeholder_error());\n             None\n         };\n-        do read_error::cond.trap(|_| {\n+        do io_error::cond.trap(|_| {\n         }).inside {\n             let byte = reader.read_byte();\n             assert!(byte == None);\n@@ -722,11 +803,11 @@ mod test {\n     fn bytes_error() {\n         let mut reader = MockReader::new();\n         reader.read = |_| {\n-            read_error::cond.raise(placeholder_error());\n+            io_error::cond.raise(placeholder_error());\n             None\n         };\n         let mut it = reader.bytes();\n-        do read_error::cond.trap(|_| ()).inside {\n+        do io_error::cond.trap(|_| ()).inside {\n             let byte = it.next();\n             assert!(byte == None);\n         }\n@@ -765,7 +846,7 @@ mod test {\n     #[test]\n     fn read_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n-        do read_error::cond.trap(|_| {\n+        do io_error::cond.trap(|_| {\n         }).inside {\n             assert!(reader.read_bytes(4) == ~[10, 11]);\n         }\n@@ -806,7 +887,7 @@ mod test {\n     fn push_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n         let mut buf = ~[8, 9];\n-        do read_error::cond.trap(|_| {\n+        do io_error::cond.trap(|_| {\n         }).inside {\n             reader.push_bytes(&mut buf, 4);\n             assert!(buf == ~[8, 9, 10, 11]);\n@@ -824,13 +905,13 @@ mod test {\n                     buf[0] = 10;\n                     Some(1)\n                 } else {\n-                    read_error::cond.raise(placeholder_error());\n+                    io_error::cond.raise(placeholder_error());\n                     None\n                 }\n             }\n         };\n         let mut buf = ~[8, 9];\n-        do read_error::cond.trap(|_| { } ).inside {\n+        do io_error::cond.trap(|_| { } ).inside {\n             reader.push_bytes(&mut buf, 4);\n         }\n         assert!(buf == ~[8, 9, 10]);\n@@ -850,7 +931,7 @@ mod test {\n                     buf[0] = 10;\n                     Some(1)\n                 } else {\n-                    read_error::cond.raise(placeholder_error());\n+                    io_error::cond.raise(placeholder_error());\n                     None\n                 }\n             }\n@@ -903,7 +984,7 @@ mod test {\n                     buf[1] = 11;\n                     Some(2)\n                 } else {\n-                    read_error::cond.raise(placeholder_error());\n+                    io_error::cond.raise(placeholder_error());\n                     None\n                 }\n             }"}, {"sha": "d035e2f457cc2b940f10f377d91b58eb64e6e209", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 69, "deletions": 88, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -15,10 +15,11 @@ with regular files & directories on a filesystem.\n \n At the top-level of the module are a set of freestanding functions,\n associated with various filesystem operations. They all operate\n-on a `PathLike` object.\n+on a `ToCStr` object. This trait is already defined for common\n+objects such as strings and `Path` instances.\n \n All operations in this module, including those as part of `FileStream` et al\n-block the task during execution. Most will raise `std::rt::io::{io_error,read_error}`\n+block the task during execution. Most will raise `std::rt::io::io_error`\n conditions in the event of failure.\n \n Also included in this module are the `FileInfo` and `DirectoryInfo` traits. When\n@@ -30,15 +31,14 @@ free function counterparts.\n */\n \n use prelude::*;\n-use super::support::PathLike;\n+use c_str::ToCStr;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write};\n-use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n-use rt::io::{io_error, read_error, EndOfFile,\n+use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n+use rt::io::{io_error, EndOfFile,\n             FileMode, FileAccess, FileStat, IoError,\n             PathAlreadyExists, PathDoesntExist,\n             MismatchedFileTypeForOperation, ignore_io_error};\n-use rt::local::Local;\n use option::{Some, None};\n use path::Path;\n \n@@ -48,7 +48,6 @@ use path::Path;\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::open;\n ///     use std::rt::io::{FileMode, FileAccess};\n ///\n@@ -87,22 +86,20 @@ use path::Path;\n /// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n ///   for\n /// * Filesystem-level errors (full disk, etc)\n-pub fn open<P: PathLike>(path: &P,\n-                         mode: FileMode,\n-                         access: FileAccess\n-                        ) -> Option<FileStream> {\n-    let open_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_open(path, mode, access)\n-    };\n-    match open_result {\n-        Ok(fd) => Some(FileStream {\n-            fd: fd,\n-            last_nread: -1\n-        }),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+pub fn open<P: ToCStr>(path: &P,\n+                       mode: FileMode,\n+                       access: FileAccess\n+                      ) -> Option<FileStream> {\n+    do with_local_io |io| {\n+        match io.fs_open(&path.to_c_str(), mode, access) {\n+            Ok(fd) => Some(FileStream {\n+                fd: fd,\n+                last_nread: -1\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }\n@@ -113,7 +110,6 @@ pub fn open<P: PathLike>(path: &P,\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::unlink;\n ///\n ///     let p = &Path(\"/some/file/path.txt\");\n@@ -129,17 +125,16 @@ pub fn open<P: PathLike>(path: &P,\n ///\n /// This function will raise an `io_error` condition if the user lacks permissions to\n /// remove the file or if some other filesystem-level error occurs\n-pub fn unlink<P: PathLike>(path: &P) {\n-    let unlink_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_unlink(path)\n-    };\n-    match unlink_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+pub fn unlink<P: ToCStr>(path: &P) {\n+    do with_local_io |io| {\n+        match io.fs_unlink(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Create a new, empty directory at the provided path\n@@ -148,7 +143,6 @@ pub fn unlink<P: PathLike>(path: &P) {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::mkdir;\n ///\n ///     let p = &Path(\"/some/dir\");\n@@ -159,17 +153,16 @@ pub fn unlink<P: PathLike>(path: &P) {\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions to make a\n /// new directory at the provided path, or if the directory already exists\n-pub fn mkdir<P: PathLike>(path: &P) {\n-    let mkdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_mkdir(path)\n-    };\n-    match mkdir_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+pub fn mkdir<P: ToCStr>(path: &P) {\n+    do with_local_io |io| {\n+        match io.fs_mkdir(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Remove an existing, empty directory\n@@ -178,7 +171,6 @@ pub fn mkdir<P: PathLike>(path: &P) {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::rmdir;\n ///\n ///     let p = &Path(\"/some/dir\");\n@@ -189,31 +181,29 @@ pub fn mkdir<P: PathLike>(path: &P) {\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty\n-pub fn rmdir<P: PathLike>(path: &P) {\n-    let rmdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_rmdir(path)\n-    };\n-    match rmdir_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+pub fn rmdir<P: ToCStr>(path: &P) {\n+    do with_local_io |io| {\n+        match io.fs_rmdir(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Get information on the file, directory, etc at the provided path\n ///\n-/// Given a `rt::io::support::PathLike`, query the file system to get\n-/// information about a file, directory, etc.\n+/// Given a path, query the file system to get information about a file,\n+/// directory, etc.\n ///\n /// Returns a `Some(std::rt::io::PathInfo)` on success\n ///\n /// # Example\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::stat;\n ///\n ///     let p = &Path(\"/some/file/path.txt\");\n@@ -238,18 +228,14 @@ pub fn rmdir<P: PathLike>(path: &P) {\n /// This call will raise an `io_error` condition if the user lacks the requisite\n /// permissions to perform a `stat` call on the given path or if there is no\n /// entry in the filesystem at the provided path.\n-pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n-    let open_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_stat(path)\n-    };\n-    match open_result {\n-        Ok(p) => {\n-            Some(p)\n-        },\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n+    do with_local_io |io| {\n+        match io.fs_stat(&path.to_c_str()) {\n+            Ok(p) => Some(p),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }\n@@ -260,7 +246,6 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::readdir;\n ///\n ///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n@@ -279,18 +264,14 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n /// Will raise an `io_error` condition if the provided `path` doesn't exist,\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n-pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n-    let readdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_readdir(path, 0)\n-    };\n-    match readdir_result {\n-        Ok(p) => {\n-            Some(p)\n-        },\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n+    do with_local_io |io| {\n+        match io.fs_readdir(&path.to_c_str(), 0) {\n+            Ok(p) => Some(p),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }\n@@ -380,7 +361,7 @@ impl Reader for FileStream {\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n                 if ioerr.kind != EndOfFile {\n-                    read_error::cond.raise(ioerr);\n+                    io_error::cond.raise(ioerr);\n                 }\n                 return None;\n             }\n@@ -407,7 +388,7 @@ impl Writer for FileStream {\n         match self.fd.flush() {\n             Ok(_) => (),\n             Err(ioerr) => {\n-                read_error::cond.raise(ioerr);\n+                io_error::cond.raise(ioerr);\n             }\n         }\n     }\n@@ -420,7 +401,7 @@ impl Seek for FileStream {\n         match res {\n             Ok(cursor) => cursor,\n             Err(ioerr) => {\n-                read_error::cond.raise(ioerr);\n+                io_error::cond.raise(ioerr);\n                 return -1;\n             }\n         }\n@@ -434,7 +415,7 @@ impl Seek for FileStream {\n                 ()\n             },\n             Err(ioerr) => {\n-                read_error::cond.raise(ioerr);\n+                io_error::cond.raise(ioerr);\n             }\n         }\n     }"}, {"sha": "0ec37cd3c07894f46906fca2bb3e069ad2d82417", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -22,46 +22,66 @@ use vec;\n \n /// Writes to an owned, growable byte vector\n pub struct MemWriter {\n-    priv buf: ~[u8]\n+    priv buf: ~[u8],\n+    priv pos: uint,\n }\n \n impl MemWriter {\n-    pub fn new() -> MemWriter { MemWriter { buf: vec::with_capacity(128) } }\n+    pub fn new() -> MemWriter {\n+        MemWriter { buf: vec::with_capacity(128), pos: 0 }\n+    }\n }\n \n impl Writer for MemWriter {\n     fn write(&mut self, buf: &[u8]) {\n-        self.buf.push_all(buf)\n+        // Make sure the internal buffer is as least as big as where we\n+        // currently are\n+        let difference = self.pos as i64 - self.buf.len() as i64;\n+        if difference > 0 {\n+            self.buf.grow(difference as uint, &0);\n+        }\n+\n+        // Figure out what bytes will be used to overwrite what's currently\n+        // there (left), and what will be appended on the end (right)\n+        let cap = self.buf.len() - self.pos;\n+        let (left, right) = if cap <= buf.len() {\n+            (buf.slice_to(cap), buf.slice_from(cap))\n+        } else {\n+            (buf, &[])\n+        };\n+\n+        // Do the necessary writes\n+        if left.len() > 0 {\n+            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n+                                    left, left.len());\n+        }\n+        if right.len() > 0 {\n+            self.buf.push_all(right);\n+        }\n+\n+        // Bump us forward\n+        self.pos += buf.len();\n     }\n \n     fn flush(&mut self) { /* no-op */ }\n }\n \n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { self.buf.len() as u64 }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n-\n-impl Decorator<~[u8]> for MemWriter {\n-\n-    fn inner(self) -> ~[u8] {\n-        match self {\n-            MemWriter { buf: buf } => buf\n-        }\n-    }\n+    fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n-        match *self {\n-            MemWriter { buf: ref buf } => buf\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        match style {\n+            SeekSet => { self.pos = pos as uint; }\n+            SeekEnd => { self.pos = self.buf.len() + pos as uint; }\n+            SeekCur => { self.pos += pos as uint; }\n         }\n     }\n+}\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n-        match *self {\n-            MemWriter { buf: ref mut buf } => buf\n-        }\n-    }\n+impl Decorator<~[u8]> for MemWriter {\n+    fn inner(self) -> ~[u8] { self.buf }\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n }\n \n /// Reads from an owned byte vector\n@@ -208,6 +228,7 @@ pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {\n mod test {\n     use prelude::*;\n     use super::*;\n+    use rt::io::*;\n \n     #[test]\n     fn test_mem_writer() {\n@@ -218,7 +239,24 @@ mod test {\n         writer.write([1, 2, 3]);\n         writer.write([4, 5, 6, 7]);\n         assert_eq!(writer.tell(), 8);\n-        assert_eq!(writer.inner(), ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n+        assert_eq!(*writer.inner_ref(), ~[0, 1, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(0, SeekSet);\n+        assert_eq!(writer.tell(), 0);\n+        writer.write([3, 4]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(1, SeekCur);\n+        writer.write([0, 1]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 7]);\n+\n+        writer.seek(-1, SeekEnd);\n+        writer.write([1, 2]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+\n+        writer.seek(1, SeekEnd);\n+        writer.write([1]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n     #[test]"}, {"sha": "758c97791658f878094960a97298377f34bdd999", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -261,7 +261,6 @@ pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n-pub use self::pipe::UnboundPipeStream;\n pub use self::process::Process;\n \n // Some extension traits that all Readers and Writers get.\n@@ -299,10 +298,6 @@ pub mod comm_adapters;\n /// Extension traits\n pub mod extensions;\n \n-/// Non-I/O things needed by the I/O module\n-// XXX: shouldn this really be pub?\n-pub mod support;\n-\n /// Basic Timer\n pub mod timer;\n \n@@ -331,9 +326,11 @@ pub mod native {\n /// Mock implementations for testing\n mod mock;\n \n+/// Signal handling\n+pub mod signal;\n+\n /// The default buffer size for various I/O operations\n-/// XXX: Not pub\n-pub static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n+static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n /// The type passed to I/O condition handlers to indicate error\n ///\n@@ -375,7 +372,9 @@ pub enum IoErrorKind {\n     BrokenPipe,\n     PathAlreadyExists,\n     PathDoesntExist,\n-    MismatchedFileTypeForOperation\n+    MismatchedFileTypeForOperation,\n+    ResourceUnavailable,\n+    IoUnavailable,\n }\n \n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n@@ -395,7 +394,9 @@ impl ToStr for IoErrorKind {\n             BrokenPipe => ~\"BrokenPipe\",\n             PathAlreadyExists => ~\"PathAlreadyExists\",\n             PathDoesntExist => ~\"PathDoesntExist\",\n-            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\"\n+            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\",\n+            IoUnavailable => ~\"IoUnavailable\",\n+            ResourceUnavailable => ~\"ResourceUnavailable\",\n         }\n     }\n }\n@@ -406,12 +407,6 @@ condition! {\n     pub io_error: IoError -> ();\n }\n \n-// XXX: Can't put doc comments on macros\n-// Raised by `read` on error\n-condition! {\n-    pub read_error: IoError -> ();\n-}\n-\n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n@@ -431,7 +426,7 @@ pub trait Reader {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `read_error` condition on error. If the condition\n+    /// Raises the `io_error` condition on error. If the condition\n     /// is handled then no guarantee is made about the number of bytes\n     /// read and the contents of `buf`. If the condition is handled\n     /// returns `None` (XXX see below)."}, {"sha": "ba819df071a97d5e37862fd8b5124ad113b039ef", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -17,13 +17,31 @@ use os;\n use prelude::*;\n use super::super::*;\n \n-fn raise_error() {\n+#[cfg(windows)]\n+fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+    match errno {\n+        libc::EOF => (EndOfFile, \"end of file\"),\n+        _ => (OtherIoError, \"unknown error\"),\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n     // XXX: this should probably be a bit more descriptive...\n-    let (kind, desc) = match os::errno() as i32 {\n+    match errno {\n         libc::EOF => (EndOfFile, \"end of file\"),\n+\n+        // These two constants can have the same value on some systems, but\n+        // different values on others, so we can't use a match clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            (ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n         _ => (OtherIoError, \"unknown error\"),\n-    };\n+    }\n+}\n \n+fn raise_error() {\n+    let (kind, desc) = get_err(os::errno() as i32);\n     io_error::cond.raise(IoError {\n         kind: kind,\n         desc: desc,"}, {"sha": "27cf9781c9c3cda643d001843693a26488c42443", "filename": "src/libstd/rt/io/net/addrinfo.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Synchronous DNS Resolution\n+\n+Contains the functionality to perform DNS resolution in a style related to\n+getaddrinfo()\n+\n+*/\n+\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::io::{io_error};\n+use rt::io::net::ip::{SocketAddr, IpAddr};\n+use rt::rtio::{IoFactory, with_local_io};\n+\n+/// Hints to the types of sockets that are desired when looking up hosts\n+pub enum SocketType {\n+    Stream, Datagram, Raw\n+}\n+\n+/// Flags which can be or'd into the `flags` field of a `Hint`. These are used\n+/// to manipulate how a query is performed.\n+///\n+/// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n+pub enum Flag {\n+    AddrConfig,\n+    All,\n+    CanonName,\n+    NumericHost,\n+    NumericServ,\n+    Passive,\n+    V4Mapped,\n+}\n+\n+/// A transport protocol associated with either a hint or a return value of\n+/// `lookup`\n+pub enum Protocol {\n+    TCP, UDP\n+}\n+\n+/// This structure is used to provide hints when fetching addresses for a\n+/// remote host to control how the lookup is performed.\n+///\n+/// For details on these fields, see their corresponding definitions via\n+/// `man -s 3 getaddrinfo`\n+pub struct Hint {\n+    family: uint,\n+    socktype: Option<SocketType>,\n+    protocol: Option<Protocol>,\n+    flags: uint,\n+}\n+\n+pub struct Info {\n+    address: SocketAddr,\n+    family: uint,\n+    socktype: Option<SocketType>,\n+    protocol: Option<Protocol>,\n+    flags: uint,\n+}\n+\n+/// Easy name resolution. Given a hostname, returns the list of IP addresses for\n+/// that hostname.\n+///\n+/// # Failure\n+///\n+/// On failure, this will raise on the `io_error` condition.\n+pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+    lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n+}\n+\n+/// Full-fleged resolution. This function will perform a synchronous call to\n+/// getaddrinfo, controlled by the parameters\n+///\n+/// # Arguments\n+///\n+/// * hostname - an optional hostname to lookup against\n+/// * servname - an optional service name, listed in the system services\n+/// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n+///          controls lookup\n+///\n+/// # Failure\n+///\n+/// On failure, this will raise on the `io_error` condition.\n+///\n+/// XXX: this is not public because the `Hint` structure is not ready for public\n+///      consumption just yet.\n+fn lookup(hostname: Option<&str>, servname: Option<&str>,\n+          hint: Option<Hint>) -> Option<~[Info]> {\n+    do with_local_io |io| {\n+        match io.get_host_addresses(hostname, servname, hint) {\n+            Ok(i) => Some(i),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::Some;\n+    use rt::io::net::ip::Ipv4Addr;\n+    use super::*;\n+\n+    #[test]\n+    fn dns_smoke_test() {\n+        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n+        let mut found_local = false;\n+        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n+        for addr in ipaddrs.iter() {\n+            found_local = found_local || addr == local_addr;\n+        }\n+        assert!(found_local);\n+    }\n+}"}, {"sha": "cf109167089d40ca6581ce6bdade64927d65dfc0", "filename": "src/libstd/rt/io/net/mod.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,55 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use rt::io::io_error;\n-use rt::io::net::ip::IpAddr;\n-use rt::rtio::{IoFactory, IoFactoryObject};\n-use rt::local::Local;\n+pub use self::addrinfo::get_host_addresses;\n \n+pub mod addrinfo;\n pub mod tcp;\n pub mod udp;\n pub mod ip;\n #[cfg(unix)]\n pub mod unix;\n-\n-/// Simplistic name resolution\n-pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n-    /*!\n-     * Get the IP addresses for a given host name.\n-     *\n-     * Raises io_error on failure.\n-     */\n-\n-    let ipaddrs = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).get_host_addresses(host)\n-    };\n-\n-    match ipaddrs {\n-        Ok(i) => Some(i),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use option::Some;\n-    use rt::io::net::ip::Ipv4Addr;\n-    use super::*;\n-\n-    #[test]\n-    fn dns_smoke_test() {\n-        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n-        let mut found_local = false;\n-        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in ipaddrs.iter() {\n-            found_local = found_local || addr == local_addr;\n-        }\n-        assert!(found_local);\n-    }\n-}"}, {"sha": "4e841b36a5d3739d22578cb7077a6a09c845450a", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,37 +12,27 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer, Listener, Acceptor};\n-use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioSocket,\n-               RtioTcpListener, RtioTcpListenerObject,\n-               RtioTcpAcceptor, RtioTcpAcceptorObject,\n-               RtioTcpStream, RtioTcpStreamObject};\n-use rt::local::Local;\n+use rt::io::{io_error, EndOfFile};\n+use rt::rtio::{IoFactory, with_local_io,\n+               RtioSocket, RtioTcpListener, RtioTcpAcceptor, RtioTcpStream};\n \n pub struct TcpStream {\n-    priv obj: ~RtioTcpStreamObject\n+    priv obj: ~RtioTcpStream\n }\n \n impl TcpStream {\n-    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n+    fn new(s: ~RtioTcpStream) -> TcpStream {\n         TcpStream { obj: s }\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        let stream = unsafe {\n-            rtdebug!(\"borrowing io to connect\");\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            rtdebug!(\"about to connect\");\n-            (*io).tcp_connect(addr)\n-        };\n-\n-        match stream {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                rtdebug!(\"failed to connect: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.tcp_connect(addr) {\n+                Ok(s) => Some(TcpStream::new(s)),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }\n@@ -77,7 +67,7 @@ impl Reader for TcpStream {\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n                 if ioerr.kind != EndOfFile {\n-                    read_error::cond.raise(ioerr);\n+                    io_error::cond.raise(ioerr);\n                 }\n                 return None;\n             }\n@@ -99,20 +89,18 @@ impl Writer for TcpStream {\n }\n \n pub struct TcpListener {\n-    priv obj: ~RtioTcpListenerObject\n+    priv obj: ~RtioTcpListener\n }\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        let listener = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).tcp_bind(addr)\n-        };\n-        match listener {\n-            Ok(l) => Some(TcpListener { obj: l }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return None;\n+        do with_local_io |io| {\n+            match io.tcp_bind(addr) {\n+                Ok(l) => Some(TcpListener { obj: l }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }\n@@ -142,7 +130,7 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n }\n \n pub struct TcpAcceptor {\n-    priv obj: ~RtioTcpAcceptorObject\n+    priv obj: ~RtioTcpAcceptor\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n@@ -320,7 +308,7 @@ mod test {\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n-                do read_error::cond.trap(|e| {\n+                do io_error::cond.trap(|e| {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {\n@@ -355,7 +343,7 @@ mod test {\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n-                do read_error::cond.trap(|e| {\n+                do io_error::cond.trap(|e| {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {"}, {"sha": "2e4ae95d98eea83f656953997d9a590cb2bb3893", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,25 +12,22 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer};\n-use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n-use rt::local::Local;\n+use rt::io::{io_error, EndOfFile};\n+use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, with_local_io};\n \n pub struct UdpSocket {\n-    priv obj: ~RtioUdpSocketObject\n+    priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let socket = unsafe {\n-            let factory: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*factory).udp_bind(addr)\n-        };\n-        match socket {\n-            Ok(s) => Some(UdpSocket { obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.udp_bind(addr) {\n+                Ok(s) => Some(UdpSocket { obj: s }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }\n@@ -41,7 +38,7 @@ impl UdpSocket {\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n                 if ioerr.kind != EndOfFile {\n-                    read_error::cond.raise(ioerr);\n+                    io_error::cond.raise(ioerr);\n                 }\n                 None\n             }"}, {"sha": "e424956e2ff6323520cbf3533d5b0a132b30e73a", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 262, "deletions": 17, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,44 +8,289 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+Named pipes\n+\n+This module contains the ability to communicate over named pipes with\n+synchronous I/O. On windows, this corresponds to talking over a Named Pipe,\n+while on Unix it corresponds to UNIX domain sockets.\n+\n+These pipes are similar to TCP in the sense that you can have both a stream to a\n+server and a server itself. The server provided accepts other `UnixStream`\n+instances as clients.\n+\n+*/\n+\n use prelude::*;\n-use super::super::*;\n-use super::super::support::PathLike;\n \n-pub struct UnixStream;\n+use c_str::ToCStr;\n+use rt::rtio::{IoFactory, RtioUnixListener, with_local_io};\n+use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n+use rt::io::pipe::PipeStream;\n+use rt::io::{io_error, Listener, Acceptor, Reader, Writer};\n+\n+/// A stream which communicates over a named pipe.\n+pub struct UnixStream {\n+    priv obj: PipeStream,\n+}\n \n impl UnixStream {\n-    pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n-        fail!()\n+    fn new(obj: ~RtioPipe) -> UnixStream {\n+        UnixStream { obj: PipeStream::new(obj) }\n+    }\n+\n+    /// Connect to a pipe named by `path`. This will attempt to open a\n+    /// connection to the underlying socket.\n+    ///\n+    /// The returned stream will be closed when the object falls out of scope.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if the connection\n+    /// could not be made.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::net::unix::UnixStream;\n+    ///\n+    ///     let server = Path(\"path/to/my/socket\");\n+    ///     let mut stream = UnixStream::connect(&server);\n+    ///     stream.write([1, 2, 3]);\n+    ///\n+    pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n+        do with_local_io |io| {\n+            match io.unix_connect(&path.to_c_str()) {\n+                Ok(s) => Some(UnixStream::new(s)),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n-\n-    fn eof(&mut self) -> bool { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.obj.read(buf) }\n+    fn eof(&mut self) -> bool { self.obj.eof() }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, _v: &[u8]) { fail!() }\n-\n-    fn flush(&mut self) { fail!() }\n+    fn write(&mut self, buf: &[u8]) { self.obj.write(buf) }\n+    fn flush(&mut self) { self.obj.flush() }\n }\n \n-pub struct UnixListener;\n+pub struct UnixListener {\n+    priv obj: ~RtioUnixListener,\n+}\n \n impl UnixListener {\n-    pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n-        fail!()\n+\n+    /// Creates a new listener, ready to receive incoming connections on the\n+    /// specified socket. The server will be named by `path`.\n+    ///\n+    /// This listener will be closed when it falls out of scope.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if the specified\n+    /// path could not be bound.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::net::unix::UnixListener;\n+    ///\n+    ///     let server = Path(\"path/to/my/socket\");\n+    ///     let mut stream = UnixListener::bind(&server);\n+    ///     for client in stream.incoming() {\n+    ///         let mut client = client;\n+    ///         client.write([1, 2, 3, 4]);\n+    ///     }\n+    ///\n+    pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n+        do with_local_io |io| {\n+            match io.unix_bind(&path.to_c_str()) {\n+                Ok(s) => Some(UnixListener{ obj: s }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> { fail!() }\n+    fn listen(self) -> Option<UnixAcceptor> {\n+        match self.obj.listen() {\n+            Ok(acceptor) => Some(UnixAcceptor { obj: acceptor }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n-pub struct UnixAcceptor;\n+pub struct UnixAcceptor {\n+    priv obj: ~RtioUnixAcceptor,\n+}\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n+    fn accept(&mut self) -> Option<UnixStream> {\n+        match self.obj.accept() {\n+            Ok(s) => Some(UnixStream::new(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::io::*;\n+    use rt::comm::oneshot;\n+    use os;\n+\n+    fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n+        let server = Cell::new(server);\n+        let client = Cell::new(client);\n+        do run_in_mt_newsched_task {\n+            let server = Cell::new(server.take());\n+            let client = Cell::new(client.take());\n+            let path1 = next_test_unix();\n+            let path2 = path1.clone();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            do spawntask {\n+                let mut acceptor = UnixListener::bind(&path1).listen();\n+                chan.take().send(());\n+                server.take()(acceptor.accept().unwrap());\n+            }\n+\n+            do spawntask {\n+                port.take().recv();\n+                client.take()(UnixStream::connect(&path2).unwrap());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn bind_error() {\n+        do run_in_mt_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).inside {\n+                let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_mt_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert_eq!(e.kind, OtherIoError);\n+                called = true;\n+            }).inside {\n+                let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        smalltest(|mut server| {\n+            let mut buf = [0];\n+            server.read(buf);\n+            assert!(buf[0] == 99);\n+        }, |mut client| {\n+            client.write([99]);\n+        })\n+    }\n+\n+    #[test]\n+    fn read_eof() {\n+        smalltest(|mut server| {\n+            let mut buf = [0];\n+            assert!(server.read(buf).is_none());\n+            assert!(server.read(buf).is_none());\n+        }, |_client| {\n+            // drop the client\n+        })\n+    }\n+\n+    #[test]\n+    fn write_begone() {\n+        smalltest(|mut server| {\n+            let buf = [0];\n+            let mut stop = false;\n+            while !stop{\n+                do io_error::cond.trap(|e| {\n+                    assert_eq!(e.kind, BrokenPipe);\n+                    stop = true;\n+                }).inside {\n+                    server.write(buf);\n+                }\n+            }\n+        }, |_client| {\n+            // drop the client\n+        })\n+    }\n+\n+    #[test]\n+    fn accept_lots() {\n+        do run_in_mt_newsched_task {\n+            let times = 10;\n+            let path1 = next_test_unix();\n+            let path2 = path1.clone();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            do spawntask {\n+                let mut acceptor = UnixListener::bind(&path1).listen();\n+                chan.take().send(());\n+                do times.times {\n+                    let mut client = acceptor.accept();\n+                    let mut buf = [0];\n+                    client.read(buf);\n+                    assert_eq!(buf[0], 100);\n+                }\n+            }\n+\n+            do spawntask {\n+                port.take().recv();\n+                do times.times {\n+                    let mut stream = UnixStream::connect(&path2);\n+                    stream.write([100]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn path_exists() {\n+        do run_in_mt_newsched_task {\n+            let path = next_test_unix();\n+            let _acceptor = UnixListener::bind(&path).listen();\n+            assert!(os::path_exists(&path));\n+        }\n+    }\n }"}, {"sha": "52699964b62418e17273570bb42ecc24956254f2", "filename": "src/libstd/rt/io/option.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Foption.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,12 +13,10 @@\n //! I/O constructors return option types to allow errors to be handled.\n //! These implementations allow e.g. `Option<FileStream>` to be used\n //! as a `Reader` without unwrapping the option first.\n-//!\n-//! # XXX Seek and Close\n \n use option::*;\n-use super::{Reader, Writer, Listener, Acceptor};\n-use super::{standard_error, PreviousIoError, io_error, read_error, IoError};\n+use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle};\n+use super::{standard_error, PreviousIoError, io_error, IoError};\n \n fn prev_io_error() -> IoError {\n     standard_error(PreviousIoError)\n@@ -45,7 +43,7 @@ impl<R: Reader> Reader for Option<R> {\n         match *self {\n             Some(ref mut reader) => reader.read(buf),\n             None => {\n-                read_error::cond.raise(prev_io_error());\n+                io_error::cond.raise(prev_io_error());\n                 None\n             }\n         }\n@@ -62,6 +60,24 @@ impl<R: Reader> Reader for Option<R> {\n     }\n }\n \n+impl<S: Seek> Seek for Option<S> {\n+    fn tell(&self) -> u64 {\n+        match *self {\n+            Some(ref seeker) => seeker.tell(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                0\n+            }\n+        }\n+    }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        match *self {\n+            Some(ref mut seeker) => seeker.seek(pos, style),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+}\n+\n impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for Option<L> {\n     fn listen(self) -> Option<A> {\n         match self {\n@@ -91,7 +107,7 @@ mod test {\n     use option::*;\n     use super::super::mem::*;\n     use rt::test::*;\n-    use super::super::{PreviousIoError, io_error, read_error};\n+    use super::super::{PreviousIoError, io_error, io_error};\n \n     #[test]\n     fn test_option_writer() {\n@@ -145,7 +161,7 @@ mod test {\n         let mut buf = [];\n \n         let mut called = false;\n-        do read_error::cond.trap(|err| {\n+        do io_error::cond.trap(|err| {\n             assert_eq!(err.kind, PreviousIoError);\n             called = true;\n         }).inside {"}, {"sha": "ec9a4a0101fee27e03ebcbc89e4c10ac63490966", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -15,37 +15,47 @@\n \n use prelude::*;\n use super::{Reader, Writer};\n-use rt::io::{io_error, read_error, EndOfFile};\n-use rt::local::Local;\n-use rt::rtio::{RtioPipe, RtioPipeObject, IoFactoryObject, IoFactory};\n-use rt::rtio::RtioUnboundPipeObject;\n+use rt::io::{io_error, EndOfFile};\n+use rt::io::native::file;\n+use rt::rtio::{RtioPipe, with_local_io};\n \n pub struct PipeStream {\n-    priv obj: RtioPipeObject\n+    priv obj: ~RtioPipe,\n }\n \n-// This should not be a newtype, but rt::uv::process::set_stdio needs to reach\n-// into the internals of this :(\n-pub struct UnboundPipeStream(~RtioUnboundPipeObject);\n-\n impl PipeStream {\n-    /// Creates a new pipe initialized, but not bound to any particular\n-    /// source/destination\n-    pub fn new() -> Option<UnboundPipeStream> {\n-        let pipe = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).pipe_init(false)\n-        };\n-        match pipe {\n-            Ok(p) => Some(UnboundPipeStream(p)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+    /// Consumes a file descriptor to return a pipe stream that will have\n+    /// synchronous, but non-blocking reads/writes. This is useful if the file\n+    /// descriptor is acquired via means other than the standard methods.\n+    ///\n+    /// This operation consumes ownership of the file descriptor and it will be\n+    /// closed once the object is deallocated.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::libc;\n+    ///     use std::rt::io::pipe;\n+    ///\n+    ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n+    ///     pipe.write(bytes!(\"Hello, stderr!\"));\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the pipe cannot be created, an error will be raised on the\n+    /// `io_error` condition.\n+    pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n+        do with_local_io |io| {\n+            match io.pipe_open(fd) {\n+                Ok(obj) => Some(PipeStream { obj: obj }),\n+                Err(e) => {\n+                    io_error::cond.raise(e);\n+                    None\n+                }\n             }\n         }\n     }\n \n-    pub fn bind(inner: RtioPipeObject) -> PipeStream {\n+    pub fn new(inner: ~RtioPipe) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n }\n@@ -57,14 +67,14 @@ impl Reader for PipeStream {\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n                 if ioerr.kind != EndOfFile {\n-                    read_error::cond.raise(ioerr);\n+                    io_error::cond.raise(ioerr);\n                 }\n                 return None;\n             }\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { false }\n }\n \n impl Writer for PipeStream {\n@@ -77,5 +87,5 @@ impl Writer for PipeStream {\n         }\n     }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) {}\n }"}, {"sha": "ae087099d1fa506b8ba9c104fe40e7c62aef72b9", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,12 +11,12 @@\n //! Bindings for executing child processes\n \n use prelude::*;\n+use cell::Cell;\n \n use libc;\n use rt::io;\n use rt::io::io_error;\n-use rt::local::Local;\n-use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n+use rt::rtio::{RtioProcess, IoFactory, with_local_io};\n \n // windows values don't matter as long as they're at least one of unix's\n // TERM/KILL/INT signals\n@@ -26,7 +26,7 @@ use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n #[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n \n pub struct Process {\n-    priv handle: ~RtioProcessObject,\n+    priv handle: ~RtioProcess,\n     io: ~[Option<io::PipeStream>],\n }\n \n@@ -57,7 +57,7 @@ pub struct ProcessConfig<'self> {\n     ///     0 - stdin\n     ///     1 - stdout\n     ///     2 - stderr\n-    io: ~[StdioContainer]\n+    io: &'self [StdioContainer]\n }\n \n /// Describes what to do with a standard io stream for a child process.\n@@ -70,42 +70,32 @@ pub enum StdioContainer {\n     /// specified for.\n     InheritFd(libc::c_int),\n \n-    // XXX: these two shouldn't have libuv-specific implementation details\n-\n-    /// The specified libuv stream is inherited for the corresponding file\n-    /// descriptor it is assigned to.\n-    // XXX: this needs to be thought out more.\n-    //InheritStream(uv::net::StreamWatcher),\n-\n-    /// Creates a pipe for the specified file descriptor which will be directed\n-    /// into the previously-initialized pipe passed in.\n+    /// Creates a pipe for the specified file descriptor which will be created\n+    /// when the process is spawned.\n     ///\n     /// The first boolean argument is whether the pipe is readable, and the\n     /// second is whether it is writable. These properties are from the view of\n     /// the *child* process, not the parent process.\n-    CreatePipe(io::UnboundPipeStream,\n-               bool /* readable */,\n-               bool /* writable */),\n+    CreatePipe(bool /* readable */, bool /* writable */),\n }\n \n impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n-        let process = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).spawn(config)\n-        };\n-        match process {\n-            Ok((p, io)) => Some(Process{\n-                handle: p,\n-                io: io.move_iter().map(|p|\n-                    p.map(|p| io::PipeStream::bind(p))\n-                ).collect()\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        let config = Cell::new(config);\n+        do with_local_io |io| {\n+            match io.spawn(config.take()) {\n+                Ok((p, io)) => Some(Process{\n+                    handle: p,\n+                    io: io.move_iter().map(|p|\n+                        p.map(|p| io::PipeStream::new(p))\n+                    ).collect()\n+                }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "a13fc19d000a815b2bc5382a6bd57922fe230184", "filename": "src/libstd/rt/io/signal.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -0,0 +1,220 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Signal handling\n+\n+This modules provides bindings to receive signals safely, built on top of the\n+local I/O factory. There are a number of defined signals which can be caught,\n+but not all signals will work across all platforms (windows doesn't have\n+definitions for a number of signals.\n+\n+*/\n+\n+use comm::{Port, SharedChan, stream};\n+use hashmap;\n+use option::{Some, None};\n+use result::{Err, Ok};\n+use rt::io::io_error;\n+use rt::rtio::{IoFactory, RtioSignal, with_local_io};\n+\n+#[deriving(Eq, IterBytes)]\n+pub enum Signum {\n+    /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n+    Break = 21i,\n+    /// Equivalent to SIGHUP, delivered when the user closes the terminal\n+    /// window. On delivery of HangUp, the program is given approximately\n+    /// 10 seconds to perfom any cleanup. After that, Windows will\n+    /// unconditionally terminate it.\n+    HangUp = 1i,\n+    /// Equivalent to SIGINT, delivered when the user presses Ctrl-c.\n+    Interrupt = 2i,\n+    /// Equivalent to SIGQUIT, delivered when the user presses Ctrl-\\.\n+    Quit = 3i,\n+    /// Equivalent to SIGTSTP, delivered when the user presses Ctrl-z.\n+    StopTemporarily = 20i,\n+    /// Equivalent to SIGUSR1.\n+    User1 = 10i,\n+    /// Equivalent to SIGUSR2.\n+    User2 = 12i,\n+    /// Equivalent to SIGWINCH, delivered when the console has been resized.\n+    /// WindowSizeChange may not be delivered in a timely manner; size change\n+    /// will only be detected when the cursor is being moved.\n+    WindowSizeChange = 28i,\n+}\n+\n+/// Listener provides a port to listen for registered signals.\n+///\n+/// Listener automatically unregisters its handles once it is out of scope.\n+/// However, clients can still unregister signums manually.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rt::io::signal::{Listener, Interrupt};\n+///\n+/// let mut listener = Listener::new();\n+/// listener.register(signal::Interrupt);\n+///\n+/// do spawn {\n+///     loop {\n+///         match listener.port.recv() {\n+///             Interrupt => println(\"Got Interrupt'ed\"),\n+///             _ => (),\n+///         }\n+///     }\n+/// }\n+///\n+/// ```\n+pub struct Listener {\n+    /// A map from signums to handles to keep the handles in memory\n+    priv handles: hashmap::HashMap<Signum, ~RtioSignal>,\n+    /// chan is where all the handles send signums, which are received by\n+    /// the clients from port.\n+    priv chan: SharedChan<Signum>,\n+\n+    /// Clients of Listener can `recv()` from this port. This is exposed to\n+    /// allow selection over this port as well as manipulation of the port\n+    /// directly.\n+    port: Port<Signum>,\n+}\n+\n+impl Listener {\n+    /// Creates a new listener for signals. Once created, signals are bound via\n+    /// the `register` method (otherwise nothing will ever be received)\n+    pub fn new() -> Listener {\n+        let (port, chan) = stream();\n+        Listener {\n+            chan: SharedChan::new(chan),\n+            port: port,\n+            handles: hashmap::HashMap::new(),\n+        }\n+    }\n+\n+    /// Listen for a signal, returning true when successfully registered for\n+    /// signum. Signals can be received using `recv()`.\n+    ///\n+    /// Once a signal is registered, this listener will continue to receive\n+    /// notifications of signals until it is unregistered. This occurs\n+    /// regardless of the number of other listeners registered in other tasks\n+    /// (or on this task).\n+    ///\n+    /// Signals are still received if there is no task actively waiting for\n+    /// a signal, and a later call to `recv` will return the signal that was\n+    /// received while no task was waiting on it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If this function fails to register a signal handler, then an error will\n+    /// be raised on the `io_error` condition and the function will return\n+    /// false.\n+    pub fn register(&mut self, signum: Signum) -> bool {\n+        if self.handles.contains_key(&signum) {\n+            return true; // self is already listening to signum, so succeed\n+        }\n+        do with_local_io |io| {\n+            match io.signal(signum, self.chan.clone()) {\n+                Ok(w) => {\n+                    self.handles.insert(signum, w);\n+                    Some(())\n+                },\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }.is_some()\n+    }\n+\n+    /// Unregisters a signal. If this listener currently had a handler\n+    /// registered for the signal, then it will stop receiving any more\n+    /// notification about the signal. If the signal has already been received,\n+    /// it may still be returned by `recv`.\n+    pub fn unregister(&mut self, signum: Signum) {\n+        self.handles.pop(&signum);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use libc;\n+    use rt::io::timer;\n+    use rt::io;\n+    use super::*;\n+\n+    // kill is only available on Unixes\n+    #[cfg(unix)]\n+    #[fixed_stack_segment]\n+    fn sigint() {\n+        unsafe {\n+            libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);\n+        }\n+    }\n+\n+    #[test] #[cfg(unix)]\n+    fn test_io_signal_smoketest() {\n+        let mut signal = Listener::new();\n+        signal.register(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        match signal.port.recv() {\n+            Interrupt => (),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+    }\n+\n+    #[test] #[cfg(unix)]\n+    fn test_io_signal_two_signal_one_signum() {\n+        let mut s1 = Listener::new();\n+        let mut s2 = Listener::new();\n+        s1.register(Interrupt);\n+        s2.register(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        match s1.port.recv() {\n+            Interrupt => (),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+        match s1.port.recv() {\n+            Interrupt => (),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+    }\n+\n+    #[test] #[cfg(unix)]\n+    fn test_io_signal_unregister() {\n+        let mut s1 = Listener::new();\n+        let mut s2 = Listener::new();\n+        s1.register(Interrupt);\n+        s2.register(Interrupt);\n+        s2.unregister(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        if s2.port.peek() {\n+            fail!(\"Unexpected {:?}\", s2.port.recv());\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    #[test]\n+    fn test_io_signal_invalid_signum() {\n+        let mut s = Listener::new();\n+        let mut called = false;\n+        do io::io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            if s.register(User1) {\n+                fail!(\"Unexpected successful registry of signum {:?}\", User1);\n+            }\n+        }\n+        assert!(called);\n+    }\n+}"}, {"sha": "b922e6400cc50801b91fa097cdf0505b6dee3da2", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 171, "deletions": 27, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,23 +8,90 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+This modules provides bindings to the local event loop's TTY interface, using it\n+to have synchronous, but non-blocking versions of stdio. These handles can be\n+inspected for information about terminal dimensions or related information\n+about the stream or terminal that it is attached to.\n+\n+# Example\n+\n+```rust\n+use std::rt::io;\n+\n+let mut out = io::stdout();\n+out.write(bytes!(\"Hello, world!\"));\n+```\n+\n+*/\n+\n use fmt;\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::local::Local;\n-use rt::rtio::{RtioFileStream, IoFactoryObject, IoFactory};\n-use super::{Reader, Writer, io_error};\n+use rt::rtio::{IoFactory, RtioTTY, RtioFileStream, with_local_io,\n+               CloseAsynchronously};\n+use super::{Reader, Writer, io_error, IoError, OtherIoError};\n+\n+// And so begins the tale of acquiring a uv handle to a stdio stream on all\n+// platforms in all situations. Our story begins by splitting the world into two\n+// categories, windows and unix. Then one day the creators of unix said let\n+// there be redirection! And henceforth there was redirection away from the\n+// console for standard I/O streams.\n+//\n+// After this day, the world split into four factions:\n+//\n+// 1. Unix with stdout on a terminal.\n+// 2. Unix with stdout redirected.\n+// 3. Windows with stdout on a terminal.\n+// 4. Windows with stdout redirected.\n+//\n+// Many years passed, and then one day the nation of libuv decided to unify this\n+// world. After months of toiling, uv created three ideas: TTY, Pipe, File.\n+// These three ideas propagated throughout the lands and the four great factions\n+// decided to settle among them.\n+//\n+// The groups of 1, 2, and 3 all worked very hard towards the idea of TTY. Upon\n+// doing so, they even enhanced themselves further then their Pipe/File\n+// brethren, becoming the dominant powers.\n+//\n+// The group of 4, however, decided to work independently. They abandoned the\n+// common TTY belief throughout, and even abandoned the fledgling Pipe belief.\n+// The members of the 4th faction decided to only align themselves with File.\n+//\n+// tl;dr; TTY works on everything but when windows stdout is redirected, in that\n+//        case pipe also doesn't work, but magically file does!\n+enum StdSource {\n+    TTY(~RtioTTY),\n+    File(~RtioFileStream),\n+}\n+\n+#[fixed_stack_segment] #[inline(never)]\n+fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n+    do with_local_io |io| {\n+        let fd = unsafe { libc::dup(fd) };\n+        match io.tty_open(fd, readable) {\n+            Ok(tty) => Some(f(TTY(tty))),\n+            Err(_) => {\n+                // It's not really that desirable if these handles are closed\n+                // synchronously, and because they're squirreled away in a task\n+                // structure the destructors will be run when the task is\n+                // attempted to get destroyed. This means that if we run a\n+                // synchronous destructor we'll attempt to do some scheduling\n+                // operations which will just result in sadness.\n+                Some(f(File(io.fs_from_raw_fd(fd, CloseAsynchronously))))\n+            }\n+        }\n+    }.unwrap()\n+}\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// See `stdout()` for notes about this function.\n+#[fixed_stack_segment] #[inline(never)]\n pub fn stdin() -> StdReader {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDIN_FILENO, false)\n-    };\n-    StdReader { inner: stream }\n+    do src(libc::STDIN_FILENO, true) |src| { StdReader { inner: src } }\n }\n \n /// Creates a new non-blocking handle to the stdout of the current process.\n@@ -34,22 +101,14 @@ pub fn stdin() -> StdReader {\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDOUT_FILENO, false)\n-    };\n-    StdWriter { inner: stream }\n+    do src(libc::STDOUT_FILENO, false) |src| { StdWriter { inner: src } }\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDERR_FILENO, false)\n-    };\n-    StdWriter { inner: stream }\n+    do src(libc::STDERR_FILENO, false) |src| { StdWriter { inner: src } }\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted\n@@ -87,12 +146,16 @@ pub fn println_args(fmt: &fmt::Arguments) {\n \n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n-    priv inner: ~RtioFileStream\n+    priv inner: StdSource\n }\n \n impl Reader for StdReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.inner.read(buf) {\n+        let ret = match self.inner {\n+            TTY(ref mut tty) => tty.read(buf),\n+            File(ref mut file) => file.read(buf).map_move(|i| i as uint),\n+        };\n+        match ret {\n             Ok(amt) => Some(amt as uint),\n             Err(e) => {\n                 io_error::cond.raise(e);\n@@ -106,21 +169,102 @@ impl Reader for StdReader {\n \n /// Representation of a writer to a standard output stream\n pub struct StdWriter {\n-    priv inner: ~RtioFileStream\n+    priv inner: StdSource\n+}\n+\n+impl StdWriter {\n+    /// Gets the size of this output window, if possible. This is typically used\n+    /// when the writer is attached to something like a terminal, this is used\n+    /// to fetch the dimensions of the terminal.\n+    ///\n+    /// If successful, returns Some((width, height)).\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if an error\n+    /// happens.\n+    pub fn winsize(&mut self) -> Option<(int, int)> {\n+        match self.inner {\n+            TTY(ref mut tty) => {\n+                match tty.get_winsize() {\n+                    Ok(p) => Some(p),\n+                    Err(e) => {\n+                        io_error::cond.raise(e);\n+                        None\n+                    }\n+                }\n+            }\n+            File(*) => {\n+                io_error::cond.raise(IoError {\n+                    kind: OtherIoError,\n+                    desc: \"stream is not a tty\",\n+                    detail: None,\n+                });\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Controls whether this output stream is a \"raw stream\" or simply a normal\n+    /// stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if an error\n+    /// happens.\n+    pub fn set_raw(&mut self, raw: bool) {\n+        match self.inner {\n+            TTY(ref mut tty) => {\n+                match tty.set_raw(raw) {\n+                    Ok(()) => {},\n+                    Err(e) => io_error::cond.raise(e),\n+                }\n+            }\n+            File(*) => {\n+                io_error::cond.raise(IoError {\n+                    kind: OtherIoError,\n+                    desc: \"stream is not a tty\",\n+                    detail: None,\n+                });\n+            }\n+        }\n+    }\n+\n+    /// Returns whether this tream is attached to a TTY instance or not.\n+    ///\n+    /// This is similar to libc's isatty() function\n+    pub fn isatty(&self) -> bool {\n+        match self.inner {\n+            TTY(ref tty) => tty.isatty(),\n+            File(*) => false,\n+        }\n+    }\n }\n \n impl Writer for StdWriter {\n     fn write(&mut self, buf: &[u8]) {\n-        match self.inner.write(buf) {\n+        let ret = match self.inner {\n+            TTY(ref mut tty) => tty.write(buf),\n+            File(ref mut file) => file.write(buf),\n+        };\n+        match ret {\n             Ok(()) => {}\n             Err(e) => io_error::cond.raise(e)\n         }\n     }\n \n-    fn flush(&mut self) {\n-        match self.inner.flush() {\n-            Ok(()) => {}\n-            Err(e) => io_error::cond.raise(e)\n-        }\n+    fn flush(&mut self) { /* nothing to do */ }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn smoke() {\n+        // Just make sure we can acquire handles\n+        stdin();\n+        stdout();\n+        stderr();\n     }\n }"}, {"sha": "31040bc51a135ec47a7d3e2a32e557e7c55bf40d", "filename": "src/libstd/rt/io/support.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsupport.rs?ref=61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use path::*;\n-\n-pub trait PathLike {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T;\n-}\n-\n-impl<'self> PathLike for &'self str {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        f(*self)\n-    }\n-}\n-\n-impl PathLike for Path {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        let s = self.as_str().unwrap();\n-        f(s)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use path::*;\n-    use super::PathLike;\n-\n-    #[test]\n-    fn path_like_smoke_test() {\n-        let expected = if cfg!(unix) { \"/home\" } else { \"C:\\\\\" };\n-        let path = Path::new(expected);\n-        path.path_as_str(|p| assert!(p == expected));\n-        path.path_as_str(|p| assert!(p == expected));\n-    }\n-}"}, {"sha": "fab0062ee0054ce2498ca30e8c790717a09116ed", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,13 +10,11 @@\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::io::{io_error};\n-use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioTimer, RtioTimerObject};\n-use rt::local::Local;\n+use rt::io::io_error;\n+use rt::rtio::{IoFactory, RtioTimer, with_local_io};\n \n pub struct Timer {\n-    priv obj: ~RtioTimerObject\n+    priv obj: ~RtioTimer\n }\n \n /// Sleep the current task for `msecs` milliseconds.\n@@ -28,20 +26,19 @@ pub fn sleep(msecs: u64) {\n \n impl Timer {\n \n+    /// Creates a new timer which can be used to put the current task to sleep\n+    /// for a number of milliseconds.\n     pub fn new() -> Option<Timer> {\n-        let timer = unsafe {\n-            rtdebug!(\"Timer::init: borrowing io to init timer\");\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            rtdebug!(\"about to init timer\");\n-            (*io).timer_init()\n-        };\n-        match timer {\n-            Ok(t) => Some(Timer { obj: t }),\n-            Err(ioerr) => {\n-                rtdebug!(\"Timer::init: failed to init: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.timer_init() {\n+                Ok(t) => Some(Timer { obj: t }),\n+                Err(ioerr) => {\n+                    rtdebug!(\"Timer::init: failed to init: {:?}\", ioerr);\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n+\n         }\n     }\n "}, {"sha": "1ddc2f86f4bc40410f694b36d828534c84ec090a", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,8 +12,6 @@ use option::{Option, Some, None};\n use rt::sched::Scheduler;\n use rt::task::Task;\n use rt::local_ptr;\n-use rt::rtio::{EventLoop, IoFactoryObject};\n-//use borrow::to_uint;\n use cell::Cell;\n \n pub trait Local {\n@@ -122,24 +120,6 @@ impl Local for Scheduler {\n     }\n }\n \n-// XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer\n-impl Local for IoFactoryObject {\n-    fn put(_value: ~IoFactoryObject) { rtabort!(\"unimpl\") }\n-    fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    fn exists(_: Option<IoFactoryObject>) -> bool { rtabort!(\"unimpl\") }\n-    fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n-    unsafe fn unsafe_take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n-        let sched: *mut Scheduler = Local::unsafe_borrow();\n-        let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n-        return io;\n-    }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> {\n-        rtabort!(\"unimpl\")\n-    }\n-}\n-\n-\n #[cfg(test)]\n mod test {\n     use option::None;"}, {"sha": "31650ede7000d240b428e8300e5179499fa89de6", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,6 +12,7 @@ use fmt;\n use from_str::from_str;\n use libc::exit;\n use option::{Some, None, Option};\n+use rt::io;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use u32;\n@@ -166,14 +167,23 @@ pub trait Logger {\n     fn log(&mut self, args: &fmt::Arguments);\n }\n \n-pub struct StdErrLogger;\n+/// This logger emits output to the stderr of the process, and contains a lazily\n+/// initialized event-loop driven handle to the stream.\n+pub struct StdErrLogger {\n+    priv handle: Option<io::stdio::StdWriter>,\n+}\n+\n+impl StdErrLogger {\n+    pub fn new() -> StdErrLogger { StdErrLogger { handle: None } }\n+}\n \n impl Logger for StdErrLogger {\n     fn log(&mut self, args: &fmt::Arguments) {\n-        // FIXME(#6846): this should not call the blocking version of println,\n-        //               or at least the default loggers for tasks shouldn't do\n-        //               that\n-        ::rt::util::dumb_println(args);\n+        // First time logging? Get a handle to the stderr of this process.\n+        if self.handle.is_none() {\n+            self.handle = Some(io::stderr());\n+        }\n+        fmt::writeln(self.handle.get_mut_ref() as &mut io::Writer, args);\n     }\n }\n "}, {"sha": "66d7a6bf48823b3f80df0610f67a0a4290043558", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -279,7 +279,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n-        let loop_ = ~UvEventLoop::new();\n+        let loop_ = ~UvEventLoop::new() as ~rtio::EventLoop;\n         let mut sched = ~Scheduler::new(loop_,\n                                         work_queue.clone(),\n                                         work_queues.clone(),\n@@ -303,7 +303,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         // set.\n         let work_queue = WorkQueue::new();\n \n-        let main_loop = ~UvEventLoop::new();\n+        let main_loop = ~UvEventLoop::new() as ~rtio::EventLoop;\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n                                                      work_queue,\n                                                      work_queues.clone(),"}, {"sha": "66a0676a2f410655649da3278e6e49f6749e3b7e", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 93, "deletions": 35, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,40 +11,29 @@\n use libc;\n use option::*;\n use result::*;\n+use comm::SharedChan;\n use libc::c_int;\n+use c_str::CString;\n \n+use ai = rt::io::net::addrinfo;\n use rt::io::IoError;\n+use rt::io::signal::Signum;\n use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n-use rt::uv::uvio;\n use path::Path;\n-use super::io::support::PathLike;\n use super::io::{SeekStyle};\n use super::io::{FileMode, FileAccess, FileStat};\n \n-// XXX: ~object doesn't work currently so these are some placeholder\n-// types to use instead\n-pub type EventLoopObject = uvio::UvEventLoop;\n-pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n-pub type IoFactoryObject = uvio::UvIoFactory;\n-pub type RtioTcpStreamObject = uvio::UvTcpStream;\n-pub type RtioTcpAcceptorObject = uvio::UvTcpAcceptor;\n-pub type RtioTcpListenerObject = uvio::UvTcpListener;\n-pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n-pub type RtioTimerObject = uvio::UvTimer;\n-pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n-pub type RtioPipeObject = uvio::UvPipeStream;\n-pub type RtioUnboundPipeObject = uvio::UvUnboundPipe;\n-pub type RtioProcessObject = uvio::UvProcess;\n-\n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n     fn callback_ms(&mut self, ms: u64, ~fn());\n-    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallbackObject;\n+    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallback;\n+\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n+    // FIXME(#9382) this is an awful interface\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory));\n }\n \n pub trait RemoteCallback {\n@@ -69,32 +58,74 @@ pub struct FileOpenConfig {\n     priv mode: int\n }\n \n+/// Description of what to do when a file handle is closed\n+pub enum CloseBehavior {\n+    /// Do not close this handle when the object is destroyed\n+    DontClose,\n+    /// Synchronously close the handle, meaning that the task will block when\n+    /// the handle is destroyed until it has been fully closed.\n+    CloseSynchronously,\n+    /// Asynchronously closes a handle, meaning that the task will *not* block\n+    /// when the handle is destroyed, but the handle will still get deallocated\n+    /// and cleaned up (but this will happen asynchronously on the local event\n+    /// loop).\n+    CloseAsynchronously,\n+}\n+\n+pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n+    use rt::sched::Scheduler;\n+    use rt::local::Local;\n+    use rt::io::{io_error, standard_error, IoUnavailable};\n+\n+    unsafe {\n+        let sched: *mut Scheduler = Local::unsafe_borrow();\n+        let mut io = None;\n+        (*sched).event_loop.io(|i| io = Some(i));\n+        match io {\n+            Some(io) => f(io),\n+            None => {\n+                io_error::cond.raise(standard_error(IoUnavailable));\n+                None\n+            }\n+        }\n+    }\n+}\n+\n pub trait IoFactory {\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError>;\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n-    fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n-    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError>;\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;\n+    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n-    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n-    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n-    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError>;\n-    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>;\n+            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n+\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n+    fn unix_bind(&mut self, path: &CString) ->\n+        Result<~RtioUnixListener, IoError>;\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n+    fn tty_open(&mut self, fd: c_int, readable: bool)\n+            -> Result<~RtioTTY, IoError>;\n+    fn signal(&mut self, signal: Signum, channel: SharedChan<Signum>)\n+        -> Result<~RtioSignal, IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError>;\n+    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn accept(&mut self) -> Result<~RtioTcpStream, IoError>;\n     fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n@@ -154,3 +185,30 @@ pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }\n+\n+pub trait RtioUnixListener {\n+    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError>;\n+}\n+\n+pub trait RtioUnixAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError>;\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n+}\n+\n+pub trait RtioTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError>;\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError>;\n+    fn isatty(&self) -> bool;\n+}\n+\n+pub trait PausibleIdleCallback {\n+    fn start(&mut self, f: ~fn());\n+    fn pause(&mut self);\n+    fn resume(&mut self);\n+    fn close(&mut self);\n+}\n+\n+pub trait RtioSignal {}"}, {"sha": "6e661884616175dd0d603ccc8cf9b9e4e022b238", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -16,7 +16,7 @@ use unstable::raw;\n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n use super::stack::{StackPool};\n-use super::rtio::{EventLoop, EventLoopObject, RemoteCallbackObject};\n+use super::rtio::EventLoop;\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n use super::message_queue::MessageQueue;\n@@ -63,7 +63,7 @@ pub struct Scheduler {\n     no_sleep: bool,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n-    event_loop: ~EventLoopObject,\n+    event_loop: ~EventLoop,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n     priv sched_task: Option<~Task>,\n@@ -107,7 +107,7 @@ impl Scheduler {\n \n     // * Initialization Functions\n \n-    pub fn new(event_loop: ~EventLoopObject,\n+    pub fn new(event_loop: ~EventLoop,\n                work_queue: WorkQueue<~Task>,\n                work_queues: ~[WorkQueue<~Task>],\n                sleeper_list: SleeperList)\n@@ -119,7 +119,7 @@ impl Scheduler {\n \n     }\n \n-    pub fn new_special(event_loop: ~EventLoopObject,\n+    pub fn new_special(event_loop: ~EventLoop,\n                        work_queue: WorkQueue<~Task>,\n                        work_queues: ~[WorkQueue<~Task>],\n                        sleeper_list: SleeperList,\n@@ -227,7 +227,7 @@ impl Scheduler {\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n+            let event_loop: *mut ~EventLoop = &mut self_sched.event_loop;\n \n             // Our scheduler must be in the task before the event loop\n             // is started.\n@@ -793,7 +793,7 @@ pub enum SchedMessage {\n }\n \n pub struct SchedHandle {\n-    priv remote: ~RemoteCallbackObject,\n+    priv remote: ~RemoteCallback,\n     priv queue: MessageQueue<SchedMessage>,\n     sched_id: uint\n }\n@@ -905,6 +905,7 @@ mod test {\n     use cell::Cell;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n+    use rt::rtio::EventLoop;\n     use rt::util;\n     use option::{Some};\n \n@@ -1020,7 +1021,7 @@ mod test {\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n-                ~UvEventLoop::new(),\n+                ~UvEventLoop::new() as ~EventLoop,\n                 normal_queue,\n                 queues.clone(),\n                 sleepers.clone());\n@@ -1031,7 +1032,7 @@ mod test {\n \n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n-                ~UvEventLoop::new(),\n+                ~UvEventLoop::new() as ~EventLoop,\n                 special_queue.clone(),\n                 queues.clone(),\n                 sleepers.clone(),\n@@ -1202,7 +1203,7 @@ mod test {\n                 let queues = ~[queue.clone()];\n \n                 let mut sched = ~Scheduler::new(\n-                    ~UvEventLoop::new(),\n+                    ~UvEventLoop::new() as ~EventLoop,\n                     queue,\n                     queues.clone(),\n                     sleepers.clone());"}, {"sha": "1ea68bb52d7e09de5d97f183ea58b7daacbca499", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -132,7 +132,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             death: Death::new(),\n@@ -166,7 +166,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             death: Death::new(),\n@@ -188,7 +188,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             // FIXME(#7544) make watching optional\n@@ -479,7 +479,6 @@ pub extern \"C\" fn rust_stack_exhausted() {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n-    use rt::logging::Logger;\n     use unstable::intrinsics;\n \n     unsafe {\n@@ -529,8 +528,12 @@ pub extern \"C\" fn rust_stack_exhausted() {\n             do Local::borrow |task: &mut Task| {\n                 let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n-                format_args!(|args| { task.logger.log(args) },\n-                             \"task '{}' has overflowed its stack\", n);\n+                // See the message below for why this is not emitted to the\n+                // task's logger. This has the additional conundrum of the\n+                // logger may not be initialized just yet, meaning that an FFI\n+                // call would happen to initialized it (calling out to libuv),\n+                // and the FFI call needs 2MB of stack when we just ran out.\n+                rterrln!(\"task '{}' has overflowed its stack\", n);\n             }\n         } else {\n             rterrln!(\"stack overflow in non-task context\");\n@@ -546,9 +549,9 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n-    use rt::logging::Logger;\n     use str::Str;\n     use c_str::CString;\n+    use unstable::intrinsics;\n \n     unsafe {\n         let msg = CString::new(msg, false);\n@@ -557,35 +560,35 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             Some(s) => s, None => rtabort!(\"message wasn't utf8?\")\n         };\n \n-        if in_green_task_context() {\n-            // Be careful not to allocate in this block, if we're failing we may\n-            // have been failing due to a lack of memory in the first place...\n-            do Local::borrow |task: &mut Task| {\n-                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-                match file.as_str() {\n-                    Some(file) => {\n-                        format_args!(|args| { task.logger.log(args) },\n-                                     \"task '{}' failed at '{}', {}:{}\",\n-                                     n, msg, file, line);\n-                    }\n-                    None => {\n-                        format_args!(|args| { task.logger.log(args) },\n-                                     \"task '{}' failed at '{}'\", n, msg);\n-                    }\n-                }\n-            }\n-        } else {\n+        if !in_green_task_context() {\n             match file.as_str() {\n                 Some(file) => {\n                     rterrln!(\"failed in non-task context at '{}', {}:{}\",\n                              msg, file, line as int);\n                 }\n-                None => rterrln!(\"failed in non-task context at '{}'\", msg),\n+                None => rterrln!(\"failed in non-task context at '{}'\", msg)\n             }\n+            intrinsics::abort();\n         }\n \n+        // Be careful not to allocate in this block, if we're failing we may\n+        // have been failing due to a lack of memory in the first place...\n         let task: *mut Task = Local::unsafe_borrow();\n+        let n = (*task).name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        // XXX: this should no get forcibly printed to the console, this should\n+        //      either be sent to the parent task (ideally), or get printed to\n+        //      the task's logger. Right now the logger is actually a uvio\n+        //      instance, which uses unkillable blocks internally for various\n+        //      reasons. This will cause serious trouble if the task is failing\n+        //      due to mismanagment of its own kill flag, so calling our own\n+        //      logger in its current state is a bit of a problem.\n+        match file.as_str() {\n+            Some(file) => {\n+                rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n+            }\n+            None => rterrln!(\"task '{}' failed at '{}'\", n, msg),\n+        }\n         if (*task).unwinder.unwinding {\n             rtabort!(\"unwinding again\");\n         }"}, {"sha": "c238b1dfba16a1527a3fc20cc80e1ace4d0f1b95", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rand;\n+use rand::Rng;\n+use os;\n use libc;\n use option::{Some, None};\n+use path::Path;\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n@@ -18,6 +22,7 @@ use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n use path::GenericPath;\n use rt::sched::Scheduler;\n+use rt::rtio::EventLoop;\n use unstable::{run_in_bare_thread};\n use rt::thread::Thread;\n use rt::task::Task;\n@@ -32,7 +37,7 @@ pub fn new_test_uv_sched() -> Scheduler {\n     let queue = WorkQueue::new();\n     let queues = ~[queue.clone()];\n \n-    let mut sched = Scheduler::new(~UvEventLoop::new(),\n+    let mut sched = Scheduler::new(~UvEventLoop::new() as ~EventLoop,\n                                    queue,\n                                    queues,\n                                    SleeperList::new());\n@@ -191,7 +196,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         for i in range(0u, nthreads) {\n-            let loop_ = ~UvEventLoop::new();\n+            let loop_ = ~UvEventLoop::new() as ~EventLoop;\n             let mut sched = ~Scheduler::new(loop_,\n                                             work_queues[i].clone(),\n                                             work_queues.clone(),\n@@ -327,6 +332,12 @@ pub fn next_test_port() -> u16 {\n     }\n }\n \n+/// Get a temporary path which could be the location of a unix socket\n+#[fixed_stack_segment] #[inline(never)]\n+pub fn next_test_unix() -> Path {\n+    os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n+}\n+\n /// Get a unique IPv4 localhost:port pair starting at 9600\n pub fn next_test_ip4() -> SocketAddr {\n     SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }"}, {"sha": "070985fb0a5cf79a9ac36454fdab630f74ccf67d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -71,9 +71,24 @@ pub fn default_sched_threads() -> uint {\n \n pub fn dumb_println(args: &fmt::Arguments) {\n     use rt::io::native::stdio::stderr;\n-    use rt::io::Writer;\n+    use rt::io::{Writer, io_error, ResourceUnavailable};\n+    use rt::task::Task;\n+    use rt::local::Local;\n+\n     let mut out = stderr();\n-    fmt::writeln(&mut out as &mut Writer, args);\n+    if Local::exists(None::<Task>) {\n+        let mut again = true;\n+        do io_error::cond.trap(|e| {\n+            again = e.kind == ResourceUnavailable;\n+        }).inside {\n+            while again {\n+                again = false;\n+                fmt::writeln(&mut out as &mut Writer, args);\n+            }\n+        }\n+    } else {\n+        fmt::writeln(&mut out as &mut Writer, args);\n+    }\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "a1593d5c8db73efa44583ae751549bf40101f59c", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 109, "deletions": 10, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,9 +18,10 @@ use rt::uv::uvll;\n use rt::uv::uvll::UV_GETADDRINFO;\n use rt::uv::{Loop, UvError, NativeHandle};\n use rt::uv::status_to_maybe_uv_error;\n-use rt::uv::net::UvAddrInfo;\n+use rt::uv::net;\n+use ai = rt::io::net::addrinfo;\n \n-type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>);\n+type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &net::UvAddrInfo, Option<UvError>);\n \n pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n \n@@ -38,7 +39,7 @@ impl GetAddrInfoRequest {\n     }\n \n     pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n-                       service: Option<&str>, hints: Option<UvAddrInfo>,\n+                       service: Option<&str>, hints: Option<ai::Hint>,\n                        cb: GetAddrInfoCallback) {\n \n         assert!(node.is_some() || service.is_some());\n@@ -72,8 +73,41 @@ impl GetAddrInfoRequest {\n             cb(req, addrinfo, err)\n         };\n \n-        // XXX: Implement hints\n-        assert!(hints.is_none());\n+        let hint = hints.map(|hint| {\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if hint.flags & (aival as uint) != 0 {\n+                    flags |= cval as i32;\n+                }\n+            }\n+            /* XXX: do we really want to support these?\n+            let socktype = match hint.socktype {\n+                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n+                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n+                Some(ai::Raw) => uvll::rust_SOCK_RAW(),\n+                None => 0,\n+            };\n+            let protocol = match hint.protocol {\n+                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),\n+                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n+                _ => 0,\n+            };\n+            */\n+            let socktype = 0;\n+            let protocol = 0;\n+\n+            uvll::addrinfo {\n+                ai_flags: flags,\n+                ai_family: hint.family as c_int,\n+                ai_socktype: socktype,\n+                ai_protocol: protocol,\n+                ai_addrlen: 0,\n+                ai_canonname: null(),\n+                ai_addr: null(),\n+                ai_next: null(),\n+            }\n+        });\n+        let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n \n         self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n \n@@ -83,15 +117,15 @@ impl GetAddrInfoRequest {\n                                            getaddrinfo_cb,\n                                            c_node_ptr,\n                                            c_service_ptr,\n-                                           null()));\n+                                           hint_ptr));\n         }\n \n         extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n                                      status: c_int,\n                                      res: *uvll::addrinfo) {\n             let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n             let err = status_to_maybe_uv_error(status);\n-            let addrinfo = UvAddrInfo(res);\n+            let addrinfo = net::UvAddrInfo(res);\n             let data = req.get_req_data();\n             (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n             unsafe {\n@@ -137,6 +171,72 @@ impl GetAddrInfoRequest {\n     }\n }\n \n+fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n+    /* XXX: do we really want to support these?\n+    unsafe {\n+        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n+        f(uvll::rust_AI_ALL(), ai::All);\n+        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n+        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n+        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n+        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n+        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n+    }\n+    */\n+}\n+\n+// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n+pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n+    unsafe {\n+        let &net::UvAddrInfo(addr) = addr;\n+        let mut addr = addr;\n+\n+        let mut addrs = ~[];\n+        loop {\n+            let uvaddr = net::sockaddr_to_UvSocketAddr((*addr).ai_addr);\n+            let rustaddr = net::uv_socket_addr_to_socket_addr(uvaddr);\n+\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if (*addr).ai_flags & cval != 0 {\n+                    flags |= aival as uint;\n+                }\n+            }\n+\n+            /* XXX: do we really want to support these\n+            let protocol = match (*addr).ai_protocol {\n+                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n+                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n+                _ => None,\n+            };\n+            let socktype = match (*addr).ai_socktype {\n+                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n+                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n+                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n+                _ => None,\n+            };\n+            */\n+            let protocol = None;\n+            let socktype = None;\n+\n+            addrs.push(ai::Info {\n+                address: rustaddr,\n+                family: (*addr).ai_family as uint,\n+                socktype: socktype,\n+                protocol: protocol,\n+                flags: flags,\n+            });\n+            if (*addr).ai_next.is_not_null() {\n+                addr = (*addr).ai_next;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return addrs;\n+    }\n+}\n+\n impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n     fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n         GetAddrInfoRequest(handle)\n@@ -150,7 +250,6 @@ impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n mod test {\n     use option::{Some, None};\n     use rt::uv::Loop;\n-    use rt::uv::net::accum_sockaddrs;\n     use rt::io::net::ip::{SocketAddr, Ipv4Addr};\n     use super::*;\n \n@@ -159,14 +258,14 @@ mod test {\n         let mut loop_ = Loop::new();\n         let mut req = GetAddrInfoRequest::new();\n         do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n-            let sockaddrs = accum_sockaddrs(addrinfo);\n+            let sockaddrs = accum_addrinfo(addrinfo);\n             let mut found_local = false;\n             let local_addr = &SocketAddr {\n                 ip: Ipv4Addr(127, 0, 0, 1),\n                 port: 0\n             };\n             for addr in sockaddrs.iter() {\n-                found_local = found_local || addr == local_addr;\n+                found_local = found_local || addr.address == *local_addr;\n             }\n             assert!(found_local);\n         }"}, {"sha": "108aef43c3c9ab8c2ef57351cf2124eb19583181", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{c_int, c_void};\n+use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n use rt::uv::uvll::UV_ASYNC;\n-use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback};\n use rt::uv::WatcherInterop;\n use rt::uv::status_to_maybe_uv_error;\n \n@@ -47,27 +47,6 @@ impl AsyncWatcher {\n             uvll::async_send(handle);\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        let mut this = self;\n-        let data = this.get_watcher_data();\n-        assert!(data.close_cb.is_none());\n-        data.close_cb = Some(cb);\n-\n-        unsafe {\n-            uvll::close(self.native_handle(), close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_stream_t) {\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = watcher.get_watcher_data();\n-                data.close_cb.take_unwrap()();\n-            }\n-            watcher.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void); }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {"}, {"sha": "d2ca15959b025990942f81fef6da567aa0a117e3", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 75, "deletions": 82, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,12 +10,13 @@\n \n use prelude::*;\n use ptr::null;\n+use c_str;\n+use c_str::CString;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n              status_to_maybe_uv_error, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n-use super::super::io::support::PathLike;\n use cast::transmute;\n use libc;\n use libc::{c_int};\n@@ -36,74 +37,67 @@ impl FsRequest {\n         fs_req\n     }\n \n-    pub fn open<P: PathLike>(self, loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) {\n+    pub fn open(self, loop_: &Loop, path: &CString, flags: int, mode: int,\n+                cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                           self.native_handle(), p, flags, mode, complete_cb_ptr)\n-            })\n         });\n+        assert_eq!(ret, 0);\n     }\n \n-    pub fn open_sync<P: PathLike>(self, loop_: &Loop, path: &P,\n-                                  flags: int, mode: int) -> Result<c_int, UvError> {\n+    pub fn open_sync(self, loop_: &Loop, path: &CString,\n+                     flags: int, mode: int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(None)\n         };\n-        let result = path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let result = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                     self.native_handle(), p, flags, mode, complete_cb_ptr)\n-            })\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn unlink<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_unlink(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n-    pub fn unlink_sync<P: PathLike>(self, loop_: &Loop, path: &P)\n+    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n       -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(None)\n         };\n-        let result = path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_unlink(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        let result = path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn stat<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_stat(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_stat(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n@@ -113,11 +107,12 @@ impl FsRequest {\n         };\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_write(loop_.native_handle(), self.native_handle(),\n                            fd, base_ptr,\n                            len, offset, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n@@ -142,11 +137,12 @@ impl FsRequest {\n         };\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_read(loop_.native_handle(), self.native_handle(),\n                            fd, buf_ptr,\n                            len, offset, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n@@ -169,10 +165,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n@@ -186,44 +183,41 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn mkdir<P: PathLike>(self, loop_: &Loop, path: &P, mode: int, cb: FsCallback) {\n+    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_mkdir(loop_.native_handle(),\n-                          self.native_handle(), p, mode, complete_cb_ptr)\n-            })\n+                           self.native_handle(), p, mode, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n-    pub fn rmdir<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_rmdir(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n-            })\n+                           self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n-    pub fn readdir<P: PathLike>(self, loop_: &Loop, path: &P,\n-                                flags: c_int, cb: FsCallback) {\n+    pub fn readdir(self, loop_: &Loop, path: &CString,\n+                   flags: c_int, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n-                          self.native_handle(), p, flags, complete_cb_ptr)\n-            })\n+                             self.native_handle(), p, flags, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     // accessors/utility funcs\n@@ -286,13 +280,10 @@ impl FsRequest {\n         }\n     }\n \n-    pub fn get_paths(&mut self) -> ~[~str] {\n-        use str;\n+    pub fn each_path(&mut self, f: &fn(&CString)) {\n         let ptr = self.get_ptr();\n         match self.get_result() {\n-            n if (n <= 0) => {\n-                ~[]\n-            },\n+            n if (n <= 0) => {}\n             n => {\n                 let n_len = n as uint;\n                 // we pass in the len that uv tells us is there\n@@ -301,11 +292,10 @@ impl FsRequest {\n                 // correctly delimited and we stray into garbage memory?\n                 // in any case, passing Some(n_len) fixes it and ensures\n                 // good results\n-                let raw_path_strs = unsafe {\n-                    str::raw::from_c_multistring(ptr as *libc::c_char, Some(n_len)) };\n-                let raw_len = raw_path_strs.len();\n-                assert_eq!(raw_len, n_len);\n-                raw_path_strs\n+                unsafe {\n+                    c_str::from_c_multistring(ptr as *libc::c_char,\n+                                              Some(n_len), f);\n+                }\n             }\n         }\n     }\n@@ -368,7 +358,6 @@ mod test {\n     use vec;\n     use str;\n     use unstable::run_in_bare_thread;\n-    use path::Path;\n     use rt::uv::{Loop, Buf, slice_to_uv_buf};\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n \n@@ -391,10 +380,9 @@ mod test {\n             let read_mem = vec::from_elem(read_buf_len, 0u8);\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n-            let p = Path::new(path_str);\n             let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &p, create_flags as int, mode as int)\n-            |req, uverr| {\n+            do open_req.open(&loop_, &path_str.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n                 assert!(uverr.is_none());\n                 let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n@@ -405,8 +393,8 @@ mod test {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &Path::new(path_str), read_flags as int,0)\n-                            |req, uverr| {\n+                        do open_req.open(&loop_, &path_str.to_c_str(),\n+                                         read_flags as int,0) |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n                             let fd = req.get_result();\n@@ -431,7 +419,8 @@ mod test {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n                                         let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_, &Path::new(path_str))\n+                                        do unlink_req.unlink(loop_,\n+                                                             &path_str.to_c_str())\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -465,8 +454,8 @@ mod test {\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n-                                                   create_flags as int, mode as int);\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n+                                            create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let fd = result.unwrap();\n             // write\n@@ -479,7 +468,7 @@ mod test {\n             assert!(result.is_ok());\n             // re-open\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n@@ -503,7 +492,7 @@ mod test {\n                 assert!(result.is_ok());\n                 // unlink\n                 let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &Path::new(path_str));\n+                let result = unlink_req.unlink_sync(&loop_, &path_str.to_c_str());\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n@@ -539,8 +528,8 @@ mod test {\n             let write_buf  = slice_to_uv_buf(write_val);\n             let write_buf_ptr: *Buf = &write_buf;\n             let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path, create_flags as int, mode as int)\n-            |req, uverr| {\n+            do open_req.open(&loop_, &path.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n                 assert!(uverr.is_none());\n                 let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n@@ -549,7 +538,7 @@ mod test {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat_req = FsRequest::new();\n-                    do stat_req.stat(&loop_, &path) |req, uverr| {\n+                    do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let stat = req.get_stat();\n@@ -560,11 +549,13 @@ mod test {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n                             let unlink_req = FsRequest::new();\n-                            do unlink_req.unlink(&loop_, &path) |req,uverr| {\n+                            do unlink_req.unlink(&loop_,\n+                                                 &path.to_c_str()) |req,uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 let stat_req = FsRequest::new();\n-                                do stat_req.stat(&loop_, &path) |_, uverr| {\n+                                do stat_req.stat(&loop_,\n+                                                 &path.to_c_str()) |_, uverr| {\n                                     // should cause an error because the\n                                     // file doesn't exist anymore\n                                     assert!(uverr.is_some());\n@@ -587,22 +578,23 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                               mode as int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let stat_req = FsRequest::new();\n-                do stat_req.stat(&loop_, &path) |req, uverr| {\n+                do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat = req.get_stat();\n                     naive_print(&loop_, format!(\"{:?}\", stat));\n                     assert!(stat.is_dir());\n                     let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let stat_req = FsRequest::new();\n-                        do stat_req.stat(&loop_, &path) |_req, uverr| {\n+                        do stat_req.stat(&loop_, &path.to_c_str()) |_req, uverr| {\n                             assert!(uverr.is_some());\n                         }\n                     }\n@@ -620,16 +612,17 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let mkdir_req = FsRequest::new();\n-                do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                                   mode as int) |req,uverr| {\n                     assert!(uverr.is_some());\n                     let loop_ = req.get_loop();\n                     let _stat = req.get_stat();\n                     let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n                         assert!(uverr.is_none());\n                         let _loop = req.get_loop();\n                     }\n@@ -645,7 +638,7 @@ mod test {\n             let mut loop_ = Loop::new();\n             let path = \"./tmp/never_existed_dir\";\n             let rmdir_req = FsRequest::new();\n-            do rmdir_req.rmdir(&loop_, &path) |_req, uverr| {\n+            do rmdir_req.rmdir(&loop_, &path.to_c_str()) |_req, uverr| {\n                 assert!(uverr.is_some());\n             }\n             loop_.run();"}, {"sha": "40f0750b2d0742d1ab0b78787387ee1e1d2cccc2", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,7 +11,7 @@\n use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback};\n use rt::uv::status_to_maybe_uv_error;\n \n pub struct IdleWatcher(*uvll::uv_idle_t);\n@@ -20,9 +20,9 @@ impl Watcher for IdleWatcher { }\n impl IdleWatcher {\n     pub fn new(loop_: &mut Loop) -> IdleWatcher {\n         unsafe {\n-            let handle = uvll::idle_new();\n+            let handle = uvll::malloc_handle(uvll::UV_IDLE);\n             assert!(handle.is_not_null());\n-            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n             let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher\n@@ -36,29 +36,14 @@ impl IdleWatcher {\n         }\n \n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let data = idle_watcher.get_watcher_data();\n-            let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(idle_watcher, status);\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n     pub fn restart(&mut self) {\n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let data = idle_watcher.get_watcher_data();\n-            let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(idle_watcher, status);\n+            assert!(self.get_watcher_data().idle_cb.is_some());\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n@@ -68,30 +53,7 @@ impl IdleWatcher {\n         // free\n \n         unsafe {\n-            assert!(0 == uvll::idle_stop(self.native_handle()));\n-        }\n-    }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            unsafe {\n-                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-                {\n-                    let data = idle_watcher.get_watcher_data();\n-                    data.close_cb.take_unwrap()();\n-                }\n-                idle_watcher.drop_watcher_data();\n-                uvll::idle_delete(handle);\n-            }\n+            assert_eq!(uvll::idle_stop(self.native_handle()), 0);\n         }\n     }\n }\n@@ -105,6 +67,14 @@ impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n     }\n }\n \n+extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+    let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+    let data = idle_watcher.get_watcher_data();\n+    let cb: &IdleCallback = data.idle_cb.get_ref();\n+    let status = status_to_maybe_uv_error(status);\n+    (*cb)(idle_watcher, status);\n+}\n+\n #[cfg(test)]\n mod test {\n "}, {"sha": "c92a54425bf4f2962ee08e4fde04527d93101bcb", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -48,6 +48,7 @@ use cast::transmute;\n use ptr::null;\n use unstable::finally::Finally;\n use rt::io::net::ip::SocketAddr;\n+use rt::io::signal::Signum;\n \n use rt::io::IoError;\n \n@@ -60,6 +61,7 @@ pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n pub use self::process::Process;\n pub use self::pipe::Pipe;\n+pub use self::signal::SignalWatcher;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -75,6 +77,8 @@ pub mod async;\n pub mod addrinfo;\n pub mod process;\n pub mod pipe;\n+pub mod tty;\n+pub mod signal;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -83,6 +87,14 @@ pub struct Loop {\n     priv handle: *uvll::uv_loop_t\n }\n \n+pub struct Handle(*uvll::uv_handle_t);\n+\n+impl Watcher for Handle {}\n+impl NativeHandle<*uvll::uv_handle_t> for Handle {\n+    fn from_native_handle(h: *uvll::uv_handle_t) -> Handle { Handle(h) }\n+    fn native_handle(&self) -> *uvll::uv_handle_t { **self }\n+}\n+\n /// The trait implemented by uv 'watchers' (handles). Watchers are\n /// non-owning wrappers around the uv handles and are not completely\n /// safe - there may be multiple instances for a single underlying\n@@ -137,6 +149,7 @@ pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n+pub type SignalCallback = ~fn(SignalWatcher, Signum);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n@@ -153,13 +166,16 @@ struct WatcherData {\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n     exit_cb: Option<ExitCallback>,\n+    signal_cb: Option<SignalCallback>,\n }\n \n pub trait WatcherInterop {\n     fn event_loop(&self) -> Loop;\n     fn install_watcher_data(&mut self);\n     fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n     fn drop_watcher_data(&mut self);\n+    fn close(self, cb: NullCallback);\n+    fn close_async(self);\n }\n \n impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n@@ -186,6 +202,7 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 udp_recv_cb: None,\n                 udp_send_cb: None,\n                 exit_cb: None,\n+                signal_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);\n@@ -207,6 +224,34 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n             uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n         }\n     }\n+\n+    fn close(self, cb: NullCallback) {\n+        let mut this = self;\n+        {\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(this.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.get_watcher_data().close_cb.take_unwrap()();\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n+\n+    fn close_async(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n }\n \n // XXX: Need to define the error constants like EOF so they can be\n@@ -297,6 +342,13 @@ pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError>\n /// The uv buffer type\n pub type Buf = uvll::uv_buf_t;\n \n+pub fn empty_buf() -> Buf {\n+    uvll::uv_buf_t {\n+        base: null(),\n+        len: 0,\n+    }\n+}\n+\n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = vec::raw::to_ptr(v);"}, {"sha": "77de8348c14613a7a0aa09167a7d4adea3bb8426", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 63, "deletions": 116, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,8 +13,8 @@ use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n-use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n-             status_to_maybe_uv_error, vec_to_uv_buf};\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle,\n+             status_to_maybe_uv_error, empty_buf};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec;\n use str;\n@@ -27,7 +27,7 @@ pub enum UvSocketAddr {\n     UvIpv6SocketAddr(*sockaddr_in6),\n }\n \n-fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n+pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n     unsafe {\n         assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n         assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n@@ -96,28 +96,6 @@ pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n     uv_socket_addr_as_socket_addr(addr, util::id)\n }\n \n-// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_sockaddrs(addr: &UvAddrInfo) -> ~[SocketAddr] {\n-    unsafe {\n-        let &UvAddrInfo(addr) = addr;\n-        let mut addr = addr;\n-\n-        let mut addrs = ~[];\n-        loop {\n-            let uvaddr = sockaddr_to_UvSocketAddr((*addr).ai_addr);\n-            let rustaddr = uv_socket_addr_to_socket_addr(uvaddr);\n-            addrs.push(rustaddr);\n-            if (*addr).ai_next.is_not_null() {\n-                addr = (*addr).ai_next;\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        return addrs;\n-    }\n-}\n-\n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n@@ -141,23 +119,17 @@ impl Watcher for StreamWatcher { }\n \n impl StreamWatcher {\n     pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.alloc_cb = Some(alloc);\n-            data.read_cb = Some(cb);\n-        }\n-\n-        let ret = unsafe { uvll::read_start(self.native_handle(), alloc_cb, read_cb) };\n-\n-        if ret != 0 {\n-            // uvll::read_start failed, so read_cb will not be called.\n-            // Call it manually for scheduling.\n-            call_read_cb(self.native_handle(), ret as ssize_t);\n-        }\n-\n-        fn call_read_cb(stream: *uvll::uv_stream_t, errno: ssize_t) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            read_cb(stream, errno, vec_to_uv_buf(~[]));\n+        unsafe {\n+            match uvll::read_start(self.native_handle(), alloc_cb, read_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.alloc_cb = Some(alloc);\n+                    data.read_cb = Some(cb);\n+                }\n+                n => {\n+                    cb(*self, 0, empty_buf(), Some(UvError(n)))\n+                }\n+            }\n         }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n@@ -181,20 +153,25 @@ impl StreamWatcher {\n         // but read_stop may be called from inside one of them and we\n         // would end up freeing the in-use environment\n         let handle = self.native_handle();\n-        unsafe { uvll::read_stop(handle); }\n+        unsafe { assert_eq!(uvll::read_stop(handle), 0); }\n     }\n \n     pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.write_cb.is_none());\n-            data.write_cb = Some(cb);\n-        }\n-\n         let req = WriteRequest::new();\n-        unsafe {\n-        assert_eq!(0, uvll::write(req.native_handle(), self.native_handle(), [buf], write_cb));\n-        }\n+        return unsafe {\n+            match uvll::write(req.native_handle(), self.native_handle(),\n+                              [buf], write_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    assert!(data.write_cb.is_none());\n+                    data.write_cb = Some(cb);\n+                }\n+                n => {\n+                    req.delete();\n+                    cb(*self, Some(UvError(n)))\n+                }\n+            }\n+        };\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n@@ -206,30 +183,36 @@ impl StreamWatcher {\n         }\n     }\n \n-    pub fn accept(&mut self, stream: StreamWatcher) {\n-        let self_handle = self.native_handle() as *c_void;\n-        let stream_handle = stream.native_handle() as *c_void;\n-        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n-    }\n \n-    pub fn close(self, cb: NullCallback) {\n+    pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n         {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n         }\n \n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n+        return unsafe {\n+            static BACKLOG: c_int = 128; // XXX should be configurable\n+            match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n+                0 => Ok(()),\n+                n => Err(UvError(n))\n+            }\n+        };\n \n-        extern fn close_cb(handle: *uvll::uv_stream_t) {\n+        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n+            rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().close_cb.take_unwrap();\n-            stream_watcher.drop_watcher_data();\n-            unsafe { free_handle(handle as *c_void) }\n-            cb();\n+            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(status);\n+            (*cb)(stream_watcher, status);\n         }\n     }\n+\n+    pub fn accept(&mut self, stream: StreamWatcher) {\n+        let self_handle = self.native_handle() as *c_void;\n+        let stream_handle = stream.native_handle() as *c_void;\n+        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n+    }\n }\n \n impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n@@ -300,28 +283,6 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn listen(&mut self, cb: ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            static BACKLOG: c_int = 128; // XXX should be configurable\n-            // XXX: This can probably fail\n-            assert_eq!(0, uvll::listen(self.native_handle(), BACKLOG, connection_cb));\n-        }\n-\n-        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n-            rtdebug!(\"connection_cb\");\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(stream_watcher, status);\n-        }\n-    }\n-\n     pub fn as_stream(&self) -> StreamWatcher {\n         NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n     }\n@@ -433,25 +394,6 @@ impl UdpWatcher {\n             cb(udp_watcher, status);\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_udp_t) {\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = udp_watcher.get_watcher_data().close_cb.take_unwrap();\n-            udp_watcher.drop_watcher_data();\n-            unsafe { free_handle(handle as *c_void) }\n-            cb();\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n@@ -464,12 +406,12 @@ impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n }\n \n // uv_connect_t is a subclass of uv_req_t\n-struct ConnectRequest(*uvll::uv_connect_t);\n+pub struct ConnectRequest(*uvll::uv_connect_t);\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n \n-    fn new() -> ConnectRequest {\n+    pub fn new() -> ConnectRequest {\n         let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n         assert!(connect_handle.is_not_null());\n         ConnectRequest(connect_handle as *uvll::uv_connect_t)\n@@ -644,7 +586,8 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n                 let mut loop_ = loop_;\n@@ -678,7 +621,9 @@ mod test {\n                     }\n                     count_cell.put_back(count);\n                 }\n-            }\n+            };\n+\n+            assert!(res.is_ok());\n \n             let client_thread = do Thread::start {\n                 rtdebug!(\"starting client thread\");\n@@ -705,7 +650,7 @@ mod test {\n             loop_.run();\n             loop_.close();\n             client_thread.join();\n-        }\n+        };\n     }\n \n     #[test]\n@@ -718,7 +663,8 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n                 let mut loop_ = loop_;\n@@ -754,7 +700,8 @@ mod test {\n                     }\n                     count_cell.put_back(count);\n                 }\n-            }\n+            };\n+            assert!(res.is_ok());\n \n             let client_thread = do Thread::start {\n                 rtdebug!(\"starting client thread\");"}, {"sha": "74b9312954c83b94703d4418c66a6d1f07f6e042", "filename": "src/libstd/rt/uv/pipe.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,6 +10,7 @@\n \n use prelude::*;\n use libc;\n+use c_str::CString;\n \n use rt::uv;\n use rt::uv::net;\n@@ -37,23 +38,54 @@ impl Pipe {\n         net::StreamWatcher(**self as *uvll::uv_stream_t)\n     }\n \n-    pub fn close(self, cb: uv::NullCallback) {\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn open(&mut self, file: libc::c_int) -> Result<(), uv::UvError> {\n+        match unsafe { uvll::pipe_open(self.native_handle(), file) } {\n+            0 => Ok(()),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn bind(&mut self, name: &CString) -> Result<(), uv::UvError> {\n+        do name.with_ref |name| {\n+            match unsafe { uvll::pipe_bind(self.native_handle(), name) } {\n+                0 => Ok(()),\n+                n => Err(uv::UvError(n))\n+            }\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn connect(&mut self, name: &CString, cb: uv::ConnectionCallback) {\n         {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n         }\n \n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n+        let connect = net::ConnectRequest::new();\n+        let name = do name.with_ref |p| { p };\n \n-        extern fn close_cb(handle: *uvll::uv_pipe_t) {\n-            let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n+        unsafe {\n+            uvll::pipe_connect(connect.native_handle(),\n+                               self.native_handle(),\n+                               name,\n+                               connect_cb)\n+        }\n+\n+        extern \"C\" fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n+            let connect_request: net::ConnectRequest =\n+                    uv::NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = connect_request.stream();\n+            connect_request.delete();\n+\n+            let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n+            let status = uv::status_to_maybe_uv_error(status);\n+            cb(stream_watcher, status);\n         }\n     }\n+\n }\n \n impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {"}, {"sha": "f0d0afeb6aa401de1f3f1898c5eae5140c6cebdc", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,12 +12,11 @@ use prelude::*;\n use cell::Cell;\n use libc;\n use ptr;\n-use util;\n use vec;\n \n use rt::io::process::*;\n use rt::uv;\n-use rt::uv::uvio::UvPipeStream;\n+use rt::uv::uvio::{UvPipeStream, UvUnboundPipe};\n use rt::uv::uvll;\n \n /// A process wraps the handle of the underlying uv_process_t.\n@@ -42,9 +41,9 @@ impl Process {\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(&mut self, loop_: &uv::Loop, mut config: ProcessConfig,\n+    pub fn spawn(&mut self, loop_: &uv::Loop, config: ProcessConfig,\n                  exit_cb: uv::ExitCallback)\n-                    -> Result<~[Option<UvPipeStream>], uv::UvError>\n+                    -> Result<~[Option<~UvPipeStream>], uv::UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n \n@@ -62,13 +61,14 @@ impl Process {\n                                                        err);\n         }\n \n-        let io = util::replace(&mut config.io, ~[]);\n+        let io = config.io;\n         let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n         let mut ret_io = vec::with_capacity(io.len());\n         unsafe {\n             vec::raw::set_len(&mut stdio, io.len());\n-            for (slot, other) in stdio.iter().zip(io.move_iter()) {\n-                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other);\n+            for (slot, other) in stdio.iter().zip(io.iter()) {\n+                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n+                                   loop_);\n                 ret_io.push(io);\n             }\n         }\n@@ -122,30 +122,12 @@ impl Process {\n     pub fn pid(&self) -> libc::pid_t {\n         unsafe { uvll::process_pid(**self) as libc::pid_t }\n     }\n-\n-    /// Closes this handle, invoking the specified callback once closed\n-    pub fn close(self, cb: uv::NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_process_t) {\n-            let mut process: Process = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n-        }\n-    }\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: StdioContainer) -> Option<UvPipeStream> {\n-    match io {\n+                    io: &StdioContainer,\n+                    loop_: &uv::Loop) -> Option<~UvPipeStream> {\n+    match *io {\n         Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n             None\n@@ -155,18 +137,19 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n             uvll::set_stdio_container_fd(dst, fd);\n             None\n         }\n-        CreatePipe(pipe, readable, writable) => {\n+        CreatePipe(readable, writable) => {\n             let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n             if readable {\n                 flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n             }\n             if writable {\n                 flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n             }\n+            let pipe = UvUnboundPipe::new(loop_);\n             let handle = pipe.pipe.as_stream().native_handle();\n             uvll::set_stdio_container_flags(dst, flags);\n             uvll::set_stdio_container_stream(dst, handle);\n-            Some(pipe.bind())\n+            Some(~UvPipeStream::new(pipe))\n         }\n     }\n }"}, {"sha": "3252c89673d6b550f2cfc4d9913b720934a85b29", "filename": "src/libstd/rt/uv/signal.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use option::Some;\n+use libc::c_int;\n+use result::{Err, Ok, Result};\n+use rt::io::signal::Signum;\n+use rt::uv::{Loop, NativeHandle, SignalCallback, UvError, Watcher};\n+use rt::uv::uvll;\n+\n+pub struct SignalWatcher(*uvll::uv_signal_t);\n+\n+impl Watcher for SignalWatcher { }\n+\n+impl SignalWatcher {\n+    pub fn new(loop_: &mut Loop) -> SignalWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::signal_init(loop_.native_handle(), handle));\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, signum: Signum, callback: SignalCallback)\n+            -> Result<(), UvError>\n+    {\n+        return unsafe {\n+            match uvll::signal_start(self.native_handle(), signal_cb,\n+                                     signum as c_int) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.signal_cb = Some(callback);\n+                    Ok(())\n+                }\n+                n => Err(UvError(n)),\n+            }\n+        };\n+\n+        extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.signal_cb.get_ref();\n+            (*cb)(watcher, unsafe { cast::transmute(signum as int) });\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::signal_stop(self.native_handle());\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {\n+    fn from_native_handle(handle: *uvll::uv_signal_t) -> SignalWatcher {\n+        SignalWatcher(handle)\n+    }\n+\n+    fn native_handle(&self) -> *uvll::uv_signal_t {\n+        match self { &SignalWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "fb3c84df39f9b83ddb1bcde12837ecafd304320e", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{c_void, c_int};\n+use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback};\n use rt::uv::status_to_maybe_uv_error;\n \n pub struct TimerWatcher(*uvll::uv_timer_t);\n@@ -53,31 +53,6 @@ impl TimerWatcher {\n             uvll::timer_stop(self.native_handle());\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        let mut watcher = self;\n-        {\n-            let data = watcher.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            uvll::close(watcher.native_handle(), close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_timer_t) {\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = watcher.get_watcher_data();\n-                data.close_cb.take_unwrap()();\n-            }\n-            watcher.drop_watcher_data();\n-            unsafe {\n-                uvll::free_handle(handle as *c_void);\n-            }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {"}, {"sha": "f44c5ae8eff611b88f8ea635db0b57581ae25462", "filename": "src/libstd/rt/uv/tty.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftty.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc;\n+\n+use rt::uv;\n+use rt::uv::net;\n+use rt::uv::uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct TTY(*uvll::uv_tty_t);\n+\n+impl uv::Watcher for TTY {}\n+\n+impl TTY {\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn new(loop_: &uv::Loop, fd: libc::c_int, readable: bool) ->\n+            Result<TTY, uv::UvError>\n+    {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TTY) };\n+        assert!(handle.is_not_null());\n+\n+        let ret = unsafe {\n+            uvll::tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n+                           readable as libc::c_int)\n+        };\n+        match ret {\n+            0 => {\n+                let mut ret: TTY = uv::NativeHandle::from_native_handle(handle);\n+                ret.install_watcher_data();\n+                Ok(ret)\n+            }\n+            n => {\n+                unsafe { uvll::free_handle(handle); }\n+                Err(uv::UvError(n))\n+            }\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn set_mode(&self, raw: bool) -> Result<(), uv::UvError> {\n+        let raw = raw as libc::c_int;\n+        match unsafe { uvll::tty_set_mode(self.native_handle(), raw) } {\n+            0 => Ok(()),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)] #[allow(unused_mut)]\n+    pub fn get_winsize(&self) -> Result<(int, int), uv::UvError> {\n+        let mut width: libc::c_int = 0;\n+        let mut height: libc::c_int = 0;\n+        let widthptr: *libc::c_int = &width;\n+        let heightptr: *libc::c_int = &width;\n+\n+        match unsafe { uvll::tty_get_winsize(self.native_handle(),\n+                                             widthptr, heightptr) } {\n+            0 => Ok((width as int, height as int)),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_tty_t> for TTY {\n+    fn from_native_handle(handle: *uvll::uv_tty_t) -> TTY {\n+        TTY(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tty_t {\n+        match self { &TTY(ptr) => ptr }\n+    }\n+}\n+"}, {"sha": "29370c484eb5a06fe7fc93823ade3067c4e375e0", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 432, "deletions": 174, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use c_str::ToCStr;\n+use c_str::{ToCStr, CString};\n use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n+use comm::{SendDeferred, SharedChan};\n use libc::{c_int, c_uint, c_void, pid_t};\n use ops::Drop;\n use option::*;\n use ptr;\n use str;\n-use str::Str;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -32,17 +32,18 @@ use rt::tube::Tube;\n use rt::task::SchedHome;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n-use rt::uv::addrinfo::GetAddrInfoRequest;\n+use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n+use rt::uv::addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n use unstable::sync::Exclusive;\n use path::{GenericPath, Path};\n-use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n           S_IRUSR, S_IWUSR, S_IRWXU};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n              CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n              FileStat};\n+use rt::io::signal::Signum;\n use task;\n+use ai = rt::io::net::addrinfo;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -214,11 +215,11 @@ impl EventLoop for UvEventLoop {\n \n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n         let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n-        return ~UvPausibleIdleCallback {\n+        ~UvPausibleIdleCallback {\n             watcher: idle_watcher,\n             idle_flag: false,\n             closed: false\n-        };\n+        } as ~PausibleIdleCallback\n     }\n \n     fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n@@ -230,12 +231,12 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallbackObject {\n-        ~UvRemoteCallback::new(self.uvio.uv_loop(), f)\n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n+        ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+        f(&mut self.uvio as &mut IoFactory)\n     }\n }\n \n@@ -245,30 +246,30 @@ pub struct UvPausibleIdleCallback {\n     priv closed: bool\n }\n \n-impl UvPausibleIdleCallback {\n+impl PausibleIdleCallback for UvPausibleIdleCallback {\n     #[inline]\n-    pub fn start(&mut self, f: ~fn()) {\n+    fn start(&mut self, f: ~fn()) {\n         do self.watcher.start |_idle_watcher, _status| {\n             f();\n         };\n         self.idle_flag = true;\n     }\n     #[inline]\n-    pub fn pause(&mut self) {\n+    fn pause(&mut self) {\n         if self.idle_flag == true {\n             self.watcher.stop();\n             self.idle_flag = false;\n         }\n     }\n     #[inline]\n-    pub fn resume(&mut self) {\n+    fn resume(&mut self) {\n         if self.idle_flag == false {\n             self.watcher.restart();\n             self.idle_flag = true;\n         }\n     }\n     #[inline]\n-    pub fn close(&mut self) {\n+    fn close(&mut self) {\n         self.pause();\n         if !self.closed {\n             self.closed = true;\n@@ -414,9 +415,9 @@ impl UvIoFactory {\n \n /// Helper for a variety of simple uv_fs_* functions that\n /// have no ret val\n-fn uv_fs_helper<P: PathLike>(loop_: &mut Loop, path: &P,\n-                             cb: ~fn(&mut FsRequest, &mut Loop, &P,\n-                                     ~fn(&FsRequest, Option<UvError>)))\n+fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n+                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n+                        ~fn(&FsRequest, Option<UvError>)))\n         -> Result<(), IoError> {\n     let result_cell = Cell::new_empty();\n     let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n@@ -446,11 +447,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError> {\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStream, IoError>> = &result_cell;\n \n         // Block this task and take ownership, switch to scheduler context\n         do task::unkillable { // FIXME(#8674)\n@@ -466,7 +467,8 @@ impl IoFactory for UvIoFactory {\n                         None => {\n                             let tcp = NativeHandle::from_native_handle(stream.native_handle());\n                             let home = get_handle_to_current_scheduler!();\n-                            let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n+                            let res = Ok(~UvTcpStream { watcher: tcp, home: home }\n+                                                as ~RtioTcpStream);\n \n                             // Store the stream in the task's stack\n                             unsafe { (*result_cell_ptr).put_back(res); }\n@@ -493,12 +495,12 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError> {\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => {\n                 let home = get_handle_to_current_scheduler!();\n-                Ok(~UvTcpListener::new(watcher, home))\n+                Ok(~UvTcpListener::new(watcher, home) as ~RtioTcpListener)\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n@@ -516,12 +518,12 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => {\n                 let home = get_handle_to_current_scheduler!();\n-                Ok(~UvUdpSocket { watcher: watcher, home: home })\n+                Ok(~UvUdpSocket { watcher: watcher, home: home } as ~RtioUdpSocket)\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n@@ -539,19 +541,19 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError> {\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n         let watcher = TimerWatcher::new(self.uv_loop());\n         let home = get_handle_to_current_scheduler!();\n-        Ok(~UvTimer::new(watcher, home))\n+        Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n     }\n \n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let home = get_handle_to_current_scheduler!();\n-        ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n+        ~UvFileStream::new(loop_, fd, close, home) as ~RtioFileStream\n     }\n \n-    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError> {\n         let mut flags = match fm {\n             Open => 0,\n@@ -588,7 +590,7 @@ impl IoFactory for UvIoFactory {\n                         let home = get_handle_to_current_scheduler!();\n                         let fd = req.get_result() as c_int;\n                         let fs = ~UvFileStream::new(\n-                            loop_, fd, true, home) as ~RtioFileStream;\n+                            loop_, fd, CloseSynchronously, home) as ~RtioFileStream;\n                         let res = Ok(fs);\n                         unsafe { (*result_cell_ptr).put_back(res); }\n                         let scheduler: ~Scheduler = Local::take();\n@@ -606,14 +608,14 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n         do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n             do unlink_req.unlink(l, p) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError> {\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n         use str::StrSlice;\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<FileStat,\n@@ -625,14 +627,15 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_str = path.path_as_str(|p| p.to_owned());\n-                do stat_req.stat(self.uv_loop(), path)\n-                      |req,err| {\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_instance = Cell::new(Path::new(slice));\n+                do stat_req.stat(self.uv_loop(), path) |req,err| {\n                     let res = match err {\n                         None => {\n                             let stat = req.get_stat();\n                             Ok(FileStat {\n-                                path: Path::new(path_str.as_slice()),\n+                                path: path_instance.take(),\n                                 is_file: stat.is_file(),\n                                 is_dir: stat.is_dir(),\n                                 device: stat.st_dev,\n@@ -658,23 +661,27 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError> {\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[IpAddr], IoError>> = &result_cell;\n-        let host_ptr: *&str = &host;\n+        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n+        let host_ptr: *Option<&str> = &host;\n+        let servname_ptr: *Option<&str> = &servname;\n+        let hint_ptr: *Option<ai::Hint> = &hint;\n         let addrinfo_req = GetAddrInfoRequest::new();\n         let addrinfo_req_cell = Cell::new(addrinfo_req);\n+\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let mut addrinfo_req = addrinfo_req_cell.take();\n                 unsafe {\n                     do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                Some(*host_ptr),\n-                                                None, None) |_, addrinfo, err| {\n+                                                *host_ptr, *servname_ptr,\n+                                                *hint_ptr) |_, addrinfo, err| {\n                         let res = match err {\n-                            None => Ok(accum_sockaddrs(addrinfo).map(|addr| addr.ip.clone())),\n+                            None => Ok(accum_addrinfo(addrinfo)),\n                             Some(err) => Err(uv_error_to_io_error(err))\n                         };\n                         (*result_cell_ptr).put_back(res);\n@@ -688,22 +695,22 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n-    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError> {\n         let mode = S_IRWXU as int;\n         do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n             do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n         do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n             do rmdir_req.rmdir(l, p) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError> {\n         use str::StrSlice;\n         let result_cell = Cell::new_empty();\n@@ -716,17 +723,17 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_str = path.path_as_str(|p| p.to_owned());\n-                do stat_req.readdir(self.uv_loop(), path, flags)\n-                      |req,err| {\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_parent = Cell::new(Path::new(slice));\n+                do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n+                    let parent = path_parent.take();\n                     let res = match err {\n                         None => {\n-                            let rel_paths = req.get_paths();\n                             let mut paths = ~[];\n-                            for r in rel_paths.iter() {\n-                                let mut p = Path::new(path_str.as_slice());\n-                                p.push(r.as_slice());\n-                                paths.push(p);\n+                            do req.each_path |rel_path| {\n+                                let p = rel_path.as_bytes();\n+                                paths.push(parent.join(p.slice_to(rel_path.len())));\n                             }\n                             Ok(paths)\n                         },\n@@ -744,13 +751,8 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError> {\n-        let home = get_handle_to_current_scheduler!();\n-        Ok(~UvUnboundPipe { pipe: Pipe::new(self.uv_loop(), ipc), home: home })\n-    }\n-\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>\n+            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n     {\n         // Sadly, we must create the UvProcess before we actually call uv_spawn\n         // so that the exit_cb can close over it and notify it when the process\n@@ -792,7 +794,8 @@ impl IoFactory for UvIoFactory {\n             Ok(io) => {\n                 // Only now do we actually get a handle to this scheduler.\n                 ret.home = Some(get_handle_to_current_scheduler!());\n-                Ok((ret, io))\n+                Ok((ret as ~RtioProcess,\n+                    io.move_iter().map(|p| p.map(|p| p as ~RtioPipe)).collect()))\n             }\n             Err(uverr) => {\n                 // We still need to close the process handle we created, but\n@@ -801,6 +804,76 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n     }\n+\n+    fn unix_bind(&mut self, path: &CString) ->\n+        Result<~RtioUnixListener, IoError> {\n+        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n+        match pipe.pipe.bind(path) {\n+            Ok(()) => Ok(~UvUnixListener::new(pipe) as ~RtioUnixListener),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n+        }\n+    }\n+\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n+        let pipe = UvUnboundPipe::new(self.uv_loop());\n+        let mut rawpipe = pipe.pipe;\n+\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n+        let pipe_cell = Cell::new(pipe);\n+        let pipe_cell_ptr: *Cell<UvUnboundPipe> = &pipe_cell;\n+\n+        let scheduler: ~Scheduler = Local::take();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do rawpipe.connect(path) |_stream, err| {\n+                let res = match err {\n+                    None => {\n+                        let pipe = unsafe { (*pipe_cell_ptr).take() };\n+                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n+                    }\n+                    Some(e) => Err(uv_error_to_io_error(e)),\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn tty_open(&mut self, fd: c_int, readable: bool)\n+            -> Result<~RtioTTY, IoError> {\n+        match tty::TTY::new(self.uv_loop(), fd, readable) {\n+            Ok(tty) => Ok(~UvTTY {\n+                home: get_handle_to_current_scheduler!(),\n+                tty: tty,\n+                fd: fd,\n+            } as ~RtioTTY),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n+    }\n+\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n+        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n+        match pipe.pipe.open(fd) {\n+            Ok(()) => Ok(~UvPipeStream::new(pipe) as ~RtioPipe),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n+    }\n+\n+    fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n+        -> Result<~RtioSignal, IoError> {\n+        let watcher = SignalWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        let mut signal = ~UvSignal::new(watcher, home);\n+        match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n+            Ok(()) => Ok(signal as ~RtioSignal),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n+        }\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -841,11 +914,12 @@ impl RtioSocket for UvTcpListener {\n }\n \n impl RtioTcpListener for UvTcpListener {\n-    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError> {\n+    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError> {\n         do self.home_for_io_consume |self_| {\n-            let mut acceptor = ~UvTcpAcceptor::new(self_);\n+            let acceptor = ~UvTcpAcceptor::new(self_);\n             let incoming = Cell::new(acceptor.incoming.clone());\n-            do acceptor.listener.watcher.listen |mut server, status| {\n+            let mut stream = acceptor.listener.watcher.as_stream();\n+            let res = do stream.listen |mut server, status| {\n                 do incoming.with_mut_ref |incoming| {\n                     let inc = match status {\n                         Some(_) => Err(standard_error(OtherIoError)),\n@@ -854,20 +928,24 @@ impl RtioTcpListener for UvTcpListener {\n                             // first accept call in the callback guarenteed to succeed\n                             server.accept(inc.as_stream());\n                             let home = get_handle_to_current_scheduler!();\n-                            Ok(~UvTcpStream { watcher: inc, home: home })\n+                            Ok(~UvTcpStream { watcher: inc, home: home }\n+                                    as ~RtioTcpStream)\n                         }\n                     };\n                     incoming.send(inc);\n                 }\n             };\n-            Ok(acceptor)\n+            match res {\n+                Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n         }\n     }\n }\n \n pub struct UvTcpAcceptor {\n     priv listener: UvTcpListener,\n-    priv incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    priv incoming: Tube<Result<~RtioTcpStream, IoError>>,\n }\n \n impl HomingIO for UvTcpAcceptor {\n@@ -888,36 +966,33 @@ impl RtioSocket for UvTcpAcceptor {\n     }\n }\n \n+fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n+    let r = unsafe {\n+        uvll::tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n+    };\n+\n+    match status_to_maybe_uv_error(r) {\n+        Some(err) => Err(uv_error_to_io_error(err)),\n+        None => Ok(())\n+    }\n+}\n+\n impl RtioTcpAcceptor for UvTcpAcceptor {\n-    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n+    fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n         do self.home_for_io |self_| {\n             self_.incoming.recv()\n         }\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 1 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 1)\n         }\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 0 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 0)\n         }\n     }\n }\n@@ -994,6 +1069,17 @@ pub struct UvUnboundPipe {\n     priv home: SchedHandle,\n }\n \n+impl UvUnboundPipe {\n+    /// Creates a new unbound pipe homed to the current scheduler, placed on the\n+    /// specified event loop\n+    pub fn new(loop_: &Loop) -> UvUnboundPipe {\n+        UvUnboundPipe {\n+            pipe: Pipe::new(loop_, false),\n+            home: get_handle_to_current_scheduler!(),\n+        }\n+    }\n+}\n+\n impl HomingIO for UvUnboundPipe {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n@@ -1013,18 +1099,12 @@ impl Drop for UvUnboundPipe {\n     }\n }\n \n-impl UvUnboundPipe {\n-    pub unsafe fn bind(~self) -> UvPipeStream {\n-        UvPipeStream { inner: self }\n-    }\n-}\n-\n pub struct UvPipeStream {\n-    priv inner: ~UvUnboundPipe,\n+    priv inner: UvUnboundPipe,\n }\n \n impl UvPipeStream {\n-    pub fn new(inner: ~UvUnboundPipe) -> UvPipeStream {\n+    pub fn new(inner: UvUnboundPipe) -> UvPipeStream {\n         UvPipeStream { inner: inner }\n     }\n }\n@@ -1402,22 +1482,22 @@ impl RtioTimer for UvTimer {\n pub struct UvFileStream {\n     priv loop_: Loop,\n     priv fd: c_int,\n-    priv close_on_drop: bool,\n-    priv home: SchedHandle\n+    priv close: CloseBehavior,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvFileStream {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n impl UvFileStream {\n-    fn new(loop_: Loop, fd: c_int, close_on_drop: bool,\n+    fn new(loop_: Loop, fd: c_int, close: CloseBehavior,\n            home: SchedHandle) -> UvFileStream {\n         UvFileStream {\n             loop_: loop_,\n             fd: fd,\n-            close_on_drop: close_on_drop,\n-            home: home\n+            close: close,\n+            home: home,\n         }\n     }\n     fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n@@ -1437,9 +1517,9 @@ impl UvFileStream {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n+                }\n+            }\n+        }\n         result_cell.take()\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n@@ -1459,9 +1539,9 @@ impl UvFileStream {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n+                }\n+            }\n+        }\n         result_cell.take()\n     }\n     fn seek_common(&mut self, pos: i64, whence: c_int) ->\n@@ -1484,16 +1564,23 @@ impl UvFileStream {\n \n impl Drop for UvFileStream {\n     fn drop(&mut self) {\n-        if self.close_on_drop {\n-            do self.home_for_io_with_sched |self_, scheduler| {\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    let close_req = file::FsRequest::new();\n-                    do close_req.close(&self_.loop_, self_.fd) |_,_| {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    };\n-                };\n+        match self.close {\n+            DontClose => {}\n+            CloseAsynchronously => {\n+                let close_req = file::FsRequest::new();\n+                do close_req.close(&self.loop_, self.fd) |_,_| {}\n+            }\n+            CloseSynchronously => {\n+                do self.home_for_io_with_sched |self_, scheduler| {\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        let close_req = file::FsRequest::new();\n+                        do close_req.close(&self_.loop_, self_.fd) |_,_| {\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1612,13 +1699,185 @@ impl RtioProcess for UvProcess {\n     }\n }\n \n+pub struct UvUnixListener {\n+    priv inner: UvUnboundPipe\n+}\n+\n+impl HomingIO for UvUnixListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.inner.home() }\n+}\n+\n+impl UvUnixListener {\n+    fn new(pipe: UvUnboundPipe) -> UvUnixListener {\n+        UvUnixListener { inner: pipe }\n+    }\n+}\n+\n+impl RtioUnixListener for UvUnixListener {\n+    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n+        do self.home_for_io_consume |self_| {\n+            let acceptor = ~UvUnixAcceptor::new(self_);\n+            let incoming = Cell::new(acceptor.incoming.clone());\n+            let mut stream = acceptor.listener.inner.pipe.as_stream();\n+            let res = do stream.listen |mut server, status| {\n+                do incoming.with_mut_ref |incoming| {\n+                    let inc = match status {\n+                        Some(e) => Err(uv_error_to_io_error(e)),\n+                        None => {\n+                            let pipe = UvUnboundPipe::new(&server.event_loop());\n+                            server.accept(pipe.pipe.as_stream());\n+                            Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n+                        }\n+                    };\n+                    incoming.send(inc);\n+                }\n+            };\n+            match res {\n+                Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvTTY {\n+    tty: tty::TTY,\n+    home: SchedHandle,\n+    fd: c_int,\n+}\n+\n+impl HomingIO for UvTTY {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvTTY {\n+    fn drop(&mut self) {\n+        // TTY handles are used for the logger in a task, so this destructor is\n+        // run when a task is destroyed. When a task is being destroyed, a local\n+        // scheduler isn't available, so we can't do the normal \"take the\n+        // scheduler and resume once close is done\". Instead close operations on\n+        // a TTY are asynchronous.\n+        self.tty.close_async();\n+    }\n+}\n+\n+impl RtioTTY for UvTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.set_mode(raw) {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.get_winsize() {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn isatty(&self) -> bool {\n+        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY }\n+    }\n+}\n+\n+pub struct UvUnixAcceptor {\n+    listener: UvUnixListener,\n+    incoming: Tube<Result<~RtioPipe, IoError>>,\n+}\n+\n+impl HomingIO for UvUnixAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n+\n+impl UvUnixAcceptor {\n+    fn new(listener: UvUnixListener) -> UvUnixAcceptor {\n+        UvUnixAcceptor { listener: listener, incoming: Tube::new() }\n+    }\n+}\n+\n+impl RtioUnixAcceptor for UvUnixAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n+        do self.home_for_io |self_| {\n+            self_.incoming.recv()\n+        }\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 1)\n+        }\n+    }\n+\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 0)\n+        }\n+    }\n+}\n+\n+pub struct UvSignal {\n+    watcher: signal::SignalWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvSignal {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvSignal {\n+    fn new(w: signal::SignalWatcher, home: SchedHandle) -> UvSignal {\n+        UvSignal { watcher: w, home: home }\n+    }\n+}\n+\n+impl RtioSignal for UvSignal {}\n+\n+impl Drop for UvSignal {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            rtdebug!(\"closing UvSignal\");\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// this function is full of lies\n+unsafe fn local_io() -> &'static mut IoFactory {\n+    do Local::borrow |sched: &mut Scheduler| {\n+        let mut io = None;\n+        sched.event_loop.io(|i| io = Some(i));\n+        cast::transmute(io.unwrap())\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            let io = local_io();\n             let addr = next_test_ip4();\n-            let maybe_chan = (*io).tcp_connect(addr);\n+            let maybe_chan = io.tcp_connect(addr);\n             assert!(maybe_chan.is_err());\n         }\n     }\n@@ -1628,9 +1887,9 @@ fn test_simple_io_no_connect() {\n fn test_simple_udp_io_bind_only() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            let io = local_io();\n             let addr = next_test_ip4();\n-            let maybe_socket = (*io).udp_bind(addr);\n+            let maybe_socket = io.udp_bind(addr);\n             assert!(maybe_socket.is_ok());\n         }\n     }\n@@ -1649,9 +1908,11 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         let work_queue2 = WorkQueue::new();\n         let queues = ~[work_queue1.clone(), work_queue2.clone()];\n \n-        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n                                          sleepers.clone());\n-        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n                                          sleepers.clone());\n \n         let handle1 = Cell::new(sched1.make_handle());\n@@ -1665,11 +1926,9 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         };\n \n         let test_function: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n+            let io = unsafe { local_io() };\n             let addr = next_test_ip4();\n-            let maybe_socket = unsafe { (*io).udp_bind(addr) };\n+            let maybe_socket = io.udp_bind(addr);\n             // this socket is bound to this event loop\n             assert!(maybe_socket.is_ok());\n \n@@ -1728,9 +1987,11 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let work_queue2 = WorkQueue::new();\n         let queues = ~[work_queue1.clone(), work_queue2.clone()];\n \n-        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n                                          sleepers.clone());\n-        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n                                          sleepers.clone());\n \n         let handle1 = Cell::new(sched1.make_handle());\n@@ -1741,11 +2002,9 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let chan = Cell::new(chan);\n \n         let body1: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n+            let io = unsafe { local_io() };\n             let addr = next_test_ip4();\n-            let socket = unsafe { (*io).udp_bind(addr) };\n+            let socket = io.udp_bind(addr);\n             assert!(socket.is_ok());\n             chan.take().send(socket);\n         };\n@@ -1799,8 +2058,8 @@ fn test_simple_tcp_server_and_client() {\n         // Start the server first so it's listening when we connect\n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let listener = (*io).tcp_bind(addr).unwrap();\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n                 let mut acceptor = listener.listen().unwrap();\n                 chan.take().send(());\n                 let mut stream = acceptor.accept().unwrap();\n@@ -1817,8 +2076,8 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n@@ -1842,9 +2101,11 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let client_work_queue = WorkQueue::new();\n         let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n \n-        let mut server_sched = ~Scheduler::new(~UvEventLoop::new(), server_work_queue,\n+        let sloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut server_sched = ~Scheduler::new(sloop, server_work_queue,\n                                                queues.clone(), sleepers.clone());\n-        let mut client_sched = ~Scheduler::new(~UvEventLoop::new(), client_work_queue,\n+        let cloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut client_sched = ~Scheduler::new(cloop, client_work_queue,\n                                                queues.clone(), sleepers.clone());\n \n         let server_handle = Cell::new(server_sched.make_handle());\n@@ -1861,8 +2122,8 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let server_fn: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n-            let listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(server_addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1874,12 +2135,10 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let client_fn: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n-            let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n+            let io = unsafe { local_io() };\n+            let mut stream = io.tcp_connect(client_addr);\n             while stream.is_err() {\n-                stream = unsafe { (*io).tcp_connect(client_addr) };\n+                stream = io.tcp_connect(client_addr);\n             }\n             stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n         };\n@@ -1918,8 +2177,8 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n+                let io = local_io();\n+                let mut server_socket = io.udp_bind(server_addr).unwrap();\n                 chan.take().send(());\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n@@ -1934,8 +2193,8 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n+                let io = local_io();\n+                let mut client_socket = io.udp_bind(client_addr).unwrap();\n                 port.take().recv();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n@@ -1952,8 +2211,8 @@ fn test_read_and_block() {\n         let chan = Cell::new(chan);\n \n         do spawntask {\n-            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n-            let listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             chan.take().send(());\n             let mut stream = acceptor.accept().unwrap();\n@@ -1991,8 +2250,8 @@ fn test_read_and_block() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -2014,8 +2273,8 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let listener = (*io).tcp_bind(addr).unwrap();\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n                 let mut acceptor = listener.listen().unwrap();\n                 chan.take().send(());\n                 let mut stream = acceptor.accept().unwrap();\n@@ -2031,8 +2290,8 @@ fn test_read_read_read() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n@@ -2060,8 +2319,8 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client = (*io).udp_bind(client_addr).unwrap();\n+                let io = local_io();\n+                let mut client = io.udp_bind(client_addr).unwrap();\n                 port.take().recv();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n@@ -2070,8 +2329,8 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server = (*io).udp_bind(server_addr).unwrap();\n+                let io = local_io();\n+                let mut server = io.udp_bind(server_addr).unwrap();\n                 chan.take().send(());\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n@@ -2105,9 +2364,9 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n-                let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n+                let io = local_io();\n+                let mut server_out = io.udp_bind(server_out_addr).unwrap();\n+                let mut server_in = io.udp_bind(server_in_addr).unwrap();\n                 let (port, chan) = first.take();\n                 chan.send(());\n                 port.recv();\n@@ -2131,9 +2390,9 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n-                let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n+                let io = local_io();\n+                let mut client_out = io.udp_bind(client_out_addr).unwrap();\n+                let mut client_in = io.udp_bind(client_in_addr).unwrap();\n                 let (port, chan) = second.take();\n                 port.recv();\n                 chan.send(());\n@@ -2163,8 +2422,8 @@ fn test_udp_many_read() {\n fn test_timer_sleep_simple() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            let timer = (*io).timer_init();\n+            let io = local_io();\n+            let timer = io.timer_init();\n             do timer.map_move |mut t| { t.sleep(1) };\n         }\n     }\n@@ -2174,29 +2433,28 @@ fn file_test_uvio_full_simple_impl() {\n     use str::StrSlice; // why does this have to be explicitly imported to work?\n                        // compiler was complaining about no trait for str that\n                        // does .as_bytes() ..\n-    use path::Path;\n     use rt::io::{Open, Create, ReadWrite, Read};\n     unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        let io = local_io();\n         let write_val = \"hello uvio!\";\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n             let create_fm = Create;\n             let create_fa = ReadWrite;\n-            let mut fd = (*io).fs_open(&Path::new(path), create_fm, create_fa).unwrap();\n+            let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n             let ro_fm = Open;\n             let ro_fa = Read;\n-            let mut fd = (*io).fs_open(&Path::new(path), ro_fm, ro_fa).unwrap();\n+            let mut fd = io.fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(&Path::new(path));\n+        io.fs_unlink(&path.to_c_str());\n     }\n }\n \n@@ -2211,9 +2469,9 @@ fn uvio_naive_print(input: &str) {\n     use str::StrSlice;\n     unsafe {\n         use libc::{STDOUT_FILENO};\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        let io = local_io();\n         {\n-            let mut fd = (*io).fs_from_raw_fd(STDOUT_FILENO, false);\n+            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, DontClose);\n             let write_buf = input.as_bytes();\n             fd.write(write_buf);\n         }"}, {"sha": "75e6a0c6ca552f919039677dfc68c6c2524c72af", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 100, "deletions": 32, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -131,6 +131,8 @@ pub type uv_udp_send_t = c_void;\n pub type uv_getaddrinfo_t = c_void;\n pub type uv_process_t = c_void;\n pub type uv_pipe_t = c_void;\n+pub type uv_tty_t = c_void;\n+pub type uv_signal_t = c_void;\n \n pub struct uv_timespec_t {\n     tv_sec: libc::c_long,\n@@ -218,6 +220,8 @@ pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n                                     exit_status: c_int,\n                                     term_signal: c_int);\n+pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n+                                      signum: c_int);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n@@ -231,37 +235,37 @@ pub type socklen_t = c_int;\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: socklen_t,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n     ai_addr: *sockaddr,\n-    priv ai_canonname: *char,\n+    ai_canonname: *char,\n     ai_next: *addrinfo\n }\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: socklen_t,\n-    priv ai_canonname: *char,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n \n #[cfg(windows)]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: size_t,\n-    priv ai_canonname: *char,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: size_t,\n+    ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n@@ -419,18 +423,6 @@ pub unsafe fn walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void) {\n     rust_uv_walk(loop_handle, cb, arg);\n }\n \n-pub unsafe fn idle_new() -> *uv_idle_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_new()\n-}\n-\n-pub unsafe fn idle_delete(handle: *uv_idle_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_delete(handle)\n-}\n-\n pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -958,6 +950,52 @@ pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n     #[fixed_stack_segment]; #[inline(never)];\n     rust_uv_freeaddrinfo(ai);\n }\n+pub unsafe fn pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_open(pipe, file)\n+}\n+pub unsafe fn pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_bind(pipe, name)\n+}\n+pub unsafe fn pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                           name: *c_char, cb: uv_connect_cb) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_connect(req, handle, name, cb)\n+}\n+pub unsafe fn tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                       readable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_init(loop_ptr, tty, fd, readable)\n+}\n+pub unsafe fn tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_set_mode(tty, mode)\n+}\n+pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                              height: *c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_get_winsize(tty, width, height)\n+}\n+pub unsafe fn guess_handle(fd: c_int) -> uv_handle_type {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_guess_handle(fd)\n+}\n+\n+pub unsafe fn signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_init(loop_, handle);\n+}\n+pub unsafe fn signal_start(handle: *uv_signal_t,\n+                           signal_cb: uv_signal_cb,\n+                           signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_start(handle, signal_cb, signum);\n+}\n+pub unsafe fn signal_stop(handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_stop(handle);\n+}\n \n pub struct uv_err_data {\n     priv err_name: ~str,\n@@ -978,8 +1016,6 @@ extern {\n     fn rust_uv_close(handle: *c_void, cb: uv_close_cb);\n     fn rust_uv_walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void);\n \n-    fn rust_uv_idle_new() -> *uv_idle_t;\n-    fn rust_uv_idle_delete(handle: *uv_idle_t);\n     fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n     fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n     fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n@@ -1102,4 +1138,36 @@ extern {\n     fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n                                        stream: *uv_stream_t);\n     fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n+\n+    fn rust_uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n+    fn rust_uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n+    fn rust_uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                            name: *c_char, cb: uv_connect_cb);\n+    fn rust_uv_tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                        readable: c_int) -> c_int;\n+    fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n+    fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                               height: *c_int) -> c_int;\n+    fn rust_uv_guess_handle(fd: c_int) -> uv_handle_type;\n+\n+    // XXX: see comments in addrinfo.rs\n+    // These should all really be constants...\n+    //#[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ALL() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n+\n+    fn rust_uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n+    fn rust_uv_signal_start(handle: *uv_signal_t,\n+                            signal_cb: uv_signal_cb,\n+                            signum: c_int) -> c_int;\n+    fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n }"}, {"sha": "615ba60e066c06a6c70b4bac95a4bc5e2358069c", "filename": "src/libstd/run.rs", "status": "modified", "additions": 60, "deletions": 35, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -17,8 +17,9 @@ use comm::{stream, SharedChan};\n use libc::{pid_t, c_int};\n use libc;\n use prelude::*;\n-use rt::io::native::process;\n+use rt::io::process;\n use rt::io;\n+use rt::io::extensions::ReaderUtil;\n use task;\n \n /**\n@@ -121,8 +122,24 @@ impl Process {\n      */\n     pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n         let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n-        let inner = process::Process::new(prog, args, env, dir,\n-                                          in_fd, out_fd, err_fd);\n+        let env = env.as_ref().map(|a| a.as_slice());\n+        let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n+        fn rtify(fd: Option<c_int>, input: bool) -> process::StdioContainer {\n+            match fd {\n+                Some(fd) => process::InheritFd(fd),\n+                None => process::CreatePipe(input, !input),\n+            }\n+        }\n+        let rtio = [rtify(in_fd, true), rtify(out_fd, false),\n+                    rtify(err_fd, false)];\n+        let rtconfig = process::ProcessConfig {\n+            program: prog,\n+            args: args,\n+            env: env,\n+            cwd: cwd,\n+            io: rtio,\n+        };\n+        let inner = process::Process::new(rtconfig).unwrap();\n         Process { inner: inner }\n     }\n \n@@ -135,34 +152,40 @@ impl Process {\n      * Fails if there is no stdin available (it's already been removed by\n      * take_input)\n      */\n-    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer { self.inner.input() }\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n+        self.inner.io[0].get_mut_ref() as &mut io::Writer\n+    }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stdout.\n      *\n      * Fails if there is no stdout available (it's already been removed by\n      * take_output)\n      */\n-    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.output() }\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n+        self.inner.io[1].get_mut_ref() as &mut io::Reader\n+    }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stderr.\n      *\n      * Fails if there is no stderr available (it's already been removed by\n      * take_error)\n      */\n-    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.error() }\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n+        self.inner.io[2].get_mut_ref() as &mut io::Reader\n+    }\n \n     /**\n      * Closes the handle to the child process's stdin.\n      */\n     pub fn close_input(&mut self) {\n-        self.inner.take_input();\n+        self.inner.io[0].take();\n     }\n \n     fn close_outputs(&mut self) {\n-        self.inner.take_output();\n-        self.inner.take_error();\n+        self.inner.io[1].take();\n+        self.inner.io[2].take();\n     }\n \n     /**\n@@ -185,21 +208,9 @@ impl Process {\n      * were redirected to existing file descriptors.\n      */\n     pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        self.inner.take_input(); // close stdin\n-        let output = Cell::new(self.inner.take_output());\n-        let error = Cell::new(self.inner.take_error());\n-\n-        fn read_everything(r: &mut io::Reader) -> ~[u8] {\n-            let mut ret = ~[];\n-            let mut buf = [0, ..1024];\n-            loop {\n-                match r.read(buf) {\n-                    Some(n) => { ret.push_all(buf.slice_to(n)); }\n-                    None => break\n-                }\n-            }\n-            return ret;\n-        }\n+        self.close_input();\n+        let output = Cell::new(self.inner.io[1].take());\n+        let error = Cell::new(self.inner.io[2].take());\n \n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n@@ -208,16 +219,27 @@ impl Process {\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n-            match error.take() {\n-                Some(ref mut e) => ch.send((2, read_everything(*e))),\n-                None => ch.send((2, ~[]))\n+\n+        // FIXME(#910, #8674): right now I/O is incredibly brittle when it comes\n+        //      to linked failure, so these tasks must be spawn so they're not\n+        //      affected by linked failure. If these are removed, then the\n+        //      runtime may never exit because linked failure will cause some\n+        //      SchedHandle structures to not get destroyed, meaning that\n+        //      there's always an async watcher available.\n+        do task::spawn_unlinked {\n+            do io::ignore_io_error {\n+                match error.take() {\n+                    Some(ref mut e) => ch.send((2, e.read_to_end())),\n+                    None => ch.send((2, ~[]))\n+                }\n             }\n         }\n-        do task::spawn_sched(task::SingleThreaded) {\n-            match output.take() {\n-                Some(ref mut e) => ch_clone.send((1, read_everything(*e))),\n-                None => ch_clone.send((1, ~[]))\n+        do task::spawn_unlinked {\n+            do io::ignore_io_error {\n+                match output.take() {\n+                    Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n+                    None => ch_clone.send((1, ~[]))\n+                }\n             }\n         }\n \n@@ -311,6 +333,7 @@ mod tests {\n     use path::Path;\n     use run;\n     use str;\n+    use task::spawn;\n     use unstable::running_on_valgrind;\n     use rt::io::native::file;\n     use rt::io::{Writer, Reader};\n@@ -383,6 +406,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[ignore] // FIXME(#10016) cat never sees stdin close\n     fn test_pipes() {\n \n         let pipe_in = os::pipe();\n@@ -401,13 +425,14 @@ mod tests {\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n \n-        let expected = ~\"test\";\n-        writeclose(pipe_in.out, expected);\n+        do spawn {\n+            writeclose(pipe_in.out, ~\"test\");\n+        }\n         let actual = readclose(pipe_out.input);\n         readclose(pipe_err.input);\n         proc.finish();\n \n-        assert_eq!(expected, actual);\n+        assert_eq!(~\"test\", actual);\n     }\n \n     fn writeclose(fd: c_int, s: &str) {"}, {"sha": "12316cb5ead2a2c66ff4d5f45b86b9bef7513bb4", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -148,7 +148,6 @@ pub mod iter;\n pub mod to_str;\n pub mod to_bytes;\n pub mod clone;\n-pub mod io;\n pub mod hash;\n pub mod container;\n pub mod default;"}, {"sha": "053076c5d89ec334022312657eadcec353b1f2f0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -1018,7 +1018,6 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n-    use option::{Option, Some};\n     use cast;\n     use libc;\n     use ptr;\n@@ -1172,34 +1171,6 @@ pub mod raw {\n         vec::raw::set_len(as_owned_vec(s), new_len)\n     }\n \n-    /// Parses a C \"multistring\", eg windows env values or\n-    /// the req->ptr result in a uv_fs_readdir() call.\n-    /// Optionally, a `count` can be passed in, limiting the\n-    /// parsing to only being done `count`-times.\n-    #[inline]\n-    pub unsafe fn from_c_multistring(buf: *libc::c_char, count: Option<uint>) -> ~[~str] {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let mut curr_ptr: uint = buf as uint;\n-        let mut result = ~[];\n-        let mut ctr = 0;\n-        let (limited_count, limit) = match count {\n-            Some(limit) => (true, limit),\n-            None => (false, 0)\n-        };\n-        while(((limited_count && ctr < limit) || !limited_count)\n-              && *(curr_ptr as *libc::c_char) != 0 as libc::c_char) {\n-            let env_pair = from_c_str(\n-                curr_ptr as *libc::c_char);\n-            result.push(env_pair);\n-            curr_ptr +=\n-                libc::strlen(curr_ptr as *libc::c_char) as uint\n-                + 1;\n-            ctr += 1;\n-        }\n-        result\n-    }\n-\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n@@ -1214,26 +1185,6 @@ pub mod raw {\n             assert_eq!(c, ~\"AAA\");\n         }\n     }\n-\n-    #[test]\n-    fn test_str_multistring_parsing() {\n-        use option::None;\n-        unsafe {\n-            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n-            let ptr = vec::raw::to_ptr(input);\n-            let result = from_c_multistring(ptr as *libc::c_char, None);\n-            assert!(result.len() == 2);\n-            let mut ctr = 0;\n-            for x in result.iter() {\n-                match ctr {\n-                    0 => assert_eq!(x, &~\"zero\"),\n-                    1 => assert_eq!(x, &~\"one\"),\n-                    _ => fail!(\"shouldn't happen!\")\n-                }\n-                ctr += 1;\n-            }\n-        }\n-    }\n }\n \n /*"}, {"sha": "fbe2988f77c7178915e91c59305b8ca1c9a3e2f4", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -89,7 +89,7 @@ use unstable::sync::Exclusive;\n use rt::in_green_task_context;\n use rt::local::Local;\n use rt::task::{Task, Sched};\n-use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread};\n+use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread, EventLoop};\n use rt::uv::uvio::UvEventLoop;\n \n #[cfg(test)] use task::default_task_opts;\n@@ -607,7 +607,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let work_queue = WorkQueue::new();\n \n             // Create a new scheduler to hold the new task\n-            let new_loop = ~UvEventLoop::new();\n+            let new_loop = ~UvEventLoop::new() as ~EventLoop;\n             let mut new_sched = ~Scheduler::new_special(new_loop,\n                                                         work_queue,\n                                                         (*sched).work_queues.clone(),"}, {"sha": "8c78e34528bdec63928586c28717ee449a8e5018", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -16,8 +16,6 @@ The `ToBytes` and `IterBytes` traits\n \n use cast;\n use container::Container;\n-use io;\n-use io::Writer;\n use iter::Iterator;\n use option::{None, Option, Some};\n use str::{Str, StrSlice};\n@@ -360,7 +358,10 @@ pub trait ToBytes {\n \n impl<A:IterBytes> ToBytes for A {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n-        do io::with_bytes_writer |wr| {\n+        use rt::io::mem;\n+        use rt::io::Writer;\n+\n+        do mem::with_mem_writer |wr| {\n             do self.iter_bytes(lsb0) |bytes| {\n                 wr.write(bytes);\n                 true"}, {"sha": "456d344b838c5baf65ea05744de32202764e452a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -962,7 +962,6 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n mod test {\n     use ast::*;\n     use super::*;\n-    use std::io;\n     use opt_vec;\n     use std::hashmap::HashMap;\n \n@@ -1137,7 +1136,7 @@ mod test {\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n-        io::println(\"about to run bad test\");\n+        println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n                                     R(id(a,EMPTY_CTXT),51)],\n                                   EMPTY_CTXT,&mut t);"}, {"sha": "736f92910af204e3fa6737fc051fd53f5280c92a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,7 +11,7 @@\n use codemap::{Pos, Span};\n use codemap;\n \n-use std::io;\n+use std::rt::io;\n use std::local_data;\n use extra::term;\n \n@@ -199,9 +199,14 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n     local_data_key!(tls_terminal: @Option<term::Terminal>)\n \n-    let stderr = io::stderr();\n+    let stderr = @mut io::stderr() as @mut io::Writer;\n+    fn is_stderr_screen() -> bool {\n+        #[fixed_stack_segment];\n+        use std::libc;\n+        unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n+    }\n \n-    if stderr.get_type() == io::Screen {\n+    if is_stderr_screen() {\n         let t = match local_data::get(tls_terminal, |v| v.map(|k| *k)) {\n             None => {\n                 let t = term::Terminal::new(stderr);\n@@ -218,21 +223,21 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n         match t {\n             &Some(ref term) => {\n                 term.attr(color);\n-                stderr.write_str(msg);\n+                write!(stderr, \"{}\", msg);\n                 term.reset();\n             },\n-            _ => stderr.write_str(msg)\n+            _ => write!(stderr, \"{}\", msg)\n         }\n     } else {\n-        stderr.write_str(msg);\n+        write!(stderr, \"{}\", msg);\n     }\n }\n \n fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n-    let stderr = io::stderr();\n+    let mut stderr = io::stderr();\n \n     if !topic.is_empty() {\n-        stderr.write_str(format!(\"{} \", topic));\n+        write!(&mut stderr as &mut io::Writer, \"{} \", topic);\n     }\n \n     print_maybe_styled(format!(\"{}: \", diagnosticstr(lvl)),\n@@ -266,6 +271,8 @@ fn highlight_lines(cm: @codemap::CodeMap,\n                    lvl: level,\n                    lines: @codemap::FileLines) {\n     let fm = lines.file;\n+    let mut err = io::stderr();\n+    let err = &mut err as &mut io::Writer;\n \n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n@@ -277,21 +284,12 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        io::stderr().write_str(format!(\"{}:{} \", fm.name, *line + 1u));\n-        let s = fm.get_line(*line as int) + \"\\n\";\n-        io::stderr().write_str(s);\n+        write!(err, \"{}:{} {}\\n\", fm.name, *line + 1, fm.get_line(*line as int));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        let mut indent = s.len();\n-        let mut out = ~\"\";\n-        while indent > 0u {\n-            out.push_char(' ');\n-            indent -= 1u;\n-        }\n-        out.push_str(\"...\\n\");\n-        io::stderr().write_str(out);\n+        write!(err, \"{0:1$}...\\n\", \"\", s.len());\n     }\n \n     // FIXME (#3260)\n@@ -325,7 +323,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        io::stderr().write_str(s);\n+        write!(err, \"{}\", s);\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {"}, {"sha": "99bcb36eedbf567af2e01f77a352a493f7c1b5d0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -1524,7 +1524,8 @@ mod test {\n     }\n \n     fn fake_print_crate(crate: &ast::Crate) {\n-        let s = pprust::rust_printer(std::io::stderr(),get_ident_interner());\n+        let out = @mut std::rt::io::stderr() as @mut std::rt::io::Writer;\n+        let s = pprust::rust_printer(out, get_ident_interner());\n         pprust::print_crate_(s, crate);\n     }\n \n@@ -1536,7 +1537,7 @@ mod test {\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n-        // std::io::println(format!(\"expanded: {:?}\\n\",expanded_ast));\n+        // println(format!(\"expanded: {:?}\\n\",expanded_ast));\n         //mtwt_resolve_crate(expanded_ast)\n     //}\n     //fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n@@ -1645,9 +1646,9 @@ mod test {\n                     let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n                                                     invalid_name);\n                     if (!(varref_name==binding_name)){\n-                        std::io::println(\"uh oh, should match but doesn't:\");\n-                        std::io::println(format!(\"varref: {:?}\",varref));\n-                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n+                        println(\"uh oh, should match but doesn't:\");\n+                        println!(\"varref: {:?}\",varref);\n+                        println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1665,12 +1666,12 @@ mod test {\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        std::io::println(format!(\"varref: {:?}\",varref));\n+                        println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n                                  ident_to_str(&varref.segments[0].identifier));\n-                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n+                        println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert!(!fail);\n@@ -1703,17 +1704,17 @@ foo_module!()\n                                           && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n                                      }).enumerate() {\n             if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n-                std::io::println(\"uh oh, xx binding didn't match xx varref:\");\n-                std::io::println(format!(\"this is xx varref \\\\# {:?}\",idx));\n-                std::io::println(format!(\"binding: {:?}\",cxbind));\n-                std::io::println(format!(\"resolves to: {:?}\",resolved_binding));\n-                std::io::println(format!(\"varref: {:?}\",v.segments[0].identifier));\n-                std::io::println(format!(\"resolves to: {:?}\",\n-                                         mtwt_resolve(v.segments[0].identifier)));\n+                println(\"uh oh, xx binding didn't match xx varref:\");\n+                println!(\"this is xx varref \\\\# {:?}\",idx);\n+                println!(\"binding: {:?}\",cxbind);\n+                println!(\"resolves to: {:?}\",resolved_binding);\n+                println!(\"varref: {:?}\",v.segments[0].identifier);\n+                println!(\"resolves to: {:?}\",\n+                         mtwt_resolve(v.segments[0].identifier));\n                 let table = get_sctable();\n-                std::io::println(\"SC table:\");\n+                println(\"SC table:\");\n                 for (idx,val) in table.table.iter().enumerate() {\n-                    std::io::println(format!(\"{:4u} : {:?}\",idx,val));\n+                    println!(\"{:4u} : {:?}\",idx,val);\n                 }\n             }\n             assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);"}, {"sha": "3e07b16221ec113be82f3d72d94d8f2b9c7403d9", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -15,15 +15,13 @@ use ext::base;\n use print;\n use parse::token::{get_ident_interner};\n \n-use std::io;\n-\n pub fn expand_syntax_ext(cx: @ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n-    io::stdout().write_line(\n+    println(\n         print::pprust::tt_to_str(\n             &ast::tt_delim(@mut tt.to_owned()),\n             get_ident_interner()));"}, {"sha": "119a74cccd6d505a2a965ea948571682a0fcd2e4", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -19,8 +19,10 @@ use parse;\n use parse::token::{get_ident_interner};\n use print::pprust;\n \n-use std::io;\n-use std::result;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+use std::str;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -89,14 +91,23 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n-    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path::new(file)));\n-    match res {\n-      result::Ok(res) => {\n-          base::MRExpr(cx.expr_str(sp, res.to_managed()))\n-      }\n-      result::Err(e) => {\n-        cx.span_fatal(sp, e);\n-      }\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n+    let mut error = None;\n+    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n+        file.open_reader(io::Open).read_to_end()\n+    };\n+    match error {\n+        Some(e) => {\n+            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n+                                      file.display(), e.desc));\n+        }\n+        None => {}\n+    }\n+    match str::from_utf8_owned_opt(bytes) {\n+        Some(s) => base::MRExpr(cx.expr_str(sp, s.to_managed())),\n+        None => {\n+            cx.span_fatal(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n+        }\n     }\n }\n \n@@ -106,13 +117,20 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     use std::at_vec;\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n-    match io::read_whole_file(&res_rel_file(cx, sp, &Path::new(file))) {\n-        result::Ok(src) => {\n-            let v = at_vec::to_managed_move(src);\n-            base::MRExpr(cx.expr_lit(sp, ast::lit_binary(v)))\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n+\n+    let mut error = None;\n+    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n+        file.open_reader(io::Open).read_to_end()\n+    };\n+    match error {\n+        Some(e) => {\n+            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n+                                      file.display(), e.desc));\n         }\n-        result::Err(ref e) => {\n-            cx.parse_sess().span_diagnostic.handler().fatal((*e))\n+        None => {\n+            let bytes = at_vec::to_managed_move(bytes);\n+            base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n         }\n     }\n }"}, {"sha": "e9e6eb872c86f6e814f5d9cc1d2b5d424e943e44", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,7 +18,8 @@ use parse::lexer;\n use parse::token;\n use parse::token::{get_ident_interner};\n \n-use std::io;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n use std::str;\n use std::uint;\n \n@@ -346,9 +347,9 @@ pub struct lit {\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @mut diagnostic::span_handler,\n                                     path: @str,\n-                                    srdr: @io::Reader)\n+                                    mut srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n-    let src = str::from_utf8(srdr.read_whole_stream()).to_managed();\n+    let src = str::from_utf8(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "fad9eab75420042877630cfcd5ff59375e277992", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -19,8 +19,11 @@ use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n \n-use std::io;\n use std::path::Path;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+use std::str;\n \n pub mod lexer;\n pub mod parser;\n@@ -260,16 +263,32 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n /// add the path to the session's codemap and return the new filemap.\n pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n-    match io::read_whole_file_str(path) {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        Ok(src) => string_to_filemap(sess, src.to_managed(), path.as_str().unwrap().to_managed()),\n-        Err(e) => {\n-            match spanopt {\n-                Some(span) => sess.span_diagnostic.span_fatal(span, e),\n-                None => sess.span_diagnostic.handler().fatal(e)\n-            }\n+    let err = |msg: &str| {\n+        match spanopt {\n+            Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n+            None => sess.span_diagnostic.handler().fatal(msg),\n+        }\n+    };\n+    let mut error = None;\n+    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n+        path.open_reader(io::Open).read_to_end()\n+    };\n+    match error {\n+        Some(e) => {\n+            err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+        }\n+        None => {}\n+    }\n+    match str::from_utf8_owned_opt(bytes) {\n+        Some(s) => {\n+            return string_to_filemap(sess, s.to_managed(),\n+                                     path.as_str().unwrap().to_managed());\n+        }\n+        None => {\n+            err(format!(\"{} is not UTF-8 encoded\", path.display()))\n         }\n     }\n+    unreachable!()\n }\n \n // given a session and a string, add the string to\n@@ -318,7 +337,10 @@ mod test {\n     use super::*;\n     use extra::serialize::Encodable;\n     use extra;\n-    use std::io;\n+    use std::rt::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::str;\n     use codemap::{Span, BytePos, Spanned};\n     use opt_vec;\n     use ast;\n@@ -330,10 +352,10 @@ mod test {\n     use util::parser_testing::string_to_stmt;\n \n     #[cfg(test)] fn to_json_str<E : Encodable<extra::json::Encoder>>(val: @E) -> ~str {\n-        do io::with_str_writer |writer| {\n-            let mut encoder = extra::json::Encoder(writer);\n-            val.encode(&mut encoder);\n-        }\n+        let writer = @mut MemWriter::new();\n+        let mut encoder = extra::json::Encoder(writer as @mut io::Writer);\n+        val.encode(&mut encoder);\n+        str::from_utf8(*writer.inner_ref())\n     }\n \n     // produce a codemap::span"}, {"sha": "4801fa21fc4936043f6181a1769d50212e0113cc", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -61,7 +61,7 @@\n  * avoid combining it with other lines and making matters even worse.\n  */\n \n-use std::io;\n+use std::rt::io;\n use std::vec;\n \n #[deriving(Clone, Eq)]\n@@ -148,7 +148,7 @@ pub struct print_stack_elt {\n \n pub static size_infinity: int = 0xffff;\n \n-pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n+pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n@@ -157,7 +157,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     @mut Printer {\n-        out: @out,\n+        out: out,\n         buf_len: n,\n         margin: linewidth as int,\n         space: linewidth as int,\n@@ -255,7 +255,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n  * called 'print'.\n  */\n pub struct Printer {\n-    out: @@io::Writer,\n+    out: @mut io::Writer,\n     buf_len: uint,\n     margin: int, // width of lines we're constrained to\n     space: int, // number of spaces left on line\n@@ -452,7 +452,7 @@ impl Printer {\n     }\n     pub fn print_newline(&mut self, amount: int) {\n         debug!(\"NEWLINE {}\", amount);\n-        (*self.out).write_str(\"\\n\");\n+        write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n@@ -474,10 +474,10 @@ impl Printer {\n     }\n     pub fn print_str(&mut self, s: &str) {\n         while self.pending_indentation > 0 {\n-            (*self.out).write_str(\" \");\n+            write!(self.out, \" \");\n             self.pending_indentation -= 1;\n         }\n-        (*self.out).write_str(s);\n+        write!(self.out, \"{}\", s);\n     }\n     pub fn print(&mut self, x: token, L: int) {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(x), L,"}, {"sha": "400ff804485239d79070b39826f30169eee8f2a4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -28,7 +28,10 @@ use print::pp;\n use print::pprust;\n \n use std::char;\n-use std::io;\n+use std::str;\n+use std::rt::io;\n+use std::rt::io::Decorator;\n+use std::rt::io::mem::MemWriter;\n \n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n@@ -83,11 +86,11 @@ pub fn end(s: @ps) {\n     pp::end(s.s);\n }\n \n-pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n+pub fn rust_printer(writer: @mut io::Writer, intr: @ident_interner) -> @ps {\n     return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n-pub fn rust_printer_annotated(writer: @io::Writer,\n+pub fn rust_printer_annotated(writer: @mut io::Writer,\n                               intr: @ident_interner,\n                               ann: @pp_ann)\n                               -> @ps {\n@@ -118,8 +121,8 @@ pub fn print_crate(cm: @CodeMap,\n                    span_diagnostic: @mut diagnostic::span_handler,\n                    crate: &ast::Crate,\n                    filename: @str,\n-                   input: @io::Reader,\n-                   out: @io::Writer,\n+                   input: @mut io::Reader,\n+                   out: @mut io::Writer,\n                    ann: @pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -200,26 +203,26 @@ pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        print_fn(s, decl, Some(purity), AbiSet::Rust(),\n-                 name, generics, opt_explicit_self, ast::inherited);\n-        end(s); // Close the head box\n-        end(s); // Close the outer box\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    print_fn(s, decl, Some(purity), AbiSet::Rust(),\n+             name, generics, opt_explicit_self, ast::inherited);\n+    end(s); // Close the head box\n+    end(s); // Close the outer box\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        // containing cbox, will be closed by print-block at }\n-        cbox(s, indent_unit);\n-        // head-ibox, will be closed by print-block after {\n-        ibox(s, 0u);\n-        print_block(s, blk);\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    // containing cbox, will be closed by print-block at }\n+    cbox(s, indent_unit);\n+    // head-ibox, will be closed by print-block after {\n+    ibox(s, 0u);\n+    print_block(s, blk);\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n@@ -2196,11 +2199,11 @@ pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n }\n \n pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        f(s, t);\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    f(s, t);\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn next_comment(s: @ps) -> Option<comments::cmnt> {"}, {"sha": "0cbbb58d02c66d5ba4e1fbd712c59c06d7d79553", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -466,16 +466,6 @@ rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n     return (sockaddr_in6*)input->ai_addr;\n }\n \n-extern \"C\" uv_idle_t*\n-rust_uv_idle_new() {\n-  return new uv_idle_t;\n-}\n-\n-extern \"C\" void\n-rust_uv_idle_delete(uv_idle_t* handle) {\n-  delete handle;\n-}\n-\n extern \"C\" int\n rust_uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n   return uv_idle_init(loop, idle);\n@@ -637,3 +627,54 @@ extern \"C\" int\n rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n   return uv_pipe_init(loop, p, ipc);\n }\n+\n+extern \"C\" int\n+rust_uv_pipe_open(uv_pipe_t *pipe, int file) {\n+    return uv_pipe_open(pipe, file);\n+}\n+\n+extern \"C\" int\n+rust_uv_pipe_bind(uv_pipe_t *pipe, char *name) {\n+    return uv_pipe_bind(pipe, name);\n+}\n+\n+extern \"C\" void\n+rust_uv_pipe_connect(uv_connect_t *req, uv_pipe_t *handle,\n+                     char *name, uv_connect_cb cb) {\n+    uv_pipe_connect(req, handle, name, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_tty_init(uv_loop_t *loop, uv_tty_t *tty, int fd, int readable) {\n+    return uv_tty_init(loop, tty, fd, readable);\n+}\n+\n+extern \"C\" int\n+rust_uv_tty_set_mode(uv_tty_t *tty, int mode) {\n+    return uv_tty_set_mode(tty, mode);\n+}\n+\n+extern \"C\" int\n+rust_uv_tty_get_winsize(uv_tty_t *tty, int *width, int *height) {\n+    return uv_tty_get_winsize(tty, width, height);\n+}\n+\n+extern \"C\" uv_handle_type\n+rust_uv_guess_handle(int fd) {\n+    return uv_guess_handle(fd);\n+}\n+\n+extern \"C\" int\n+rust_uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {\n+  return uv_signal_init(loop, handle);\n+}\n+\n+extern \"C\" int\n+rust_uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {\n+  return uv_signal_start(handle, signal_cb, signum);\n+}\n+\n+extern \"C\" int\n+rust_uv_signal_stop(uv_signal_t* handle) {\n+  return uv_signal_stop(handle);\n+}"}, {"sha": "269da8e7882ac9fd61647b595f7828a36b8562fb", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -98,8 +98,6 @@ rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n rust_uv_getaddrinfo\n rust_uv_freeaddrinfo\n-rust_uv_idle_new\n-rust_uv_idle_delete\n rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop\n@@ -191,6 +189,9 @@ rust_set_stdio_container_fd\n rust_set_stdio_container_stream\n rust_uv_process_pid\n rust_uv_pipe_init\n+rust_uv_signal_init\n+rust_uv_signal_start\n+rust_uv_signal_stop\n sdhtml_renderer\n sd_markdown_new\n sd_markdown_render\n@@ -199,3 +200,10 @@ bufrelease\n bufnew\n rust_take_dlerror_lock\n rust_drop_dlerror_lock\n+rust_uv_pipe_open\n+rust_uv_pipe_bind\n+rust_uv_pipe_connect\n+rust_uv_tty_init\n+rust_uv_tty_set_mode\n+rust_uv_tty_get_winsize\n+rust_uv_guess_handle"}, {"sha": "f91327b6a6521262d12d14be8938fea305a8e2c6", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use extra::time;\n use extra::treemap::TreeMap;\n use std::hashmap::{HashMap, HashSet};\n-use std::io;\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::trie::TrieMap;\n@@ -28,7 +27,7 @@ fn timed(label: &str, f: &fn()) {\n }\n \n fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n-    io::println(\" Ascending integers:\");\n+    println(\" Ascending integers:\");\n \n     do timed(\"insert\") {\n         for i in range(0u, n_keys) {\n@@ -50,7 +49,7 @@ fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n }\n \n fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n-    io::println(\" Descending integers:\");\n+    println(\" Descending integers:\");\n \n     do timed(\"insert\") {\n         for i in range(0, n_keys).invert() {\n@@ -118,7 +117,7 @@ fn main() {\n \n     println!(\"{} keys\", n_keys);\n \n-    io::println(\"\\nTreeMap:\");\n+    println(\"\\nTreeMap:\");\n \n     {\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n@@ -131,12 +130,12 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n-    io::println(\"\\nHashMap:\");\n+    println(\"\\nHashMap:\");\n \n     {\n         let mut map: HashMap<uint,uint> = HashMap::new();\n@@ -149,12 +148,12 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: HashMap<uint,uint> = HashMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n-    io::println(\"\\nTrieMap:\");\n+    println(\"\\nTrieMap:\");\n \n     {\n         let mut map: TrieMap<uint> = TrieMap::new();\n@@ -167,7 +166,7 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: TrieMap<uint> = TrieMap::new();\n         vector(&mut map, n_keys, rand);\n     }"}, {"sha": "9f65dc1e5555bd3ce182a277876521b0460f7093", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use extra::bitv::BitvSet;\n use extra::treemap::TreeSet;\n use std::hashmap::HashSet;\n-use std::io;\n use std::os;\n use std::rand;\n use std::uint;\n@@ -123,12 +122,11 @@ impl Results {\n }\n \n fn write_header(header: &str) {\n-    io::stdout().write_str(header);\n-    io::stdout().write_str(\"\\n\");\n+    println(header);\n }\n \n fn write_row(label: &str, value: f64) {\n-    io::stdout().write_str(format!(\"{:30s} {} s\\n\", label, value));\n+    println!(\"{:30s} {} s\\n\", label, value);\n }\n \n fn write_results(label: &str, results: &Results) {"}, {"sha": "2a5971be216b876c1229205f9d597af31fad9f54", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -22,7 +22,6 @@ extern mod extra;\n \n use std::comm::{Port, Chan, SharedChan};\n use std::comm;\n-use std::io;\n use std::os;\n use std::task;\n use std::uint;\n@@ -90,10 +89,10 @@ fn run(args: &[~str]) {\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n-    io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n+    print!(\"Count is {:?}\\n\", result);\n+    print!(\"Test took {:?} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "1ff531324b3585cb9c4bf1c0d35ebd9bcda5ede3", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -17,7 +17,6 @@\n extern mod extra;\n \n use std::comm::{SharedChan, Chan, stream};\n-use std::io;\n use std::os;\n use std::task;\n use std::uint;\n@@ -84,10 +83,10 @@ fn run(args: &[~str]) {\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n-    io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n+    print!(\"Count is {:?}\\n\", result);\n+    print!(\"Test took {:?} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "6bfb731badd5b741beb517bfdb9ff92dfcff9942", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -14,7 +14,6 @@ extern mod extra;\n \n use std::cell::Cell;\n use std::comm::{stream, SharedChan};\n-use std::io;\n use std::option;\n use std::os;\n use std::task;\n@@ -191,15 +190,15 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     }\n \n     // print each color in the set\n-    io::println(show_color_list(set));\n+    println(show_color_list(set));\n \n     // print each creature's stats\n     for rep in report.iter() {\n-        io::println(*rep);\n+        println(*rep);\n     }\n \n     // print the total number of creatures met\n-    io::println(show_number(creatures_met));\n+    println(show_number(creatures_met));\n }\n \n fn main() {\n@@ -215,10 +214,10 @@ fn main() {\n     let nn = from_str::<uint>(args[1]).unwrap();\n \n     print_complements();\n-    io::println(\"\");\n+    println(\"\");\n \n     rendezvous(nn, ~[Blue, Red, Yellow]);\n-    io::println(\"\");\n+    println(\"\");\n \n     rendezvous(nn,\n         ~[Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue]);"}, {"sha": "52f068b8b1cdd13600440ded3f050365c4b23262", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use std::int;\n-use std::io;\n+use std::rt::io;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -68,12 +68,12 @@ fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n     bisect(genelist.clone(), 0, genelist.len() - 1, r)\n }\n \n-fn make_random_fasta(wr: @io::Writer,\n+fn make_random_fasta(wr: @mut io::Writer,\n                      id: ~str,\n                      desc: ~str,\n                      genelist: ~[AminoAcids],\n                      n: int) {\n-    wr.write_line(~\">\" + id + \" \" + desc);\n+    writeln!(wr, \">{} {}\", id, desc);\n     let mut rng = rand::rng();\n     let rng = @mut MyRandom {\n         last: rng.gen()\n@@ -83,26 +83,26 @@ fn make_random_fasta(wr: @io::Writer,\n         op.push_char(select_random(myrandom_next(rng, 100u32),\n                                    genelist.clone()));\n         if op.len() >= LINE_LENGTH {\n-            wr.write_line(op);\n+            writeln!(wr, \"{}\", op);\n             op = ~\"\";\n         }\n     }\n-    if op.len() > 0u { wr.write_line(op); }\n+    if op.len() > 0u { writeln!(wr, \"{}\", op); }\n }\n \n-fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n-    wr.write_line(~\">\" + id + \" \" + desc);\n+fn make_repeat_fasta(wr: @mut io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n+    writeln!(wr, \">{} {}\", id, desc);\n     let mut op = str::with_capacity( LINE_LENGTH );\n     let sl = s.len();\n     for i in range(0u, n as uint) {\n         if (op.len() >= LINE_LENGTH) {\n-            wr.write_line( op );\n+            writeln!(wr, \"{}\", op);\n             op = str::with_capacity( LINE_LENGTH );\n         }\n         op.push_char( s[i % sl] as char );\n     }\n     if op.len() > 0 {\n-        wr.write_line(op)\n+        writeln!(wr, \"{}\", op);\n     }\n }\n \n@@ -111,6 +111,7 @@ fn acid(ch: char, prob: u32) -> AminoAcids {\n }\n \n fn main() {\n+    use std::rt::io::file::FileInfo;\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n         // alioth tests k-nucleotide with this data at 25,000,000\n@@ -122,10 +123,10 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        io::file_writer(&Path::new(\"./shootout-fasta.data\"),\n-                        [io::Truncate, io::Create]).unwrap()\n+        let file = Path::new(\"./shootout-fasta.data\").open_writer(io::CreateOrTruncate);\n+        @mut file as @mut io::Writer\n     } else {\n-        io::stdout()\n+        @mut io::stdout() as @mut io::Writer\n     };\n \n     let n = from_str::<int>(args[1]).unwrap();"}, {"sha": "cfc78e1615ec072da0fe76873ad3fbb2e95c66b2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,10 +18,9 @@ use std::cmp::Ord;\n use std::comm::{stream, Port, Chan};\n use std::comm;\n use std::hashmap::HashMap;\n-use std::io::ReaderUtil;\n-use std::io;\n use std::option;\n use std::os;\n+use std::rt::io;\n use std::str;\n use std::task;\n use std::util;\n@@ -195,48 +194,48 @@ fn main() {\n    let mut proc_mode = false;\n \n    loop {\n-      let line = match rdr.read_line() {\n-          Some(ln) => ln, None => break,\n-      };\n-      let line = line.trim().to_owned();\n-\n-      if line.len() == 0u { continue; }\n-\n-      match (line[0] as char, proc_mode) {\n-\n-         // start processing if this is the one\n-         ('>', false) => {\n-            match line.slice_from(1).find_str(\"THREE\") {\n-               option::Some(_) => { proc_mode = true; }\n-               option::None    => { }\n-            }\n-         }\n-\n-         // break our processing\n-         ('>', true) => { break; }\n-\n-         // process the sequence for k-mers\n-         (_, true) => {\n-            let line_bytes = line.as_bytes();\n-\n-           for (ii, _sz) in sizes.iter().enumerate() {\n-               let lb = line_bytes.to_owned();\n-               to_child[ii].send(lb);\n-            }\n-         }\n-\n-         // whatever\n-         _ => { }\n-      }\n+       let line = match io::ignore_io_error(|| rdr.read_line()) {\n+           Some(ln) => ln, None => break,\n+       };\n+       let line = line.trim().to_owned();\n+\n+       if line.len() == 0u { continue; }\n+\n+       match (line[0] as char, proc_mode) {\n+\n+           // start processing if this is the one\n+           ('>', false) => {\n+               match line.slice_from(1).find_str(\"THREE\") {\n+                   option::Some(_) => { proc_mode = true; }\n+                   option::None    => { }\n+               }\n+           }\n+\n+           // break our processing\n+           ('>', true) => { break; }\n+\n+           // process the sequence for k-mers\n+           (_, true) => {\n+               let line_bytes = line.as_bytes();\n+\n+               for (ii, _sz) in sizes.iter().enumerate() {\n+                   let lb = line_bytes.to_owned();\n+                   to_child[ii].send(lb);\n+               }\n+           }\n+\n+           // whatever\n+           _ => { }\n+       }\n    }\n \n    // finish...\n-    for (ii, _sz) in sizes.iter().enumerate() {\n-      to_child[ii].send(~[]);\n+   for (ii, _sz) in sizes.iter().enumerate() {\n+       to_child[ii].send(~[]);\n    }\n \n    // now fetch and print result messages\n-    for (ii, _sz) in sizes.iter().enumerate() {\n-      io::println(from_child[ii].recv());\n+   for (ii, _sz) in sizes.iter().enumerate() {\n+       println(from_child[ii].recv());\n    }\n }"}, {"sha": "b3c3fa4db6fb601d279ba3e6ab468e2163bc82f0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -23,8 +23,6 @@ extern mod extra;\n \n use extra::{time, getopts};\n use std::comm::{stream, SharedChan};\n-use std::io::WriterUtil;\n-use std::io;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n@@ -113,8 +111,6 @@ fn main() {\n \n         let num_trials = 10;\n \n-        let out = io::stdout();\n-\n         for n in range(1, max + 1) {\n             for _ in range(0, num_trials) {\n                 let start = time::precise_time_ns();\n@@ -123,8 +119,7 @@ fn main() {\n \n                 let elapsed = stop - start;\n \n-                out.write_line(format!(\"{}\\t{}\\t{}\", n, fibn,\n-                                       elapsed.to_str()));\n+                println!(\"{}\\t{}\\t{}\", n, fibn, elapsed.to_str());\n             }\n         }\n     }"}, {"sha": "e1b1f59298ed47602bcd86e790b8d50e78b9e368", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,8 +13,6 @@\n extern mod extra;\n \n use extra::smallintmap::SmallIntMap;\n-use std::io::WriterUtil;\n-use std::io;\n use std::os;\n use std::uint;\n \n@@ -59,8 +57,8 @@ fn main() {\n \n     let maxf = max as f64;\n \n-    io::stdout().write_str(format!(\"insert(): {:?} seconds\\n\", checkf));\n-    io::stdout().write_str(format!(\"        : {} op/sec\\n\", maxf/checkf));\n-    io::stdout().write_str(format!(\"get()   : {:?} seconds\\n\", appendf));\n-    io::stdout().write_str(format!(\"        : {} op/sec\\n\", maxf/appendf));\n+    println!(\"insert(): {:?} seconds\\n\", checkf);\n+    println!(\"        : {} op/sec\\n\", maxf/checkf);\n+    println!(\"get()   : {:?} seconds\\n\", appendf);\n+    println!(\"        : {} op/sec\\n\", maxf/appendf);\n }"}, {"sha": "d4f4a46af38b123d85118fbc7e0b58e61a7d9434", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -14,8 +14,9 @@\n \n extern mod extra;\n \n-use std::io::{ReaderUtil, WriterUtil};\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::stdio::StdReader;\n+use std::rt::io::buffered::BufferedReader;\n use std::os;\n use std::uint;\n use std::unstable::intrinsics::cttz16;\n@@ -67,12 +68,14 @@ impl Sudoku {\n         return true;\n     }\n \n-    pub fn read(reader: @io::Reader) -> Sudoku {\n-        assert!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n+    pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n+        assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n-        while !reader.eof() {\n-            let line = reader.read_line();\n+        loop {\n+            let line = match reader.read_line() {\n+                Some(ln) => ln, None => break\n+            };\n             let comps: ~[&str] = line.trim().split_iter(',').collect();\n \n             if comps.len() == 3u {\n@@ -87,13 +90,13 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn write(&self, writer: @io::Writer) {\n+    pub fn write(&self, writer: @mut io::Writer) {\n         for row in range(0u8, 9u8) {\n-            writer.write_str(format!(\"{}\", self.grid[row][0] as uint));\n+            write!(writer, \"{}\", self.grid[row][0]);\n             for col in range(1u8, 9u8) {\n-                writer.write_str(format!(\" {}\", self.grid[row][col] as uint));\n+                write!(writer, \" {}\", self.grid[row][col]);\n             }\n-            writer.write_char('\\n');\n+            write!(writer, \"\\n\");\n          }\n     }\n \n@@ -278,8 +281,8 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(io::stdin())\n+        Sudoku::read(BufferedReader::new(io::stdin()))\n     };\n     sudoku.solve();\n-    sudoku.write(io::stdout());\n+    sudoku.write(@mut io::stdout() as @mut io::Writer);\n }"}, {"sha": "dcfef4e1d9c8510838f087b24507c19e07feaf8f", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,8 +10,6 @@\n \n // Tests that auto-ref can't create mutable aliases to immutable memory.\n \n-use std::io;\n-\n struct Foo {\n     x: int\n }"}, {"sha": "ef5ad2766ca69b8804bd26a5d74a2d61ec565154", "filename": "src/test/compile-fail/issue-5060-fail.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,17 +10,15 @@\n \n #[feature(macro_rules)];\n \n-use std::io;\n-\n macro_rules! print_hd_tl (\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n-        io::print(stringify!($field)); //~ ERROR unknown macro variable\n-        io::print(\"::[\");\n+        print(stringify!($field)); //~ ERROR unknown macro variable\n+        print(\"::[\");\n         $(\n-            io::print(stringify!($field_tl));\n-            io::print(\", \");\n+            print(stringify!($field_tl));\n+            print(\", \");\n         )+\n-        io::print(\"]\\n\");\n+        print(\"]\\n\");\n     })\n )\n "}, {"sha": "621510cea99e44b54ba82d0e7bf57ffdf5e2a599", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+trait A {}\n \n struct Struct {\n-    r: io::Reader //~ ERROR reference to trait `io::Reader` where a type is expected\n+    r: A //~ ERROR reference to trait `A` where a type is expected\n }\n \n-fn new_struct(r: io::Reader) -> Struct { //~ ERROR reference to trait `io::Reader` where a type is expected\n+fn new_struct(r: A) -> Struct { //~ ERROR reference to trait `A` where a type is expected\n     Struct { r: r }\n }\n "}, {"sha": "9dc29e59f904a0238126761ffe329ade0fe97e19", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n pub struct PkgId {\n     local_path: ~str,\n     junk: ~str\n@@ -32,7 +30,7 @@ pub fn remove_package_from_database() {\n     list_database(push_id);\n \n     for l in lines_to_use.iter() {\n-        io::stdout().write_line(l.local_path);\n+        println!(\"{}\", l.local_path);\n     }\n \n }"}, {"sha": "2818214c994b1363d585e63219cc56d33431cad4", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,8 +13,6 @@\n \n use cal = bar::c::cc;\n \n-use std::io;\n-\n use std::either::Right;        //~ ERROR unused import\n \n use std::util::*;              // shouldn't get errors for not using\n@@ -24,15 +22,23 @@ use std::util::*;              // shouldn't get errors for not using\n use std::option::{Some, None}; //~ ERROR unused import\n                                 //~^ ERROR unused import\n \n-use std::io::ReaderUtil;       //~ ERROR unused import\n+use test::A;       //~ ERROR unused import\n // Be sure that if we just bring some methods into scope that they're also\n // counted as being used.\n-use std::io::WriterUtil;\n+use test::B;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n \n+mod test {\n+    pub trait A { fn a(&self) {} }\n+    pub trait B { fn b(&self) {} }\n+    pub struct C;\n+    impl A for C {}\n+    impl B for C {}\n+}\n+\n mod foo {\n     pub struct Point{x: int, y: int}\n     pub struct Square{p: Point, h: uint, w: uint}\n@@ -58,6 +64,6 @@ fn main() {\n     cal(foo::Point{x:3, y:9});\n     let a = 3;\n     ignore(a);\n-    io::stdout().write_str(\"a\");\n+    test::C.b();\n     let _a = from_elem(0, 0);\n }"}, {"sha": "863663334f8ed444fda789b0d78c842c83dc31d7", "filename": "src/test/run-fail/issue-2156.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8c059c4c6082683d78b2ee3d963f65fa1eb98/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unnecessary_allocation)];\n-\n-// error-pattern:explicit failure\n-// Don't double free the string\n-extern mod extra;\n-\n-use std::io::ReaderUtil;\n-use std::io;\n-\n-fn main() {\n-    do io::with_str_reader(~\"\") |rdr| {\n-        match rdr.read_char() { '=' => { } _ => { fail!() } }\n-    }\n-}"}, {"sha": "5211e76d3d7d2073565b5e2bb382f9d489524f33", "filename": "src/test/run-pass/auto-ref-bounded-ty-param.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n trait Foo {\n     fn f(&self);\n }\n@@ -30,7 +28,7 @@ impl<T:Baz> Foo for T {\n \n impl Baz for Bar {\n     fn g(&self) {\n-        io::println(self.x.to_str());\n+        println(self.x.to_str());\n     }\n }\n "}, {"sha": "4ff184b44831e4f371cecfd399b855749a085ce0", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -18,6 +18,7 @@\n use std::libc;\n use std::run;\n use std::str;\n+use std::rt::io;\n \n #[test]\n fn test_destroy_once() {\n@@ -29,7 +30,9 @@ fn test_destroy_once() {\n fn test_destroy_twice() {\n     let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n     p.destroy(); // this shouldnt crash...\n-    p.destroy(); // ...and nor should this (and nor should the destructor)\n+    do io::io_error::cond.trap(|_| {}).inside {\n+        p.destroy(); // ...and nor should this (and nor should the destructor)\n+    }\n }\n \n fn test_destroy_actually_kills(force: bool) {"}, {"sha": "8d3ad26764281ee52d68784e491e94268f86b81e", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -17,7 +17,8 @@\n \n extern mod extra;\n \n-use std::io;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::Decorator;\n use std::rand::{random, Rand};\n use extra::serialize::{Encodable, Decodable};\n use extra::ebml;\n@@ -55,11 +56,10 @@ struct G<T> {\n \n fn roundtrip<T: Rand + Eq + Encodable<Encoder> + Decodable<Decoder>>() {\n     let obj: T = random();\n-    let bytes = do io::with_bytes_writer |w| {\n-        let mut e = Encoder(w);\n-        obj.encode(&mut e);\n-    };\n-    let doc = ebml::reader::Doc(@bytes);\n+    let w = @mut MemWriter::new();\n+    let mut e = Encoder(w);\n+    obj.encode(&mut e);\n+    let doc = ebml::reader::Doc(@w.inner_ref().to_owned());\n     let mut dec = Decoder(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "2831740deaf477f54a2d837a06e93022201dfea1", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -1,7 +1,5 @@\n #[feature(managed_boxes)];\n \n-use std::io::println;\n-\n pub fn main() {\n     let v: ~[int] = ~[ 1, ..5 ];\n     println(v[0].to_str());"}, {"sha": "8cd2d9edbd7c0de6ac18b8d9c77dabd6f8e0e6fa", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -15,14 +15,16 @@ extern mod extra;\n use extra::glob::glob;\n use extra::tempfile::TempDir;\n use std::unstable::finally::Finally;\n-use std::{io, os, unstable};\n+use std::{os, unstable};\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n \n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n             os::make_dir(&Path::new(path), 0xFFFF);\n         } else {\n-            io::mk_file_writer(&Path::new(path), [io::Create]);\n+            Path::new(path).open_writer(io::Create);\n         }\n     }\n "}, {"sha": "5a3b177aadcd2786019f855fa80165b399f511a9", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -16,8 +16,7 @@\n \n extern mod extra;\n \n-use std::io::ReaderUtil;\n-use std::io;\n+use std::rt::io;\n use std::to_str;\n \n enum square {\n@@ -64,16 +63,15 @@ fn square_from_char(c: char) -> square {\n }\n \n fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n-    let input = @input as @io::Reader;\n+    let input = @mut input as @mut io::Reader;\n     let mut grid = ~[];\n-    do input.each_line |line| {\n-        let mut row = ~[];\n-        for c in line.iter() {\n-            row.push(square_from_char(c))\n-        }\n-        grid.push(row);\n-        true\n-    };\n+    let mut line = [0, ..10];\n+    input.read(line);\n+    let mut row = ~[];\n+    for c in line.iter() {\n+        row.push(square_from_char(*c as char))\n+    }\n+    grid.push(row);\n     let width = grid[0].len();\n     for row in grid.iter() { assert!(row.len() == width) }\n     grid"}, {"sha": "e092d45ce68c8a4c97b7ef8b5ad077721b2d737d", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,9 +12,6 @@\n \n extern mod extra;\n \n-use std::io::WriterUtil;\n-use std::io;\n-\n enum Token {\n         Text(@~str),\n         ETag(@~[~str], @~str),\n@@ -28,8 +25,7 @@ fn check_strs(actual: &str, expected: &str) -> bool\n {\n         if actual != expected\n         {\n-            io::stderr().write_line(format!(\"Found {}, but expected {}\", actual,\n-                                            expected));\n+            println!(\"Found {}, but expected {}\", actual, expected);\n             return false;\n         }\n         return true;"}, {"sha": "ba92434ba69af6f12798d32e2da4a9c633655797", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,13 +13,11 @@\n // rustc --test map_to_str.rs && ./map_to_str\n extern mod extra;\n \n-use std::io::{WriterUtil};\n-\n fn check_strs(actual: &str, expected: &str) -> bool\n {\n     if actual != expected\n     {\n-        io::stderr().write_line(fmt!(\"Found %s, but expected %s\", actual, expected));\n+        println!(\"Found %s, but expected %s\", actual, expected);\n         return false;\n     }\n     return true;"}, {"sha": "50d6a3ae6b8db4b209cd3328ebe6325a12b9f669", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -20,8 +20,6 @@ extern mod extra;\n \n // Extern mod controls linkage. Use controls the visibility of names to modules that are\n // already linked in. Using WriterUtil allows us to use the write_line method.\n-use std::io::WriterUtil;\n-use std::io;\n use std::str;\n use std::vec;\n \n@@ -150,7 +148,7 @@ impl Canvas for AsciiArt {\n // this little helper.\n pub fn check_strs(actual: &str, expected: &str) -> bool {\n     if actual != expected {\n-        io::stderr().write_line(format!(\"Found:\\n{}\\nbut expected\\n{}\", actual, expected));\n+        println!(\"Found:\\n{}\\nbut expected\\n{}\", actual, expected);\n         return false;\n     }\n     return true;"}, {"sha": "86cef39abc81f5b023e25676789b57e6861d74ef", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::rt::io;\n \n pub fn main() {\n-    let stdout = &io::stdout() as &io::WriterUtil;\n-    stdout.write_line(\"Hello!\");\n+    let stdout = &mut io::stdout() as &mut io::Writer;\n+    stdout.write(bytes!(\"Hello!\"));\n }"}, {"sha": "32e13f5ac7f461051ab276acd0b30d09bfdc3549", "filename": "src/test/run-pass/issue-4541.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4541.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n fn parse_args() -> ~str {\n     let args = ::std::os::args();\n     let mut n = 0;\n@@ -28,5 +26,5 @@ fn parse_args() -> ~str {\n }\n \n pub fn main() {\n-    io::println(parse_args());\n+    println(parse_args());\n }"}, {"sha": "7b96d5a48b9fdcf1a6d4a61522ab309d889b2d6d", "filename": "src/test/run-pass/issue-5060.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5060.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,17 +10,15 @@\n \n #[feature(macro_rules)];\n \n-use std::io;\n-\n macro_rules! print_hd_tl (\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n-        io::print(stringify!($field_hd));\n-        io::print(\"::[\");\n+        print(stringify!($field_hd));\n+        print(\"::[\");\n         $(\n-            io::print(stringify!($field_tl));\n-            io::print(\", \");\n+            print(stringify!($field_tl));\n+            print(\", \");\n         )+\n-        io::print(\"]\\n\");\n+        print(\"]\\n\");\n     })\n )\n "}, {"sha": "4282e7acf19b123844419b98c94cf3c16cbea0ec", "filename": "src/test/run-pass/issue-5741.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-5741.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-5741.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5741.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -10,9 +10,7 @@\n \n #[allow(unreachable_code)];\n \n-use std::io;\n-\n pub fn main() {\n     return;\n-    while io::stdin().read_line() != ~\"quit\" { };\n+    while true {};\n }"}, {"sha": "247b74e4643122bb8373a6e448f775e0c43ddb2a", "filename": "src/test/run-pass/issue-8498.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8498.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n // xfail-test\n-use std::io;\n \n fn main() {\n // This is ok\n     match &[(~5,~7)] {\n         ps => {\n            let (ref y, _) = ps[0];\n-           io::println(fmt!(\"1. y = %d\", **y));\n+           println(fmt!(\"1. y = %d\", **y));\n            assert!(**y == 5);\n         }\n     }\n@@ -25,8 +24,8 @@ fn main() {\n     match Some(&[(~5,)]) {\n         Some(ps) => {\n            let (ref y,) = ps[0];\n-           io::println(fmt!(\"2. y = %d\", **y));\n-           if **y != 5 { io::println(\"sadness\"); }\n+           println(fmt!(\"2. y = %d\", **y));\n+           if **y != 5 { println(\"sadness\"); }\n         }\n         None => ()\n     }\n@@ -35,7 +34,7 @@ fn main() {\n     match Some(&[(~5,~7)]) {\n         Some(ps) => {\n            let (ref y, ref z) = ps[0];\n-           io::println(fmt!(\"3. y = %d z = %d\", **y, **z));\n+           println(fmt!(\"3. y = %d z = %d\", **y, **z));\n            assert!(**y == 5);\n         }\n         None => ()"}, {"sha": "0580bc938d7d424be1b3b9b001f8c2d8ea93c764", "filename": "src/test/run-pass/match-drop-strs-issue-4541.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -2,7 +2,6 @@\n // copying, and moving to ensure that we don't segfault\n // or double-free, as we were wont to do in the past.\n \n-use std::io;\n use std::os;\n \n fn parse_args() -> ~str {\n@@ -23,5 +22,5 @@ fn parse_args() -> ~str {\n }\n \n pub fn main() {\n-    io::println(parse_args());\n+    println(parse_args());\n }"}, {"sha": "5e03b47d1b1dcc1fcb6332e930ed478aeecfb45b", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::io;\n-\n trait Serializer {\n }\n \n@@ -33,15 +31,13 @@ impl<A:Serializable> Serializable for F<A> {\n     }\n }\n \n-impl Serializer for @io::Writer {\n+impl Serializer for int {\n }\n \n pub fn main() {\n-    do io::with_str_writer |wr| {\n-        let foo = F { a: 1 };\n-        foo.serialize(wr);\n+    let foo = F { a: 1 };\n+    foo.serialize(1i);\n \n-        let bar = F { a: F {a: 1 } };\n-        bar.serialize(wr);\n-    };\n+    let bar = F { a: F {a: 1 } };\n+    bar.serialize(2i);\n }"}, {"sha": "ef59606afe347e03d5e6d1b663975d692736926c", "filename": "src/test/run-pass/new-import-syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::println;\n-\n pub fn main() {\n     println(\"Hello world!\");\n }"}, {"sha": "fa681c81398fecfa1cedaa55739b3bfed5b8b007", "filename": "src/test/run-pass/new-style-constants.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::println;\n-\n static FOO: int = 3;\n \n pub fn main() {"}, {"sha": "14595f83ce506a1d3c950f71b9233b5be9b07690", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -25,7 +25,6 @@\n \n use std::rt::io::process::{Process, ProcessConfig, CreatePipe, Ignored};\n use std::rt::io::{Reader, Writer};\n-use std::rt::io::pipe::PipeStream;\n use std::str;\n \n #[test]\n@@ -105,8 +104,7 @@ fn run_output(args: ProcessConfig) -> ~str {\n #[test]\n #[cfg(unix, not(target_os=\"android\"))]\n fn stdout_works() {\n-    let pipe = PipeStream::new().unwrap();\n-    let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+    let io = ~[Ignored, CreatePipe(false, true)];\n     let args = ProcessConfig {\n         program: \"/bin/sh\",\n         args: [~\"-c\", ~\"echo foobar\"],\n@@ -120,8 +118,7 @@ fn stdout_works() {\n #[test]\n #[cfg(unix, not(target_os=\"android\"))]\n fn set_cwd_works() {\n-    let pipe = PipeStream::new().unwrap();\n-    let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+    let io = ~[Ignored, CreatePipe(false, true)];\n     let cwd = Some(\"/\");\n     let args = ProcessConfig {\n         program: \"/bin/sh\",\n@@ -136,10 +133,8 @@ fn set_cwd_works() {\n #[test]\n #[cfg(unix, not(target_os=\"android\"))]\n fn stdin_works() {\n-    let input = PipeStream::new().unwrap();\n-    let output = PipeStream::new().unwrap();\n-    let io = ~[CreatePipe(input, true, false),\n-               CreatePipe(output, false, true)];\n+    let io = ~[CreatePipe(true, false),\n+               CreatePipe(false, true)];\n     let args = ProcessConfig {\n         program: \"/bin/sh\",\n         args: [~\"-c\", ~\"read line; echo $line\"],"}, {"sha": "85cf265c2d0e861223259f097a7c1b45bab3a5a3", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -13,20 +13,22 @@\n extern mod extra;\n \n use extra::tempfile;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use std::os;\n \n pub fn main() {\n     let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {\n-        match io::file_writer(&path, [io::Create, io::Truncate]) {\n-            Err(ref e) => fail!(\"{}\", e.clone()),\n-            Ok(f) => {\n+        match path.open_writer(io::CreateOrTruncate) {\n+            None => unreachable!(),\n+            Some(f) => {\n+                let mut f = f;\n                 for _ in range(0u, 1000) {\n-                    f.write_u8(0);\n+                    f.write([0]);\n                 }\n             }\n         }"}, {"sha": "c8f2afe8c6171351e223242efcebed36db317c0b", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5b2219cc893b30863f9136703166f306fcc684/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=3f5b2219cc893b30863f9136703166f306fcc684", "patch": "@@ -11,8 +11,6 @@\n // except according to those terms.\n \n mod base {\n-    use std::io;\n-\n     pub trait HasNew<T> {\n         fn new() -> Self;\n     }\n@@ -34,7 +32,7 @@ mod base {\n \n     impl ::base::HasNew<Bar> for Bar {\n         fn new() -> Bar {\n-            io::println(\"Bar\");\n+            println(\"Bar\");\n             Bar { dummy: () }\n         }\n     }"}]}