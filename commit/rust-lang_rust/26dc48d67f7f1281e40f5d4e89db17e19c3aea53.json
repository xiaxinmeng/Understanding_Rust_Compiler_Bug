{"sha": "26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZGM0OGQ2N2Y3ZjEyODFlNDBmNWQ0ZTg5ZGIxN2UxOWMzYWVhNTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-15T15:29:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-15T20:38:29Z"}, "message": "break apart typeck a little (more to come)", "tree": {"sha": "f16759eaecb74ced53f9a793e2e4d9b15924445c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f16759eaecb74ced53f9a793e2e4d9b15924445c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "html_url": "https://github.com/rust-lang/rust/commit/26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adb61e3e992aa6539dd178f8b2c2f55aca942b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/adb61e3e992aa6539dd178f8b2c2f55aca942b16", "html_url": "https://github.com/rust-lang/rust/commit/adb61e3e992aa6539dd178f8b2c2f55aca942b16"}], "stats": {"total": 3031, "additions": 1531, "deletions": 1500}, "files": [{"sha": "f5f82bf26900fafc7677cde51317ee744cf0f16b", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 1499, "changes": 1515, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -27,6 +27,11 @@ import util::common::{indent, indenter};\n import std::list;\n import list::{list, nil, cons};\n \n+// from internal typeck modules:\n+import astconv::{ast_ty_to_ty, in_anon_rscope,\n+                 ast_region_to_region, region_scope,\n+                 ast_conv};\n+\n export check_crate;\n export method_map;\n export method_origin, serialize_method_origin, deserialize_method_origin;\n@@ -329,11 +334,12 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       }\n       ast::vstore_uniq { ty::vstore_uniq }\n       ast::vstore_box { ty::vstore_box }\n-      ast::vstore_slice(r) {\n+      ast::vstore_slice(a_r) {\n         alt fcx.block_region() {\n           result::ok(b_r) {\n             let rscope = in_anon_rscope(fcx, b_r);\n-            ty::vstore_slice(ast_region_to_region(fcx, rscope, e.span, r))\n+            let r = astconv::ast_region_to_region(fcx, rscope, e.span, a_r);\n+            ty::vstore_slice(r)\n           }\n           result::err(msg) {\n             fcx.ccx.tcx.sess.span_err(e.span, msg);\n@@ -344,142 +350,6 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n     }\n }\n \n-iface ast_conv {\n-    fn tcx() -> ty::ctxt;\n-    fn ccx() -> @crate_ctxt;\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n-\n-    // what type should we use when a type is omitted?\n-    fn ty_infer(span: span) -> ty::t;\n-}\n-\n-impl of ast_conv for @crate_ctxt {\n-    fn tcx() -> ty::ctxt { self.tcx }\n-    fn ccx() -> @crate_ctxt { self }\n-\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        if id.crate != ast::local_crate {\n-            csearch::get_type(self.tcx, id)\n-        } else {\n-            alt self.tcx.items.find(id.node) {\n-              some(ast_map::node_item(item, _)) {\n-                ty_of_item(self, item)\n-              }\n-              some(ast_map::node_native_item(native_item, _, _)) {\n-                ty_of_native_item(self, native_item)\n-              }\n-              x {\n-                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", x]);\n-              }\n-            }\n-        }\n-    }\n-\n-    fn ty_infer(span: span) -> ty::t {\n-        self.tcx.sess.span_bug(span,\n-                               \"found `ty_infer` in unexpected place\");\n-    }\n-}\n-\n-impl of ast_conv for @fn_ctxt {\n-    fn tcx() -> ty::ctxt { self.ccx.tcx }\n-    fn ccx() -> @crate_ctxt { self.ccx }\n-\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        ty::lookup_item_type(self.tcx(), id)\n-    }\n-\n-    fn ty_infer(_span: span) -> ty::t {\n-        self.next_ty_var()\n-    }\n-}\n-\n-iface region_scope {\n-    fn anon_region() -> result<ty::region, str>;\n-    fn named_region(id: str) -> result<ty::region, str>;\n-}\n-\n-enum empty_rscope { empty_rscope }\n-impl of region_scope for empty_rscope {\n-    fn anon_region() -> result<ty::region, str> {\n-        result::err(\"region types are not allowed here\")\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        if id == \"static\" { result::ok(ty::re_static) }\n-        else { result::err(\"only the static region is allowed here\") }\n-    }\n-}\n-\n-enum type_rscope = ast::region_param;\n-impl of region_scope for type_rscope {\n-    fn anon_region() -> result<ty::region, str> {\n-        alt *self {\n-          ast::rp_self { result::ok(ty::re_bound(ty::br_self)) }\n-          ast::rp_none {\n-            result::err(\"to use region types here, the containing type \\\n-                         must be declared with a region bound\")\n-          }\n-        }\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        empty_rscope.named_region(id).chain_err { |_e|\n-            if id == \"self\" { self.anon_region() }\n-            else {\n-                result::err(\"named regions other than `self` are not \\\n-                             allowed as part of a type declaration\")\n-            }\n-        }\n-    }\n-}\n-\n-impl of region_scope for @fn_ctxt {\n-    fn anon_region() -> result<ty::region, str> {\n-        result::ok(self.next_region_var())\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        empty_rscope.named_region(id).chain_err { |_e|\n-            alt self.in_scope_regions.find(ty::br_named(id)) {\n-              some(r) { result::ok(r) }\n-              none if id == \"blk\" { self.block_region() }\n-              none {\n-                result::err(#fmt[\"named region `%s` not in scope here\", id])\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-enum anon_rscope = {anon: ty::region, base: region_scope};\n-fn in_anon_rscope<RS: region_scope copy>(self: RS, r: ty::region)\n-    -> @anon_rscope {\n-    @anon_rscope({anon: r, base: self as region_scope})\n-}\n-impl of region_scope for @anon_rscope {\n-    fn anon_region() -> result<ty::region, str> {\n-        result::ok(self.anon)\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        self.base.named_region(id)\n-    }\n-}\n-\n-enum binding_rscope = {base: region_scope};\n-fn in_binding_rscope<RS: region_scope copy>(self: RS) -> @binding_rscope {\n-    let base = self as region_scope;\n-    @binding_rscope({base: base})\n-}\n-impl of region_scope for @binding_rscope {\n-    fn anon_region() -> result<ty::region, str> {\n-        result::ok(ty::re_bound(ty::br_anon))\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        self.base.named_region(id).chain_err {|_e|\n-            result::ok(ty::re_bound(ty::br_named(id)))\n-        }\n-    }\n-}\n-\n fn get_region_reporting_err(tcx: ty::ctxt,\n                             span: span,\n                             res: result<ty::region, str>) -> ty::region {\n@@ -493,321 +363,6 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n-    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n-\n-    let res = alt a_r.node {\n-      ast::re_anon { rscope.anon_region() }\n-      ast::re_named(id) { rscope.named_region(id) }\n-    };\n-\n-    get_region_reporting_err(self.tcx(), span, res)\n-}\n-\n-fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, did: ast::def_id,\n-    path: @ast::path) -> ty_param_substs_and_ty {\n-\n-    let tcx = self.tcx();\n-    let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n-        self.get_item_ty(did);\n-\n-    // If the type is parameterized by the self region, then replace self\n-    // region with the current anon region binding (in other words,\n-    // whatever & would get replaced with).\n-    let self_r = alt (decl_rp, path.rp) {\n-      (ast::rp_none, none) {\n-        none\n-      }\n-      (ast::rp_none, some(_)) {\n-        tcx.sess.span_err(\n-            path.span,\n-            #fmt[\"No region bound is permitted on %s, \\\n-                  which is not declared as containing region pointers\",\n-                 ty::item_path_str(tcx, did)]);\n-        none\n-      }\n-      (ast::rp_self, none) {\n-        let res = rscope.anon_region();\n-        let r = get_region_reporting_err(self.tcx(), path.span, res);\n-        some(r)\n-      }\n-      (ast::rp_self, some(r)) {\n-        some(ast_region_to_region(self, rscope, path.span, r))\n-      }\n-    };\n-\n-    // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_bounds, path.types) {\n-        self.tcx().sess.span_fatal(\n-            path.span,\n-            #fmt[\"wrong number of type arguments, expected %u but found %u\",\n-                 (*decl_bounds).len(), path.types.len()]);\n-    }\n-    let tps = path.types.map { |a_t| ast_ty_to_ty(self, rscope, a_t) };\n-\n-    let substs = {self_r:self_r, self_ty:none, tps:tps};\n-    {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n-}\n-\n-fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy>(\n-    self: AC,\n-    rscope: RS,\n-    did: ast::def_id,\n-    path: @ast::path,\n-    path_id: ast::node_id) -> ty_param_substs_and_ty {\n-\n-    // Lookup the polytype of the item and then substitute the provided types\n-    // for any type/region parameters.\n-    let tcx = self.tcx();\n-    let {substs: substs, ty: ty} =\n-        ast_path_to_substs_and_ty(self, rscope, did, path);\n-    write_ty_to_tcx(tcx, path_id, ty);\n-    write_substs_to_tcx(tcx, path_id, substs.tps);\n-    ret {substs: substs, ty: ty};\n-}\n-\n-/*\n-  Instantiates the path for the given iface reference, assuming that\n-  it's bound to a valid iface type. Returns the def_id for the defining\n-  iface. Fails if the type is a type other than an iface type.\n- */\n-fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n-                         rp: ast::region_param)\n-    -> (ast::def_id, ty_param_substs_and_ty) {\n-\n-    let sp = t.path.span, err = \"can only implement interface types\",\n-        sess = ccx.tcx.sess;\n-\n-    let rscope = type_rscope(rp);\n-\n-    alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n-      ast::def_ty(t_id) {\n-        let tpt = ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n-        alt ty::get(tpt.ty).struct {\n-           ty::ty_iface(*) {\n-              (t_id, tpt)\n-           }\n-           _ { sess.span_fatal(sp, err); }\n-        }\n-      }\n-      _ {\n-          sess.span_fatal(sp, err);\n-      }\n-    }\n-}\n-\n-const NO_REGIONS: uint = 1u;\n-const NO_TPS: uint = 2u;\n-\n-// Parses the programmer's textual representation of a type into our\n-// internal notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n-fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n-\n-    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy>(\n-        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n-\n-        ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n-    }\n-\n-    fn mk_vstore<AC: ast_conv, RS: region_scope copy>(\n-        self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n-\n-        let tcx = self.tcx();\n-        let seq_ty = ast_ty_to_ty(self, rscope, a_seq_ty);\n-\n-        alt ty::get(seq_ty).struct {\n-          ty::ty_vec(mt) {\n-            ret ty::mk_evec(tcx, mt, vst);\n-          }\n-\n-          ty::ty_str {\n-            ret ty::mk_estr(tcx, vst);\n-          }\n-\n-          _ {\n-            tcx.sess.span_err(\n-                a_seq_ty.span,\n-                #fmt[\"Bound not allowed on a %s.\",\n-                     ty::ty_sort_str(tcx, seq_ty)]);\n-            ret seq_ty;\n-          }\n-        }\n-    }\n-\n-    fn check_path_args(tcx: ty::ctxt,\n-                       path: @ast::path,\n-                       flags: uint) {\n-        if (flags & NO_TPS) != 0u {\n-            if path.types.len() > 0u {\n-                tcx.sess.span_err(\n-                    path.span,\n-                    \"Type parameters are not allowed on this type.\");\n-            }\n-        }\n-\n-        if (flags & NO_REGIONS) != 0u {\n-            if path.rp.is_some() {\n-                tcx.sess.span_err(\n-                    path.span,\n-                    \"Region parameters are not allowed on this type.\");\n-            }\n-        }\n-    }\n-\n-    let tcx = self.tcx();\n-\n-    alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n-      some(ty::atttce_resolved(ty)) { ret ty; }\n-      some(ty::atttce_unresolved) {\n-        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n-                                          insert a enum in the cycle, \\\n-                                          if this is desired)\");\n-      }\n-      none { /* go on */ }\n-    }\n-\n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n-    let typ = alt ast_ty.node {\n-      ast::ty_nil { ty::mk_nil(tcx) }\n-      ast::ty_bot { ty::mk_bot(tcx) }\n-      ast::ty_box(mt) {\n-        ty::mk_box(tcx, ast_mt_to_mt(self, rscope, mt))\n-      }\n-      ast::ty_uniq(mt) {\n-        ty::mk_uniq(tcx, ast_mt_to_mt(self, rscope, mt))\n-      }\n-      ast::ty_vec(mt) {\n-        ty::mk_vec(tcx, ast_mt_to_mt(self, rscope, mt))\n-      }\n-      ast::ty_ptr(mt) {\n-        ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n-      }\n-      ast::ty_rptr(region, mt) {\n-        let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        let mt = ast_mt_to_mt(self, in_anon_rscope(rscope, r), mt);\n-        ty::mk_rptr(tcx, r, mt)\n-      }\n-      ast::ty_tup(fields) {\n-        let flds = vec::map(fields) { |t| ast_ty_to_ty(self, rscope, t) };\n-        ty::mk_tup(tcx, flds)\n-      }\n-      ast::ty_rec(fields) {\n-        let flds = fields.map {|f|\n-            let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n-            {ident: f.node.ident, mt: tm}\n-        };\n-        ty::mk_rec(tcx, flds)\n-      }\n-      ast::ty_fn(proto, decl) {\n-        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl, none))\n-      }\n-      ast::ty_path(path, id) {\n-        let a_def = alt tcx.def_map.find(id) {\n-          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n-                                                       path_to_str(path))); }\n-          some(d) { d }};\n-        alt a_def {\n-          ast::def_ty(did) | ast::def_class(did) {\n-            ast_path_to_ty(self, rscope, did, path, id).ty\n-          }\n-          ast::def_prim_ty(nty) {\n-            alt nty {\n-              ast::ty_bool {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_bool(tcx)\n-              }\n-              ast::ty_int(it) {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_int(tcx, it)\n-              }\n-              ast::ty_uint(uit) {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_uint(tcx, uit)\n-              }\n-              ast::ty_float(ft) {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_float(tcx, ft)\n-              }\n-              ast::ty_str {\n-                check_path_args(tcx, path, NO_TPS);\n-                // This is a bit of a hack, but basically str/& needs to be\n-                // converted into a vstore:\n-                alt path.rp {\n-                  none {\n-                    ty::mk_str(tcx)\n-                  }\n-                  some(ast_r) {\n-                    let r = ast_region_to_region(self, rscope,\n-                                                 ast_ty.span, ast_r);\n-                    ty::mk_estr(tcx, ty::vstore_slice(r))\n-                  }\n-                }\n-              }\n-            }\n-          }\n-          ast::def_ty_param(id, n) {\n-            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-            ty::mk_param(tcx, n, id)\n-          }\n-          ast::def_self(_) {\n-            // n.b.: resolve guarantees that the self type only appears in an\n-            // iface, which we rely upon in various places when creating\n-            // substs\n-            ty::mk_self(tcx)\n-          }\n-          _ {\n-            tcx.sess.span_fatal(ast_ty.span,\n-                                \"found type name used as a variable\");\n-          }\n-        }\n-      }\n-      ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n-        let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n-        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n-      }\n-      ast::ty_vstore(a_t, ast::vstore_uniq) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n-      }\n-      ast::ty_vstore(a_t, ast::vstore_box) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_box)\n-      }\n-      ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n-      }\n-      ast::ty_vstore(_, ast::vstore_fixed(none)) {\n-        tcx.sess.span_bug(\n-            ast_ty.span,\n-            \"implied fixed length for bound\");\n-      }\n-      ast::ty_constr(t, cs) {\n-        let mut out_cs = [];\n-        for cs.each {|constr|\n-            out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n-        }\n-        ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n-      }\n-      ast::ty_infer {\n-        // ty_infer should only appear as the type of arguments or return\n-        // values in a fn_expr, or as the type of local variables.  Both of\n-        // these cases are handled specially and should not descend into this\n-        // routine.\n-        self.tcx().sess.span_bug(\n-            ast_ty.span,\n-            \"found `ty_infer` in unexpected place\");\n-      }\n-      ast::ty_mac(_) {\n-        tcx.sess.span_bug(ast_ty.span,\n-                          \"found `ty_mac` in unexpected place\");\n-      }\n-    };\n-\n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n-    ret typ;\n-}\n-\n fn check_bounds_are_used(ccx: @crate_ctxt,\n                          span: span,\n                          tps: [ast::ty_param],\n@@ -851,102 +406,6 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     }\n }\n \n-fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n-    -> ty::ty_param_bounds_and_ty {\n-\n-    let def_id = local_def(it.id);\n-    let tcx = ccx.tcx;\n-    alt tcx.tcache.find(def_id) {\n-      some(tpt) { ret tpt; }\n-      _ {}\n-    }\n-    alt it.node {\n-      ast::item_const(t, _) {\n-        let typ = ccx.to_ty(empty_rscope, t);\n-        let tpt = no_params(typ);\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_fn(decl, tps, _) {\n-        let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n-                                 decl, none);\n-        let tpt = {bounds: bounds,\n-                   rp: ast::rp_none, // functions do not have a self\n-                   ty: ty::mk_fn(ccx.tcx, tofd)};\n-        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_ty(t, tps, rp) {\n-        alt tcx.tcache.find(local_def(it.id)) {\n-          some(tpt) { ret tpt; }\n-          none { }\n-        }\n-\n-        let tpt = {\n-            let ty = {\n-                let t0 = ccx.to_ty(type_rscope(rp), t);\n-                // Do not associate a def id with a named, parameterized type\n-                // like \"foo<X>\".  This is because otherwise ty_to_str will\n-                // print the name as merely \"foo\", as it has no way to\n-                // reconstruct the value of X.\n-                if !vec::is_empty(tps) { t0 } else {\n-                    ty::mk_with_id(tcx, t0, def_id)\n-                }\n-            };\n-            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n-        };\n-\n-        check_bounds_are_used(ccx, t.span, tps, rp, tpt.ty);\n-\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_res(decl, tps, _, _, _, rp) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                              decl.inputs[0], none);\n-        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n-        let t_res = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), t_res);\n-        ret t_res;\n-      }\n-      ast::item_enum(_, tps, rp) {\n-        // Create a new generic polytype.\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_iface(tps, rp, ms) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_class(tps, _, _, _, _, rp) {\n-          let {bounds,substs} = mk_substs(ccx, tps, rp);\n-          let t = ty::mk_class(tcx, local_def(it.id), substs);\n-          let tpt = {bounds: bounds, rp: rp, ty: t};\n-          tcx.tcache.insert(local_def(it.id), tpt);\n-          ret tpt;\n-      }\n-      ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_native_mod(_) { fail; }\n-    }\n-}\n-fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n-    -> ty::ty_param_bounds_and_ty {\n-    alt it.node {\n-      ast::native_item_fn(fn_decl, params) {\n-        ret ty_of_native_fn_decl(ccx, fn_decl, params,\n-                                 local_def(it.id));\n-      }\n-    }\n-}\n-\n type next_region_param_id = { mut id: uint };\n \n fn collect_bound_regions_in_tys(\n@@ -1047,166 +506,6 @@ fn replace_bound_regions(\n     }\n }\n \n-fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, a: ast::arg,\n-    expected_ty: option<ty::arg>) -> ty::arg {\n-\n-    let ty = alt a.ty.node {\n-      ast::ty_infer if expected_ty.is_some() {expected_ty.get().ty}\n-      ast::ty_infer {self.ty_infer(a.ty.span)}\n-      _ {ast_ty_to_ty(self, rscope, a.ty)}\n-    };\n-\n-    let mode = {\n-        alt a.mode {\n-          ast::infer(_) if expected_ty.is_some() {\n-            result::get(ty::unify_mode(self.tcx(), a.mode,\n-                                       expected_ty.get().mode))\n-          }\n-          ast::infer(_) {\n-            alt ty::get(ty).struct {\n-              // If the type is not specified, then this must be a fn expr.\n-              // Leave the mode as infer(_), it will get inferred based\n-              // on constraints elsewhere.\n-              ty::ty_var(_) {a.mode}\n-\n-              // If the type is known, then use the default for that type.\n-              // Here we unify m and the default.  This should update the\n-              // tables in tcx but should never fail, because nothing else\n-              // will have been unified with m yet:\n-              _ {\n-                let m1 = ast::expl(ty::default_arg_mode_for_ty(ty));\n-                result::get(ty::unify_mode(self.tcx(), a.mode, m1))\n-              }\n-            }\n-          }\n-          ast::expl(_) {a.mode}\n-        }\n-    };\n-\n-    {mode: mode, ty: ty}\n-}\n-\n-type expected_tys = option<{inputs: [ty::arg],\n-                            output: ty::t}>;\n-\n-fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS,\n-    proto: ast::proto,\n-    decl: ast::fn_decl,\n-    expected_tys: expected_tys) -> ty::fn_ty {\n-\n-    #debug[\"ty_of_fn_decl\"];\n-    indent {||\n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = in_binding_rscope(rscope);\n-\n-        let input_tys = decl.inputs.mapi { |i, a|\n-            let expected_arg_ty = expected_tys.chain { |e|\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs.len() {some(e.inputs[i])} else {none}\n-            };\n-            ty_of_arg(self, rb, a, expected_arg_ty)\n-        };\n-\n-        let expected_ret_ty = expected_tys.map { |e| e.output };\n-        let output_ty = alt decl.output.node {\n-          ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n-          ast::ty_infer {self.ty_infer(decl.output.span)}\n-          _ {ast_ty_to_ty(self, rb, decl.output)}\n-        };\n-\n-        let out_constrs = vec::map(decl.constraints) {|constr|\n-            ty::ast_constr_to_constr(self.tcx(), constr)\n-        };\n-        {proto: proto, inputs: input_tys,\n-         output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n-    }\n-}\n-\n-fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n-                        decl: ast::fn_decl,\n-                        ty_params: [ast::ty_param],\n-                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-\n-    let bounds = ty_param_bounds(ccx, ty_params);\n-    let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n-    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n-\n-    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n-                                   inputs: input_tys,\n-                                   output: output_ty,\n-                                   ret_style: ast::return_val,\n-                                   constraints: []});\n-    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n-    ccx.tcx.tcache.insert(def_id, tpt);\n-    ret tpt;\n-}\n-\n-fn ty_param_bounds(ccx: @crate_ctxt,\n-                   params: [ast::ty_param]) -> @[ty::param_bounds] {\n-\n-    fn compute_bounds(ccx: @crate_ctxt,\n-                      param: ast::ty_param) -> ty::param_bounds {\n-        @vec::flat_map(*param.bounds) { |b|\n-            alt b {\n-              ast::bound_send { [ty::bound_send] }\n-              ast::bound_copy { [ty::bound_copy] }\n-              ast::bound_iface(t) {\n-                let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n-                alt ty::get(ity).struct {\n-                  ty::ty_iface(*) {\n-                    [ty::bound_iface(ity)]\n-                  }\n-                  _ {\n-                    ccx.tcx.sess.span_err(\n-                        t.span, \"type parameter bounds must be \\\n-                                 interface types\");\n-                    []\n-                  }\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    @params.map { |param|\n-        alt ccx.tcx.ty_param_bounds.find(param.id) {\n-          some(bs) { bs }\n-          none {\n-            let bounds = compute_bounds(ccx, param);\n-            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n-            bounds\n-          }\n-        }\n-    }\n-}\n-\n-fn ty_of_method(ccx: @crate_ctxt,\n-                m: @ast::method,\n-                rp: ast::region_param) -> ty::method {\n-    {ident: m.ident,\n-     tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n-                        m.decl, none),\n-     purity: m.decl.purity,\n-     vis: m.vis}\n-}\n-\n-fn ty_of_ty_method(self: @crate_ctxt,\n-                   m: ast::ty_method,\n-                   rp: ast::region_param) -> ty::method {\n-    {ident: m.ident,\n-     tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n-                        m.decl, none),\n-     // assume public, because this is only invoked on iface methods\n-     purity: m.decl.purity, vis: ast::public}\n-}\n-\n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     #debug[\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)];\n@@ -1365,7 +664,7 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n     -> {bounds: @[ty::param_bounds], params: [ty::t]} {\n \n     let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, atps);\n+    let bounds = astconv::ty_param_bounds(ccx, atps);\n     {bounds: bounds,\n      params: vec::map(atps, {|atp|\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n@@ -1430,326 +729,6 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n     }\n }\n \n-// Item collection - a pair of bootstrap passes:\n-//\n-// (1) Collect the IDs of all type items (typedefs) and store them in a table.\n-//\n-// (2) Translate the AST fragments that describe types to determine a type for\n-//     each item. When we encounter a named type, we consult the table built\n-//     in pass 1 to find its item, and recursively translate it.\n-//\n-// We then annotate the AST with the resulting types and return the annotated\n-// AST, along with a table mapping item IDs to their types.\n-mod collect {\n-    fn get_enum_variant_types(ccx: @crate_ctxt,\n-                              enum_ty: ty::t,\n-                              variants: [ast::variant],\n-                              ty_params: [ast::ty_param],\n-                              rp: ast::region_param) {\n-        let tcx = ccx.tcx;\n-\n-        // Create a set of parameter types shared among all the variants.\n-        for variants.each {|variant|\n-            // Nullary enum constructors get turned into constants; n-ary enum\n-            // constructors get turned into functions.\n-            let result_ty = if vec::len(variant.node.args) == 0u {\n-                enum_ty\n-            } else {\n-                let rs = type_rscope(rp);\n-                let args = variant.node.args.map { |va|\n-                    let arg_ty = ccx.to_ty(rs, va.ty);\n-                    {mode: ast::expl(ast::by_copy), ty: arg_ty}\n-                };\n-                ty::mk_fn(tcx, {proto: ast::proto_box,\n-                                inputs: args,\n-                                output: enum_ty,\n-                                ret_style: ast::return_val,\n-                                constraints: []})\n-            };\n-            let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                       rp: rp,\n-                       ty: result_ty};\n-            tcx.tcache.insert(local_def(variant.node.id), tpt);\n-            write_ty_to_tcx(tcx, variant.node.id, result_ty);\n-        }\n-    }\n-\n-    fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n-        fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n-                            stuff: [T], f: fn@(T) -> ty::method) {\n-            ty::store_iface_methods(ccx.tcx, id, @vec::map(stuff, f));\n-        }\n-\n-        let tcx = ccx.tcx;\n-        alt check tcx.items.get(id) {\n-          ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n-              store_methods::<ast::ty_method>(ccx, id, ms) {|m|\n-                  ty_of_ty_method(ccx, m, rp)\n-              };\n-          }\n-          ast_map::node_item(@{node: ast::item_class(_,_,its,_,_,rp), _}, _) {\n-              let (_,ms) = split_class_items(its);\n-              // All methods need to be stored, since lookup_method\n-              // relies on the same method cache for self-calls\n-              store_methods::<@ast::method>(ccx, id, ms) {|m|\n-                  ty_of_method(ccx, m, rp)\n-              };\n-          }\n-        }\n-    }\n-\n-    fn check_methods_against_iface(ccx: @crate_ctxt,\n-                                   tps: [ast::ty_param],\n-                                   rp: ast::region_param,\n-                                   selfty: ty::t,\n-                                   a_ifacety: @ast::iface_ref,\n-                                   ms: [@ast::method]) {\n-\n-        let tcx = ccx.tcx;\n-        let i_bounds = ty_param_bounds(ccx, tps);\n-        let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n-        let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n-        if did.crate == ast::local_crate {\n-            ensure_iface_methods(ccx, did.node);\n-        }\n-        for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-            alt vec::find(my_methods, {|m| if_m.ident == m.mty.ident}) {\n-              some({mty: m, id, span}) {\n-                if m.purity != if_m.purity {\n-                    ccx.tcx.sess.span_err(\n-                        span, #fmt[\"method `%s`'s purity \\\n-                                    not match the iface method's \\\n-                                    purity\", m.ident]);\n-                }\n-                let mt = compare_impl_method(\n-                    ccx.tcx, span, m, vec::len(tps),\n-                    if_m, tpt.substs, selfty);\n-                let old = tcx.tcache.get(local_def(id));\n-                if old.ty != mt {\n-                    tcx.tcache.insert(\n-                        local_def(id),\n-                        {bounds: old.bounds,\n-                         rp: old.rp,\n-                         ty: mt});\n-                    write_ty_to_tcx(tcx, id, mt);\n-                }\n-              }\n-              none {\n-                tcx.sess.span_err(\n-                    a_ifacety.path.span,\n-                    #fmt[\"missing method `%s`\", if_m.ident]);\n-              }\n-            } // alt\n-        } // |if_m|\n-    } // fn\n-\n-    fn convert_class_item(ccx: @crate_ctxt,\n-                          rp: ast::region_param,\n-                          v: ast_util::ivar) {\n-        /* we want to do something here, b/c within the\n-         scope of the class, it's ok to refer to fields &\n-        methods unqualified */\n-        /* they have these types *within the scope* of the\n-         class. outside the class, it's done with expr_field */\n-        let tt = ccx.to_ty(type_rscope(rp), v.ty);\n-        write_ty_to_tcx(ccx.tcx, v.id, tt);\n-    }\n-\n-    fn convert_methods(ccx: @crate_ctxt,\n-                       ms: [@ast::method],\n-                       rp: ast::region_param,\n-                       i_bounds: @[ty::param_bounds],\n-                       self_ty: ty::t)\n-        -> [{mty: ty::method, id: ast::node_id, span: span}] {\n-\n-        let tcx = ccx.tcx;\n-        vec::map(ms) { |m|\n-            write_ty_to_tcx(tcx, m.self_id, self_ty);\n-            let bounds = ty_param_bounds(ccx, m.tps);\n-            let mty = ty_of_method(ccx, m, rp);\n-            let fty = ty::mk_fn(tcx, mty.fty);\n-            tcx.tcache.insert(\n-                local_def(m.id),\n-                // n.b. This code is kind of sketchy (concat'ing i_bounds\n-                // with bounds), but removing *i_bounds breaks other stuff\n-                {bounds: @(*i_bounds + *bounds), rp: rp, ty: fty});\n-            write_ty_to_tcx(tcx, m.id, fty);\n-            {mty: mty, id: m.id, span: m.span}\n-        }\n-    }\n-\n-    fn convert(ccx: @crate_ctxt, it: @ast::item) {\n-        let tcx = ccx.tcx;\n-        alt it.node {\n-          // These don't define types.\n-          ast::item_mod(_) {}\n-          ast::item_native_mod(m) {\n-            if syntax::attr::native_abi(it.attrs) ==\n-               either::right(ast::native_abi_rust_intrinsic) {\n-                for m.items.each { |item| check_intrinsic_type(ccx, item); }\n-            }\n-          }\n-          ast::item_enum(variants, ty_params, rp) {\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            get_enum_variant_types(ccx, tpt.ty, variants,\n-                                   ty_params, rp);\n-          }\n-          ast::item_impl(tps, rp, ifce, selfty, ms) {\n-            let i_bounds = ty_param_bounds(ccx, tps);\n-            let selfty = ccx.to_ty(type_rscope(rp), selfty);\n-            write_ty_to_tcx(tcx, it.id, selfty);\n-            tcx.tcache.insert(local_def(it.id),\n-                              {bounds: i_bounds,\n-                               rp: rp,\n-                               ty: selfty});\n-            alt ifce {\n-              some(t) {\n-                check_methods_against_iface(\n-                    ccx, tps, rp,\n-                    selfty, t, ms);\n-              }\n-              _ {\n-                // Still have to do this to write method types\n-                // into the table\n-                convert_methods(\n-                    ccx, ms, rp,\n-                    i_bounds, selfty);\n-              }\n-            }\n-          }\n-          ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n-            let {bounds, substs} = mk_substs(ccx, tps, rp);\n-            let def_id = local_def(it.id);\n-            let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                                  decl.inputs[0], none);\n-            let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n-\n-            let t_ctor = ty::mk_fn(tcx, {\n-                proto: ast::proto_box,\n-                inputs: [{mode: ast::expl(ast::by_copy), ty: t_arg.ty}],\n-                output: t_res,\n-                ret_style: ast::return_val, constraints: []\n-            });\n-            let t_dtor = ty::mk_fn(tcx, {\n-                proto: ast::proto_box,\n-                inputs: [t_arg], output: ty::mk_nil(tcx),\n-                ret_style: ast::return_val, constraints: []\n-            });\n-            write_ty_to_tcx(tcx, it.id, t_res);\n-            write_ty_to_tcx(tcx, ctor_id, t_ctor);\n-            tcx.tcache.insert(local_def(ctor_id),\n-                              {bounds: bounds,\n-                               rp: rp,\n-                               ty: t_ctor});\n-            tcx.tcache.insert(def_id, {bounds: bounds,\n-                                       rp: rp,\n-                                       ty: t_res});\n-            write_ty_to_tcx(tcx, dtor_id, t_dtor);\n-          }\n-          ast::item_iface(*) {\n-            let tpt = ty_of_item(ccx, it);\n-            #debug[\"item_iface(it.id=%d, tpt.ty=%s)\",\n-                   it.id, ty_to_str(tcx, tpt.ty)];\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            ensure_iface_methods(ccx, it.id);\n-          }\n-          ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n-            // Write the class type\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            // Write the ctor type\n-            let t_ctor =\n-                ty::mk_fn(tcx,\n-                          ty_of_fn_decl(ccx,\n-                                        empty_rscope,\n-                                        ast::proto_any,\n-                                        ctor.node.dec,\n-                                        none));\n-            write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n-            tcx.tcache.insert(local_def(ctor.node.id),\n-                              {bounds: tpt.bounds,\n-                               rp: ast::rp_none,\n-                               ty: t_ctor});\n-            option::iter(m_dtor) {|dtor|\n-              // Write the dtor type\n-              let t_dtor = ty::mk_fn(tcx,\n-                                   // not sure about empty_rscope\n-                                   // FIXME\n-                                   ty_of_fn_decl(ccx,\n-                                                 empty_rscope,\n-                                                 ast::proto_any,\n-                                                 ast_util::dtor_dec(),\n-                                                 none));\n-              write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n-              tcx.tcache.insert(local_def(dtor.node.id),\n-                                {bounds: tpt.bounds,\n-                                 rp: ast::rp_none,\n-                                 ty: t_dtor});\n-            };\n-            ensure_iface_methods(ccx, it.id);\n-            /* FIXME: check for proper public/privateness */\n-            // Write the type of each of the members\n-            let (fields, methods) = split_class_items(members);\n-            for fields.each {|f|\n-                convert_class_item(ccx, rp, f);\n-            }\n-            // The selfty is just the class type\n-            let {bounds:_, substs} = mk_substs(ccx, tps, rp);\n-            let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n-            // Need to convert all methods so we can check internal\n-            // references to private methods\n-\n-            // NDM to TJC---I think we ought to be using bounds here, not @[].\n-            // But doing so causes errors later on.\n-            convert_methods(ccx, methods, rp, @[], selfty);\n-\n-            /*\n-            Finally, check that the class really implements the ifaces\n-            that it claims to implement.\n-            */\n-            for ifaces.each { |ifce|\n-                check_methods_against_iface(ccx, tps, rp, selfty,\n-                                            ifce, methods);\n-                let t = ty::node_id_to_type(tcx, ifce.id);\n-\n-                // FIXME: This assumes classes only implement\n-                // non-parameterized ifaces. add a test case for\n-                // a class implementing a parameterized iface.\n-                // -- tjc (#1726)\n-                tcx.tcache.insert(local_def(ifce.id), no_params(t));\n-            }\n-          }\n-          _ {\n-            // This call populates the type cache with the converted type\n-            // of the item in passing. All we have to do here is to write\n-            // it into the node type table.\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n-          }\n-       }\n-    }\n-    fn convert_native(ccx: @crate_ctxt, i: @ast::native_item) {\n-        // As above, this call populates the type table with the converted\n-        // type of the native item. We simply write it into the node type\n-        // table.\n-        let tpt = ty_of_native_item(ccx, i);\n-        alt i.node {\n-          ast::native_item_fn(_, _) {\n-            write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n-          }\n-        }\n-    }\n-    fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n-        visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-            visit_item: bind convert(ccx, _),\n-            visit_native_item: bind convert_native(ccx, _)\n-            with *visit::default_simple_visitor()\n-        }));\n-    }\n-}\n-\n-\n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     let mut t1 = t;\n     let mut enum_dids = [];\n@@ -1866,196 +845,6 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     }\n }\n \n-\n-// Type resolution: the phase that finds all the types in the AST with\n-// unresolved type variables and replaces \"ty_var\" types with their\n-// substitutions.\n-mod writeback {\n-\n-    export resolve_type_vars_in_fn;\n-    export resolve_type_vars_in_expr;\n-\n-    fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n-       option<ty::t> {\n-        if !ty::type_needs_infer(typ) { ret some(typ); }\n-        alt infer::resolve_deep(fcx.infcx, typ, true) {\n-          result::ok(new_type) { ret some(new_type); }\n-          result::err(e) {\n-            if !fcx.ccx.tcx.sess.has_errors() {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp,\n-                    #fmt[\"cannot determine a type \\\n-                          for this expression: %s\",\n-                         infer::fixup_err_to_str(e)])\n-            }\n-            ret none;\n-          }\n-        }\n-    }\n-    fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n-        -> option<ty::t> {\n-        let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n-        let n_ty = fcx.node_ty(id);\n-        alt resolve_type_vars_in_type(fcx, sp, n_ty) {\n-          none {\n-            wbcx.success = false;\n-            ret none;\n-          }\n-\n-          some(t) {\n-            #debug[\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n-                   id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)];\n-            write_ty_to_tcx(tcx, id, t);\n-            alt fcx.opt_node_ty_substs(id) {\n-              some(substs) {\n-                let mut new_tps = [];\n-                for substs.tps.each {|subst|\n-                    alt resolve_type_vars_in_type(fcx, sp, subst) {\n-                      some(t) { new_tps += [t]; }\n-                      none { wbcx.success = false; ret none; }\n-                    }\n-                }\n-                write_substs_to_tcx(tcx, id, new_tps);\n-              }\n-              none {}\n-            }\n-            ret some(t);\n-          }\n-        }\n-    }\n-\n-    fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n-                                        id: ast::node_id)\n-        -> option<ty::t> {\n-        if wbcx.fcx.node_types.contains_key(id as uint) {\n-            resolve_type_vars_for_node(wbcx, sp, id)\n-        } else {\n-            none\n-        }\n-    }\n-\n-    type wb_ctxt =\n-        // As soon as we hit an error we have to stop resolving\n-        // the entire function\n-        {fcx: @fn_ctxt, mut success: bool};\n-    type wb_vt = visit::vt<wb_ctxt>;\n-\n-    fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n-        if !wbcx.success { ret; }\n-        resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n-        visit::visit_stmt(s, wbcx, v);\n-    }\n-    fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n-        if !wbcx.success { ret; }\n-        resolve_type_vars_for_node(wbcx, e.span, e.id);\n-        alt e.node {\n-          ast::expr_fn(_, decl, _, _) |\n-          ast::expr_fn_block(decl, _, _) {\n-            vec::iter(decl.inputs) {|input|\n-                let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n-\n-                // Just in case we never constrained the mode to anything,\n-                // constrain it to the default for the type in question.\n-                alt (r_ty, input.mode) {\n-                  (some(t), ast::infer(_)) {\n-                    let tcx = wbcx.fcx.ccx.tcx;\n-                    let m_def = ty::default_arg_mode_for_ty(t);\n-                    ty::set_default_mode(tcx, input.mode, m_def);\n-                  }\n-                  _ {}\n-                }\n-            }\n-          }\n-\n-          ast::expr_new(_, alloc_id, _) {\n-            resolve_type_vars_for_node(wbcx, e.span, alloc_id);\n-          }\n-\n-          ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n-          ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n-            maybe_resolve_type_vars_for_node(wbcx, e.span,\n-                                             ast_util::op_expr_callee_id(e));\n-          }\n-\n-          _ { }\n-        }\n-        visit::visit_expr(e, wbcx, v);\n-    }\n-    fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n-        if !wbcx.success { ret; }\n-        resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n-        visit::visit_block(b, wbcx, v);\n-    }\n-    fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n-        if !wbcx.success { ret; }\n-        resolve_type_vars_for_node(wbcx, p.span, p.id);\n-        #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n-               pat_to_str(p), p.id,\n-               wbcx.fcx.ty_to_str(\n-                   ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n-                                       p.id))];\n-        visit::visit_pat(p, wbcx, v);\n-    }\n-    fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n-        if !wbcx.success { ret; }\n-        let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-        alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, true) {\n-          result::ok(lty) {\n-            #debug[\"Type for local %s (id %d) resolved to %s\",\n-                   pat_to_str(l.node.pat), l.node.id,\n-                   wbcx.fcx.ty_to_str(lty)];\n-            write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n-          }\n-          result::err(e) {\n-            wbcx.fcx.ccx.tcx.sess.span_err(\n-                l.span,\n-                #fmt[\"cannot determine a type \\\n-                      for this local variable: %s\",\n-                     infer::fixup_err_to_str(e)]);\n-            wbcx.success = false;\n-          }\n-        }\n-        visit::visit_local(l, wbcx, v);\n-    }\n-    fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n-        // Ignore items\n-    }\n-\n-    fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n-        let wbcx = {fcx: fcx, mut success: true};\n-        let visit =\n-            visit::mk_vt(@{visit_item: visit_item,\n-                           visit_stmt: visit_stmt,\n-                           visit_expr: visit_expr,\n-                           visit_block: visit_block,\n-                           visit_pat: visit_pat,\n-                           visit_local: visit_local\n-                              with *visit::default_visitor()});\n-        visit.visit_expr(e, wbcx, visit);\n-        ret wbcx.success;\n-    }\n-\n-    fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n-                               decl: ast::fn_decl,\n-                               blk: ast::blk) -> bool {\n-        let wbcx = {fcx: fcx, mut success: true};\n-        let visit =\n-            visit::mk_vt(@{visit_item: visit_item,\n-                           visit_stmt: visit_stmt,\n-                           visit_expr: visit_expr,\n-                           visit_block: visit_block,\n-                           visit_pat: visit_pat,\n-                           visit_local: visit_local\n-                              with *visit::default_visitor()});\n-        visit.visit_block(blk, wbcx, visit);\n-        for decl.inputs.each {|arg|\n-            resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n-        }\n-        ret wbcx.success;\n-    }\n-\n-}\n-\n fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n     fn param(ccx: @crate_ctxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n@@ -2099,7 +888,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n                               inputs: inputs, output: output,\n                               ret_style: ast::return_val,\n                               constraints: []});\n-    let i_ty = ty_of_native_item(ccx, it);\n+    let i_ty = astconv::ty_of_native_item(ccx, it);\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n@@ -2454,7 +1243,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n                                   _}, _)) {\n             {n_tps: ts.len(),\n              rp: rp,\n-             raw_ty: fcx.ccx.to_ty(type_rscope(rp), st)}\n+             raw_ty: fcx.ccx.to_ty(astconv::type_rscope(rp), st)}\n           }\n           some(ast_map::node_item(@{node: ast::item_class(ts,\n                                  _,_,_,_,rp), id: class_id, _},_)) {\n@@ -3170,8 +1959,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // construct the function type\n         let fty = ty::mk_fn(tcx,\n-                            ty_of_fn_decl(fcx, fcx, proto, decl,\n-                                          expected_tys));\n+                            astconv::ty_of_fn_decl(fcx, fcx, proto, decl,\n+                                                   expected_tys));\n \n         #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n                expr_to_str(expr), fcx.ty_to_str(fty));\n@@ -4407,7 +3196,7 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_member],\n                rp: ast::region_param) -> class_map {\n \n     let rslt = int_hash::<ty::t>();\n-    let rs = type_rscope(rp);\n+    let rs = astconv::type_rscope(rp);\n     for members.each { |m|\n       alt m.node {\n          ast::instance_var(_,t,_,id,_) {\n@@ -4416,7 +3205,7 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_member],\n          ast::class_method(mth) {\n            rslt.insert(mth.id,\n                        ty::mk_fn(ccx.tcx,\n-                                 ty_of_method(ccx, mth, rp).fty));\n+                                 collect::ty_of_method(ccx, mth, rp).fty));\n          }\n       }\n     }\n@@ -4447,7 +3236,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, dtor_id, none);\n       }\n       ast::item_impl(tps, rp, _, ty, ms) {\n-        let self_ty = ccx.to_ty(type_rscope(rp), ty);\n+        let self_ty = ccx.to_ty(astconv::type_rscope(rp), ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n       ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n@@ -4545,278 +3334,6 @@ fn check_for_main_fn(ccx: @crate_ctxt, crate: @ast::crate) {\n     }\n }\n \n-mod vtable {\n-    fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n-        vec::any(tps, {|bs|\n-            vec::any(*bs, {|b|\n-                alt b { ty::bound_iface(_) { true } _ { false } }\n-            })\n-        })\n-    }\n-\n-    fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n-                      bounds: @[ty::param_bounds], substs: ty::substs,\n-                      allow_unsafe: bool) -> vtable_res {\n-        let tcx = fcx.ccx.tcx;\n-        let mut result = [], i = 0u;\n-        for substs.tps.each {|ty|\n-            for vec::each(*bounds[i]) {|bound|\n-                alt bound {\n-                  ty::bound_iface(i_ty) {\n-                    let i_ty = ty::subst(tcx, substs, i_ty);\n-                    result += [lookup_vtable(fcx, isc, sp, ty, i_ty,\n-                                             allow_unsafe)];\n-                  }\n-                  _ {}\n-                }\n-            }\n-            i += 1u;\n-        }\n-        @result\n-    }\n-\n-    fn fixup_substs(fcx: @fn_ctxt, sp: span,\n-                    id: ast::def_id, substs: ty::substs) -> ty::substs {\n-        let tcx = fcx.ccx.tcx;\n-        // use a dummy type just to package up the substs that need fixing up\n-        let t = ty::mk_iface(tcx, id, substs);\n-        let t_f = fixup_ty(fcx, sp, t);\n-        alt check ty::get(t_f).struct {\n-          ty::ty_iface(_, substs_f) { substs_f }\n-        }\n-    }\n-\n-    fn relate_iface_tys(fcx: @fn_ctxt, sp: span,\n-                        exp_iface_ty: ty::t, act_iface_ty: ty::t) {\n-        demand::suptype(fcx, sp, exp_iface_ty, act_iface_ty)\n-    }\n-\n-    /*\n-      Look up the vtable to use when treating an item of type <t>\n-      as if it has type <iface_ty>\n-     */\n-    fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n-                     ty: ty::t, iface_ty: ty::t, allow_unsafe: bool)\n-        -> vtable_origin {\n-\n-        #debug[\"lookup_vtable(ty=%s, iface_ty=%s)\",\n-               fcx.ty_to_str(ty), fcx.ty_to_str(iface_ty)];\n-        let _i = indenter();\n-\n-        let tcx = fcx.ccx.tcx;\n-        let (iface_id, iface_substs) = alt check ty::get(iface_ty).struct {\n-            ty::ty_iface(did, substs) { (did, substs) }\n-        };\n-        let ty = fixup_ty(fcx, sp, ty);\n-        alt ty::get(ty).struct {\n-          ty::ty_param(n, did) {\n-            let mut n_bound = 0u;\n-            for vec::each(*tcx.ty_param_bounds.get(did.node)) { |bound|\n-                alt bound {\n-                  ty::bound_send | ty::bound_copy { /* ignore */ }\n-                  ty::bound_iface(ity) {\n-                    alt check ty::get(ity).struct {\n-                      ty::ty_iface(idid, substs) {\n-                        if iface_id == idid {\n-                            relate_iface_tys(fcx, sp, iface_ty, ity);\n-                            ret vtable_param(n, n_bound);\n-                        }\n-                      }\n-                    }\n-                    n_bound += 1u;\n-                  }\n-                }\n-            }\n-          }\n-\n-          ty::ty_iface(did, substs) if iface_id == did {\n-            relate_iface_tys(fcx, sp, iface_ty, ty);\n-            if !allow_unsafe {\n-                for vec::each(*ty::iface_methods(tcx, did)) {|m|\n-                    if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n-                        tcx.sess.span_err(\n-                            sp, \"a boxed iface with self types may not be \\\n-                                 passed as a bounded type\");\n-                    } else if (*m.tps).len() > 0u {\n-                        tcx.sess.span_err(\n-                            sp, \"a boxed iface with generic methods may not \\\n-                                 be passed as a bounded type\");\n-\n-                    }\n-                }\n-            }\n-            ret vtable_iface(did, substs.tps);\n-          }\n-\n-          _ {\n-            let mut found = [];\n-\n-            for list::each(isc) {|impls|\n-            /* For each impl in scope... */\n-                for vec::each(*impls) {|im|\n-                    // im = one specific impl\n-                    // find the iface that im implements (if any)\n-                    let of_ty = alt ty::impl_iface(tcx, im.did) {\n-                      some(of_ty) { of_ty }\n-                      _ { cont; }\n-                    };\n-\n-                    // it must have the same id as the expected one\n-                    alt ty::get(of_ty).struct {\n-                      ty::ty_iface(id, _) if id != iface_id { cont; }\n-                      _ { /* ok */ }\n-                    }\n-\n-                    // check whether the type unifies with the type\n-                    // that the impl is for, and continue if not\n-                    let {substs: substs, ty: for_ty} =\n-                        impl_self_ty(fcx, im.did);\n-                    let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                    alt fcx.mk_subty(ty, for_ty) {\n-                      result::err(_) { cont; }\n-                      result::ok(()) { }\n-                    }\n-\n-                    // check that desired iface type unifies\n-                    let of_ty = ty::subst(tcx, substs, of_ty);\n-                    relate_iface_tys(fcx, sp, iface_ty, of_ty);\n-\n-                    // recursively process the bounds\n-                    let iface_tps = iface_substs.tps;\n-                    let substs_f = fixup_substs(fcx, sp, iface_id, substs);\n-                    connect_iface_tps(fcx, sp, substs_f.tps,\n-                                      iface_tps, im.did);\n-                    let subres = lookup_vtables(fcx, isc, sp,\n-                                                im_bs, substs_f, false);\n-                    found += [vtable_static(im.did, substs_f.tps, subres)];\n-                }\n-\n-                alt found.len() {\n-                  0u { /* fallthrough */ }\n-                  1u { ret found[0]; }\n-                  _ {\n-                    fcx.ccx.tcx.sess.span_err(\n-                        sp, \"multiple applicable methods in scope\");\n-                    ret found[0];\n-                  }\n-                }\n-            }\n-          }\n-        }\n-\n-        tcx.sess.span_fatal(\n-            sp, \"failed to find an implementation of interface \" +\n-            ty_to_str(tcx, iface_ty) + \" for \" +\n-            ty_to_str(tcx, ty));\n-    }\n-\n-    fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n-        let tcx = fcx.ccx.tcx;\n-        alt infer::resolve_deep(fcx.infcx, ty, true) {\n-          result::ok(new_type) { new_type }\n-          result::err(e) {\n-            tcx.sess.span_fatal(\n-                sp,\n-                #fmt[\"cannot determine a type \\\n-                      for this bounded type parameter: %s\",\n-                     infer::fixup_err_to_str(e)])\n-          }\n-        }\n-    }\n-\n-    fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n-                         iface_tys: [ty::t], impl_did: ast::def_id) {\n-        let tcx = fcx.ccx.tcx;\n-        let ity = option::get(ty::impl_iface(tcx, impl_did));\n-        let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n-        alt check ty::get(iface_ty).struct {\n-          ty::ty_iface(_, substs) {\n-            vec::iter2(substs.tps, iface_tys,\n-                       {|a, b| demand::suptype(fcx, sp, a, b);});\n-          }\n-        }\n-    }\n-\n-    fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n-        let cx = fcx.ccx;\n-        alt ex.node {\n-          ast::expr_path(*) {\n-            alt fcx.opt_node_ty_substs(ex.id) {\n-              some(substs) {\n-                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n-                let item_ty = ty::lookup_item_type(cx.tcx, did);\n-                if has_iface_bounds(*item_ty.bounds) {\n-                    let impls = cx.impl_map.get(ex.id);\n-                    cx.vtable_map.insert(ex.id, lookup_vtables(\n-                        fcx, impls, ex.span,\n-                        item_ty.bounds, substs, false));\n-                }\n-              }\n-              _ {}\n-            }\n-          }\n-          // Must resolve bounds on methods with bounded params\n-          ast::expr_field(*) | ast::expr_binary(*) |\n-          ast::expr_unary(*) | ast::expr_assign_op(*) |\n-          ast::expr_index(*) {\n-            alt cx.method_map.find(ex.id) {\n-              some(method_static(did)) {\n-                let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-                if has_iface_bounds(*bounds) {\n-                    let callee_id = alt ex.node {\n-                      ast::expr_field(_, _, _) { ex.id }\n-                      _ { ast_util::op_expr_callee_id(ex) }\n-                    };\n-                    let substs = fcx.node_ty_substs(callee_id);\n-                    let iscs = cx.impl_map.get(ex.id);\n-                    cx.vtable_map.insert(callee_id, lookup_vtables(\n-                        fcx, iscs, ex.span, bounds, substs, false));\n-                }\n-              }\n-              _ {}\n-            }\n-          }\n-          ast::expr_cast(src, _) {\n-            let target_ty = fcx.expr_ty(ex);\n-            alt ty::get(target_ty).struct {\n-              ty::ty_iface(*) {\n-               /* Casting to an interface type.\n-                  Look up all impls for the cast expr...\n-               */\n-                let impls = cx.impl_map.get(ex.id);\n-                /*\n-                  Look up vtables for the type we're casting to,\n-                  passing in the source and target type\n-                 */\n-                let vtable = lookup_vtable(fcx, impls, ex.span,\n-                                           fcx.expr_ty(src), target_ty,\n-                                           true);\n-                /*\n-                  Map this expression to that vtable (that is: \"ex has\n-                  vtable <vtable>\")\n-                 */\n-                cx.vtable_map.insert(ex.id, @[vtable]);\n-              }\n-              _ {}\n-            }\n-          }\n-          _ {}\n-        }\n-        visit::visit_expr(ex, fcx, v);\n-    }\n-\n-    // Detect points where an interface-bounded type parameter is\n-    // instantiated, resolve the impls for the parameters.\n-    fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n-        visit::visit_block(bl, fcx, visit::mk_vt(@{\n-            visit_expr: resolve_expr,\n-            visit_item: fn@(_i: @ast::item, &&_e: @fn_ctxt,\n-                            _v: visit::vt<@fn_ctxt>) {}\n-            with *visit::default_visitor()\n-        }));\n-    }\n-}\n-\n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> (method_map, vtable_map) {\n     let ccx = @{impl_map: impl_map,"}, {"sha": "8f5eacf77080b41f39df3a3d6ba622f5d450c3bf", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "added", "additions": 711, "deletions": 0, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -0,0 +1,711 @@\n+#[doc = \"\n+\n+Conversion from AST representation of types to the ty.rs representation.\n+\n+The main routine here is `ast_ty_to_ty()`: each use is parameterized\n+by an instance of `ast_conv` and a `region_scope`.\n+\n+The `ast_conv` interface is the conversion context.  It has two\n+implementations, one for the crate context and one for the function\n+context.  The main purpose is to provide the `get_item_ty()` hook\n+which looks up the type of an item by its def-id.  This can be done in\n+two ways: in the initial phase, when a crate context is provided, this\n+will potentially trigger a call to `ty_of_item()`.  Later, when a\n+function context is used, this will simply be a lookup.\n+\n+The `region_scope` interface controls how region references are\n+handled.  It has two methods which are used to resolve anonymous\n+region references (e.g., `&T`) and named region references (e.g.,\n+`&a.T`).  There are numerous region scopes that can be used, but most\n+commonly you want either `empty_rscope`, which permits only the static\n+region, or `type_rscope`, which permits the self region if the type in\n+question is parameterized by a region.\n+\n+\"];\n+\n+iface ast_conv {\n+    fn tcx() -> ty::ctxt;\n+    fn ccx() -> @crate_ctxt;\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+\n+    // what type should we use when a type is omitted?\n+    fn ty_infer(span: span) -> ty::t;\n+}\n+\n+impl of ast_conv for @crate_ctxt {\n+    fn tcx() -> ty::ctxt { self.tcx }\n+    fn ccx() -> @crate_ctxt { self }\n+\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        if id.crate != ast::local_crate {\n+            csearch::get_type(self.tcx, id)\n+        } else {\n+            alt self.tcx.items.find(id.node) {\n+              some(ast_map::node_item(item, _)) {\n+                ty_of_item(self, item)\n+              }\n+              some(ast_map::node_native_item(native_item, _, _)) {\n+                ty_of_native_item(self, native_item)\n+              }\n+              x {\n+                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n+                                        in get_item_ty(): %?\", x]);\n+              }\n+            }\n+        }\n+    }\n+\n+    fn ty_infer(span: span) -> ty::t {\n+        self.tcx.sess.span_bug(span,\n+                               \"found `ty_infer` in unexpected place\");\n+    }\n+}\n+\n+impl of ast_conv for @fn_ctxt {\n+    fn tcx() -> ty::ctxt { self.ccx.tcx }\n+    fn ccx() -> @crate_ctxt { self.ccx }\n+\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        ty::lookup_item_type(self.tcx(), id)\n+    }\n+\n+    fn ty_infer(_span: span) -> ty::t {\n+        self.next_ty_var()\n+    }\n+}\n+\n+iface region_scope {\n+    fn anon_region() -> result<ty::region, str>;\n+    fn named_region(id: str) -> result<ty::region, str>;\n+}\n+\n+enum empty_rscope { empty_rscope }\n+impl of region_scope for empty_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        result::err(\"region types are not allowed here\")\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        if id == \"static\" { result::ok(ty::re_static) }\n+        else { result::err(\"only the static region is allowed here\") }\n+    }\n+}\n+\n+enum type_rscope = ast::region_param;\n+impl of region_scope for type_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        alt *self {\n+          ast::rp_self { result::ok(ty::re_bound(ty::br_self)) }\n+          ast::rp_none {\n+            result::err(\"to use region types here, the containing type \\\n+                         must be declared with a region bound\")\n+          }\n+        }\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        empty_rscope.named_region(id).chain_err { |_e|\n+            if id == \"self\" { self.anon_region() }\n+            else {\n+                result::err(\"named regions other than `self` are not \\\n+                             allowed as part of a type declaration\")\n+            }\n+        }\n+    }\n+}\n+\n+impl of region_scope for @fn_ctxt {\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(self.next_region_var())\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        empty_rscope.named_region(id).chain_err { |_e|\n+            alt self.in_scope_regions.find(ty::br_named(id)) {\n+              some(r) { result::ok(r) }\n+              none if id == \"blk\" { self.block_region() }\n+              none {\n+                result::err(#fmt[\"named region `%s` not in scope here\", id])\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+enum anon_rscope = {anon: ty::region, base: region_scope};\n+fn in_anon_rscope<RS: region_scope copy>(self: RS, r: ty::region)\n+    -> @anon_rscope {\n+    @anon_rscope({anon: r, base: self as region_scope})\n+}\n+impl of region_scope for @anon_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(self.anon)\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        self.base.named_region(id)\n+    }\n+}\n+\n+enum binding_rscope = {base: region_scope};\n+fn in_binding_rscope<RS: region_scope copy>(self: RS) -> @binding_rscope {\n+    let base = self as region_scope;\n+    @binding_rscope({base: base})\n+}\n+impl of region_scope for @binding_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(ty::re_bound(ty::br_anon))\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        self.base.named_region(id).chain_err {|_e|\n+            result::ok(ty::re_bound(ty::br_named(id)))\n+        }\n+    }\n+}\n+\n+fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n+\n+    let res = alt a_r.node {\n+      ast::re_anon { rscope.anon_region() }\n+      ast::re_named(id) { rscope.named_region(id) }\n+    };\n+\n+    get_region_reporting_err(self.tcx(), span, res)\n+}\n+\n+fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS, did: ast::def_id,\n+    path: @ast::path) -> ty_param_substs_and_ty {\n+\n+    let tcx = self.tcx();\n+    let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n+        self.get_item_ty(did);\n+\n+    // If the type is parameterized by the self region, then replace self\n+    // region with the current anon region binding (in other words,\n+    // whatever & would get replaced with).\n+    let self_r = alt (decl_rp, path.rp) {\n+      (ast::rp_none, none) {\n+        none\n+      }\n+      (ast::rp_none, some(_)) {\n+        tcx.sess.span_err(\n+            path.span,\n+            #fmt[\"No region bound is permitted on %s, \\\n+                  which is not declared as containing region pointers\",\n+                 ty::item_path_str(tcx, did)]);\n+        none\n+      }\n+      (ast::rp_self, none) {\n+        let res = rscope.anon_region();\n+        let r = get_region_reporting_err(self.tcx(), path.span, res);\n+        some(r)\n+      }\n+      (ast::rp_self, some(r)) {\n+        some(ast_region_to_region(self, rscope, path.span, r))\n+      }\n+    };\n+\n+    // Convert the type parameters supplied by the user.\n+    if !vec::same_length(*decl_bounds, path.types) {\n+        self.tcx().sess.span_fatal(\n+            path.span,\n+            #fmt[\"wrong number of type arguments, expected %u but found %u\",\n+                 (*decl_bounds).len(), path.types.len()]);\n+    }\n+    let tps = path.types.map { |a_t| ast_ty_to_ty(self, rscope, a_t) };\n+\n+    let substs = {self_r:self_r, self_ty:none, tps:tps};\n+    {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n+}\n+\n+fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC,\n+    rscope: RS,\n+    did: ast::def_id,\n+    path: @ast::path,\n+    path_id: ast::node_id) -> ty_param_substs_and_ty {\n+\n+    // Lookup the polytype of the item and then substitute the provided types\n+    // for any type/region parameters.\n+    let tcx = self.tcx();\n+    let {substs: substs, ty: ty} =\n+        ast_path_to_substs_and_ty(self, rscope, did, path);\n+    write_ty_to_tcx(tcx, path_id, ty);\n+    write_substs_to_tcx(tcx, path_id, substs.tps);\n+    ret {substs: substs, ty: ty};\n+}\n+\n+/*\n+  Instantiates the path for the given iface reference, assuming that\n+  it's bound to a valid iface type. Returns the def_id for the defining\n+  iface. Fails if the type is a type other than an iface type.\n+ */\n+fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n+                         rp: ast::region_param)\n+    -> (ast::def_id, ty_param_substs_and_ty) {\n+\n+    let sp = t.path.span, err = \"can only implement interface types\",\n+        sess = ccx.tcx.sess;\n+\n+    let rscope = type_rscope(rp);\n+\n+    alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n+      ast::def_ty(t_id) {\n+        let tpt = ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n+        alt ty::get(tpt.ty).struct {\n+           ty::ty_iface(*) {\n+              (t_id, tpt)\n+           }\n+           _ { sess.span_fatal(sp, err); }\n+        }\n+      }\n+      _ {\n+          sess.span_fatal(sp, err);\n+      }\n+    }\n+}\n+\n+const NO_REGIONS: uint = 1u;\n+const NO_TPS: uint = 2u;\n+\n+// Parses the programmer's textual representation of a type into our\n+// internal notion of a type. `getter` is a function that returns the type\n+// corresponding to a definition ID:\n+fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n+\n+    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy>(\n+        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n+\n+        ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n+    }\n+\n+    fn mk_vstore<AC: ast_conv, RS: region_scope copy>(\n+        self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n+\n+        let tcx = self.tcx();\n+        let seq_ty = ast_ty_to_ty(self, rscope, a_seq_ty);\n+\n+        alt ty::get(seq_ty).struct {\n+          ty::ty_vec(mt) {\n+            ret ty::mk_evec(tcx, mt, vst);\n+          }\n+\n+          ty::ty_str {\n+            ret ty::mk_estr(tcx, vst);\n+          }\n+\n+          _ {\n+            tcx.sess.span_err(\n+                a_seq_ty.span,\n+                #fmt[\"Bound not allowed on a %s.\",\n+                     ty::ty_sort_str(tcx, seq_ty)]);\n+            ret seq_ty;\n+          }\n+        }\n+    }\n+\n+    fn check_path_args(tcx: ty::ctxt,\n+                       path: @ast::path,\n+                       flags: uint) {\n+        if (flags & NO_TPS) != 0u {\n+            if path.types.len() > 0u {\n+                tcx.sess.span_err(\n+                    path.span,\n+                    \"Type parameters are not allowed on this type.\");\n+            }\n+        }\n+\n+        if (flags & NO_REGIONS) != 0u {\n+            if path.rp.is_some() {\n+                tcx.sess.span_err(\n+                    path.span,\n+                    \"Region parameters are not allowed on this type.\");\n+            }\n+        }\n+    }\n+\n+    let tcx = self.tcx();\n+\n+    alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n+      some(ty::atttce_resolved(ty)) { ret ty; }\n+      some(ty::atttce_unresolved) {\n+        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n+                                          insert a enum in the cycle, \\\n+                                          if this is desired)\");\n+      }\n+      none { /* go on */ }\n+    }\n+\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n+    let typ = alt ast_ty.node {\n+      ast::ty_nil { ty::mk_nil(tcx) }\n+      ast::ty_bot { ty::mk_bot(tcx) }\n+      ast::ty_box(mt) {\n+        ty::mk_box(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_uniq(mt) {\n+        ty::mk_uniq(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_vec(mt) {\n+        ty::mk_vec(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_ptr(mt) {\n+        ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_rptr(region, mt) {\n+        let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n+        let mt = ast_mt_to_mt(self, in_anon_rscope(rscope, r), mt);\n+        ty::mk_rptr(tcx, r, mt)\n+      }\n+      ast::ty_tup(fields) {\n+        let flds = vec::map(fields) { |t| ast_ty_to_ty(self, rscope, t) };\n+        ty::mk_tup(tcx, flds)\n+      }\n+      ast::ty_rec(fields) {\n+        let flds = fields.map {|f|\n+            let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n+            {ident: f.node.ident, mt: tm}\n+        };\n+        ty::mk_rec(tcx, flds)\n+      }\n+      ast::ty_fn(proto, decl) {\n+        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl, none))\n+      }\n+      ast::ty_path(path, id) {\n+        let a_def = alt tcx.def_map.find(id) {\n+          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n+                                                       path_to_str(path))); }\n+          some(d) { d }};\n+        alt a_def {\n+          ast::def_ty(did) | ast::def_class(did) {\n+            ast_path_to_ty(self, rscope, did, path, id).ty\n+          }\n+          ast::def_prim_ty(nty) {\n+            alt nty {\n+              ast::ty_bool {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_bool(tcx)\n+              }\n+              ast::ty_int(it) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_int(tcx, it)\n+              }\n+              ast::ty_uint(uit) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_uint(tcx, uit)\n+              }\n+              ast::ty_float(ft) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_float(tcx, ft)\n+              }\n+              ast::ty_str {\n+                check_path_args(tcx, path, NO_TPS);\n+                // This is a bit of a hack, but basically str/& needs to be\n+                // converted into a vstore:\n+                alt path.rp {\n+                  none {\n+                    ty::mk_str(tcx)\n+                  }\n+                  some(ast_r) {\n+                    let r = ast_region_to_region(self, rscope,\n+                                                 ast_ty.span, ast_r);\n+                    ty::mk_estr(tcx, ty::vstore_slice(r))\n+                  }\n+                }\n+              }\n+            }\n+          }\n+          ast::def_ty_param(id, n) {\n+            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+            ty::mk_param(tcx, n, id)\n+          }\n+          ast::def_self(_) {\n+            // n.b.: resolve guarantees that the self type only appears in an\n+            // iface, which we rely upon in various places when creating\n+            // substs\n+            ty::mk_self(tcx)\n+          }\n+          _ {\n+            tcx.sess.span_fatal(ast_ty.span,\n+                                \"found type name used as a variable\");\n+          }\n+        }\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n+        let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n+        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_uniq) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_box) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_box)\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n+      }\n+      ast::ty_vstore(_, ast::vstore_fixed(none)) {\n+        tcx.sess.span_bug(\n+            ast_ty.span,\n+            \"implied fixed length for bound\");\n+      }\n+      ast::ty_constr(t, cs) {\n+        let mut out_cs = [];\n+        for cs.each {|constr|\n+            out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n+        }\n+        ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n+      }\n+      ast::ty_infer {\n+        // ty_infer should only appear as the type of arguments or return\n+        // values in a fn_expr, or as the type of local variables.  Both of\n+        // these cases are handled specially and should not descend into this\n+        // routine.\n+        self.tcx().sess.span_bug(\n+            ast_ty.span,\n+            \"found `ty_infer` in unexpected place\");\n+      }\n+      ast::ty_mac(_) {\n+        tcx.sess.span_bug(ast_ty.span,\n+                          \"found `ty_mac` in unexpected place\");\n+      }\n+    };\n+\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n+    ret typ;\n+}\n+\n+fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n+    -> ty::ty_param_bounds_and_ty {\n+\n+    let def_id = local_def(it.id);\n+    let tcx = ccx.tcx;\n+    alt tcx.tcache.find(def_id) {\n+      some(tpt) { ret tpt; }\n+      _ {}\n+    }\n+    alt it.node {\n+      ast::item_const(t, _) {\n+        let typ = ccx.to_ty(empty_rscope, t);\n+        let tpt = no_params(typ);\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_fn(decl, tps, _) {\n+        let bounds = ty_param_bounds(ccx, tps);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n+                                 decl, none);\n+        let tpt = {bounds: bounds,\n+                   rp: ast::rp_none, // functions do not have a self\n+                   ty: ty::mk_fn(ccx.tcx, tofd)};\n+        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_ty(t, tps, rp) {\n+        alt tcx.tcache.find(local_def(it.id)) {\n+          some(tpt) { ret tpt; }\n+          none { }\n+        }\n+\n+        let tpt = {\n+            let ty = {\n+                let t0 = ccx.to_ty(type_rscope(rp), t);\n+                // Do not associate a def id with a named, parameterized type\n+                // like \"foo<X>\".  This is because otherwise ty_to_str will\n+                // print the name as merely \"foo\", as it has no way to\n+                // reconstruct the value of X.\n+                if !vec::is_empty(tps) { t0 } else {\n+                    ty::mk_with_id(tcx, t0, def_id)\n+                }\n+            };\n+            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n+        };\n+\n+        check_bounds_are_used(ccx, t.span, tps, rp, tpt.ty);\n+\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_res(decl, tps, _, _, _, rp) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n+                              decl.inputs[0], none);\n+        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n+        let t_res = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), t_res);\n+        ret t_res;\n+      }\n+      ast::item_enum(_, tps, rp) {\n+        // Create a new generic polytype.\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_iface(tps, rp, ms) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_class(tps, _, _, _, _, rp) {\n+          let {bounds,substs} = mk_substs(ccx, tps, rp);\n+          let t = ty::mk_class(tcx, local_def(it.id), substs);\n+          let tpt = {bounds: bounds, rp: rp, ty: t};\n+          tcx.tcache.insert(local_def(it.id), tpt);\n+          ret tpt;\n+      }\n+      ast::item_impl(*) | ast::item_mod(_) |\n+      ast::item_native_mod(_) { fail; }\n+    }\n+}\n+\n+fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n+    -> ty::ty_param_bounds_and_ty {\n+    alt it.node {\n+      ast::native_item_fn(fn_decl, params) {\n+        ret ty_of_native_fn_decl(ccx, fn_decl, params,\n+                                 local_def(it.id));\n+      }\n+    }\n+}\n+\n+fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS, a: ast::arg,\n+    expected_ty: option<ty::arg>) -> ty::arg {\n+\n+    let ty = alt a.ty.node {\n+      ast::ty_infer if expected_ty.is_some() {expected_ty.get().ty}\n+      ast::ty_infer {self.ty_infer(a.ty.span)}\n+      _ {ast_ty_to_ty(self, rscope, a.ty)}\n+    };\n+\n+    let mode = {\n+        alt a.mode {\n+          ast::infer(_) if expected_ty.is_some() {\n+            result::get(ty::unify_mode(self.tcx(), a.mode,\n+                                       expected_ty.get().mode))\n+          }\n+          ast::infer(_) {\n+            alt ty::get(ty).struct {\n+              // If the type is not specified, then this must be a fn expr.\n+              // Leave the mode as infer(_), it will get inferred based\n+              // on constraints elsewhere.\n+              ty::ty_var(_) {a.mode}\n+\n+              // If the type is known, then use the default for that type.\n+              // Here we unify m and the default.  This should update the\n+              // tables in tcx but should never fail, because nothing else\n+              // will have been unified with m yet:\n+              _ {\n+                let m1 = ast::expl(ty::default_arg_mode_for_ty(ty));\n+                result::get(ty::unify_mode(self.tcx(), a.mode, m1))\n+              }\n+            }\n+          }\n+          ast::expl(_) {a.mode}\n+        }\n+    };\n+\n+    {mode: mode, ty: ty}\n+}\n+\n+type expected_tys = option<{inputs: [ty::arg],\n+                            output: ty::t}>;\n+\n+fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS,\n+    proto: ast::proto,\n+    decl: ast::fn_decl,\n+    expected_tys: expected_tys) -> ty::fn_ty {\n+\n+    #debug[\"ty_of_fn_decl\"];\n+    indent {||\n+        // new region names that appear inside of the fn decl are bound to\n+        // that function type\n+        let rb = in_binding_rscope(rscope);\n+\n+        let input_tys = decl.inputs.mapi { |i, a|\n+            let expected_arg_ty = expected_tys.chain { |e|\n+                // no guarantee that the correct number of expected args\n+                // were supplied\n+                if i < e.inputs.len() {some(e.inputs[i])} else {none}\n+            };\n+            ty_of_arg(self, rb, a, expected_arg_ty)\n+        };\n+\n+        let expected_ret_ty = expected_tys.map { |e| e.output };\n+        let output_ty = alt decl.output.node {\n+          ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n+          ast::ty_infer {self.ty_infer(decl.output.span)}\n+          _ {ast_ty_to_ty(self, rb, decl.output)}\n+        };\n+\n+        let out_constrs = vec::map(decl.constraints) {|constr|\n+            ty::ast_constr_to_constr(self.tcx(), constr)\n+        };\n+        {proto: proto, inputs: input_tys,\n+         output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n+    }\n+}\n+\n+\n+fn ty_param_bounds(ccx: @crate_ctxt,\n+                   params: [ast::ty_param]) -> @[ty::param_bounds] {\n+\n+    fn compute_bounds(ccx: @crate_ctxt,\n+                      param: ast::ty_param) -> ty::param_bounds {\n+        @vec::flat_map(*param.bounds) { |b|\n+            alt b {\n+              ast::bound_send { [ty::bound_send] }\n+              ast::bound_copy { [ty::bound_copy] }\n+              ast::bound_iface(t) {\n+                let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n+                alt ty::get(ity).struct {\n+                  ty::ty_iface(*) {\n+                    [ty::bound_iface(ity)]\n+                  }\n+                  _ {\n+                    ccx.tcx.sess.span_err(\n+                        t.span, \"type parameter bounds must be \\\n+                                 interface types\");\n+                    []\n+                  }\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    @params.map { |param|\n+        alt ccx.tcx.ty_param_bounds.find(param.id) {\n+          some(bs) { bs }\n+          none {\n+            let bounds = compute_bounds(ccx, param);\n+            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n+            bounds\n+          }\n+        }\n+    }\n+}\n+\n+fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n+                        decl: ast::fn_decl,\n+                        ty_params: [ast::ty_param],\n+                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+\n+    let bounds = ty_param_bounds(ccx, ty_params);\n+    let rb = in_binding_rscope(empty_rscope);\n+    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n+    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n+\n+    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n+                                   inputs: input_tys,\n+                                   output: output_ty,\n+                                   ret_style: ast::return_val,\n+                                   constraints: []});\n+    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n+    ccx.tcx.tcache.insert(def_id, tpt);\n+    ret tpt;\n+}"}, {"sha": "d1283375b5bcf0d7fe6c5147236a991351a5fc92", "filename": "src/rustc/middle/typeck/collect.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -0,0 +1,343 @@\n+import astconv::{type_rscope, instantiate_iface_ref, ty_of_item,\n+                 empty_rscope, ty_of_native_item, ast_conv};\n+\n+// Item collection - a pair of bootstrap passes:\n+//\n+// (1) Collect the IDs of all type items (typedefs) and store them in a table.\n+//\n+// (2) Translate the AST fragments that describe types to determine a type for\n+//     each item. When we encounter a named type, we consult the table built\n+//     in pass 1 to find its item, and recursively translate it.\n+//\n+// We then annotate the AST with the resulting types and return the annotated\n+// AST, along with a table mapping item IDs to their types.\n+fn get_enum_variant_types(ccx: @crate_ctxt,\n+                          enum_ty: ty::t,\n+                          variants: [ast::variant],\n+                          ty_params: [ast::ty_param],\n+                          rp: ast::region_param) {\n+    let tcx = ccx.tcx;\n+\n+    // Create a set of parameter types shared among all the variants.\n+    for variants.each {|variant|\n+        // Nullary enum constructors get turned into constants; n-ary enum\n+        // constructors get turned into functions.\n+        let result_ty = if vec::len(variant.node.args) == 0u {\n+            enum_ty\n+        } else {\n+            let rs = type_rscope(rp);\n+            let args = variant.node.args.map { |va|\n+                let arg_ty = ccx.to_ty(rs, va.ty);\n+                {mode: ast::expl(ast::by_copy), ty: arg_ty}\n+            };\n+            ty::mk_fn(tcx, {proto: ast::proto_box,\n+                            inputs: args,\n+                            output: enum_ty,\n+                            ret_style: ast::return_val,\n+                            constraints: []})\n+        };\n+        let tpt = {bounds: astconv::ty_param_bounds(ccx, ty_params),\n+                   rp: rp,\n+                   ty: result_ty};\n+        tcx.tcache.insert(local_def(variant.node.id), tpt);\n+        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n+    }\n+}\n+\n+fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n+    fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n+                        stuff: [T], f: fn@(T) -> ty::method) {\n+        ty::store_iface_methods(ccx.tcx, id, @vec::map(stuff, f));\n+    }\n+\n+    let tcx = ccx.tcx;\n+    alt check tcx.items.get(id) {\n+      ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n+        store_methods::<ast::ty_method>(ccx, id, ms) {|m|\n+            ty_of_ty_method(ccx, m, rp)\n+        };\n+      }\n+      ast_map::node_item(@{node: ast::item_class(_,_,its,_,_,rp), _}, _) {\n+        let (_,ms) = split_class_items(its);\n+        // All methods need to be stored, since lookup_method\n+        // relies on the same method cache for self-calls\n+        store_methods::<@ast::method>(ccx, id, ms) {|m|\n+            ty_of_method(ccx, m, rp)\n+        };\n+      }\n+    }\n+}\n+\n+fn check_methods_against_iface(ccx: @crate_ctxt,\n+                               tps: [ast::ty_param],\n+                               rp: ast::region_param,\n+                               selfty: ty::t,\n+                               a_ifacety: @ast::iface_ref,\n+                               ms: [@ast::method]) {\n+\n+    let tcx = ccx.tcx;\n+    let i_bounds = astconv::ty_param_bounds(ccx, tps);\n+    let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n+    let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n+    if did.crate == ast::local_crate {\n+        ensure_iface_methods(ccx, did.node);\n+    }\n+    for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n+        alt vec::find(my_methods, {|m| if_m.ident == m.mty.ident}) {\n+          some({mty: m, id, span}) {\n+            if m.purity != if_m.purity {\n+                ccx.tcx.sess.span_err(\n+                    span, #fmt[\"method `%s`'s purity \\\n+                                not match the iface method's \\\n+                                purity\", m.ident]);\n+            }\n+            let mt = compare_impl_method(\n+                ccx.tcx, span, m, vec::len(tps),\n+                if_m, tpt.substs, selfty);\n+            let old = tcx.tcache.get(local_def(id));\n+            if old.ty != mt {\n+                tcx.tcache.insert(\n+                    local_def(id),\n+                    {bounds: old.bounds,\n+                     rp: old.rp,\n+                     ty: mt});\n+                write_ty_to_tcx(tcx, id, mt);\n+            }\n+          }\n+          none {\n+            tcx.sess.span_err(\n+                a_ifacety.path.span,\n+                #fmt[\"missing method `%s`\", if_m.ident]);\n+          }\n+        } // alt\n+    } // |if_m|\n+} // fn\n+\n+fn convert_class_item(ccx: @crate_ctxt,\n+                      rp: ast::region_param,\n+                      v: ast_util::ivar) {\n+    /* we want to do something here, b/c within the\n+    scope of the class, it's ok to refer to fields &\n+    methods unqualified */\n+    /* they have these types *within the scope* of the\n+    class. outside the class, it's done with expr_field */\n+    let tt = ccx.to_ty(type_rscope(rp), v.ty);\n+    write_ty_to_tcx(ccx.tcx, v.id, tt);\n+}\n+\n+fn convert_methods(ccx: @crate_ctxt,\n+                   ms: [@ast::method],\n+                   rp: ast::region_param,\n+                   i_bounds: @[ty::param_bounds],\n+                   self_ty: ty::t)\n+    -> [{mty: ty::method, id: ast::node_id, span: span}] {\n+\n+    let tcx = ccx.tcx;\n+    vec::map(ms) { |m|\n+        write_ty_to_tcx(tcx, m.self_id, self_ty);\n+        let bounds = astconv::ty_param_bounds(ccx, m.tps);\n+        let mty = ty_of_method(ccx, m, rp);\n+        let fty = ty::mk_fn(tcx, mty.fty);\n+        tcx.tcache.insert(\n+            local_def(m.id),\n+            // n.b. This code is kind of sketchy (concat'ing i_bounds\n+            // with bounds), but removing *i_bounds breaks other stuff\n+            {bounds: @(*i_bounds + *bounds), rp: rp, ty: fty});\n+        write_ty_to_tcx(tcx, m.id, fty);\n+        {mty: mty, id: m.id, span: m.span}\n+    }\n+}\n+\n+fn convert(ccx: @crate_ctxt, it: @ast::item) {\n+    let tcx = ccx.tcx;\n+    alt it.node {\n+      // These don't define types.\n+      ast::item_mod(_) {}\n+      ast::item_native_mod(m) {\n+        if syntax::attr::native_abi(it.attrs) ==\n+            either::right(ast::native_abi_rust_intrinsic) {\n+            for m.items.each { |item| check_intrinsic_type(ccx, item); }\n+        }\n+      }\n+      ast::item_enum(variants, ty_params, rp) {\n+        let tpt = ty_of_item(ccx, it);\n+        write_ty_to_tcx(tcx, it.id, tpt.ty);\n+        get_enum_variant_types(ccx, tpt.ty, variants,\n+                               ty_params, rp);\n+      }\n+      ast::item_impl(tps, rp, ifce, selfty, ms) {\n+        let i_bounds = astconv::ty_param_bounds(ccx, tps);\n+        let selfty = ccx.to_ty(type_rscope(rp), selfty);\n+        write_ty_to_tcx(tcx, it.id, selfty);\n+        tcx.tcache.insert(local_def(it.id),\n+                          {bounds: i_bounds,\n+                           rp: rp,\n+                           ty: selfty});\n+        alt ifce {\n+          some(t) {\n+            check_methods_against_iface(\n+                ccx, tps, rp,\n+                selfty, t, ms);\n+          }\n+          _ {\n+            // Still have to do this to write method types\n+            // into the table\n+            convert_methods(\n+                ccx, ms, rp,\n+                i_bounds, selfty);\n+          }\n+        }\n+      }\n+      ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let def_id = local_def(it.id);\n+        let t_arg = astconv::ty_of_arg(ccx, type_rscope(rp),\n+                                       decl.inputs[0], none);\n+        let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n+\n+        let t_ctor = ty::mk_fn(tcx, {\n+            proto: ast::proto_box,\n+            inputs: [{mode: ast::expl(ast::by_copy), ty: t_arg.ty}],\n+            output: t_res,\n+            ret_style: ast::return_val, constraints: []\n+        });\n+        let t_dtor = ty::mk_fn(tcx, {\n+            proto: ast::proto_box,\n+            inputs: [t_arg], output: ty::mk_nil(tcx),\n+            ret_style: ast::return_val, constraints: []\n+        });\n+        write_ty_to_tcx(tcx, it.id, t_res);\n+        write_ty_to_tcx(tcx, ctor_id, t_ctor);\n+        tcx.tcache.insert(local_def(ctor_id),\n+                          {bounds: bounds,\n+                           rp: rp,\n+                           ty: t_ctor});\n+        tcx.tcache.insert(def_id, {bounds: bounds,\n+                                   rp: rp,\n+                                   ty: t_res});\n+        write_ty_to_tcx(tcx, dtor_id, t_dtor);\n+      }\n+      ast::item_iface(*) {\n+        let tpt = ty_of_item(ccx, it);\n+        #debug[\"item_iface(it.id=%d, tpt.ty=%s)\",\n+               it.id, ty_to_str(tcx, tpt.ty)];\n+        write_ty_to_tcx(tcx, it.id, tpt.ty);\n+        ensure_iface_methods(ccx, it.id);\n+      }\n+      ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n+        // Write the class type\n+        let tpt = ty_of_item(ccx, it);\n+        write_ty_to_tcx(tcx, it.id, tpt.ty);\n+        // Write the ctor type\n+        let t_ctor =\n+            ty::mk_fn(\n+                tcx,\n+                astconv::ty_of_fn_decl(ccx,\n+                                       empty_rscope,\n+                                       ast::proto_any,\n+                                       ctor.node.dec,\n+                                       none));\n+        write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n+        tcx.tcache.insert(local_def(ctor.node.id),\n+                          {bounds: tpt.bounds,\n+                           rp: ast::rp_none,\n+                           ty: t_ctor});\n+        option::iter(m_dtor) {|dtor|\n+            // Write the dtor type\n+            let t_dtor = ty::mk_fn(\n+                tcx,\n+                // not sure about empty_rscope\n+                // FIXME\n+                astconv::ty_of_fn_decl(ccx,\n+                                       empty_rscope,\n+                                       ast::proto_any,\n+                                       ast_util::dtor_dec(),\n+                                       none));\n+            write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n+            tcx.tcache.insert(local_def(dtor.node.id),\n+                              {bounds: tpt.bounds,\n+                               rp: ast::rp_none,\n+                               ty: t_dtor});\n+        };\n+        ensure_iface_methods(ccx, it.id);\n+        /* FIXME: check for proper public/privateness */\n+        // Write the type of each of the members\n+        let (fields, methods) = split_class_items(members);\n+        for fields.each {|f|\n+            convert_class_item(ccx, rp, f);\n+        }\n+        // The selfty is just the class type\n+        let {bounds:_, substs} = mk_substs(ccx, tps, rp);\n+        let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n+        // Need to convert all methods so we can check internal\n+        // references to private methods\n+\n+        // NDM to TJC---I think we ought to be using bounds here, not @[].\n+        // But doing so causes errors later on.\n+        convert_methods(ccx, methods, rp, @[], selfty);\n+\n+        /*\n+        Finally, check that the class really implements the ifaces\n+        that it claims to implement.\n+        */\n+        for ifaces.each { |ifce|\n+            check_methods_against_iface(ccx, tps, rp, selfty,\n+                                        ifce, methods);\n+            let t = ty::node_id_to_type(tcx, ifce.id);\n+\n+            // FIXME: This assumes classes only implement\n+            // non-parameterized ifaces. add a test case for\n+            // a class implementing a parameterized iface.\n+            // -- tjc (#1726)\n+            tcx.tcache.insert(local_def(ifce.id), no_params(t));\n+        }\n+      }\n+      _ {\n+        // This call populates the type cache with the converted type\n+        // of the item in passing. All we have to do here is to write\n+        // it into the node type table.\n+        let tpt = ty_of_item(ccx, it);\n+        write_ty_to_tcx(tcx, it.id, tpt.ty);\n+      }\n+    }\n+}\n+fn convert_native(ccx: @crate_ctxt, i: @ast::native_item) {\n+    // As above, this call populates the type table with the converted\n+    // type of the native item. We simply write it into the node type\n+    // table.\n+    let tpt = ty_of_native_item(ccx, i);\n+    alt i.node {\n+      ast::native_item_fn(_, _) {\n+        write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n+      }\n+    }\n+}\n+fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n+        visit_item: bind convert(ccx, _),\n+        visit_native_item: bind convert_native(ccx, _)\n+        with *visit::default_simple_visitor()\n+    }));\n+}\n+\n+fn ty_of_method(ccx: @crate_ctxt,\n+                m: @ast::method,\n+                rp: ast::region_param) -> ty::method {\n+    {ident: m.ident,\n+     tps: astconv::ty_param_bounds(ccx, m.tps),\n+     fty: astconv::ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n+                                 m.decl, none),\n+     purity: m.decl.purity,\n+     vis: m.vis}\n+}\n+\n+fn ty_of_ty_method(self: @crate_ctxt,\n+                   m: ast::ty_method,\n+                   rp: ast::region_param) -> ty::method {\n+    {ident: m.ident,\n+     tps: astconv::ty_param_bounds(self, m.tps),\n+     fty: astconv::ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n+                                 m.decl, none),\n+     // assume public, because this is only invoked on iface methods\n+     purity: m.decl.purity, vis: ast::public}\n+}"}, {"sha": "293ea3144dc2d13cd72a8133015e9a934b7069f5", "filename": "src/rustc/middle/typeck/vtable.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -0,0 +1,271 @@\n+fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n+    vec::any(tps, {|bs|\n+        vec::any(*bs, {|b|\n+            alt b { ty::bound_iface(_) { true } _ { false } }\n+        })\n+    })\n+}\n+\n+fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+                  bounds: @[ty::param_bounds], substs: ty::substs,\n+                  allow_unsafe: bool) -> vtable_res {\n+    let tcx = fcx.ccx.tcx;\n+    let mut result = [], i = 0u;\n+    for substs.tps.each {|ty|\n+        for vec::each(*bounds[i]) {|bound|\n+            alt bound {\n+              ty::bound_iface(i_ty) {\n+                let i_ty = ty::subst(tcx, substs, i_ty);\n+                result += [lookup_vtable(fcx, isc, sp, ty, i_ty,\n+                                         allow_unsafe)];\n+              }\n+              _ {}\n+            }\n+        }\n+        i += 1u;\n+    }\n+    @result\n+}\n+\n+fn fixup_substs(fcx: @fn_ctxt, sp: span,\n+                id: ast::def_id, substs: ty::substs) -> ty::substs {\n+    let tcx = fcx.ccx.tcx;\n+    // use a dummy type just to package up the substs that need fixing up\n+    let t = ty::mk_iface(tcx, id, substs);\n+    let t_f = fixup_ty(fcx, sp, t);\n+    alt check ty::get(t_f).struct {\n+      ty::ty_iface(_, substs_f) { substs_f }\n+    }\n+}\n+\n+fn relate_iface_tys(fcx: @fn_ctxt, sp: span,\n+                    exp_iface_ty: ty::t, act_iface_ty: ty::t) {\n+    demand::suptype(fcx, sp, exp_iface_ty, act_iface_ty)\n+}\n+\n+/*\n+Look up the vtable to use when treating an item of type <t>\n+as if it has type <iface_ty>\n+*/\n+fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+                 ty: ty::t, iface_ty: ty::t, allow_unsafe: bool)\n+    -> vtable_origin {\n+\n+    #debug[\"lookup_vtable(ty=%s, iface_ty=%s)\",\n+           fcx.ty_to_str(ty), fcx.ty_to_str(iface_ty)];\n+    let _i = indenter();\n+\n+    let tcx = fcx.ccx.tcx;\n+    let (iface_id, iface_substs) = alt check ty::get(iface_ty).struct {\n+      ty::ty_iface(did, substs) { (did, substs) }\n+    };\n+    let ty = fixup_ty(fcx, sp, ty);\n+    alt ty::get(ty).struct {\n+      ty::ty_param(n, did) {\n+        let mut n_bound = 0u;\n+        for vec::each(*tcx.ty_param_bounds.get(did.node)) { |bound|\n+            alt bound {\n+              ty::bound_send | ty::bound_copy { /* ignore */ }\n+              ty::bound_iface(ity) {\n+                alt check ty::get(ity).struct {\n+                  ty::ty_iface(idid, substs) {\n+                    if iface_id == idid {\n+                        relate_iface_tys(fcx, sp, iface_ty, ity);\n+                        ret vtable_param(n, n_bound);\n+                    }\n+                  }\n+                }\n+                n_bound += 1u;\n+              }\n+            }\n+        }\n+      }\n+\n+      ty::ty_iface(did, substs) if iface_id == did {\n+        relate_iface_tys(fcx, sp, iface_ty, ty);\n+        if !allow_unsafe {\n+            for vec::each(*ty::iface_methods(tcx, did)) {|m|\n+                if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n+                    tcx.sess.span_err(\n+                        sp, \"a boxed iface with self types may not be \\\n+                             passed as a bounded type\");\n+                } else if (*m.tps).len() > 0u {\n+                    tcx.sess.span_err(\n+                        sp, \"a boxed iface with generic methods may not \\\n+                             be passed as a bounded type\");\n+\n+                }\n+            }\n+        }\n+        ret vtable_iface(did, substs.tps);\n+      }\n+\n+      _ {\n+        let mut found = [];\n+\n+        for list::each(isc) {|impls|\n+            /* For each impl in scope... */\n+                for vec::each(*impls) {|im|\n+                    // im = one specific impl\n+                    // find the iface that im implements (if any)\n+                    let of_ty = alt ty::impl_iface(tcx, im.did) {\n+                      some(of_ty) { of_ty }\n+                      _ { cont; }\n+                    };\n+\n+                    // it must have the same id as the expected one\n+                    alt ty::get(of_ty).struct {\n+                      ty::ty_iface(id, _) if id != iface_id { cont; }\n+                      _ { /* ok */ }\n+                    }\n+\n+                    // check whether the type unifies with the type\n+                    // that the impl is for, and continue if not\n+                    let {substs: substs, ty: for_ty} =\n+                        impl_self_ty(fcx, im.did);\n+                    let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                    alt fcx.mk_subty(ty, for_ty) {\n+                      result::err(_) { cont; }\n+                      result::ok(()) { }\n+                    }\n+\n+                    // check that desired iface type unifies\n+                    let of_ty = ty::subst(tcx, substs, of_ty);\n+                    relate_iface_tys(fcx, sp, iface_ty, of_ty);\n+\n+                    // recursively process the bounds\n+                    let iface_tps = iface_substs.tps;\n+                    let substs_f = fixup_substs(fcx, sp, iface_id, substs);\n+                    connect_iface_tps(fcx, sp, substs_f.tps,\n+                                      iface_tps, im.did);\n+                    let subres = lookup_vtables(fcx, isc, sp,\n+                                                im_bs, substs_f, false);\n+                    found += [vtable_static(im.did, substs_f.tps, subres)];\n+                }\n+\n+                alt found.len() {\n+                  0u { /* fallthrough */ }\n+                  1u { ret found[0]; }\n+                  _ {\n+                    fcx.ccx.tcx.sess.span_err(\n+                        sp, \"multiple applicable methods in scope\");\n+                    ret found[0];\n+                  }\n+                }\n+            }\n+          }\n+        }\n+\n+        tcx.sess.span_fatal(\n+            sp, \"failed to find an implementation of interface \" +\n+            ty_to_str(tcx, iface_ty) + \" for \" +\n+            ty_to_str(tcx, ty));\n+    }\n+\n+fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n+    let tcx = fcx.ccx.tcx;\n+    alt infer::resolve_deep(fcx.infcx, ty, true) {\n+      result::ok(new_type) { new_type }\n+      result::err(e) {\n+        tcx.sess.span_fatal(\n+            sp,\n+            #fmt[\"cannot determine a type \\\n+                  for this bounded type parameter: %s\",\n+                 infer::fixup_err_to_str(e)])\n+      }\n+    }\n+}\n+\n+fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n+                     iface_tys: [ty::t], impl_did: ast::def_id) {\n+    let tcx = fcx.ccx.tcx;\n+    let ity = option::get(ty::impl_iface(tcx, impl_did));\n+    let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n+    alt check ty::get(iface_ty).struct {\n+      ty::ty_iface(_, substs) {\n+        vec::iter2(substs.tps, iface_tys,\n+                   {|a, b| demand::suptype(fcx, sp, a, b);});\n+      }\n+    }\n+}\n+\n+fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+    let cx = fcx.ccx;\n+    alt ex.node {\n+      ast::expr_path(*) {\n+        alt fcx.opt_node_ty_substs(ex.id) {\n+          some(substs) {\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n+            let item_ty = ty::lookup_item_type(cx.tcx, did);\n+            if has_iface_bounds(*item_ty.bounds) {\n+                let impls = cx.impl_map.get(ex.id);\n+                cx.vtable_map.insert(ex.id, lookup_vtables(\n+                    fcx, impls, ex.span,\n+                    item_ty.bounds, substs, false));\n+            }\n+          }\n+          _ {}\n+        }\n+      }\n+      // Must resolve bounds on methods with bounded params\n+      ast::expr_field(*) | ast::expr_binary(*) |\n+      ast::expr_unary(*) | ast::expr_assign_op(*) |\n+      ast::expr_index(*) {\n+        alt cx.method_map.find(ex.id) {\n+          some(method_static(did)) {\n+            let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+            if has_iface_bounds(*bounds) {\n+                let callee_id = alt ex.node {\n+                  ast::expr_field(_, _, _) { ex.id }\n+                  _ { ast_util::op_expr_callee_id(ex) }\n+                };\n+                let substs = fcx.node_ty_substs(callee_id);\n+                let iscs = cx.impl_map.get(ex.id);\n+                cx.vtable_map.insert(callee_id, lookup_vtables(\n+                    fcx, iscs, ex.span, bounds, substs, false));\n+            }\n+          }\n+          _ {}\n+        }\n+      }\n+      ast::expr_cast(src, _) {\n+        let target_ty = fcx.expr_ty(ex);\n+        alt ty::get(target_ty).struct {\n+          ty::ty_iface(*) {\n+            /* Casting to an interface type.\n+            Look up all impls for the cast expr...\n+            */\n+            let impls = cx.impl_map.get(ex.id);\n+            /*\n+            Look up vtables for the type we're casting to,\n+            passing in the source and target type\n+            */\n+            let vtable = lookup_vtable(fcx, impls, ex.span,\n+                                       fcx.expr_ty(src), target_ty,\n+                                       true);\n+            /*\n+            Map this expression to that vtable (that is: \"ex has\n+            vtable <vtable>\")\n+            */\n+            cx.vtable_map.insert(ex.id, @[vtable]);\n+          }\n+          _ {}\n+        }\n+      }\n+      _ {}\n+    }\n+    visit::visit_expr(ex, fcx, v);\n+}\n+\n+// Detect points where an interface-bounded type parameter is\n+// instantiated, resolve the impls for the parameters.\n+fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n+    visit::visit_block(bl, fcx, visit::mk_vt(@{\n+        visit_expr: resolve_expr,\n+        visit_item: fn@(_i: @ast::item, &&_e: @fn_ctxt,\n+                        _v: visit::vt<@fn_ctxt>) {}\n+        with *visit::default_visitor()\n+    }));\n+}\n+\n+"}, {"sha": "914c47879253e533fe912340c6f9931a71d8660c", "filename": "src/rustc/middle/typeck/writeback.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -0,0 +1,184 @@\n+// Type resolution: the phase that finds all the types in the AST with\n+// unresolved type variables and replaces \"ty_var\" types with their\n+// substitutions.\n+export resolve_type_vars_in_fn;\n+export resolve_type_vars_in_expr;\n+\n+fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n+    option<ty::t> {\n+    if !ty::type_needs_infer(typ) { ret some(typ); }\n+    alt infer::resolve_deep(fcx.infcx, typ, true) {\n+      result::ok(new_type) { ret some(new_type); }\n+      result::err(e) {\n+        if !fcx.ccx.tcx.sess.has_errors() {\n+            fcx.ccx.tcx.sess.span_err(\n+                sp,\n+                #fmt[\"cannot determine a type \\\n+                      for this expression: %s\",\n+                     infer::fixup_err_to_str(e)])\n+        }\n+        ret none;\n+      }\n+    }\n+}\n+fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n+    -> option<ty::t> {\n+    let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n+    let n_ty = fcx.node_ty(id);\n+    alt resolve_type_vars_in_type(fcx, sp, n_ty) {\n+      none {\n+        wbcx.success = false;\n+        ret none;\n+      }\n+\n+      some(t) {\n+        #debug[\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+               id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)];\n+        write_ty_to_tcx(tcx, id, t);\n+        alt fcx.opt_node_ty_substs(id) {\n+          some(substs) {\n+            let mut new_tps = [];\n+            for substs.tps.each {|subst|\n+                alt resolve_type_vars_in_type(fcx, sp, subst) {\n+                  some(t) { new_tps += [t]; }\n+                  none { wbcx.success = false; ret none; }\n+                }\n+            }\n+            write_substs_to_tcx(tcx, id, new_tps);\n+          }\n+          none {}\n+        }\n+        ret some(t);\n+      }\n+    }\n+}\n+\n+fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n+                                    id: ast::node_id)\n+    -> option<ty::t> {\n+    if wbcx.fcx.node_types.contains_key(id as uint) {\n+        resolve_type_vars_for_node(wbcx, sp, id)\n+    } else {\n+        none\n+    }\n+}\n+\n+type wb_ctxt =\n+    // As soon as we hit an error we have to stop resolving\n+    // the entire function\n+    {fcx: @fn_ctxt, mut success: bool};\n+type wb_vt = visit::vt<wb_ctxt>;\n+\n+fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n+    if !wbcx.success { ret; }\n+    resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n+    visit::visit_stmt(s, wbcx, v);\n+}\n+fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n+    if !wbcx.success { ret; }\n+    resolve_type_vars_for_node(wbcx, e.span, e.id);\n+    alt e.node {\n+      ast::expr_fn(_, decl, _, _) |\n+      ast::expr_fn_block(decl, _, _) {\n+        vec::iter(decl.inputs) {|input|\n+            let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+\n+            // Just in case we never constrained the mode to anything,\n+            // constrain it to the default for the type in question.\n+            alt (r_ty, input.mode) {\n+              (some(t), ast::infer(_)) {\n+                let tcx = wbcx.fcx.ccx.tcx;\n+                let m_def = ty::default_arg_mode_for_ty(t);\n+                ty::set_default_mode(tcx, input.mode, m_def);\n+              }\n+              _ {}\n+            }\n+        }\n+      }\n+\n+      ast::expr_new(_, alloc_id, _) {\n+        resolve_type_vars_for_node(wbcx, e.span, alloc_id);\n+      }\n+\n+      ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n+      ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n+        maybe_resolve_type_vars_for_node(wbcx, e.span,\n+                                         ast_util::op_expr_callee_id(e));\n+      }\n+\n+      _ { }\n+    }\n+    visit::visit_expr(e, wbcx, v);\n+}\n+fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n+    if !wbcx.success { ret; }\n+    resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n+    visit::visit_block(b, wbcx, v);\n+}\n+fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n+    if !wbcx.success { ret; }\n+    resolve_type_vars_for_node(wbcx, p.span, p.id);\n+    #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n+           pat_to_str(p), p.id,\n+           wbcx.fcx.ty_to_str(\n+               ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n+                                   p.id))];\n+    visit::visit_pat(p, wbcx, v);\n+}\n+fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n+    if !wbcx.success { ret; }\n+    let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n+    alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, true) {\n+      result::ok(lty) {\n+        #debug[\"Type for local %s (id %d) resolved to %s\",\n+               pat_to_str(l.node.pat), l.node.id,\n+               wbcx.fcx.ty_to_str(lty)];\n+        write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n+      }\n+      result::err(e) {\n+        wbcx.fcx.ccx.tcx.sess.span_err(\n+            l.span,\n+            #fmt[\"cannot determine a type \\\n+                  for this local variable: %s\",\n+                 infer::fixup_err_to_str(e)]);\n+        wbcx.success = false;\n+      }\n+    }\n+    visit::visit_local(l, wbcx, v);\n+}\n+fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n+    // Ignore items\n+}\n+\n+fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n+    let wbcx = {fcx: fcx, mut success: true};\n+    let visit =\n+        visit::mk_vt(@{visit_item: visit_item,\n+                       visit_stmt: visit_stmt,\n+                       visit_expr: visit_expr,\n+                       visit_block: visit_block,\n+                       visit_pat: visit_pat,\n+                       visit_local: visit_local\n+                       with *visit::default_visitor()});\n+    visit.visit_expr(e, wbcx, visit);\n+    ret wbcx.success;\n+}\n+\n+fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n+                           decl: ast::fn_decl,\n+                           blk: ast::blk) -> bool {\n+    let wbcx = {fcx: fcx, mut success: true};\n+    let visit =\n+        visit::mk_vt(@{visit_item: visit_item,\n+                       visit_stmt: visit_stmt,\n+                       visit_expr: visit_expr,\n+                       visit_block: visit_block,\n+                       visit_pat: visit_pat,\n+                       visit_local: visit_local\n+                       with *visit::default_visitor()});\n+    visit.visit_block(blk, wbcx, visit);\n+    for decl.inputs.each {|arg|\n+        resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n+    }\n+    ret wbcx.success;\n+}"}, {"sha": "a1ae3943998f41c659c1e227a9795b77f78698eb", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/26dc48d67f7f1281e40f5d4e89db17e19c3aea53/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=26dc48d67f7f1281e40f5d4e89db17e19c3aea53", "patch": "@@ -52,7 +52,12 @@ mod middle {\n     mod infer;\n     mod ast_map;\n     mod resolve;\n-    mod typeck;\n+    mod typeck {\n+        mod astconv;\n+        mod collect;\n+        mod vtable;\n+        mod writeback;\n+    }\n     mod check_loop;\n     mod check_alt;\n     mod check_const;"}]}