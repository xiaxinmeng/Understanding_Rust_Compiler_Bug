{"sha": "c77cd480cf2105afcbb92de4f514f1f9637912c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3N2NkNDgwY2YyMTA1YWZjYmI5MmRlNGY1MTRmMWY5NjM3OTEyYzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-05T18:02:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T02:05:50Z"}, "message": "Introduce the DepGraph and DepTracking map abstractions,\nalong with a README explaining how they are to be used", "tree": {"sha": "e20124bc8fe86c9183716ac5fe0c7d47228c5efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e20124bc8fe86c9183716ac5fe0c7d47228c5efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c77cd480cf2105afcbb92de4f514f1f9637912c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c77cd480cf2105afcbb92de4f514f1f9637912c5", "html_url": "https://github.com/rust-lang/rust/commit/c77cd480cf2105afcbb92de4f514f1f9637912c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c77cd480cf2105afcbb92de4f514f1f9637912c5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7", "html_url": "https://github.com/rust-lang/rust/commit/badc23b6ad47c6b6d401a3ea1dc5163bdcd86cd7"}], "stats": {"total": 1131, "additions": 1127, "deletions": 4}, "files": [{"sha": "c607894c5e338b0e9ff880ee7c9d06f2f62988fe", "filename": "src/librustc/dep_graph/README.md", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,384 @@\n+# Dependency graph for incremental compilation\n+\n+This module contains the infrastructure for managing the incremental\n+compilation dependency graph. This README aims to explain how it ought\n+to be used. In this document, we'll first explain the overall\n+strategy, and then share some tips for handling specific scenarios.\n+\n+The high-level idea is that we want to instrument the compiler to\n+track which parts of the AST and other IR are read/written by what.\n+This way, when we come back later, we can look at this graph and\n+determine what work needs to be redone.\n+\n+### The dependency graph\n+\n+The nodes of the graph are defined by the enum `DepNode`. They represent\n+one of three things:\n+\n+1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n+2. Data nodes (like `ItemSignature(DefId)`) represent some computed\n+   information about a particular item.\n+3. Procedure notes (like `CoherenceCheckImpl(DefId)`) represent some\n+   procedure that is executing. Usually this procedure is\n+   performing some kind of check for errors. You can think of them as\n+   computed values where the value being computed is `()` (and the\n+   value may fail to be computed, if an error results).\n+\n+An edge `N1 -> N2` is added between two nodes if either:\n+\n+- the value of `N1` is used to compute `N2`;\n+- `N1` is read by the procedure `N2`;\n+- the procedure `N1` writes the value `N2`.\n+\n+The latter two conditions are equivalent to the first one if you think\n+of procedures as values.\n+\n+### Basic tracking\n+\n+There is a very general strategy to ensure that you have a correct, if\n+sometimes overconservative, dependency graph. The two main things you have\n+to do are (a) identify shared state and (b) identify the current tasks.\n+\n+### Identifying shared state\n+\n+Identify \"shared state\" that will be written by one pass and read by\n+another. In particular, we need to identify shared state that will be\n+read \"across items\" -- that is, anything where changes in one item\n+could invalidate work done for other items. So, for example:\n+\n+1. The signature for a function is \"shared state\".\n+2. The computed type of some expression in the body of a function is\n+   not shared state, because if it changes it does not itself\n+   invalidate other functions (though it may be that it causes new\n+   monomorphizations to occur, but that's handled independently).\n+   \n+Put another way: if the HIR for an item changes, we are going to\n+recompile that item for sure. But we need the dep tracking map to tell\n+us what *else* we have to recompile. Shared state is anything that is\n+used to communicate results from one item to another.\n+\n+### Identifying the current task\n+\n+The dep graph always tracks a current task: this is basically the\n+`DepNode` that the compiler is computing right now. Typically it would\n+be a procedure node, but it can also be a data node (as noted above,\n+the two are kind of equivalent).\n+\n+You set the current task by calling `dep_graph.in_task(node)`. For example:\n+\n+```rust\n+let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n+```\n+\n+Now all the code until `_task` goes out of scope will be considered\n+part of the \"privacy task\".\n+\n+The tasks are maintained in a stack, so it is perfectly fine to nest\n+one task within another. Because pushing a task is considered to be\n+computing a value, when you nest a task `N2` inside of a task `N1`, we\n+automatically add an edge `N2 -> N1` (since `N1` presumably needed the\n+result of `N2` to complete):\n+\n+```rust\n+let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n+let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n+// this will result in an edge N1 -> n2\n+```\n+\n+### Ignore tasks\n+\n+Although it is rarely needed, you can also push a special \"ignore\"\n+task:\n+\n+```rust\n+let _ignore = tc.dep_graph.in_ignore();\n+```\n+\n+This will cause all read/write edges to be ignored until it goes out\n+of scope or until something else is pushed. For example, we could\n+suppress the edge between nested tasks like so:\n+\n+```rust\n+let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n+let _ignore = tcx.dep_graph.in_ignore();\n+let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n+// now no edge is added\n+```\n+\n+### Tracking reads and writes\n+\n+We need to identify what shared state is read/written by the current\n+task as it executes. The most fundamental way of doing that is to invoke\n+the `read` and `write` methods on `DepGraph`:\n+\n+```rust\n+// Adds an edge from DepNode::Hir(some_def_id) to the current task\n+tcx.dep_graph.read(DepNode::Hir(some_def_id))\n+\n+// Adds an edge from the current task to DepNode::ItemSignature(some_def_id)\n+tcx.dep_graph.write(DepNode::ItemSignature(some_def_id))\n+```\n+\n+However, you should rarely need to invoke those methods directly.\n+Instead, the idea is to *encapsulate* shared state into some API that\n+will invoke `read` and `write` automatically. The most common way to\n+do this is to use a `DepTrackingMap`, described in the next section,\n+but any sort of abstraction brarier will do. In general, the strategy\n+is that getting access to information implicitly adds an appropriate\n+`read`. So, for example, when you use the\n+`dep_graph::visit_all_items_in_krate` helper method, it will visit\n+each item `X`, start a task `Foo(X)` for that item, and automatically\n+add an edge `Hir(X) -> Foo(X)`. This edge is added because the code is\n+being given access to the HIR node for `X`, and hence it is expected\n+to read from it. Similarly, reading from the `tcache` map for item `X`\n+(which is a `DepTrackingMap`, described below) automatically invokes\n+`dep_graph.read(ItemSignature(X))`.\n+\n+To make this strategy work, a certain amount of indirection is\n+required. For example, modules in the HIR do not have direct pointers\n+to the items that they contain. Rather, they contain node-ids -- one\n+can then ask the HIR map for the item with a given node-id. This gives\n+us an opportunity to add an appropriate read edge.\n+\n+#### Explicit calls to read and write when starting a new subtask\n+\n+One time when you *may* need to call `read` and `write` directly is\n+when you push a new task onto the stack, either by calling `in_task`\n+as shown above or indirectly, such as with the `memoize` pattern\n+described below. In that case, any data that the task has access to\n+from the surrounding environment must be explicitly \"read\". For\n+example, in `librustc_typeck`, the collection code visits all items\n+and, among other things, starts a subtask producing its signature\n+(what follows is simplified pseudocode, of course):\n+\n+```rust\n+fn visit_item(item: &hir::Item) {\n+    // Here, current subtask is \"Collect(X)\", and an edge Hir(X) -> Collect(X)\n+    // has automatically been added by `visit_all_items_in_krate`.\n+    let sig = signature_of_item(item);\n+}\n+\n+fn signature_of_item(item: &hir::Item) {\n+    let def_id = tcx.map.local_def_id(item.id);\n+    let task = tcx.dep_graph.in_task(DepNode::ItemSignature(def_id));\n+    tcx.dep_graph.read(DepNode::Hir(def_id)); // <-- the interesting line\n+    ...\n+}\n+```\n+\n+Here you can see that, in `signature_of_item`, we started a subtask\n+corresponding to producing the `ItemSignature`. This subtask will read from\n+`item` -- but it gained access to `item` implicitly. This means that if it just\n+reads from `item`, there would be missing edges in the graph:\n+\n+    Hir(X) --+ // added by the explicit call to `read`\n+      |      |\n+      |      +---> ItemSignature(X) -> Collect(X)\n+      |                                 ^\n+      |                                 |\n+      +---------------------------------+ // added by `visit_all_items_in_krate`\n+    \n+In particular, the edge from `Hir(X)` to `ItemSignature(X)` is only\n+present because we called `read` ourselves when entering the `ItemSignature(X)`\n+task.\n+\n+So, the rule of thumb: when entering a new task yourself, register\n+reads on any shared state that you inherit. (This actually comes up\n+fairly infrequently though: the main place you need caution is around\n+memoization.)\n+\n+#### Dependency tracking map\n+\n+`DepTrackingMap` is a particularly convenient way to correctly store\n+shared state. A `DepTrackingMap` is a special hashmap that will add\n+edges automatically when `get` and `insert` are called. The idea is\n+that, when you get/insert a value for the key `K`, we will add an edge\n+from/to the node `DepNode::Variant(K)` (for some variant specific to\n+the map).\n+\n+Each `DepTrackingMap` is parameterized by a special type `M` that\n+implements `DepTrackingMapId`; this trait defines the key and value\n+types of the map, and also defines a fn for converting from the key to\n+a `DepNode` label. You don't usually have to muck about with this by\n+hand, there is a macro for creating it. You can see the complete set\n+of `DepTrackingMap` definitions in `librustc/middle/ty/maps.rs`.\n+\n+As an example, let's look at the `adt_defs` map. The `adt_defs` map\n+maps from the def-id of a struct/enum to its `AdtDef`. It is defined\n+using this macro:\n+\n+```rust\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+//            ~~~~~~~  ~~~~~~~~~~~~~ ~~~~~     ~~~~~~~~~~~~~~~~~~~~~~\n+//               |           |      Key type       Value type\n+//               |    DepNode variant\n+//      Name of map id type\n+```\n+\n+this indicates that a map id type `AdtDefs` will be created. The key\n+of the map will be a `DefId` and value will be\n+`ty::AdtDefMaster<'tcx>`. The `DepNode` will be created by\n+`DepNode::ItemSignature(K)` for a given key.\n+\n+Once that is done, you can just use the `DepTrackingMap` like any\n+other map.\n+\n+#### Memoization\n+\n+One particularly interesting case is memoization. If you have some\n+shared state that you compute in a memoized fashion, the correct thing\n+to do is to define a `RefCell<DepTrackingMap>` for it and use the\n+`memoize` helper:\n+\n+```rust\n+map.memoize(key, || /* compute value */)\n+```\n+\n+This will create a graph that looks like\n+\n+    ... -> MapVariant(key) -> CurrentTask\n+\n+where `MapVariant` is the `DepNode` variant that the map is associated with,\n+and `...` are whatever edges the `/* compute value */` closure creates.\n+\n+In particular, using the memoize helper is much better than writing\n+the obvious code yourself:\n+\n+```\n+if let Some(result) = map.get(key) {\n+    return result;\n+}\n+let value = /* compute value */;\n+map.insert(key, value);\n+```\n+\n+If you write that code manually, the dependency graph you get will\n+include artificial edges that are not necessary. For example, imagine that\n+two tasks, A and B, both invoke the manual memoization code, but A happens\n+to go first. The resulting graph will be:\n+\n+    ... -> A -> MapVariant(key) -> B\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~       // caused by A writing to MapVariant(key)\n+                ~~~~~~~~~~~~~~~~~~~~  // caused by B reading from MapVariant(key)\n+\n+This graph is not *wrong*, but it encodes a path from A to B that\n+should not exist.  In contrast, using the memoized helper, you get:\n+\n+    ... -> MapVariant(key) -> A\n+                 |\n+                 +----------> B\n+                 \n+which is much cleaner.                 \n+\n+**Be aware though that the closure is executed with `MapVariant(key)`\n+pushed onto the stack as the current task!** That means that you must\n+add explicit `read` calls for any shared state that it accesses\n+implicitly from its environment. See the section on \"explicit calls to\n+read and write when starting a new subtask\" above for more details.\n+\n+### How to decide where to introduce a new task\n+\n+Certainly, you need at least one task on the stack: any attempt to\n+`read` or `write` shared state will panic if there is no current\n+task. But where does it make sense to introduce subtasks? The basic\n+rule is that a subtask makes sense for any discrete unit of work you\n+may want to skip in the future. Adding a subtask separates out the\n+reads/writes from *that particular subtask* versus the larger\n+context. An example: you might have a 'meta' task for all of borrow\n+checking, and then subtasks for borrow checking individual fns.  (Seen\n+in this light, memoized computations are just a special case where we\n+may want to avoid redoing the work even within the context of one\n+compilation.)\n+\n+The other case where you might want a subtask is to help with refining\n+the reads/writes for some later bit of work that needs to be memoized.\n+For example, we create a subtask for type-checking the body of each\n+fn.  However, in the initial version of incr. comp. at least, we do\n+not expect to actually *SKIP* type-checking -- we only expect to skip\n+trans. However, it's still useful to create subtasks for type-checking\n+individual items, because, otherwise, if a fn sig changes, we won't\n+know which callers are affected -- in fact, because the graph would be\n+so coarse, we'd just have to retrans everything, since we can't\n+distinguish which fns used which fn sigs.\n+\n+### Testing the dependency graph\n+\n+There are various ways to write tests against the dependency graph.\n+The simplest mechanism are the\n+`#[rustc_if_this_changed` and `#[rustc_then_this_would_need]`\n+annotations. These are used in compile-fail tests to test whether the\n+expected set of paths exist in the dependency graph. As an example,\n+see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n+\n+The idea is that you can annotate a test like:\n+\n+```rust\n+#[rustc_if_this_changed]\n+fn foo() { }\n+\n+#[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+fn bar() { foo(); }\n+\n+#[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+fn baz() { }\n+```\n+\n+This will check whether there is a path in the dependency graph from\n+`Hir(foo)` to `TypeckItemBody(bar)`. An error is reported for each\n+`#[rustc_then_this_would_need]` annotation that indicates whether a\n+path exists. `//~ ERROR` annotations can then be used to test if a\n+path is found (as demonstrated above).\n+\n+### Debugging the dependency graph\n+\n+The compiler is also capable of dumping the dependency graph for your\n+debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n+graph will be dumped to `dep_graph.{txt,dot}` in the current\n+directory.  You can override the filename with the `RUST_DEP_GRAPH`\n+environment variable.\n+\n+Frequently, though, the full dep graph is quite overwhelming and not\n+particularly helpful. Therefore, the compiler also allows you to filter\n+the graph. You can filter in three ways:\n+\n+1. All edges originating in a particular set of nodes (usually a single node).\n+2. All edges reaching a particular set of nodes.\n+3. All edges that lie between given start and end nodes.\n+\n+To filter, use the `RUST_DEP_GRAPH_FILTER` environment variable, which should\n+look like one of the following:\n+\n+```\n+source_filter     // nodes originating from source_filter\n+-> target_filter  // nodes that can reach target_filter\n+source_filter -> target_filter // nodes in between source_filter and target_filter\n+```\n+\n+`source_filter` and `target_filter` are a comma-separated list of strings.\n+A node is considered to match a filter if all of those strings appear in its\n+label. So, for example:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='-> TypeckItemBody'\n+```\n+\n+would select the predecessors of all `TypeckItemBody` nodes. Usually though you\n+want the `TypeckItemBody` nod for some particular fn, so you might write:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='-> TypeckItemBody,bar'\n+```\n+\n+This will select only the `TypeckItemBody` nodes for fns with `bar` in their name.\n+\n+Perhaps you are finding that when you change `foo` you need to re-type-check `bar`,\n+but you don't think you should have to. In that case, you might do:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='Hir,foo -> TypeckItemBody,bar'\n+```\n+\n+This will dump out all the nodes that lead from `Hir(foo)` to\n+`TypeckItemBody(bar)`, from which you can (hopefully) see the source\n+of the erroneous edge.\n+"}, {"sha": "4f1063eae5029ee3a9570a4802ce564887d14912", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::cell::RefCell;\n+use std::ops::Index;\n+use std::hash::Hash;\n+use std::marker::PhantomData;\n+\n+use super::{DepNode, DepGraph};\n+\n+/// A DepTrackingMap offers a subset of the `Map` API and ensures that\n+/// we make calls to `read` and `write` as appropriate. We key the\n+/// maps with a unique type for brevity.\n+pub struct DepTrackingMap<M: DepTrackingMapId> {\n+    phantom: PhantomData<M>,\n+    graph: DepGraph,\n+    map: FnvHashMap<M::Key, M::Value>,\n+}\n+\n+pub trait DepTrackingMapId {\n+    type Key: Eq + Hash + Clone;\n+    type Value: Clone;\n+    fn to_dep_node(key: &Self::Key) -> DepNode;\n+}\n+\n+impl<M: DepTrackingMapId> DepTrackingMap<M> {\n+    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n+        DepTrackingMap {\n+            phantom: PhantomData,\n+            graph: graph,\n+            map: FnvHashMap()\n+        }\n+    }\n+\n+    /// Registers a (synthetic) read from the key `k`. Usually this\n+    /// is invoked automatically by `get`.\n+    fn read(&self, k: &M::Key) {\n+        let dep_node = M::to_dep_node(k);\n+        self.graph.read(dep_node);\n+    }\n+\n+    /// Registers a (synthetic) write to the key `k`. Usually this is\n+    /// invoked automatically by `insert`.\n+    fn write(&self, k: &M::Key) {\n+        let dep_node = M::to_dep_node(k);\n+        self.graph.write(dep_node);\n+    }\n+\n+    pub fn get(&self, k: &M::Key) -> Option<&M::Value> {\n+        self.read(k);\n+        self.map.get(k)\n+    }\n+\n+    pub fn insert(&mut self, k: M::Key, v: M::Value) -> Option<M::Value> {\n+        self.write(&k);\n+        self.map.insert(k, v)\n+    }\n+\n+    pub fn contains_key(&self, k: &M::Key) -> bool {\n+        self.read(k);\n+        self.map.contains_key(k)\n+    }\n+}\n+\n+impl<'k, M: DepTrackingMapId> Index<&'k M::Key> for DepTrackingMap<M> {\n+    type Output = M::Value;\n+\n+    #[inline]\n+    fn index(&self, k: &'k M::Key) -> &M::Value {\n+        self.get(k).unwrap()\n+    }\n+}\n+"}, {"sha": "07b18944aa199ff1a25e63bb58d51d0387fe62f6", "filename": "src/librustc/dep_graph/edges.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use super::{DepGraphQuery, DepNode};\n+\n+pub struct DepGraphEdges {\n+    ids: Vec<DepNode>,\n+    indices: FnvHashMap<DepNode, IdIndex>,\n+    edges: FnvHashSet<(IdIndex, IdIndex)>,\n+    open_nodes: Vec<OpenNode>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+struct IdIndex {\n+    index: u32\n+}\n+\n+impl IdIndex {\n+    fn new(v: usize) -> IdIndex {\n+        assert!((v & 0xFFFF_FFFF) == v);\n+        IdIndex { index: v as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum OpenNode {\n+    Node(IdIndex),\n+    Ignore,\n+}\n+\n+impl DepGraphEdges {\n+    pub fn new() -> DepGraphEdges {\n+        DepGraphEdges {\n+            ids: vec![],\n+            indices: FnvHashMap(),\n+            edges: FnvHashSet(),\n+            open_nodes: Vec::new()\n+        }\n+    }\n+\n+    fn id(&self, index: IdIndex) -> &DepNode {\n+        &self.ids[index.index()]\n+    }\n+\n+    /// Creates a node for `id` in the graph.\n+    fn make_node(&mut self, id: DepNode) -> IdIndex {\n+        if let Some(&i) = self.indices.get(&id) {\n+            return i;\n+        }\n+\n+        let index = IdIndex::new(self.ids.len());\n+        self.ids.push(id.clone());\n+        self.indices.insert(id, index);\n+        index\n+    }\n+\n+    /// Top of the stack of open nodes.\n+    fn current_node(&self) -> Option<OpenNode> {\n+        self.open_nodes.last().cloned()\n+    }\n+\n+    pub fn push_ignore(&mut self) {\n+        self.open_nodes.push(OpenNode::Ignore);\n+    }\n+\n+    pub fn pop_ignore(&mut self) {\n+        let popped_node = self.open_nodes.pop().unwrap();\n+        assert_eq!(popped_node, OpenNode::Ignore);\n+    }\n+\n+    pub fn push_task(&mut self, key: DepNode) {\n+        let top_node = self.current_node();\n+\n+        let new_node = self.make_node(key.clone());\n+        self.open_nodes.push(OpenNode::Node(new_node));\n+\n+        // if we are in the midst of doing task T, then this new task\n+        // N is a subtask of T, so add an edge N -> T.\n+        if let Some(top_node) = top_node {\n+            self.add_edge_from_open_node(top_node, |t| (new_node, t));\n+        }\n+    }\n+\n+    pub fn pop_task(&mut self, key: DepNode) {\n+        let popped_node = self.open_nodes.pop().unwrap();\n+        assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n+    }\n+\n+    /// Indicates that the current task `C` reads `v` by adding an\n+    /// edge from `v` to `C`. If there is no current task, panics. If\n+    /// you want to suppress this edge, use `ignore`.\n+    pub fn read(&mut self, v: DepNode) {\n+        let source = self.make_node(v);\n+        self.add_edge_from_current_node(|current| (source, current))\n+    }\n+\n+    /// Indicates that the current task `C` writes `v` by adding an\n+    /// edge from `C` to `v`. If there is no current task, panics. If\n+    /// you want to suppress this edge, use `ignore`.\n+    pub fn write(&mut self, v: DepNode) {\n+        let target = self.make_node(v);\n+        self.add_edge_from_current_node(|current| (current, target))\n+    }\n+\n+    /// Invoke `add_edge_from_open_node` with the top of the stack, or\n+    /// panic if stack is empty.\n+    fn add_edge_from_current_node<OP>(&mut self,\n+                                      op: OP)\n+        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n+    {\n+        match self.current_node() {\n+            Some(open_node) => self.add_edge_from_open_node(open_node, op),\n+            None => panic!(\"no current node, cannot add edge into dependency graph\")\n+        }\n+    }\n+\n+    /// Adds an edge to or from the `open_node`, assuming `open_node`\n+    /// is not `Ignore`. The direction of the edge is determined by\n+    /// the closure `op` --- we pass as argument the open node `n`,\n+    /// and the closure returns a (source, target) tuple, which should\n+    /// include `n` in one spot or another.\n+    fn add_edge_from_open_node<OP>(&mut self,\n+                                   open_node: OpenNode,\n+                                   op: OP)\n+        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n+    {\n+        let (source, target) = match open_node {\n+            OpenNode::Node(n) => op(n),\n+            OpenNode::Ignore => { return; }\n+        };\n+\n+        // ignore trivial self edges, which are not very interesting\n+        if source == target {\n+            return;\n+        }\n+\n+        if self.edges.insert((source, target)) {\n+            debug!(\"adding edge from {:?} to {:?}\",\n+                   self.id(source),\n+                   self.id(target));\n+        }\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        let edges: Vec<_> = self.edges.iter()\n+                                      .map(|&(i, j)| (self.id(i).clone(), self.id(j).clone()))\n+                                      .collect();\n+        DepGraphQuery::new(&self.ids, &edges)\n+    }\n+}"}, {"sha": "c3d195811f235acf3de2b97ca65ab602d50d0444", "filename": "src/librustc/dep_graph/mod.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::thread::{DepGraphThreadData, DepMessage};\n+use middle::def_id::DefId;\n+use middle::ty;\n+use middle::ty::fast_reject::SimplifiedType;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use std::rc::Rc;\n+\n+mod dep_tracking_map;\n+mod edges;\n+mod query;\n+mod raii;\n+mod thread;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum DepNode {\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.map.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.map.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n+    Krate,\n+\n+    // Represents the HIR node with the given node-id\n+    Hir(DefId),\n+\n+    // Represents different phases in the compiler.\n+    CollectItem(DefId),\n+    Coherence,\n+    CoherenceCheckImpl(DefId),\n+    CoherenceOverlapCheck(DefId),\n+    CoherenceOverlapCheckSpecial(DefId),\n+    CoherenceOrphanCheck(DefId),\n+    Variance,\n+    WfCheck(DefId),\n+    TypeckItemType(DefId),\n+    TypeckItemBody(DefId),\n+    Dropck,\n+    DropckImpl(DefId),\n+    CheckConst(DefId),\n+    Privacy,\n+    IntrinsicCheck(DefId),\n+    MatchCheck(DefId),\n+    MirMapConstruction(DefId),\n+    BorrowCheck(DefId),\n+    RvalueCheck(DefId),\n+    Reachability,\n+    DeadCheck,\n+    StabilityCheck,\n+    LateLintCheck,\n+    IntrinsicUseCheck,\n+    TransCrate,\n+    TransCrateItem(DefId),\n+    TransInlinedItem(DefId),\n+    TransWriteMetadata,\n+\n+    // Nodes representing bits of computed IR in the tcx. Each shared\n+    // table in the tcx (or elsewhere) maps to one of these\n+    // nodes. Often we map multiple tables to the same node if there\n+    // is no point in distinguishing them (e.g., both the type and\n+    // predicates for an item wind up in `ItemSignature`). Other\n+    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n+    // might be mergable are kept distinct because the sets of def-ids\n+    // to which they apply are disjoint, and hence we might as well\n+    // have distinct labels for easier debugging.\n+    ImplOrTraitItems(DefId),\n+    ItemSignature(DefId),\n+    FieldTy(DefId),\n+    TraitItemDefIds(DefId),\n+    InherentImpls(DefId),\n+    ImplItems(DefId),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(DefId),\n+\n+    // Nodes representing caches. To properly handle a true cache, we\n+    // don't use a DepTrackingMap, but rather we push a task node.\n+    // Otherwise the write into the map would be incorrectly\n+    // attributed to the first task that happened to fill the cache,\n+    // which would yield an overly conservative dep-graph.\n+    TraitItems(DefId),\n+    ReprHints(DefId),\n+    TraitSelect(DefId, Option<SimplifiedType>),\n+}\n+\n+#[derive(Clone)]\n+pub struct DepGraph {\n+    data: Rc<DepGraphThreadData>\n+}\n+\n+impl DepGraph {\n+    pub fn new(enabled: bool) -> DepGraph {\n+        DepGraph {\n+            data: Rc::new(DepGraphThreadData::new(enabled))\n+        }\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        self.data.query()\n+    }\n+\n+    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n+        raii::IgnoreTask::new(&self.data)\n+    }\n+\n+    pub fn in_task<'graph>(&'graph self, key: DepNode) -> raii::DepTask<'graph> {\n+        raii::DepTask::new(&self.data, key)\n+    }\n+\n+    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_ignore();\n+        op()\n+    }\n+\n+    pub fn with_task<OP,R>(&self, key: DepNode, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_task(key);\n+        op()\n+    }\n+\n+    pub fn read(&self, v: DepNode) {\n+        self.data.enqueue(DepMessage::Read(v));\n+    }\n+\n+    pub fn write(&self, v: DepNode) {\n+        self.data.enqueue(DepMessage::Write(v));\n+    }\n+}\n+\n+pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapId};\n+\n+pub use self::query::DepGraphQuery;\n+\n+/// Visit all the items in the krate in some order. When visiting a\n+/// particular item, first create a dep-node by calling `dep_node_fn`\n+/// and push that onto the dep-graph stack of tasks, and also create a\n+/// read edge from the corresponding AST node. This is used in\n+/// compiler passes to automatically record the item that they are\n+/// working on.\n+pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &ty::ctxt<'tcx>,\n+                                          mut dep_node_fn: F,\n+                                          visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+{\n+    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n+        tcx: &'visit ty::ctxt<'tcx>,\n+        dep_node_fn: &'visit mut F,\n+        visitor: &'visit mut V\n+    }\n+\n+    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+    {\n+        fn visit_item(&mut self, i: &'tcx hir::Item) {\n+            let item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(item_def_id);\n+            debug!(\"About to start task {:?}\", task_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id);\n+            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+            self.visitor.visit_item(i)\n+        }\n+    }\n+\n+    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n+    let mut tracking_visitor = TrackingVisitor {\n+        tcx: tcx,\n+        dep_node_fn: &mut dep_node_fn,\n+        visitor: visitor\n+    };\n+    krate.visit_all_items(&mut tracking_visitor)\n+}"}, {"sha": "74a054acb4fa05c98aabf3c5a4afab035626ce3e", "filename": "src/librustc/dep_graph/query.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::graph::{Graph, NodeIndex};\n+\n+use super::DepNode;\n+\n+pub struct DepGraphQuery {\n+    pub graph: Graph<DepNode, ()>,\n+    pub indices: FnvHashMap<DepNode, NodeIndex>,\n+}\n+\n+impl DepGraphQuery {\n+    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+        let mut graph = Graph::new();\n+        let mut indices = FnvHashMap();\n+        for node in nodes {\n+            indices.insert(node.clone(), graph.next_node_index());\n+            graph.add_node(node.clone());\n+        }\n+\n+        for &(ref source, ref target) in edges {\n+            let source = indices[source];\n+            let target = indices[target];\n+            graph.add_edge(source, target, ());\n+        }\n+\n+        DepGraphQuery {\n+            graph: graph,\n+            indices: indices\n+        }\n+    }\n+\n+    pub fn nodes(&self) -> Vec<DepNode> {\n+        self.graph.all_nodes()\n+                  .iter()\n+                  .map(|n| n.data.clone())\n+                  .collect()\n+    }\n+\n+    pub fn edges(&self) -> Vec<(DepNode,DepNode)> {\n+        self.graph.all_edges()\n+                  .iter()\n+                  .map(|edge| (edge.source(), edge.target()))\n+                  .map(|(s, t)| (self.graph.node_data(s).clone(), self.graph.node_data(t).clone()))\n+                  .collect()\n+    }\n+\n+    /// All nodes reachable from `node`. In other words, things that\n+    /// will have to be recomputed if `node` changes.\n+    pub fn dependents(&self, node: DepNode) -> Vec<DepNode> {\n+        if let Some(&index) = self.indices.get(&node) {\n+            self.graph.depth_traverse(index)\n+                      .map(|dependent_node| self.graph.node_data(dependent_node).clone())\n+                      .collect()\n+        } else {\n+            vec![]\n+        }\n+    }\n+}"}, {"sha": "dd7ff92f9c360d2b9d2d878a0bc272258c81b9ed", "filename": "src/librustc/dep_graph/raii.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::DepNode;\n+use super::thread::{DepGraphThreadData, DepMessage};\n+\n+pub struct DepTask<'graph> {\n+    data: &'graph DepGraphThreadData,\n+    key: DepNode,\n+}\n+\n+impl<'graph> DepTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode) -> DepTask<'graph> {\n+        data.enqueue(DepMessage::PushTask(key));\n+        DepTask { data: data, key: key }\n+    }\n+}\n+\n+impl<'graph> Drop for DepTask<'graph> {\n+    fn drop(&mut self) {\n+        self.data.enqueue(DepMessage::PopTask(self.key));\n+    }\n+}\n+\n+pub struct IgnoreTask<'graph> {\n+    data: &'graph DepGraphThreadData\n+}\n+\n+impl<'graph> IgnoreTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData) -> IgnoreTask<'graph> {\n+        data.enqueue(DepMessage::PushIgnore);\n+        IgnoreTask { data: data }\n+    }\n+}\n+\n+impl<'graph> Drop for IgnoreTask<'graph> {\n+    fn drop(&mut self) {\n+        self.data.enqueue(DepMessage::PopIgnore);\n+    }\n+}"}, {"sha": "f2a5b1c9ef920c176d316f40406910f4d9fd6426", "filename": "src/librustc/dep_graph/thread.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Manages the communication between the compiler's main thread and\n+//! the thread that constructs the dependency graph. The basic idea is\n+//! to use double buffering to lower the cost of producing a message.\n+//! In the compiler thread, we accumulate messages in a vector until\n+//! the vector is full, or until we want to query the graph, and then\n+//! we send that vector over to the depgraph thread. At the same time,\n+//! we receive an empty vector from the depgraph thread that we can use\n+//! to accumulate more messages. This way we only ever have two vectors\n+//! allocated (and both have a fairly large capacity).\n+\n+use rustc_data_structures::veccell::VecCell;\n+use std::sync::mpsc::{self, Sender, Receiver};\n+use std::thread;\n+\n+use super::DepGraphQuery;\n+use super::DepNode;\n+use super::edges::DepGraphEdges;\n+\n+pub enum DepMessage {\n+    Read(DepNode),\n+    Write(DepNode),\n+    PushTask(DepNode),\n+    PopTask(DepNode),\n+    PushIgnore,\n+    PopIgnore,\n+    Query,\n+}\n+\n+pub struct DepGraphThreadData {\n+    enabled: bool,\n+\n+    // current buffer, where we accumulate messages\n+    messages: VecCell<DepMessage>,\n+\n+    // whence to receive new buffer when full\n+    swap_in: Receiver<Vec<DepMessage>>,\n+\n+    // where to send buffer when full\n+    swap_out: Sender<Vec<DepMessage>>,\n+\n+    // where to receiver query results\n+    query_in: Receiver<DepGraphQuery>,\n+}\n+\n+const INITIAL_CAPACITY: usize = 2048;\n+\n+impl DepGraphThreadData {\n+    pub fn new(enabled: bool) -> DepGraphThreadData {\n+        let (tx1, rx1) = mpsc::channel();\n+        let (tx2, rx2) = mpsc::channel();\n+        let (txq, rxq) = mpsc::channel();\n+        if enabled {\n+            thread::spawn(move || main(rx1, tx2, txq));\n+        }\n+        DepGraphThreadData {\n+            enabled: enabled,\n+            messages: VecCell::with_capacity(INITIAL_CAPACITY),\n+            swap_in: rx2,\n+            swap_out: tx1,\n+            query_in: rxq,\n+        }\n+    }\n+\n+    /// Sends the current batch of messages to the thread. Installs a\n+    /// new vector of messages.\n+    fn swap(&self) {\n+        assert!(self.enabled, \"should never swap if not enabled\");\n+\n+        // should be a buffer waiting for us (though of course we may\n+        // have to wait for depgraph thread to finish processing the\n+        // old messages)\n+        let new_messages = self.swap_in.recv().unwrap();\n+        assert!(new_messages.is_empty());\n+\n+        // swap in the empty buffer and extract the full one\n+        let old_messages = self.messages.swap(new_messages);\n+\n+        // send full buffer to depgraph thread to be processed\n+        self.swap_out.send(old_messages).unwrap();\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        assert!(self.enabled, \"cannot query if dep graph construction not enabled\");\n+        self.enqueue(DepMessage::Query);\n+        self.swap();\n+        self.query_in.recv().unwrap()\n+    }\n+\n+    /// Enqueue a message to be sent when things are next swapped. (If\n+    /// the buffer is full, this may swap.)\n+    #[inline]\n+    pub fn enqueue(&self, message: DepMessage) {\n+        if self.enabled {\n+            let len = self.messages.push(message);\n+            if len == INITIAL_CAPACITY {\n+                self.swap();\n+            }\n+        }\n+    }\n+}\n+\n+/// Definition of the depgraph thread.\n+pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n+            swap_out: Sender<Vec<DepMessage>>,\n+            query_out: Sender<DepGraphQuery>) {\n+    let mut edges = DepGraphEdges::new();\n+\n+    // the compiler thread always expects a fresh buffer to be\n+    // waiting, so queue one up\n+    swap_out.send(Vec::with_capacity(INITIAL_CAPACITY)).unwrap();\n+\n+    // process the buffers from compiler thread as we receive them\n+    for mut messages in swap_in {\n+        for msg in messages.drain(..) {\n+            match msg {\n+                DepMessage::Read(node) => edges.read(node),\n+                DepMessage::Write(node) => edges.write(node),\n+                DepMessage::PushTask(node) => edges.push_task(node),\n+                DepMessage::PopTask(node) => edges.pop_task(node),\n+                DepMessage::PushIgnore => edges.push_ignore(),\n+                DepMessage::PopIgnore => edges.pop_ignore(),\n+                DepMessage::Query => query_out.send(edges.query()).unwrap(),\n+            }\n+        }\n+        swap_out.send(messages).unwrap();\n+    }\n+}"}, {"sha": "f84d5fbaf81dd6090e2c1f4ad7b5a559b48a0ce7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -87,6 +87,8 @@ pub mod back {\n     pub use rustc_back::svh;\n }\n \n+pub mod dep_graph;\n+\n pub mod front {\n     pub mod check_attr;\n     pub mod map;"}, {"sha": "a06e8a72c44ee685b4588b622f4afa395e3d2f32", "filename": "src/librustc/middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -15,7 +15,7 @@ use syntax::ast;\n use self::SimplifiedType::*;\n \n /// See `simplify_type\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "1ea09490aed2f4d05d99f64d555e68db2e45de2f", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -77,16 +77,16 @@ impl<E: Debug> Debug for Edge<E> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct NodeIndex(pub usize);\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct EdgeIndex(pub usize);\n \n pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Direction { repr: usize }\n \n pub const OUTGOING: Direction = Direction { repr: 0 };\n@@ -410,4 +410,12 @@ impl<E> Edge<E> {\n     pub fn target(&self) -> NodeIndex {\n         self.target\n     }\n+\n+    pub fn source_or_target(&self, direction: Direction) -> NodeIndex {\n+        if direction == OUTGOING {\n+            self.target\n+        } else {\n+            self.source\n+        }\n+    }\n }"}, {"sha": "ef64d7dde091c0b99f28295e059d0b232a9071df", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -40,6 +40,7 @@ pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n pub mod tuple_slice;\n+pub mod veccell;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "1842d0a4958e33fd5d5ecf41381600246b7f1674", "filename": "src/librustc_data_structures/veccell/mod.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77cd480cf2105afcbb92de4f514f1f9637912c5/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs?ref=c77cd480cf2105afcbb92de4f514f1f9637912c5", "patch": "@@ -0,0 +1,37 @@\n+use std::cell::UnsafeCell;\n+use std::mem;\n+\n+pub struct VecCell<T> {\n+    data: UnsafeCell<Vec<T>>\n+}\n+\n+impl<T> VecCell<T> {\n+    pub fn with_capacity(capacity: usize) -> VecCell<T>{\n+        VecCell { data: UnsafeCell::new(Vec::with_capacity(capacity)) }\n+    }\n+\n+    #[inline]\n+    pub fn push(&self, data: T) -> usize {\n+        // The logic here, and in `swap` below, is that the `push`\n+        // method on the vector will not recursively access this\n+        // `VecCell`. Therefore, we can temporarily obtain mutable\n+        // access, secure in the knowledge that even if aliases exist\n+        // -- indeed, even if aliases are reachable from within the\n+        // vector -- they will not be used for the duration of this\n+        // particular fn call. (Note that we also are relying on the\n+        // fact that `VecCell` is not `Sync`.)\n+        unsafe {\n+            let v = self.data.get();\n+            (*v).push(data);\n+            (*v).len()\n+        }\n+    }\n+\n+    pub fn swap(&self, mut data: Vec<T>) -> Vec<T> {\n+        unsafe {\n+            let v = self.data.get();\n+            mem::swap(&mut *v, &mut data);\n+        }\n+        data\n+    }\n+}"}]}