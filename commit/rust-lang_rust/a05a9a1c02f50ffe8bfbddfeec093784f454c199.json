{"sha": "a05a9a1c02f50ffe8bfbddfeec093784f454c199", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNWE5YTFjMDJmNTBmZmU4YmZiZGRmZWVjMDkzNzg0ZjQ1NGMxOTk=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-03T17:40:20Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-06T02:05:07Z"}, "message": "std: Improve vec::ChunkIter\n\nImplement clone, bidirectionality and random access for this iterator", "tree": {"sha": "918020a806ff76d98d8c8eb89b337a76575b6eb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918020a806ff76d98d8c8eb89b337a76575b6eb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a05a9a1c02f50ffe8bfbddfeec093784f454c199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a05a9a1c02f50ffe8bfbddfeec093784f454c199", "html_url": "https://github.com/rust-lang/rust/commit/a05a9a1c02f50ffe8bfbddfeec093784f454c199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a05a9a1c02f50ffe8bfbddfeec093784f454c199/comments", "author": null, "committer": null, "parents": [{"sha": "872d15d46440aa12014873dac0f19e325e169860", "url": "https://api.github.com/repos/rust-lang/rust/commits/872d15d46440aa12014873dac0f19e325e169860", "html_url": "https://github.com/rust-lang/rust/commit/872d15d46440aa12014873dac0f19e325e169860"}], "stats": {"total": 59, "additions": 51, "deletions": 8}, "files": [{"sha": "fa1291c61e1bec0a883db368d52a17d95cf7eacd", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a05a9a1c02f50ffe8bfbddfeec093784f454c199/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05a9a1c02f50ffe8bfbddfeec093784f454c199/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a05a9a1c02f50ffe8bfbddfeec093784f454c199", "patch": "@@ -479,6 +479,7 @@ pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n \n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n+#[deriving(Clone)]\n pub struct WindowIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n@@ -498,23 +499,57 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n \n /// An iterator over a vector in (non-overlapping) chunks (`size`\n /// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainer.\n+#[deriving(Clone)]\n pub struct ChunkIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n }\n \n impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n-        if self.size == 0 {\n+        if self.v.len() == 0 {\n             None\n-        } else if self.size >= self.v.len() {\n-            // finished\n-            self.size = 0;\n-            Some(self.v)\n         } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(self.size, self.v.len());\n-            ret\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n+    fn next_back(&mut self) -> Option<&'self [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+impl<'self, T> RandomAccessIterator<&'self [T]> for ChunkIter<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<&'self [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            Some(self.v.slice(lo, cmp::min(lo, self.v.len() - self.size) + self.size))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -3378,6 +3413,14 @@ mod tests {\n         assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n         assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n         assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+\n+        assert_eq!(v.chunk_iter(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        let it = v.chunk_iter(2);\n+        assert_eq!(it.indexable(), 3);\n+        assert_eq!(it.idx(0).unwrap(), &[1,2]);\n+        assert_eq!(it.idx(1).unwrap(), &[3,4]);\n+        assert_eq!(it.idx(2).unwrap(), &[5]);\n+        assert_eq!(it.idx(3), None);\n     }\n \n     #[test]"}]}