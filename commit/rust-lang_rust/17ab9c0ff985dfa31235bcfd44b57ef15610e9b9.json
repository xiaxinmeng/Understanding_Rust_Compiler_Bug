{"sha": "17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWI5YzBmZjk4NWRmYTMxMjM1YmNmZDQ0YjU3ZWYxNTYxMGU5Yjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-14T17:43:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-14T17:59:43Z"}, "message": "extract Rust 2021 prelude logic to its own module", "tree": {"sha": "30bb5ca9cc9d474de15ad2fe39af02e09ebf2db7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30bb5ca9cc9d474de15ad2fe39af02e09ebf2db7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "html_url": "https://github.com/rust-lang/rust/commit/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d42f3da6358e80c0f13dc057152e04b7283def8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d42f3da6358e80c0f13dc057152e04b7283def8", "html_url": "https://github.com/rust-lang/rust/commit/8d42f3da6358e80c0f13dc057152e04b7283def8"}], "stats": {"total": 302, "additions": 178, "deletions": 124}, "files": [{"sha": "e956637dec1d631a96e1dfe5d3b052c0059ee0ec", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 11, "deletions": 124, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "patch": "@@ -3,16 +3,15 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/method-lookup.html\n \n mod confirm;\n+mod prelude2021;\n pub mod probe;\n mod suggest;\n \n pub use self::suggest::{SelfSource, TraitInfo};\n pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n-use crate::check::method::probe::PickKind;\n use crate::check::FnCtxt;\n-use rustc_ast::ast::Mutability;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -23,9 +22,7 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TypeFoldable, WithConstness};\n-use rustc_session::lint::builtin::FUTURE_PRELUDE_COLLISION;\n-use rustc_span::edition::Edition;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -202,71 +199,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick =\n             self.lookup_probe(span, segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n \n-        if span.edition() < Edition::Edition2021 {\n-            if let sym::try_into = segment.ident.name {\n-                if !matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n-                    self.tcx.struct_span_lint_hir(\n-                        FUTURE_PRELUDE_COLLISION,\n-                        call_expr.hir_id,\n-                        call_expr.span,\n-                        |lint| {\n-                            let sp = call_expr.span;\n-                            let trait_name = self.tcx.def_path_str(pick.item.container.id());\n-\n-                            let mut lint = lint.build(&format!(\n-                                \"trait method `{}` will become ambiguous in Rust 2021\",\n-                                segment.ident.name\n-                            ));\n-\n-                            if let Ok(self_expr) =\n-                                self.sess().source_map().span_to_snippet(self_expr.span)\n-                            {\n-                                let derefs = \"*\".repeat(pick.autoderefs);\n-\n-                                let autoref = match pick.autoref_or_ptr_adjustment {\n-                                    Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                                        mutbl: Mutability::Mut,\n-                                        ..\n-                                    }) => \"&mut \",\n-                                    Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                                        mutbl: Mutability::Not,\n-                                        ..\n-                                    }) => \"&\",\n-                                    Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n-                                };\n-                                let self_adjusted =\n-                                    if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n-                                        pick.autoref_or_ptr_adjustment\n-                                    {\n-                                        format!(\"{}{} as *const _\", derefs, self_expr)\n-                                    } else {\n-                                        format!(\"{}{}{}\", autoref, derefs, self_expr)\n-                                    };\n-                                lint.span_suggestion(\n-                                    sp,\n-                                    \"disambiguate the associated function\",\n-                                    format!(\n-                                        \"{}::{}({})\",\n-                                        trait_name, segment.ident.name, self_adjusted,\n-                                    ),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                lint.span_help(\n-                                    sp,\n-                                    &format!(\n-                                        \"disambiguate the associated function with `{}::{}(...)`\",\n-                                        trait_name, segment.ident,\n-                                    ),\n-                                );\n-                            }\n-\n-                            lint.emit();\n-                        },\n-                    );\n-                }\n-            }\n-        }\n+        self.lint_dot_call_from_2018(self_ty, segment, span, call_expr, self_expr, &pick);\n \n         for import_id in &pick.import_ids {\n             debug!(\"used_trait_import: {:?}\", import_id);\n@@ -551,60 +484,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ProbeScope::TraitsInScope,\n         )?;\n \n-        if span.edition() < Edition::Edition2021 {\n-            if let sym::try_into | sym::try_from | sym::from_iter = method_name.name {\n-                // No need to warn if either:\n-                //\n-                // * The method comes from std/core, since ten it's the built-in trait.\n-                // * This is an inherent method called on a specific type, like `Vec::foo(...)`,\n-                //   since such methods take precedence over trait methods.\n-                if !matches!(tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core)\n-                    && !matches!(pick.kind, PickKind::InherentImplPick)\n-                {\n-                    tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n-                        // \"type\" refers to either a type or, more likely, a trait from which\n-                        // the associated function or method is from.\n-                        let type_name = tcx.def_path_str(pick.item.container.id());\n-                        let type_generics = tcx.generics_of(pick.item.container.id());\n-\n-                        let parameter_count =\n-                            type_generics.count() - (type_generics.has_self as usize);\n-                        let trait_name = if parameter_count == 0 {\n-                            type_name\n-                        } else {\n-                            format!(\n-                                \"{}<{}>\",\n-                                type_name,\n-                                std::iter::repeat(\"_\")\n-                                    .take(parameter_count)\n-                                    .collect::<Vec<_>>()\n-                                    .join(\", \")\n-                            )\n-                        };\n-\n-                        let mut lint = lint.build(&format!(\n-                            \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n-                            method_name.name\n-                        ));\n-\n-                        let self_ty = self\n-                            .sess()\n-                            .source_map()\n-                            .span_to_snippet(self_ty_span)\n-                            .unwrap_or_else(|_| self_ty.to_string());\n-\n-                        lint.span_suggestion(\n-                            span,\n-                            \"disambiguate the associated function\",\n-                            format!(\"<{} as {}>::{}\", self_ty, trait_name, method_name.name,),\n-                            Applicability::MachineApplicable,\n-                        );\n-\n-                        lint.emit();\n-                    });\n-                }\n-            }\n-        }\n+        self.lint_fully_qualified_call_from_2018(\n+            span,\n+            method_name,\n+            self_ty,\n+            self_ty_span,\n+            expr_id,\n+            &pick,\n+        );\n \n         debug!(\"resolve_fully_qualified_call: pick={:?}\", pick);\n         {"}, {"sha": "b141a4f6f89dae3153ed287b40f81c650f663e35", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab9c0ff985dfa31235bcfd44b57ef15610e9b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=17ab9c0ff985dfa31235bcfd44b57ef15610e9b9", "patch": "@@ -0,0 +1,167 @@\n+use rustc_ast::Mutability;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_middle::ty::Ty;\n+use rustc_session::lint::builtin::FUTURE_PRELUDE_COLLISION;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+use crate::check::{\n+    method::probe::{self, Pick},\n+    FnCtxt,\n+};\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn lint_dot_call_from_2018(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        segment: &hir::PathSegment<'_>,\n+        span: Span,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        pick: &Pick<'tcx>,\n+    ) {\n+        debug!(\n+            \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n+            segment.ident, self_ty, call_expr, self_expr\n+        );\n+\n+        // Rust 2021 and later is already using the new prelude\n+        if span.rust_2021() {\n+            return;\n+        }\n+\n+        // These are the method names that were added to prelude in Rust 2021\n+        if !matches!(segment.ident.name, sym::try_into) {\n+            return;\n+        }\n+\n+        // No need to lint if method came from std/core, as that will now be in the prelude\n+        if matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+            return;\n+        }\n+\n+        self.tcx.struct_span_lint_hir(\n+            FUTURE_PRELUDE_COLLISION,\n+            call_expr.hir_id,\n+            call_expr.span,\n+            |lint| {\n+                let sp = call_expr.span;\n+                let trait_name = self.tcx.def_path_str(pick.item.container.id());\n+\n+                let mut lint = lint.build(&format!(\n+                    \"trait method `{}` will become ambiguous in Rust 2021\",\n+                    segment.ident.name\n+                ));\n+\n+                if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span) {\n+                    let derefs = \"*\".repeat(pick.autoderefs);\n+\n+                    let autoref = match pick.autoref_or_ptr_adjustment {\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Mut,\n+                            ..\n+                        }) => \"&mut \",\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Not,\n+                            ..\n+                        }) => \"&\",\n+                        Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n+                    };\n+                    let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                        pick.autoref_or_ptr_adjustment\n+                    {\n+                        format!(\"{}{} as *const _\", derefs, self_expr)\n+                    } else {\n+                        format!(\"{}{}{}\", autoref, derefs, self_expr)\n+                    };\n+                    lint.span_suggestion(\n+                        sp,\n+                        \"disambiguate the associated function\",\n+                        format!(\"{}::{}({})\", trait_name, segment.ident.name, self_adjusted,),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    lint.span_help(\n+                        sp,\n+                        &format!(\n+                            \"disambiguate the associated function with `{}::{}(...)`\",\n+                            trait_name, segment.ident,\n+                        ),\n+                    );\n+                }\n+\n+                lint.emit();\n+            },\n+        );\n+    }\n+\n+    pub(super) fn lint_fully_qualified_call_from_2018(\n+        &self,\n+        span: Span,\n+        method_name: Ident,\n+        self_ty: Ty<'tcx>,\n+        self_ty_span: Span,\n+        expr_id: hir::HirId,\n+        pick: &Pick<'tcx>,\n+    ) {\n+        // Rust 2021 and later is already using the new prelude\n+        if span.rust_2021() {\n+            return;\n+        }\n+\n+        // These are the fully qualified methods added to prelude in Rust 2021\n+        if !matches!(method_name.name, sym::try_into | sym::try_from | sym::from_iter) {\n+            return;\n+        }\n+\n+        // No need to lint if method came from std/core, as that will now be in the prelude\n+        if matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+            return;\n+        }\n+\n+        // No need to lint if this is an inherent method called on a specific type, like `Vec::foo(...)`,\n+        // since such methods take precedence over trait methods.\n+        if matches!(pick.kind, probe::PickKind::InherentImplPick) {\n+            return;\n+        }\n+\n+        self.tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n+            // \"type\" refers to either a type or, more likely, a trait from which\n+            // the associated function or method is from.\n+            let type_name = self.tcx.def_path_str(pick.item.container.id());\n+            let type_generics = self.tcx.generics_of(pick.item.container.id());\n+\n+            let parameter_count = type_generics.count() - (type_generics.has_self as usize);\n+            let trait_name = if parameter_count == 0 {\n+                type_name\n+            } else {\n+                format!(\n+                    \"{}<{}>\",\n+                    type_name,\n+                    std::iter::repeat(\"_\").take(parameter_count).collect::<Vec<_>>().join(\", \")\n+                )\n+            };\n+\n+            let mut lint = lint.build(&format!(\n+                \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n+                method_name.name\n+            ));\n+\n+            let self_ty = self\n+                .sess()\n+                .source_map()\n+                .span_to_snippet(self_ty_span)\n+                .unwrap_or_else(|_| self_ty.to_string());\n+\n+            lint.span_suggestion(\n+                span,\n+                \"disambiguate the associated function\",\n+                format!(\"<{} as {}>::{}\", self_ty, trait_name, method_name.name,),\n+                Applicability::MachineApplicable,\n+            );\n+\n+            lint.emit();\n+        });\n+    }\n+}"}]}