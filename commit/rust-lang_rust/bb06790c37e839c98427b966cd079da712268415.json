{"sha": "bb06790c37e839c98427b966cd079da712268415", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMDY3OTBjMzdlODM5Yzk4NDI3Yjk2NmNkMDc5ZGE3MTIyNjg0MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T09:26:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T09:26:24Z"}, "message": "auto merge of #14830 : luqmana/rust/cmtrttcbctto, r=nikomatsakis\n\nFixes #14399.", "tree": {"sha": "78e05c8c9d6e8f4e44b01bb6fe7987277839c296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78e05c8c9d6e8f4e44b01bb6fe7987277839c296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb06790c37e839c98427b966cd079da712268415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb06790c37e839c98427b966cd079da712268415", "html_url": "https://github.com/rust-lang/rust/commit/bb06790c37e839c98427b966cd079da712268415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb06790c37e839c98427b966cd079da712268415/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "html_url": "https://github.com/rust-lang/rust/commit/f8c9aec34486f953eec0e46cb9c13cdcd20dc476"}, {"sha": "4eb5d7baf928a922b30d71e64f7be258d1a82f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb5d7baf928a922b30d71e64f7be258d1a82f2f", "html_url": "https://github.com/rust-lang/rust/commit/4eb5d7baf928a922b30d71e64f7be258d1a82f2f"}], "stats": {"total": 225, "additions": 164, "deletions": 61}, "files": [{"sha": "8cb975182a033181745a0eb77ce9a2ab5cb83760", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -552,16 +552,17 @@ impl tr for freevar_entry {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee);\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+        -> (typeck::ExprAdjustment, MethodCallee);\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n                         ebml_w: &mut Encoder,\n-                        autoderef: u32,\n+                        adjustment: typeck::ExprAdjustment,\n                         method: &MethodCallee) {\n     ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n-        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n-            autoderef.encode(ebml_w)\n+        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n+            adjustment.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             method.origin.encode(ebml_w)\n@@ -576,12 +577,14 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee) {\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+        -> (typeck::ExprAdjustment, MethodCallee) {\n+\n         self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+            let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n                 Decodable::decode(this)\n             }).unwrap();\n-            Ok((autoderef, MethodCallee {\n+            Ok((adjustment, MethodCallee {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n                         Decodable::decode(this).unwrap();\n@@ -627,11 +630,11 @@ impl tr for MethodOrigin {\n \n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n                               ebml_w: &mut Encoder,\n-                              autoderef: u32,\n+                              adjustment: typeck::ExprAdjustment,\n                               dr: &typeck::vtable_res) {\n     ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n-        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n-            autoderef.encode(ebml_w)\n+        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n+            adjustment.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n             Ok(encode_vtable_res(ecx, ebml_w, dr))\n@@ -705,7 +708,7 @@ pub trait vtable_decoder_helpers {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (u32, typeck::vtable_res);\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res);\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_res;\n@@ -731,12 +734,12 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (u32, typeck::vtable_res) {\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+            let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n                 Decodable::decode(this)\n             }).unwrap();\n-            Ok((autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n+            Ok((adjustment, this.read_struct_field(\"vtable_res\", 1, |this| {\n                 Ok(this.read_vtable_res(tcx, cdata))\n             }).unwrap()))\n         }).unwrap()\n@@ -1050,7 +1053,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n+                encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n             })\n         })\n     }\n@@ -1059,7 +1062,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, dr);\n+                encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n             })\n         })\n     }\n@@ -1068,12 +1071,13 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         match *adj {\n             ty::AutoDerefRef(adj) => {\n                 for autoderef in range(0, adj.autoderefs) {\n-                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                    let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n                         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                             ebml_w.id(id);\n                             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n+                                encode_method_callee(ecx, ebml_w,\n+                                                     method_call.adjustment, method)\n                             })\n                         })\n                     }\n@@ -1083,12 +1087,32 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                             ebml_w.id(id);\n                             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                                 encode_vtable_res_with_key(ecx, ebml_w,\n-                                                           method_call.autoderef, dr);\n+                                                           method_call.adjustment, dr);\n                             })\n                         })\n                     }\n                 }\n             }\n+            ty::AutoObject(..) => {\n+                let method_call = MethodCall::autoobject(id);\n+                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                    ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n+                        ebml_w.id(id);\n+                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                            encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n+                        })\n+                    })\n+                }\n+\n+                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n+                    ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n+                        ebml_w.id(id);\n+                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                            encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n+                        })\n+                    })\n+                }\n+            }\n             _ => {}\n         }\n \n@@ -1393,20 +1417,20 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let (autoderef, method) = val_dsr.read_method_callee(xcx);\n+                        let (adjustment, method) = val_dsr.read_method_callee(xcx);\n                         let method_call = MethodCall {\n                             expr_id: id,\n-                            autoderef: autoderef\n+                            adjustment: adjustment\n                         };\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n-                        let (autoderef, vtable_res) =\n+                        let (adjustment, vtable_res) =\n                             val_dsr.read_vtable_res_with_key(xcx.dcx.tcx,\n                                                              xcx.dcx.cdata);\n                         let vtable_key = MethodCall {\n                             expr_id: id,\n-                            autoderef: autoderef\n+                            adjustment: adjustment\n                         };\n                         dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }"}, {"sha": "3e72341ebb02fa37db26279e186f9eff122d6400", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -594,7 +594,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n \n         for i in range(0, autoderefs) {\n-            let deref_id = typeck::MethodCall::autoderef(expr.id, i as u32);\n+            let deref_id = typeck::MethodCall::autoderef(expr.id, i);\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {"}, {"sha": "fbe4936a47aa670ab1ab020f2f34e77fa2147ef2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -700,9 +700,14 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                              base_cmt: cmt,\n                              deref_cnt: uint)\n                              -> cmt {\n+        let adjustment = match self.typer.adjustments().borrow().find(&node.id()) {\n+            Some(&ty::AutoObject(..)) => typeck::AutoObject,\n+            _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n+            _ => typeck::NoAdjustment\n+        };\n         let method_call = typeck::MethodCall {\n             expr_id: node.id(),\n-            autoderef: deref_cnt as u32\n+            adjustment: adjustment\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n "}, {"sha": "9c957eec90acdef6fb9f8aeb814a21307aab627c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -65,8 +65,8 @@ use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n use middle::ty;\n-use middle::typeck::MethodCall;\n use middle::typeck;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -1178,7 +1178,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n         }\n         ast::UnDeref => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            deref_once(bcx, expr, datum, 0)\n+            deref_once(bcx, expr, datum, method_call)\n         }\n     }\n }\n@@ -1487,7 +1487,7 @@ fn trans_overloaded_call<'a>(\n                       SaveIn(addr))\n         }));\n \n-    let method_call = typeck::MethodCall::expr(expr.id);\n+    let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n                          .borrow()\n@@ -1737,31 +1737,28 @@ fn deref_multiple<'a>(bcx: &'a Block<'a>,\n                       -> DatumBlock<'a, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;\n-    for i in range(1, times+1) {\n-        datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, i));\n+    for i in range(0, times) {\n+        let method_call = MethodCall::autoderef(expr.id, i);\n+        datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, method_call));\n     }\n     DatumBlock { bcx: bcx, datum: datum }\n }\n \n fn deref_once<'a>(bcx: &'a Block<'a>,\n                   expr: &ast::Expr,\n                   datum: Datum<Expr>,\n-                  derefs: uint)\n+                  method_call: MethodCall)\n                   -> DatumBlock<'a, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={}, datum={}, derefs={})\",\n+    debug!(\"deref_once(expr={}, datum={}, method_call={})\",\n            expr.repr(bcx.tcx()),\n            datum.to_str(ccx),\n-           derefs);\n+           method_call);\n \n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_call = MethodCall {\n-        expr_id: expr.id,\n-        autoderef: derefs as u32\n-    };\n     let method_ty = ccx.tcx.method_map.borrow()\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n@@ -1771,11 +1768,10 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             // converts from the `Shaht<T>` pointer that we have into\n             // a `&T` pointer.  We can then proceed down the normal\n             // path (below) to dereference that `&T`.\n-            let datum = if derefs == 0 {\n-                datum\n-            } else {\n-                // Always perform an AutoPtr when applying an overloaded auto-deref.\n-                unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n+            let datum = match method_call.adjustment {\n+                // Always perform an AutoPtr when applying an overloaded auto-deref\n+                typeck::AutoDeref(_) => unpack_datum!(bcx, auto_ref(bcx, datum, expr)),\n+                _ => datum\n             };\n             let val = unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n                                                               datum, None, None));\n@@ -1834,8 +1830,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    debug!(\"deref_once(expr={}, derefs={}, result={})\",\n-           expr.id, derefs, r.datum.to_str(ccx));\n+    debug!(\"deref_once(expr={}, method_call={}, result={})\",\n+           expr.id, method_call, r.datum.to_str(ccx));\n \n     return r;\n "}, {"sha": "85660cd2eb540c880d13f0ebedf74f7ca67d679a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -538,9 +538,13 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n     // Store the vtable into the second half of pair.\n     let origins = {\n         let vtable_map = ccx.tcx.vtable_map.borrow();\n-        resolve_param_vtables_under_param_substs(ccx.tcx(),\n-            bcx.fcx.param_substs,\n-            vtable_map.get(&MethodCall::expr(id)).get_self().unwrap())\n+        // This trait cast might be because of implicit coercion\n+        let method_call = match ccx.tcx.adjustments.borrow().find(&id) {\n+            Some(&ty::AutoObject(..)) => MethodCall::autoobject(id),\n+            _ => MethodCall::expr(id)\n+        };\n+        let vres = vtable_map.get(&method_call).get_self().unwrap();\n+        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);"}, {"sha": "c4e48bea85e0a49a6fad948a8b7b8b77aba6b2f0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -2823,7 +2823,7 @@ pub fn adjust_ty(cx: &ctxt,\n \n                     if !ty::type_is_error(adjusted_ty) {\n                         for i in range(0, adj.autoderefs) {\n-                            let method_call = typeck::MethodCall::autoderef(expr_id, i as u32);\n+                            let method_call = typeck::MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n                                     adjusted_ty = ty_fn_ret(method_ty);"}, {"sha": "7b16248c2e6a2f2518e59896a37b6c73dd0ccae9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -1331,8 +1331,7 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n         let mt = match ty::deref(resolved_t, false) {\n             Some(mt) => Some(mt),\n             None => {\n-                let method_call =\n-                    expr_id.map(|id| MethodCall::autoderef(id, autoderefs as u32));\n+                let method_call = expr_id.map(|id| MethodCall::autoderef(id, autoderefs));\n                 try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n         };"}, {"sha": "4cd319af0d9d8a5c6185d963da94d67d4587a71a", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -879,7 +879,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n-        let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n+        let method_call = MethodCall::autoderef(deref_expr.id, i);\n         derefd_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n             Some(method) => {\n                 // Treat overloaded autoderefs as if an AutoRef adjustment"}, {"sha": "6ac6cdce8590d32ad33927870a2c21c508c5f7f3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -529,7 +529,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n-    let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t| {\n+    let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t, key: MethodCall| {\n       // Look up vtables for the type we're casting to,\n       // passing in the source and target type.  The source\n       // must be a pointer type suitable to the object sigil,\n@@ -596,7 +596,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       if !is_early {\n                           let mut r = VecPerParamSpace::empty();\n                           r.push(subst::SelfSpace, vtables);\n-                          insert_vtables(fcx, MethodCall::expr(ex.id), r);\n+                          insert_vtables(fcx, key, r);\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -694,7 +694,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprCast(ref src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          resolve_object_cast(&**src, target_ty);\n+          let key = MethodCall::expr(ex.id);\n+          resolve_object_cast(&**src, target_ty, key);\n       }\n       _ => ()\n     }\n@@ -705,7 +706,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             match *adjustment {\n                 AutoDerefRef(adj) => {\n                     for autoderef in range(0, adj.autoderefs) {\n-                        let method_call = MethodCall::autoderef(ex.id, autoderef as u32);\n+                        let method_call = MethodCall::autoderef(ex.id, autoderef);\n                         match fcx.inh.method_map.borrow().find(&method_call) {\n                             Some(method) => {\n                                 debug!(\"vtable resolution on parameter bounds for autoderef {}\",\n@@ -745,7 +746,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         }\n                     };\n \n-                    resolve_object_cast(ex, object_ty);\n+                    let key = MethodCall::autoobject(ex.id);\n+                    resolve_object_cast(ex, object_ty, key);\n                 }\n                 AutoAddEnv(..) => {}\n             }"}, {"sha": "8e3e8e6091b2ea75fc45538bb9913a59e6baf200", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -248,7 +248,7 @@ impl<'cx> WritebackCx<'cx> {\n \n                     ty::AutoDerefRef(adj) => {\n                         for autoderef in range(0, adj.autoderefs) {\n-                            let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                            let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n                             self.visit_vtable_map_entry(reason, method_call);\n                         }\n@@ -260,6 +260,10 @@ impl<'cx> WritebackCx<'cx> {\n                     }\n \n                     ty::AutoObject(trait_store, bb, def_id, substs) => {\n+                        let method_call = MethodCall::autoobject(id);\n+                        self.visit_method_map_entry(reason, method_call);\n+                        self.visit_vtable_map_entry(reason, method_call);\n+\n                         ty::AutoObject(\n                             self.resolve(&trait_store, reason),\n                             self.resolve(&bb, reason),"}, {"sha": "bc2768ce214eb9f35380e96f14b6123da76a4050", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -149,24 +149,52 @@ pub struct MethodCallee {\n     pub substs: subst::Substs\n }\n \n+/**\n+ * With method calls, we store some extra information in\n+ * side tables (i.e method_map, vtable_map). We use\n+ * MethodCall as a key to index into these tables instead of\n+ * just directly using the expression's NodeId. The reason\n+ * for this being that we may apply adjustments (coercions)\n+ * with the resulting expression also needing to use the\n+ * side tables. The problem with this is that we don't\n+ * assign a separate NodeId to this new expression\n+ * and so it would clash with the base expression if both\n+ * needed to add to the side tables. Thus to disambiguate\n+ * we also keep track of whether there's an adjustment in\n+ * our key.\n+ */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n-    pub autoderef: u32\n+    pub adjustment: ExprAdjustment\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n+pub enum ExprAdjustment {\n+    NoAdjustment,\n+    AutoDeref(uint),\n+    AutoObject\n }\n \n impl MethodCall {\n     pub fn expr(id: ast::NodeId) -> MethodCall {\n         MethodCall {\n             expr_id: id,\n-            autoderef: 0\n+            adjustment: NoAdjustment\n+        }\n+    }\n+\n+    pub fn autoobject(id: ast::NodeId) -> MethodCall {\n+        MethodCall {\n+            expr_id: id,\n+            adjustment: AutoObject\n         }\n     }\n \n-    pub fn autoderef(expr_id: ast::NodeId, autoderef: u32) -> MethodCall {\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: uint) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n-            autoderef: 1 + autoderef\n+            adjustment: AutoDeref(1 + autoderef)\n         }\n     }\n }"}, {"sha": "fbb8a3a1720f903ecc79b68c19fc9644e8ab9192", "filename": "src/test/run-pass/deref-rc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Ftest%2Frun-pass%2Fderef-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Ftest%2Frun-pass%2Fderef-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-rc.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+fn main() {\n+    let x = Rc::new([1, 2, 3, 4]);\n+    assert!(*x == [1, 2, 3, 4]);\n+}"}, {"sha": "4c84d0fcaf089d29f0da26fc3324f0fedbf2a29e", "filename": "src/test/run-pass/issue-14399.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb06790c37e839c98427b966cd079da712268415/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb06790c37e839c98427b966cd079da712268415/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14399.rs?ref=bb06790c37e839c98427b966cd079da712268415", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #14399\n+// We'd previously ICE if we had a method call whose return\n+// value was coerced to a trait object. (v.clone() returns Box<B1>\n+// which is coerced to Box<A>).\n+\n+#[deriving(Clone)]\n+struct B1;\n+\n+trait A {}\n+impl A for B1 {}\n+\n+fn main() {\n+    let v = box B1;\n+    let _c: Box<A> = v.clone();\n+}"}]}