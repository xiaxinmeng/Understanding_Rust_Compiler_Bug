{"sha": "2db05230d35c068c557fe476cf16197836580c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYjA1MjMwZDM1YzA2OGM1NTdmZTQ3NmNmMTYxOTc4MzY1ODBjMmQ=", "commit": {"author": {"name": "bstrie", "email": "865233+bstrie@users.noreply.github.com", "date": "2021-04-11T22:38:44Z"}, "committer": {"name": "bstrie", "email": "865233+bstrie@users.noreply.github.com", "date": "2021-06-30T21:28:17Z"}, "message": "impl From<[(K, V); N]> for std::collections", "tree": {"sha": "b607e9b105ebad19c901722e8a59a8130068015a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b607e9b105ebad19c901722e8a59a8130068015a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2db05230d35c068c557fe476cf16197836580c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2db05230d35c068c557fe476cf16197836580c2d", "html_url": "https://github.com/rust-lang/rust/commit/2db05230d35c068c557fe476cf16197836580c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2db05230d35c068c557fe476cf16197836580c2d/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7953910464e073eb3876d1544a3fd5b5ba0ca49b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7953910464e073eb3876d1544a3fd5b5ba0ca49b", "html_url": "https://github.com/rust-lang/rust/commit/7953910464e073eb3876d1544a3fd5b5ba0ca49b"}], "stats": {"total": 270, "additions": 244, "deletions": 26}, "files": [{"sha": "2f999a10a961095433c8f3dc17dc910b546f746c", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -209,6 +209,14 @@ use super::SpecExtend;\n /// assert!(heap.is_empty())\n /// ```\n ///\n+/// A `BinaryHeap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BinaryHeap;\n+///\n+/// let heap = BinaryHeap::from([1, 5, 2]);\n+/// ```\n+///\n /// ## Min-heap\n ///\n /// Either `std::cmp::Reverse` or a custom `Ord` implementation can be used to\n@@ -1443,6 +1451,22 @@ impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+impl<T: Ord, const N: usize> From<[T; N]> for BinaryHeap<T> {\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut h1 = BinaryHeap::from([1, 4, 2, 3]);\n+    /// let mut h2: BinaryHeap<_> = [1, 4, 2, 3].into();\n+    /// while let Some((a, b)) = h1.pop().zip(h2.pop()) {\n+    ///     assert_eq!(a, b);\n+    /// }\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T> From<BinaryHeap<T>> for Vec<T> {\n     /// Converts a `BinaryHeap<T>` into a `Vec<T>`."}, {"sha": "708389579dbcfb2731f9cf9285cf555404f87e99", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -109,7 +109,20 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// }\n /// ```\n ///\n-/// `BTreeMap` also implements an [`Entry API`], which allows for more complex\n+/// A `BTreeMap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+///\n+/// let solar_distance = BTreeMap::from([\n+///     (\"Mercury\", 0.4),\n+///     (\"Venus\", 0.7),\n+///     (\"Earth\", 1.0),\n+///     (\"Mars\", 1.5),\n+/// ]);\n+/// ```\n+///\n+/// `BTreeMap` implements an [`Entry API`], which allows for complex\n /// methods of getting, setting, updating and removing keys and their values:\n ///\n /// [`Entry API`]: BTreeMap::entry\n@@ -2030,6 +2043,20 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+impl<K: Ord, V, const N: usize> From<[(K, V); N]> for BTreeMap<K, V> {\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let map1 = BTreeMap::from([(1, 2), (3, 4)]);\n+    /// let map2: BTreeMap<_, _> = [(1, 2), (3, 4)].into();\n+    /// assert_eq!(map1, map2);\n+    /// ```\n+    fn from(arr: [(K, V); N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///"}, {"sha": "1e61692b7c63cb65be66a7d3ea5c8d019e1fbee7", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -2173,3 +2173,10 @@ fn test_insert_remove_intertwined_ord_chaos() {\n     }\n     map.check_invariants();\n }\n+\n+#[test]\n+fn from_array() {\n+    let map = BTreeMap::from([(1, 2), (3, 4)]);\n+    let unordered_duplicates = BTreeMap::from([(3, 4), (1, 2), (1, 2)]);\n+    assert_eq!(map, unordered_duplicates);\n+}"}, {"sha": "56c2cb56b5ba597d9c8e0dbb0d2cb8ba31ed5d8a", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -59,6 +59,14 @@ use super::Recover;\n ///     println!(\"{}\", book);\n /// }\n /// ```\n+///\n+/// A `BTreeSet` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BTreeSet;\n+///\n+/// let set = BTreeSet::from([1, 2, 3]);\n+/// ```\n #[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n@@ -1057,6 +1065,20 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+impl<T: Ord, const N: usize> From<[T; N]> for BTreeSet<T> {\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set1 = BTreeSet::from([1, 2, 3, 4]);\n+    /// let set2: BTreeSet<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(set1, set2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for BTreeSet<T> {\n     type Item = T;"}, {"sha": "de7a10dca7b8c5ccfe1c80d3924c26a5d4a1703a", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -738,3 +738,10 @@ fn test_split_off_large_random_sorted() {\n     assert!(set.into_iter().eq(data.clone().into_iter().filter(|x| *x < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| *x >= key)));\n }\n+\n+#[test]\n+fn from_array() {\n+    let set = BTreeSet::from([1, 2, 3, 4]);\n+    let unordered_duplicates = BTreeSet::from([4, 1, 4, 3, 2]);\n+    assert_eq!(set, unordered_duplicates);\n+}"}, {"sha": "8b978a4e806e7a1bd1ddff1cdb7d7610c405eb75", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -31,6 +31,13 @@ mod tests;\n /// The `LinkedList` allows pushing and popping elements at either end\n /// in constant time.\n ///\n+/// A `LinkedList` with a known list of items can be initialized from an array:\n+/// ```\n+/// use std::collections::LinkedList;\n+///\n+/// let list = LinkedList::from([1, 2, 3]);\n+/// ```\n+///\n /// NOTE: It is almost always better to use `Vec` or `VecDeque` because\n /// array-based containers are generally faster,\n /// more memory efficient, and make better use of CPU cache.\n@@ -1767,6 +1774,20 @@ impl<T: Hash> Hash for LinkedList<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+impl<T, const N: usize> From<[T; N]> for LinkedList<T> {\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let list1 = LinkedList::from([1, 2, 3, 4]);\n+    /// let list2: LinkedList<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(list1, list2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}, {"sha": "98514b43e7f52be1e50050424a2d177517908cb1", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -67,6 +67,14 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible\n /// push onto the back in this manner, and iterating over `VecDeque` goes front\n /// to back.\n ///\n+/// A `VecDeque` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::VecDeque;\n+///\n+/// let deq = VecDeque::from([-1, 0, 1]);\n+/// ```\n+///\n /// Since `VecDeque` is a ring buffer, its elements are not necessarily contiguous\n /// in memory. If you want to access the elements as a single slice, such as for\n /// efficient sorting, you can use [`make_contiguous`]. It rotates the `VecDeque`\n@@ -2855,3 +2863,17 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n+\n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+impl<T, const N: usize> From<[T; N]> for VecDeque<T> {\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deq1 = VecDeque::from([1, 2, 3, 4]);\n+    /// let deq2: VecDeque<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(deq1, deq2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}"}, {"sha": "617c76a680b9fa5fd3386511ddcc3fa61e0c450b", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -152,12 +152,13 @@ mod spec_extend;\n /// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n-/// The [`vec!`] macro is provided to make initialization more convenient:\n+/// The [`vec!`] macro is provided for convenient initialization:\n ///\n /// ```\n-/// let mut vec = vec![1, 2, 3];\n-/// vec.push(4);\n-/// assert_eq!(vec, [1, 2, 3, 4]);\n+/// let mut vec1 = vec![1, 2, 3];\n+/// vec1.push(4);\n+/// let vec2 = Vec::from([1, 2, 3, 4]);\n+/// assert_eq!(vec1, vec2);\n /// ```\n ///\n /// It can also initialize each element of a `Vec<T>` with a given value."}, {"sha": "fdc64850f714f1141c14b30ac89713202fda85f7", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -124,8 +124,21 @@ use crate::sys;\n /// }\n /// ```\n ///\n-/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n-/// for more complex methods of getting, setting, updating and removing keys and\n+/// A `HashMap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// let solar_distance = HashMap::from([\n+///     (\"Mercury\", 0.4),\n+///     (\"Venus\", 0.7),\n+///     (\"Earth\", 1.0),\n+///     (\"Mars\", 1.5),\n+/// ]);\n+/// ```\n+///\n+/// `HashMap` implements an [`Entry API`](#method.entry), which allows\n+/// for complex methods of getting, setting, updating and removing keys and\n /// their values:\n ///\n /// ```\n@@ -179,27 +192,17 @@ use crate::sys;\n /// }\n ///\n /// // Use a HashMap to store the vikings' health points.\n-/// let mut vikings = HashMap::new();\n-///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n+/// let vikings = HashMap::from([\n+///     (Viking::new(\"Einar\", \"Norway\"), 25),\n+///     (Viking::new(\"Olaf\", \"Denmark\"), 24),\n+///     (Viking::new(\"Harald\", \"Iceland\"), 12),\n+/// ]);\n ///\n /// // Use derived implementation to print the status of the vikings.\n /// for (viking, health) in &vikings {\n ///     println!(\"{:?} has {} hp\", viking, health);\n /// }\n /// ```\n-///\n-/// A `HashMap` with fixed list of elements can be initialized from an array:\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n-///     .iter().cloned().collect();\n-/// // use the values stored in map\n-/// ```\n \n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashmap_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1151,6 +1154,37 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+// Note: as what is currently the most convenient built-in way to construct\n+// a HashMap, a simple usage of this function must not *require* the user\n+// to provide a type annotation in order to infer the third type parameter\n+// (the hasher parameter, conventionally \"S\").\n+// To that end, this impl is defined using RandomState as the concrete\n+// type of S, rather than being generic over `S: BuildHasher + Default`.\n+// It is expected that users who want to specify a hasher will manually use\n+// `with_capacity_and_hasher`.\n+// If type parameter defaults worked on impls, and if type parameter\n+// defaults could be mixed with const generics, then perhaps\n+// this could be generalized.\n+// See also the equivalent impl on HashSet.\n+impl<K, V, const N: usize> From<[(K, V); N]> for HashMap<K, V, RandomState>\n+where\n+    K: Eq + Hash,\n+{\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let map1 = HashMap::from([(1, 2), (3, 4)]);\n+    /// let map2: HashMap<_, _> = [(1, 2), (3, 4)].into();\n+    /// assert_eq!(map1, map2);\n+    /// ```\n+    fn from(arr: [(K, V); N]) -> Self {\n+        crate::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n /// An iterator over the entries of a `HashMap`.\n ///\n /// This `struct` is created by the [`iter`] method on [`HashMap`]. See its"}, {"sha": "def085e380b19953dfbb86d830f3a9591e438167", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -1085,3 +1085,15 @@ mod test_drain_filter {\n         assert_eq!(map.len(), 2);\n     }\n }\n+\n+#[test]\n+fn from_array() {\n+    let map = HashMap::from([(1, 2), (3, 4)]);\n+    let unordered_duplicates = HashMap::from([(3, 4), (1, 2), (1, 2)]);\n+    assert_eq!(map, unordered_duplicates);\n+\n+    // This next line must infer the hasher type parameter.\n+    // If you make a change that causes this line to no longer infer,\n+    // that's a problem!\n+    let _must_not_require_type_annotation = HashMap::from([(1, 2)]);\n+}"}, {"sha": "6e58ebdce507d07f97fb3f8d2e417dd2a83bb6eb", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -95,14 +95,12 @@ use super::map::{map_try_reserve_error, RandomState};\n /// }\n /// ```\n ///\n-/// A `HashSet` with fixed list of elements can be initialized from an array:\n+/// A `HashSet` with a known list of items can be initialized from an array:\n ///\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let viking_names: HashSet<&'static str> =\n-///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n-/// // use the values stored in the set\n+/// let viking_names = HashSet::from([\"Einar\", \"Olaf\", \"Harald\"]);\n /// ```\n ///\n /// [hash set]: crate::collections#use-the-set-variant-of-any-of-these-maps-when\n@@ -998,6 +996,37 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.55.0\")]\n+// Note: as what is currently the most convenient built-in way to construct\n+// a HashSet, a simple usage of this function must not *require* the user\n+// to provide a type annotation in order to infer the third type parameter\n+// (the hasher parameter, conventionally \"S\").\n+// To that end, this impl is defined using RandomState as the concrete\n+// type of S, rather than being generic over `S: BuildHasher + Default`.\n+// It is expected that users who want to specify a hasher will manually use\n+// `with_capacity_and_hasher`.\n+// If type parameter defaults worked on impls, and if type parameter\n+// defaults could be mixed with const generics, then perhaps\n+// this could be generalized.\n+// See also the equivalent impl on HashMap.\n+impl<T, const N: usize> From<[T; N]> for HashSet<T, RandomState>\n+where\n+    T: Eq + Hash,\n+{\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let set1 = HashSet::from([1, 2, 3, 4]);\n+    /// let set2: HashSet<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(set1, set2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        crate::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Extend<T> for HashSet<T, S>\n where"}, {"sha": "6a625e6243c2157f4416502f28b3240b56480e3b", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db05230d35c068c557fe476cf16197836580c2d/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=2db05230d35c068c557fe476cf16197836580c2d", "patch": "@@ -484,3 +484,15 @@ fn test_drain_filter_pred_panic_leak() {\n     assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n     assert_eq!(set.len(), 0);\n }\n+\n+#[test]\n+fn from_array() {\n+    let set = HashSet::from([1, 2, 3, 4]);\n+    let unordered_duplicates = HashSet::from([4, 1, 4, 3, 2]);\n+    assert_eq!(set, unordered_duplicates);\n+\n+    // This next line must infer the hasher type parameter.\n+    // If you make a change that causes this line to no longer infer,\n+    // that's a problem!\n+    let _must_not_require_type_annotation = HashSet::from([1, 2]);\n+}"}]}