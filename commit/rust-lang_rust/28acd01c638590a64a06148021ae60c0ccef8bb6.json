{"sha": "28acd01c638590a64a06148021ae60c0ccef8bb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YWNkMDFjNjM4NTkwYTY0YTA2MTQ4MDIxYWU2MGMwY2NlZjhiYjY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-05T10:53:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-05T11:26:43Z"}, "message": "Merge match arms works with many arms", "tree": {"sha": "14fcfce46985eb77539fd9d5445559911818f7e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14fcfce46985eb77539fd9d5445559911818f7e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28acd01c638590a64a06148021ae60c0ccef8bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28acd01c638590a64a06148021ae60c0ccef8bb6", "html_url": "https://github.com/rust-lang/rust/commit/28acd01c638590a64a06148021ae60c0ccef8bb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28acd01c638590a64a06148021ae60c0ccef8bb6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45dd90b0e8d54fe0467f9e0f886c7c05d2400eb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/45dd90b0e8d54fe0467f9e0f886c7c05d2400eb0", "html_url": "https://github.com/rust-lang/rust/commit/45dd90b0e8d54fe0467f9e0f886c7c05d2400eb0"}], "stats": {"total": 99, "additions": 70, "deletions": 29}, "files": [{"sha": "8af30866c661bb7b52ece38f7e48f2cf0925d487", "filename": "crates/ra_assists/src/assists/merge_match_arms.rs", "status": "modified", "additions": 70, "deletions": 29, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/28acd01c638590a64a06148021ae60c0ccef8bb6/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28acd01c638590a64a06148021ae60c0ccef8bb6/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs?ref=28acd01c638590a64a06148021ae60c0ccef8bb6", "patch": "@@ -1,7 +1,12 @@\n+use std::iter::successors;\n+\n use hir::db::HirDatabase;\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Direction, TextUnit,\n+};\n \n-use crate::{Assist, AssistCtx, AssistId, TextRange, TextUnit};\n+use crate::{Assist, AssistCtx, AssistId, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -29,51 +34,52 @@ use crate::{Assist, AssistCtx, AssistId, TextRange, TextUnit};\n // ```\n pub(crate) fn merge_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n-\n-    // We check if the following match arm matches this one. We could, but don't,\n-    // compare to the previous match arm as well.\n-    let next = current_arm.syntax().next_sibling();\n-    let next_arm = ast::MatchArm::cast(next?)?;\n-\n     // Don't try to handle arms with guards for now - can add support for this later\n-    if current_arm.guard().is_some() || next_arm.guard().is_some() {\n+    if current_arm.guard().is_some() {\n         return None;\n     }\n-\n     let current_expr = current_arm.expr()?;\n-    let next_expr = next_arm.expr()?;\n+    let current_text_range = current_arm.syntax().text_range();\n+    let cursor_offset_back = current_text_range.end() - ctx.frange.range.start();\n \n-    // Check for match arm equality by comparing lengths and then string contents\n-    if current_expr.syntax().text_range().len() != next_expr.syntax().text_range().len() {\n-        return None;\n-    }\n-    if current_expr.syntax().text() != next_expr.syntax().text() {\n+    // We check if the following match arms match this one. We could, but don't,\n+    // compare to the previous match arm as well.\n+    let arms_to_merge = successors(Some(current_arm), next_arm)\n+        .take_while(|arm| {\n+            if arm.guard().is_some() {\n+                return false;\n+            }\n+            match arm.expr() {\n+                Some(expr) => expr.syntax().text() == current_expr.syntax().text(),\n+                None => false,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if arms_to_merge.len() <= 1 {\n         return None;\n     }\n \n-    let cursor_to_end = current_arm.syntax().text_range().end() - ctx.frange.range.start();\n-\n     ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", |edit| {\n-        let pats = if contains_placeholder(&current_arm) || contains_placeholder(&next_arm) {\n+        let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {\n-            let ps: Vec<String> = current_arm\n-                .pats()\n+            arms_to_merge\n+                .iter()\n+                .flat_map(ast::MatchArm::pats)\n                 .map(|x| x.syntax().to_string())\n-                .chain(next_arm.pats().map(|x| x.syntax().to_string()))\n-                .collect();\n-            ps.join(\" | \")\n+                .collect::<Vec<String>>()\n+                .join(\" | \")\n         };\n \n         let arm = format!(\"{} => {}\", pats, current_expr.syntax().text());\n-        let offset = TextUnit::from_usize(arm.len()) - cursor_to_end;\n \n-        let start = current_arm.syntax().text_range().start();\n-        let end = next_arm.syntax().text_range().end();\n+        let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n+        let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n \n-        edit.target(current_arm.syntax().text_range());\n+        edit.target(current_text_range);\n+        edit.set_cursor(start + TextUnit::from_usize(arm.len()) - cursor_offset_back);\n         edit.replace(TextRange::from_to(start, end), arm);\n-        edit.set_cursor(start + offset);\n     })\n }\n \n@@ -84,6 +90,10 @@ fn contains_placeholder(a: &ast::MatchArm) -> bool {\n     })\n }\n \n+fn next_arm(arm: &ast::MatchArm) -> Option<ast::MatchArm> {\n+    arm.syntax().siblings(Direction::Next).skip(1).find_map(ast::MatchArm::cast)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::merge_match_arms;\n@@ -185,6 +195,37 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn merges_all_subsequent_arms() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A =><|> 92,\n+                    X::B => 92,\n+                    X::C => 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A | X::B | X::C =><|> 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn merge_match_arms_rejects_guards() {\n         check_assist_not_applicable("}]}