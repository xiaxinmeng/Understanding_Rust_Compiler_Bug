{"sha": "f320c38aec185de2a02e0febff133da1f6a3462b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMjBjMzhhZWMxODVkZTJhMDJlMGZlYmZmMTMzZGExZjZhMzQ2MmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-11T10:07:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T10:07:52Z"}, "message": "Merge #4819\n\n4819: Add an FST index to `ImportMap` and use it to speed up auto import r=matklad a=jonas-schievink\n\nFor the importing crate, we still use the symbol index, but I've modified it to only look at files that comprise that crate (instead of the whole workspace).\r\n\r\nOh, and since now the symbol query limit is respected correctly, it's possible that some results from the local crate now disappear if there are many matches.\r\n\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/4763\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "f22c1d5af6dcd994667d656833c3a27c568961ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f22c1d5af6dcd994667d656833c3a27c568961ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f320c38aec185de2a02e0febff133da1f6a3462b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4gJ4CRBK7hj4Ov3rIwAAdHIIAI2675n/4htBUHD0GoZMD8Ge\nV3XOeWhAQpP2MycRqqSBoQrj5jaJnQVK1GdGhVT1wiwNVtbktMlCJmrj+7Z+wxfT\nP+HYQcgpL/Et+g5D+jWrTSDXA+qsR5SnKwW1TzRfWSMKeUoxCnB4Cwe8jGOlKnd7\n51GLpGX8Zyiy0fJRkxNv/AgTy3oyIr1VkQ7RZ5EEp0SjIXXLUVPsppymVUH+JwFp\nr+W+Ljrfnu7WkPHifDrJGOFwY+LBTeBTP26CvL9p+MiW6kYGCaO1+Hp+x6vbk0uE\nv+veJ9mFjhAe5/iFPInBRxtZF2VZ6WDj4OBQJJws6ZkBNyMn1+M48y8C0m04KoA=\n=TuF4\n-----END PGP SIGNATURE-----\n", "payload": "tree f22c1d5af6dcd994667d656833c3a27c568961ff\nparent dfbd81e84a699005db4e88e9fbf8d4440525a097\nparent 6766a6b0e189f47d7a405c872598bca9a2395360\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1591870072 +0000\ncommitter GitHub <noreply@github.com> 1591870072 +0000\n\nMerge #4819\n\n4819: Add an FST index to `ImportMap` and use it to speed up auto import r=matklad a=jonas-schievink\n\nFor the importing crate, we still use the symbol index, but I've modified it to only look at files that comprise that crate (instead of the whole workspace).\r\n\r\nOh, and since now the symbol query limit is respected correctly, it's possible that some results from the local crate now disappear if there are many matches.\r\n\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/4763\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f320c38aec185de2a02e0febff133da1f6a3462b", "html_url": "https://github.com/rust-lang/rust/commit/f320c38aec185de2a02e0febff133da1f6a3462b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f320c38aec185de2a02e0febff133da1f6a3462b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfbd81e84a699005db4e88e9fbf8d4440525a097", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbd81e84a699005db4e88e9fbf8d4440525a097", "html_url": "https://github.com/rust-lang/rust/commit/dfbd81e84a699005db4e88e9fbf8d4440525a097"}, {"sha": "6766a6b0e189f47d7a405c872598bca9a2395360", "url": "https://api.github.com/repos/rust-lang/rust/commits/6766a6b0e189f47d7a405c872598bca9a2395360", "html_url": "https://github.com/rust-lang/rust/commit/6766a6b0e189f47d7a405c872598bca9a2395360"}], "stats": {"total": 581, "additions": 537, "deletions": 44}, "files": [{"sha": "e6338e3160b8a621a825dfafaa80426e4addead4", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -981,7 +981,10 @@ dependencies = [\n  \"anymap\",\n  \"drop_bomb\",\n  \"either\",\n+ \"fst\",\n+ \"indexmap\",\n  \"insta\",\n+ \"itertools\",\n  \"log\",\n  \"once_cell\",\n  \"ra_arena\","}, {"sha": "5092bf3366714370e4b6899047c899d842f44ffd", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -130,7 +130,7 @@ impl AutoImportAssets {\n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n         let _p = profile(\"auto_import::search_for_imports\");\n         let current_crate = self.module_with_name_to_import.krate();\n-        ImportsLocator::new(db)\n+        ImportsLocator::new(db, current_crate)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n             .filter_map(|candidate| match &self.import_candidate {\n@@ -841,4 +841,105 @@ fn main() {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn dep_import() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+                    pub struct Struct;\n+\n+                    //- /main.rs crate:main deps:dep\n+                    fn main() {\n+                        Struct<|>\n+                    }\",\n+            r\"use dep::Struct;\n+\n+fn main() {\n+    Struct\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn whole_segment() {\n+        // Tests that only imports whose last segment matches the identifier get suggested.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+                    pub mod fmt {\n+                        pub trait Display {}\n+                    }\n+\n+                    pub fn panic_fmt() {}\n+\n+                    //- /main.rs crate:main deps:dep\n+                    struct S;\n+\n+                    impl f<|>mt::Display for S {}\",\n+            r\"use dep::fmt;\n+\n+struct S;\n+impl fmt::Display for S {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_generated() {\n+        // Tests that macro-generated items are suggested from external crates.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+\n+                    macro_rules! mac {\n+                        () => {\n+                            pub struct Cheese;\n+                        };\n+                    }\n+\n+                    mac!();\n+\n+                    //- /main.rs crate:main deps:dep\n+\n+                    fn main() {\n+                        Cheese<|>;\n+                    }\",\n+            r\"use dep::Cheese;\n+\n+fn main() {\n+    Cheese;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn casing() {\n+        // Tests that differently cased names don't interfere and we only suggest the matching one.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+\n+                    pub struct FMT;\n+                    pub struct fmt;\n+\n+                    //- /main.rs crate:main deps:dep\n+\n+                    fn main() {\n+                        FMT<|>;\n+                    }\",\n+            r\"use dep::FMT;\n+\n+fn main() {\n+    FMT;\n+}\n+\",\n+        );\n+    }\n }"}, {"sha": "1a9f6cc768b6386e80720907de66eade9d9b9eb1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -9,6 +9,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n+    import_map,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     type_ref::{Mutability, TypeRef},\n@@ -98,6 +99,23 @@ impl Crate {\n         db.crate_graph()[self.id].display_name.as_ref().cloned()\n     }\n \n+    pub fn query_external_importables(\n+        self,\n+        db: &dyn DefDatabase,\n+        query: &str,\n+    ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+        import_map::search_dependencies(\n+            db,\n+            self.into(),\n+            import_map::Query::new(query).anchor_end().case_sensitive().limit(40),\n+        )\n+        .into_iter()\n+        .map(|item| match item {\n+            ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n+            ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n+        })\n+    }\n+\n     pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }"}, {"sha": "ef1f65ee0655ad26a9c5a7d9289fdcff3a2787a1", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -14,6 +14,9 @@ rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n anymap = \"0.12.1\"\n drop_bomb = \"0.1.4\"\n+fst = { version = \"0.4\", default-features = false }\n+itertools = \"0.9.0\"\n+indexmap = \"1.4.0\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "36b4fdd816061efe94c452cf8b4a108d427d2e1a", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "modified", "additions": 345, "deletions": 10, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -1,9 +1,11 @@\n //! A map of all publicly exported items in a crate.\n \n-use std::{collections::hash_map::Entry, fmt, sync::Arc};\n+use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n \n+use fst::{self, Streamer};\n+use indexmap::{map::Entry, IndexMap};\n use ra_db::CrateId;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHasher;\n \n use crate::{\n     db::DefDatabase,\n@@ -13,6 +15,8 @@ use crate::{\n     ModuleDefId, ModuleId,\n };\n \n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n+\n /// A map from publicly exported items to the path needed to import/name them from a downstream\n /// crate.\n ///\n@@ -21,16 +25,24 @@ use crate::{\n ///\n /// Note that all paths are relative to the containing crate's root, so the crate name still needs\n /// to be prepended to the `ModPath` before the path is valid.\n-#[derive(Eq, PartialEq)]\n pub struct ImportMap {\n-    map: FxHashMap<ItemInNs, ModPath>,\n+    map: FxIndexMap<ItemInNs, ModPath>,\n+\n+    /// List of keys stored in `map`, sorted lexicographically by their `ModPath`. Indexed by the\n+    /// values returned by running `fst`.\n+    ///\n+    /// Since a path can refer to multiple items due to namespacing, we store all items with the\n+    /// same path right after each other. This allows us to find all items after the FST gives us\n+    /// the index of the first one.\n+    importables: Vec<ItemInNs>,\n+    fst: fst::Map<Vec<u8>>,\n }\n \n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n         let _p = ra_prof::profile(\"import_map_query\");\n         let def_map = db.crate_def_map(krate);\n-        let mut import_map = FxHashMap::with_capacity_and_hasher(64, Default::default());\n+        let mut import_map = FxIndexMap::with_capacity_and_hasher(64, Default::default());\n \n         // We look only into modules that are public(ly reexported), starting with the crate root.\n         let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n@@ -88,7 +100,34 @@ impl ImportMap {\n             }\n         }\n \n-        Arc::new(Self { map: import_map })\n+        let mut importables = import_map.iter().collect::<Vec<_>>();\n+\n+        importables.sort_by(cmp);\n+\n+        // Build the FST, taking care not to insert duplicate values.\n+\n+        let mut builder = fst::MapBuilder::memory();\n+        let mut last_batch_start = 0;\n+\n+        for idx in 0..importables.len() {\n+            if let Some(next_item) = importables.get(idx + 1) {\n+                if cmp(&importables[last_batch_start], next_item) == Ordering::Equal {\n+                    continue;\n+                }\n+            }\n+\n+            let start = last_batch_start;\n+            last_batch_start = idx + 1;\n+\n+            let key = fst_path(&importables[start].1);\n+\n+            builder.insert(key, start as u64).unwrap();\n+        }\n+\n+        let fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n+        let importables = importables.iter().map(|(item, _)| **item).collect();\n+\n+        Arc::new(Self { map: import_map, fst, importables })\n     }\n \n     /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n@@ -97,6 +136,15 @@ impl ImportMap {\n     }\n }\n \n+impl PartialEq for ImportMap {\n+    fn eq(&self, other: &Self) -> bool {\n+        // `fst` and `importables` are built from `map`, so we don't need to compare them.\n+        self.map == other.map\n+    }\n+}\n+\n+impl Eq for ImportMap {}\n+\n impl fmt::Debug for ImportMap {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut importable_paths: Vec<_> = self\n@@ -117,19 +165,135 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n+fn fst_path(path: &ModPath) -> String {\n+    let mut s = path.to_string();\n+    s.make_ascii_lowercase();\n+    s\n+}\n+\n+fn cmp((_, lhs): &(&ItemInNs, &ModPath), (_, rhs): &(&ItemInNs, &ModPath)) -> Ordering {\n+    let lhs_str = fst_path(lhs);\n+    let rhs_str = fst_path(rhs);\n+    lhs_str.cmp(&rhs_str)\n+}\n+\n+#[derive(Debug)]\n+pub struct Query {\n+    query: String,\n+    lowercased: String,\n+    anchor_end: bool,\n+    case_sensitive: bool,\n+    limit: usize,\n+}\n+\n+impl Query {\n+    pub fn new(query: &str) -> Self {\n+        Self {\n+            lowercased: query.to_lowercase(),\n+            query: query.to_string(),\n+            anchor_end: false,\n+            case_sensitive: false,\n+            limit: usize::max_value(),\n+        }\n+    }\n+\n+    /// Only returns items whose paths end with the (case-insensitive) query string as their last\n+    /// segment.\n+    pub fn anchor_end(self) -> Self {\n+        Self { anchor_end: true, ..self }\n+    }\n+\n+    /// Limits the returned number of items to `limit`.\n+    pub fn limit(self, limit: usize) -> Self {\n+        Self { limit, ..self }\n+    }\n+\n+    /// Respect casing of the query string when matching.\n+    pub fn case_sensitive(self) -> Self {\n+        Self { case_sensitive: true, ..self }\n+    }\n+}\n+\n+/// Searches dependencies of `krate` for an importable path matching `query`.\n+///\n+/// This returns a list of items that could be imported from dependencies of `krate`.\n+pub fn search_dependencies<'a>(\n+    db: &'a dyn DefDatabase,\n+    krate: CrateId,\n+    query: Query,\n+) -> Vec<ItemInNs> {\n+    let _p = ra_prof::profile(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n+\n+    let graph = db.crate_graph();\n+    let import_maps: Vec<_> =\n+        graph[krate].dependencies.iter().map(|dep| db.import_map(dep.crate_id)).collect();\n+\n+    let automaton = fst::automaton::Subsequence::new(&query.lowercased);\n+\n+    let mut op = fst::map::OpBuilder::new();\n+    for map in &import_maps {\n+        op = op.add(map.fst.search(&automaton));\n+    }\n+\n+    let mut stream = op.union();\n+    let mut res = Vec::new();\n+    while let Some((_, indexed_values)) = stream.next() {\n+        for indexed_value in indexed_values {\n+            let import_map = &import_maps[indexed_value.index];\n+            let importables = &import_map.importables[indexed_value.value as usize..];\n+\n+            // Path shared by the importable items in this group.\n+            let path = &import_map.map[&importables[0]];\n+\n+            if query.anchor_end {\n+                // Last segment must match query.\n+                let last = path.segments.last().unwrap().to_string();\n+                if last.to_lowercase() != query.lowercased {\n+                    continue;\n+                }\n+            }\n+\n+            // Add the items from this `ModPath` group. Those are all subsequent items in\n+            // `importables` whose paths match `path`.\n+            let iter = importables.iter().copied().take_while(|item| {\n+                let item_path = &import_map.map[item];\n+                fst_path(item_path) == fst_path(path)\n+            });\n+\n+            if query.case_sensitive {\n+                // FIXME: This does not do a subsequence match.\n+                res.extend(iter.filter(|item| {\n+                    let item_path = &import_map.map[item];\n+                    item_path.to_string().contains(&query.query)\n+                }));\n+            } else {\n+                res.extend(iter);\n+            }\n+\n+            if res.len() >= query.limit {\n+                res.truncate(query.limit);\n+                return res;\n+            }\n+        }\n+    }\n+\n+    res\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use crate::test_db::TestDB;\n     use insta::assert_snapshot;\n+    use itertools::Itertools;\n     use ra_db::fixture::WithFixture;\n-    use ra_db::SourceDatabase;\n+    use ra_db::{SourceDatabase, Upcast};\n \n     fn import_map(ra_fixture: &str) -> String {\n         let db = TestDB::with_files(ra_fixture);\n         let crate_graph = db.crate_graph();\n \n-        let import_maps: Vec<_> = crate_graph\n+        let s = crate_graph\n             .iter()\n             .filter_map(|krate| {\n                 let cdata = &crate_graph[krate];\n@@ -139,9 +303,41 @@ mod tests {\n \n                 Some(format!(\"{}:\\n{:?}\", name, map))\n             })\n-            .collect();\n+            .join(\"\\n\");\n+        s\n+    }\n \n-        import_maps.join(\"\\n\")\n+    fn search_dependencies_of(ra_fixture: &str, krate_name: &str, query: Query) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+        let krate = crate_graph\n+            .iter()\n+            .find(|krate| {\n+                crate_graph[*krate].display_name.as_ref().map(|n| n.to_string())\n+                    == Some(krate_name.to_string())\n+            })\n+            .unwrap();\n+\n+        search_dependencies(db.upcast(), krate, query)\n+            .into_iter()\n+            .filter_map(|item| {\n+                let mark = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                item.krate(db.upcast()).map(|krate| {\n+                    let map = db.import_map(krate);\n+                    let path = map.path_of(item).unwrap();\n+                    format!(\n+                        \"{}::{} ({})\",\n+                        crate_graph[krate].display_name.as_ref().unwrap(),\n+                        path,\n+                        mark\n+                    )\n+                })\n+            })\n+            .join(\"\\n\")\n     }\n \n     #[test]\n@@ -328,4 +524,143 @@ mod tests {\n         lib:\n         \"###);\n     }\n+\n+    #[test]\n+    fn namespacing() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub struct Thing;     // t + v\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        - Thing (v)\n+        \"###);\n+\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod Thing {}      // t\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\"));\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (v)\n+        dep::Fmt (m)\n+        dep::fmt::Display (t)\n+        dep::format (v)\n+        \"###);\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\").anchor_end());\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (v)\n+        dep::Fmt (m)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search_casing() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep\n+\n+            pub struct fmt;\n+            pub struct FMT;\n+        \"#;\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\"));\n+\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::fmt (v)\n+        dep::FMT (t)\n+        dep::FMT (v)\n+        \"###);\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\").case_sensitive());\n+\n+        assert_snapshot!(res, @r###\"\n+        dep::FMT (t)\n+        dep::FMT (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search_limit() {\n+        let res = search_dependencies_of(\n+            r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                fn fmt();\n+            }\n+        }\n+        #[macro_export]\n+        macro_rules! Fmt {\n+            () => {};\n+        }\n+        pub struct Fmt;\n+\n+        pub fn format() {}\n+        pub fn no() {}\n+    \"#,\n+            \"main\",\n+            Query::new(\"\").limit(2),\n+        );\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        \"###);\n+    }\n }"}, {"sha": "fff112e661034c3ffda72a122639422c899343b6", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -1,7 +1,7 @@\n //! This module contains an import search funcionality that is provided to the ra_assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n \n-use hir::{MacroDef, ModuleDef, Semantics};\n+use hir::{Crate, MacroDef, ModuleDef, Semantics};\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n \n@@ -11,44 +11,46 @@ use crate::{\n     RootDatabase,\n };\n use either::Either;\n+use rustc_hash::FxHashSet;\n \n pub struct ImportsLocator<'a> {\n     sema: Semantics<'a, RootDatabase>,\n+    krate: Crate,\n }\n \n impl<'a> ImportsLocator<'a> {\n-    pub fn new(db: &'a RootDatabase) -> Self {\n-        Self { sema: Semantics::new(db) }\n+    pub fn new(db: &'a RootDatabase, krate: Crate) -> Self {\n+        Self { sema: Semantics::new(db), krate }\n     }\n \n     pub fn find_imports(&mut self, name_to_import: &str) -> Vec<Either<ModuleDef, MacroDef>> {\n         let _p = profile(\"search_for_imports\");\n         let db = self.sema.db;\n \n-        let project_results = {\n-            let mut query = Query::new(name_to_import.to_string());\n-            query.exact();\n-            query.limit(40);\n-            symbol_index::world_symbols(db, query)\n-        };\n-        let lib_results = {\n+        // Query dependencies first.\n+        let mut candidates: FxHashSet<_> =\n+            self.krate.query_external_importables(db, name_to_import).collect();\n+\n+        // Query the local crate using the symbol index.\n+        let local_results = {\n             let mut query = Query::new(name_to_import.to_string());\n-            query.libs();\n             query.exact();\n             query.limit(40);\n-            symbol_index::world_symbols(db, query)\n+            symbol_index::crate_symbols(db, self.krate.into(), query)\n         };\n \n-        project_results\n-            .into_iter()\n-            .chain(lib_results.into_iter())\n-            .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n-            .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n-                Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n-                _ => None,\n-            })\n-            .collect()\n+        candidates.extend(\n+            local_results\n+                .into_iter()\n+                .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n+                .filter_map(|name_definition_to_import| match name_definition_to_import {\n+                    Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n+                    Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n+                    _ => None,\n+                }),\n+        );\n+\n+        candidates.into_iter().collect()\n     }\n \n     fn get_name_definition(&mut self, import_candidate: &FileSymbol) -> Option<Definition> {"}, {"sha": "aab91897320acd2da070551c94f36554b7db2253", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320c38aec185de2a02e0febff133da1f6a3462b/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=f320c38aec185de2a02e0febff133da1f6a3462b", "patch": "@@ -29,9 +29,10 @@ use std::{\n };\n \n use fst::{self, Streamer};\n+use hir::db::DefDatabase;\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n-    FileId, SourceDatabaseExt, SourceRootId,\n+    CrateId, FileId, SourceDatabaseExt, SourceRootId,\n };\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -110,6 +111,14 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n+/// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n+struct Snap(salsa::Snapshot<RootDatabase>);\n+impl Clone for Snap {\n+    fn clone(&self) -> Snap {\n+        Snap(self.0.snapshot())\n+    }\n+}\n+\n // Feature: Workspace Symbol\n //\n // Uses fuzzy-search to find types, modules and functions by name across your\n@@ -132,13 +141,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n // | VS Code | kbd:[Ctrl+T]\n // |===\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n-    /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-    struct Snap(salsa::Snapshot<RootDatabase>);\n-    impl Clone for Snap {\n-        fn clone(&self) -> Snap {\n-            Snap(self.0.snapshot())\n-        }\n-    }\n+    let _p = ra_prof::profile(\"world_symbols\").detail(|| query.query.clone());\n \n     let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n         let snap = Snap(db.snapshot());\n@@ -173,6 +176,33 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     query.search(&buf)\n }\n \n+pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<FileSymbol> {\n+    // FIXME(#4842): This now depends on CrateDefMap, why not build the entire symbol index from\n+    // that instead?\n+\n+    let def_map = db.crate_def_map(krate);\n+    let mut files = Vec::new();\n+    let mut modules = vec![def_map.root];\n+    while let Some(module) = modules.pop() {\n+        let data = &def_map[module];\n+        files.extend(data.origin.file_id());\n+        modules.extend(data.children.values());\n+    }\n+\n+    let snap = Snap(db.snapshot());\n+\n+    #[cfg(not(feature = \"wasm\"))]\n+    let buf = files\n+        .par_iter()\n+        .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n+        .collect::<Vec<_>>();\n+\n+    #[cfg(feature = \"wasm\")]\n+    let buf = files.iter().map(|&file_id| snap.0.file_symbols(file_id)).collect::<Vec<_>>();\n+\n+    query.search(&buf)\n+}\n+\n pub fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n     let name = name_ref.text();\n     let mut query = Query::new(name.to_string());\n@@ -298,9 +328,6 @@ impl Query {\n         let mut stream = op.union();\n         let mut res = Vec::new();\n         while let Some((_, indexed_values)) = stream.next() {\n-            if res.len() >= self.limit {\n-                break;\n-            }\n             for indexed_value in indexed_values {\n                 let symbol_index = &indices[indexed_value.index];\n                 let (start, end) = SymbolIndex::map_value_to_range(indexed_value.value);\n@@ -312,7 +339,11 @@ impl Query {\n                     if self.exact && symbol.name != self.query {\n                         continue;\n                     }\n+\n                     res.push(symbol.clone());\n+                    if res.len() >= self.limit {\n+                        return res;\n+                    }\n                 }\n             }\n         }"}]}