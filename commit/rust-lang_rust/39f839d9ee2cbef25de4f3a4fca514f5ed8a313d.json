{"sha": "39f839d9ee2cbef25de4f3a4fca514f5ed8a313d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjgzOWQ5ZWUyY2JlZjI1ZGU0ZjNhNGZjYTUxNGY1ZWQ4YTMxM2Q=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-01T14:38:20Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-02T15:17:23Z"}, "message": "middle: ty: remove dead code", "tree": {"sha": "b4a57fbd8d9f73f41e1f90e60c08a1ca73d81a3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a57fbd8d9f73f41e1f90e60c08a1ca73d81a3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d", "html_url": "https://github.com/rust-lang/rust/commit/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4653941d6a960691249218205b58b5576ce21c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4653941d6a960691249218205b58b5576ce21c7", "html_url": "https://github.com/rust-lang/rust/commit/b4653941d6a960691249218205b58b5576ce21c7"}], "stats": {"total": 213, "additions": 4, "deletions": 209}, "files": [{"sha": "1a12c0ab6ac0afd56dbcc398953be9c0e31ed76f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 209, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f839d9ee2cbef25de4f3a4fca514f5ed8a313d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=39f839d9ee2cbef25de4f3a4fca514f5ed8a313d", "patch": "@@ -411,9 +411,6 @@ pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), needs_infer)\n }\n-pub fn type_has_regions(t: t) -> bool {\n-    tbox_has_flag(get(t), has_regions)\n-}\n pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n@@ -1506,10 +1503,6 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: &ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n-    ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n-}\n-\n // Substitute *only* type parameters.  Used in trans where regions are erased.\n pub fn subst_tps(tcx: &ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n@@ -1623,27 +1616,13 @@ pub fn type_is_structural(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_sequence(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_str(_) | ty_vec(_, _) => true,\n-      _ => false\n-    }\n-}\n-\n pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n     }\n }\n \n-pub fn type_is_str(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_str(_) => true,\n-      _ => false\n-    }\n-}\n-\n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_str(_) => return mk_mach_uint(ast::TyU8),\n@@ -1672,20 +1651,6 @@ pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n     }\n }\n \n-pub fn get_element_type(ty: t, i: uint) -> t {\n-    match get(ty).sty {\n-      ty_tup(ref ts) => return *ts.get(i),\n-      _ => fail!(\"get_element_type called on invalid type\")\n-    }\n-}\n-\n-pub fn type_is_box(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_box(_) => return true,\n-      _ => return false\n-    }\n-}\n-\n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) => true,\n@@ -1700,35 +1665,13 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_slice(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_)) => true,\n-      _ => return false\n-    }\n-}\n-\n-pub fn type_is_unique_box(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_uniq(_) => return true,\n-      _ => return false\n-    }\n-}\n-\n pub fn type_is_unsafe_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pub fn type_is_vec(ty: t) -> bool {\n-    return match get(ty).sty {\n-          ty_vec(_, _) | ty_unboxed_vec(_) => true,\n-          ty_str(_) => true,\n-          _ => false\n-        };\n-}\n-\n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) | ty_vec(_, vstore_uniq) | ty_str(vstore_uniq) => true,\n@@ -1920,10 +1863,6 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_bounds(&self, cx: &ctxt, bbs: BuiltinBounds) -> bool {\n-        bbs.iter().all(|bb| self.meets_bound(cx, bb))\n-    }\n-\n     pub fn meets_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n             BoundStatic => self.is_static(cx),\n@@ -2021,10 +1960,6 @@ impl TypeContents {\n         v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n-    pub fn inverse(&self) -> TypeContents {\n-        TypeContents { bits: !self.bits }\n-    }\n-\n     pub fn has_dtor(&self) -> bool {\n         self.intersects(TC::OwnsDtor)\n     }\n@@ -2054,10 +1989,6 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_has_dtor(cx: &ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).has_dtor()\n-}\n-\n pub fn type_is_static(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n@@ -2642,14 +2573,8 @@ pub fn type_is_machine(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_enum(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_enum(_, _) => return true,\n-      _ => return false\n-    }\n-}\n-\n // Is the type's representation size known at compile time?\n+#[allow(dead_code)] // leaving in for DST\n pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n     match get(ty).sty {\n         // FIXME(#6308) add trait, vec, str, etc here.\n@@ -2681,14 +2606,6 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-pub fn type_param(ty: t) -> Option<uint> {\n-    match get(ty).sty {\n-      ty_param(p) => return Some(p.idx),\n-      _ => {/* fall through */ }\n-    }\n-    return None;\n-}\n-\n // Returns the type and mutability of *t.\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n@@ -2751,10 +2668,6 @@ pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n     }\n }\n \n-fn node_id_has_type_params(cx: &ctxt, id: ast::NodeId) -> bool {\n-    cx.node_type_substs.borrow().contains_key(&id)\n-}\n-\n pub fn fn_is_variadic(fty: t) -> bool {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.variadic,\n@@ -2795,16 +2708,6 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     }\n }\n \n-pub fn ty_fn_purity(fty: t) -> ast::Purity {\n-    match get(fty).sty {\n-        ty_bare_fn(ref f) => f.purity,\n-        ty_closure(ref f) => f.purity,\n-        ref s => {\n-            fail!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n-        }\n-    }\n-}\n-\n pub fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n@@ -2823,14 +2726,6 @@ pub fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-pub fn ty_vstore(ty: t) -> vstore {\n-    match get(ty).sty {\n-        ty_vec(_, vstore) => vstore,\n-        ty_str(vstore) => vstore,\n-        ref s => fail!(\"ty_vstore() called on invalid sty: {:?}\", s)\n-    }\n-}\n-\n pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: t) -> Region {\n@@ -2846,49 +2741,6 @@ pub fn ty_region(tcx: &ctxt,\n     }\n }\n \n-pub fn replace_fn_sig(cx: &ctxt, fsty: &sty, new_sig: FnSig) -> t {\n-    match *fsty {\n-        ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n-        ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..**f}),\n-        ref s => {\n-            cx.sess.bug(\n-                format!(\"ty_fn_sig() called on non-fn type: {:?}\", s));\n-        }\n-    }\n-}\n-\n-pub fn replace_closure_return_type(tcx: &ctxt, fn_type: t, ret_type: t) -> t {\n-    /*!\n-     *\n-     * Returns a new function type based on `fn_type` but returning a value of\n-     * type `ret_type` instead. */\n-\n-    match ty::get(fn_type).sty {\n-        ty::ty_closure(ref fty) => {\n-            ty::mk_closure(tcx, ClosureTy {\n-                sig: FnSig {output: ret_type, ..fty.sig.clone()},\n-                ..(**fty).clone()\n-            })\n-        }\n-        _ => {\n-            tcx.sess.bug(format!(\n-                \"replace_fn_ret() invoked with non-fn-type: {}\",\n-                ty_to_str(tcx, fn_type)));\n-        }\n-    }\n-}\n-\n-// Returns a vec of all the input and output types of fty.\n-pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n-    sig.inputs.iter().map(|a| *a).collect::<Vec<_>>().append_one(sig.output)\n-}\n-\n-// Type accessors for AST nodes\n-pub fn block_ty(cx: &ctxt, b: &ast::Block) -> t {\n-    return node_id_to_type(cx, b.id);\n-}\n-\n-\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n@@ -3180,6 +3032,7 @@ pub struct ParamsTy {\n     pub ty: t\n }\n \n+#[allow(dead_code)] // this may be useful?\n pub fn expr_ty_params_and_ty(cx: &ctxt,\n                              expr: &ast::Expr)\n                           -> ParamsTy {\n@@ -3189,10 +3042,6 @@ pub fn expr_ty_params_and_ty(cx: &ctxt,\n     }\n }\n \n-pub fn expr_has_ty_params(cx: &ctxt, expr: &ast::Expr) -> bool {\n-    return node_id_has_type_params(cx, expr.id);\n-}\n-\n pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n                                    -> Rc<Vec<TypeParameterDef>> {\n     match origin {\n@@ -3416,12 +3265,6 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n     }\n }\n \n-pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n-    let mut i = 0u;\n-    for f in fields.iter() { if f.ident.name == name { return Some(i); } i += 1u; }\n-    return None;\n-}\n-\n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n@@ -3657,14 +3500,6 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n     }\n }\n \n-pub fn def_has_ty_params(def: ast::Def) -> bool {\n-    match def {\n-      ast::DefFn(_, _) | ast::DefVariant(_, _, _) | ast::DefStruct(_)\n-        => true,\n-      _ => false\n-    }\n-}\n-\n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n }\n@@ -3843,8 +3678,8 @@ pub fn try_add_builtin_trait(tcx: &ctxt,\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n-      ty_trait(~TyTrait { def_id: id, .. }) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n-      _ => None\n+        ty_trait(~TyTrait { def_id: id, .. }) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n+        _ => None\n     }\n }\n \n@@ -4240,18 +4075,6 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     }\n }\n \n-pub fn lookup_struct_field(cx: &ctxt,\n-                           parent: ast::DefId,\n-                           field_id: ast::DefId)\n-                        -> field_ty {\n-    let r = lookup_struct_fields(cx, parent);\n-    match r.iter().find(\n-                 |f| f.id.node == field_id.node) {\n-        Some(t) => *t,\n-        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n-    }\n-}\n-\n fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n     fields.iter().map(|field| {\n         match field.node.kind {\n@@ -4361,13 +4184,6 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: &ctxt, generics: &ast::Generics) -> Vec<t> {\n-    Vec::from_fn(generics.ty_params.len(), |i| {\n-        let id = generics.ty_params.get(i).id;\n-        ty::mk_param(tcx, i, ast_util::local_def(id))\n-    })\n-}\n-\n /// Returns an equivalent type with all the typedefs and self regions removed.\n pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n@@ -4547,19 +4363,6 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n-pub fn count_traits_and_supertraits(tcx: &ctxt,\n-                                    type_param_defs: &[TypeParameterDef]) -> uint {\n-    let mut total = 0;\n-    for type_param_def in type_param_defs.iter() {\n-        each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds.as_slice(), |_| {\n-            total += 1;\n-            true\n-        });\n-    }\n-    return total;\n-}\n-\n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n@@ -5043,12 +4846,4 @@ impl BorrowKind {\n             UniqueImmBorrow => \"uniquely immutable\",\n         }\n     }\n-\n-    pub fn to_short_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mut\",\n-            ImmBorrow => \"imm\",\n-            UniqueImmBorrow => \"own\",\n-        }\n-    }\n }"}]}