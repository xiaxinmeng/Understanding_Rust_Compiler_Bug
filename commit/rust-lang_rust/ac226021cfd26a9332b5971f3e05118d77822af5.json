{"sha": "ac226021cfd26a9332b5971f3e05118d77822af5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjI2MDIxY2ZkMjZhOTMzMmI1OTcxZjNlMDUxMThkNzc4MjJhZjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-26T09:09:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-26T09:09:28Z"}, "message": "scope based comletion", "tree": {"sha": "04e9d19956b74d551f798bf26f420fa978b8f30f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04e9d19956b74d551f798bf26f420fa978b8f30f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac226021cfd26a9332b5971f3e05118d77822af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac226021cfd26a9332b5971f3e05118d77822af5", "html_url": "https://github.com/rust-lang/rust/commit/ac226021cfd26a9332b5971f3e05118d77822af5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac226021cfd26a9332b5971f3e05118d77822af5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c121bfa2f2a7a06f01143e3203c650156e2fb4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c121bfa2f2a7a06f01143e3203c650156e2fb4e", "html_url": "https://github.com/rust-lang/rust/commit/4c121bfa2f2a7a06f01143e3203c650156e2fb4e"}], "stats": {"total": 516, "additions": 475, "deletions": 41}, "files": [{"sha": "e6ba83d2ec50d78d39237fff4e09484e83b7924d", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -9,7 +9,7 @@ use libsyntax2::{\n     SyntaxNodeRef,\n     algo::{\n         Direction, siblings,\n-        find_leaf_at_offset, ancestors,\n+        find_leaf_at_offset,\n     },\n };\n "}, {"sha": "16c9ead7416e3faa40774a5b5c9b366aede84fae", "filename": "crates/libeditor/src/completion.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcompletion.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -1,7 +1,11 @@\n use libsyntax2::{\n-    File, TextUnit,\n-    ast,\n-    algo::find_leaf_at_offset,\n+    File, TextUnit, AstNode, SyntaxNodeRef,\n+    ast::{self, NameOwner},\n+    algo::{\n+        ancestors,\n+        visit::{visitor_ctx, VisitorCtx},\n+        walk::preorder,\n+    },\n };\n \n use {\n@@ -25,7 +29,33 @@ pub fn scope_completion(file: &File, offset: TextUnit) -> Option<Vec<CompletionI\n }\n \n fn complete(name_ref: ast::NameRef) -> Vec<CompletionItem> {\n-    vec![CompletionItem {\n-        name: \"foo\".to_string()\n-    }]\n+    let mut res = Vec::new();\n+    for node in ancestors(name_ref.syntax()) {\n+        process_scope(node, &mut res);\n+    }\n+    res\n+}\n+\n+fn process_scope(node: SyntaxNodeRef, sink: &mut Vec<CompletionItem>) {\n+    let _ = visitor_ctx(sink)\n+        .visit::<ast::Block, _>(|block, sink| {\n+            block.let_stmts()\n+                .filter_map(|it| it.pat())\n+                .for_each(move |it| process_pat(it, sink))\n+        })\n+        .visit::<ast::FnDef, _>(|fn_def, sink| {\n+            fn_def.param_list().into_iter()\n+                .flat_map(|it| it.params())\n+                .filter_map(|it| it.pat())\n+                .for_each(move |it| process_pat(it, sink))\n+        })\n+        .accept(node);\n+\n+    fn process_pat(pat: ast::Pat, sink: &mut Vec<CompletionItem>) {\n+        let items = preorder(pat.syntax())\n+            .filter_map(ast::BindPat::cast)\n+            .filter_map(ast::BindPat::name)\n+            .map(|name| CompletionItem { name: name.text().to_string() });\n+        sink.extend(items);\n+    }\n }"}, {"sha": "ecdc149c736f2bb565905aabd739d68921008751", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -256,25 +256,23 @@ struct Foo { f: u32 }\n \");\n }\n \n-// #[test]\n-// fn test_completion() {\n-//     fn do_check(code: &str, expected_completions: &str) {\n-//         let (off, code) = extract_offset(&code);\n-//         let file = file(&code);\n-//         let completions = scope_completion(&file, off).unwrap();\n-//         assert_eq_dbg(expected_completions, &completions);\n-//     }\n+#[test]\n+fn test_completion() {\n+    fn do_check(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let file = file(&code);\n+        let completions = scope_completion(&file, off).unwrap();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n \n-//     do_check(r\"\n-// fn foo(foo: i32) {\n-//     let bar = 92;\n-//     1 + <|>\n-// }\n-// \", r#\"\n-// CompletionItem { name: \"bar\" },\n-// CompletionItem { name: \"foo\" },\n-// \"#);\n-// }\n+    do_check(r\"\n+fn quux(x: i32) {\n+    let y = 92;\n+    1 + <|>\n+}\n+\", r#\"[CompletionItem { name: \"y\" },\n+       CompletionItem { name: \"x\" }]\"#);\n+}\n \n fn file(text: &str) -> File {\n     File::parse(text)"}, {"sha": "9f1c127c70776883d092713198f8d01b363164c6", "filename": "crates/libsyntax2/src/algo/visit.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -6,6 +6,10 @@ pub fn visitor<'a, T>() -> impl Visitor<'a, Output=T> {\n     EmptyVisitor { ph: PhantomData }\n }\n \n+pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output=T, Ctx=C> {\n+    EmptyVisitorCtx { ph: PhantomData, ctx }\n+}\n+\n pub trait Visitor<'a>: Sized {\n     type Output;\n     fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output>;\n@@ -17,6 +21,18 @@ pub trait Visitor<'a>: Sized {\n     }\n }\n \n+pub trait VisitorCtx<'a>: Sized {\n+    type Output;\n+    type Ctx;\n+    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx>;\n+    fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n+        where N: AstNode<'a>,\n+              F: FnOnce(N, Self::Ctx) -> Self::Output,\n+    {\n+        VisCtx { inner: self, f, ph: PhantomData }\n+    }\n+}\n+\n #[derive(Debug)]\n struct EmptyVisitor<T> {\n     ph: PhantomData<fn() -> T>\n@@ -30,6 +46,21 @@ impl<'a, T> Visitor<'a> for EmptyVisitor<T> {\n     }\n }\n \n+#[derive(Debug)]\n+struct EmptyVisitorCtx<T, C> {\n+    ctx: C,\n+    ph: PhantomData<fn() -> T>,\n+}\n+\n+impl<'a, T, C> VisitorCtx<'a> for EmptyVisitorCtx<T, C> {\n+    type Output = T;\n+    type Ctx = C;\n+\n+    fn accept(self, _node: SyntaxNodeRef<'a>) -> Result<T, C> {\n+        Err(self.ctx)\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct Vis<V, N, F> {\n     inner: V,\n@@ -50,3 +81,30 @@ impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n         inner.accept(node).or_else(|| N::cast(node).map(f))\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct VisCtx<V, N, F> {\n+    inner: V,\n+    f: F,\n+    ph: PhantomData<fn(N)>,\n+}\n+\n+impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n+    where\n+        V: VisitorCtx<'a>,\n+        N: AstNode<'a>,\n+        F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+{\n+    type Output = <V as VisitorCtx<'a>>::Output;\n+    type Ctx = <V as VisitorCtx<'a>>::Ctx;\n+\n+    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx> {\n+        let VisCtx { inner, f, .. } = self;\n+        inner.accept(node).or_else(|ctx|\n+            match N::cast(node) {\n+                None => Err(ctx),\n+                Some(node) => Ok(f(node, ctx))\n+            }\n+        )\n+    }\n+}"}, {"sha": "536ee705fbd4972bc7886336fe386b81e3bca0ad", "filename": "crates/libsyntax2/src/algo/walk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fwalk.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -17,19 +17,19 @@ pub enum WalkEvent<'a> {\n }\n \n pub fn walk<'a>(root: SyntaxNodeRef<'a>) -> impl Iterator<Item = WalkEvent<'a>> {\n-    generate(Some(WalkEvent::Enter(root)), |pos| {\n+    generate(Some(WalkEvent::Enter(root)), move |pos| {\n         let next = match *pos {\n             WalkEvent::Enter(node) => match node.first_child() {\n                 Some(child) => WalkEvent::Enter(child),\n                 None => WalkEvent::Exit(node),\n             },\n             WalkEvent::Exit(node) => {\n+                if node == root {\n+                    return None;\n+                }\n                 match node.next_sibling() {\n                     Some(sibling) => WalkEvent::Enter(sibling),\n-                    None => match node.parent() {\n-                        Some(node) => WalkEvent::Exit(node),\n-                        None => return None,\n-                    },\n+                    None => WalkEvent::Exit(node.parent().unwrap()),\n                 }\n             }\n         };"}, {"sha": "6926c0535e48ab04380959c1f43551567a71bb46", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 306, "deletions": 2, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -80,6 +80,25 @@ impl<'a> AstNode<'a> for BinExpr<'a> {\n \n impl<'a> BinExpr<'a> {}\n \n+// BindPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct BindPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for BindPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BIND_PAT => Some(BindPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ast::NameOwner<'a> for BindPat<'a> {}\n+impl<'a> BindPat<'a> {}\n+\n // Block\n #[derive(Debug, Clone, Copy)]\n pub struct Block<'a> {\n@@ -96,7 +115,11 @@ impl<'a> AstNode<'a> for Block<'a> {\n     fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<'a> Block<'a> {}\n+impl<'a> Block<'a> {\n+    pub fn let_stmts(self) -> impl Iterator<Item = LetStmt<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // BlockExpr\n #[derive(Debug, Clone, Copy)]\n@@ -378,6 +401,24 @@ impl<'a> AstNode<'a> for FieldExpr<'a> {\n \n impl<'a> FieldExpr<'a> {}\n \n+// FieldPatList\n+#[derive(Debug, Clone, Copy)]\n+pub struct FieldPatList<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for FieldPatList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            FIELD_PAT_LIST => Some(FieldPatList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> FieldPatList<'a> {}\n+\n // FnDef\n #[derive(Debug, Clone, Copy)]\n pub struct FnDef<'a> {\n@@ -397,7 +438,11 @@ impl<'a> AstNode<'a> for FnDef<'a> {\n impl<'a> ast::NameOwner<'a> for FnDef<'a> {}\n impl<'a> ast::TypeParamsOwner<'a> for FnDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for FnDef<'a> {}\n-impl<'a> FnDef<'a> {}\n+impl<'a> FnDef<'a> {\n+    pub fn param_list(self) -> Option<ParamList<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // FnPointerType\n #[derive(Debug, Clone, Copy)]\n@@ -561,6 +606,28 @@ impl<'a> AstNode<'a> for LambdaExpr<'a> {\n \n impl<'a> LambdaExpr<'a> {}\n \n+// LetStmt\n+#[derive(Debug, Clone, Copy)]\n+pub struct LetStmt<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for LetStmt<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            LET_STMT => Some(LetStmt { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> LetStmt<'a> {\n+    pub fn pat(self) -> Option<Pat<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // LoopExpr\n #[derive(Debug, Clone, Copy)]\n pub struct LoopExpr<'a> {\n@@ -831,6 +898,50 @@ impl<'a> ast::TypeParamsOwner<'a> for NominalDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}\n impl<'a> NominalDef<'a> {}\n \n+// Param\n+#[derive(Debug, Clone, Copy)]\n+pub struct Param<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for Param<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PARAM => Some(Param { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> Param<'a> {\n+    pub fn pat(self) -> Option<Pat<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// ParamList\n+#[derive(Debug, Clone, Copy)]\n+pub struct ParamList<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ParamList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PARAM_LIST => Some(ParamList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ParamList<'a> {\n+    pub fn params(self) -> impl Iterator<Item = Param<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n+\n // ParenExpr\n #[derive(Debug, Clone, Copy)]\n pub struct ParenExpr<'a> {\n@@ -867,6 +978,55 @@ impl<'a> AstNode<'a> for ParenType<'a> {\n \n impl<'a> ParenType<'a> {}\n \n+// Pat\n+#[derive(Debug, Clone, Copy)]\n+pub enum Pat<'a> {\n+    RefPat(RefPat<'a>),\n+    BindPat(BindPat<'a>),\n+    PlaceholderPat(PlaceholderPat<'a>),\n+    PathPat(PathPat<'a>),\n+    StructPat(StructPat<'a>),\n+    FieldPatList(FieldPatList<'a>),\n+    TupleStructPat(TupleStructPat<'a>),\n+    TuplePat(TuplePat<'a>),\n+    SlicePat(SlicePat<'a>),\n+    RangePat(RangePat<'a>),\n+}\n+\n+impl<'a> AstNode<'a> for Pat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            REF_PAT => Some(Pat::RefPat(RefPat { syntax })),\n+            BIND_PAT => Some(Pat::BindPat(BindPat { syntax })),\n+            PLACEHOLDER_PAT => Some(Pat::PlaceholderPat(PlaceholderPat { syntax })),\n+            PATH_PAT => Some(Pat::PathPat(PathPat { syntax })),\n+            STRUCT_PAT => Some(Pat::StructPat(StructPat { syntax })),\n+            FIELD_PAT_LIST => Some(Pat::FieldPatList(FieldPatList { syntax })),\n+            TUPLE_STRUCT_PAT => Some(Pat::TupleStructPat(TupleStructPat { syntax })),\n+            TUPLE_PAT => Some(Pat::TuplePat(TuplePat { syntax })),\n+            SLICE_PAT => Some(Pat::SlicePat(SlicePat { syntax })),\n+            RANGE_PAT => Some(Pat::RangePat(RangePat { syntax })),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n+        match self {\n+            Pat::RefPat(inner) => inner.syntax(),\n+            Pat::BindPat(inner) => inner.syntax(),\n+            Pat::PlaceholderPat(inner) => inner.syntax(),\n+            Pat::PathPat(inner) => inner.syntax(),\n+            Pat::StructPat(inner) => inner.syntax(),\n+            Pat::FieldPatList(inner) => inner.syntax(),\n+            Pat::TupleStructPat(inner) => inner.syntax(),\n+            Pat::TuplePat(inner) => inner.syntax(),\n+            Pat::SlicePat(inner) => inner.syntax(),\n+            Pat::RangePat(inner) => inner.syntax(),\n+        }\n+    }\n+}\n+\n+impl<'a> Pat<'a> {}\n+\n // PathExpr\n #[derive(Debug, Clone, Copy)]\n pub struct PathExpr<'a> {\n@@ -885,6 +1045,24 @@ impl<'a> AstNode<'a> for PathExpr<'a> {\n \n impl<'a> PathExpr<'a> {}\n \n+// PathPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct PathPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for PathPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PATH_PAT => Some(PathPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> PathPat<'a> {}\n+\n // PathType\n #[derive(Debug, Clone, Copy)]\n pub struct PathType<'a> {\n@@ -903,6 +1081,24 @@ impl<'a> AstNode<'a> for PathType<'a> {\n \n impl<'a> PathType<'a> {}\n \n+// PlaceholderPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct PlaceholderPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for PlaceholderPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PLACEHOLDER_PAT => Some(PlaceholderPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> PlaceholderPat<'a> {}\n+\n // PlaceholderType\n #[derive(Debug, Clone, Copy)]\n pub struct PlaceholderType<'a> {\n@@ -975,6 +1171,24 @@ impl<'a> AstNode<'a> for RangeExpr<'a> {\n \n impl<'a> RangeExpr<'a> {}\n \n+// RangePat\n+#[derive(Debug, Clone, Copy)]\n+pub struct RangePat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for RangePat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            RANGE_PAT => Some(RangePat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> RangePat<'a> {}\n+\n // RefExpr\n #[derive(Debug, Clone, Copy)]\n pub struct RefExpr<'a> {\n@@ -993,6 +1207,24 @@ impl<'a> AstNode<'a> for RefExpr<'a> {\n \n impl<'a> RefExpr<'a> {}\n \n+// RefPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct RefPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for RefPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            REF_PAT => Some(RefPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> RefPat<'a> {}\n+\n // ReferenceType\n #[derive(Debug, Clone, Copy)]\n pub struct ReferenceType<'a> {\n@@ -1055,6 +1287,24 @@ impl<'a> Root<'a> {\n     }\n }\n \n+// SlicePat\n+#[derive(Debug, Clone, Copy)]\n+pub struct SlicePat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for SlicePat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            SLICE_PAT => Some(SlicePat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> SlicePat<'a> {}\n+\n // SliceType\n #[derive(Debug, Clone, Copy)]\n pub struct SliceType<'a> {\n@@ -1137,6 +1387,24 @@ impl<'a> AstNode<'a> for StructLit<'a> {\n \n impl<'a> StructLit<'a> {}\n \n+// StructPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct StructPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for StructPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            STRUCT_PAT => Some(StructPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> StructPat<'a> {}\n+\n // TokenTree\n #[derive(Debug, Clone, Copy)]\n pub struct TokenTree<'a> {\n@@ -1211,6 +1479,42 @@ impl<'a> AstNode<'a> for TupleExpr<'a> {\n \n impl<'a> TupleExpr<'a> {}\n \n+// TuplePat\n+#[derive(Debug, Clone, Copy)]\n+pub struct TuplePat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for TuplePat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            TUPLE_PAT => Some(TuplePat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> TuplePat<'a> {}\n+\n+// TupleStructPat\n+#[derive(Debug, Clone, Copy)]\n+pub struct TupleStructPat<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for TupleStructPat<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            TUPLE_STRUCT_PAT => Some(TupleStructPat { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> TupleStructPat<'a> {}\n+\n // TupleType\n #[derive(Debug, Clone, Copy)]\n pub struct TupleType<'a> {"}, {"sha": "3a125ace680ba1a8f8596916d9210f938b7869ab", "filename": "crates/libsyntax2/src/grammar.ron", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -241,11 +241,16 @@ Grammar(\n                 [\"modules\", \"Module\"],\n             ]\n         ),\n-        \"FnDef\": ( traits: [\n-            \"NameOwner\",\n-            \"TypeParamsOwner\",\n-            \"AttrsOwner\",\n-        ] ),\n+        \"FnDef\": (\n+            traits: [\n+                \"NameOwner\",\n+                \"TypeParamsOwner\",\n+                \"AttrsOwner\",\n+            ],\n+            options: [\n+                [\"param_list\", \"ParamList\"]\n+            ],\n+        ),\n         \"StructDef\": (\n             traits: [\n                 \"NameOwner\",\n@@ -393,13 +398,52 @@ Grammar(\n             ],\n         ),\n \n+        \"RefPat\": (),\n+        \"BindPat\": ( traits: [\"NameOwner\"] ),\n+        \"PlaceholderPat\": (),\n+        \"PathPat\": (),\n+        \"StructPat\": (),\n+        \"FieldPatList\": (),\n+        \"TupleStructPat\": (),\n+        \"TuplePat\": (),\n+        \"SlicePat\": (),\n+        \"RangePat\": (),\n+\n+        \"Pat\": (\n+            enum: [\n+                \"RefPat\",\n+                \"BindPat\",\n+                \"PlaceholderPat\",\n+                \"PathPat\",\n+                \"StructPat\",\n+                \"FieldPatList\",\n+                \"TupleStructPat\",\n+                \"TuplePat\",\n+                \"SlicePat\",\n+                \"RangePat\",\n+            ],\n+        ),\n+\n         \"Name\": (),\n         \"NameRef\": (),\n         \"Attr\": ( options: [ [\"value\", \"TokenTree\"] ] ),\n         \"TokenTree\": (),\n         \"TypeParamList\": ( collections: [ [\"type_params\", \"TypeParam\" ] ]),\n-        \"TypeParam\": ( traits: [\"NameOwner\"]),\n+        \"TypeParam\": ( traits: [\"NameOwner\"] ),\n         \"WhereClause\": (),\n-        \"Block\": (),\n+        \"LetStmt\": ( options: [ [\"pat\", \"Pat\"] ]),\n+        \"Block\": (\n+            collections: [\n+                [\"let_stmts\", \"LetStmt\"],\n+            ]\n+        ),\n+        \"ParamList\": (\n+            collections: [\n+                [\"params\", \"Param\"]\n+            ]\n+        ),\n+        \"Param\": (\n+            options: [[\"pat\", \"Pat\"]],\n+        )\n     },\n )"}, {"sha": "7c6f7b63e8b74c06cac24ea547024425845382e0", "filename": "crates/libsyntax2/src/grammar/items/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac226021cfd26a9332b5971f3e05118d77822af5/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs?ref=ac226021cfd26a9332b5971f3e05118d77822af5", "patch": "@@ -115,7 +115,7 @@ pub(super) fn maybe_item(p: &mut Parser, flavor: ItemFlavor) -> MaybeItem {\n         // test unsafe_fn\n         // unsafe fn foo() {}\n         FN_KW => {\n-            function(p, flavor);\n+            fn_def(p, flavor);\n             FN_DEF\n         }\n \n@@ -227,7 +227,7 @@ fn extern_item_list(p: &mut Parser) {\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n-fn function(p: &mut Parser, flavor: ItemFlavor) {\n+fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     assert!(p.at(FN_KW));\n     p.bump();\n "}]}