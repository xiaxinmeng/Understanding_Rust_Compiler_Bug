{"sha": "6972f07510d93a82e2c8d1bdef3120c418c3ae08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NzJmMDc1MTBkOTNhODJlMmM4ZDFiZGVmMzEyMGM0MThjM2FlMDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T00:49:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T00:56:25Z"}, "message": "Make #fmt and #ifmt synonymous. Issue #855", "tree": {"sha": "ff8177a085b6078fabf21f5cdbe002df914b5d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff8177a085b6078fabf21f5cdbe002df914b5d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6972f07510d93a82e2c8d1bdef3120c418c3ae08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6972f07510d93a82e2c8d1bdef3120c418c3ae08", "html_url": "https://github.com/rust-lang/rust/commit/6972f07510d93a82e2c8d1bdef3120c418c3ae08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6972f07510d93a82e2c8d1bdef3120c418c3ae08/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc45eb785ad00de59a3cb26225d30f0fbc72b1c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc45eb785ad00de59a3cb26225d30f0fbc72b1c0", "html_url": "https://github.com/rust-lang/rust/commit/fc45eb785ad00de59a3cb26225d30f0fbc72b1c0"}], "stats": {"total": 764, "additions": 598, "deletions": 166}, "files": [{"sha": "8828bfb88f657e9388f0dea88bba14291df11645", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -63,7 +63,7 @@ mod syntax {\n         mod base;\n         mod expand;\n \n-        mod ifmt;\n+        mod fmt;\n         mod env;\n         mod simplext;\n         mod concat_idents;"}, {"sha": "fda7bb71dbf8c9fc228e8783e04386647d5e59bf", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -22,7 +22,9 @@ tag syntax_extension {\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n-    syntax_expanders.insert(~\"ifmt\", normal(ext::ifmt::expand_syntax_ext));\n+    syntax_expanders.insert(~\"fmt\", normal(ext::fmt::expand_syntax_ext));\n+    // FIXME: Transitional. Remove\n+    syntax_expanders.insert(~\"ifmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"env\", normal(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));"}, {"sha": "5e07c812236b197d0f00580e0307240d686b1984", "filename": "src/comp/syntax/ext/fmt.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -1,7 +1,7 @@\n \n \n /*\n- * The compiler code necessary to support the #ifmt extension. Eventually this\n+ * The compiler code necessary to support the #fmt extension. Eventually this\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n@@ -10,7 +10,7 @@ import std::str;\n import std::option;\n import std::option::none;\n import std::option::some;\n-import std::extifmt::ct::*;\n+import std::extfmt::ct::*;\n import base::*;\n import codemap::span;\n export expand_syntax_ext;\n@@ -22,15 +22,15 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n           ast::expr_vec(elts, _) { elts }\n           _ {\n             cx.span_fatal(\n-                sp, ~\"#ifmt requires arguments of the form `[...]`.\")\n+                sp, ~\"#fmt requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, ~\"#ifmt requires a format string\");\n+        cx.span_fatal(sp, ~\"#fmt requires a format string\");\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    ~\"first argument to #ifmt must be a \"\n+                    ~\"first argument to #fmt must be a \"\n                     + ~\"string literal.\");\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n@@ -106,8 +106,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             ret str::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n-            ret [~\"extifmt\", ~\"rt\", ident];\n-        } else { ret [~\"std\", ~\"extifmt\", ~\"rt\", ident]; }\n+            ret [~\"extfmt\", ~\"rt\", ident];\n+        } else { ret [~\"std\", ~\"extfmt\", ~\"rt\", ident]; }\n     }\n     fn make_rt_path_expr(cx: &ext_ctxt, sp: span,\n                          ident: &istr) -> @ast::expr {\n@@ -151,7 +151,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #ifmt conversion\"); }\n+              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n@@ -205,7 +205,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { ret false; }\n             }\n         }\n-        let unsupported = ~\"conversion not supported in #ifmt string\";\n+        let unsupported = ~\"conversion not supported in #fmt string\";\n         alt cnv.param {\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -217,14 +217,14 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"+ flag only valid in \" +\n-                                      ~\"signed #ifmt conversion\");\n+                                      ~\"signed #fmt conversion\");\n                 }\n               }\n               flag_space_for_sign. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"space flag only valid in \" +\n-                                      ~\"signed #ifmt conversions\");\n+                                      ~\"signed #fmt conversions\");\n                 }\n               }\n               flag_left_zero_pad. { }\n@@ -329,7 +329,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              ~\"not enough arguments to #ifmt \" +\n+                              ~\"not enough arguments to #fmt \" +\n                                   ~\"for the given format string\");\n             }\n             log \"Building conversion:\";", "previous_filename": "src/comp/syntax/ext/ifmt.rs"}, {"sha": "7f363b661da3d0407a1d03e341becfdb13bd4a84", "filename": "src/lib/extfmt.rs", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -0,0 +1,429 @@\n+\n+\n+/* The 'fmt' extension is modeled on the posix printf system.\n+ *\n+ * A posix conversion ostensibly looks like this:\n+ *\n+ * %[parameter][flags][width][.precision][length]type\n+ *\n+ * Given the different numeric type bestiary we have, we omit the 'length'\n+ * parameter and support slightly different conversions for 'type':\n+ *\n+ * %[parameter][flags][width][.precision]type\n+ *\n+ * we also only support translating-to-rust a tiny subset of the possible\n+ * combinations at the moment.\n+ */\n+import option::none;\n+import option::some;\n+\n+\n+/*\n+ * We have a 'ct' (compile-time) module that parses format strings into a\n+ * sequence of conversions. From those conversions AST fragments are built\n+ * that call into properly-typed functions in the 'rt' (run-time) module.\n+ * Each of those run-time conversion functions accepts another conversion\n+ * description that specifies how to format its output.\n+ *\n+ * The building of the AST is currently done in a module inside the compiler,\n+ * but should migrate over here as the plugin interface is defined.\n+ */\n+\n+// Functions used by the fmt extension at compile time\n+mod ct {\n+    tag signedness { signed; unsigned; }\n+    tag caseness { case_upper; case_lower; }\n+    tag ty {\n+        ty_bool;\n+        ty_str;\n+        ty_char;\n+        ty_int(signedness);\n+        ty_bits;\n+        ty_hex(caseness);\n+        ty_octal;\n+        // FIXME: More types\n+    }\n+    tag flag {\n+        flag_left_justify;\n+        flag_left_zero_pad;\n+        flag_space_for_sign;\n+        flag_sign_always;\n+        flag_alternate;\n+    }\n+    tag count {\n+        count_is(int);\n+        count_is_param(int);\n+        count_is_next_param;\n+        count_implied;\n+    }\n+\n+    // A formatted conversion from an expression to a string\n+    type conv =\n+        {param: option::t<int>,\n+         flags: [flag],\n+         width: count,\n+         precision: count,\n+         ty: ty};\n+\n+\n+    // A fragment of the output sequence\n+    tag piece { piece_string(istr); piece_conv(conv); }\n+    type error_fn = fn(&istr) -> ! ;\n+\n+    fn parse_fmt_string(s: &istr, error: error_fn) -> [piece] {\n+        let pieces: [piece] = [];\n+        let lim = str::byte_len(s);\n+        let buf = ~\"\";\n+        fn flush_buf(buf: &istr, pieces: &mutable [piece]) -> istr {\n+            if str::byte_len(buf) > 0u {\n+                let piece = piece_string(buf);\n+                pieces += [piece];\n+            }\n+            ret ~\"\";\n+        }\n+        let i = 0u;\n+        while i < lim {\n+            let curr = str::substr(s, i, 1u);\n+            if str::eq(curr, ~\"%\") {\n+                i += 1u;\n+                if i >= lim {\n+                    error(~\"unterminated conversion at end of string\");\n+                }\n+                let curr2 = str::substr(s, i, 1u);\n+                if str::eq(curr2, ~\"%\") {\n+                    i += 1u;\n+                } else {\n+                    buf = flush_buf(buf, pieces);\n+                    let rs = parse_conversion(s, i, lim, error);\n+                    pieces += [rs.piece];\n+                    i = rs.next;\n+                }\n+            } else { buf += curr; i += 1u; }\n+        }\n+        buf = flush_buf(buf, pieces);\n+        ret pieces;\n+    }\n+    fn peek_num(s: &istr, i: uint, lim: uint) ->\n+       option::t<{num: uint, next: uint}> {\n+        if i >= lim { ret none; }\n+        let c = s[i];\n+        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n+        let n = c - ('0' as u8) as uint;\n+        ret alt peek_num(s, i + 1u, lim) {\n+              none. { some({num: n, next: i + 1u}) }\n+              some(next) {\n+                let m = next.num;\n+                let j = next.next;\n+                some({num: n * 10u + m, next: j})\n+              }\n+            };\n+    }\n+    fn parse_conversion(s: &istr, i: uint, lim: uint, error: error_fn) ->\n+       {piece: piece, next: uint} {\n+        let parm = parse_parameter(s, i, lim);\n+        let flags = parse_flags(s, parm.next, lim);\n+        let width = parse_count(s, flags.next, lim);\n+        let prec = parse_precision(s, width.next, lim);\n+        let ty = parse_type(s, prec.next, lim, error);\n+        ret {piece:\n+                 piece_conv({param: parm.param,\n+                             flags: flags.flags,\n+                             width: width.count,\n+                             precision: prec.count,\n+                             ty: ty.ty}),\n+             next: ty.next};\n+    }\n+    fn parse_parameter(s: &istr, i: uint, lim: uint) ->\n+       {param: option::t<int>, next: uint} {\n+        if i >= lim { ret {param: none, next: i}; }\n+        let num = peek_num(s, i, lim);\n+        ret alt num {\n+              none. { {param: none, next: i} }\n+              some(t) {\n+                let n = t.num;\n+                let j = t.next;\n+                if j < lim && s[j] == '$' as u8 {\n+                    {param: some(n as int), next: j + 1u}\n+                } else { {param: none, next: i} }\n+              }\n+            };\n+    }\n+    fn parse_flags(s: &istr, i: uint, lim: uint) ->\n+       {flags: [flag], next: uint} {\n+        let noflags: [flag] = [];\n+        if i >= lim { ret {flags: noflags, next: i}; }\n+\n+        // FIXME: This recursion generates illegal instructions if the return\n+        // value isn't boxed. Only started happening after the ivec conversion\n+        fn more_(f: flag, s: &istr, i: uint, lim: uint) ->\n+           @{flags: [flag], next: uint} {\n+            let next = parse_flags(s, i + 1u, lim);\n+            let rest = next.flags;\n+            let j = next.next;\n+            let curr: [flag] = [f];\n+            ret @{flags: curr + rest, next: j};\n+        }\n+        let more = bind more_(_, s, i, lim);\n+        let f = s[i];\n+        ret if f == '-' as u8 {\n+                *more(flag_left_justify)\n+            } else if f == '0' as u8 {\n+                *more(flag_left_zero_pad)\n+            } else if f == ' ' as u8 {\n+                *more(flag_space_for_sign)\n+            } else if f == '+' as u8 {\n+                *more(flag_sign_always)\n+            } else if f == '#' as u8 {\n+                *more(flag_alternate)\n+            } else { {flags: noflags, next: i} };\n+    }\n+    fn parse_count(s: &istr, i: uint,\n+                   lim: uint) -> {count: count, next: uint} {\n+        ret if i >= lim {\n+                {count: count_implied, next: i}\n+            } else if s[i] == '*' as u8 {\n+                let param = parse_parameter(s, i + 1u, lim);\n+                let j = param.next;\n+                alt param.param {\n+                  none. { {count: count_is_next_param, next: j} }\n+                  some(n) { {count: count_is_param(n), next: j} }\n+                }\n+            } else {\n+                let num = peek_num(s, i, lim);\n+                alt num {\n+                  none. { {count: count_implied, next: i} }\n+                  some(num) {\n+                    {count: count_is(num.num as int), next: num.next}\n+                  }\n+                }\n+            };\n+    }\n+    fn parse_precision(s: &istr, i: uint, lim: uint) ->\n+       {count: count, next: uint} {\n+        ret if i >= lim {\n+                {count: count_implied, next: i}\n+            } else if s[i] == '.' as u8 {\n+                let count = parse_count(s, i + 1u, lim);\n+\n+\n+                // If there were no digits specified, i.e. the precision\n+                // was \".\", then the precision is 0\n+                alt count.count {\n+                  count_implied. { {count: count_is(0), next: count.next} }\n+                  _ { count }\n+                }\n+            } else { {count: count_implied, next: i} };\n+    }\n+    fn parse_type(s: &istr, i: uint, lim: uint, error: error_fn) ->\n+       {ty: ty, next: uint} {\n+        if i >= lim { error(~\"missing type in conversion\"); }\n+        let tstr = str::substr(s, i, 1u);\n+        // TODO: Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        let t =\n+            if str::eq(tstr, ~\"b\") {\n+                ty_bool\n+            } else if str::eq(tstr, ~\"s\") {\n+                ty_str\n+            } else if str::eq(tstr, ~\"c\") {\n+                ty_char\n+            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n+                ty_int(signed)\n+            } else if str::eq(tstr, ~\"u\") {\n+                ty_int(unsigned)\n+            } else if str::eq(tstr, ~\"x\") {\n+                ty_hex(case_lower)\n+            } else if str::eq(tstr, ~\"X\") {\n+                ty_hex(case_upper)\n+            } else if str::eq(tstr, ~\"t\") {\n+                ty_bits\n+            } else if str::eq(tstr, ~\"o\") {\n+                ty_octal\n+            } else { error(~\"unknown type in conversion: \" + tstr) };\n+        ret {ty: t, next: i + 1u};\n+    }\n+}\n+\n+\n+// Functions used by the fmt extension at runtime. For now there are a lot of\n+// decisions made a runtime. If it proves worthwhile then some of these\n+// conditions can be evaluated at compile-time. For now though it's cleaner to\n+// implement it this way, I think.\n+mod rt {\n+    tag flag {\n+        flag_left_justify;\n+        flag_left_zero_pad;\n+        flag_space_for_sign;\n+        flag_sign_always;\n+        flag_alternate;\n+\n+\n+        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n+        // which have some difficulty typechecking currently. See\n+        // comments in front::extfmt::make_flags\n+        flag_none;\n+    }\n+    tag count { count_is(int); count_implied; }\n+    tag ty { ty_default; ty_bits; ty_hex_upper; ty_hex_lower; ty_octal; }\n+\n+    // FIXME: May not want to use a vector here for flags;\n+    // instead just use a bool per flag\n+    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n+\n+    fn conv_int(cv: &conv, i: int) -> istr {\n+        let radix = 10u;\n+        let prec = get_int_precision(cv);\n+        let s = int_to_str_prec(i, radix, prec);\n+        if 0 <= i {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                s = ~\"+\" + s;\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                s = ~\" \" + s;\n+            }\n+        }\n+        ret pad(cv, s, pad_signed);\n+    }\n+    fn conv_uint(cv: &conv, u: uint) -> istr {\n+        let prec = get_int_precision(cv);\n+        let rs =\n+            alt cv.ty {\n+              ty_default. { uint_to_str_prec(u, 10u, prec) }\n+              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n+              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n+              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n+              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n+            };\n+        ret pad(cv, rs, pad_unsigned);\n+    }\n+    fn conv_bool(cv: &conv, b: bool) -> istr {\n+        let s = if b { ~\"true\" } else { ~\"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+\n+        ret conv_str(cv, s);\n+    }\n+    fn conv_char(cv: &conv, c: char) -> istr {\n+        ret pad(cv, str::from_char(c), pad_nozero);\n+    }\n+    fn conv_str(cv: &conv, s: &istr) -> istr {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+\n+        // FIXME: substr works on bytes, not chars!\n+        let unpadded =\n+            alt cv.precision {\n+              count_implied. { s }\n+              count_is(max) {\n+                if max as uint < str::char_len(s) {\n+                    str::substr(s, 0u, max as uint)\n+                } else { s }\n+              }\n+            };\n+        ret pad(cv, unpadded, pad_nozero);\n+    }\n+\n+    // Convert an int to string with minimum number of digits. If precision is\n+    // 0 and num is 0 then the result is the empty string.\n+    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> istr {\n+        ret if num < 0 {\n+                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+            } else { uint_to_str_prec(num as uint, radix, prec) };\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> istr {\n+        ret if prec == 0u && num == 0u {\n+                ~\"\"\n+            } else {\n+                let s = uint::to_str(num, radix);\n+                let len = str::char_len(s);\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str_init_elt('0', diff);\n+                    pad + s\n+                } else { s }\n+            };\n+    }\n+    fn get_int_precision(cv: &conv) -> uint {\n+        ret alt cv.precision {\n+              count_is(c) { c as uint }\n+              count_implied. { 1u }\n+            };\n+    }\n+\n+    // FIXME: This might be useful in str: but needs to be utf8 safe first\n+    fn str_init_elt(c: char, n_elts: uint) -> istr {\n+        let svec = vec::init_elt::<u8>(c as u8, n_elts);\n+\n+        ret str::unsafe_from_bytes(svec);\n+    }\n+    tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n+    fn pad(cv: &conv, s: &istr, mode: pad_mode) -> istr {\n+        let uwidth;\n+        alt cv.width {\n+          count_implied. { ret s; }\n+          count_is(width) {\n+            // FIXME: Maybe width should be uint\n+\n+            uwidth = width as uint;\n+          }\n+        }\n+        let strlen = str::char_len(s);\n+        if uwidth <= strlen { ret s; }\n+        let padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            let padstr = str_init_elt(padchar, diff);\n+            ret s + padstr;\n+        }\n+        let might_zero_pad = false;\n+        let signed = false;\n+        alt mode {\n+          pad_nozero. {\n+            // fallthrough\n+\n+          }\n+          pad_signed. { might_zero_pad = true; signed = true; }\n+          pad_unsigned. { might_zero_pad = true; }\n+        }\n+        fn have_precision(cv: &conv) -> bool {\n+            ret alt cv.precision { count_implied. { false } _ { true } };\n+        }\n+        let zero_padding = false;\n+        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+               !have_precision(cv) {\n+            padchar = '0';\n+            zero_padding = true;\n+        }\n+        let padstr = str_init_elt(padchar, diff);\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding && str::byte_len(s) > 0u {\n+            let head = s[0];\n+            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n+                let headstr = str::unsafe_from_bytes([head]);\n+                let bytelen = str::byte_len(s);\n+                let numpart = str::substr(s, 1u, bytelen - 1u);\n+                ret headstr + padstr + numpart;\n+            }\n+        }\n+        ret padstr + s;\n+    }\n+    fn have_flag(flags: &[flag], f: flag) -> bool {\n+        for candidate: flag in flags { if candidate == f { ret true; } }\n+        ret false;\n+    }\n+}\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "78ecf62e174823cd60c8b6867fd497650969d6c8", "filename": "src/lib/extifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fextifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fextifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextifmt.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -1,4 +1,4 @@\n-\n+// FIXME: Transitional. Remove me\n \n /* The 'fmt' extension is modeled on the posix printf system.\n  *"}, {"sha": "2159f46159d40f7e240b5472ff622859342116b8", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -85,6 +85,7 @@ mod sort;\n mod sha1;\n mod ebml;\n mod ufind;\n+mod extfmt;\n mod extifmt;\n mod box;\n mod getopts;"}, {"sha": "1dfce7e89c40b050c9dbd7370e0a8102cc8eeaff", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:only valid in signed #ifmt conversion\n+// error-pattern:only valid in signed #fmt conversion\n \n fn main() {\n     // Can't use a sign on unsigned conversions"}, {"sha": "2866c569ff1bb22c4f082d7a566201466af8805f", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:only valid in signed #ifmt conversion\n+// error-pattern:only valid in signed #fmt conversion\n \n fn main() {\n     // Can't use a space on unsigned conversions"}, {"sha": "77ae154085fe9e5d4fadb337988b981922b389d7", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 149, "deletions": 149, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6972f07510d93a82e2c8d1bdef3120c418c3ae08/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=6972f07510d93a82e2c8d1bdef3120c418c3ae08", "patch": "@@ -8,10 +8,10 @@ fn test(actual: &istr, expected: &istr) {\n }\n \n fn main() {\n-    test(#ifmt[~\"hello %d friends and %s things\", 10, ~\"formatted\"],\n+    test(#fmt[~\"hello %d friends and %s things\", 10, ~\"formatted\"],\n          ~\"hello 10 friends and formatted things\");\n \n-    test(#ifmt[~\"test\"], ~\"test\");\n+    test(#fmt[~\"test\"], ~\"test\");\n \n     // a quadratic optimization in LLVM (jump-threading) makes this test a\n     // bit slow to compile unless we break it up\n@@ -26,192 +26,192 @@ fn main() {\n fn part1() {\n     // Simple tests for types\n \n-    test(#ifmt[~\"%d\", 1], ~\"1\");\n-    test(#ifmt[~\"%i\", 2], ~\"2\");\n-    test(#ifmt[~\"%i\", -1], ~\"-1\");\n-    test(#ifmt[~\"%u\", 10u], ~\"10\");\n-    test(#ifmt[~\"%s\", ~\"test\"], ~\"test\");\n-    test(#ifmt[~\"%b\", true], ~\"true\");\n-    test(#ifmt[~\"%b\", false], ~\"false\");\n-    test(#ifmt[~\"%c\", 'A'], ~\"A\");\n-    test(#ifmt[~\"%x\", 0xff_u], ~\"ff\");\n-    test(#ifmt[~\"%X\", 0x12ab_u], ~\"12AB\");\n-    test(#ifmt[~\"%o\", 10u], ~\"12\");\n-    test(#ifmt[~\"%t\", 0b11010101_u], ~\"11010101\");\n+    test(#fmt[~\"%d\", 1], ~\"1\");\n+    test(#fmt[~\"%i\", 2], ~\"2\");\n+    test(#fmt[~\"%i\", -1], ~\"-1\");\n+    test(#fmt[~\"%u\", 10u], ~\"10\");\n+    test(#fmt[~\"%s\", ~\"test\"], ~\"test\");\n+    test(#fmt[~\"%b\", true], ~\"true\");\n+    test(#fmt[~\"%b\", false], ~\"false\");\n+    test(#fmt[~\"%c\", 'A'], ~\"A\");\n+    test(#fmt[~\"%x\", 0xff_u], ~\"ff\");\n+    test(#fmt[~\"%X\", 0x12ab_u], ~\"12AB\");\n+    test(#fmt[~\"%o\", 10u], ~\"12\");\n+    test(#fmt[~\"%t\", 0b11010101_u], ~\"11010101\");\n     // 32-bit limits\n \n-    test(#ifmt[~\"%i\", -2147483648], ~\"-2147483648\");\n-    test(#ifmt[~\"%i\", 2147483647], ~\"2147483647\");\n-    test(#ifmt[~\"%u\", 4294967295u], ~\"4294967295\");\n-    test(#ifmt[~\"%x\", 0xffffffff_u], ~\"ffffffff\");\n-    test(#ifmt[~\"%o\", 0xffffffff_u], ~\"37777777777\");\n-    test(#ifmt[~\"%t\", 0xffffffff_u], ~\"11111111111111111111111111111111\");\n+    test(#fmt[~\"%i\", -2147483648], ~\"-2147483648\");\n+    test(#fmt[~\"%i\", 2147483647], ~\"2147483647\");\n+    test(#fmt[~\"%u\", 4294967295u], ~\"4294967295\");\n+    test(#fmt[~\"%x\", 0xffffffff_u], ~\"ffffffff\");\n+    test(#fmt[~\"%o\", 0xffffffff_u], ~\"37777777777\");\n+    test(#fmt[~\"%t\", 0xffffffff_u], ~\"11111111111111111111111111111111\");\n }\n fn part2() {\n     // Widths\n \n-    test(#ifmt[~\"%1d\", 500], ~\"500\");\n-    test(#ifmt[~\"%10d\", 500], ~\"       500\");\n-    test(#ifmt[~\"%10d\", -500], ~\"      -500\");\n-    test(#ifmt[~\"%10u\", 500u], ~\"       500\");\n-    test(#ifmt[~\"%10s\", ~\"test\"], ~\"      test\");\n-    test(#ifmt[~\"%10b\", true], ~\"      true\");\n-    test(#ifmt[~\"%10x\", 0xff_u], ~\"        ff\");\n-    test(#ifmt[~\"%10X\", 0xff_u], ~\"        FF\");\n-    test(#ifmt[~\"%10o\", 10u], ~\"        12\");\n-    test(#ifmt[~\"%10t\", 0xff_u], ~\"  11111111\");\n-    test(#ifmt[~\"%10c\", 'A'], ~\"         A\");\n+    test(#fmt[~\"%1d\", 500], ~\"500\");\n+    test(#fmt[~\"%10d\", 500], ~\"       500\");\n+    test(#fmt[~\"%10d\", -500], ~\"      -500\");\n+    test(#fmt[~\"%10u\", 500u], ~\"       500\");\n+    test(#fmt[~\"%10s\", ~\"test\"], ~\"      test\");\n+    test(#fmt[~\"%10b\", true], ~\"      true\");\n+    test(#fmt[~\"%10x\", 0xff_u], ~\"        ff\");\n+    test(#fmt[~\"%10X\", 0xff_u], ~\"        FF\");\n+    test(#fmt[~\"%10o\", 10u], ~\"        12\");\n+    test(#fmt[~\"%10t\", 0xff_u], ~\"  11111111\");\n+    test(#fmt[~\"%10c\", 'A'], ~\"         A\");\n     // Left justify\n \n-    test(#ifmt[~\"%-10d\", 500], ~\"500       \");\n-    test(#ifmt[~\"%-10d\", -500], ~\"-500      \");\n-    test(#ifmt[~\"%-10u\", 500u], ~\"500       \");\n-    test(#ifmt[~\"%-10s\", ~\"test\"], ~\"test      \");\n-    test(#ifmt[~\"%-10b\", true], ~\"true      \");\n-    test(#ifmt[~\"%-10x\", 0xff_u], ~\"ff        \");\n-    test(#ifmt[~\"%-10X\", 0xff_u], ~\"FF        \");\n-    test(#ifmt[~\"%-10o\", 10u], ~\"12        \");\n-    test(#ifmt[~\"%-10t\", 0xff_u], ~\"11111111  \");\n-    test(#ifmt[~\"%-10c\", 'A'], ~\"A         \");\n+    test(#fmt[~\"%-10d\", 500], ~\"500       \");\n+    test(#fmt[~\"%-10d\", -500], ~\"-500      \");\n+    test(#fmt[~\"%-10u\", 500u], ~\"500       \");\n+    test(#fmt[~\"%-10s\", ~\"test\"], ~\"test      \");\n+    test(#fmt[~\"%-10b\", true], ~\"true      \");\n+    test(#fmt[~\"%-10x\", 0xff_u], ~\"ff        \");\n+    test(#fmt[~\"%-10X\", 0xff_u], ~\"FF        \");\n+    test(#fmt[~\"%-10o\", 10u], ~\"12        \");\n+    test(#fmt[~\"%-10t\", 0xff_u], ~\"11111111  \");\n+    test(#fmt[~\"%-10c\", 'A'], ~\"A         \");\n }\n \n fn part3() {\n     // Precision\n \n-    test(#ifmt[~\"%.d\", 0], ~\"\");\n-    test(#ifmt[~\"%.u\", 0u], ~\"\");\n-    test(#ifmt[~\"%.x\", 0u], ~\"\");\n-    test(#ifmt[~\"%.t\", 0u], ~\"\");\n-    test(#ifmt[~\"%.d\", 10], ~\"10\");\n-    test(#ifmt[~\"%.d\", -10], ~\"-10\");\n-    test(#ifmt[~\"%.u\", 10u], ~\"10\");\n-    test(#ifmt[~\"%.s\", ~\"test\"], ~\"\");\n-    test(#ifmt[~\"%.x\", 127u], ~\"7f\");\n-    test(#ifmt[~\"%.o\", 10u], ~\"12\");\n-    test(#ifmt[~\"%.t\", 3u], ~\"11\");\n-    test(#ifmt[~\"%.c\", 'A'], ~\"A\");\n-    test(#ifmt[~\"%.0d\", 0], ~\"\");\n-    test(#ifmt[~\"%.0u\", 0u], ~\"\");\n-    test(#ifmt[~\"%.0x\", 0u], ~\"\");\n-    test(#ifmt[~\"%.0t\", 0u], ~\"\");\n-    test(#ifmt[~\"%.0d\", 10], ~\"10\");\n-    test(#ifmt[~\"%.0d\", -10], ~\"-10\");\n-    test(#ifmt[~\"%.0u\", 10u], ~\"10\");\n-    test(#ifmt[~\"%.0s\", ~\"test\"], ~\"\");\n-    test(#ifmt[~\"%.0x\", 127u], ~\"7f\");\n-    test(#ifmt[~\"%.0o\", 10u], ~\"12\");\n-    test(#ifmt[~\"%.0t\", 3u], ~\"11\");\n-    test(#ifmt[~\"%.0c\", 'A'], ~\"A\");\n-    test(#ifmt[~\"%.1d\", 0], ~\"0\");\n-    test(#ifmt[~\"%.1u\", 0u], ~\"0\");\n-    test(#ifmt[~\"%.1x\", 0u], ~\"0\");\n-    test(#ifmt[~\"%.1t\", 0u], ~\"0\");\n-    test(#ifmt[~\"%.1d\", 10], ~\"10\");\n-    test(#ifmt[~\"%.1d\", -10], ~\"-10\");\n-    test(#ifmt[~\"%.1u\", 10u], ~\"10\");\n-    test(#ifmt[~\"%.1s\", ~\"test\"], ~\"t\");\n-    test(#ifmt[~\"%.1x\", 127u], ~\"7f\");\n-    test(#ifmt[~\"%.1o\", 10u], ~\"12\");\n-    test(#ifmt[~\"%.1t\", 3u], ~\"11\");\n-    test(#ifmt[~\"%.1c\", 'A'], ~\"A\");\n+    test(#fmt[~\"%.d\", 0], ~\"\");\n+    test(#fmt[~\"%.u\", 0u], ~\"\");\n+    test(#fmt[~\"%.x\", 0u], ~\"\");\n+    test(#fmt[~\"%.t\", 0u], ~\"\");\n+    test(#fmt[~\"%.d\", 10], ~\"10\");\n+    test(#fmt[~\"%.d\", -10], ~\"-10\");\n+    test(#fmt[~\"%.u\", 10u], ~\"10\");\n+    test(#fmt[~\"%.s\", ~\"test\"], ~\"\");\n+    test(#fmt[~\"%.x\", 127u], ~\"7f\");\n+    test(#fmt[~\"%.o\", 10u], ~\"12\");\n+    test(#fmt[~\"%.t\", 3u], ~\"11\");\n+    test(#fmt[~\"%.c\", 'A'], ~\"A\");\n+    test(#fmt[~\"%.0d\", 0], ~\"\");\n+    test(#fmt[~\"%.0u\", 0u], ~\"\");\n+    test(#fmt[~\"%.0x\", 0u], ~\"\");\n+    test(#fmt[~\"%.0t\", 0u], ~\"\");\n+    test(#fmt[~\"%.0d\", 10], ~\"10\");\n+    test(#fmt[~\"%.0d\", -10], ~\"-10\");\n+    test(#fmt[~\"%.0u\", 10u], ~\"10\");\n+    test(#fmt[~\"%.0s\", ~\"test\"], ~\"\");\n+    test(#fmt[~\"%.0x\", 127u], ~\"7f\");\n+    test(#fmt[~\"%.0o\", 10u], ~\"12\");\n+    test(#fmt[~\"%.0t\", 3u], ~\"11\");\n+    test(#fmt[~\"%.0c\", 'A'], ~\"A\");\n+    test(#fmt[~\"%.1d\", 0], ~\"0\");\n+    test(#fmt[~\"%.1u\", 0u], ~\"0\");\n+    test(#fmt[~\"%.1x\", 0u], ~\"0\");\n+    test(#fmt[~\"%.1t\", 0u], ~\"0\");\n+    test(#fmt[~\"%.1d\", 10], ~\"10\");\n+    test(#fmt[~\"%.1d\", -10], ~\"-10\");\n+    test(#fmt[~\"%.1u\", 10u], ~\"10\");\n+    test(#fmt[~\"%.1s\", ~\"test\"], ~\"t\");\n+    test(#fmt[~\"%.1x\", 127u], ~\"7f\");\n+    test(#fmt[~\"%.1o\", 10u], ~\"12\");\n+    test(#fmt[~\"%.1t\", 3u], ~\"11\");\n+    test(#fmt[~\"%.1c\", 'A'], ~\"A\");\n }\n fn part4() {\n-    test(#ifmt[~\"%.5d\", 0], ~\"00000\");\n-    test(#ifmt[~\"%.5u\", 0u], ~\"00000\");\n-    test(#ifmt[~\"%.5x\", 0u], ~\"00000\");\n-    test(#ifmt[~\"%.5t\", 0u], ~\"00000\");\n-    test(#ifmt[~\"%.5d\", 10], ~\"00010\");\n-    test(#ifmt[~\"%.5d\", -10], ~\"-00010\");\n-    test(#ifmt[~\"%.5u\", 10u], ~\"00010\");\n-    test(#ifmt[~\"%.5s\", ~\"test\"], ~\"test\");\n-    test(#ifmt[~\"%.5x\", 127u], ~\"0007f\");\n-    test(#ifmt[~\"%.5o\", 10u], ~\"00012\");\n-    test(#ifmt[~\"%.5t\", 3u], ~\"00011\");\n-    test(#ifmt[~\"%.5c\", 'A'], ~\"A\");\n+    test(#fmt[~\"%.5d\", 0], ~\"00000\");\n+    test(#fmt[~\"%.5u\", 0u], ~\"00000\");\n+    test(#fmt[~\"%.5x\", 0u], ~\"00000\");\n+    test(#fmt[~\"%.5t\", 0u], ~\"00000\");\n+    test(#fmt[~\"%.5d\", 10], ~\"00010\");\n+    test(#fmt[~\"%.5d\", -10], ~\"-00010\");\n+    test(#fmt[~\"%.5u\", 10u], ~\"00010\");\n+    test(#fmt[~\"%.5s\", ~\"test\"], ~\"test\");\n+    test(#fmt[~\"%.5x\", 127u], ~\"0007f\");\n+    test(#fmt[~\"%.5o\", 10u], ~\"00012\");\n+    test(#fmt[~\"%.5t\", 3u], ~\"00011\");\n+    test(#fmt[~\"%.5c\", 'A'], ~\"A\");\n     // Bool precision. I'm not sure if it's good or bad to have bool\n     // conversions support precision - it's not standard printf so we\n     // can do whatever. For now I'm making it behave the same as string\n     // conversions.\n \n-    test(#ifmt[~\"%.b\", true], ~\"\");\n-    test(#ifmt[~\"%.0b\", true], ~\"\");\n-    test(#ifmt[~\"%.1b\", true], ~\"t\");\n+    test(#fmt[~\"%.b\", true], ~\"\");\n+    test(#fmt[~\"%.0b\", true], ~\"\");\n+    test(#fmt[~\"%.1b\", true], ~\"t\");\n }\n \n fn part5() {\n     // Explicit + sign. Only for signed conversions\n \n-    test(#ifmt[~\"%+d\", 0], ~\"+0\");\n-    test(#ifmt[~\"%+d\", 1], ~\"+1\");\n-    test(#ifmt[~\"%+d\", -1], ~\"-1\");\n+    test(#fmt[~\"%+d\", 0], ~\"+0\");\n+    test(#fmt[~\"%+d\", 1], ~\"+1\");\n+    test(#fmt[~\"%+d\", -1], ~\"-1\");\n     // Leave space for sign\n \n-    test(#ifmt[~\"% d\", 0], ~\" 0\");\n-    test(#ifmt[~\"% d\", 1], ~\" 1\");\n-    test(#ifmt[~\"% d\", -1], ~\"-1\");\n+    test(#fmt[~\"% d\", 0], ~\" 0\");\n+    test(#fmt[~\"% d\", 1], ~\" 1\");\n+    test(#fmt[~\"% d\", -1], ~\"-1\");\n     // Plus overrides space\n \n-    test(#ifmt[~\"% +d\", 0], ~\"+0\");\n-    test(#ifmt[~\"%+ d\", 0], ~\"+0\");\n+    test(#fmt[~\"% +d\", 0], ~\"+0\");\n+    test(#fmt[~\"%+ d\", 0], ~\"+0\");\n     // 0-padding\n \n-    test(#ifmt[~\"%05d\", 0], ~\"00000\");\n-    test(#ifmt[~\"%05d\", 1], ~\"00001\");\n-    test(#ifmt[~\"%05d\", -1], ~\"-0001\");\n-    test(#ifmt[~\"%05u\", 1u], ~\"00001\");\n-    test(#ifmt[~\"%05x\", 127u], ~\"0007f\");\n-    test(#ifmt[~\"%05X\", 127u], ~\"0007F\");\n-    test(#ifmt[~\"%05o\", 10u], ~\"00012\");\n-    test(#ifmt[~\"%05t\", 3u], ~\"00011\");\n+    test(#fmt[~\"%05d\", 0], ~\"00000\");\n+    test(#fmt[~\"%05d\", 1], ~\"00001\");\n+    test(#fmt[~\"%05d\", -1], ~\"-0001\");\n+    test(#fmt[~\"%05u\", 1u], ~\"00001\");\n+    test(#fmt[~\"%05x\", 127u], ~\"0007f\");\n+    test(#fmt[~\"%05X\", 127u], ~\"0007F\");\n+    test(#fmt[~\"%05o\", 10u], ~\"00012\");\n+    test(#fmt[~\"%05t\", 3u], ~\"00011\");\n     // 0-padding a string is undefined but glibc does this:\n \n-    test(#ifmt[~\"%05s\", ~\"test\"], ~\" test\");\n-    test(#ifmt[~\"%05c\", 'A'], ~\"    A\");\n-    test(#ifmt[~\"%05b\", true], ~\" true\");\n+    test(#fmt[~\"%05s\", ~\"test\"], ~\" test\");\n+    test(#fmt[~\"%05c\", 'A'], ~\"    A\");\n+    test(#fmt[~\"%05b\", true], ~\" true\");\n     // Left-justify overrides 0-padding\n \n-    test(#ifmt[~\"%-05d\", 0], ~\"0    \");\n-    test(#ifmt[~\"%-05d\", 1], ~\"1    \");\n-    test(#ifmt[~\"%-05d\", -1], ~\"-1   \");\n-    test(#ifmt[~\"%-05u\", 1u], ~\"1    \");\n-    test(#ifmt[~\"%-05x\", 127u], ~\"7f   \");\n-    test(#ifmt[~\"%-05X\", 127u], ~\"7F   \");\n-    test(#ifmt[~\"%-05o\", 10u], ~\"12   \");\n-    test(#ifmt[~\"%-05t\", 3u], ~\"11   \");\n-    test(#ifmt[~\"%-05s\", ~\"test\"], ~\"test \");\n-    test(#ifmt[~\"%-05c\", 'A'], ~\"A    \");\n-    test(#ifmt[~\"%-05b\", true], ~\"true \");\n+    test(#fmt[~\"%-05d\", 0], ~\"0    \");\n+    test(#fmt[~\"%-05d\", 1], ~\"1    \");\n+    test(#fmt[~\"%-05d\", -1], ~\"-1   \");\n+    test(#fmt[~\"%-05u\", 1u], ~\"1    \");\n+    test(#fmt[~\"%-05x\", 127u], ~\"7f   \");\n+    test(#fmt[~\"%-05X\", 127u], ~\"7F   \");\n+    test(#fmt[~\"%-05o\", 10u], ~\"12   \");\n+    test(#fmt[~\"%-05t\", 3u], ~\"11   \");\n+    test(#fmt[~\"%-05s\", ~\"test\"], ~\"test \");\n+    test(#fmt[~\"%-05c\", 'A'], ~\"A    \");\n+    test(#fmt[~\"%-05b\", true], ~\"true \");\n }\n fn part6() {\n     // Precision overrides 0-padding\n \n-    test(#ifmt[~\"%06.5d\", 0], ~\" 00000\");\n-    test(#ifmt[~\"%06.5u\", 0u], ~\" 00000\");\n-    test(#ifmt[~\"%06.5x\", 0u], ~\" 00000\");\n-    test(#ifmt[~\"%06.5d\", 10], ~\" 00010\");\n-    test(#ifmt[~\"%06.5d\", -10], ~\"-00010\");\n-    test(#ifmt[~\"%06.5u\", 10u], ~\" 00010\");\n-    test(#ifmt[~\"%06.5s\", ~\"test\"], ~\"  test\");\n-    test(#ifmt[~\"%06.5c\", 'A'], ~\"     A\");\n-    test(#ifmt[~\"%06.5x\", 127u], ~\" 0007f\");\n-    test(#ifmt[~\"%06.5X\", 127u], ~\" 0007F\");\n-    test(#ifmt[~\"%06.5o\", 10u], ~\" 00012\");\n+    test(#fmt[~\"%06.5d\", 0], ~\" 00000\");\n+    test(#fmt[~\"%06.5u\", 0u], ~\" 00000\");\n+    test(#fmt[~\"%06.5x\", 0u], ~\" 00000\");\n+    test(#fmt[~\"%06.5d\", 10], ~\" 00010\");\n+    test(#fmt[~\"%06.5d\", -10], ~\"-00010\");\n+    test(#fmt[~\"%06.5u\", 10u], ~\" 00010\");\n+    test(#fmt[~\"%06.5s\", ~\"test\"], ~\"  test\");\n+    test(#fmt[~\"%06.5c\", 'A'], ~\"     A\");\n+    test(#fmt[~\"%06.5x\", 127u], ~\" 0007f\");\n+    test(#fmt[~\"%06.5X\", 127u], ~\" 0007F\");\n+    test(#fmt[~\"%06.5o\", 10u], ~\" 00012\");\n     // Signed combinations\n \n-    test(#ifmt[~\"% 5d\", 1], ~\"    1\");\n-    test(#ifmt[~\"% 5d\", -1], ~\"   -1\");\n-    test(#ifmt[~\"%+5d\", 1], ~\"   +1\");\n-    test(#ifmt[~\"%+5d\", -1], ~\"   -1\");\n-    test(#ifmt[~\"% 05d\", 1], ~\" 0001\");\n-    test(#ifmt[~\"% 05d\", -1], ~\"-0001\");\n-    test(#ifmt[~\"%+05d\", 1], ~\"+0001\");\n-    test(#ifmt[~\"%+05d\", -1], ~\"-0001\");\n-    test(#ifmt[~\"%- 5d\", 1], ~\" 1   \");\n-    test(#ifmt[~\"%- 5d\", -1], ~\"-1   \");\n-    test(#ifmt[~\"%-+5d\", 1], ~\"+1   \");\n-    test(#ifmt[~\"%-+5d\", -1], ~\"-1   \");\n-    test(#ifmt[~\"%- 05d\", 1], ~\" 1   \");\n-    test(#ifmt[~\"%- 05d\", -1], ~\"-1   \");\n-    test(#ifmt[~\"%-+05d\", 1], ~\"+1   \");\n-    test(#ifmt[~\"%-+05d\", -1], ~\"-1   \");\n+    test(#fmt[~\"% 5d\", 1], ~\"    1\");\n+    test(#fmt[~\"% 5d\", -1], ~\"   -1\");\n+    test(#fmt[~\"%+5d\", 1], ~\"   +1\");\n+    test(#fmt[~\"%+5d\", -1], ~\"   -1\");\n+    test(#fmt[~\"% 05d\", 1], ~\" 0001\");\n+    test(#fmt[~\"% 05d\", -1], ~\"-0001\");\n+    test(#fmt[~\"%+05d\", 1], ~\"+0001\");\n+    test(#fmt[~\"%+05d\", -1], ~\"-0001\");\n+    test(#fmt[~\"%- 5d\", 1], ~\" 1   \");\n+    test(#fmt[~\"%- 5d\", -1], ~\"-1   \");\n+    test(#fmt[~\"%-+5d\", 1], ~\"+1   \");\n+    test(#fmt[~\"%-+5d\", -1], ~\"-1   \");\n+    test(#fmt[~\"%- 05d\", 1], ~\" 1   \");\n+    test(#fmt[~\"%- 05d\", -1], ~\"-1   \");\n+    test(#fmt[~\"%-+05d\", 1], ~\"+1   \");\n+    test(#fmt[~\"%-+05d\", -1], ~\"-1   \");\n }"}]}