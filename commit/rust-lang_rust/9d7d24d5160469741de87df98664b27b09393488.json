{"sha": "9d7d24d5160469741de87df98664b27b09393488", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkN2QyNGQ1MTYwNDY5NzQxZGU4N2RmOTg2NjRiMjdiMDkzOTM0ODg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-29T23:44:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-29T23:44:01Z"}, "message": "Rollup merge of #76057 - matklad:remove-retokenize, r=petrochenkov\n\nMove retokenize hack to save_analysis\n\ncloses #76046", "tree": {"sha": "7ed5ec1d3f0bac738d77606139a936ce8564c23e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ed5ec1d3f0bac738d77606139a936ce8564c23e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d7d24d5160469741de87df98664b27b09393488", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfSuhBCRBK7hj4Ov3rIwAAdHIIAE1hHq0un+uUqKbZEorlUSd7\njsx6W2mZOi46Q2u6Tql2LK6gKOY1tzVMbdcN5h20hIUPLp4Ve+E+Lks5WxxNFmWe\n2d7lcgqlSlGf9xK5IXdul3T8c2c/PMyUM4n4Ci+NN7LzSQ8H4qNZudGLanHF7/2X\nKThmHUPKuXoVxzsN+2uDNQlhE+8ho4yO87qjyKOjKo6+TWLgP9gZTVcQFfNSa6rn\n9TTBUDAhnFqSoZ63ZJkM/8RZrVbcmhcuYrcxgLb+q8u1SiuRFzoY+1ftanmf/tMP\n4Cz9fUcaUN9dS+qafvMyY/4LTCmxm8WDvMD8OlvW7wFMO2lQ1Hr30R1EzvynYxg=\n=yAbS\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ed5ec1d3f0bac738d77606139a936ce8564c23e\nparent 11193ca202a765e13d258627933494cd25e38482\nparent 6621895365ea70bcfaf09bb05e35d64c2f52e4c6\nauthor Dylan DPC <dylan.dpc@gmail.com> 1598744641 +0200\ncommitter GitHub <noreply@github.com> 1598744641 +0200\n\nRollup merge of #76057 - matklad:remove-retokenize, r=petrochenkov\n\nMove retokenize hack to save_analysis\n\ncloses #76046\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7d24d5160469741de87df98664b27b09393488", "html_url": "https://github.com/rust-lang/rust/commit/9d7d24d5160469741de87df98664b27b09393488", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d7d24d5160469741de87df98664b27b09393488/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11193ca202a765e13d258627933494cd25e38482", "url": "https://api.github.com/repos/rust-lang/rust/commits/11193ca202a765e13d258627933494cd25e38482", "html_url": "https://github.com/rust-lang/rust/commit/11193ca202a765e13d258627933494cd25e38482"}, {"sha": "6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "html_url": "https://github.com/rust-lang/rust/commit/6621895365ea70bcfaf09bb05e35d64c2f52e4c6"}], "stats": {"total": 124, "additions": 36, "deletions": 88}, "files": [{"sha": "4e18870fe2a1491c7e041d6b2d8baa93987181a0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7d24d5160469741de87df98664b27b09393488/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9d7d24d5160469741de87df98664b27b09393488/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9d7d24d5160469741de87df98664b27b09393488", "patch": "@@ -3927,8 +3927,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n+ \"rustc_lexer\",\n  \"rustc_middle\",\n- \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serde_json\","}, {"sha": "a65d3446819244de1dd443eef8267a40b16bff8d", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=9d7d24d5160469741de87df98664b27b09393488", "patch": "@@ -46,19 +46,10 @@ impl<'a> StringReader<'a> {\n         source_file: Lrc<rustc_span::SourceFile>,\n         override_span: Option<Span>,\n     ) -> Self {\n-        // Make sure external source is loaded first, before accessing it.\n-        // While this can't show up during normal parsing, `retokenize` may\n-        // be called with a source file from an external crate.\n-        sess.source_map().ensure_source_file_source_present(Lrc::clone(&source_file));\n-\n-        let src = if let Some(src) = &source_file.src {\n-            Lrc::clone(&src)\n-        } else if let Some(src) = source_file.external_src.borrow().get_source() {\n-            Lrc::clone(&src)\n-        } else {\n+        let src = source_file.src.clone().unwrap_or_else(|| {\n             sess.span_diagnostic\n                 .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n-        };\n+        });\n \n         StringReader {\n             sess,\n@@ -70,23 +61,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.source_map().lookup_byte_offset(span.lo());\n-        let end = sess.source_map().lookup_byte_offset(span.hi());\n-\n-        // Make the range zero-length if the span is invalid.\n-        if begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let mut sr = StringReader::new(sess, begin.sf, None);\n-\n-        // Seek the lexer to the right byte range.\n-        sr.end_src_index = sr.src_index(span.hi());\n-\n-        sr\n-    }\n-\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n         self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }"}, {"sha": "979a8da2a9f682740c96ea0579bd180a0372a2f2", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=9d7d24d5160469741de87df98664b27b09393488", "patch": "@@ -16,7 +16,7 @@ rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n-rustc_parse = { path = \"../librustc_parse\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n serde_json = \"1\"\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "ce484858cbb66e1b74a73a0c3f91d62e34391161", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9d7d24d5160469741de87df98664b27b09393488", "patch": "@@ -14,7 +14,7 @@\n //! recording the output.\n \n use rustc_ast as ast;\n-use rustc_ast::{token, walk_list};\n+use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n@@ -1207,9 +1207,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n-                if let Some(sub_span) =\n-                    self.span.sub_span_of_token(item.span, token::BinOp(token::Star))\n-                {\n+                if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n                         let access = access_from!(self.save_ctxt, item, item.hir_id);\n                         let span = self.span_from_span(sub_span);"}, {"sha": "edcd4925773743270fc2b97e280b6a3e1599e6d4", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7d24d5160469741de87df98664b27b09393488/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=9d7d24d5160469741de87df98664b27b09393488", "patch": "@@ -1,6 +1,6 @@\n use crate::generated_code;\n-use rustc_ast::token::{self, TokenKind};\n-use rustc_parse::lexer::{self, StringReader};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_session::Session;\n use rustc_span::*;\n \n@@ -43,61 +43,37 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn retokenise_span(&self, span: Span) -> StringReader<'a> {\n-        lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n-    }\n-\n-    pub fn sub_span_of_token(&self, span: Span, tok: TokenKind) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let next = toks.next_token();\n-            if next == token::Eof {\n-                return None;\n-            }\n-            if next == tok {\n-                return Some(next.span);\n-            }\n+    /// Finds the span of `*` token withing the larger `span`.\n+    pub fn sub_span_of_star(&self, mut span: Span) -> Option<Span> {\n+        let begin = self.sess.source_map().lookup_byte_offset(span.lo());\n+        let end = self.sess.source_map().lookup_byte_offset(span.hi());\n+        // Make the range zero-length if the span is invalid.\n+        if begin.sf.start_pos != end.sf.start_pos {\n+            span = span.shrink_to_lo();\n         }\n-    }\n \n-    // // Return the name for a macro definition (identifier after first `!`)\n-    // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     loop {\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Eof {\n-    //             return None;\n-    //         }\n-    //         if ts == token::Not {\n-    //             let ts = toks.real_token();\n-    //             if ts.kind.is_ident() {\n-    //                 return Some(ts.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //     }\n-    // }\n+        let sf = Lrc::clone(&begin.sf);\n \n-    // // Return the name for a macro use (identifier before first `!`).\n-    // pub fn span_for_macro_use_name(&self, span:Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     let mut prev = toks.real_token();\n-    //     loop {\n-    //         if prev == token::Eof {\n-    //             return None;\n-    //         }\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Not {\n-    //             if prev.kind.is_ident() {\n-    //                 return Some(prev.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //         prev = ts;\n-    //     }\n-    // }\n+        self.sess.source_map().ensure_source_file_source_present(Lrc::clone(&sf));\n+        let src =\n+            sf.src.clone().or_else(|| sf.external_src.borrow().get_source().map(Lrc::clone))?;\n+        let to_index = |pos: BytePos| -> usize { (pos - sf.start_pos).0 as usize };\n+        let text = &src[to_index(span.lo())..to_index(span.hi())];\n+        let start_pos = {\n+            let mut pos = 0;\n+            tokenize(text)\n+                .map(|token| {\n+                    let start = pos;\n+                    pos += token.len;\n+                    (start, token)\n+                })\n+                .find(|(_pos, token)| token.kind == TokenKind::Star)?\n+                .0\n+        };\n+        let lo = span.lo() + BytePos(start_pos as u32);\n+        let hi = lo + BytePos(1);\n+        Some(span.with_lo(lo).with_hi(hi))\n+    }\n \n     /// Return true if the span is generated code, and\n     /// it is not a subspan of the root callsite."}]}