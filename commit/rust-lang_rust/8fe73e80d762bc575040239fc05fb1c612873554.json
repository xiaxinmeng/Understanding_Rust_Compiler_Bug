{"sha": "8fe73e80d762bc575040239fc05fb1c612873554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTczZTgwZDc2MmJjNTc1MDQwMjM5ZmMwNWZiMWM2MTI4NzM1NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T18:16:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T18:16:02Z"}, "message": "Auto merge of #76971 - bugadani:issue-75659, r=Amanieu\n\nRefactor memchr to allow optimization\n\nCloses #75659\n\nThe implementation already uses naive search if the slice if short enough, but the case is complicated enough to not be optimized away. This PR refactors memchr so that it exists early when the slice is short enough.\n\nCodegen-wise, as shown in #75659, memchr was not inlined previously so the only way I could find to test this is to check if there is no memchr call. Let me know if there is a more robust solution here.", "tree": {"sha": "a0f1265e371692d886598d75e1c2a0f962edf2a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f1265e371692d886598d75e1c2a0f962edf2a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe73e80d762bc575040239fc05fb1c612873554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe73e80d762bc575040239fc05fb1c612873554", "html_url": "https://github.com/rust-lang/rust/commit/8fe73e80d762bc575040239fc05fb1c612873554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe73e80d762bc575040239fc05fb1c612873554/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad6187ce51eb3a304ca448b8676870f95ab5b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad6187ce51eb3a304ca448b8676870f95ab5b11", "html_url": "https://github.com/rust-lang/rust/commit/2ad6187ce51eb3a304ca448b8676870f95ab5b11"}, {"sha": "de623bfaf77a69d86e1561f6b4e0fdd9d193cf60", "url": "https://api.github.com/repos/rust-lang/rust/commits/de623bfaf77a69d86e1561f6b4e0fdd9d193cf60", "html_url": "https://github.com/rust-lang/rust/commit/de623bfaf77a69d86e1561f6b4e0fdd9d193cf60"}], "stats": {"total": 106, "additions": 90, "deletions": 16}, "files": [{"sha": "ed26c59c17c432af3fca1ea54caa21fa058ead29", "filename": "library/core/src/slice/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs?ref=8fe73e80d762bc575040239fc05fb1c612873554", "patch": "@@ -268,12 +268,14 @@ where\n }\n \n impl SliceContains for u8 {\n+    #[inline]\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         memchr::memchr(*self, x).is_some()\n     }\n }\n \n impl SliceContains for i8 {\n+    #[inline]\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         let byte = *self as u8;\n         // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`"}, {"sha": "0c0f1750264eb2dbe21418b3cdadf023077ff6c6", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=8fe73e80d762bc575040239fc05fb1c612873554", "patch": "@@ -12,6 +12,7 @@ const HI_U64: u64 = 0x8080808080808080;\n // Use truncation.\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n+const USIZE_BYTES: usize = mem::size_of::<usize>();\n \n /// Returns `true` if `x` contains any zero byte.\n ///\n@@ -38,19 +39,29 @@ fn repeat_byte(b: u8) -> usize {\n }\n \n /// Returns the first index matching the byte `x` in `text`.\n+#[inline]\n pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+    // Fast path for small slices\n+    if text.len() < 2 * USIZE_BYTES {\n+        return text.iter().position(|elt| *elt == x);\n+    }\n+\n+    memchr_general_case(x, text)\n+}\n+\n+fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n     // Split `text` in three parts\n     // - unaligned initial part, before the first word aligned address in text\n     // - body, scan by 2 words at a time\n     // - the last remaining part, < 2 word size\n+\n+    // search up to an aligned boundary\n     let len = text.len();\n     let ptr = text.as_ptr();\n-    let usize_bytes = mem::size_of::<usize>();\n+    let mut offset = ptr.align_offset(USIZE_BYTES);\n \n-    // search up to an aligned boundary\n-    let mut offset = ptr.align_offset(usize_bytes);\n     if offset > 0 {\n         offset = cmp::min(offset, len);\n         if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n@@ -60,22 +71,19 @@ pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n \n     // search the body of the text\n     let repeated_x = repeat_byte(x);\n+    while offset <= len - 2 * USIZE_BYTES {\n+        unsafe {\n+            let u = *(ptr.add(offset) as *const usize);\n+            let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);\n \n-    if len >= 2 * usize_bytes {\n-        while offset <= len - 2 * usize_bytes {\n-            unsafe {\n-                let u = *(ptr.add(offset) as *const usize);\n-                let v = *(ptr.add(offset + usize_bytes) as *const usize);\n-\n-                // break if there is a matching byte\n-                let zu = contains_zero_byte(u ^ repeated_x);\n-                let zv = contains_zero_byte(v ^ repeated_x);\n-                if zu || zv {\n-                    break;\n-                }\n+            // break if there is a matching byte\n+            let zu = contains_zero_byte(u ^ repeated_x);\n+            let zv = contains_zero_byte(v ^ repeated_x);\n+            if zu || zv {\n+                break;\n             }\n-            offset += usize_bytes * 2;\n         }\n+        offset += USIZE_BYTES * 2;\n     }\n \n     // Find the byte after the point the body loop stopped."}, {"sha": "4192632fe5781a3fa4684ec035546784d2634747", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73e80d762bc575040239fc05fb1c612873554/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=8fe73e80d762bc575040239fc05fb1c612873554", "patch": "@@ -1636,6 +1636,7 @@ impl<T> [T] {\n     /// assert!(!v.iter().any(|e| e == \"hi\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn contains(&self, x: &T) -> bool\n     where\n         T: PartialEq,"}, {"sha": "d093c841d68ef0bf0266bc5b999e8625ff3e6ddb", "filename": "src/test/codegen/issue-75659.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73e80d762bc575040239fc05fb1c612873554/src%2Ftest%2Fcodegen%2Fissue-75659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73e80d762bc575040239fc05fb1c612873554/src%2Ftest%2Fcodegen%2Fissue-75659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-75659.rs?ref=8fe73e80d762bc575040239fc05fb1c612873554", "patch": "@@ -0,0 +1,63 @@\n+// This test checks that the call to memchr/slice_contains is optimized away\n+// when searching in small slices.\n+\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @foo1\n+#[no_mangle]\n+pub fn foo1(x: u8, data: &[u8; 1]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo2\n+#[no_mangle]\n+pub fn foo2(x: u8, data: &[u8; 2]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo3\n+#[no_mangle]\n+pub fn foo3(x: u8, data: &[u8; 3]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo4\n+#[no_mangle]\n+pub fn foo4(x: u8, data: &[u8; 4]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo8\n+#[no_mangle]\n+pub fn foo8(x: u8, data: &[u8; 8]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo8_i8\n+#[no_mangle]\n+pub fn foo8_i8(x: i8, data: &[i8; 8]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    !data.contains(&x)\n+}\n+\n+// Check that the general case isn't inlined\n+// CHECK-LABEL: @foo80\n+#[no_mangle]\n+pub fn foo80(x: u8, data: &[u8; 80]) -> bool {\n+    // CHECK: call core::slice::memchr\n+    data.contains(&x)\n+}"}]}