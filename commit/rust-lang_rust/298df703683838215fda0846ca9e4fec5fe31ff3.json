{"sha": "298df703683838215fda0846ca9e4fec5fe31ff3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OGRmNzAzNjgzODM4MjE1ZmRhMDg0NmNhOWU0ZmVjNWZlMzFmZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-04T22:16:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-04T22:16:13Z"}, "message": "Auto merge of #5061 - ThibsG:UselessMatch3664, r=flip1995\n\nAdd new lint: match with a single binding statement\n\nThis lint catches `match` statements that binds to only one block and could be rewritten using a simple `let` statement.\n\nLint name: MATCH_SINGLE_BINDING\n\nfixes: #3664\n\nchangelog: add lint for match with single binding statement", "tree": {"sha": "4c078b4caea743048e10c0ecddefe455eb0842a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c078b4caea743048e10c0ecddefe455eb0842a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298df703683838215fda0846ca9e4fec5fe31ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298df703683838215fda0846ca9e4fec5fe31ff3", "html_url": "https://github.com/rust-lang/rust/commit/298df703683838215fda0846ca9e4fec5fe31ff3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298df703683838215fda0846ca9e4fec5fe31ff3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d33c603d26f5645808f9e7cdcd2d2c9806cb23c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7", "html_url": "https://github.com/rust-lang/rust/commit/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7"}, {"sha": "00904cb100f9f9d3291f98a3434f7aba9301b8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/00904cb100f9f9d3291f98a3434f7aba9301b8de", "html_url": "https://github.com/rust-lang/rust/commit/00904cb100f9f9d3291f98a3434f7aba9301b8de"}], "stats": {"total": 586, "additions": 486, "deletions": 100}, "files": [{"sha": "49de9df64694c779aff4340c01a9ad55bcb2e6a9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -1217,6 +1217,7 @@ Released 2018-09-13\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats\n [`match_same_arms`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_same_arms\n+[`match_single_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_single_binding\n [`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n [`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n [`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum"}, {"sha": "da02591f690d607da6e3e75eef55373db5e84e98", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 351 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 352 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "1d23dd115bc49d9b5346dbe2152201d345c3fc62", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=d33c603d26f5645808f9e7cdcd2d2c9806cb23c7", "patch": "@@ -1,77 +0,0 @@\n-use super::utils::{get_arg_name, match_var, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::*;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n-    /// or tuple struct where a `let` will suffice.\n-    ///\n-    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    ///\n-    /// let data = match wrapper {\n-    ///     Wrapper::Data(i) => i,\n-    /// };\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    /// let Wrapper::Data(data) = wrapper;\n-    /// ```\n-    pub INFALLIBLE_DESTRUCTURING_MATCH,\n-    style,\n-    \"a `match` statement with a single infallible arm instead of a `let`\"\n-}\n-\n-declare_lint_pass!(InfallibleDestructingMatch => [INFALLIBLE_DESTRUCTURING_MATCH]);\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfallibleDestructingMatch {\n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n-        if_chain! {\n-            if let Some(ref expr) = local.init;\n-            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n-            if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n-            if args.len() == 1;\n-            if let Some(arg) = get_arg_name(&args[0]);\n-            let body = remove_blocks(&arms[0].body);\n-            if match_var(body, arg);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    INFALLIBLE_DESTRUCTURING_MATCH,\n-                    local.span,\n-                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n-                     Consider using `let`\",\n-                    \"try this\",\n-                    format!(\n-                        \"let {}({}) = {};\",\n-                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "45342cc7e0070f66d44f81d9ec801f98b2576835", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -218,7 +218,6 @@ pub mod if_let_some_result;\n pub mod if_not_else;\n pub mod implicit_return;\n pub mod indexing_slicing;\n-pub mod infallible_destructuring_match;\n pub mod infinite_iter;\n pub mod inherent_impl;\n pub mod inherent_to_string;\n@@ -555,7 +554,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &implicit_return::IMPLICIT_RETURN,\n         &indexing_slicing::INDEXING_SLICING,\n         &indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n-        &infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         &infinite_iter::INFINITE_ITER,\n         &infinite_iter::MAYBE_INFINITE_ITER,\n         &inherent_impl::MULTIPLE_INHERENT_IMPL,\n@@ -600,10 +598,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n+        &matches::INFALLIBLE_DESTRUCTURING_MATCH,\n         &matches::MATCH_AS_REF,\n         &matches::MATCH_BOOL,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n+        &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILD_ERR_ARM,\n         &matches::SINGLE_MATCH,\n         &matches::SINGLE_MATCH_ELSE,\n@@ -864,7 +864,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n-    store.register_late_pass(|| box matches::Matches);\n+    store.register_late_pass(|| box matches::Matches::default());\n     store.register_late_pass(|| box minmax::MinMaxPass);\n     store.register_late_pass(|| box open_options::OpenOptions);\n     store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n@@ -941,7 +941,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box question_mark::QuestionMark);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box infallible_destructuring_match::InfallibleDestructingMatch);\n     store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n@@ -1166,7 +1165,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&identity_op::IDENTITY_OP),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n-        LintId::of(&infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&infinite_iter::INFINITE_ITER),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY),\n@@ -1201,10 +1199,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n+        LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n+        LintId::of(&matches::MATCH_SINGLE_BINDING),\n         LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n@@ -1382,7 +1382,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n-        LintId::of(&infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n@@ -1395,6 +1394,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n@@ -1483,6 +1483,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::MATCH_AS_REF),\n+        LintId::of(&matches::MATCH_SINGLE_BINDING),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&methods::CHARS_NEXT_CMP),\n         LintId::of(&methods::CLONE_ON_COPY),"}, {"sha": "1d8c5ec9038dc460fe58ea979ec897f595096811", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 178, "deletions": 6, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -3,9 +3,9 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, is_allowed, is_expn_of, is_wild, match_qpath, match_type, multispan_sugg, remove_blocks, snippet,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-    walk_ptrs_ty,\n+    expr_block, get_arg_name, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, match_type,\n+    match_var, multispan_sugg, remove_blocks, snippet, snippet_block, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_note, span_lint_and_sugg, span_lint_and_then, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::lint::in_external_macro;\n@@ -14,7 +14,7 @@ use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use std::cmp::Ordering;\n use std::collections::Bound;\n@@ -245,7 +245,75 @@ declare_clippy_lint! {\n     \"a wildcard pattern used with others patterns in same match arm\"\n }\n \n-declare_lint_pass!(Matches => [\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a `match` statement with a single infallible arm instead of a `let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for useless match that binds to only one value.\n+    ///\n+    /// **Why is this bad?** Readability and needless complexity.\n+    ///\n+    /// **Known problems:**  Suggested replacements may be incorrect when `match`\n+    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let a = 1;\n+    /// # let b = 2;\n+    ///\n+    /// // Bad\n+    /// match (a, b) {\n+    ///     (c, d) => {\n+    ///         // useless match\n+    ///     }\n+    /// }\n+    ///\n+    /// // Good\n+    /// let (c, d) = (a, b);\n+    /// ```\n+    pub MATCH_SINGLE_BINDING,\n+    complexity,\n+    \"a match with a single binding instead of using `let` statement\"\n+}\n+\n+#[derive(Default)]\n+pub struct Matches {\n+    infallible_destructuring_match_linted: bool,\n+}\n+\n+impl_lint_pass!(Matches => [\n     SINGLE_MATCH,\n     MATCH_REF_PATS,\n     MATCH_BOOL,\n@@ -254,7 +322,9 @@ declare_lint_pass!(Matches => [\n     MATCH_WILD_ERR_ARM,\n     MATCH_AS_REF,\n     WILDCARD_ENUM_MATCH_ARM,\n-    WILDCARD_IN_OR_PATTERNS\n+    WILDCARD_IN_OR_PATTERNS,\n+    MATCH_SINGLE_BINDING,\n+    INFALLIBLE_DESTRUCTURING_MATCH\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n@@ -270,11 +340,51 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n             check_wild_enum_match(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n             check_wild_in_or_pats(cx, arms);\n+\n+            if self.infallible_destructuring_match_linted {\n+                self.infallible_destructuring_match_linted = false;\n+            } else {\n+                check_match_single_binding(cx, ex, arms, expr);\n+            }\n         }\n         if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n+\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n+        if_chain! {\n+            if let Some(ref expr) = local.init;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n+            if arms.len() == 1 && arms[0].guard.is_none();\n+            if let PatKind::TupleStruct(\n+                QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n+            if args.len() == 1;\n+            if let Some(arg) = get_arg_name(&args[0]);\n+            let body = remove_blocks(&arms[0].body);\n+            if match_var(body, arg);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                self.infallible_destructuring_match_linted = true;\n+                span_lint_and_sugg(\n+                    cx,\n+                    INFALLIBLE_DESTRUCTURING_MATCH,\n+                    local.span,\n+                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n+                    Consider using `let`\",\n+                    \"try this\",\n+                    format!(\n+                        \"let {}({}) = {};\",\n+                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n+                    ),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n }\n \n #[rustfmt::skip]\n@@ -712,6 +822,68 @@ fn check_wild_in_or_pats(cx: &LateContext<'_, '_>, arms: &[Arm<'_>]) {\n     }\n }\n \n+fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+        return;\n+    }\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = remove_blocks(&arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\").to_owned().to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    match match_body.kind {\n+        ExprKind::Block(block, _) => {\n+            // macro + expr_ty(body) == ()\n+            if block.span.from_expansion() && cx.tables.expr_ty(&match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+        _ => {\n+            // expr_ty(body) == ()\n+            if cx.tables.expr_ty(&match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+    }\n+\n+    let mut applicability = Applicability::MaybeIncorrect;\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                expr.span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using `let` statement\",\n+                format!(\n+                    \"let {} = {};\\n{}\",\n+                    snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                    snippet_body\n+                ),\n+                applicability,\n+            );\n+        },\n+        PatKind::Wild => {\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                expr.span,\n+                \"this match could be replaced by its body itself\",\n+                \"consider using the match body instead\",\n+                snippet_body,\n+                Applicability::MachineApplicable,\n+            );\n+        },\n+        _ => (),\n+    }\n+}\n+\n /// Gets all arms that are unbounded `PatRange`s.\n fn all_ranges<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,"}, {"sha": "7d2aedd667d74ba1caad518470b343efc9136a0a", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 351] = [\n+pub const ALL_LINTS: [Lint; 352] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -775,7 +775,7 @@ pub const ALL_LINTS: [Lint; 351] = [\n         group: \"style\",\n         desc: \"a `match` statement with a single infallible arm instead of a `let`\",\n         deprecation: None,\n-        module: \"infallible_destructuring_match\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"infinite_iter\",\n@@ -1092,6 +1092,13 @@ pub const ALL_LINTS: [Lint; 351] = [\n         deprecation: None,\n         module: \"copies\",\n     },\n+    Lint {\n+        name: \"match_single_binding\",\n+        group: \"complexity\",\n+        desc: \"a match with a single binding instead of using `let` statement\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_wild_err_arm\",\n         group: \"style\","}, {"sha": "c0a52d832c00a2793fa49252ab0bbb88c511e4c0", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -3,7 +3,8 @@\n     clippy::borrowed_box,\n     clippy::needless_pass_by_value,\n     clippy::unused_unit,\n-    clippy::redundant_clone\n+    clippy::redundant_clone,\n+    clippy::match_single_binding\n )]\n #![warn(clippy::boxed_local)]\n "}, {"sha": "c86a769a3da4b170e2dbbc93118ed5a49dd0b216", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -1,13 +1,13 @@\n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:39:13\n+  --> $DIR/escape_analysis.rs:40:13\n    |\n LL | fn warn_arg(x: Box<A>) {\n    |             ^\n    |\n    = note: `-D clippy::boxed-local` implied by `-D warnings`\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:130:12\n+  --> $DIR/escape_analysis.rs:131:12\n    |\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^"}, {"sha": "5de43733ad33601a1108985bdb686b0d10d332e1", "filename": "tests/ui/match_ref_pats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -26,6 +26,7 @@ fn ref_pats() {\n     }\n     // False positive: only wildcard pattern.\n     let w = Some(0);\n+    #[allow(clippy::match_single_binding)]\n     match w {\n         _ => println!(\"none\"),\n     }"}, {"sha": "52cb4a14b72bcecce5de2cf219fc616ccfa2e7b6", "filename": "tests/ui/match_ref_pats.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_ref_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_ref_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.stderr?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -47,7 +47,7 @@ LL |         None => println!(\"none\"),\n    |\n \n error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:34:5\n+  --> $DIR/match_ref_pats.rs:35:5\n    |\n LL | /     if let &None = a {\n LL | |         println!(\"none\");\n@@ -60,7 +60,7 @@ LL |     if let None = *a {\n    |            ^^^^   ^^\n \n error: you don't need to add `&` to both the expression and the patterns\n-  --> $DIR/match_ref_pats.rs:39:5\n+  --> $DIR/match_ref_pats.rs:40:5\n    |\n LL | /     if let &None = &b {\n LL | |         println!(\"none\");\n@@ -73,7 +73,7 @@ LL |     if let None = b {\n    |            ^^^^   ^\n \n error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:66:9\n+  --> $DIR/match_ref_pats.rs:67:9\n    |\n LL | /         match foo_variant!(0) {\n LL | |             &Foo::A => println!(\"A\"),"}, {"sha": "8fb8dc323e4302b41d35f77b854c7a9208da6904", "filename": "tests/ui/match_single_binding.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_single_binding)]\n+#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = 3;\n+    // Lint\n+    let (x, y, z) = (a, b, c);\n+{\n+    println!(\"{} {} {}\", x, y, z);\n+}\n+    // Lint\n+    let (x, y, z) = (a, b, c);\n+println!(\"{} {} {}\", x, y, z);\n+    // Ok\n+    match a {\n+        2 => println!(\"2\"),\n+        _ => println!(\"Not 2\"),\n+    }\n+    // Ok\n+    let d = Some(5);\n+    match d {\n+        Some(d) => println!(\"{}\", d),\n+        _ => println!(\"None\"),\n+    }\n+    // Lint\n+    println!(\"whatever\");\n+    // Lint\n+    {\n+    let x = 29;\n+    println!(\"x has a value of {}\", x);\n+}\n+    // Lint\n+    {\n+    let e = 5 * a;\n+    if e >= 5 {\n+        println!(\"e is superior to 5\");\n+    }\n+}\n+    // Lint\n+    let p = Point { x: 0, y: 7 };\n+    let Point { x, y } = p;\n+println!(\"Coords: ({}, {})\", x, y);\n+    // Lint\n+    let Point { x: x1, y: y1 } = p;\n+println!(\"Coords: ({}, {})\", x1, y1);\n+    // Lint\n+    let x = 5;\n+    let ref r = x;\n+println!(\"Got a reference to {}\", r);\n+    // Lint\n+    let mut x = 5;\n+    let ref mut mr = x;\n+println!(\"Got a mutable reference to {}\", mr);\n+}"}, {"sha": "55b0b09a008842805492ba598f204a222d784844", "filename": "tests/ui/match_single_binding.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -0,0 +1,75 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_single_binding)]\n+#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = 3;\n+    // Lint\n+    match (a, b, c) {\n+        (x, y, z) => {\n+            println!(\"{} {} {}\", x, y, z);\n+        },\n+    }\n+    // Lint\n+    match (a, b, c) {\n+        (x, y, z) => println!(\"{} {} {}\", x, y, z),\n+    }\n+    // Ok\n+    match a {\n+        2 => println!(\"2\"),\n+        _ => println!(\"Not 2\"),\n+    }\n+    // Ok\n+    let d = Some(5);\n+    match d {\n+        Some(d) => println!(\"{}\", d),\n+        _ => println!(\"None\"),\n+    }\n+    // Lint\n+    match a {\n+        _ => println!(\"whatever\"),\n+    }\n+    // Lint\n+    match a {\n+        _ => {\n+            let x = 29;\n+            println!(\"x has a value of {}\", x);\n+        },\n+    }\n+    // Lint\n+    match a {\n+        _ => {\n+            let e = 5 * a;\n+            if e >= 5 {\n+                println!(\"e is superior to 5\");\n+            }\n+        },\n+    }\n+    // Lint\n+    let p = Point { x: 0, y: 7 };\n+    match p {\n+        Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n+    }\n+    // Lint\n+    match p {\n+        Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n+    }\n+    // Lint\n+    let x = 5;\n+    match x {\n+        ref r => println!(\"Got a reference to {}\", r),\n+    }\n+    // Lint\n+    let mut x = 5;\n+    match x {\n+        ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+    }\n+}"}, {"sha": "d76e229adff095c5ed51f05caf70fa5f48dd649b", "filename": "tests/ui/match_single_binding.stderr", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -0,0 +1,140 @@\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:16:5\n+   |\n+LL | /     match (a, b, c) {\n+LL | |         (x, y, z) => {\n+LL | |             println!(\"{} {} {}\", x, y, z);\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::match-single-binding` implied by `-D warnings`\n+help: consider using `let` statement\n+   |\n+LL |     let (x, y, z) = (a, b, c);\n+LL | {\n+LL |     println!(\"{} {} {}\", x, y, z);\n+LL | }\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:22:5\n+   |\n+LL | /     match (a, b, c) {\n+LL | |         (x, y, z) => println!(\"{} {} {}\", x, y, z),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let (x, y, z) = (a, b, c);\n+LL | println!(\"{} {} {}\", x, y, z);\n+   |\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:37:5\n+   |\n+LL | /     match a {\n+LL | |         _ => println!(\"whatever\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"whatever\");`\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:41:5\n+   |\n+LL | /     match a {\n+LL | |         _ => {\n+LL | |             let x = 29;\n+LL | |             println!(\"x has a value of {}\", x);\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the match body instead\n+   |\n+LL |     {\n+LL |     let x = 29;\n+LL |     println!(\"x has a value of {}\", x);\n+LL | }\n+   |\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:48:5\n+   |\n+LL | /     match a {\n+LL | |         _ => {\n+LL | |             let e = 5 * a;\n+LL | |             if e >= 5 {\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the match body instead\n+   |\n+LL |     {\n+LL |     let e = 5 * a;\n+LL |     if e >= 5 {\n+LL |         println!(\"e is superior to 5\");\n+LL |     }\n+LL | }\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:58:5\n+   |\n+LL | /     match p {\n+LL | |         Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let Point { x, y } = p;\n+LL | println!(\"Coords: ({}, {})\", x, y);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:62:5\n+   |\n+LL | /     match p {\n+LL | |         Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let Point { x: x1, y: y1 } = p;\n+LL | println!(\"Coords: ({}, {})\", x1, y1);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:67:5\n+   |\n+LL | /     match x {\n+LL | |         ref r => println!(\"Got a reference to {}\", r),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let ref r = x;\n+LL | println!(\"Got a reference to {}\", r);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:72:5\n+   |\n+LL | /     match x {\n+LL | |         ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let ref mut mr = x;\n+LL | println!(\"Got a mutable reference to {}\", mr);\n+   |\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "2b889b62ea991b1adb023046529925fcd306320a", "filename": "tests/ui/println_empty_string.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.fixed?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::match_single_binding)]\n \n fn main() {\n     println!();"}, {"sha": "890f5f68476031be617714b7faea400cc8b66e95", "filename": "tests/ui/println_empty_string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.rs?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::match_single_binding)]\n \n fn main() {\n     println!();"}, {"sha": "23112b8816893894760e77f5a9f09e3abd30a22c", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298df703683838215fda0846ca9e4fec5fe31ff3/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=298df703683838215fda0846ca9e4fec5fe31ff3", "patch": "@@ -1,13 +1,13 @@\n error: using `println!(\"\")`\n-  --> $DIR/println_empty_string.rs:5:5\n+  --> $DIR/println_empty_string.rs:6:5\n    |\n LL |     println!(\"\");\n    |     ^^^^^^^^^^^^ help: replace it with: `println!()`\n    |\n    = note: `-D clippy::println-empty-string` implied by `-D warnings`\n \n error: using `println!(\"\")`\n-  --> $DIR/println_empty_string.rs:8:14\n+  --> $DIR/println_empty_string.rs:9:14\n    |\n LL |         _ => println!(\"\"),\n    |              ^^^^^^^^^^^^ help: replace it with: `println!()`"}]}