{"sha": "33fb5bb004613a0da01c2be272480c06fb82d6dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZmI1YmIwMDQ2MTNhMGRhMDFjMmJlMjcyNDgwYzA2ZmI4MmQ2ZGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T20:39:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:19Z"}, "message": "bench: Fix fallout in benchmarks", "tree": {"sha": "60b42c52c7f0aa36fc3d06d028b3c98cd461aab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60b42c52c7f0aa36fc3d06d028b3c98cd461aab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33fb5bb004613a0da01c2be272480c06fb82d6dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33fb5bb004613a0da01c2be272480c06fb82d6dc", "html_url": "https://github.com/rust-lang/rust/commit/33fb5bb004613a0da01c2be272480c06fb82d6dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33fb5bb004613a0da01c2be272480c06fb82d6dc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f7eb3b058f78bffe5406776eb31080615799ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f7eb3b058f78bffe5406776eb31080615799ce7", "html_url": "https://github.com/rust-lang/rust/commit/8f7eb3b058f78bffe5406776eb31080615799ce7"}], "stats": {"total": 259, "additions": 101, "deletions": 158}, "files": [{"sha": "ea7f2446bf33ddb8a9202f7d86a1fcbaa16b0e21", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -35,7 +35,7 @@ pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n         if ret == 0 {\n             return Err(io::Error::last_os_error())\n         }\n-        assert!(ret as usize < v.capacit());\n+        assert!(ret as usize < v.capacity());\n         v.set_len(ret);\n     }\n     Ok(PathBuf::from(OsString::from_wide(&v)))"}, {"sha": "8f3e939f1f40d7f37f6954a51e54e92c4235354f", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, std_misc, rand)]\n+#![feature(std_misc, rand)]\n \n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;\n-use std::rand::{Rng, IsaacRng, SeedableRng};\n+use std::__rand::{Rng, thread_rng};\n use std::time::Duration;\n \n fn timed<F>(label: &str, f: F) where F: FnMut() {\n@@ -114,7 +114,7 @@ fn main() {\n \n     {\n         let seed: &[_] = &[1, 1, 1, 1, 1, 1, 1];\n-        let mut rng: IsaacRng = SeedableRng::from_seed(seed);\n+        let mut rng = thread_rng();\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.gen();"}, {"sha": "d910367afbf496088ebcc49ff599bbde2787105c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -11,18 +11,14 @@\n // ignore-lexer-test FIXME #15679\n // Microbenchmarks for various functions in std and extra\n \n-#![feature(unboxed_closures, rand, old_io, old_path, std_misc, collections)]\n+#![feature(rand, collections, std_misc)]\n \n-use std::old_io::*;\n-use std::old_path::{Path, GenericPath};\n use std::iter::repeat;\n use std::mem::swap;\n use std::env;\n-use std::rand::Rng;\n-use std::rand;\n+use std::__rand::{thread_rng, Rng};\n use std::str;\n use std::time::Duration;\n-use std::vec;\n \n fn main() {\n     let argv: Vec<String> = env::args().collect();\n@@ -35,7 +31,6 @@ fn main() {\n     }\n \n     bench!(shift_push);\n-    bench!(read_line);\n     bench!(vec_plus);\n     bench!(vec_append);\n     bench!(vec_push_all);\n@@ -70,21 +65,8 @@ fn shift_push() {\n     }\n }\n \n-fn read_line() {\n-    use std::old_io::BufferedReader;\n-\n-    let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n-    path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n-\n-    for _ in 0..3 {\n-        let mut reader = BufferedReader::new(File::open(&path).unwrap());\n-        for _line in reader.lines() {\n-        }\n-    }\n-}\n-\n fn vec_plus() {\n-    let mut r = rand::thread_rng();\n+    let mut r = thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -102,7 +84,7 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let mut r = rand::thread_rng();\n+    let mut r = thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -123,7 +105,7 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let mut r = rand::thread_rng();\n+    let mut r = thread_rng();\n \n     let mut v = Vec::new();\n     for i in 0..1500 {"}, {"sha": "c21470d4bb3e7f48e82ccf4f5b2c998382730d44", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -16,7 +16,7 @@\n \n use std::f32::consts::PI;\n use std::num::Float;\n-use std::rand::{Rng, StdRng};\n+use std::__rand::{Rng, thread_rng};\n \n #[derive(Copy, Clone)]\n struct Vec2 {\n@@ -44,7 +44,7 @@ struct Noise2DContext {\n \n impl Noise2DContext {\n     fn new() -> Noise2DContext {\n-        let mut rng = StdRng::new().unwrap();\n+        let mut rng = thread_rng();\n \n         let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }; 256];\n         for x in &mut rgradients[..] {"}, {"sha": "145ab71446354183d32dcefdcb80223b70532aa5", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -38,13 +38,11 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core, old_io, io, core)]\n-\n use std::cmp::min;\n-use std::old_io::*;\n-use std::iter::repeat;\n use std::env;\n-use std::slice::bytes::copy_memory;\n+use std::io;\n+use std::io::prelude::*;\n+use std::iter::repeat;\n \n const LINE_LEN: usize = 60;\n const LOOKUP_SIZE: usize = 4 * 1024;\n@@ -116,27 +114,31 @@ struct RepeatFasta<'a, W:'a> {\n     out: &'a mut W\n }\n \n-impl<'a, W: Writer> RepeatFasta<'a, W> {\n+impl<'a, W: Write> RepeatFasta<'a, W> {\n     fn new(alu: &'static str, w: &'a mut W) -> RepeatFasta<'a, W> {\n         RepeatFasta { alu: alu, out: w }\n     }\n \n-    fn make(&mut self, n: usize) -> IoResult<()> {\n+    fn make(&mut self, n: usize) -> io::Result<()> {\n         let alu_len = self.alu.len();\n         let mut buf = repeat(0).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(alu, &mut buf);\n+        for (slot, val) in buf.iter_mut().zip(alu.iter()) {\n+            *slot = *val;\n+        }\n         let buf_len = buf.len();\n-        copy_memory(&alu[..LINE_LEN], &mut buf[alu_len..buf_len]);\n+        for (slot, val) in buf[alu_len..buf_len].iter_mut().zip(alu[..LINE_LEN].iter()) {\n+            *slot = *val;\n+        }\n \n         let mut pos = 0;\n         let mut bytes;\n         let mut n = n;\n         while n > 0 {\n             bytes = min(LINE_LEN, n);\n-            try!(self.out.write(&buf[pos..pos + bytes]));\n-            try!(self.out.write_u8('\\n' as u8));\n+            try!(self.out.write_all(&buf[pos..pos + bytes]));\n+            try!(self.out.write_all(&[b'\\n']));\n             pos += bytes;\n             if pos > alu_len {\n                 pos -= alu_len;\n@@ -165,7 +167,7 @@ struct RandomFasta<'a, W:'a> {\n     out: &'a mut W,\n }\n \n-impl<'a, W: Writer> RandomFasta<'a, W> {\n+impl<'a, W: Write> RandomFasta<'a, W> {\n     fn new(w: &'a mut W, a: &[AminoAcid]) -> RandomFasta<'a, W> {\n         RandomFasta {\n             seed: 42,\n@@ -189,7 +191,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         0\n     }\n \n-    fn make(&mut self, n: usize) -> IoResult<()> {\n+    fn make(&mut self, n: usize) -> io::Result<()> {\n         let lines = n / LINE_LEN;\n         let chars_left = n % LINE_LEN;\n         let mut buf = [0;LINE_LEN + 1];\n@@ -204,7 +206,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in 0..chars_left {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(&buf[..chars_left])\n+        self.out.write_all(&buf[..chars_left])\n     }\n }\n \n@@ -216,23 +218,23 @@ fn main() {\n         5\n     };\n \n-    let mut out = stdout();\n+    let mut out = io::stdout();\n \n-    out.write_line(\">ONE Homo sapiens alu\").unwrap();\n+    out.write_all(b\">ONE Homo sapiens alu\\n\").unwrap();\n     {\n         let mut repeat = RepeatFasta::new(ALU, &mut out);\n         repeat.make(n * 2).unwrap();\n     }\n \n-    out.write_line(\">TWO IUB ambiguity codes\").unwrap();\n+    out.write_all(b\">TWO IUB ambiguity codes\\n\").unwrap();\n     let iub = sum_and_scale(&IUB);\n     let mut random = RandomFasta::new(&mut out, &iub);\n     random.make(n * 3).unwrap();\n \n-    random.out.write_line(\">THREE Homo sapiens frequency\").unwrap();\n+    random.out.write_all(b\">THREE Homo sapiens frequency\\n\").unwrap();\n     let homo_sapiens = sum_and_scale(&HOMO_SAPIENS);\n     random.lookup = make_lookup(&homo_sapiens);\n     random.make(n * 5).unwrap();\n \n-    random.out.write_str(\"\\n\").unwrap();\n+    random.out.write_all(b\"\\n\").unwrap();\n }"}, {"sha": "0474cfb6fc8193c90356172d713afac0b17f32d2", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -38,14 +38,12 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(old_io, old_path, io, core)]\n-\n use std::cmp::min;\n-use std::old_io::*;\n-use std::old_io;\n-use std::old_path::Path;\n-use std::num::Float;\n use std::env;\n+use std::fs::File;\n+use std::io::{self, BufWriter};\n+use std::io::prelude::*;\n+use std::num::Float;\n \n const LINE_LENGTH: usize = 60;\n const IM: u32 = 139968;\n@@ -87,9 +85,9 @@ impl<'a> Iterator for AAGen<'a> {\n     }\n }\n \n-fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n+fn make_fasta<W: Write, I: Iterator<Item=u8>>(\n     wr: &mut W, header: &str, mut it: I, mut n: usize)\n-    -> std::old_io::IoResult<()>\n+    -> io::Result<()>\n {\n     try!(wr.write(header.as_bytes()));\n     let mut line = [0; LINE_LENGTH + 1];\n@@ -105,7 +103,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n     Ok(())\n }\n \n-fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n+fn run<W: Write>(writer: &mut W) -> io::Result<()> {\n     let mut args = env::args();\n     let n = if env::var_os(\"RUST_BENCH\").is_some() {\n         25000000\n@@ -146,10 +144,10 @@ fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n \n fn main() {\n     let res = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let mut file = BufferedWriter::new(File::create(&Path::new(\"./shootout-fasta.data\")));\n+        let mut file = BufWriter::new(File::create(\"./shootout-fasta.data\").unwrap());\n         run(&mut file)\n     } else {\n-        run(&mut old_io::stdout())\n+        run(&mut io::stdout())\n     };\n     res.unwrap()\n }"}, {"sha": "bcd8fbf88523ea8c3d87f6852352bec101931c7f", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -13,18 +13,17 @@\n \n // multi tasking k-nucleotide\n \n-#![feature(box_syntax, std_misc, old_io, collections, os)]\n+#![allow(bad_style)]\n \n-use std::ascii::{AsciiExt, OwnedAsciiExt};\n+use std::ascii::AsciiExt;\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::HashMap;\n use std::mem::replace;\n-use std::num::Float;\n-use std::option;\n-use std::os;\n use std::env;\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread;\n+use std::io;\n+use std::io::prelude::*;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -75,10 +74,10 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , usize>, total: usize) -> String {\n \n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , usize>, key: String) -> usize {\n-   let key = key.into_ascii_lowercase();\n+   let key = key.to_ascii_lowercase();\n    match mm.get(key.as_bytes()) {\n-      option::Option::None      => { return 0; }\n-      option::Option::Some(&num) => { return num; }\n+      None => 0,\n+      Some(&num) => num,\n    }\n }\n \n@@ -123,7 +122,7 @@ fn make_sequence_processor(sz: usize,\n        line = from_parent.recv().unwrap();\n        if line == Vec::new() { break; }\n \n-       carry.push_all(&line);\n+       carry.extend(line);\n        carry = windows_with_carry(&carry, sz, |window| {\n            update_freq(&mut freqs, window);\n            total += 1;\n@@ -147,15 +146,13 @@ fn make_sequence_processor(sz: usize,\n \n // given a FASTA file on stdin, process sequence THREE\n fn main() {\n-    use std::old_io::*;\n-\n+    let input = io::stdin();\n     let rdr = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let foo = include_bytes!(\"shootout-k-nucleotide.data\");\n-        box MemReader::new(foo.to_vec()) as Box<Reader>\n+        let foo: &[u8] = include_bytes!(\"shootout-k-nucleotide.data\");\n+        Box::new(foo) as Box<BufRead>\n     } else {\n-        box stdio::stdin() as Box<Reader>\n+        Box::new(input.lock()) as Box<BufRead>\n     };\n-    let mut rdr = BufferedReader::new(rdr);\n \n     // initialize each sequence sorter\n     let sizes: Vec<usize> = vec!(1,2,3,4,6,12,18);"}, {"sha": "93a0a461746bf64855152f2da74e53611bdace07", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -38,13 +38,13 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(simd, old_io, core, io)]\n+#![feature(simd, core)]\n \n // ignore-pretty very bad with line comments\n \n-use std::old_io;\n-use std::old_io::*;\n use std::env;\n+use std::io::prelude::*;\n+use std::io;\n use std::simd::f64x2;\n use std::sync::Arc;\n use std::thread;\n@@ -53,8 +53,7 @@ const ITER: usize = 50;\n const LIMIT: f64 = 2.0;\n const WORKERS: usize = 16;\n \n-#[inline(always)]\n-fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n+fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n     assert!(WORKERS % 2 == 0);\n \n     // Ensure w and h are multiples of 8.\n@@ -142,9 +141,9 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n         })\n     }).collect::<Vec<_>>();\n \n-    try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n+    try!(writeln!(&mut out, \"P4\\n{} {}\", w, h));\n     for res in data {\n-        try!(out.write(&res.join()));\n+        try!(out.write_all(&res.join()));\n     }\n     out.flush()\n }\n@@ -202,9 +201,9 @@ fn main() {\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");\n-        mandelbrot(1000, old_io::util::NullWriter)\n+        mandelbrot(1000, io::sink())\n     } else {\n-        mandelbrot(args.nth(1).unwrap().parse().unwrap(), old_io::stdout())\n+        mandelbrot(args.nth(1).unwrap().parse().unwrap(), io::stdout())\n     };\n     res.unwrap();\n }"}, {"sha": "96ac1e064bfd0bf83903228a5a86681b5f514532", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 15, "deletions": 50, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -40,18 +40,18 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(unboxed_closures, libc, old_io, collections, io, core)]\n+#![feature(libc)]\n \n extern crate libc;\n \n-use std::old_io::stdio::{stdin_raw, stdout_raw};\n-use std::old_io::*;\n-use std::ptr::{copy, Unique};\n+use std::io;\n+use std::io::prelude::*;\n+use std::ptr::copy;\n use std::thread;\n \n struct Tables {\n-    table8: [u8;1 << 8],\n-    table16: [u16;1 << 16]\n+    table8: [u8; 1 << 8],\n+    table16: [u16; 1 << 16]\n }\n \n impl Tables {\n@@ -101,36 +101,6 @@ impl Tables {\n     }\n }\n \n-/// Reads all remaining bytes from the stream.\n-fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n-    // As reading the input stream in memory is a bottleneck, we tune\n-    // Reader::read_to_end() with a fast growing policy to limit\n-    // recopies.  If MREMAP_RETAIN is implemented in the linux kernel\n-    // and jemalloc use it, this trick will become useless.\n-    const CHUNK: usize = 64 * 1024;\n-\n-    let mut vec = Vec::with_capacity(CHUNK);\n-    loop {\n-        // workaround: very fast growing\n-        let len = vec.len();\n-        if vec.capacity() - len < CHUNK {\n-            let cap = vec.capacity();\n-            let mult = if cap < 256 * 1024 * 1024 {\n-                16\n-            } else {\n-                2\n-            };\n-            vec.reserve_exact(mult * cap - len);\n-        }\n-        match r.push_at_least(1, CHUNK, &mut vec) {\n-            Ok(_) => {}\n-            Err(ref e) if e.kind == EndOfFile => break,\n-            Err(e) => return Err(e)\n-        }\n-    }\n-    Ok(vec)\n-}\n-\n /// Finds the first position at which `b` occurs in `s`.\n fn memchr(h: &[u8], n: u8) -> Option<usize> {\n     use libc::{c_void, c_int, size_t};\n@@ -175,7 +145,8 @@ const LINE_LEN: usize = 60;\n \n /// Compute the reverse complement.\n fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n-    let seq = seq.init_mut();// Drop the last newline\n+    let len = seq.len();\n+    let seq = &mut seq[..len - 1]; // Drop the last newline\n     let len = seq.len();\n     let off = LINE_LEN - len % (LINE_LEN + 1);\n     let mut i = LINE_LEN;\n@@ -222,26 +193,20 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n     }\n }\n \n-\n-struct Racy<T>(T);\n-\n-unsafe impl<T: 'static> Send for Racy<T> {}\n-\n /// Executes a closure in parallel over the given iterator over mutable slice.\n /// The closure `f` is run in parallel with an element of `iter`.\n-fn parallel<'a, I: Iterator, F>(iter: I, ref f: F)\n-        where I::Item: Send + 'a,\n-              F: Fn(I::Item) + Sync + 'a {\n+fn parallel<I: Iterator, F>(iter: I, ref f: F)\n+        where I::Item: Send,\n+              F: Fn(I::Item) + Sync, {\n     iter.map(|x| {\n-        thread::scoped(move|| {\n-            f(x)\n-        })\n+        thread::scoped(move || f(x))\n     }).collect::<Vec<_>>();\n }\n \n fn main() {\n-    let mut data = read_to_end(&mut stdin_raw()).unwrap();\n+    let mut data = Vec::with_capacity(1024 * 1024);\n+    io::stdin().read_to_end(&mut data);\n     let tables = &Tables::new();\n     parallel(mut_dna_seqs(&mut data), |seq| reverse_complement(seq, tables));\n-    stdout_raw().write(&data).unwrap();\n+    io::stdout().write_all(&data).unwrap();\n }"}, {"sha": "a1ca59caa3304008e638380cb13c2f4c1390371b", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -10,15 +10,15 @@\n \n // min-lldb-version: 310\n \n-// This test case checks if function arguments already have the correct value when breaking at the\n-// first line of the function, that is if the function prologue has already been executed at the\n-// first line. Note that because of the __morestack part of the prologue GDB incorrectly breaks at\n-// before the arguments have been properly loaded when setting the breakpoint via the function name.\n+// This test case checks if function arguments already have the correct value\n+// when breaking at the first line of the function, that is if the function\n+// prologue has already been executed at the first line. Note that because of\n+// the __morestack part of the prologue GDB incorrectly breaks at before the\n+// arguments have been properly loaded when setting the breakpoint via the\n+// function name.\n \n // compile-flags:-g\n \n-#![feature(old_io)]\n-\n // === GDB TESTS ===================================================================================\n \n // gdb-command:run\n@@ -227,7 +227,7 @@\n #![omit_gdb_pretty_printer_section]\n \n fn immediate_args(a: isize, b: bool, c: f64) {\n-    ::std::old_io::print(\"\") // #break\n+    println!(\"\") // #break\n }\n \n struct BigStruct {\n@@ -242,21 +242,21 @@ struct BigStruct {\n }\n \n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    ::std::old_io::print(\"\") // #break\n+    println!(\"\") // #break\n }\n \n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0; // #break\n-    ::std::old_io::print(\"\")\n+    println!(\"\")\n }\n \n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b; // #break\n-    ::std::old_io::print(\"\")\n+    println!(\"\")\n }\n \n fn function_call(x: u64, y: u64, z: f64) {\n-    std::old_io::stdio::print(\"Hi!\") // #break\n+    println!(\"Hi!\") // #break\n }\n \n fn identifier(x: u64, y: u64, z: f64) -> u64 {"}, {"sha": "7e959a1e920126bb08e647eaaa45a64a2558e62d", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -11,17 +11,17 @@\n // ignore-android: FIXME(#10381)\n // min-lldb-version: 310\n \n-// This test case checks if function arguments already have the correct value when breaking at the\n-// beginning of a function. Functions with the #[no_stack_check] attribute have the same prologue as\n-// regular C functions compiled with GCC or Clang and therefore are better handled by GDB. As a\n-// consequence, and as opposed to regular Rust functions, we can set the breakpoints via the\n-// function name (and don't have to fall back on using line numbers). For LLDB this shouldn't make\n-// a difference because it can handle both cases.\n+// This test case checks if function arguments already have the correct value\n+// when breaking at the beginning of a function. Functions with the\n+// #[no_stack_check] attribute have the same prologue as regular C functions\n+// compiled with GCC or Clang and therefore are better handled by GDB. As a\n+// consequence, and as opposed to regular Rust functions, we can set the\n+// breakpoints via the function name (and don't have to fall back on using line\n+// numbers). For LLDB this shouldn't make a difference because it can handle\n+// both cases.\n \n // compile-flags:-g\n \n-#![feature(old_io)]\n-\n // === GDB TESTS ===================================================================================\n \n // gdb-command:rbreak immediate_args\n@@ -251,7 +251,7 @@\n \n #[no_stack_check]\n fn immediate_args(a: isize, b: bool, c: f64) {\n-    ::std::old_io::print(\"\");\n+    println!(\"\");\n }\n \n struct BigStruct {\n@@ -267,24 +267,24 @@ struct BigStruct {\n \n #[no_stack_check]\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    ::std::old_io::print(\"\");\n+    println!(\"\");\n }\n \n #[no_stack_check]\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n-    ::std::old_io::print(\"\");\n+    println!(\"\");\n }\n \n #[no_stack_check]\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n-    ::std::old_io::print(\"\");\n+    println!(\"\");\n }\n \n #[no_stack_check]\n fn function_call(x: u64, y: u64, z: f64) {\n-    std::old_io::stdio::print(\"Hi!\")\n+    println!(\"Hi!\")\n }\n \n #[no_stack_check]"}, {"sha": "13dc0c6d12007e1f9dc5a8d8b0450783e69143b2", "filename": "src/test/debuginfo/issue13213.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33fb5bb004613a0da01c2be272480c06fb82d6dc/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue13213.rs?ref=33fb5bb004613a0da01c2be272480c06fb82d6dc", "patch": "@@ -23,5 +23,5 @@ extern crate issue13213aux;\n // be available because they have been optimized out from the exporting crate.\n fn main() {\n     let b: issue13213aux::S = issue13213aux::A;\n-    ::std::old_io::println(\"Nothing to do here...\");\n+    println!(\"Nothing to do here...\");\n }"}]}