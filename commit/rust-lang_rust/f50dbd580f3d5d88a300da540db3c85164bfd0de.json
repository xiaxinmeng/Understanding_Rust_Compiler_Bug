{"sha": "f50dbd580f3d5d88a300da540db3c85164bfd0de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MGRiZDU4MGYzZDVkODhhMzAwZGE1NDBkYjNjODUxNjRiZmQwZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-29T14:50:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-29T14:50:38Z"}, "message": "Auto merge of #37918 - flodiebold:separate-bodies, r=nikomatsakis\n\nSeparate function bodies from their signatures in HIR\n\nAlso give them their own dep map node.\n\nI'm still unhappy with the handling of inlined items (1452edc1), but maybe you have a suggestion how to improve it.\n\nFixes #35078.\n\nr? @nikomatsakis", "tree": {"sha": "e33816de38e0bf1ddf1c0932acfaa217559c2755", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e33816de38e0bf1ddf1c0932acfaa217559c2755"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f50dbd580f3d5d88a300da540db3c85164bfd0de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f50dbd580f3d5d88a300da540db3c85164bfd0de", "html_url": "https://github.com/rust-lang/rust/commit/f50dbd580f3d5d88a300da540db3c85164bfd0de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f50dbd580f3d5d88a300da540db3c85164bfd0de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de15be5ec9144f6701c8de606fdf83c6eefefef", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de15be5ec9144f6701c8de606fdf83c6eefefef", "html_url": "https://github.com/rust-lang/rust/commit/5de15be5ec9144f6701c8de606fdf83c6eefefef"}, {"sha": "593b2736598f3e08bb7636615e52e1f76a2f2da5", "url": "https://api.github.com/repos/rust-lang/rust/commits/593b2736598f3e08bb7636615e52e1f76a2f2da5", "html_url": "https://github.com/rust-lang/rust/commit/593b2736598f3e08bb7636615e52e1f76a2f2da5"}], "stats": {"total": 2715, "additions": 1807, "deletions": 908}, "files": [{"sha": "0c941a4a2301fcc651f299203636bbebc300583b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -42,6 +42,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // Represents the HIR node with the given node-id\n     Hir(D),\n \n+    // Represents the body of a function or method. The def-id is that of the\n+    // function/method.\n+    HirBody(D),\n+\n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n     MetaData(D),\n@@ -59,6 +63,7 @@ pub enum DepNode<D: Clone + Debug> {\n     PluginRegistrar,\n     StabilityIndex,\n     CollectItem(D),\n+    CollectItemSig(D),\n     Coherence,\n     EffectCheck,\n     Liveness,\n@@ -150,6 +155,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             CollectItem,\n             BorrowCheck,\n             Hir,\n+            HirBody,\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,\n@@ -199,8 +205,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n \n             Hir(ref d) => op(d).map(Hir),\n+            HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n+            CollectItemSig(ref d) => op(d).map(CollectItemSig),\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),"}, {"sha": "625bde2ca8b67c52dd99ea0be8df8cb602017336", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 120, "deletions": 38, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -67,6 +67,62 @@ impl<'a> FnKind<'a> {\n     }\n }\n \n+/// Specifies what nested things a visitor wants to visit. The most\n+/// common choice is `OnlyBodies`, which will cause the visitor to\n+/// visit fn bodies for fns that it encounters, but skip over nested\n+/// item-like things.\n+///\n+/// See the comments on `ItemLikeVisitor` for more details on the overall\n+/// visit strategy.\n+pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n+    /// Do not visit any nested things. When you add a new\n+    /// \"non-nested\" thing, you will want to audit such uses to see if\n+    /// they remain valid.\n+    ///\n+    /// Use this if you are only walking some particular kind of tree\n+    /// (i.e., a type, or fn signature) and you don't want to thread a\n+    /// HIR map around.\n+    None,\n+\n+    /// Do not visit nested item-like things, but visit nested things\n+    /// that are inside of an item-like.\n+    ///\n+    /// **This is the most common choice.** A very commmon pattern is\n+    /// to use `tcx.visit_all_item_likes_in_krate()` as an outer loop,\n+    /// and to have the visitor that visits the contents of each item\n+    /// using this setting.\n+    OnlyBodies(&'this Map<'tcx>),\n+\n+    /// Visit all nested things, including item-likes.\n+    ///\n+    /// **This is an unusual choice.** It is used when you want to\n+    /// process everything within their lexical context. Typically you\n+    /// kick off the visit by doing `walk_krate()`.\n+    All(&'this Map<'tcx>),\n+}\n+\n+impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n+    /// Returns the map to use for an \"intra item-like\" thing (if any).\n+    /// e.g., function body.\n+    pub fn intra(self) -> Option<&'this Map<'tcx>> {\n+        match self {\n+            NestedVisitorMap::None => None,\n+            NestedVisitorMap::OnlyBodies(map) => Some(map),\n+            NestedVisitorMap::All(map) => Some(map),\n+        }\n+    }\n+\n+    /// Returns the map to use for an \"item-like\" thing (if any).\n+    /// e.g., item, impl-item.\n+    pub fn inter(self) -> Option<&'this Map<'tcx>> {\n+        match self {\n+            NestedVisitorMap::None => None,\n+            NestedVisitorMap::OnlyBodies(_) => None,\n+            NestedVisitorMap::All(map) => Some(map),\n+        }\n+    }\n+}\n+\n /// Each method of the Visitor trait is a hook to be potentially\n /// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n@@ -88,23 +144,22 @@ pub trait Visitor<'v> : Sized {\n     // Nested items.\n \n     /// The default versions of the `visit_nested_XXX` routines invoke\n-    /// this method to get a map to use; if they get back `None`, they\n-    /// just skip nested things. Otherwise, they will lookup the\n-    /// nested item-like things in the map and visit it. So the best\n-    /// way to implement a nested visitor is to override this method\n-    /// to return a `Map`; one advantage of this is that if we add\n-    /// more types of nested things in the future, they will\n-    /// automatically work.\n+    /// this method to get a map to use. By selecting an enum variant,\n+    /// you control which kinds of nested HIR are visited; see\n+    /// `NestedVisitorMap` for details. By \"nested HIR\", we are\n+    /// referring to bits of HIR that are not directly embedded within\n+    /// one another but rather indirectly, through a table in the\n+    /// crate. This is done to control dependencies during incremental\n+    /// compilation: the non-inline bits of HIR can be tracked and\n+    /// hashed separately.\n     ///\n     /// **If for some reason you want the nested behavior, but don't\n     /// have a `Map` are your disposal:** then you should override the\n     /// `visit_nested_XXX` methods, and override this method to\n     /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n     /// added in the future, we will see the panic in your code and\n     /// fix it appropriately.\n-    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n-        None\n-    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v>;\n \n     /// Invoked when a nested item is encountered. By default does\n     /// nothing unless you override `nested_visit_map` to return\n@@ -116,8 +171,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map()\n-                           .map(|map| map.expect_item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }\n@@ -128,13 +182,23 @@ pub trait Visitor<'v> : Sized {\n     /// method.\n     #[allow(unused_variables)]\n     fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n-        let opt_item = self.nested_visit_map()\n-                           .map(|map| map.impl_item(id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.impl_item(id));\n         if let Some(item) = opt_item {\n             self.visit_impl_item(item);\n         }\n     }\n \n+    /// Invoked to visit the body of a function, method or closure. Like\n+    /// visit_nested_item, does nothing by default unless you override\n+    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n+    /// body.\n+    fn visit_body(&mut self, id: ExprId) {\n+        let opt_expr = self.nested_visit_map().intra().map(|map| map.expr(id));\n+        if let Some(expr) = opt_expr {\n+            self.visit_expr(expr);\n+        }\n+    }\n+\n     /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n@@ -200,7 +264,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: ExprId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -363,7 +427,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n                                             unsafety,\n@@ -372,7 +436,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             &item.vis,\n                                             &item.attrs),\n                              declaration,\n-                             body,\n+                             body_id,\n                              item.span,\n                              item.id)\n         }\n@@ -697,13 +761,25 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Expr,\n+                                   body_id: ExprId,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_expr(function_body)\n+    visitor.visit_body(body_id)\n+}\n+\n+pub fn walk_fn_with_body<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             function_kind: FnKind<'v>,\n+                                             function_declaration: &'v FnDecl,\n+                                             body: &'v Expr,\n+                                             _span: Span,\n+                                             id: NodeId) {\n+    visitor.visit_id(id);\n+    walk_fn_decl(visitor, function_declaration);\n+    walk_fn_kind(visitor, function_kind);\n+    visitor.visit_expr(body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -720,13 +796,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        MethodTraitItem(ref sig, Some(ref body)) => {\n+        MethodTraitItem(ref sig, Some(body_id)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.name,\n                                             sig,\n                                             None,\n                                             &trait_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              trait_item.span,\n                              trait_item.id);\n         }\n@@ -752,13 +828,13 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n         }\n-        ImplItemKind::Method(ref sig, ref body) => {\n+        ImplItemKind::Method(ref sig, body_id) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n                                             Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              impl_item.span,\n                              impl_item.id);\n         }\n@@ -883,7 +959,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n+        ExprClosure(_, ref function_declaration, body, _fn_decl_span) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n@@ -998,34 +1074,40 @@ impl IdRange {\n }\n \n \n-pub struct IdRangeComputingVisitor {\n-    pub result: IdRange,\n+pub struct IdRangeComputingVisitor<'a, 'ast: 'a> {\n+    result: IdRange,\n+    map: &'a map::Map<'ast>,\n }\n \n-impl IdRangeComputingVisitor {\n-    pub fn new() -> IdRangeComputingVisitor {\n-        IdRangeComputingVisitor { result: IdRange::max() }\n+impl<'a, 'ast> IdRangeComputingVisitor<'a, 'ast> {\n+    pub fn new(map: &'a map::Map<'ast>) -> IdRangeComputingVisitor<'a, 'ast> {\n+        IdRangeComputingVisitor { result: IdRange::max(), map: map }\n     }\n \n     pub fn result(&self) -> IdRange {\n         self.result\n     }\n }\n \n-impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n+impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.map)\n+    }\n+\n     fn visit_id(&mut self, id: NodeId) {\n         self.result.add(id);\n     }\n }\n \n /// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body(fk: FnKind,\n-                                    decl: &FnDecl,\n-                                    body: &Expr,\n-                                    sp: Span,\n-                                    id: NodeId)\n-                                    -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    visitor.visit_fn(fk, decl, body, sp, id);\n+pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n+                                        decl: &'v FnDecl,\n+                                        body: &'v Expr,\n+                                        sp: Span,\n+                                        id: NodeId,\n+                                        map: &map::Map<'v>)\n+                                        -> IdRange {\n+    let mut visitor = IdRangeComputingVisitor::new(map);\n+    walk_fn_with_body(&mut visitor, fk, decl, body, sp, id);\n     visitor.result()\n }"}, {"sha": "71ef7131440b80393fa90c3e3880437befd77909", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -41,8 +41,10 @@ use super::intravisit::Visitor;\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the `visit_nested_foo()` foo methods\n-///      as needed. Walk your crate with `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the\n+///      `visit_nested_map()` methods to return\n+///      `NestedVisitorMap::All`. Walk your crate with\n+///      `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}, {"sha": "ccf94e0b803db6391287cb12b383dabc121ae9e9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -47,9 +47,12 @@ use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n use util::nodemap::NodeMap;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use std::collections::BTreeMap;\n use std::iter;\n+use std::mem;\n+\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n@@ -68,6 +71,7 @@ pub struct LoweringContext<'a> {\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n+    exprs: FnvHashMap<hir::ExprId, hir::Expr>,\n     resolver: &'a mut Resolver,\n \n     /// The items being lowered are collected here.\n@@ -104,6 +108,7 @@ pub fn lower_crate(sess: &Session,\n         crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n+        exprs: FnvHashMap(),\n         resolver: resolver,\n         items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -120,6 +125,23 @@ enum ParamMode {\n \n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n+        self.lower_items(c);\n+        let module = self.lower_mod(&c.module);\n+        let attrs = self.lower_attrs(&c.attrs);\n+        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+\n+        hir::Crate {\n+            module: module,\n+            attrs: attrs,\n+            span: c.span,\n+            exported_macros: exported_macros,\n+            items: self.items,\n+            impl_items: self.impl_items,\n+            exprs: mem::replace(&mut self.exprs, FnvHashMap()),\n+        }\n+    }\n+\n+    fn lower_items(&mut self, c: &Crate) {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n@@ -139,16 +161,14 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n+        let mut item_lowerer = ItemLowerer { lctx: self };\n+        visit::walk_crate(&mut item_lowerer, c);\n+    }\n \n-        hir::Crate {\n-            module: self.lower_mod(&c.module),\n-            attrs: self.lower_attrs(&c.attrs),\n-            span: c.span,\n-            exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n-            items: self.items,\n-            impl_items: self.impl_items,\n-        }\n+    fn record_expr(&mut self, expr: hir::Expr) -> hir::ExprId {\n+        let id = hir::ExprId(expr.id);\n+        self.exprs.insert(id, expr);\n+        id\n     }\n \n     fn next_id(&self) -> NodeId {\n@@ -825,12 +845,14 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n+                let body = self.expr_block(body, ThinVec::new());\n+                let body_id = self.record_expr(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            P(self.expr_block(body, ThinVec::new())))\n+                            body_id)\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -897,7 +919,8 @@ impl<'a> LoweringContext<'a> {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n                                              body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n-                            P(this.expr_block(body, ThinVec::new()))\n+                            let expr = this.expr_block(body, ThinVec::new());\n+                            this.record_expr(expr)\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -925,8 +948,9 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  P(this.expr_block(body, ThinVec::new())))\n+                        let expr = this.expr_block(body, ThinVec::new());\n+                        let expr_id = this.record_expr(expr);\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig), expr_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1375,9 +1399,10 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                     self.with_parent_def(e.id, |this| {\n+                        let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         P(this.lower_expr(body)),\n+                                         this.record_expr(expr),\n                                          fn_decl_span)\n                     })\n                 }"}, {"sha": "068e7ed8624ed77300f10252a13fa392639634ee", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -48,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Expr,\n+    pub body: ast::ExprId,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -115,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Expr,\n+    body:     ast::ExprId,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -125,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Expr,\n+    body: ast::ExprId,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::ExprId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -172,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Expr {\n-        self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n+    pub fn body(self) -> ast::ExprId {\n+        self.handle(|i: ItemFnParts<'a>|  i.body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -196,6 +196,18 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts|    c.id)\n     }\n \n+    pub fn constness(self) -> ast::Constness {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, _, constness, ..) => {\n+                constness\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.constness\n+            }\n+            _ => ast::Constness::NotConst\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)\n@@ -215,21 +227,21 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Expr,\n+                  ast::ExprId,\n                   Span,\n                   &'a [Attribute])\n                   -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n+                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n                         decl: &decl,\n                         unsafety: unsafety,\n-                        body: &block,\n+                        body: block,\n                         generics: generics,\n                         abi: abi,\n                         vis: &i.vis,\n@@ -240,24 +252,24 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n-                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                ast::MethodTraitItem(ref sig, Some(body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::ImplItemKind::Method(ref sig, ref body) => {\n+                    ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }\n-            }\n+            },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n+                ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n+                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "c46c8f044e0ffc3863feb0bfb7bd85b5fac414dd", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -10,7 +10,7 @@\n \n use super::*;\n \n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n@@ -91,7 +91,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n \n-    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n \n@@ -106,6 +106,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.visit_impl_item(self.krate.impl_item(item_id))\n     }\n \n+    fn visit_body(&mut self, id: ExprId) {\n+        self.visit_expr(self.krate.expr(id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -209,7 +213,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Expr, s: Span, id: NodeId) {\n+                b: ExprId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }"}, {"sha": "273094b735c3a1e9b137915161c25b4887fc85bc", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -11,7 +11,7 @@\n use hir::map::definitions::*;\n \n use hir;\n-use hir::intravisit;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use middle::cstore::InlinedItem;\n@@ -326,7 +326,18 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n }\n \n // We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        // note however that we override `visit_body` below\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_body(&mut self, id: hir::ExprId) {\n+        if let Some(krate) = self.hir_crate {\n+            self.visit_expr(krate.expr(id));\n+        }\n+    }\n+\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "434e34e7003df1fd9a4cbfd20733a395e281af7b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -18,7 +18,6 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n use dep_graph::{DepGraph, DepNode};\n \n use middle::cstore::InlinedItem;\n-use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n@@ -61,6 +60,8 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n     NodeTyParam(&'ast TyParam),\n     NodeVisibility(&'ast Visibility),\n+\n+    NodeInlinedItem(&'ast InlinedItem),\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -120,6 +121,8 @@ impl<'ast> MapEntry<'ast> {\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n             NodeVisibility(n) => EntryVisibility(p, n),\n+\n+            NodeInlinedItem(n) => RootInlinedParent(n),\n         }\n     }\n \n@@ -168,6 +171,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n             EntryVisibility(_, n) => NodeVisibility(n),\n+            RootInlinedParent(n) => NodeInlinedItem(n),\n             _ => return None\n         })\n     }\n@@ -252,26 +256,43 @@ impl<'ast> Map<'ast> {\n         let map = self.map.borrow();\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n+            let mut last_expr = None;\n             loop {\n                 match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n                         assert_eq!(id, item.id);\n                         let def_id = self.local_def_id(id);\n                         assert!(!self.is_inlined_def_id(def_id));\n+\n+                        if let Some(last_id) = last_expr {\n+                            // The body of the item may have a separate dep node\n+                            // (Note that trait items don't currently have\n+                            // their own dep node, so there's also just one\n+                            // HirBody node for all the items)\n+                            if self.is_body(last_id, item) {\n+                                return DepNode::HirBody(def_id);\n+                            }\n+                        }\n                         return DepNode::Hir(def_id);\n                     }\n \n-                    EntryImplItem(..) => {\n+                    EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n                         assert!(!self.is_inlined_def_id(def_id));\n+\n+                        if let Some(last_id) = last_expr {\n+                            // The body of the item may have a separate dep node\n+                            if self.is_impl_item_body(last_id, item) {\n+                                return DepNode::HirBody(def_id);\n+                            }\n+                        }\n                         return DepNode::Hir(def_id);\n                     }\n \n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n                     EntryVariant(p, _) |\n                     EntryField(p, _) |\n-                    EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n                     EntryTraitRef(p, _) |\n@@ -284,6 +305,11 @@ impl<'ast> Map<'ast> {\n                     EntryVisibility(p, _) =>\n                         id = p,\n \n+                    EntryExpr(p, _) => {\n+                        last_expr = Some(id);\n+                        id = p;\n+                    }\n+\n                     RootCrate =>\n                         return DepNode::Krate,\n \n@@ -328,12 +354,8 @@ impl<'ast> Map<'ast> {\n                     EntryVisibility(p, _) =>\n                         id = p,\n \n-                    RootInlinedParent(parent) => match *parent {\n-                        InlinedItem::Item(def_id, _) |\n-                        InlinedItem::TraitItem(def_id, _) |\n-                        InlinedItem::ImplItem(def_id, _) =>\n-                            return DepNode::MetaData(def_id)\n-                    },\n+                    RootInlinedParent(parent) =>\n+                        return DepNode::MetaData(parent.def_id),\n \n                     RootCrate =>\n                         bug!(\"node {} has crate ancestor but is inlined\", id0),\n@@ -345,6 +367,29 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    fn is_body(&self, node_id: NodeId, item: &Item) -> bool {\n+        match item.node {\n+            ItemFn(_, _, _, _, _, body) => body.node_id() == node_id,\n+            // Since trait items currently don't get their own dep nodes,\n+            // we check here whether node_id is the body of any of the items.\n+            // If they get their own dep nodes, this can go away\n+            ItemTrait(_, _, _, ref trait_items) => {\n+                trait_items.iter().any(|trait_item| { match trait_item.node {\n+                    MethodTraitItem(_, Some(body)) => body.node_id() == node_id,\n+                    _ => false\n+                }})\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn is_impl_item_body(&self, node_id: NodeId, item: &ImplItem) -> bool {\n+        match item.node {\n+            ImplItemKind::Method(_, body) => body.node_id() == node_id,\n+            _ => false\n+        }\n+    }\n+\n     pub fn num_local_def_ids(&self) -> usize {\n         self.definitions.borrow().len()\n     }\n@@ -556,8 +601,7 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&II::TraitItem(did, _))) |\n-            Some(RootInlinedParent(&II::ImplItem(did, _))) => did,\n+            Some(RootInlinedParent(ii)) => ii.def_id,\n             _ => self.local_def_id(parent)\n         }\n     }\n@@ -655,6 +699,10 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expr(&self, id: ExprId) -> &'ast Expr {\n+        self.expect_expr(id.node_id())\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -958,6 +1006,8 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             // printing.\n             NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n+\n+            NodeInlinedItem(_) => bug!(\"cannot print inlined item\"),\n         }\n     }\n }\n@@ -1071,6 +1121,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n+        Some(NodeInlinedItem(_)) => {\n+            format!(\"inlined item {}\", id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "4fd8f96ba046a7a74526317c37d12a2bd09a69f6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -33,6 +33,7 @@ pub use self::PathParameters::*;\n use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FxHashSet};\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n@@ -428,6 +429,7 @@ pub struct Crate {\n     pub items: BTreeMap<NodeId, Item>,\n \n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n+    pub exprs: FnvHashMap<ExprId, Expr>,\n }\n \n impl Crate {\n@@ -458,6 +460,10 @@ impl Crate {\n             visitor.visit_impl_item(impl_item);\n         }\n     }\n+\n+    pub fn expr(&self, id: ExprId) -> &Expr {\n+        &self.exprs[&id]\n+    }\n }\n \n /// A macro definition, in this crate or imported from another.\n@@ -846,6 +852,15 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ExprId(NodeId);\n+\n+impl ExprId {\n+    pub fn node_id(self) -> NodeId {\n+        self.0\n+    }\n+}\n+\n /// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n@@ -855,6 +870,12 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n+impl Expr {\n+    pub fn expr_id(&self) -> ExprId {\n+        ExprId(self.id)\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))\n@@ -914,7 +935,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, ExprId, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1068,7 +1089,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Expr>>),\n+    MethodTraitItem(MethodSig, Option<ExprId>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1101,7 +1122,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Expr>),\n+    Method(MethodSig, ExprId),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1546,7 +1567,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, ExprId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "74920b1328076d392dd9212fe903cd8ea0e80993", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -644,6 +644,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_expr_id(&mut self, expr_id: &hir::ExprId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            let expr = &krate.exprs[expr_id];\n+            self.print_expr(expr)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n@@ -729,7 +738,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(&body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1020,7 +1029,7 @@ impl<'a> State<'a> {\n                     self.nbsp()?;\n                     self.end()?; // need to close a box\n                     self.end()?; // need to close a box\n-                    self.print_expr(body)?;\n+                    self.print_expr_id(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1065,7 +1074,7 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1432,7 +1441,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall"}, {"sha": "fba4f35074dbc062a5f5d7f5716d798ac5bfa8f3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -719,10 +719,10 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut IdVisitor)\n+    fn visit_ids<'b, F: 'b>(&'b mut self, f: F)\n+        where F: FnOnce(&mut IdVisitor<'b, 'a, 'tcx>)\n     {\n-        let mut v = IdVisitor {\n+        let mut v = IdVisitor::<'b, 'a, 'tcx> {\n             cx: self\n         };\n         f(&mut v);\n@@ -791,8 +791,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n@@ -835,9 +835,10 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.expr(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n@@ -1107,7 +1108,11 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> hir_visit::Visitor<'tcx> for IdVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::OnlyBodies(&self.cx.tcx.map)\n+    }\n+\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n@@ -1117,12 +1122,12 @@ impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _ti: &'tcx hir::TraitItem) {\n         // Do not recurse into trait or impl items automatically. These are\n         // processed separately by calling hir_visit::walk_trait_item()\n     }\n \n-    fn visit_impl_item(&mut self, _ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _ii: &'tcx hir::ImplItem) {\n         // See visit_trait_item()\n     }\n }"}, {"sha": "d055506a38226b8277316b9a3f4a729544cac274", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 88, "deletions": 22, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -137,18 +137,96 @@ pub struct NativeLibrary {\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    Item(DefId /* def-id in source crate */, P<hir::Item>),\n-    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>)\n+pub struct InlinedItem {\n+    pub def_id: DefId,\n+    pub body: P<hir::Expr>,\n+    pub const_fn_args: Vec<Option<DefId>>,\n+}\n+\n+/// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n+/// a crate; it then gets read as an InlinedItem.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n+pub struct InlinedItemRef<'a> {\n+    pub def_id: DefId,\n+    pub body: &'a hir::Expr,\n+    pub const_fn_args: Vec<Option<DefId>>,\n+}\n+\n+fn get_fn_args(decl: &hir::FnDecl) -> Vec<Option<DefId>> {\n+    decl.inputs.iter().map(|arg| match arg.pat.node {\n+        hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+        _ => None\n+    }).collect()\n+}\n+\n+impl<'a> InlinedItemRef<'a> {\n+    pub fn from_item<'b, 'tcx>(def_id: DefId,\n+                               item: &'a hir::Item,\n+                               tcx: TyCtxt<'b, 'a, 'tcx>)\n+                               -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n+                (tcx.map.expr(body_id), get_fn_args(decl)),\n+            hir::ItemConst(_, ref body) => (&**body, Vec::new()),\n+            _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn from_trait_item(def_id: DefId,\n+                           item: &'a hir::TraitItem,\n+                           _tcx: TyCtxt)\n+                           -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ConstTraitItem(_, Some(ref body)) =>\n+                (&**body, Vec::new()),\n+            hir::ConstTraitItem(_, None) => {\n+                bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n+            },\n+            _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn from_impl_item<'b, 'tcx>(def_id: DefId,\n+                                    item: &'a hir::ImplItem,\n+                                    tcx: TyCtxt<'b, 'a, 'tcx>)\n+                                    -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ImplItemKind::Method(ref sig, body_id) =>\n+                (tcx.map.expr(body_id), get_fn_args(&sig.decl)),\n+            hir::ImplItemKind::Const(_, ref body) =>\n+                (&**body, Vec::new()),\n+            _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn visit<V>(&self, visitor: &mut V)\n+        where V: Visitor<'a>\n+    {\n+        visitor.visit_expr(&self.body);\n+    }\n }\n \n-/// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub enum InlinedItemRef<'a> {\n-    Item(DefId, &'a hir::Item),\n-    TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem)\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        visitor.visit_expr(&self.body);\n+    }\n }\n \n pub enum LoadedMacro {\n@@ -292,18 +370,6 @@ pub trait CrateStore<'tcx> {\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        match *self {\n-            InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n-            InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-            InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-        }\n-    }\n-}\n-\n // FIXME: find a better place for this?\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let mut err_count = 0;"}, {"sha": "f7a34c43cccbd8335afcbd0dfd85a655e16cd5f4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -193,6 +193,10 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n         let mut formals = Formals { entry: entry, index: index };\n         intravisit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n+            fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n+                panic!(\"should not encounter fn bodies or items\")\n+            }\n+\n             fn visit_pat(&mut self, p: &hir::Pat) {\n                 self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n                 intravisit::walk_pat(self, p)"}, {"sha": "1bf6b837fd998d2f201540621297a8e8a6839ff2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -15,7 +15,7 @@\n use dep_graph::DepNode;\n use hir::map as ast_map;\n use hir::{self, PatKind};\n-use hir::intravisit::{self, Visitor};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n use middle::privacy;\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &ast_map::Node) {\n+    fn visit_node(&mut self, node: &ast_map::Node<'tcx>) {\n         let had_extern_repr = self.struct_has_extern_repr;\n         self.struct_has_extern_repr = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -220,9 +220,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n \n-    fn visit_variant_data(&mut self, def: &hir::VariantData, _: ast::Name,\n+    fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n                         _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -234,7 +237,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tcx.tables().qpath_def(qpath, expr.id);\n@@ -255,7 +258,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n         if arm.pats.len() == 1 {\n             let variants = arm.pats[0].necessary_variants();\n \n@@ -271,7 +274,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n@@ -288,7 +291,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_non_const_paths = false;\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n         self.handle_definition(id, path.def);\n         intravisit::walk_path(self, path);\n     }\n@@ -507,8 +510,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -562,12 +565,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 }\n                 intravisit::walk_expr(self, expr)\n             }\n-            hir::ImplItemKind::Method(_, ref body) => {\n+            hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_expr(self, body)\n+                self.visit_body(body_id)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -576,10 +579,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref body))|\n-            hir::MethodTraitItem(_, Some(ref body)) => {\n+            hir::ConstTraitItem(_, Some(ref body)) => {\n                 intravisit::walk_expr(self, body)\n             }\n+            hir::MethodTraitItem(_, Some(body_id)) => {\n+                self.visit_body(body_id)\n+            }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |\n             hir::TypeTraitItem(..) => {}"}, {"sha": "2ec7aa4c4d9031c316c0ac37d3557008203de98f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use hir::{self, PatKind};\n use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor};\n+use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -92,9 +92,13 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n-    fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>\n@@ -111,12 +115,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n-        intravisit::walk_fn(self, fn_kind, fn_decl, block, span, id);\n+        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n             hir::UnsafeBlock(source) => {\n@@ -155,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n@@ -212,7 +216,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n             if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {"}, {"sha": "e927843a984b8c351a307ca2e625d4ba69f831bf", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -47,6 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n         find_item(item, self, at_root);\n     }\n \n+\n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n         // entry fn is never an impl item\n     }"}, {"sha": "6896c69d7db92249224b4f1a1adf23ca7878668d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -19,7 +19,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -34,7 +34,7 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n+    fn visit_const(&mut self, item_id: ast::NodeId, expr: &'tcx hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n         self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n@@ -116,9 +116,13 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n     // const, static and N in [T; N].\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n@@ -127,24 +131,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n@@ -158,8 +162,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.infcx.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n             self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n         } else {"}, {"sha": "445aed8f97d600fe3eeb547b24d2ca96e008d3ee", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -128,7 +128,7 @@ use syntax_pos::Span;\n use hir::Expr;\n use hir;\n use hir::print::{expr_to_string, block_to_string};\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -182,14 +182,18 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n-    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n-    fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n+    fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &'tcx Expr) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -348,28 +352,32 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n-                _: &'v hir::Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.ir.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, _: FnKind<'tcx>, _: &'tcx hir::FnDecl,\n+                _: hir::ExprId, _: Span, _: NodeId) {\n         // do not check contents of nested fns\n     }\n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         check_arm(self, a);\n     }\n }\n \n-fn visit_fn(ir: &mut IrMaps,\n-            fk: FnKind,\n-            decl: &hir::FnDecl,\n-            body: &hir::Expr,\n-            sp: Span,\n-            id: ast::NodeId) {\n+fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n+                          fk: FnKind<'tcx>,\n+                          decl: &'tcx hir::FnDecl,\n+                          body_id: hir::ExprId,\n+                          sp: Span,\n+                          id: ast::NodeId) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n@@ -387,7 +395,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp, id);\n+    intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or panic\n@@ -400,6 +408,8 @@ fn visit_fn(ir: &mut IrMaps,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n+    let body = ir.tcx.map.expr(body_id);\n+\n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(body);\n@@ -410,7 +420,7 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n+fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n     local.pat.each_binding(|_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n@@ -423,7 +433,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n+fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n         pat.each_binding(|bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n@@ -439,7 +449,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n+fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n@@ -923,7 +933,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., ref blk, _) => {\n+          hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n@@ -932,7 +942,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk.id, succ, node, |this| {\n+              self.with_loop_nodes(blk_id.node_id(), succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n@@ -1354,7 +1364,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &hir::Local) {\n+fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n@@ -1369,7 +1379,7 @@ fn check_local(this: &mut Liveness, local: &hir::Local) {\n     intravisit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n+fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1379,7 +1389,7 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n     intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr(this: &mut Liveness, expr: &Expr) {\n+fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n         this.check_lvalue(&l);\n@@ -1469,7 +1479,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn check_lvalue(&mut self, expr: &Expr) {\n+    fn check_lvalue(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(def_id) = path.def {"}, {"sha": "4c3b102e540399f1c38d2f3b1b5841617a541ecd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., ref body, _) => body.id,\n+                hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n                 _ => bug!()\n             }\n         };"}, {"sha": "9798b2d587dbf413cb4f3a22578e198b5b34d29b", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -28,7 +28,7 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use hir;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n@@ -88,8 +88,12 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n                 Some(self.tcx.tables().qpath_def(qpath, expr.id))\n@@ -216,7 +220,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &ast_map::Node,\n+    fn propagate_node(&mut self, node: &ast_map::Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n@@ -244,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n-                            self.visit_expr(body);\n+                            self.visit_body(body);\n                         }\n                     }\n \n@@ -274,10 +278,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref body)) |\n-                    hir::MethodTraitItem(_, Some(ref body)) => {\n+                    hir::ConstTraitItem(_, Some(ref body)) => {\n                         self.visit_expr(body);\n                     }\n+                    hir::MethodTraitItem(_, Some(body_id)) => {\n+                        self.visit_body(body_id);\n+                    }\n                     hir::TypeTraitItem(..) => {}\n                 }\n             }\n@@ -286,10 +292,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(_, ref expr) => {\n                         self.visit_expr(&expr);\n                     }\n-                    hir::ImplItemKind::Method(ref sig, ref body) => {\n+                    hir::ImplItemKind::Method(ref sig, body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            self.visit_expr(body)\n+                            self.visit_body(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "05fa619ce41e4e8e1b8b5f0e36a55d9ce7772868", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -31,7 +31,7 @@ use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n \n use hir;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n@@ -302,14 +302,16 @@ pub struct Context {\n     parent: CodeExtent\n }\n \n-struct RegionResolutionVisitor<'a> {\n+struct RegionResolutionVisitor<'ast: 'a, 'a> {\n     sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n     cx: Context,\n \n+    map: &'a ast_map::Map<'ast>,\n+\n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n     /// are calling \"terminating scopes\" because, when attempting to\n@@ -660,7 +662,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -731,7 +733,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -741,7 +743,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n     intravisit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &'tcx hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -752,7 +754,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     intravisit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -770,7 +772,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n@@ -848,7 +850,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                           local: &'tcx hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n@@ -1063,7 +1066,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     }\n }\n \n-fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n+fn resolve_item<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, item: &'tcx hir::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n@@ -1078,38 +1081,38 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n     visitor.terminating_scopes = prev_ts;\n }\n \n-fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              kind: FnKind,\n-              decl: &hir::FnDecl,\n-              body: &hir::Expr,\n-              sp: Span,\n-              id: ast::NodeId) {\n+fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                        kind: FnKind<'tcx>,\n+                        decl: &'tcx hir::FnDecl,\n+                        body_id: hir::ExprId,\n+                        sp: Span,\n+                        id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n                                span={:?}, \\\n                                body.id={:?}, \\\n                                cx.parent={:?})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n-           body.id,\n+           body_id,\n            visitor.cx.parent);\n \n     visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n \n     let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id() });\n \n     if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body.id, root_id);\n+        visitor.region_maps.record_fn_parent(body_id.node_id(), root_id);\n     }\n \n     let outer_cx = visitor.cx;\n     let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body.id);\n+    visitor.terminating_scopes.insert(body_id.node_id());\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: ROOT_CODE_EXTENT,\n         var_parent: fn_decl_scope,\n     };\n@@ -1119,18 +1122,18 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_expr(body);\n+    visitor.visit_body(body_id);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'a> RegionResolutionVisitor<'a> {\n+impl<'ast, 'a> RegionResolutionVisitor<'ast, 'a> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n         self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n@@ -1166,42 +1169,46 @@ impl<'a> RegionResolutionVisitor<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n-    fn visit_block(&mut self, b: &Block) {\n+impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.map)\n+    }\n+\n+    fn visit_block(&mut self, b: &'ast Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &'ast Item) {\n         resolve_item(self, i);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         intravisit::walk_impl_item(self, ii);\n         self.create_item_scope_if_needed(ii.id);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         intravisit::walk_trait_item(self, ti);\n         self.create_item_scope_if_needed(ti.id);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Expr, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n+                b: hir::ExprId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &Arm) {\n+    fn visit_arm(&mut self, a: &'ast Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &Pat) {\n+    fn visit_pat(&mut self, p: &'ast Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &Stmt) {\n+    fn visit_stmt(&mut self, s: &'ast Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'ast Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &'ast Local) {\n         resolve_local(self, l);\n     }\n }\n@@ -1228,6 +1235,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n+            map: map,\n             cx: Context {\n                 root_id: None,\n                 parent: ROOT_CODE_EXTENT,"}, {"sha": "c5b03a4a32add5b64a3a0309b6d3979cf39e4edb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -34,7 +34,7 @@ use util::nodemap::NodeMap;\n use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n@@ -132,8 +132,8 @@ pub fn krate(sess: &Session,\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     // Override the nested functions -- lifetimes follow lexical scope,\n     // so it's convenient to walk the tree in lexical order.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.hir_map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.hir_map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n+                b: hir::ExprId, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -407,7 +407,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -419,10 +419,14 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_expr(b);\n+    gather.visit_expr(ctxt.hir_map.expr(b));\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_expr(&mut self, ex: &'v hir::Expr) {\n             // do not recurse into closures defined in the block\n             // since they are treated as separate fns from the POV of\n@@ -497,7 +501,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn(&mut self,\n                              fk: FnKind<'tcx>,\n                              fd: &'tcx hir::FnDecl,\n-                             fb: &'tcx hir::Expr,\n+                             fb: hir::ExprId,\n                              _span: Span,\n                              fn_id: ast::NodeId) {\n         match fk {\n@@ -518,8 +522,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_expr(fb))\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id(), s: self.scope },\n+                  |_old_scope, this| this.visit_body(fb))\n     }\n \n     // FIXME(#37666) this works around a limitation in the region inferencer\n@@ -938,6 +942,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n                 hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n@@ -975,6 +983,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n             self.regions.insert(lifetime_ref.name);\n         }"}, {"sha": "f3890f1c3b7e3c392c84491acb9a119a6d8a3fdc", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -30,8 +30,7 @@ use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n use hir::{Item, Generics, StructField, Variant};\n-use hir::intravisit::{self, Visitor};\n-use hir::itemlikevisit::DeepVisitor;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -234,8 +233,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -326,8 +325,12 @@ impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MissingStabilityAnnotations<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         match i.node {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n@@ -341,35 +344,35 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_item(self, i)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         self.check_missing_stability(ti.id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let impl_def_id = self.tcx.map.local_def_id(self.tcx.map.get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant(&mut self, var: &Variant, g: &Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         self.check_missing_stability(var.node.data.id(), var.span);\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         self.check_missing_stability(s.id, s.span);\n         intravisit::walk_struct_field(self, s);\n     }\n \n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n         self.check_missing_stability(i.id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n \n-    fn visit_macro_def(&mut self, md: &hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         if md.imported_from.is_none() {\n             self.check_missing_stability(md.id, md.span);\n         }\n@@ -425,8 +428,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut checker = Checker { tcx: tcx };\n-    tcx.visit_all_item_likes_in_krate(DepNode::StabilityCheck,\n-                                      &mut DeepVisitor::new(&mut checker));\n+    tcx.visit_all_item_likes_in_krate(DepNode::StabilityCheck, &mut checker.as_deep_visitor());\n }\n \n struct Checker<'a, 'tcx: 'a> {\n@@ -534,6 +536,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemExternCrate(_) => {\n@@ -641,7 +650,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n         missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span);\n         intravisit::walk_crate(&mut missing, krate);\n-        krate.visit_all_item_likes(&mut DeepVisitor::new(&mut missing));\n+        krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }\n \n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;"}, {"sha": "c6df1497e681dd3ac3c4587d0c7d45e772ff3c29", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -18,7 +18,7 @@ use rustc_back::PanicStrategy;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::intravisit;\n use hir;\n \n@@ -125,6 +125,10 @@ impl<'a> Context<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some(lang_item) = lang_items::extract(&i.attrs) {\n             self.register(&lang_item.as_str(), i.span);"}, {"sha": "9a92e9e70feb4e65681b36c07e59db7ada659871", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.map.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body.node_id()))\n                     }\n                 }\n             }\n@@ -1227,9 +1227,9 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let extent = if let Some(ref body) = *body {\n+                        let extent = if let Some(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body.id)\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id())\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n                             tcx.region_maps.item_extent(id)\n@@ -1243,14 +1243,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body_id) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id()))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1280,13 +1280,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                if let hir::ExprClosure(.., ref body, _) = expr.node {\n+                if let hir::ExprClosure(.., body, _) = expr.node {\n                     let def_id = tcx.map.local_def_id(id);\n                     let base_def_id = tcx.closure_base_def_id(def_id);\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        tcx.region_maps.call_site_extent(id, body.id))\n+                        tcx.region_maps.call_site_extent(id, body.node_id()))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }"}, {"sha": "5d59b58b847d9e0eabc99315c5352f0dd67c60d2", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -30,7 +30,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n use rustc::hir::intravisit;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n use self::restrictions::RestrictionResult;\n \n@@ -520,8 +520,12 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     item_id: ast::NodeId\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n             let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n                                                                self.item_id);\n@@ -542,9 +546,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt,\n-                                          item_id: ast::NodeId,\n-                                          expr: &hir::Expr) {\n+pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n+                                                    item_id: ast::NodeId,\n+                                                    expr: &'tcx hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n "}, {"sha": "34e91e60074641723b99ecd679f200457c71b704", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -47,7 +47,7 @@ use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n pub mod check_loans;\n \n@@ -62,9 +62,13 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -79,18 +83,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         borrowck_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n             gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n             gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n         }\n@@ -131,7 +135,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n+fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::Item) {\n     // Gather loans for items. Note that we don't need\n     // to check loans for single expressions. The check\n     // loan step is intended for things that have a data\n@@ -154,15 +158,17 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck_fn(this: &mut BorrowckCtxt,\n-               fk: FnKind,\n-               decl: &hir::FnDecl,\n-               body: &hir::Expr,\n-               sp: Span,\n-               id: ast::NodeId,\n-               attributes: &[ast::Attribute]) {\n+fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                         fk: FnKind<'tcx>,\n+                         decl: &'tcx hir::FnDecl,\n+                         body_id: hir::ExprId,\n+                         sp: Span,\n+                         id: ast::NodeId,\n+                         attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n+    let body = this.tcx.map.expr(body_id);\n+\n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n         this.with_temp_region_map(id, |this| {\n             mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n@@ -191,21 +197,21 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                              decl,\n                              body);\n \n-    intravisit::walk_fn(this, fk, decl, body, sp, id);\n+    intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                          fk: FnKind,\n-                                          decl: &hir::FnDecl,\n+                                          fk: FnKind<'tcx>,\n+                                          decl: &'tcx hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &hir::Expr,\n+                                          body: &'tcx hir::Expr,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id, &tcx.map);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n \n@@ -241,7 +247,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    fn_parts: FnParts<'a>,\n+    fn_parts: FnParts<'tcx>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n@@ -257,11 +263,13 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n+    let body = tcx.map.expr(fn_parts.body);\n+\n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n                                                      fn_parts.kind,\n                                                      &fn_parts.decl,\n                                                      cfg,\n-                                                     &fn_parts.body,\n+                                                     body,\n                                                      fn_parts.span,\n                                                      fn_parts.id);\n \n@@ -407,8 +415,8 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: TyCtxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., ref block, _) => {\n-                block.id\n+            hir::ExprClosure(.., body_id, _) => {\n+                body_id.node_id()\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)"}, {"sha": "786b59e818da2052de8fc7f4e7e3c65523698cfe", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n-use rustc::hir::intravisit::{self, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use rustc::hir::print::pat_to_string;\n use rustc::hir::{self, Pat, PatKind};\n \n@@ -41,29 +41,33 @@ use syntax_pos::Span;\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, _expr: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, _expr: &'tcx hir::Expr) {\n         return // const, static and N in [T; N] - shouldn't contain anything\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(..) = item.node {\n             return // nothing worth match checking in a constant\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(..) = item.node {\n             return // nothing worth match checking in a constant\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -90,8 +94,12 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n     param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n \n         match ex.node {\n@@ -102,7 +110,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_local(&mut self, loc: &hir::Local) {\n+    fn visit_local(&mut self, loc: &'tcx hir::Local) {\n         intravisit::walk_local(self, loc);\n \n         self.check_irrefutable(&loc.pat, false);\n@@ -111,8 +119,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, n: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {\n@@ -557,6 +565,10 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_pat(&mut self, pat: &Pat) {\n         match pat.node {\n             PatKind::Binding(.., ref subpat) => {"}, {"sha": "9fcab1239899fed2b44055026b324cb5f3ee3c80", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -33,7 +33,6 @@ use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{Expr, PatKind};\n use rustc::hir;\n-use rustc::hir::intravisit::FnKind;\n use syntax::ptr::P;\n use syntax::codemap;\n use syntax::attr::IntType;\n@@ -103,14 +102,16 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::ConstTraitItem(..) => {\n+                hir::ConstTraitItem(ref ty, ref expr_option) => {\n                     if let Some(substs) = substs {\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         let trait_id = tcx.map.get_parent(node_id);\n                         let trait_id = tcx.map.local_def_id(trait_id);\n-                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                        let default_value = expr_option.as_ref()\n+                            .map(|expr| (&**expr, tcx.ast_ty_to_prim_ty(ty)));\n+                        resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -141,33 +142,31 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem::Item(_, ref item), _)) => match item.node {\n-                hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n-            },\n-            Some((&InlinedItem::TraitItem(trait_id, ref ti), _)) => match ti.node {\n-                hir::ConstTraitItem(..) => {\n+            Some((&InlinedItem { body: ref const_expr, .. }, _)) => {\n+                Some((&**const_expr, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n+            }\n+            _ => None\n+        };\n+        let expr_ty = match tcx.sess.cstore.describe_def(def_id) {\n+            Some(Def::AssociatedConst(_)) => {\n+                let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n+                // As mentioned in the comments above for in-crate\n+                // constants, we only try to find the expression for a\n+                // trait-associated const if the caller gives us the\n+                // substitutions for the reference to it.\n+                if let Some(trait_id) = trait_id {\n                     used_substs = true;\n+\n                     if let Some(substs) = substs {\n-                        // As mentioned in the comments above for in-crate\n-                        // constants, we only try to find the expression for\n-                        // a trait-associated const if the caller gives us\n-                        // the substitutions for the reference to it.\n-                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                        resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n                     } else {\n                         None\n                     }\n+                } else {\n+                    expr_ty\n                 }\n-                _ => None\n-            },\n-            Some((&InlinedItem::ImplItem(_, ref ii), _)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n             },\n+            Some(Def::Const(..)) => expr_ty,\n             _ => None\n         };\n         // If we used the substitutions, particularly to choose an impl\n@@ -196,24 +195,29 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return None;\n     }\n \n-    let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem::Item(_, ref item), _)) => Some(item.id),\n-        Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n-        _ => None\n-    };\n+    let fn_id = tcx.sess.cstore.maybe_get_item_ast(tcx, def_id).map(|t| t.1);\n     tcx.extern_const_fns.borrow_mut().insert(def_id,\n                                              fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n     fn_id\n }\n \n+pub enum ConstFnNode<'tcx> {\n+    Local(FnLikeNode<'tcx>),\n+    Inlined(&'tcx InlinedItem)\n+}\n+\n pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                       -> Option<FnLikeNode<'tcx>>\n+                                       -> Option<ConstFnNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         node_id\n     } else {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n-            fn_id\n+            if let ast_map::NodeInlinedItem(ii) = tcx.map.get(fn_id) {\n+                return Some(ConstFnNode::Inlined(ii));\n+            } else {\n+                bug!(\"Got const fn from external crate, but it's not inlined\")\n+            }\n         } else {\n             return None;\n         }\n@@ -224,18 +228,10 @@ pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         None => return None\n     };\n \n-    match fn_like.kind() {\n-        FnKind::ItemFn(_, _, _, hir::Constness::Const, ..) => {\n-            Some(fn_like)\n-        }\n-        FnKind::Method(_, m, ..) => {\n-            if m.constness == hir::Constness::Const {\n-                Some(fn_like)\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None\n+    if fn_like.constness() == hir::Constness::Const {\n+        Some(ConstFnNode::Local(fn_like))\n+    } else {\n+        None\n     }\n }\n \n@@ -868,15 +864,22 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), fn_like.body())\n-          } else {\n-              signal!(e, NonConstPath)\n+          let (arg_defs, body_id) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), ii.body.expr_id()),\n+              Some(ConstFnNode::Local(fn_like)) =>\n+                  (fn_like.decl().inputs.iter()\n+                   .map(|arg| match arg.pat.node {\n+                       hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+                       _ => None\n+                   }).collect(),\n+                   fn_like.body()),\n+              None => signal!(e, NonConstPath),\n           };\n-          assert_eq!(decl.inputs.len(), args.len());\n+          let result = tcx.map.expr(body_id);\n+          assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n-          for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+          for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n               let arg_val = eval_const_expr_partial(\n                   tcx,\n@@ -885,7 +888,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              if let PatKind::Binding(_, def_id, _, _) = arg.pat.node {\n+              if let Some(def_id) = arg {\n                 assert!(call_args.insert(def_id, arg_val).is_none());\n               }\n           }\n@@ -1068,11 +1071,13 @@ fn infer<'a, 'tcx>(i: ConstInt,\n     }\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                ti: &'tcx hir::TraitItem,\n-                                                trait_id: DefId,\n-                                                rcvr_substs: &'tcx Substs<'tcx>)\n-                                                -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item_id: DefId,\n+    default_value: Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+) -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n@@ -1103,21 +1108,16 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n+                let name = tcx.associated_item(trait_item_id).name;\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == ti.name);\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n-                    None => match ti.node {\n-                        hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                            Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n-                        },\n-                        _ => None,\n-                    },\n+                    None => default_value,\n                 }\n             }\n             _ => {\n-            span_bug!(ti.span,\n-                      \"resolve_trait_associated_const: unexpected vtable type\")\n+                bug!(\"resolve_trait_associated_const: unexpected vtable type\")\n             }\n         }\n     })"}, {"sha": "f85077766516d940a8264dec6fc63a3168a7daad", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -696,13 +696,16 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       code: blocks::Code,\n+                                       code: blocks::Code<'tcx>,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n                                        -> io::Result<()> {\n     let cfg = match code {\n         blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n-        blocks::Code::FnLike(fn_like) => cfg::CFG::new(tcx, fn_like.body()),\n+        blocks::Code::FnLike(fn_like) => {\n+            let body = tcx.map.expr(fn_like.body());\n+            cfg::CFG::new(tcx, body)\n+        },\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {"}, {"sha": "4595a940f100d4e9596d198bd74f359d9b798cad", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -34,7 +34,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n@@ -149,19 +149,30 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n     {\n         assert!(def_id.is_local());\n         debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n+        self.calculate_def_hash(DepNode::Hir(def_id), false, &mut walk_op);\n+        self.calculate_def_hash(DepNode::HirBody(def_id), true, &mut walk_op);\n+    }\n+\n+    fn calculate_def_hash<W>(&mut self,\n+                             dep_node: DepNode<DefId>,\n+                             hash_bodies: bool,\n+                             walk_op: &mut W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+    {\n         let mut state = IchHasher::new();\n         walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n                                                    self.tcx,\n                                                    &mut self.def_path_hashes,\n                                                    &mut self.codemap,\n-                                                   self.hash_spans));\n+                                                   self.hash_spans,\n+                                                   hash_bodies));\n         let bytes_hashed = state.bytes_hashed();\n         let item_hash = state.finish();\n-        self.hashes.insert(DepNode::Hir(def_id), item_hash);\n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n+        debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n+        self.hashes.insert(dep_node, item_hash);\n \n         let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n-                           bytes_hashed;\n+            bytes_hashed;\n         self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n@@ -200,7 +211,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n                                                             self.tcx,\n                                                             &mut self.def_path_hashes,\n                                                             &mut self.codemap,\n-                                                            self.hash_spans);\n+                                                            self.hash_spans,\n+                                                            false);\n             visitor.hash_attributes(&krate.attrs);\n         }\n \n@@ -212,6 +224,10 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n \n \n impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.calculate_node_id(item.id, |v| v.visit_item(item));\n         visit::walk_item(self, item);"}, {"sha": "681ad2efa0c14bf250b216ea03c0728be0e989e5", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -52,14 +52,16 @@ pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     hash_spans: bool,\n     codemap: &'a mut CachingCodemapView<'tcx>,\n     overflow_checks_enabled: bool,\n+    hash_bodies: bool,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     pub fn new(st: &'a mut IchHasher,\n                tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n                def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n                codemap: &'a mut CachingCodemapView<'tcx>,\n-               hash_spans: bool)\n+               hash_spans: bool,\n+               hash_bodies: bool)\n                -> Self {\n         let check_overflow = tcx.sess.opts.debugging_opts.force_overflow_checks\n             .unwrap_or(tcx.sess.opts.debug_assertions);\n@@ -71,6 +73,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             hash_spans: hash_spans,\n             codemap: codemap,\n             overflow_checks_enabled: check_overflow,\n+            hash_bodies: hash_bodies,\n         }\n     }\n \n@@ -459,15 +462,16 @@ fn saw_ty(node: &Ty_) -> SawTyComponent {\n #[derive(Hash)]\n enum SawTraitOrImplItemComponent {\n     SawTraitOrImplItemConst,\n-    SawTraitOrImplItemMethod(Unsafety, Constness, Abi),\n+    // The boolean signifies whether a body is present\n+    SawTraitOrImplItemMethod(Unsafety, Constness, Abi, bool),\n     SawTraitOrImplItemType\n }\n \n fn saw_trait_item(ti: &TraitItem_) -> SawTraitOrImplItemComponent {\n     match *ti {\n         ConstTraitItem(..) => SawTraitOrImplItemConst,\n-        MethodTraitItem(ref sig, _) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi),\n+        MethodTraitItem(ref sig, ref body) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, body.is_some()),\n         TypeTraitItem(..) => SawTraitOrImplItemType\n     }\n }\n@@ -476,7 +480,7 @@ fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n     match *ii {\n         ImplItemKind::Const(..) => SawTraitOrImplItemConst,\n         ImplItemKind::Method(ref sig, _) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi),\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n         ImplItemKind::Type(..) => SawTraitOrImplItemType\n     }\n }\n@@ -509,6 +513,14 @@ macro_rules! hash_span {\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n+        if self.hash_bodies {\n+            visit::NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        } else {\n+            visit::NestedVisitorMap::None\n+        }\n+    }\n+\n     fn visit_variant_data(&mut self,\n                           s: &'tcx VariantData,\n                           name: Name,\n@@ -609,7 +621,8 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, n: NodeId) {\n         debug!(\"visit_mod: st={:?}\", self.st);\n-        SawMod.hash(self.st); visit::walk_mod(self, m, n)\n+        SawMod.hash(self.st);\n+        visit::walk_mod(self, m, n)\n     }\n \n     fn visit_ty(&mut self, t: &'tcx Ty) {"}, {"sha": "40873011a7b8d7fc73aaa76fa17fc9c75b91a8ac", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -114,7 +114,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n         match dep_node {\n             DepNode::Krate |\n-            DepNode::Hir(_) => {\n+            DepNode::Hir(_) |\n+            DepNode::HirBody(_) => {\n                 // HIR nodes are inputs, so if we are asserting that the HIR node is\n                 // dirty, we check the dirty input set.\n                 if !self.dirty_inputs.contains(&dep_node) {\n@@ -143,7 +144,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n         match dep_node {\n             DepNode::Krate |\n-            DepNode::Hir(_) => {\n+            DepNode::Hir(_) |\n+            DepNode::HirBody(_) => {\n                 // For HIR nodes, check the inputs.\n                 if self.dirty_inputs.contains(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);"}, {"sha": "562efa4b0d2a8c2e720389fe1309475c0daf516b", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -45,7 +45,9 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n         match *dep_node {\n             DepNode::Krate |\n-            DepNode::Hir(_) => true,\n+            DepNode::Hir(_) |\n+            DepNode::HirBody(_) =>\n+                true,\n             DepNode::MetaData(def_id) => !def_id.is_local(),\n             _ => false,\n         }\n@@ -58,7 +60,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n-            DepNode::Hir(def_id) => {\n+            DepNode::Hir(def_id) | DepNode::HirBody(def_id) => {\n                 assert!(def_id.is_local(),\n                         \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n                         def_id,"}, {"sha": "05e21aa19b1b8870c6841a3f5af68e4ffc879344", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -145,8 +145,8 @@ pub fn encode_dep_graph(preds: &Predecessors,\n     for (&target, sources) in &preds.inputs {\n         match *target {\n             DepNode::MetaData(ref def_id) => {\n-                // Metadata *targets* are always local metadata nodes. We handle\n-                // those in `encode_metadata_hashes`, which comes later.\n+                // Metadata *targets* are always local metadata nodes. We have\n+                // already handled those in `encode_metadata_hashes`.\n                 assert!(def_id.is_local());\n                 continue;\n             }"}, {"sha": "6598b7dcc527faff76d00f6bf3fc19020be69309", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::map as ast_map;\n \n-use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n+use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange, NestedVisitorMap};\n \n use cstore::CrateMetadata;\n use encoder::EncodeContext;\n@@ -43,13 +43,9 @@ enum TableEntry<'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef) -> Lazy<Ast<'tcx>> {\n-        let mut id_visitor = IdRangeComputingVisitor::new();\n-        match ii {\n-            InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n-            InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii),\n-        }\n+    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef<'tcx>) -> Lazy<Ast<'tcx>> {\n+        let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n+        ii.visit(&mut id_visitor);\n \n         let ii_pos = self.position();\n         ii.encode(self).unwrap();\n@@ -60,11 +56,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 ecx: self,\n                 count: 0,\n             };\n-            match ii {\n-                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii),\n-            }\n+            ii.visit(&mut visitor);\n             visitor.count\n         };\n \n@@ -81,7 +73,11 @@ struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     count: usize,\n }\n \n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.ecx.tcx.map)\n+    }\n+\n     fn visit_id(&mut self, id: ast::NodeId) {\n         debug!(\"Encoding side tables for id {}\", id);\n \n@@ -122,17 +118,13 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                      }];\n \n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n+    let item_node_id = tcx.sess.next_node_id();\n     let ii = ast_map::map_decoded_item(&tcx.map,\n                                        parent_def_path,\n                                        parent_did,\n                                        ii,\n-                                       tcx.sess.next_node_id());\n+                                       item_node_id);\n \n-    let item_node_id = match ii {\n-        &InlinedItem::Item(_, ref i) => i.id,\n-        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-    };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     let ty = tcx.item_type(orig_did);\n     let generics = tcx.item_generics(orig_did);"}, {"sha": "573b2f6d2a60cd9c500ecc820f9954dd3fc6785d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -443,12 +443,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n         let find_inlined_item_root = |inlined_item_id| {\n             let mut node = inlined_item_id;\n-            let mut path = Vec::with_capacity(10);\n \n             // If we can't find the inline root after a thousand hops, we can\n             // be pretty sure there's something wrong with the HIR map.\n             for _ in 0 .. 1000 {\n-                path.push(node);\n                 let parent_node = tcx.map.get_parent_node(node);\n                 if parent_node == node {\n                     return node;\n@@ -464,27 +462,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            Some(&InlinedItem::Item(d, ref item)) => {\n-                assert_eq!(d, def_id);\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n-            }\n-            Some(&InlinedItem::TraitItem(_, ref trait_item)) => {\n-                let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n-                cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n-\n-                // Associated consts already have to be evaluated in `typeck`, so\n-                // the logic to do that already exists in `middle`. In order to\n-                // reuse that code, it needs to be able to look up the traits for\n-                // inlined items.\n-                let ty_trait_item = tcx.associated_item(def_id).clone();\n-                let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-                tcx.associated_items.borrow_mut()\n-                   .insert(trait_item_def_id, ty_trait_item);\n-            }\n-            Some(&InlinedItem::ImplItem(_, ref impl_item)) => {\n-                let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n-                cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n+            Some(&InlinedItem { ref body, .. }) => {\n+                let inlined_root_node_id = find_inlined_item_root(body.id);\n+                cache_inlined_item(def_id, inlined_root_node_id, inlined_root_node_id);\n             }\n         }\n "}, {"sha": "4839c409335ea8fb5dfbba579cbfca491b10bfd8", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -39,7 +39,7 @@ use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n use super::index_builder::{FromId, IndexBuilder, Untracked};\n@@ -516,9 +516,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if trait_item.kind == ty::AssociatedKind::Const {\n+            ast: if let hir::ConstTraitItem(_, Some(_)) = ast_item.node {\n+                // We only save the HIR for associated consts with bodies\n+                // (InlinedItemRef::from_trait_item panics otherwise)\n                 let trait_def_id = trait_item.container.id();\n-                Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n+                Some(self.encode_inlined_item(\n+                    InlinedItemRef::from_trait_item(trait_def_id, ast_item, tcx)\n+                ))\n             } else {\n                 None\n             },\n@@ -527,6 +531,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n+\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -587,7 +593,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: if ast {\n-                Some(self.encode_inlined_item(InlinedItemRef::ImplItem(impl_def_id, ast_item)))\n+                Some(self.encode_inlined_item(\n+                    InlinedItemRef::from_impl_item(impl_def_id, ast_item, tcx)\n+                ))\n             } else {\n                 None\n             },\n@@ -630,7 +638,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n-    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"encoding info for item at {}\",\n@@ -817,7 +825,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ast: match item.node {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n-                    Some(self.encode_inlined_item(InlinedItemRef::Item(def_id, item)))\n+                    Some(self.encode_inlined_item(\n+                        InlinedItemRef::from_item(def_id, item, tcx)\n+                    ))\n                 }\n                 _ => None,\n             },\n@@ -973,6 +983,9 @@ struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.index.tcx.map)\n+    }\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n         self.index.encode_info_for_expr(ex);"}, {"sha": "94bf8936fe61b893e1c98de0752f2c9321934c78", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -736,7 +736,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n                     match expr.node {\n-                        hir::ExprClosure(.., ref body, _) => body.id,\n+                        hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n                         _ => {\n                             span_bug!(expr.span, \"closure expr is not a closure expr\");\n                         }"}, {"sha": "32639cc3f86965a50350356ba67410e9faa365c3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -23,7 +23,6 @@ use rustc_const_eval as const_eval;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n@@ -51,11 +50,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n-                match fn_like.map(|f| f.kind()) {\n-                    Some(FnKind::ItemFn(_, _, _, c, ..)) => c,\n-                    Some(FnKind::Method(_, m, ..)) => m.constness,\n-                    _ => hir::Constness::NotConst\n-                }\n+                fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n             MirSource::Promoted(..) => bug!()\n         };"}, {"sha": "88d02d7d004c9b6f20222122683b70a08202780a", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -30,7 +30,7 @@ use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -144,6 +144,10 @@ impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n     // Const and static items.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n@@ -210,7 +214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Expr,\n+                body_id: hir::ExprId,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n@@ -223,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n         };\n \n         let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n-            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body.id), None)))\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id()), None)))\n         } else {\n             let def_id = self.tcx.map.local_def_id(id);\n             (self.tcx.item_type(def_id).fn_abi(), None)\n@@ -237,12 +241,14 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                     (fn_sig.inputs[index], Some(&*arg.pat))\n                 });\n \n+        let body = self.tcx.map.expr(body_id);\n+\n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n             build::construct_fn(cx, id, arguments, abi, fn_sig.output, body)\n         });\n \n-        intravisit::walk_fn(self, fk, decl, body, span, id);\n+        intravisit::walk_fn(self, fk, decl, body_id, span, id);\n     }\n }\n "}, {"sha": "57929879f94025752ce00801351760880240cda1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty};\n@@ -116,15 +115,10 @@ impl fmt::Display for Mode {\n \n pub fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n-        match fn_like.map(|f| f.kind()) {\n-            Some(FnKind::ItemFn(_, _, _, c, ..)) => {\n-                c == hir::Constness::Const\n-            }\n-            Some(FnKind::Method(_, m, ..)) => {\n-                m.constness == hir::Constness::Const\n-            }\n-            _ => false\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.map.get(node_id)) {\n+            fn_like.constness() == hir::Constness::Const\n+        } else {\n+            false\n         }\n     } else {\n         tcx.sess.cstore.is_const_fn(def_id)"}, {"sha": "86f56d003584155205fe623628809f055c4deefb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -27,7 +27,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n-use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n+use rustc_const_eval::{ConstFnNode, eval_const_expr_partial, lookup_const_by_id};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n@@ -48,7 +48,7 @@ use rustc::lint::builtin::CONST_ERR;\n use rustc::hir::{self, PatKind};\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n@@ -100,7 +100,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n             .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n     }\n \n-    fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {\n+    fn global_expr(&mut self, mode: Mode, expr: &'gcx hir::Expr) -> ConstQualif {\n         assert!(mode != Mode::Var);\n         match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n             Entry::Occupied(entry) => return *entry.get(),\n@@ -132,9 +132,9 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n \n     fn fn_like(&mut self,\n-               fk: FnKind,\n-               fd: &hir::FnDecl,\n-               b: &hir::Expr,\n+               fk: FnKind<'gcx>,\n+               fd: &'gcx hir::FnDecl,\n+               b: hir::ExprId,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -160,7 +160,8 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         };\n \n         let qualif = self.with_mode(mode, |this| {\n-            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n+            let body = this.tcx.map.expr(b);\n+            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, body));\n             intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n             this.qualif\n         });\n@@ -179,21 +180,39 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n-        if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n-            let qualif = self.fn_like(fn_like.kind(),\n-                                      fn_like.decl(),\n-                                      fn_like.body(),\n-                                      fn_like.span(),\n-                                      fn_like.id());\n-            self.add_qualif(qualif);\n+        match lookup_const_fn_by_id(self.tcx, def_id) {\n+            Some(ConstFnNode::Local(fn_like)) => {\n+                let qualif = self.fn_like(fn_like.kind(),\n+                                          fn_like.decl(),\n+                                          fn_like.body(),\n+                                          fn_like.span(),\n+                                          fn_like.id());\n \n-            if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                self.add_qualif(ConstQualif::MUTABLE_MEM);\n-            }\n+                self.add_qualif(qualif);\n+\n+                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n+                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n+\n+                true\n+            },\n+            Some(ConstFnNode::Inlined(ii)) => {\n+                let node_id = ii.body.id;\n+\n+                let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n+                    Entry::Occupied(entry) => *entry.get(),\n+                    _ => bug!(\"const qualif entry missing for inlined item\")\n+                };\n \n-            true\n-        } else {\n-            false\n+                self.add_qualif(qualif);\n+\n+                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n+                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n+\n+                true\n+            },\n+            None => false\n         }\n     }\n \n@@ -213,8 +232,12 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item) {\n         debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n         assert_eq!(self.mode, Mode::Var);\n         match i.node {\n@@ -240,7 +263,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, t: &'v hir::TraitItem) {\n+    fn visit_trait_item(&mut self, t: &'tcx hir::TraitItem) {\n         match t.node {\n             hir::ConstTraitItem(_, ref default) => {\n                 if let Some(ref expr) = *default {\n@@ -253,7 +276,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_impl_item(&mut self, i: &'v hir::ImplItem) {\n+    fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n         match i.node {\n             hir::ImplItemKind::Const(_, ref expr) => {\n                 self.global_expr(Mode::Const, &expr);\n@@ -263,15 +286,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self,\n-                fk: FnKind<'v>,\n-                fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr,\n+                fk: FnKind<'tcx>,\n+                fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         match p.node {\n             PatKind::Lit(ref lit) => {\n                 self.global_expr(Mode::Const, &lit);\n@@ -296,7 +319,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_block(&mut self, block: &hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n         // Check all statements in the block\n         for stmt in &block.stmts {\n             match stmt.node {\n@@ -315,7 +338,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         intravisit::walk_block(self, block);\n     }\n \n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n "}, {"sha": "b7858013988953dd11f200698545d63ce65d91a7", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -106,7 +106,7 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'v> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n \n@@ -172,7 +172,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: hir_visit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr,\n+                b: hir::ExprId,\n                 s: Span,\n                 id: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);"}, {"sha": "10f464a9901d0beebb54f19fc72c9852f70447fe", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -13,7 +13,7 @@ use rustc::session::Session;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -59,16 +59,20 @@ pub fn check_crate(sess: &Session, map: &Map) {\n     }.as_deep_visitor());\n }\n \n-impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n+impl<'a, 'ast> Visitor<'ast> for CheckLoopVisitor<'a, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n-    fn visit_impl_item(&mut self, i: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, i: &'ast hir::ImplItem) {\n         self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'ast hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n                 self.with_context(Loop(LoopKind::WhileLoop), |v| {\n@@ -79,8 +83,8 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n             hir::ExprLoop(ref b, _, source) => {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n-            hir::ExprClosure(.., ref b, _) => {\n-                self.with_context(Closure, |v| v.visit_expr(&b));\n+            hir::ExprClosure(.., b, _) => {\n+                self.with_context(Closure, |v| v.visit_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {"}, {"sha": "ddb5af1e80c345a00973628fb3cb1a4a97051034", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::traits::Reveal;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -31,11 +31,15 @@ struct RvalueContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n     fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'v>,\n-                fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr,\n+                fk: intravisit::FnKind<'tcx>,\n+                fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context\n@@ -46,8 +50,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 tcx: infcx.tcx,\n                 param_env: &param_env\n             };\n+            let body = infcx.tcx.map.expr(b);\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.walk_fn(fd, b);\n+            euv.walk_fn(fd, body);\n         });\n         intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n     }"}, {"sha": "ffb5045fe3b07efb13a45841c9bd80739672a993", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -20,7 +20,7 @@ use rustc::util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n use std::cell::RefCell;\n@@ -36,6 +36,10 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_item(&mut self, it: &'ast hir::Item) {\n         match it.node {\n             hir::ItemStatic(..) |\n@@ -200,6 +204,10 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.ast_map)\n+    }\n+\n     fn visit_item(&mut self, it: &'ast hir::Item) {\n         self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it), it.span);\n     }"}, {"sha": "8b8172bf5b5c203b423950512a0e7e83103f1c01", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -30,7 +30,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n@@ -120,8 +120,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -432,8 +432,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -615,6 +615,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = ty.node {\n             if self.inner.path_is_private_type(path) {\n@@ -640,8 +644,8 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -1059,8 +1063,12 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n         let min = |vis1: ty::Visibility, vis2| {\n             if vis1.is_at_least(vis2, &tcx.map) { vis2 } else { vis1 }\n@@ -1163,11 +1171,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n         }\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {\n         // handled in `visit_item` above\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             // Check the traits being exposed, as they're separate,\n             // e.g. `impl Iterator<Item=T>` has two predicates,\n@@ -1181,9 +1189,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n     }\n \n     // Don't recurse into expressions in array sizes or const initializers\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n     // Don't recurse into patterns in function arguments\n-    fn visit_pat(&mut self, _: &hir::Pat) {}\n+    fn visit_pat(&mut self, _: &'tcx hir::Pat) {}\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "9ed5a5d148cd62410cd608a546524d3c96db189b", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -15,7 +15,7 @@\n //! paths etc in all kinds of annoying scenarios.\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::ast;\n \n use common::SharedCrateContext;\n@@ -67,6 +67,10 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id);\n         intravisit::walk_item(self, item);"}, {"sha": "0854ca3d1bb26577c9dac211c3ed1c49b25c71e9", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body: &'gcx hir::Expr,\n+                              body_id: hir::ExprId,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -37,6 +37,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n+        let body = self.tcx.map.expr(body_id);\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n "}, {"sha": "0c4e5e4fa0dfc4d88a1a99370d8ea079ea1ddbb8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -119,7 +119,7 @@ use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n@@ -538,6 +538,10 @@ struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.map)\n+    }\n+\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.ccx, i);\n         intravisit::walk_item(self, i);\n@@ -630,9 +634,11 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body: &'tcx hir::Expr,\n+                           body_id: hir::ExprId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n+    let body = ccx.tcx.map.expr(body_id);\n+\n     let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n@@ -643,13 +649,13 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n+        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id());\n         let fn_sig =\n             fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n         let fn_sig =\n             inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n         let fn_sig =\n-            inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+            inh.normalize_associated_types_in(body.span, body_id.node_id(), &fn_sig);\n \n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n@@ -659,7 +665,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, decl, body);\n+        fcx.regionck_fn(fn_id, decl, body_id);\n         fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n     });\n }\n@@ -694,6 +700,10 @@ impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::None\n+    }\n+\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'gcx hir::Local) {\n         let o_ty = match local.ty {\n@@ -750,7 +760,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: &'gcx hir::Expr, _: Span, _: ast::NodeId) { }\n+                _: hir::ExprId, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -911,8 +921,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n            ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n-      hir::ItemFn(ref decl, .., ref body) => {\n-        check_bare_fn(ccx, &decl, &body, it.id, it.span);\n+      hir::ItemFn(ref decl, .., body_id) => {\n+        check_bare_fn(ccx, &decl, body_id, it.id, it.span);\n       }\n       hir::ItemImpl(.., ref impl_item_refs) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n@@ -923,8 +933,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n                 }\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    check_bare_fn(ccx, &sig.decl, body, impl_item.id, impl_item.span);\n+                hir::ImplItemKind::Method(ref sig, body_id) => {\n+                    check_bare_fn(ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     // Nothing to do here.\n@@ -938,8 +948,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n                     check_const(ccx, &expr, trait_item.id)\n                 }\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    check_bare_fn(ccx, &sig.decl, body, trait_item.id, trait_item.span);\n+                hir::MethodTraitItem(ref sig, Some(body_id)) => {\n+                    check_bare_fn(ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n                 }\n                 hir::MethodTraitItem(_, None) |\n                 hir::ConstTraitItem(_, None) |\n@@ -1102,14 +1112,14 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(_, ref body) => {\n+                hir::ImplItemKind::Method(_, body_id) => {\n                     let trait_span = tcx.map.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body.id,\n+                                            body_id.node_id(),\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1119,7 +1129,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             compare_impl_method(ccx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body.id,\n+                                                body_id.node_id(),\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,\n@@ -3791,8 +3801,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n-          hir::ExprClosure(capture, ref decl, ref body, _) => {\n-              self.check_expr_closure(expr, capture, &decl, &body, expected)\n+          hir::ExprClosure(capture, ref decl, body_id, _) => {\n+              self.check_expr_closure(expr, capture, &decl, body_id, expected)\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected)"}, {"sha": "3cc99b6e4e5aa3672821af4ace6ef85739c7f455", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -99,7 +99,7 @@ use std::mem;\n use std::ops::Deref;\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n use self::SubjectNode::Subject;\n@@ -113,7 +113,7 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn regionck_expr(&self, e: &hir::Expr) {\n+    pub fn regionck_expr(&self, e: &'gcx hir::Expr) {\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n@@ -141,13 +141,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Expr) {\n+                       body_id: hir::ExprId) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(body.id), body.id, Subject(fn_id));\n+        let node_id = body_id.node_id();\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, decl, body_id, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -267,14 +268,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n-                     body: &hir::Expr,\n+                     body_id: hir::ExprId,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n         let call_site = self.tcx.region_maps.lookup_code_extent(\n-            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -300,19 +301,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                          .chain(Some(fn_sig.output))\n                          .collect();\n \n-        let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body.id),\n+        let old_body_id = self.set_body_id(body_id.node_id());\n+        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id(), span);\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id()),\n                           &fn_decl.inputs[..]);\n+        let body = self.tcx.map.expr(body_id);\n         self.visit_expr(body);\n-        self.visit_region_obligations(body.id);\n+        self.visit_region_obligations(body_id.node_id());\n \n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n                body.id, call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body.id,\n+                                       body_id.node_id(),\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -469,7 +471,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -478,29 +480,33 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, fd: &'gcx hir::FnDecl,\n+                b: hir::ExprId, span: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, fd, b, span)\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'gcx hir::Arm) {\n         // see above\n         for p in &arm.pats {\n             self.constrain_bindings_in_pat(p);\n         }\n         intravisit::walk_arm(self, arm);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'gcx hir::Local) {\n         // see above\n         self.constrain_bindings_in_pat(&l.pat);\n         self.link_local(l);\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n                expr, self.repeating_scope);\n \n@@ -737,8 +743,8 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., ref body, _) => {\n-                self.check_expr_fn_block(expr, &body);\n+            hir::ExprClosure(.., body_id, _) => {\n+                self.check_expr_fn_block(expr, body_id);\n             }\n \n             hir::ExprLoop(ref body, _, _) => {\n@@ -823,9 +829,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_expr_fn_block(&mut self,\n-                           expr: &hir::Expr,\n-                           body: &hir::Expr) {\n-        let repeating_scope = self.set_repeating_scope(body.id);\n+                           expr: &'gcx hir::Expr,\n+                           body_id: hir::ExprId) {\n+        let repeating_scope = self.set_repeating_scope(body_id.node_id());\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }"}, {"sha": "63d20416bded57bddc768bd720962c6975df04b9", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -50,14 +50,14 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::NodeMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze(&self, body: &hir::Expr) {\n+    pub fn closure_analyze(&self, body: &'gcx hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n \n@@ -77,11 +77,15 @@ struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, ref body, _) => {\n-                self.check_closure(expr, cc, &body);\n+            hir::ExprClosure(cc, _, body_id, _) => {\n+                self.check_closure(expr, cc, body_id);\n             }\n \n             _ => { }\n@@ -99,7 +103,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause,\n-                     _body: &hir::Expr)\n+                     _body_id: hir::ExprId)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -153,14 +157,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Expr) {\n+                       body_id: hir::ExprId) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body_id);\n \n         {\n+            let body = self.fcx.tcx.map.expr(body_id);\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n@@ -484,11 +489,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+    }\n+\n     fn visit_fn(&mut self,\n-                fn_kind: intravisit::FnKind<'v>,\n-                decl: &'v hir::FnDecl,\n-                body: &'v hir::Expr,\n+                fn_kind: intravisit::FnKind<'gcx>,\n+                decl: &'gcx hir::FnDecl,\n+                body: hir::ExprId,\n                 span: Span,\n                 id: ast::NodeId)\n     {"}, {"sha": "b6d0ff03a07abb87953446b1b6ba714b5563cbdf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -23,7 +23,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n@@ -127,8 +127,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n             }\n-            hir::ItemFn(.., ref body) => {\n-                self.check_item_fn(item, body);\n+            hir::ItemFn(.., body_id) => {\n+                self.check_item_fn(item, body_id);\n             }\n             hir::ItemStatic(..) => {\n                 self.check_item_type(item);\n@@ -347,7 +347,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body: &hir::Expr)\n+                     body_id: hir::ExprId)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -364,7 +364,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body.id);\n+            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id());\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds\n@@ -609,6 +609,10 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n }\n \n impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n         self.check_item_well_formed(i);"}, {"sha": "84b0303e5cfbb4a9fa97b76ff740c188613b07b9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -27,14 +27,14 @@ use syntax::ast;\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc::hir::print::pat_to_string;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr, item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_expr(&self, e: &'gcx hir::Expr, item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_expr(e);\n@@ -47,8 +47,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_in_fn(&self,\n-                                   decl: &hir::FnDecl,\n-                                   body: &hir::Expr,\n+                                   decl: &'gcx hir::FnDecl,\n+                                   body: &'gcx hir::Expr,\n                                    item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n@@ -186,8 +186,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_stmt(&mut self, s: &hir::Stmt) {\n+impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -196,7 +200,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_stmt(self, s);\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -216,7 +220,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_expr(self, e);\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'gcx hir::Block) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -225,7 +229,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_block(self, b);\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -240,7 +244,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'gcx hir::Local) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -251,7 +255,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n         match t.node {\n             hir::TyArray(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);"}, {"sha": "abbf5601484bc46641a6e51e557cb8ca4daa4a36", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -385,7 +385,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n         self.check_item(item);\n     }\n \n-\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "011c82625186f338320451ed8f8758914289ed96", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -83,7 +83,7 @@ use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, map as hir_map, print as pprust};\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n \n@@ -128,13 +128,66 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        convert_item(self.ccx, item);\n+impl<'a, 'tcx> CollectItemTypesVisitor<'a, 'tcx> {\n+    /// Collect item types is structured into two tasks. The outer\n+    /// task, `CollectItem`, walks the entire content of an item-like\n+    /// thing, including its body. It also spawns an inner task,\n+    /// `CollectItemSig`, which walks only the signature. This inner\n+    /// task is the one that writes the item-type into the various\n+    /// maps.  This setup ensures that the item body is never\n+    /// accessible to the task that computes its signature, so that\n+    /// changes to the body don't affect the signature.\n+    ///\n+    /// Consider an example function `foo` that also has a closure in its body:\n+    ///\n+    /// ```\n+    /// fn foo(<sig>) {\n+    ///     ...\n+    ///     let bar = || ...; // we'll label this closure as \"bar\" below\n+    /// }\n+    /// ```\n+    ///\n+    /// This results in a dep-graph like so. I've labeled the edges to\n+    /// document where they arise.\n+    ///\n+    /// ```\n+    /// [HirBody(foo)] -2--> [CollectItem(foo)] -4-> [ItemSignature(bar)]\n+    ///                       ^           ^\n+    ///                       1           3\n+    /// [Hir(foo)] -----------+-6-> [CollectItemSig(foo)] -5-> [ItemSignature(foo)]\n+    /// ```\n+    ///\n+    /// 1. This is added by the `visit_all_item_likes_in_krate`.\n+    /// 2. This is added when we fetch the item body.\n+    /// 3. This is added because `CollectItem` launches `CollectItemSig`.\n+    ///    - it is arguably false; if we refactor the `with_task` system;\n+    ///      we could get probably rid of it, but it is also harmless enough.\n+    /// 4. This is added by the code in `visit_expr` when we write to `item_types`.\n+    /// 5. This is added by the code in `convert_item` when we write to `item_types`;\n+    ///    note that this write occurs inside the `CollectItemSig` task.\n+    /// 6. Added by explicit `read` below\n+    fn with_collect_item_sig<OP>(&self, id: ast::NodeId, op: OP)\n+        where OP: FnOnce()\n+    {\n+        let def_id = self.ccx.tcx.map.local_def_id(id);\n+        self.ccx.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), || {\n+            self.ccx.tcx.map.read(id);\n+            op();\n+        });\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.with_collect_item_sig(item.id, || convert_item(self.ccx, item));\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n             let def_id = self.ccx.tcx.map.local_def_id(expr.id);\n             generics_of_def_id(self.ccx, def_id);\n@@ -143,16 +196,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n             generics_of_def_id(self.ccx, def_id);\n         }\n         intravisit::walk_ty(self, ty);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n-        convert_impl_item(self.ccx, impl_item);\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.with_collect_item_sig(impl_item.id, || {\n+            convert_impl_item(self.ccx, impl_item)\n+        });\n         intravisit::walk_impl_item(self, impl_item);\n     }\n }"}, {"sha": "009330065f3c2000ab0249419fc5137df8de743e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -489,8 +489,8 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n }\n \n impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'hir>> {\n-        Some(self.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'hir> {\n+        intravisit::NestedVisitorMap::All(&self.map)\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {"}, {"sha": "4d9ca77969bd7359e7f4f71f6816f5c7e3cc561e", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -23,18 +23,16 @@\n #![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n \n-// FIXME(#37720) these two should be reused, but data gets entangled across crates\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n \n extern crate point;\n \n /// A fn item that calls (public) methods on `Point` from the same impl which changed\n mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    // FIXME(#37720) data gets entangled across crates\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -45,8 +43,7 @@ mod fn_calls_methods_in_same_impl {\n mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    // FIXME(#37720) data gets entangled across crates\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn dirty() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);"}, {"sha": "e0047e5ec6455aa805b60c183ee43175fb90918d", "filename": "src/test/incremental/change_pub_inherent_method_body/struct_point.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -19,9 +19,7 @@\n \n #![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n \n-// FIXME(#35078) -- this gets recompiled because we don't separate sig from body\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_changed_method\", cfg=\"rpass2\")]\n-\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_changed_method\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_calls_another_method\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n@@ -52,8 +50,7 @@ mod point {\n mod fn_calls_changed_method {\n     use point::Point;\n \n-    // FIXME(#35078) -- this gets recompiled because we don't separate sig from body\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.distance_from_origin();"}, {"sha": "647ff5dedf3dd225b83f23e0fe6d3f2cacce8005", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ pub fn change_callee_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_callee_function() {\n     callee2(1, 2)\n@@ -53,9 +55,11 @@ pub fn change_argument_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_function() {\n     callee1(1, 3)\n@@ -70,9 +74,11 @@ mod change_callee_indirectly_function {\n     #[cfg(not(cfail1))]\n     use super::callee2 as callee;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_callee_indirectly_function() {\n         callee(1, 2)\n@@ -94,9 +100,11 @@ pub fn change_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_callee_method() {\n     let s = Struct;\n@@ -113,9 +121,11 @@ pub fn change_argument_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_method() {\n     let s = Struct;\n@@ -132,9 +142,11 @@ pub fn change_ufcs_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_ufcs_callee_method() {\n     let s = Struct;\n@@ -151,9 +163,11 @@ pub fn change_argument_method_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_method_ufcs() {\n     let s = Struct;\n@@ -170,9 +184,11 @@ pub fn change_to_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_to_ufcs() {\n     let s = Struct;\n@@ -192,9 +208,11 @@ mod change_ufcs_callee_indirectly {\n     #[cfg(not(cfail1))]\n     use super::Struct2 as Struct;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_ufcs_callee_indirectly() {\n         let s = Struct;"}, {"sha": "bae3c9bf5965de9bd06d7dcac81ca405020ab24e", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_body() {\n     let mut _x = 0;\n@@ -61,9 +63,11 @@ fn change_iteration_variable_name() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_iteration_variable_name() {\n     let mut _x = 0;\n@@ -86,9 +90,11 @@ fn change_iteration_variable_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n@@ -111,9 +117,11 @@ fn change_iterable() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_iterable() {\n     let mut _x = 0;\n@@ -135,9 +143,11 @@ fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_break() {\n     let mut _x = 0;\n@@ -160,9 +170,11 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label() {\n     let mut _x = 0;\n@@ -185,9 +197,11 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -212,9 +226,11 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_break_label() {\n     let mut _x = 0;\n@@ -239,9 +255,11 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -266,9 +284,11 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_label() {\n     let mut _x = 0;\n@@ -293,9 +313,11 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "c39eeab34c8f3dc2f9e076791027003bf2c3e35d", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ pub fn change_condition(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_condition(x: bool) -> u32 {\n     if !x {\n@@ -59,9 +61,11 @@ pub fn change_then_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_then_branch(x: bool) -> u32 {\n     if x {\n@@ -84,9 +88,11 @@ pub fn change_else_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_else_branch(x: bool) -> u32 {\n     if x {\n@@ -111,9 +117,11 @@ pub fn add_else_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_else_branch(x: bool) -> u32 {\n     let mut ret = 1;\n@@ -139,9 +147,11 @@ pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n     if let Some(_) = x {\n@@ -164,9 +174,11 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -189,9 +201,11 @@ pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -216,9 +230,11 @@ pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n     let mut ret = 1;"}, {"sha": "9e532548e11dd282af5a8cb8346f01ae49774825", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -32,9 +32,11 @@ pub fn change_name() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_name() {\n     let _y = 2u64;\n@@ -49,9 +51,11 @@ pub fn add_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;\n@@ -66,9 +70,11 @@ pub fn change_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_type() {\n     let _x: u8 = 2;\n@@ -83,9 +89,11 @@ pub fn change_mutability_of_reference_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;\n@@ -100,9 +108,11 @@ pub fn change_mutability_of_slot() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -117,9 +127,11 @@ pub fn change_simple_binding_to_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_simple_binding_to_pattern() {\n     let (_a, _b) = (0u8, 'x');\n@@ -134,9 +146,11 @@ pub fn change_name_in_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_name_in_pattern() {\n     let (_a, _c) = (1u8, 'y');\n@@ -151,9 +165,11 @@ pub fn add_ref_in_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_ref_in_pattern() {\n     let (ref _a, _b) = (1u8, 'y');\n@@ -168,9 +184,11 @@ pub fn add_amp_in_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_amp_in_pattern() {\n     let (&_a, _b) = (&1u8, 'y');\n@@ -185,9 +203,11 @@ pub fn change_mutability_of_binding_in_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern() {\n     let (mut _a, _b) = (99u8, 'q');\n@@ -202,9 +222,11 @@ pub fn add_initializer() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;\n@@ -219,9 +241,11 @@ pub fn change_initializer() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_initializer() {\n     let _x = 5u16;"}, {"sha": "da43ef3c461b7b3e3d9b6a16a22112f94178dc2c", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_body() {\n     let mut _x = 0;\n@@ -60,9 +62,11 @@ fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_break() {\n     let mut _x = 0;\n@@ -85,9 +89,11 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label() {\n     let mut _x = 0;\n@@ -110,9 +116,11 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -137,9 +145,11 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_break_label() {\n     let mut _x = 0;\n@@ -164,9 +174,11 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -191,9 +203,11 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_label() {\n     let mut _x = 0;\n@@ -218,9 +232,11 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "48f99b834ce17c4bddb412b3f7aba8fde4701626", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ pub fn add_arm(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_arm(x: u32) -> u32 {\n     match x {\n@@ -62,9 +64,11 @@ pub fn change_order_of_arms(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_order_of_arms(x: u32) -> u32 {\n     match x {\n@@ -87,9 +91,11 @@ pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -112,9 +118,11 @@ pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -137,9 +145,11 @@ pub fn add_at_binding(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_at_binding(x: u32) -> u32 {\n     match x {\n@@ -162,9 +172,11 @@ pub fn change_name_of_at_binding(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_name_of_at_binding(x: u32) -> u32 {\n     match x {\n@@ -186,9 +198,11 @@ pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -210,9 +224,11 @@ pub fn change_name_in_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_name_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -234,9 +250,11 @@ pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -257,9 +275,11 @@ pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -280,9 +300,11 @@ pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n     match (&x, x & 1) {\n@@ -304,9 +326,11 @@ pub fn change_rhs_of_arm(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_rhs_of_arm(x: u32) -> u32 {\n     match x {\n@@ -329,9 +353,11 @@ pub fn add_alternative_to_arm(x: u32) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn add_alternative_to_arm(x: u32) -> u32 {\n     match x {"}, {"sha": "5d4d434fd633f594b932c7442104534dc02f4ac5", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -34,9 +34,11 @@ pub fn indexing(slice: &[u8]) -> u8 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn indexing(slice: &[u8]) -> u8 {\n     slice[100]\n@@ -50,9 +52,11 @@ pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n     val + 1\n@@ -66,9 +70,11 @@ pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n     val - 1\n@@ -82,9 +88,11 @@ pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n     val * 2\n@@ -98,9 +106,11 @@ pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n     -val\n@@ -114,9 +124,11 @@ pub fn division_by_zero(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn division_by_zero(val: i32) -> i32 {\n     2 / val\n@@ -129,9 +141,11 @@ pub fn mod_by_zero(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn mod_by_zero(val: i32) -> i32 {\n     2 % val\n@@ -150,6 +164,8 @@ pub fn bitwise(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise(val: i32) -> i32 {\n@@ -166,6 +182,8 @@ pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {"}, {"sha": "b3fc8e2d36d1c8d75c6e5e6a6fb17225035ac474", "filename": "src/test/incremental/hashes/panic_exprs_no_overflow_checks.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -41,9 +41,11 @@ pub fn indexing(slice: &[u8]) -> u8 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn indexing(slice: &[u8]) -> u8 {\n     slice[100]\n@@ -58,9 +60,11 @@ pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[rustc_inherit_overflow_checks]\n pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n@@ -76,9 +80,11 @@ pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[rustc_inherit_overflow_checks]\n pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n@@ -94,9 +100,11 @@ pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[rustc_inherit_overflow_checks]\n pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n@@ -112,9 +120,11 @@ pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[rustc_inherit_overflow_checks]\n pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n@@ -129,9 +139,11 @@ pub fn division_by_zero(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn division_by_zero(val: i32) -> i32 {\n     2 / val\n@@ -144,9 +156,11 @@ pub fn mod_by_zero(val: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn mod_by_zero(val: i32) -> i32 {\n     2 % val\n@@ -165,6 +179,8 @@ pub fn bitwise(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise(val: i32) -> i32 {\n@@ -181,6 +197,8 @@ pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n@@ -196,6 +214,8 @@ pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n@@ -212,6 +232,8 @@ pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n@@ -228,6 +250,8 @@ pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n@@ -244,6 +268,8 @@ pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_negation(val: i32) -> i32 {"}, {"sha": "6a9f4698bf887ac1828600143a852f59cc3ae868", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -42,9 +42,11 @@ fn change_field_value_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -67,9 +69,11 @@ fn change_field_order_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_order_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -97,9 +101,11 @@ fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -134,9 +140,11 @@ fn change_field_label_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_label_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -171,9 +179,11 @@ fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct2 {\n@@ -212,9 +222,11 @@ fn change_field_value_tuple_struct() -> TupleStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_tuple_struct() -> TupleStruct {\n     TupleStruct(0, 1, 3)\n@@ -231,9 +243,11 @@ fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct2(0, 1, 2);"}, {"sha": "05b0dec4e7e8194c78b92b3d0f03132cdd7bc263", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 140, "deletions": 84, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -32,9 +32,11 @@ pub fn const_negation() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn const_negation() -> i32 {\n     -1\n@@ -49,9 +51,11 @@ pub fn const_bitwise_not() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn const_bitwise_not() -> i32 {\n     !99\n@@ -66,9 +70,11 @@ pub fn var_negation(x: i32, y: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn var_negation(x: i32, y: i32) -> i32 {\n     -y\n@@ -83,9 +89,11 @@ pub fn var_bitwise_not(x: i32, y: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn var_bitwise_not(x: i32, y: i32) -> i32 {\n     !y\n@@ -100,9 +108,11 @@ pub fn var_deref(x: &i32, y: &i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn var_deref(x: &i32, y: &i32) -> i32 {\n     *y\n@@ -117,9 +127,11 @@ pub fn first_const_add() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn first_const_add() -> i32 {\n     2 + 3\n@@ -134,9 +146,11 @@ pub fn second_const_add() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn second_const_add() -> i32 {\n     1 + 3\n@@ -151,9 +165,11 @@ pub fn first_var_add(a: i32, b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn first_var_add(a: i32, b: i32) -> i32 {\n     b + 2\n@@ -168,9 +184,11 @@ pub fn second_var_add(a: i32, b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn second_var_add(a: i32, b: i32) -> i32 {\n     1 + b\n@@ -185,9 +203,11 @@ pub fn plus_to_minus(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn plus_to_minus(a: i32) -> i32 {\n     1 - a\n@@ -202,9 +222,11 @@ pub fn plus_to_mult(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn plus_to_mult(a: i32) -> i32 {\n     1 * a\n@@ -219,9 +241,11 @@ pub fn plus_to_div(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn plus_to_div(a: i32) -> i32 {\n     1 / a\n@@ -236,9 +260,11 @@ pub fn plus_to_mod(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn plus_to_mod(a: i32) -> i32 {\n     1 % a\n@@ -253,9 +279,11 @@ pub fn and_to_or(a: bool, b: bool) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn and_to_or(a: bool, b: bool) -> bool {\n     a || b\n@@ -270,9 +298,11 @@ pub fn bitwise_and_to_bitwise_or(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_bitwise_or(a: i32) -> i32 {\n     1 | a\n@@ -287,9 +317,11 @@ pub fn bitwise_and_to_bitwise_xor(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_bitwise_xor(a: i32) -> i32 {\n     1 ^ a\n@@ -304,9 +336,11 @@ pub fn bitwise_and_to_lshift(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_lshift(a: i32) -> i32 {\n     a << 1\n@@ -321,9 +355,11 @@ pub fn bitwise_and_to_rshift(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_rshift(a: i32) -> i32 {\n     a >> 1\n@@ -338,9 +374,11 @@ pub fn eq_to_uneq(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn eq_to_uneq(a: i32) -> bool {\n     a != 1\n@@ -355,9 +393,11 @@ pub fn eq_to_lt(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn eq_to_lt(a: i32) -> bool {\n     a < 1\n@@ -372,9 +412,11 @@ pub fn eq_to_gt(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn eq_to_gt(a: i32) -> bool {\n     a > 1\n@@ -389,9 +431,11 @@ pub fn eq_to_le(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn eq_to_le(a: i32) -> bool {\n     a <= 1\n@@ -406,9 +450,11 @@ pub fn eq_to_ge(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn eq_to_ge(a: i32) -> bool {\n     a >= 1\n@@ -425,9 +471,11 @@ pub fn type_cast(a: u8) -> u64 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn type_cast(a: u8) -> u64 {\n     let b = a as u32;\n@@ -444,9 +492,11 @@ pub fn value_cast(a: u32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn value_cast(a: u32) -> i32 {\n     2 as i32\n@@ -464,9 +514,11 @@ pub fn lvalue() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn lvalue() -> i32 {\n     let mut x = 10;\n@@ -486,9 +538,11 @@ pub fn rvalue() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn rvalue() -> i32 {\n     let mut x = 10;\n@@ -505,9 +559,11 @@ pub fn index_to_slice(s: &[u8], i: usize, j: usize) -> u8 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfails2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfails3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn index_to_slice(s: &[u8], i: usize, j: usize) -> u8 {\n     s[j]"}, {"sha": "f4fd7e709b4b12de827818d493b73b979ff6054a", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_body() {\n     let mut _x = 0;\n@@ -61,9 +63,11 @@ fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_condition() {\n     let mut _x = 0;\n@@ -85,9 +89,11 @@ fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_break() {\n     let mut _x = 0;\n@@ -110,9 +116,11 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label() {\n     let mut _x = 0;\n@@ -135,9 +143,11 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -162,9 +172,11 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_break_label() {\n     let mut _x = 0;\n@@ -189,9 +201,11 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -216,9 +230,11 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_label() {\n     let mut _x = 0;\n@@ -243,9 +259,11 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "aa70d7e9fc112cac5c3d8d36b634f5a138cff15e", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -36,9 +36,11 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_body() {\n     let mut _x = 0;\n@@ -61,9 +63,11 @@ fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_loop_condition() {\n     let mut _x = 0;\n@@ -85,9 +89,11 @@ fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_break() {\n     let mut _x = 0;\n@@ -110,9 +116,11 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label() {\n     let mut _x = 0;\n@@ -135,9 +143,11 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -162,9 +172,11 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_break_label() {\n     let mut _x = 0;\n@@ -189,9 +201,11 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -216,9 +230,11 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_label() {\n     let mut _x = 0;\n@@ -243,9 +259,11 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "b7f90c09b565cd41e552856c2c75d2bcf8f999bf", "filename": "src/test/incremental/hello_world.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fhello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhello_world.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -18,22 +18,22 @@ fn main() { }\n \n mod x {\n     #[cfg(rpass1)]\n-    pub fn x() -> i32 {\n+    pub fn xxxx() -> i32 {\n         1\n     }\n \n     #[cfg(rpass2)]\n-    pub fn x() -> i32 {\n+    pub fn xxxx() -> i32 {\n         2\n     }\n }\n \n mod y {\n     use x;\n \n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    pub fn y() {\n-        x::x();\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn yyyy() {\n+        x::xxxx();\n     }\n }\n \n@@ -42,6 +42,6 @@ mod z {\n \n     #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn z() {\n-        y::y();\n+        y::yyyy();\n     }\n }"}, {"sha": "0a36e3c693edbb22123c03131810e7652de29888", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -46,12 +46,14 @@ mod mod3 {\n mod mod3 {\n     use Trait2;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n     fn bar() {\n         ().method();\n     }\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     fn baz() {\n         22; // no method call, traits in scope don't matter\n     }"}, {"sha": "e8e40d57b1ee6b42e514900b0a45a435d95592f4", "filename": "src/test/incremental/ich_nested_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_nested_items.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -23,11 +23,14 @@ fn foo() {\n \n #[cfg(rpass2)]\n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n fn foo() {\n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     fn baz() { } // order is different...\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     fn bar() { } // but that doesn't matter.\n \n     fn bap() { } // neither does adding a new item"}, {"sha": "49a88c530ff64b1248ca46e678edcbfbd2be61d0", "filename": "src/test/incremental/ich_resolve_results.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_resolve_results.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -45,11 +45,13 @@ mod mod3 {\n     use test;\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     fn in_expr() {\n         Foo(0);\n     }\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     fn in_type() {\n         test::<Foo>();\n     }\n@@ -60,12 +62,14 @@ mod mod3 {\n     use test;\n     use mod2::Foo; // <-- This changed!\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"rpass3\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass3\")]\n     fn in_expr() {\n         Foo(0);\n     }\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"rpass3\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass3\")]\n     fn in_type() {\n         test::<Foo>();\n     }"}, {"sha": "36d1b3ecbcd14c7002faf009a99a3e200fc3fefb", "filename": "src/test/incremental/source_loc_macros.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -18,16 +18,19 @@\n #![feature(rustc_attrs)]\n \n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n fn line_same() {\n     let _ = line!();\n }\n \n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n fn col_same() {\n     let _ = column!();\n }\n \n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n fn file_same() {\n     let _ = file!();\n }\n@@ -38,7 +41,8 @@ fn line_different() {\n }\n \n #[cfg(rpass2)]\n-#[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n fn line_different() {\n     let _ = line!();\n }\n@@ -49,7 +53,8 @@ fn col_different() {\n }\n \n #[cfg(rpass2)]\n-#[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n fn col_different() {\n     let _ =        column!();\n }"}, {"sha": "90ec4a9d55831bb9b4ea4cd9dfa4ebc5392c6322", "filename": "src/test/incremental/spans_insignificant_w_o_debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -22,4 +22,5 @@ pub fn main() {}\n \n #[cfg(rpass2)]\n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n pub fn main() {}"}, {"sha": "cdab8de9828ab1a22a6867b29bb5266349196d13", "filename": "src/test/incremental/spans_significant_w_debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -22,4 +22,5 @@ pub fn main() {}\n \n #[cfg(rpass2)]\n #[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n pub fn main() {}"}, {"sha": "0b230df41469f0af3f1b3d1407c21cd049ca7428", "filename": "src/test/run-pass/associated-const-const-eval.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Frun-pass%2Fassociated-const-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Frun-pass%2Fassociated-const-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-const-eval.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const NUM: usize;\n+}\n+\n+impl Foo for i32 {\n+    const NUM: usize = 1;\n+}\n+\n+const FOO: usize = <i32 as Foo>::NUM;\n+\n+fn main() {\n+    assert_eq!(1, FOO);\n+\n+    match 1 {\n+        <i32 as Foo>::NUM => {},\n+        _ => assert!(false)\n+    }\n+}"}, {"sha": "7d31bb5b1a5e2dd7c0b4ec50986d3df296161aba", "filename": "src/test/run-pass/associated-const-cross-crate-const-eval.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f50dbd580f3d5d88a300da540db3c85164bfd0de/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-const-eval.rs?ref=f50dbd580f3d5d88a300da540db3c85164bfd0de", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:associated-const-cc-lib.rs\n+\n+#![feature(associated_consts)]\n+\n+extern crate associated_const_cc_lib as foolib;\n+\n+pub struct LocalFoo;\n+\n+impl foolib::Foo for LocalFoo {\n+    const BAR: usize = 1;\n+}\n+\n+const FOO_1: usize = <foolib::FooNoDefault as foolib::Foo>::BAR;\n+const FOO_2: usize = <LocalFoo as foolib::Foo>::BAR;\n+const FOO_3: usize = foolib::InherentBar::BAR;\n+\n+fn main() {\n+    assert_eq!(0, FOO_1);\n+    assert_eq!(1, FOO_2);\n+    assert_eq!(3, FOO_3);\n+\n+    match 0 {\n+        <foolib::FooNoDefault as foolib::Foo>::BAR => {},\n+        <LocalFoo as foolib::Foo>::BAR => assert!(false),\n+        foolib::InherentBar::BAR => assert!(false),\n+        _ => assert!(false)\n+    }\n+}"}]}