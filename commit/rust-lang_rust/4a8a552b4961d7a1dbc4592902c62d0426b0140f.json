{"sha": "4a8a552b4961d7a1dbc4592902c62d0426b0140f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOGE1NTJiNDk2MWQ3YTFkYmM0NTkyOTAyYzYyZDA0MjZiMDE0MGY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-18T02:01:16Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-26T00:30:38Z"}, "message": "Add DataflowResultsCursor", "tree": {"sha": "10e6948411164e6143310a46c553ce9f999b7a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e6948411164e6143310a46c553ce9f999b7a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8a552b4961d7a1dbc4592902c62d0426b0140f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8a552b4961d7a1dbc4592902c62d0426b0140f", "html_url": "https://github.com/rust-lang/rust/commit/4a8a552b4961d7a1dbc4592902c62d0426b0140f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8a552b4961d7a1dbc4592902c62d0426b0140f/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7262e64f536bba0fd617201d69d7048d27a72f00", "url": "https://api.github.com/repos/rust-lang/rust/commits/7262e64f536bba0fd617201d69d7048d27a72f00", "html_url": "https://github.com/rust-lang/rust/commit/7262e64f536bba0fd617201d69d7048d27a72f00"}], "stats": {"total": 94, "additions": 94, "deletions": 0}, "files": [{"sha": "fccd1fdf8f2e122abf3ac7c5e245053aae3dda79", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4a8a552b4961d7a1dbc4592902c62d0426b0140f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8a552b4961d7a1dbc4592902c62d0426b0140f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=4a8a552b4961d7a1dbc4592902c62d0426b0140f", "patch": "@@ -344,6 +344,100 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn body(&self) -> &'a Body<'tcx>;\n }\n \n+/// Allows iterating dataflow results in a flexible and reasonably fast way.\n+#[derive(Clone)]\n+pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    flow_state: FlowAtLocation<'tcx, BD, DR>,\n+\n+    // The statement (or terminator) whose effect has been reconstructed in\n+    // flow_state.\n+    curr_loc: Option<Location>,\n+\n+    body: &'mir Body<'tcx>,\n+}\n+\n+pub type DataflowResultsRefCursor<'mir, 'tcx, 'flow, BD> =\n+    DataflowResultsCursor<'mir, 'tcx, BD, &'flow DataflowResults<'tcx, BD>>;\n+\n+impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n+        DataflowResultsCursor {\n+            flow_state: FlowAtLocation::new(result),\n+            curr_loc: None,\n+            body,\n+        }\n+    }\n+\n+    /// Seek to the given location in MIR. This method is fast if you are\n+    /// traversing your MIR statements in order.\n+    ///\n+    /// After calling `seek`, the current state will reflect all effects up to\n+    /// and including the `before_statement_effect` of the statement at location\n+    /// `loc`. The `statement_effect` of the statement at `loc` will be\n+    /// available as the current effect (see e.g. `each_gen_bit`).\n+    ///\n+    /// If `loc.statement_index` equals the number of statements in the block,\n+    /// we will reconstruct the terminator effect in the same way as described\n+    /// above.\n+    pub fn seek(&mut self, loc: Location) {\n+        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n+            return;\n+        }\n+\n+        let start_index;\n+        let should_reset = match self.curr_loc {\n+            None => true,\n+            Some(cur)\n+                if loc.block != cur.block || loc.statement_index < cur.statement_index => true,\n+            _ => false,\n+        };\n+        if should_reset {\n+            self.flow_state.reset_to_entry_of(loc.block);\n+            start_index = 0;\n+        } else {\n+            let curr_loc = self.curr_loc.unwrap();\n+            start_index = curr_loc.statement_index;\n+            // Apply the effect from the last seek to the current state.\n+            self.flow_state.apply_local_effect(curr_loc);\n+        }\n+\n+        for stmt in start_index..loc.statement_index {\n+            let mut stmt_loc = loc;\n+            stmt_loc.statement_index = stmt;\n+            self.flow_state.reconstruct_statement_effect(stmt_loc);\n+            self.flow_state.apply_local_effect(stmt_loc);\n+        }\n+\n+        if loc.statement_index == self.body[loc.block].statements.len() {\n+            self.flow_state.reconstruct_terminator_effect(loc);\n+        } else {\n+            self.flow_state.reconstruct_statement_effect(loc);\n+        }\n+        self.curr_loc = Some(loc);\n+    }\n+\n+    /// Return whether the current state contains bit `x`.\n+    pub fn contains(&self, x: BD::Idx) -> bool {\n+        self.flow_state.contains(x)\n+    }\n+\n+    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n+    pub fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.flow_state.each_gen_bit(f)\n+    }\n+}\n+\n pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         analysis: &T,\n                                                         result: &DataflowResults<'tcx, T>,"}]}