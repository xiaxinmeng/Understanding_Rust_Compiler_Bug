{"sha": "3041a97b1acef4f8549d9e297db8deaf571341f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDFhOTdiMWFjZWY0Zjg1NDlkOWUyOTdkYjhkZWFmNTcxMzQxZjI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-08-02T21:25:19Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-08-03T12:08:47Z"}, "message": "finish type-auditing rustllvm", "tree": {"sha": "789185cf8f370ef7ddd68f3f3744d301bdccea7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/789185cf8f370ef7ddd68f3f3744d301bdccea7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3041a97b1acef4f8549d9e297db8deaf571341f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3041a97b1acef4f8549d9e297db8deaf571341f2", "html_url": "https://github.com/rust-lang/rust/commit/3041a97b1acef4f8549d9e297db8deaf571341f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3041a97b1acef4f8549d9e297db8deaf571341f2/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24874170b4dfc93243b18815b6d896e87f7ddafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/24874170b4dfc93243b18815b6d896e87f7ddafe", "html_url": "https://github.com/rust-lang/rust/commit/24874170b4dfc93243b18815b6d896e87f7ddafe"}], "stats": {"total": 440, "additions": 246, "deletions": 194}, "files": [{"sha": "6301c57c55540ebe7fe260db96eb82055f33114e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -13,19 +13,20 @@ use debuginfo::{DIBuilderRef, DIDescriptor,\n                 DIBasicType, DIDerivedType, DICompositeType, DIScope,\n                 DIVariable, DIGlobalVariable, DIArray, DISubrange,\n                 DITemplateTypeParameter, DIEnumerator, DINameSpace};\n-use RustStringRef;\n \n-use libc::{c_uint, c_ushort, c_int, size_t, c_char};\n+use libc::{c_uint, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n \n+use RustStringRef;\n+\n pub type Opcode = u32;\n pub type Bool = c_uint;\n \n pub const True: Bool = 1 as Bool;\n pub const False: Bool = 0 as Bool;\n \n-#[repr(C)]\n #[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n pub enum LLVMRustResult {\n     Success,\n     Failure,\n@@ -68,23 +69,22 @@ pub enum Linkage {\n }\n \n /// LLVMDiagnosticSeverity\n-#[repr(C)]\n #[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n pub enum DiagnosticSeverity {\n     Error = 0,\n     Warning = 1,\n     Remark = 2,\n     Note = 3,\n }\n \n-/// LLVMRustDLLStorageClassTypes\n-#[repr(C)]\n+/// LLVMDLLStorageClass\n #[derive(Copy, Clone)]\n-pub enum DLLStorageClassTypes {\n-    Other,\n-    Default,\n-    DllImport,\n-    DllExport,\n+#[repr(C)]\n+pub enum DLLStorageClass {\n+  Default   = 0,\n+  DllImport = 1, /* Function to be imported from DLL. */\n+  DllExport = 2, /* Function to be accessible from DLL. */\n }\n \n bitflags! {\n@@ -144,6 +144,7 @@ bitflags! {\n \n /// LLVMIntPredicate\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum IntPredicate {\n     IntEQ = 32,\n     IntNE = 33,\n@@ -159,6 +160,7 @@ pub enum IntPredicate {\n \n /// LLVMRealPredicate\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum RealPredicate {\n     RealPredicateFalse = 0,\n     RealOEQ = 1,\n@@ -178,7 +180,7 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n-/// LLVMTypeKind; FIXME: wrap\n+/// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n pub enum TypeKind {\n@@ -198,11 +200,12 @@ pub enum TypeKind {\n     Vector    = 13,\n     Metadata  = 14,\n     X86_MMX   = 15,\n+    Token     = 16,\n }\n \n /// LLVMAtomicRmwBinOp\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum AtomicRmwBinOp {\n     AtomicXchg = 0,\n     AtomicAdd  = 1,\n@@ -218,8 +221,8 @@ pub enum AtomicRmwBinOp {\n }\n \n /// LLVMAtomicOrdering\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum AtomicOrdering {\n     NotAtomic = 0,\n     Unordered = 1,\n@@ -232,25 +235,27 @@ pub enum AtomicOrdering {\n }\n \n /// LLVMRustSynchronizationScope\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum SynchronizationScope {\n     Other,\n     SingleThread,\n     CrossThread,\n }\n \n /// LLVMRustFileType\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum FileType {\n     Other,\n     AssemblyFile,\n     ObjectFile,\n }\n \n-/// FIXME: ?\n+/// Enum pinned in LLVMContext, used in\n+/// LLVMSetMetadata so ABI-stable.\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum MetadataType {\n     MD_dbg = 0,\n     MD_tbaa = 1,\n@@ -266,11 +271,13 @@ pub enum MetadataType {\n     MD_nonnull = 11,\n }\n \n-/// FIXME: ?\n+/// LLVMRustAsmDialect\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum AsmDialect {\n-    AD_ATT   = 0,\n-    AD_Intel = 1\n+    Other,\n+    Att,\n+    Intel,\n }\n \n /// LLVMRustCodeGenOptLevel\n@@ -295,8 +302,8 @@ pub enum RelocMode {\n }\n \n /// LLVMRustCodeModel\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum CodeModel {\n     Other,\n     Default,\n@@ -308,8 +315,8 @@ pub enum CodeModel {\n }\n \n /// LLVMRustDiagnosticKind\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum DiagnosticKind {\n     Other,\n     InlineAsm,\n@@ -326,15 +333,16 @@ pub enum DiagnosticKind {\n }\n \n /// LLVMRustArchiveKind\n-#[repr(C)]\n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum ArchiveKind {\n     Other,\n     K_GNU,\n     K_MIPS64,\n     K_BSD,\n     K_COFF,\n }\n+\n /// LLVMRustPassKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -519,7 +527,7 @@ extern {\n     pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n+    pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n     /// See llvm::LLVMType::getContext.\n     pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n@@ -589,8 +597,6 @@ extern {\n     pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n     pub fn LLVMDumpValue(Val: ValueRef);\n     pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n     pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n \n     /* Operations on Uses */\n@@ -608,9 +614,9 @@ extern {\n     pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n     /* all zeroes */\n     pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+    pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef)\n                          -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef)\n                          -> ValueRef;\n     /* only for isize/vector */\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n@@ -815,13 +821,15 @@ extern {\n     pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n     pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n     pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+    pub fn LLVMSetLinkage(Global: ValueRef, Link: Linkage);\n     pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n     pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n     pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n     pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n     pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n     pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+    pub fn LLVMSetDLLStorageClass(V: ValueRef,\n+                                  C: DLLStorageClass);\n \n \n     /* Operations on global variables */\n@@ -1685,7 +1693,7 @@ extern {\n                              Constraints: *const c_char,\n                              SideEffects: Bool,\n                              AlignStack: Bool,\n-                             Dialect: c_uint)\n+                             Dialect: AsmDialect)\n                              -> ValueRef;\n \n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n@@ -1990,9 +1998,6 @@ extern {\n     pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n     pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n-    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n-                                      C: DLLStorageClassTypes);\n-\n     pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n                                   data: *mut *const c_char) -> size_t;\n "}, {"sha": "6c4e1a54ea7281b4ff3d0ae55f9c3ac7c9337e76", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 72, "deletions": 42, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -33,13 +33,11 @@\n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n-pub use self::AsmDialect::*;\n pub use self::CodeGenOptSize::*;\n pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n@@ -50,7 +48,7 @@ use std::str::FromStr;\n use std::slice;\n use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n-use libc::{c_uint, c_ushort, c_char, size_t};\n+use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n@@ -94,32 +92,64 @@ impl Attributes {\n         self\n     }\n \n-    pub fn apply_llfn(&self, idx: usize, llfn: ValueRef) {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n-            LLVMRustAddFunctionAttribute(llfn, idx as c_uint, self.regular.bits());\n+            self.regular.apply_llfn(idx, llfn);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableAttr(llfn, idx as c_uint,\n-                                               self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableAttr(\n+                    llfn,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n         unsafe {\n-            LLVMRustAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n+            self.regular.apply_callsite(idx, callsite);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n-                                                       self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableCallSiteAttr(\n+                    callsite,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n }\n \n+pub fn AddFunctionAttrStringValue(\n+    llfn: ValueRef,\n+    idx: AttributePlace,\n+    attr: &'static str,\n+    value: &'static str\n+) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(\n+            llfn,\n+            idx.as_uint(),\n+            attr.as_ptr() as *const _,\n+            value.as_ptr() as *const _)\n+    }\n+}\n+\n #[repr(C)]\n #[derive(Copy, Clone)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n+pub enum AttributePlace {\n+    Argument(u32),\n+    Function,\n+}\n+\n+impl AttributePlace {\n+    pub fn ReturnValue() -> Self {\n+        AttributePlace::Argument(0)\n+    }\n+\n+    fn as_uint(self) -> c_uint {\n+        match self {\n+            AttributePlace::Function => !0,\n+            AttributePlace::Argument(i) => i,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -170,11 +200,6 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n         LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n }\n-pub fn SetLinkage(global: ValueRef, link: Linkage) {\n-    unsafe {\n-        LLVMSetLinkage(global, link as c_uint);\n-    }\n-}\n \n // Externally visible symbols that might appear in multiple translation units need to appear in\n // their own comdat section so that the duplicates can be discarded at link time. This can for\n@@ -194,12 +219,6 @@ pub fn UnsetComdat(val: ValueRef) {\n     }\n }\n \n-pub fn SetDLLStorageClass(global: ValueRef, class: DLLStorageClassTypes) {\n-    unsafe {\n-        LLVMRustSetDLLStorageClass(global, class);\n-    }\n-}\n-\n pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);\n@@ -212,29 +231,40 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n     }\n }\n \n-pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstICmp(pred as c_ushort, v1, v2)\n+impl Attribute {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustAddFunctionAttribute(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n-pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstFCmp(pred as c_ushort, v1, v2)\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe {\n+            LLVMRustAddCallSiteAttribute(\n+                callsite, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMRustAddFunctionAttribute(fn_, FunctionIndex as c_uint,\n-                                     attr.bits() as u64)\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustRemoveFunctionAttributes(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn RemoveFunctionAttributes(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMRustRemoveFunctionAttributes(fn_, FunctionIndex as c_uint,\n-                                         attr.bits() as u64)\n+    pub fn toggle_llfn(&self,\n+                       idx: AttributePlace,\n+                       llfn: ValueRef,\n+                       set: bool)\n+    {\n+        if set {\n+            self.apply_llfn(idx, llfn);\n+        } else {\n+            self.unapply_llfn(idx, llfn);\n+        }\n     }\n+\n }\n \n /* Memory-managed interface to target data. */"}, {"sha": "587c03af3abb6d6eaae9fbdd1c73a2650912049e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -552,13 +552,13 @@ impl FnType {\n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_llfn(i, llfn);\n+            self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_llfn(i, llfn);\n+                arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n                 i += 1;\n             }\n         }\n@@ -567,13 +567,13 @@ impl FnType {\n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_callsite(i, callsite);\n+            self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_callsite(i, callsite);\n+                arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n                 i += 1;\n             }\n         }"}, {"sha": "5514fb0f4efc37b067b21439af683cf9d6a8f754", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -83,8 +83,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let dialect = match ia.dialect {\n-        AsmDialect::Att   => llvm::AD_ATT,\n-        AsmDialect::Intel => llvm::AD_Intel\n+        AsmDialect::Att   => llvm::AsmDialect::Att,\n+        AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n     let asm = CString::new(ia.asm.as_bytes()).unwrap();"}, {"sha": "62eac35e0abd9766d64b7b471c6cf2022e15e182", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n //! Set and unset common attributes on LLVM values.\n \n-use libc::c_uint;\n-use llvm::{self, ValueRef};\n+use llvm::{self, Attribute, ValueRef};\n+use llvm::AttributePlace::Function;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use context::CrateContext;\n@@ -20,71 +20,52 @@ use context::CrateContext;\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHint),\n-        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInline),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInline),\n+        Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n+        Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n+        Never  => Attribute::NoInline.apply_llfn(Function, val),\n         None   => {\n-            let attr = llvm::Attribute::InlineHint |\n-                       llvm::Attribute::AlwaysInline |\n-                       llvm::Attribute::NoInline;\n-            llvm::RemoveFunctionAttributes(val, attr)\n+            let attr = Attribute::InlineHint |\n+                       Attribute::AlwaysInline |\n+                       Attribute::NoInline;\n+            attr.unapply_llfn(Function, val)\n         },\n     };\n }\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n-    if emit {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTable);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::UWTable);\n-    }\n+    Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n-    if can_unwind {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::NoUnwind);\n-    } else {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwind);\n-    }\n+    Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n /// Tell LLVM whether it should optimise function for size.\n #[inline]\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n-    if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSize);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::OptimizeForSize);\n-    }\n+    Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n #[inline]\n pub fn naked(val: ValueRef, is_naked: bool) {\n-    if is_naked {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::Naked);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::Naked);\n-    }\n+    Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n     if ccx.sess().must_not_eliminate_frame_pointers() {\n-        unsafe {\n-            let attr = \"no-frame-pointer-elim\\0\".as_ptr() as *const _;\n-            let val = \"true\\0\".as_ptr() as *const _;\n-            llvm::LLVMRustAddFunctionAttrStringValue(llfn,\n-                                                     llvm::FunctionIndex as c_uint,\n-                                                     attr,\n-                                                     val);\n-        }\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            \"no-frame-pointer-elim\\0\",\n+            \"true\\0\")\n     }\n }\n \n@@ -98,13 +79,12 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n \n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n-            llvm::Attributes::default().set(llvm::Attribute::Cold)\n-                .apply_llfn(llvm::FunctionIndex as usize, llfn)\n+            Attribute::Cold.apply_llfn(Function, llfn);\n         } else if attr.check_name(\"naked\") {\n             naked(llfn, true);\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n-                .apply_llfn(llvm::ReturnIndex as usize, llfn)\n+            Attribute::NoAlias.apply_llfn(\n+                llvm::AttributePlace::ReturnValue(), llfn);\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }"}, {"sha": "7fb19fefee2d1a2e9454e61b8d01973bbd950c35", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -2347,9 +2347,9 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                     let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n \n                     if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n-                        llvm::SetLinkage(val, llvm::InternalLinkage);\n-                        llvm::SetDLLStorageClass(val,\n-                                                 llvm::DLLStorageClassTypes::Default);\n+                        llvm::LLVMSetLinkage(val, llvm::InternalLinkage);\n+                        llvm::LLVMSetDLLStorageClass(val,\n+                                                     llvm::DLLStorageClass::Default);\n                         llvm::UnsetComdat(val);\n                     }\n                 }\n@@ -2394,7 +2394,7 @@ fn create_imps(cx: &CrateContextList) {\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n                 llvm::LLVMSetInitializer(imp, init);\n-                llvm::SetLinkage(imp, llvm::ExternalLinkage);\n+                llvm::LLVMSetLinkage(imp, llvm::ExternalLinkage);\n             }\n         }\n     }"}, {"sha": "90f96af5496915527d9a71c0271dc2b61b64056b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -841,7 +841,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let fty = Type::func(&argtys[..], &output);\n         unsafe {\n             let v = llvm::LLVMRustInlineAsm(\n-                fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+                fty.to_ref(), asm, cons, volatile, alignstack, dia);\n             self.call(v, inputs, None)\n         }\n     }"}, {"sha": "e53a5edfc668519f2f305e8f63687419c7ebb83a", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -249,11 +249,13 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     if  !ccx.instances().borrow().contains_key(&instance) {\n         let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n \n-        if ccx.sess().target.target.options.allows_weak_linkage {\n-            llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n-            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-        } else {\n-            llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+        unsafe {\n+            if ccx.sess().target.target.options.allows_weak_linkage {\n+                llvm::LLVMSetLinkage(llfn, llvm::WeakODRLinkage);\n+                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+            } else {\n+                llvm::LLVMSetLinkage(llfn, llvm::InternalLinkage);\n+            }\n         }\n \n         // set an inline hint for all closures"}, {"sha": "a1783e9c0a3829960035925d7f39d6183b28f4cb", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -980,7 +980,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n+        llvm::LLVMSetLinkage(g, llvm::InternalLinkage);\n \n         cx.const_cstr_cache().borrow_mut().insert(s, g);\n         g"}, {"sha": "7afb5257258ec38f5c5b26100e7ececad4bbff9f", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -10,7 +10,7 @@\n \n \n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n+use llvm::{SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n@@ -125,7 +125,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetAlignment(gv, align);\n-        SetLinkage(gv, InternalLinkage);\n+        llvm::LLVMSetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }\n@@ -637,10 +637,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n                     if is_float {\n                         let cmp = base::bin_op_to_fcmp_predicate(b.node);\n-                        ConstFCmp(cmp, te1, te2)\n+                        llvm::LLVMConstFCmp(cmp, te1, te2)\n                     } else {\n                         let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n-                        ConstICmp(cmp, te1, te2)\n+                        llvm::LLVMConstICmp(cmp, te1, te2)\n                     }\n                 },\n             } } // unsafe { match b.node {\n@@ -1072,7 +1072,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n                         let g1 = declare::declare_global(ccx, &sym, llty2);\n-                        llvm::SetLinkage(g1, linkage);\n+                        llvm::LLVMSetLinkage(g1, linkage);\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n                         // is initialized with the address of `foo`.  If `foo` is\n@@ -1086,7 +1086,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             ccx.sess().span_fatal(span,\n                                 &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n-                        llvm::SetLinkage(g2, llvm::InternalLinkage);\n+                        llvm::LLVMSetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n                         g2\n                     }\n@@ -1126,7 +1126,9 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n             }\n         }\n         if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(g, llvm::DLLStorageClassTypes::DllImport);\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n         }\n         g\n     };"}, {"sha": "0a8d490dcd2dd3e54601a69484f44d1eddf7aaea", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -77,7 +77,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n-            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            llvm::LLVMSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n             // This should make sure that the whole section is not larger than\n             // the string it contains. Otherwise we get a warning from GDB.\n             llvm::LLVMSetAlignment(section_var, 1);"}, {"sha": "324e8697ecae695ab61e3a6e550cdf085fa85fd2", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -20,6 +20,7 @@\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n+use llvm::AttributePlace::Function;\n use rustc::ty;\n use abi::{Abi, FnType};\n use attributes;\n@@ -65,16 +66,16 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n+        llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n     match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::OptimizeForSize);\n+            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n         Some(\"z\") => {\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::MinSize);\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::OptimizeForSize);\n+            llvm::Attribute::MinSize.apply_llfn(Function, llfn);\n+            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n         _ => {},\n     }\n@@ -111,7 +112,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     if sig.output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n+        llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n \n     if abi != Abi::Rust && abi != Abi::RustCall {\n@@ -162,7 +163,7 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     name: &str,\n                                     fn_type: ty::Ty<'tcx>) -> ValueRef {\n     let llfn = define_fn(ccx, name, fn_type);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    unsafe { llvm::LLVMSetLinkage(llfn, llvm::InternalLinkage) };\n     llfn\n }\n "}, {"sha": "00db19d2739c3953d95615af8801e6169acb13ae", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -824,11 +824,11 @@ pub fn const_scalar_binop(op: mir::BinOp,\n             mir::BinOp::Gt | mir::BinOp::Ge => {\n                 if is_float {\n                     let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                    llvm::ConstFCmp(cmp, lhs, rhs)\n+                    llvm::LLVMConstFCmp(cmp, lhs, rhs)\n                 } else {\n                     let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n                                                                 signed);\n-                    llvm::ConstICmp(cmp, lhs, rhs)\n+                    llvm::LLVMConstICmp(cmp, lhs, rhs)\n                 }\n             }\n         }"}, {"sha": "e9aacaa0f954f2e4fc20daa8d50ba442bcabc0b8", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -125,7 +125,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             if ccx.shared().translation_items().borrow().contains(&trans_item) {\n                 attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                llvm::SetLinkage(lldecl, llvm::ExternalLinkage);\n+                unsafe {\n+                    llvm::LLVMSetLinkage(lldecl, llvm::ExternalLinkage);\n+                }\n             } else {\n                 // FIXME: #34151\n                 // Normally, getting here would indicate a bug in trans::collector,"}, {"sha": "35bb0481c8e979e6f82248a111fa18254fb078eb", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         &format!(\"symbol `{}` is already defined\", symbol_name))\n                 });\n \n-                llvm::SetLinkage(g, linkage);\n+                unsafe { llvm::LLVMSetLinkage(g, linkage) };\n             }\n \n             item => bug!(\"predefine_static: expected static, found {:?}\", item)\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 ref attrs, node: hir::ImplItemKind::Method(..), ..\n             }) => {\n                 let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n-                llvm::SetLinkage(lldecl, linkage);\n+                unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n                 base::set_link_section(ccx, lldecl, attrs);\n                 if linkage == llvm::LinkOnceODRLinkage ||\n                    linkage == llvm::WeakODRLinkage {\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n         let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n-        llvm::SetLinkage(llfn, linkage);\n+        unsafe { llvm::LLVMSetLinkage(llfn, linkage) };\n         if linkage == llvm::LinkOnceODRLinkage ||\n            linkage == llvm::WeakODRLinkage {\n             llvm::SetUniqueComdat(ccx.llmod(), llfn);"}, {"sha": "d191591e082adedef8e9d7a0bfd00cd3cef875bd", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -208,7 +208,7 @@ impl Type {\n \n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n-            llvm::LLVMGetTypeKind(self.to_ref())\n+            llvm::LLVMRustGetTypeKind(self.to_ref())\n         }\n     }\n "}, {"sha": "1e873b5345c43d22f09da97e95eb203062b22c51", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -61,7 +61,7 @@ from_rust(LLVMRustArchiveKind kind)\n     case LLVMRustArchiveKind::COFF:\n         return Archive::K_COFF;\n     default:\n-        abort();\n+      llvm_unreachable(\"Bad ArchiveKind.\");\n   }\n }\n "}, {"sha": "e3dcf45cf0fb585b9bf2f5a0c5d289227225f715", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -196,7 +196,7 @@ from_rust(LLVMRustCodeModel model)\n     case LLVMRustCodeModel::Large:\n         return CodeModel::Large;\n     default:\n-        abort();\n+        llvm_unreachable(\"Bad CodeModel.\");\n   }\n }\n \n@@ -221,7 +221,7 @@ from_rust(LLVMRustCodeGenOptLevel level)\n     case LLVMRustCodeGenOptLevel::Aggressive:\n         return CodeGenOpt::Aggressive;\n     default:\n-        abort();\n+        llvm_unreachable(\"Bad CodeGenOptLevel.\");\n   }\n }\n \n@@ -395,7 +395,7 @@ from_rust(LLVMRustFileType type)\n     case LLVMRustFileType::ObjectFile:\n         return TargetMachine::CGFT_ObjectFile;\n     default:\n-        abort();\n+        llvm_unreachable(\"Bad FileType.\");\n   }\n }\n "}, {"sha": "0da25e7ac57b7a7eea4628692251f0b92743d3cd", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3041a97b1acef4f8549d9e297db8deaf571341f2/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3041a97b1acef4f8549d9e297db8deaf571341f2", "patch": "@@ -263,7 +263,7 @@ from_rust(LLVMRustSynchronizationScope scope)\n     case LLVMRustSynchronizationScope::CrossThread:\n         return CrossThread;\n     default:\n-        abort();\n+        llvm_unreachable(\"bad SynchronizationScope.\");\n     }\n }\n \n@@ -281,15 +281,34 @@ extern \"C\" void LLVMRustSetDebug(int Enabled) {\n #endif\n }\n \n+enum class LLVMRustAsmDialect {\n+    Other,\n+    Att,\n+    Intel,\n+};\n+\n+static InlineAsm::AsmDialect\n+from_rust(LLVMRustAsmDialect dialect)\n+{\n+    switch (dialect) {\n+    case LLVMRustAsmDialect::Att:\n+        return InlineAsm::AD_ATT;\n+    case LLVMRustAsmDialect::Intel:\n+        return InlineAsm::AD_Intel;\n+    default:\n+        llvm_unreachable(\"bad AsmDialect.\");\n+    }\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty,\n \t\t\t\t\t  char *AsmString,\n \t\t\t\t\t  char *Constraints,\n \t\t\t\t\t  LLVMBool HasSideEffects,\n \t\t\t\t\t  LLVMBool IsAlignStack,\n-\t\t\t\t\t  unsigned Dialect) {\n+\t\t\t\t\t  LLVMRustAsmDialect Dialect) {\n     return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString,\n                                Constraints, HasSideEffects,\n-                               IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n+                               IsAlignStack, from_rust(Dialect)));\n }\n \n typedef DIBuilder* LLVMRustDIBuilderRef;\n@@ -797,35 +816,6 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     return true;\n }\n \n-enum class LLVMRustDLLStorageClassTypes {\n-    Other,\n-    Default,\n-    DllImport,\n-    DllExport,\n-};\n-\n-static GlobalValue::DLLStorageClassTypes\n-from_rust(LLVMRustDLLStorageClassTypes Class)\n-{\n-    switch (Class) {\n-    case LLVMRustDLLStorageClassTypes::Default:\n-        return GlobalValue::DefaultStorageClass;\n-    case LLVMRustDLLStorageClassTypes::DllImport:\n-        return GlobalValue::DLLImportStorageClass;\n-    case LLVMRustDLLStorageClassTypes::DllExport:\n-        return GlobalValue::DLLExportStorageClass;\n-    default:\n-        abort();\n-  }\n-}\n-\n-extern \"C\" void\n-LLVMRustSetDLLStorageClass(LLVMValueRef Value,\n-                           LLVMRustDLLStorageClassTypes Class) {\n-    GlobalValue *V = unwrap<GlobalValue>(Value);\n-    V->setDLLStorageClass(from_rust(Class));\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The\n@@ -955,10 +945,53 @@ to_rust(DiagnosticKind kind)\n   }\n }\n \n-\n extern \"C\" LLVMRustDiagnosticKind LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n     return to_rust((DiagnosticKind) unwrap(di)->getKind());\n }\n+// This is kept distinct from LLVMGetTypeKind, because when\n+// a new type kind is added, the Rust-side enum must be\n+// updated or UB will result.\n+extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n+  switch (unwrap(Ty)->getTypeID()) {\n+  case Type::VoidTyID:\n+    return LLVMVoidTypeKind;\n+  case Type::HalfTyID:\n+    return LLVMHalfTypeKind;\n+  case Type::FloatTyID:\n+    return LLVMFloatTypeKind;\n+  case Type::DoubleTyID:\n+    return LLVMDoubleTypeKind;\n+  case Type::X86_FP80TyID:\n+    return LLVMX86_FP80TypeKind;\n+  case Type::FP128TyID:\n+    return LLVMFP128TypeKind;\n+  case Type::PPC_FP128TyID:\n+    return LLVMPPC_FP128TypeKind;\n+  case Type::LabelTyID:\n+    return LLVMLabelTypeKind;\n+  case Type::MetadataTyID:\n+    return LLVMMetadataTypeKind;\n+  case Type::IntegerTyID:\n+    return LLVMIntegerTypeKind;\n+  case Type::FunctionTyID:\n+    return LLVMFunctionTypeKind;\n+  case Type::StructTyID:\n+    return LLVMStructTypeKind;\n+  case Type::ArrayTyID:\n+    return LLVMArrayTypeKind;\n+  case Type::PointerTyID:\n+    return LLVMPointerTypeKind;\n+  case Type::VectorTyID:\n+    return LLVMVectorTypeKind;\n+  case Type::X86_MMXTyID:\n+    return LLVMX86_MMXTypeKind;\n+#if LLVM_VERSION_MINOR >= 8\n+  case Type::TokenTyID:\n+    return LLVMTokenTypeKind;\n+#endif\n+  }\n+  llvm_unreachable(\"Unhandled TypeID.\");\n+}\n \n extern \"C\" void LLVMRustWriteDebugLocToString(\n     LLVMContextRef C,\n@@ -971,7 +1004,6 @@ extern \"C\" void LLVMRustWriteDebugLocToString(\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n \n-// FIXME(type-audit): assume this function-pointer type does not change\n extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n     LLVMContextRef C,\n     LLVMContext::InlineAsmDiagHandlerTy H,\n@@ -1028,8 +1060,6 @@ LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n #endif\n }\n \n-// FIXME: to here.\n-\n extern \"C\" LLVMValueRef\n LLVMRustBuildCatchPad(LLVMBuilderRef Builder,\n                       LLVMValueRef ParentPad,"}]}