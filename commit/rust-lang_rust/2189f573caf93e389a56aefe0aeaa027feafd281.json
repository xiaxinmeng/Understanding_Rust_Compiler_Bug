{"sha": "2189f573caf93e389a56aefe0aeaa027feafd281", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxODlmNTczY2FmOTNlMzg5YTU2YWVmZTBhZWFhMDI3ZmVhZmQyODE=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-12T14:41:47Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-12T14:41:47Z"}, "message": "Remove extra level of nesting.", "tree": {"sha": "8f0b946cea2cdcff57c40cf87c5902529cd01c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f0b946cea2cdcff57c40cf87c5902529cd01c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2189f573caf93e389a56aefe0aeaa027feafd281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2189f573caf93e389a56aefe0aeaa027feafd281", "html_url": "https://github.com/rust-lang/rust/commit/2189f573caf93e389a56aefe0aeaa027feafd281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2189f573caf93e389a56aefe0aeaa027feafd281/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38912ee3d43868651e8ac6fc3da1153f45ba5cf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/38912ee3d43868651e8ac6fc3da1153f45ba5cf4", "html_url": "https://github.com/rust-lang/rust/commit/38912ee3d43868651e8ac6fc3da1153f45ba5cf4"}], "stats": {"total": 67, "additions": 32, "deletions": 35}, "files": [{"sha": "39ffab4dc17a7e2fe8e9386478c3793c24bc5e50", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2189f573caf93e389a56aefe0aeaa027feafd281/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2189f573caf93e389a56aefe0aeaa027feafd281/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2189f573caf93e389a56aefe0aeaa027feafd281", "patch": "@@ -436,43 +436,40 @@ pub fn parse(sess: &ParseSess, rdr: TtReader, ms: &[TokenTree]) -> NamedParseRes\n             } else {\n                 return Failure(parser.span, token::Eof);\n             }\n-        } else {\n-            if (!bb_eis.is_empty() && !next_eis.is_empty())\n-                || bb_eis.len() > 1 {\n-                let nts = bb_eis.iter().map(|ei| match ei.top_elts.get_tt(ei.idx) {\n-                    TokenTree::Token(_, MatchNt(bind, name)) => {\n-                        format!(\"{} ('{}')\", name, bind)\n-                    }\n-                    _ => panic!()\n-                }).collect::<Vec<String>>().join(\" or \");\n-\n-                return Error(parser.span, format!(\n-                    \"local ambiguity: multiple parsing options: {}\",\n-                    match next_eis.len() {\n-                        0 => format!(\"built-in NTs {}.\", nts),\n-                        1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n-                        n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n-                    }\n-                ))\n-            } else if bb_eis.is_empty() && next_eis.is_empty() {\n-                return Failure(parser.span, parser.token);\n-            } else if !next_eis.is_empty() {\n-                /* Now process the next token */\n-                cur_eis.extend(next_eis.drain(..));\n-                parser.bump();\n-            } else /* bb_eis.len() == 1 */ {\n-                let mut ei = bb_eis.pop().unwrap();\n-                if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n-                    let match_cur = ei.match_cur;\n-                    ei.matches[match_cur].push(Rc::new(MatchedNonterminal(\n-                        Rc::new(parse_nt(&mut parser, span, &ident.name.as_str())))));\n-                    ei.idx += 1;\n-                    ei.match_cur += 1;\n-                } else {\n-                    unreachable!()\n+        } else if (!bb_eis.is_empty() && !next_eis.is_empty()) || bb_eis.len() > 1 {\n+            let nts = bb_eis.iter().map(|ei| match ei.top_elts.get_tt(ei.idx) {\n+                TokenTree::Token(_, MatchNt(bind, name)) => {\n+                    format!(\"{} ('{}')\", name, bind)\n+                }\n+                _ => panic!()\n+            }).collect::<Vec<String>>().join(\" or \");\n+\n+            return Error(parser.span, format!(\n+                \"local ambiguity: multiple parsing options: {}\",\n+                match next_eis.len() {\n+                    0 => format!(\"built-in NTs {}.\", nts),\n+                    1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n+                    n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n                 }\n-                cur_eis.push(ei);\n+            ));\n+        } else if bb_eis.is_empty() && next_eis.is_empty() {\n+            return Failure(parser.span, parser.token);\n+        } else if !next_eis.is_empty() {\n+            /* Now process the next token */\n+            cur_eis.extend(next_eis.drain(..));\n+            parser.bump();\n+        } else /* bb_eis.len() == 1 */ {\n+            let mut ei = bb_eis.pop().unwrap();\n+            if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n+                let match_cur = ei.match_cur;\n+                ei.matches[match_cur].push(Rc::new(MatchedNonterminal(\n+                            Rc::new(parse_nt(&mut parser, span, &ident.name.as_str())))));\n+                ei.idx += 1;\n+                ei.match_cur += 1;\n+            } else {\n+                unreachable!()\n             }\n+            cur_eis.push(ei);\n         }\n \n         assert!(!cur_eis.is_empty());"}]}