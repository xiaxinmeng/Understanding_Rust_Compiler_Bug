{"sha": "f6d59207ad56e24a2bfefa3544de48a0f6491363", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDU5MjA3YWQ1NmUyNGEyYmZlZmEzNTQ0ZGU0OGEwZjY0OTEzNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-23T05:40:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-23T05:40:35Z"}, "message": "Auto merge of #76850 - ecstatic-morse:const-checking-refactor, r=oli-obk\n\nRemove `qualify_min_const_fn`\n\n~~Blocked on #76807 (the first six commits).~~\n\nWith this PR, all checks in `qualify_min_const_fn` are replicated in `check_consts`, and the former is no longer invoked. My goal was to have as few changes to test output as possible, since making sweeping changes to the code *while* doing big batches of diagnostics updates turned out to be a headache. To this end, there's a few `HACK`s in `check_consts` to achieve parity with `qualify_min_const_fn`.\n\nThe new system that replaces `is_min_const_fn` is referred to as \"const-stability\"  My end goal for the const-stability rules is this:\n* Const-stability is only applicable to functions defined in `staged_api` crates.\n* All functions not marked `rustc_const_unstable` are considered \"const-stable\".\n    - NB. This is currently not implemented. `#[unstable]` functions are also const-unstable. This causes problems when searching for feature gates.\n    - All \"const-unstable\" functions have an associated feature gate\n* const-stable functions can only call other const-stable functions\n     - `allow_internal_unstable` can be used to circumvent this.\n* All const-stable functions are subject to some additional checks (the ones that were unique to `qualify_min_const_fn`)\n\nThe plan is to remove each `HACK` individually in subsequent PRs. That way, changes to error message output can be reviewed in isolation.", "tree": {"sha": "6442243a32fe58e232cd5e204045d15bd7843b5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6442243a32fe58e232cd5e204045d15bd7843b5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d59207ad56e24a2bfefa3544de48a0f6491363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d59207ad56e24a2bfefa3544de48a0f6491363", "html_url": "https://github.com/rust-lang/rust/commit/f6d59207ad56e24a2bfefa3544de48a0f6491363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d59207ad56e24a2bfefa3544de48a0f6491363/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e62323df22ecf9c163023132d17b7114f68b72e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e62323df22ecf9c163023132d17b7114f68b72e8", "html_url": "https://github.com/rust-lang/rust/commit/e62323df22ecf9c163023132d17b7114f68b72e8"}, {"sha": "186d148b4cd67223fde15b421086e74a95501096", "url": "https://api.github.com/repos/rust-lang/rust/commits/186d148b4cd67223fde15b421086e74a95501096", "html_url": "https://github.com/rust-lang/rust/commit/186d148b4cd67223fde15b421086e74a95501096"}], "stats": {"total": 1050, "additions": 791, "deletions": 259}, "files": [{"sha": "480a5d2f18ecaa1246663a8b3b9c95d2a3829c41", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -7,6 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(box_syntax)]\n #![feature(const_fn)] // For the `transmute` in `P::new`\n+#![feature(const_fn_transmute)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]"}, {"sha": "8d4efd8ae8052eda0ffa4e1eb45b4da183028b67", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -51,6 +51,12 @@ impl ConstCx<'mir, 'tcx> {\n     pub fn const_kind(&self) -> hir::ConstContext {\n         self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n     }\n+\n+    pub fn is_const_stable_const_fn(&self) -> bool {\n+        self.const_kind == Some(hir::ConstContext::ConstFn)\n+            && self.tcx.features().staged_api\n+            && is_const_stable_const_fn(self.tcx, self.def_id.to_def_id())\n+    }\n }\n \n /// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n@@ -63,3 +69,37 @@ pub fn allow_internal_unstable(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: S\n     attr::allow_internal_unstable(&tcx.sess, attrs)\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n+\n+// Returns `true` if the given `const fn` is \"const-stable\".\n+//\n+// Panics if the given `DefId` does not refer to a `const fn`.\n+//\n+// Const-stability is only relevant for `const fn` within a `staged_api` crate. Only \"const-stable\"\n+// functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n+// functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n+// cannot use unstable features and can only call other \"const-stable\" functions.\n+pub fn is_const_stable_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    use attr::{ConstStability, Stability, StabilityLevel};\n+\n+    // Const-stability is only relevant for `const fn`.\n+    assert!(tcx.is_const_fn_raw(def_id));\n+\n+    // Functions with `#[rustc_const_unstable]` are const-unstable.\n+    match tcx.lookup_const_stability(def_id) {\n+        Some(ConstStability { level: StabilityLevel::Unstable { .. }, .. }) => return false,\n+        Some(ConstStability { level: StabilityLevel::Stable { .. }, .. }) => return true,\n+        None => {}\n+    }\n+\n+    // Functions with `#[unstable]` are const-unstable.\n+    //\n+    // FIXME(ecstaticmorse): We should keep const-stability attributes wholly separate from normal stability\n+    // attributes. `#[unstable]` should be irrelevant.\n+    if let Some(Stability { level: StabilityLevel::Unstable { .. }, .. }) =\n+        tcx.lookup_stability(def_id)\n+    {\n+        return false;\n+    }\n+\n+    true\n+}"}, {"sha": "e14dcf92b89d2283c62dd03d14806b330e209442", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 231, "deletions": 13, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -10,33 +10,34 @@ use rustc_span::{Span, Symbol};\n \n use super::ConstCx;\n \n-/// Emits an error if `op` is not allowed in the given const context.\n-pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n+/// Emits an error and returns `true` if `op` is not allowed in the given const context.\n+pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) -> bool {\n     debug!(\"illegal_op: op={:?}\", op);\n \n     let gate = match op.status_in_item(ccx) {\n-        Status::Allowed => return,\n+        Status::Allowed => return false,\n \n         Status::Unstable(gate) if ccx.tcx.features().enabled(gate) => {\n-            let unstable_in_stable = ccx.const_kind() == hir::ConstContext::ConstFn\n-                && ccx.tcx.features().enabled(sym::staged_api)\n-                && !ccx.tcx.has_attr(ccx.def_id.to_def_id(), sym::rustc_const_unstable)\n+            let unstable_in_stable = ccx.is_const_stable_const_fn()\n                 && !super::allow_internal_unstable(ccx.tcx, ccx.def_id.to_def_id(), gate);\n \n             if unstable_in_stable {\n                 ccx.tcx.sess\n-                    .struct_span_err(span, &format!(\"`#[feature({})]` cannot be depended on in a const-stable function\", gate.as_str()))\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\"const-stable function cannot use `#[feature({})]`\", gate.as_str()),\n+                    )\n                     .span_suggestion(\n                         ccx.body.span,\n                         \"if it is not part of the public API, make this function unstably const\",\n                         concat!(r#\"#[rustc_const_unstable(feature = \"...\", issue = \"...\")]\"#, '\\n').to_owned(),\n                         Applicability::HasPlaceholders,\n                     )\n-                    .help(\"otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\")\n+                    .note(\"otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\")\n                     .emit();\n             }\n \n-            return;\n+            return unstable_in_stable;\n         }\n \n         Status::Unstable(gate) => Some(gate),\n@@ -45,12 +46,14 @@ pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n \n     if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n         ccx.tcx.sess.miri_unleashed_feature(span, gate);\n-        return;\n+        return false;\n     }\n \n     op.emit_error(ccx, span);\n+    true\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum Status {\n     Allowed,\n     Unstable(Symbol),\n@@ -59,6 +62,8 @@ pub enum Status {\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n+    const STOPS_CONST_CHECKING: bool = false;\n+\n     /// Returns an enum indicating whether this operation is allowed within the given item.\n     fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n         Status::Forbidden\n@@ -93,6 +98,34 @@ pub trait NonConstOp: std::fmt::Debug {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct Abort;\n+impl NonConstOp for Abort {\n+    const STOPS_CONST_CHECKING: bool = true;\n+\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        mcf_status_in_item(ccx)\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(ccx, span, \"abort is not stable in const fn\")\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NonPrimitiveOp;\n+impl NonConstOp for NonPrimitiveOp {\n+    const STOPS_CONST_CHECKING: bool = true;\n+\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        mcf_status_in_item(ccx)\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(ccx, span, \"only int, `bool` and `char` operations are stable in const fn\")\n+    }\n+}\n+\n /// A function call where the callee is a pointer.\n #[derive(Debug)]\n pub struct FnCallIndirect;\n@@ -125,7 +158,8 @@ impl NonConstOp for FnCallNonConst {\n ///\n /// Contains the name of the feature that would allow the use of this function.\n #[derive(Debug)]\n-pub struct FnCallUnstable(pub DefId, pub Symbol);\n+pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n+\n impl NonConstOp for FnCallUnstable {\n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let FnCallUnstable(def_id, feature) = *self;\n@@ -134,13 +168,51 @@ impl NonConstOp for FnCallUnstable {\n             span,\n             &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n         );\n-        if nightly_options::is_nightly_build() {\n-            err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n+\n+        if ccx.is_const_stable_const_fn() {\n+            err.help(\"Const-stable functions can only call other const-stable functions\");\n+        } else if nightly_options::is_nightly_build() {\n+            if let Some(feature) = feature {\n+                err.help(&format!(\n+                    \"add `#![feature({})]` to the crate attributes to enable\",\n+                    feature\n+                ));\n+            }\n         }\n         err.emit();\n     }\n }\n \n+#[derive(Debug)]\n+pub struct FnPtrCast;\n+impl NonConstOp for FnPtrCast {\n+    const STOPS_CONST_CHECKING: bool = true;\n+\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        mcf_status_in_item(ccx)\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(ccx, span, \"function pointer casts are not allowed in const fn\");\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Generator;\n+impl NonConstOp for Generator {\n+    const STOPS_CONST_CHECKING: bool = true;\n+\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        // FIXME: This means generator-only MIR is only forbidden in const fn. This is for\n+        // compatibility with the old code. Such MIR should be forbidden everywhere.\n+        mcf_status_in_item(ccx)\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(ccx, span, \"const fn generators are unstable\");\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl NonConstOp for HeapAllocation {\n@@ -403,6 +475,24 @@ impl NonConstOp for ThreadLocalAccess {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct Transmute;\n+impl NonConstOp for Transmute {\n+    const STOPS_CONST_CHECKING: bool = true;\n+\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        if ccx.const_kind() != hir::ConstContext::ConstFn {\n+            Status::Allowed\n+        } else {\n+            Status::Unstable(sym::const_fn_transmute)\n+        }\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(ccx, span, \"can only call `transmute` from const items, not `const fn`\");\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n@@ -425,3 +515,131 @@ impl NonConstOp for UnionAccess {\n         .emit();\n     }\n }\n+\n+/// See [#64992].\n+///\n+/// [#64992]: https://github.com/rust-lang/rust/issues/64992\n+#[derive(Debug)]\n+pub struct UnsizingCast;\n+impl NonConstOp for UnsizingCast {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        mcf_status_in_item(ccx)\n+    }\n+\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+        mcf_emit_error(\n+            ccx,\n+            span,\n+            \"unsizing casts to types besides slices are not allowed in const fn\",\n+        );\n+    }\n+}\n+\n+pub mod ty {\n+    use super::*;\n+\n+    #[derive(Debug)]\n+    pub struct MutRef;\n+    impl NonConstOp for MutRef {\n+        const STOPS_CONST_CHECKING: bool = true;\n+\n+        fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+            Status::Unstable(sym::const_mut_refs)\n+        }\n+\n+        fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+            mcf_emit_error(ccx, span, \"mutable references in const fn are unstable\");\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct FnPtr;\n+    impl NonConstOp for FnPtr {\n+        const STOPS_CONST_CHECKING: bool = true;\n+\n+        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+            // FIXME: This attribute a hack to allow the specialization of the `futures` API. See\n+            // #59739. We should have a proper feature gate for this.\n+            if ccx.tcx.has_attr(ccx.def_id.to_def_id(), sym::rustc_allow_const_fn_ptr) {\n+                Status::Allowed\n+            } else {\n+                mcf_status_in_item(ccx)\n+            }\n+        }\n+\n+        fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+            mcf_emit_error(ccx, span, \"function pointers in const fn are unstable\");\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct ImplTrait;\n+    impl NonConstOp for ImplTrait {\n+        const STOPS_CONST_CHECKING: bool = true;\n+\n+        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+            mcf_status_in_item(ccx)\n+        }\n+\n+        fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+            mcf_emit_error(ccx, span, \"`impl Trait` in const fn is unstable\");\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct TraitBound;\n+    impl NonConstOp for TraitBound {\n+        const STOPS_CONST_CHECKING: bool = true;\n+\n+        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+            mcf_status_in_item(ccx)\n+        }\n+\n+        fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+            mcf_emit_error(\n+                ccx,\n+                span,\n+                \"trait bounds other than `Sized` on const fn parameters are unstable\",\n+            );\n+        }\n+    }\n+\n+    /// A trait bound with the `?const Trait` opt-out\n+    #[derive(Debug)]\n+    pub struct TraitBoundNotConst;\n+    impl NonConstOp for TraitBoundNotConst {\n+        const STOPS_CONST_CHECKING: bool = true;\n+\n+        fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+            Status::Unstable(sym::const_trait_bound_opt_out)\n+        }\n+\n+        fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n+            feature_err(\n+                &ccx.tcx.sess.parse_sess,\n+                sym::const_trait_bound_opt_out,\n+                span,\n+                \"`?const Trait` syntax is unstable\",\n+            )\n+            .emit()\n+        }\n+    }\n+}\n+\n+fn mcf_status_in_item(ccx: &ConstCx<'_, '_>) -> Status {\n+    if ccx.const_kind() != hir::ConstContext::ConstFn {\n+        Status::Allowed\n+    } else {\n+        Status::Unstable(sym::const_fn)\n+    }\n+}\n+\n+fn mcf_emit_error(ccx: &ConstCx<'_, '_>, span: Span, msg: &str) {\n+    struct_span_err!(ccx.tcx.sess, span, E0723, \"{}\", msg)\n+        .note(\n+            \"see issue #57563 <https://github.com/rust-lang/rust/issues/57563> \\\n+             for more information\",\n+        )\n+        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n+        .emit();\n+}"}, {"sha": "0c171bbc464a2b0650c52906da21ce3ac63386d4", "filename": "compiler/rustc_mir/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n \n use super::ops;\n use super::qualifs::{NeedsDrop, Qualif};\n@@ -11,13 +11,13 @@ use super::ConstCx;\n \n /// Returns `true` if we should use the more precise live drop checker that runs after drop\n /// elaboration.\n-pub fn checking_enabled(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+pub fn checking_enabled(ccx: &ConstCx<'_, '_>) -> bool {\n     // Const-stable functions must always use the stable live drop checker.\n-    if tcx.features().staged_api && !tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable) {\n+    if ccx.is_const_stable_const_fn() {\n         return false;\n     }\n \n-    tcx.features().const_precise_live_drops\n+    ccx.tcx.features().const_precise_live_drops\n }\n \n /// Look for live drops in a const context.\n@@ -30,12 +30,11 @@ pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<\n         return;\n     }\n \n-    if !checking_enabled(tcx, def_id) {\n+    let ccx = ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    if !checking_enabled(&ccx) {\n         return;\n     }\n \n-    let ccx = ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n-\n     let mut visitor = CheckLiveDrops { ccx: &ccx, qualifs: Qualifs::default() };\n \n     visitor.visit_body(body);"}, {"sha": "7ea3c1d5a6f852c53117289108d3a2e10be54d2f", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 290, "deletions": 77, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -7,19 +7,21 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::{self, Instance, InstanceDef, TyCtxt};\n-use rustc_span::Span;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{\n+    self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt, TypeAndMut,\n+};\n+use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, TraitEngine};\n \n-use std::borrow::Cow;\n use std::ops::Deref;\n \n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, CustomEq, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstCx, Qualif};\n-use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n+use crate::const_eval::is_unstable_const_fn;\n use crate::dataflow::impls::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n \n@@ -176,6 +178,8 @@ pub struct Validator<'mir, 'tcx> {\n \n     /// The span of the current statement.\n     span: Span,\n+\n+    const_checking_stopped: bool,\n }\n \n impl Deref for Validator<'mir, 'tcx> {\n@@ -188,30 +192,60 @@ impl Deref for Validator<'mir, 'tcx> {\n \n impl Validator<'mir, 'tcx> {\n     pub fn new(ccx: &'mir ConstCx<'mir, 'tcx>) -> Self {\n-        Validator { span: ccx.body.span, ccx, qualifs: Default::default() }\n+        Validator {\n+            span: ccx.body.span,\n+            ccx,\n+            qualifs: Default::default(),\n+            const_checking_stopped: false,\n+        }\n     }\n \n     pub fn check_body(&mut self) {\n-        let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n-\n-        let use_min_const_fn_checks = (const_kind == Some(hir::ConstContext::ConstFn)\n-            && crate::const_eval::is_min_const_fn(tcx, def_id.to_def_id()))\n-            && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-\n-        if use_min_const_fn_checks {\n-            // Enforce `min_const_fn` for stable `const fn`s.\n-            use crate::transform::qualify_min_const_fn::is_min_const_fn;\n-            if let Err((span, err)) = is_min_const_fn(tcx, def_id.to_def_id(), &body) {\n-                error_min_const_fn_violation(tcx, span, err);\n-                return;\n+        let ConstCx { tcx, body, def_id, .. } = *self.ccx;\n+\n+        // HACK: This function has side-effects???? Make sure we call it.\n+        let _ = crate::const_eval::is_min_const_fn(tcx, def_id.to_def_id());\n+\n+        // The local type and predicate checks are not free and only relevant for `const fn`s.\n+        if self.const_kind() == hir::ConstContext::ConstFn {\n+            // Prevent const trait methods from being annotated as `stable`.\n+            // FIXME: Do this as part of stability checking.\n+            if self.is_const_stable_const_fn() {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(self.def_id);\n+                if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+                    struct_span_err!(\n+                        self.ccx.tcx.sess,\n+                        self.span,\n+                        E0723,\n+                        \"trait methods cannot be stable const fn\"\n+                    )\n+                    .emit();\n+                }\n             }\n+\n+            self.check_item_predicates();\n+\n+            for local in &body.local_decls {\n+                if local.internal {\n+                    continue;\n+                }\n+\n+                self.span = local.source_info.span;\n+                self.check_local_or_return_ty(local.ty);\n+            }\n+\n+            // impl trait is gone in MIR, so check the return type of a const fn by its signature\n+            // instead of the type of the return place.\n+            self.span = body.local_decls[RETURN_PLACE].source_info.span;\n+            let return_ty = tcx.fn_sig(def_id).output();\n+            self.check_local_or_return_ty(return_ty.skip_binder());\n         }\n \n         self.visit_body(&body);\n \n         // Ensure that the end result is `Sync` in a non-thread local `static`.\n-        let should_check_for_sync = const_kind\n-            == Some(hir::ConstContext::Static(hir::Mutability::Not))\n+        let should_check_for_sync = self.const_kind()\n+            == hir::ConstContext::Static(hir::Mutability::Not)\n             && !tcx.is_thread_local_static(def_id.to_def_id());\n \n         if should_check_for_sync {\n@@ -226,13 +260,22 @@ impl Validator<'mir, 'tcx> {\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n     pub fn check_op(&mut self, op: impl NonConstOp) {\n-        ops::non_const(self.ccx, op, self.span);\n+        self.check_op_spanned(op, self.span);\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n     /// context.\n-    pub fn check_op_spanned(&mut self, op: impl NonConstOp, span: Span) {\n-        ops::non_const(self.ccx, op, span);\n+    pub fn check_op_spanned<O: NonConstOp>(&mut self, op: O, span: Span) {\n+        // HACK: This is for strict equivalence with the old `qualify_min_const_fn` pass, which\n+        // only emitted one error per function. It should be removed and the test output updated.\n+        if self.const_checking_stopped {\n+            return;\n+        }\n+\n+        let err_emitted = ops::non_const(self.ccx, op, span);\n+        if err_emitted && O::STOPS_CONST_CHECKING {\n+            self.const_checking_stopped = true;\n+        }\n     }\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n@@ -242,6 +285,100 @@ impl Validator<'mir, 'tcx> {\n         );\n         self.check_op_spanned(ops::StaticAccess, span)\n     }\n+\n+    fn check_local_or_return_ty(&mut self, ty: Ty<'tcx>) {\n+        for ty in ty.walk() {\n+            let ty = match ty.unpack() {\n+                GenericArgKind::Type(ty) => ty,\n+\n+                // No constraints on lifetimes or constants, except potentially\n+                // constants' types, but `walk` will get to them as well.\n+                GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+            };\n+\n+            match *ty.kind() {\n+                ty::Ref(_, _, hir::Mutability::Mut) => self.check_op(ops::ty::MutRef),\n+                ty::Opaque(..) => self.check_op(ops::ty::ImplTrait),\n+                ty::FnPtr(..) => self.check_op(ops::ty::FnPtr),\n+\n+                ty::Dynamic(preds, _) => {\n+                    for pred in preds.iter() {\n+                        match pred.skip_binder() {\n+                            ty::ExistentialPredicate::AutoTrait(_)\n+                            | ty::ExistentialPredicate::Projection(_) => {\n+                                self.check_op(ops::ty::TraitBound)\n+                            }\n+                            ty::ExistentialPredicate::Trait(trait_ref) => {\n+                                if Some(trait_ref.def_id) != self.tcx.lang_items().sized_trait() {\n+                                    self.check_op(ops::ty::TraitBound)\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn check_item_predicates(&mut self) {\n+        let ConstCx { tcx, def_id, .. } = *self.ccx;\n+\n+        let mut current = def_id.to_def_id();\n+        loop {\n+            let predicates = tcx.predicates_of(current);\n+            for (predicate, _) in predicates.predicates {\n+                match predicate.skip_binders() {\n+                    ty::PredicateAtom::RegionOutlives(_)\n+                    | ty::PredicateAtom::TypeOutlives(_)\n+                    | ty::PredicateAtom::WellFormed(_)\n+                    | ty::PredicateAtom::Projection(_)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..)\n+                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n+                    ty::PredicateAtom::ObjectSafe(_) => {\n+                        bug!(\"object safe predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::ClosureKind(..) => {\n+                        bug!(\"closure kind predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::Subtype(_) => {\n+                        bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::Trait(pred, constness) => {\n+                        if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n+                            continue;\n+                        }\n+                        match pred.self_ty().kind() {\n+                            ty::Param(p) => {\n+                                let generics = tcx.generics_of(current);\n+                                let def = generics.type_param(p, tcx);\n+                                let span = tcx.def_span(def.def_id);\n+\n+                                if constness == hir::Constness::Const {\n+                                    self.check_op_spanned(ops::ty::TraitBound, span);\n+                                } else if !tcx.features().const_fn\n+                                    || self.ccx.is_const_stable_const_fn()\n+                                {\n+                                    // HACK: We shouldn't need the conditional above, but trait\n+                                    // bounds on containing impl blocks are wrongly being marked as\n+                                    // \"not-const\".\n+                                    self.check_op_spanned(ops::ty::TraitBound, span);\n+                                }\n+                            }\n+                            // other kinds of bounds are either tautologies\n+                            // or cause errors in other passes\n+                            _ => continue,\n+                        }\n+                    }\n+                }\n+            }\n+            match predicates.parent {\n+                Some(parent) => current = parent,\n+                None => break,\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n@@ -309,11 +446,6 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)\n-            | Rvalue::UnaryOp(UnOp::Neg, _)\n-            | Rvalue::UnaryOp(UnOp::Not, _)\n-            | Rvalue::NullaryOp(NullOp::SizeOf, _)\n-            | Rvalue::CheckedBinaryOp(..)\n-            | Rvalue::Cast(CastKind::Pointer(_), ..)\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(_)\n             | Rvalue::Aggregate(..) => {}\n@@ -363,6 +495,35 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n+            Rvalue::Cast(\n+                CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n+                _,\n+                _,\n+            ) => {}\n+\n+            Rvalue::Cast(\n+                CastKind::Pointer(\n+                    PointerCast::UnsafeFnPointer\n+                    | PointerCast::ClosureFnPointer(_)\n+                    | PointerCast::ReifyFnPointer,\n+                ),\n+                _,\n+                _,\n+            ) => self.check_op(ops::FnPtrCast),\n+\n+            Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), _, cast_ty) => {\n+                if let Some(TypeAndMut { ty, .. }) = cast_ty.builtin_deref(true) {\n+                    let unsized_ty = self.tcx.struct_tail_erasing_lifetimes(ty, self.param_env);\n+\n+                    // Casting/coercing things to slices is fine.\n+                    if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n+                        return;\n+                    }\n+                }\n+\n+                self.check_op(ops::UnsizingCast);\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n@@ -373,8 +534,23 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) => {}\n+            Rvalue::NullaryOp(NullOp::Box, _) => self.check_op(ops::HeapAllocation),\n+\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                let ty = operand.ty(self.body, self.tcx);\n+                if !(ty.is_integral() || ty.is_bool()) {\n+                    self.check_op(ops::NonPrimitiveOp)\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs)\n+            | Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(self.body, self.tcx);\n+                let rhs_ty = rhs.ty(self.body, self.tcx);\n+\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs_ty.kind() {\n+                    assert_eq!(lhs_ty, rhs_ty);\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -387,10 +563,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                     self.check_op(ops::RawPtrComparison);\n                 }\n-            }\n \n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                self.check_op(ops::HeapAllocation);\n+                if !(lhs_ty.is_integral() || lhs_ty.is_bool() || lhs_ty.is_char())\n+                    || !(rhs_ty.is_integral() || rhs_ty.is_bool() || rhs_ty.is_char())\n+                {\n+                    self.check_op(ops::NonPrimitiveOp)\n+                }\n             }\n         }\n     }\n@@ -491,14 +669,19 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        use rustc_target::spec::abi::Abi::RustIntrinsic;\n+\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(self.body, self.tcx);\n+                let ConstCx { tcx, body, def_id: caller, param_env, .. } = *self.ccx;\n+                let caller = caller.to_def_id();\n+\n+                let fn_ty = func.ty(body, tcx);\n \n-                let (def_id, substs) = match *fn_ty.kind() {\n+                let (mut callee, substs) = match *fn_ty.kind() {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n \n                     ty::FnPtr(_) => {\n@@ -510,38 +693,80 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     }\n                 };\n \n-                // At this point, we are calling a function whose `DefId` is known...\n-                if is_const_fn(self.tcx, def_id) {\n-                    return;\n-                }\n-\n-                // See if this is a trait method for a concrete type whose impl of that trait is\n-                // `const`.\n+                // Resolve a trait method call to its concrete implementation, which may be in a\n+                // `const` trait impl.\n                 if self.tcx.features().const_trait_impl {\n-                    let instance = Instance::resolve(self.tcx, self.param_env, def_id, substs);\n-                    debug!(\"Resolving ({:?}) -> {:?}\", def_id, instance);\n+                    let instance = Instance::resolve(tcx, param_env, callee, substs);\n+                    debug!(\"Resolving ({:?}) -> {:?}\", callee, instance);\n                     if let Ok(Some(func)) = instance {\n                         if let InstanceDef::Item(def) = func.def {\n-                            if is_const_fn(self.tcx, def.did) {\n-                                return;\n-                            }\n+                            callee = def.did;\n                         }\n                     }\n                 }\n \n-                if is_lang_panic_fn(self.tcx, def_id) {\n+                // At this point, we are calling a function, `callee`, whose `DefId` is known...\n+\n+                if is_lang_panic_fn(tcx, callee) {\n                     self.check_op(ops::Panic);\n-                } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n-                    // Exempt unstable const fns inside of macros or functions with\n-                    // `#[allow_internal_unstable]`.\n-                    use crate::transform::qualify_min_const_fn::lib_feature_allowed;\n-                    if !self.span.allows_unstable(feature)\n-                        && !lib_feature_allowed(self.tcx, self.def_id.to_def_id(), feature)\n-                    {\n-                        self.check_op(ops::FnCallUnstable(def_id, feature));\n+                    return;\n+                }\n+\n+                // HACK: This is to \"unstabilize\" the `transmute` intrinsic\n+                // within const fns. `transmute` is allowed in all other const contexts.\n+                // This won't really scale to more intrinsics or functions. Let's allow const\n+                // transmutes in const fn before we add more hacks to this.\n+                if tcx.fn_sig(callee).abi() == RustIntrinsic\n+                    && tcx.item_name(callee) == sym::transmute\n+                {\n+                    self.check_op(ops::Transmute);\n+                    return;\n+                }\n+\n+                if !tcx.is_const_fn_raw(callee) {\n+                    self.check_op(ops::FnCallNonConst(callee));\n+                    return;\n+                }\n+\n+                // If the `const fn` we are trying to call is not const-stable, ensure that we have\n+                // the proper feature gate enabled.\n+                if let Some(gate) = is_unstable_const_fn(tcx, callee) {\n+                    if self.span.allows_unstable(gate) {\n+                        return;\n+                    }\n+\n+                    // Calling an unstable function *always* requires that the corresponding gate\n+                    // be enabled, even if the function has `#[allow_internal_unstable(the_gate)]`.\n+                    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate) {\n+                        self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n+                        return;\n+                    }\n+\n+                    // If this crate is not using stability attributes, or the caller is not claiming to be a\n+                    // stable `const fn`, that is all that is required.\n+                    if !self.ccx.is_const_stable_const_fn() {\n+                        return;\n+                    }\n+\n+                    // Otherwise, we are something const-stable calling a const-unstable fn.\n+\n+                    if super::allow_internal_unstable(tcx, caller, gate) {\n+                        return;\n+                    }\n+\n+                    self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n+                    return;\n+                }\n+\n+                // FIXME(ecstaticmorse); For compatibility, we consider `unstable` callees that\n+                // have no `rustc_const_stable` attributes to be const-unstable as well. This\n+                // should be fixed later.\n+                let callee_is_unstable_unmarked = tcx.lookup_const_stability(callee).is_none()\n+                    && tcx.lookup_stability(callee).map_or(false, |s| s.level.is_unstable());\n+                if callee_is_unstable_unmarked {\n+                    if self.ccx.is_const_stable_const_fn() {\n+                        self.check_op(ops::FnCallUnstable(callee, None));\n                     }\n-                } else {\n-                    self.check_op(ops::FnCallNonConst(def_id));\n                 }\n             }\n \n@@ -551,7 +776,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n-                if super::post_drop_elaboration::checking_enabled(self.tcx, self.def_id) {\n+                if super::post_drop_elaboration::checking_enabled(self.ccx) {\n                     return;\n                 }\n \n@@ -582,37 +807,25 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n-            TerminatorKind::InlineAsm { .. } => {\n-                self.check_op(ops::InlineAsm);\n+            TerminatorKind::InlineAsm { .. } => self.check_op(ops::InlineAsm),\n+            TerminatorKind::Abort => self.check_op(ops::Abort),\n+\n+            TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n+                self.check_op(ops::Generator)\n             }\n \n-            // FIXME: Some of these are only caught by `min_const_fn`, but should error here\n-            // instead.\n-            TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n+            TerminatorKind::Assert { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::Yield { .. } => {}\n+            | TerminatorKind::Unreachable => {}\n         }\n     }\n }\n \n-fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n-    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n-        .note(\n-            \"see issue #57563 <https://github.com/rust-lang/rust/issues/57563> \\\n-             for more information\",\n-        )\n-        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n-        .emit();\n-}\n-\n fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "f801c1ac75bc38af2383d67af98258c991b6dcb4", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -217,6 +217,7 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     /// assert!(!bull.is_borrowed());\n     /// ```\n     #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    #[rustc_const_unstable(feature = \"const_cow_is_borrowed\", issue = \"65143\")]\n     pub const fn is_borrowed(&self) -> bool {\n         match *self {\n             Borrowed(_) => true,\n@@ -239,6 +240,7 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     /// assert!(!bull.is_owned());\n     /// ```\n     #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    #[rustc_const_unstable(feature = \"const_cow_is_borrowed\", issue = \"65143\")]\n     pub const fn is_owned(&self) -> bool {\n         !self.is_borrowed()\n     }"}, {"sha": "b33cb3ad8e8399486561f98f065615dcdb706d57", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -86,9 +86,11 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n #![feature(const_btree_new)]\n+#![feature(const_fn)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n #![feature(cow_is_borrowed)]\n+#![feature(const_cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]"}, {"sha": "e6da599006000dbdeef4f570fc993cab3d45372d", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -150,6 +150,7 @@ impl<T> RawVec<T, Global> {\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n+    #[allow_internal_unstable(const_fn)]\n     pub const fn new_in(alloc: A) -> Self {\n         // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n         Self { ptr: Unique::dangling(), cap: 0, alloc }"}, {"sha": "cff8ff9ac7ad9a20bcdddab15ef4a0b09523577c", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,6 +1,7 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n+#![feature(const_cow_is_borrowed)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(new_uninit)]"}, {"sha": "a3fbed2ec1254d09c8aca3d891d0127acfe2105b", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -177,6 +177,7 @@ impl Layout {\n     /// sentinel value. Types that lazily allocate must track initialization by\n     /// some other means.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub const fn dangling(&self) -> NonNull<u8> {\n         // SAFETY: align is guaranteed to be non-zero"}, {"sha": "fa5655ca35f41b2f97e14ded32efd1ee464b1869", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -56,6 +56,7 @@ unsafe impl Sync for ResumeTy {}\n #[lang = \"from_generator\"]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[rustc_const_unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n where"}, {"sha": "86eda843c5bc32903d6187d4b74e595d6da07cbf", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -75,11 +75,13 @@\n #![feature(const_float_bits_conv)]\n #![feature(const_overflowing_int_methods)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_mut_refs)]\n #![feature(const_int_pow)]\n #![feature(constctlz)]\n #![feature(const_panic)]\n #![feature(const_pin)]\n #![feature(const_fn_union)]\n+#![feature(const_fn)]\n #![feature(const_generics)]\n #![feature(const_option)]\n #![feature(const_precise_live_drops)]"}, {"sha": "ba3d4c075e11f9e2830a8ea97c73361abac6ed78", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -401,6 +401,7 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n }\n \n impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+    #[allow_internal_unstable(const_fn)]\n     pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n@@ -413,6 +414,7 @@ impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n }\n \n impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+    #[allow_internal_unstable(const_fn)]\n     pub const fn expand2(\n         f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n@@ -457,6 +459,7 @@ impl ProcMacro {\n         }\n     }\n \n+    #[allow_internal_unstable(const_fn)]\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n@@ -465,13 +468,15 @@ impl ProcMacro {\n         ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n     }\n \n+    #[allow_internal_unstable(const_fn)]\n     pub const fn attr(\n         name: &'static str,\n         expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::Attr { name, client: Client::expand2(expand) }\n     }\n \n+    #[allow_internal_unstable(const_fn)]\n     pub const fn bang(\n         name: &'static str,\n         expand: fn(crate::TokenStream) -> crate::TokenStream,"}, {"sha": "daa577f74bac3af4de376dbc8d8de2f6a234a1a5", "filename": "library/proc_macro/src/bridge/scoped_cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -35,6 +35,7 @@ impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n \n impl<T: LambdaL> ScopedCell<T> {\n+    #[allow_internal_unstable(const_fn)]\n     pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n         ScopedCell(Cell::new(value))\n     }"}, {"sha": "f81ffd2bb9429811b26d67c77e16f9db2735ca97", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -20,6 +20,7 @@\n )]\n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(const_fn)]\n #![feature(allow_internal_unstable)]\n #![feature(decl_macro)]\n #![feature(extern_types)]"}, {"sha": "309657e70424b1e5b0ff9df86181088cd1eb5dfd", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -237,6 +237,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_fn_transmute)]\n+#![feature(const_fn)]\n #![feature(const_ipv6)]\n #![feature(const_raw_ptr_deref)]\n #![feature(const_ipv4)]\n@@ -306,6 +307,7 @@\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(thread_local)]\n+#![feature(thread_local_internals)]\n #![feature(toowned_clone_into)]\n #![feature(total_cmp)]\n #![feature(trace_macros)]"}, {"sha": "676eadd1fac3b56cee5363441cd6c17ddc11e5c3", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -117,6 +117,7 @@ pub struct Key {\n pub const INIT: StaticKey = StaticKey::new(None);\n \n impl StaticKey {\n+    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n     pub const fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> StaticKey {\n         StaticKey { key: atomic::AtomicUsize::new(0), dtor }\n     }"}, {"sha": "784b376fcdc06185fa8aca1f8094806eaf266639", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -225,6 +225,7 @@ impl<T: 'static> LocalKey<T> {\n         reason = \"recently added to create a key\",\n         issue = \"none\"\n     )]\n+    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n     pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n         LocalKey { inner }\n     }\n@@ -497,6 +498,7 @@ pub mod os {\n     }\n \n     impl<T: 'static> Key<T> {\n+        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n         pub const fn new() -> Key<T> {\n             Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n         }"}, {"sha": "644748786036d0b41f3e0981596ba2d0fa975d51", "filename": "src/test/compile-fail/consts/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -5,9 +5,7 @@ const X : usize = 2;\n const fn f(x: usize) -> usize {\n     let mut sum = 0;\n     for i in 0..x {\n-        //~^ ERROR E0015\n-        //~| ERROR E0015\n-        //~| ERROR E0658\n+        //~^ ERROR mutable references\n         //~| ERROR E0080\n         //~| ERROR E0744\n         sum += i;"}, {"sha": "e18e0a83573eed5fe892254eb05af93a0ce1ba44", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -7,7 +7,7 @@ extern \"C\" {\n const extern fn bar() {\n     unsafe {\n         regular_in_block();\n-        //~^ ERROR: can only call other `const fn` within a `const fn`\n+        //~^ ERROR: calls in constant functions\n     }\n }\n \n@@ -16,7 +16,7 @@ extern fn regular() {}\n const extern fn foo() {\n     unsafe {\n         regular();\n-        //~^ ERROR: can only call other `const fn` within a `const fn`\n+        //~^ ERROR: calls in constant functions\n     }\n }\n "}, {"sha": "348387ff5f827521fe56fe87f9e740467e4e3140", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,21 +1,15 @@\n-error[E0723]: can only call other `const fn` within a `const fn`, but `regular_in_block` is not stable as `const fn`\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/const-extern-fn-call-extern-fn.rs:9:9\n    |\n LL |         regular_in_block();\n    |         ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `regular` is not stable as `const fn`\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/const-extern-fn-call-extern-fn.rs:18:9\n    |\n LL |         regular();\n    |         ^^^^^^^^^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0723`.\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "e0b9e5f33759e661b37d0ac9130dec6f746943a7", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-min-const-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -6,7 +6,7 @@ const unsafe extern \"C\" fn closure() -> fn() { || {} }\n const unsafe extern fn use_float() { 1.0 + 1.0; }\n //~^ ERROR only int, `bool` and `char` operations are stable in const fn\n const extern \"C\" fn ptr_cast(val: *const u8) { val as usize; }\n-//~^ ERROR casting pointers to ints is unstable in const fn\n+//~^ ERROR casting pointers to integers\n \n \n fn main() {}"}, {"sha": "5ca44b3fa7e654b13ee1796d88770887e0a36ca4", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-min-const-fn.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-min-const-fn.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -16,15 +16,16 @@ LL | const unsafe extern fn use_float() { 1.0 + 1.0; }\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: casting pointers to ints is unstable in const fn\n+error[E0658]: casting pointers to integers in constant functions is unstable\n   --> $DIR/const-extern-fn-min-const-fn.rs:8:48\n    |\n LL | const extern \"C\" fn ptr_cast(val: *const u8) { val as usize; }\n    |                                                ^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n+   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0723`.\n+Some errors have detailed explanations: E0658, E0723.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "0446ece421eff33e1838e76c25f611ad4bb40f19", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,6 +1,6 @@\n // Test that we can't call random fns in a const fn or do other bad things.\n \n-#![feature(const_fn, const_transmute)]\n+#![feature(const_fn, const_fn_transmute)]\n \n use std::mem::transmute;\n "}, {"sha": "f31543af590d66c05e02788aba08d349687af5b6", "filename": "src/test/ui/consts/const-mut-refs/feature-gate-const_mut_refs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -2,6 +2,7 @@ fn main() {\n     foo(&mut 5);\n }\n \n-const fn foo(x: &mut i32) -> i32 { //~ ERROR mutable references in const fn are unstable\n+const fn foo(x: &mut i32) -> i32 { //~ ERROR mutable references in const fn\n     *x + 1\n+\n }"}, {"sha": "9d5ccb880aa1b6d71924f3a7b811bd058cf8e15d", "filename": "src/test/ui/consts/const_let_assign3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -6,8 +6,8 @@ struct S {\n \n impl S {\n     const fn foo(&mut self, x: u32) {\n+        //~^ ERROR mutable references\n         self.state = x;\n-        //~^ contains unimplemented expression\n     }\n }\n "}, {"sha": "785d9c8c2a5fb7fbf263474c32b5b3dac3f0043f", "filename": "src/test/ui/consts/const_let_assign3.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,10 +1,11 @@\n-error[E0019]: constant function contains unimplemented expression type\n-  --> $DIR/const_let_assign3.rs:9:9\n+error[E0723]: mutable references in const fn are unstable\n+  --> $DIR/const_let_assign3.rs:8:18\n    |\n-LL |         self.state = x;\n-   |         ^^^^^^^^^^^^^^\n+LL |     const fn foo(&mut self, x: u32) {\n+   |                  ^^^^^^^^^\n    |\n-   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0764]: mutable references are not allowed in constants\n   --> $DIR/const_let_assign3.rs:16:5\n@@ -28,5 +29,5 @@ LL |     *y = 42;\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0019, E0764.\n+Some errors have detailed explanations: E0019, E0723, E0764.\n For more information about an error, try `rustc --explain E0019`."}, {"sha": "589085871fba967c9958dd19b2c5d5d01b23f2bd", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,5 +1,8 @@\n const fn foo(a: i32) -> Vec<i32> {\n-    vec![1, 2, 3] //~ ERROR heap allocations are not allowed in const fn\n+    vec![1, 2, 3]\n+    //~^ ERROR allocations are not allowed\n+    //~| ERROR unimplemented expression type\n+    //~| ERROR calls in constant functions\n }\n \n fn main() {}"}, {"sha": "0f16890141f6bf5fa1b2afc8a17fbb29d4203f9d", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,13 +1,29 @@\n-error[E0723]: heap allocations are not allowed in const fn\n+error[E0010]: allocations are not allowed in constant functions\n+  --> $DIR/bad_const_fn_body_ice.rs:2:5\n+   |\n+LL |     vec![1, 2, 3]\n+   |     ^^^^^^^^^^^^^ allocation not allowed in constant functions\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0019]: constant function contains unimplemented expression type\n+  --> $DIR/bad_const_fn_body_ice.rs:2:5\n+   |\n+LL |     vec![1, 2, 3]\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/bad_const_fn_body_ice.rs:2:5\n    |\n LL |     vec![1, 2, 3]\n    |     ^^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0723`.\n+Some errors have detailed explanations: E0010, E0015, E0019.\n+For more information about an error, try `rustc --explain E0010`."}, {"sha": "5dd70acb6ff1c6cec1e013dbd5d32da6cc93fc61", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -78,25 +78,25 @@ const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n const fn foo11_2<T: Send>(t: T) -> T { t }\n //~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n const fn foo19(f: f32) -> f32 { f * 2.0 }\n-//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+//~^ ERROR int, `bool` and `char` operations\n const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n-//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+//~^ ERROR int, `bool` and `char` operations\n const fn foo19_3(f: f32) -> f32 { -f }\n-//~^ ERROR only int and `bool` operations are stable in const fn\n+//~^ ERROR int, `bool` and `char` operations\n const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n-//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+//~^ ERROR int, `bool` and `char` operations\n \n static BAR: u32 = 42;\n-const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n-const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n+const fn foo25() -> u32 { BAR } //~ ERROR cannot refer to statics\n+const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot refer to statics\n const fn foo30(x: *const u32) -> usize { x as usize }\n-//~^ ERROR casting pointers to ints is unstable\n+//~^ ERROR casting pointers to integers\n const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize } }\n-//~^ ERROR casting pointers to ints is unstable\n+//~^ ERROR casting pointers to integers\n const fn foo30_2(x: *mut u32) -> usize { x as usize }\n-//~^ ERROR casting pointers to ints is unstable\n+//~^ ERROR casting pointers to integers\n const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n-//~^ ERROR casting pointers to ints is unstable\n+//~^ ERROR casting pointers to integers\n const fn foo30_6() -> bool { let x = true; x }\n const fn inc(x: &mut i32) { *x += 1 }\n //~^ ERROR mutable references in const fn are unstable"}, {"sha": "d4498f061c64bf71ca1ff6c9bef611fbf40bd826", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -94,7 +94,7 @@ LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: only int and `bool` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:84:35\n    |\n LL | const fn foo19_3(f: f32) -> f32 { -f }\n@@ -112,59 +112,57 @@ LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: cannot access `static` items in const fn\n+error[E0013]: constant functions cannot refer to statics\n   --> $DIR/min_const_fn.rs:90:27\n    |\n LL | const fn foo25() -> u32 { BAR }\n    |                           ^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: consider extracting the value of the `static` to a `const`, and referring to that\n \n-error[E0723]: cannot access `static` items in const fn\n+error[E0013]: constant functions cannot refer to statics\n   --> $DIR/min_const_fn.rs:91:37\n    |\n LL | const fn foo26() -> &'static u32 { &BAR }\n    |                                     ^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: consider extracting the value of the `static` to a `const`, and referring to that\n \n-error[E0723]: casting pointers to ints is unstable in const fn\n+error[E0658]: casting pointers to integers in constant functions is unstable\n   --> $DIR/min_const_fn.rs:92:42\n    |\n LL | const fn foo30(x: *const u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n+   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n-error[E0723]: casting pointers to ints is unstable in const fn\n+error[E0658]: casting pointers to integers in constant functions is unstable\n   --> $DIR/min_const_fn.rs:94:63\n    |\n LL | const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n+   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n-error[E0723]: casting pointers to ints is unstable in const fn\n+error[E0658]: casting pointers to integers in constant functions is unstable\n   --> $DIR/min_const_fn.rs:96:42\n    |\n LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n+   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n-error[E0723]: casting pointers to ints is unstable in const fn\n+error[E0658]: casting pointers to integers in constant functions is unstable\n   --> $DIR/min_const_fn.rs:98:63\n    |\n LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n+   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:101:14\n@@ -267,5 +265,5 @@ LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n \n error: aborting due to 30 previous errors\n \n-Some errors have detailed explanations: E0493, E0723.\n-For more information about an error, try `rustc --explain E0493`.\n+Some errors have detailed explanations: E0013, E0493, E0658, E0723.\n+For more information about an error, try `rustc --explain E0013`."}, {"sha": "b83fdf7c656cdfefc518038eaa88f52c11776d78", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -13,20 +13,21 @@ const fn foo() -> u32 { 42 }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar() -> u32 { foo() } //~ ERROR can only call other `const fn`\n+const fn bar() -> u32 { foo() } //~ ERROR not yet stable as a const fn\n \n #[unstable(feature = \"rust1\", issue = \"none\")]\n const fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `const fn`\n+const fn bar2() -> u32 { foo2() } //~ ERROR not yet stable as a const fn\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // conformity is required, even with `const_fn` feature gate\n-const fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` operations\n+const fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n+//~^ ERROR const-stable function cannot use `#[feature(const_fn)]`\n \n // check whether this function cannot be called even with the feature gate active\n #[unstable(feature = \"foo2\", issue = \"none\")]\n@@ -35,6 +36,6 @@ const fn foo2_gated() -> u32 { 42 }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `const fn`\n+const fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR not yet stable as a const fn\n \n fn main() {}"}, {"sha": "a1f1f6f52ab2ac2031c3582a110a6b7009740eb9", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,39 +1,38 @@\n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo` is not stable as `const fn`\n+error: `foo` is not yet stable as a const fn\n   --> $DIR/min_const_fn_libstd_stability.rs:16:25\n    |\n LL | const fn bar() -> u32 { foo() }\n    |                         ^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2` is not stable as `const fn`\n+error: `foo2` is not yet stable as a const fn\n   --> $DIR/min_const_fn_libstd_stability.rs:24:26\n    |\n LL | const fn bar2() -> u32 { foo2() }\n    |                          ^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: only int, `bool` and `char` operations are stable in const fn\n+error: const-stable function cannot use `#[feature(const_fn)]`\n   --> $DIR/min_const_fn_libstd_stability.rs:29:26\n    |\n LL | const fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |                          ^^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\n+help: if it is not part of the public API, make this function unstably const\n+   |\n+LL | #[rustc_const_unstable(feature = \"...\", issue = \"...\")]\n+   |\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2_gated` is not stable as `const fn`\n-  --> $DIR/min_const_fn_libstd_stability.rs:38:32\n+error: `foo2_gated` is not yet stable as a const fn\n+  --> $DIR/min_const_fn_libstd_stability.rs:39:32\n    |\n LL | const fn bar2_gated() -> u32 { foo2_gated() }\n    |                                ^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0723`."}, {"sha": "0c8af5a199aa0179c395ad3e0a46fae5ad0cb8be", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -12,5 +12,5 @@ fn main() {}\n const unsafe fn no_union() {\n     union Foo { x: (), y: () }\n     Foo { x: () }.y\n-    //~^ accessing union fields is unstable\n+    //~^ unions in const fn\n }"}, {"sha": "322052c28fab13b1ef95e2f1d045e58ebd332e9c", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -25,16 +25,15 @@ LL | const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static u\n    = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n-error[E0723]: accessing union fields is unstable\n+error[E0658]: unions in const fn are unstable\n   --> $DIR/min_const_fn_unsafe_bad.rs:14:5\n    |\n LL |     Foo { x: () }.y\n    |     ^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: see issue #51909 <https://github.com/rust-lang/rust/issues/51909> for more information\n+   = help: add `#![feature(const_fn_union)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0658, E0723.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "902ed435e31bc05c252ede664c0d3bc0e09ec137", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -13,20 +13,21 @@ const unsafe fn foo() -> u32 { 42 }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `const fn`\n+const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR not yet stable as a const fn\n \n #[unstable(feature = \"rust1\", issue = \"none\")]\n const unsafe fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `const fn`\n+const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR not yet stable as a const fn\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // conformity is required, even with `const_fn` feature gate\n-const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` op\n+const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n+//~^ ERROR const-stable function cannot use `#[feature(const_fn)]`\n \n // check whether this function cannot be called even with the feature gate active\n #[unstable(feature = \"foo2\", issue = \"none\")]\n@@ -36,6 +37,6 @@ const unsafe fn foo2_gated() -> u32 { 42 }\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } }\n-//~^ ERROR can only call other `const fn`\n+//~^ ERROR not yet stable as a const fn\n \n fn main() {}"}, {"sha": "2741a86440487c9849b372f298287e245bc5c6eb", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,39 +1,38 @@\n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo` is not stable as `const fn`\n+error: `foo` is not yet stable as a const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:16:41\n    |\n LL | const unsafe fn bar() -> u32 { unsafe { foo() } }\n    |                                         ^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2` is not stable as `const fn`\n+error: `foo2` is not yet stable as a const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:24:42\n    |\n LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } }\n    |                                          ^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: only int, `bool` and `char` operations are stable in const fn\n+error: const-stable function cannot use `#[feature(const_fn)]`\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:29:33\n    |\n LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |                                 ^^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = note: otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\n+help: if it is not part of the public API, make this function unstably const\n+   |\n+LL | #[rustc_const_unstable(feature = \"...\", issue = \"...\")]\n+   |\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2_gated` is not stable as `const fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:38:48\n+error: `foo2_gated` is not yet stable as a const fn\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:39:48\n    |\n LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } }\n    |                                                ^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0723`."}, {"sha": "d17dcb281153c41fffcef1fa2269edca036632ca", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -13,15 +13,15 @@ const fn foo() -> u32 { 42 }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `const fn`\n+const unsafe fn bar() -> u32 { foo() } //~ ERROR not yet stable as a const fn\n \n #[unstable(feature = \"rust1\", issue = \"none\")]\n const fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `const fn`\n+const unsafe fn bar2() -> u32 { foo2() } //~ ERROR not yet stable as a const fn\n \n // check whether this function cannot be called even with the feature gate active\n #[unstable(feature = \"foo2\", issue = \"none\")]\n@@ -30,6 +30,6 @@ const fn foo2_gated() -> u32 { 42 }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `const fn`\n+const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR not yet stable as a const fn\n \n fn main() {}"}, {"sha": "891c34a888a700b95f6133670a9dd06c01746c9d", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,30 +1,26 @@\n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo` is not stable as `const fn`\n+error: `foo` is not yet stable as a const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:16:32\n    |\n LL | const unsafe fn bar() -> u32 { foo() }\n    |                                ^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2` is not stable as `const fn`\n+error: `foo2` is not yet stable as a const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:24:33\n    |\n LL | const unsafe fn bar2() -> u32 { foo2() }\n    |                                 ^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `foo2_gated` is not stable as `const fn`\n+error: `foo2_gated` is not yet stable as a const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:33:39\n    |\n LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() }\n    |                                       ^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0723`."}, {"sha": "93b67fd7b1428a710bfe9dd6efd678107fae0c0a", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -12,6 +12,16 @@ LL | static VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"\n \n warning: skipping const checks\n    |\n+help: skipping check for `const_fn` feature\n+  --> $DIR/abi-mismatch.rs:9:23\n+   |\n+LL | const fn call_rust_fn(my_fn: extern \"Rust\" fn()) {\n+   |                       ^^^^^\n+help: skipping check for `const_fn` feature\n+  --> $DIR/abi-mismatch.rs:10:5\n+   |\n+LL |     my_fn();\n+   |     ^^^^^\n help: skipping check that does not even have a feature gate\n   --> $DIR/abi-mismatch.rs:10:5\n    |"}, {"sha": "af6bc2d85fdd68770ecec1fd5167087415837af3", "filename": "src/test/ui/consts/unsizing-cast-non-null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -4,7 +4,7 @@ use std::ptr::NonNull;\n \n pub const fn dangling_slice<T>() -> NonNull<[T]> {\n     NonNull::<[T; 0]>::dangling()\n-    //~^ ERROR: unsizing casts are only allowed for references right now\n+    //~^ ERROR: unsizing casts to types besides slices\n }\n \n fn main() {}"}, {"sha": "dc08ccd02b646533d17ebdda9e86b4761b64cb9d", "filename": "src/test/ui/consts/unsizing-cast-non-null.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,4 +1,4 @@\n-error[E0723]: unsizing casts are only allowed for references right now\n+error[E0723]: unsizing casts to types besides slices are not allowed in const fn\n   --> $DIR/unsizing-cast-non-null.rs:6:5\n    |\n LL |     NonNull::<[T; 0]>::dangling()"}, {"sha": "43951c6854b1aa820cd0f2f857b693eb6d318edc", "filename": "src/test/ui/consts/unstable-const-fn-in-libcore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -6,6 +6,7 @@\n #![stable(feature = \"core\", since = \"1.6.0\")]\n #![feature(rustc_const_unstable)]\n #![feature(staged_api)]\n+#![feature(const_fn)]\n \n enum Opt<T> {\n     Some(T),"}, {"sha": "928605356a16e3d94f07d1215c509599b1ece247", "filename": "src/test/ui/consts/unstable-const-fn-in-libcore.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,11 +1,11 @@\n error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/unstable-const-fn-in-libcore.rs:23:26\n+  --> $DIR/unstable-const-fn-in-libcore.rs:24:26\n    |\n LL |             Opt::None => f(),\n    |                          ^^^\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/unstable-const-fn-in-libcore.rs:18:53\n+  --> $DIR/unstable-const-fn-in-libcore.rs:19:53\n    |\n LL |     const fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n    |                                                     ^ constant functions cannot evaluate destructors\n@@ -14,7 +14,7 @@ LL |     }\n    |     - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/unstable-const-fn-in-libcore.rs:18:47\n+  --> $DIR/unstable-const-fn-in-libcore.rs:19:47\n    |\n LL |     const fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n    |                                               ^^^^ constant functions cannot evaluate destructors"}, {"sha": "6d3fc3ce2f171440d156456ece8ece25b85f6a68", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -12,6 +12,7 @@ fn main() {\n     extern \"C\" fn ff4() {} // OK.\n     const async unsafe extern \"C\" fn ff5() {} // OK.\n     //~^ ERROR functions cannot be both `const` and `async`\n+    //~| ERROR `from_generator` is not yet stable as a const fn\n \n     trait X {\n         async fn ft1(); //~ ERROR functions in traits cannot be declared `async`\n@@ -34,6 +35,7 @@ fn main() {\n         const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR functions in traits cannot be declared `async`\n         //~| ERROR functions in traits cannot be declared const\n+        //~| ERROR `from_generator` is not yet stable as a const fn\n         //~| ERROR method `ft5` has an incompatible type for trait\n         //~| ERROR functions cannot be both `const` and `async`\n     }\n@@ -45,6 +47,7 @@ fn main() {\n         extern \"C\" fn fi4() {} // OK.\n         const async unsafe extern \"C\" fn fi5() {}\n         //~^ ERROR functions cannot be both `const` and `async`\n+        //~| ERROR `from_generator` is not yet stable as a const fn\n     }\n \n     extern {"}, {"sha": "f1e21884040f0e568fe6b9c54b2867838a6ef729", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -8,7 +8,7 @@ LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n    |     `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:17:9\n+  --> $DIR/fn-header-semantic-fail.rs:18:9\n    |\n LL |         async fn ft1();\n    |         -----^^^^^^^^^^\n@@ -19,19 +19,19 @@ LL |         async fn ft1();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:19:9\n+  --> $DIR/fn-header-semantic-fail.rs:20:9\n    |\n LL |         const fn ft3();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:22:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:22:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:22:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^-^^^^^----------------------------\n@@ -51,7 +51,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    |         `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:29:9\n+  --> $DIR/fn-header-semantic-fail.rs:30:9\n    |\n LL |         async fn ft1() {}\n    |         -----^^^^^^^^^^^^\n@@ -62,19 +62,19 @@ LL |         async fn ft1() {}\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:32:9\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n LL |         const fn ft3() {}\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:34:9\n+  --> $DIR/fn-header-semantic-fail.rs:35:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:34:9\n+  --> $DIR/fn-header-semantic-fail.rs:35:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -85,7 +85,7 @@ LL |         const async unsafe extern \"C\" fn ft5() {}\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:34:9\n+  --> $DIR/fn-header-semantic-fail.rs:35:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^-^^^^^------------------------------\n@@ -94,7 +94,7 @@ LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         `const` because of this\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:46:9\n+  --> $DIR/fn-header-semantic-fail.rs:48:9\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         ^^^^^-^^^^^------------------------------\n@@ -103,7 +103,7 @@ LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         `const` because of this\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:18\n+  --> $DIR/fn-header-semantic-fail.rs:54:18\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -113,7 +113,7 @@ LL |         async fn fe1();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:19\n+  --> $DIR/fn-header-semantic-fail.rs:55:19\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -124,7 +124,7 @@ LL |         unsafe fn fe2();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:18\n+  --> $DIR/fn-header-semantic-fail.rs:56:18\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -135,7 +135,7 @@ LL |         const fn fe3();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:54:23\n+  --> $DIR/fn-header-semantic-fail.rs:57:23\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -146,7 +146,7 @@ LL |         extern \"C\" fn fe4();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:55:42\n+  --> $DIR/fn-header-semantic-fail.rs:58:42\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -157,16 +157,24 @@ LL |         const async unsafe extern \"C\" fn fe5();\n    |         help: remove the qualifiers: `fn`\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:55:9\n+  --> $DIR/fn-header-semantic-fail.rs:58:9\n    |\n LL |         const async unsafe extern \"C\" fn fe5();\n    |         ^^^^^-^^^^^----------------------------\n    |         |     |\n    |         |     `async` because of this\n    |         `const` because of this\n \n+error: `from_generator` is not yet stable as a const fn\n+  --> $DIR/fn-header-semantic-fail.rs:13:44\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n+   |                                            ^^\n+   |\n+   = help: add `#![feature(gen_future)]` to the crate attributes to enable\n+\n error[E0053]: method `ft1` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:29:24\n+  --> $DIR/fn-header-semantic-fail.rs:30:24\n    |\n LL |         async fn ft1();\n    |                       - type in trait\n@@ -181,7 +189,7 @@ LL |         async fn ft1() {}\n               found fn pointer `fn() -> impl Future`\n \n error[E0053]: method `ft5` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:34:48\n+  --> $DIR/fn-header-semantic-fail.rs:35:48\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |                                               - type in trait\n@@ -195,7 +203,23 @@ LL |         const async unsafe extern \"C\" fn ft5() {}\n    = note: expected fn pointer `unsafe extern \"C\" fn()`\n               found fn pointer `unsafe extern \"C\" fn() -> impl Future`\n \n-error: aborting due to 20 previous errors\n+error: `from_generator` is not yet stable as a const fn\n+  --> $DIR/fn-header-semantic-fail.rs:35:48\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |                                                ^^\n+   |\n+   = help: add `#![feature(gen_future)]` to the crate attributes to enable\n+\n+error: `from_generator` is not yet stable as a const fn\n+  --> $DIR/fn-header-semantic-fail.rs:48:48\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |                                                ^^\n+   |\n+   = help: add `#![feature(gen_future)]` to the crate attributes to enable\n+\n+error: aborting due to 23 previous errors\n \n Some errors have detailed explanations: E0053, E0379, E0706.\n For more information about an error, try `rustc --explain E0053`."}, {"sha": "fc85e98ef532689d924d1ec0741c7458935cde7e", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -10,7 +10,7 @@ fn non_const() {}\n \n impl const T for S {\n     fn foo() { non_const() }\n-    //~^ ERROR can only call other `const fn`\n+    //~^ ERROR calls in constant functions\n }\n \n fn main() {}"}, {"sha": "c6c78c7d1e89564873908c5bb6cff24f0334bd01", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,12 +1,9 @@\n-error[E0723]: can only call other `const fn` within a `const fn`, but `non_const` is not stable as `const fn`\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/const-check-fns-in-const-impl.rs:12:16\n    |\n LL |     fn foo() { non_const() }\n    |                ^^^^^^^^^^^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0723`.\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "58041454d5901058fa3cc093586d8b9f48cc852d", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.gated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,5 +1,5 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/feature-gate.rs:16:1\n+  --> $DIR/feature-gate.rs:17:1\n    |\n LL | fn main() {}\n    | ^^^^^^^^^"}, {"sha": "3506237d1f1d58b8f5450a062cbc650b7eb0a01a", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(gated, feature(const_trait_bound_opt_out))]\n #![allow(incomplete_features)]\n #![feature(rustc_attrs)]\n+#![feature(const_fn)]\n \n trait T {\n     const CONST: i32;"}, {"sha": "8ae8b8868ddedaccb09b96b8af1d45e9cf28bf5b", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.stock.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `?const` on trait bounds is experimental\n-  --> $DIR/feature-gate.rs:12:29\n+  --> $DIR/feature-gate.rs:13:29\n    |\n LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n    |                             ^^^^^^"}, {"sha": "454fde34a2cdca25aee5f58945b45ba4c88d204a", "filename": "src/test/ui/rfc-2632-const-trait-impl/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -30,7 +30,7 @@ impl const std::ops::Add for Int {\n #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const fn foo() -> Int {\n     Int(1i32) + Int(2i32)\n-    //~^ ERROR can only call other `const fn` within a `const fn`\n+    //~^ ERROR not yet stable as a const fn\n }\n \n // ok"}, {"sha": "54d7cfd5d797390023baa754edbe2faea4f13298", "filename": "src/test/ui/rfc-2632-const-trait-impl/stability.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -6,18 +6,14 @@ LL | |\n LL | |         Int(self.0 - rhs.0)\n LL | |     }\n    | |_____^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `<Int as Add>::add` is not stable as `const fn`\n+error: `<Int as Add>::add` is not yet stable as a const fn\n   --> $DIR/stability.rs:32:5\n    |\n LL |     Int(1i32) + Int(2i32)\n    |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+   = help: Const-stable functions can only call other const-stable functions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "65e0d79308ca3e04eb0295b4956bee0f7760c2fe", "filename": "src/test/ui/unsafe/ranged_ints2_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d59207ad56e24a2bfefa3544de48a0f6491363/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs?ref=f6d59207ad56e24a2bfefa3544de48a0f6491363", "patch": "@@ -8,13 +8,13 @@ fn main() {\n \n const fn foo() -> NonZero<u32> {\n     let mut x = unsafe { NonZero(1) };\n-    let y = &mut x.0; //~ ERROR references in const fn are unstable\n+    let y = &mut x.0; //~ ERROR mutable references\n     //~^ ERROR mutation of layout constrained field is unsafe\n     unsafe { NonZero(1) }\n }\n \n const fn bar() -> NonZero<u32> {\n     let mut x = unsafe { NonZero(1) };\n-    let y = unsafe { &mut x.0 }; //~ ERROR mutable references in const fn are unstable\n+    let y = unsafe { &mut x.0 }; //~ ERROR mutable references\n     unsafe { NonZero(1) }\n }"}]}