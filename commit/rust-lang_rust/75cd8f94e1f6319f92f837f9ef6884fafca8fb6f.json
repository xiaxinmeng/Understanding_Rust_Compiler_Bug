{"sha": "75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Y2Q4Zjk0ZTFmNjMxOWY5MmY4MzdmOWVmNjg4NGZhZmNhOGZiNmY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-12T04:58:01Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-12T04:58:01Z"}, "message": "rustc_typeck: remove the \"preload all impls ever\" workaround in coherence.", "tree": {"sha": "9517be9169333b66a677c76d8f3790d80dcc231f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9517be9169333b66a677c76d8f3790d80dcc231f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "html_url": "https://github.com/rust-lang/rust/commit/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "592165fb17fb78e7aa1cfd054ddfdfe9401e92d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/592165fb17fb78e7aa1cfd054ddfdfe9401e92d7", "html_url": "https://github.com/rust-lang/rust/commit/592165fb17fb78e7aa1cfd054ddfdfe9401e92d7"}], "stats": {"total": 106, "additions": 4, "deletions": 102}, "files": [{"sha": "6caefec48783afe89549aa4a922642995039ab91", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "patch": "@@ -304,15 +304,6 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n     decoder::get_native_libraries(&*cdata)\n }\n \n-pub fn each_impl<F>(cstore: &cstore::CStore,\n-                    crate_num: ast::CrateNum,\n-                    callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let cdata = cstore.get_crate_data(crate_num);\n-    decoder::each_impl(&*cdata, callback)\n-}\n-\n pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n                                                 def_id: ast::DefId,\n                                                 callback: F) where"}, {"sha": "382dc437bdc4829c0b3effe1b22cd5a2cfae6513", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "patch": "@@ -1344,16 +1344,6 @@ fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n     None\n }\n \n-pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-    let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n-        callback(item_def_id(impl_doc, cdata));\n-        true\n-    });\n-}\n-\n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n                                                 id: ast::NodeId,\n                                                 mut callback: F)"}, {"sha": "4dc1596b1ff7c5d13cbabd4595984ebe9566bfd7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "patch": "@@ -16,13 +16,10 @@\n // mappings. That mapping code resides here.\n \n \n-use metadata::csearch::{each_impl, get_impl_trait};\n-use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n-use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n-use middle::ty::{ParameterEnvironment, lookup_item_type};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -33,7 +30,6 @@ use middle::ty;\n use CrateCtxt;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n-use std::collections::HashSet;\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n@@ -130,11 +126,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                       Rc::new((*v.borrow()).clone()));\n         }\n \n-        // Bring in external crates. It's fine for this to happen after the\n-        // coherence checks, because we ensure by construction that no errors\n-        // can happen at link time.\n-        self.add_external_crates();\n-\n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n         // the coherence tables contain the trait -> type mappings.\n@@ -267,11 +258,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n-    fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n-    }\n-\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n@@ -313,66 +299,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    // External crate handling\n-\n-    fn add_external_impl(&self,\n-                         impls_seen: &mut HashSet<DefId>,\n-                         impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n-                                                 impl_def_id);\n-\n-        // Make sure we don't visit the same implementation multiple times.\n-        if !impls_seen.insert(impl_def_id) {\n-            // Skip this one.\n-            return\n-        }\n-        // Good. Continue.\n-\n-        let _ = lookup_item_type(tcx, impl_def_id);\n-        let associated_traits = get_impl_trait(tcx, impl_def_id);\n-\n-        // Do a sanity check.\n-        assert!(associated_traits.is_some());\n-\n-        // Record all the trait items.\n-        if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref, impl_def_id);\n-        }\n-\n-        // For any methods that use a default implementation, add them to\n-        // the map. This is a bit unfortunate.\n-        for item_def_id in &impl_items {\n-            let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n-            match impl_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    if let Some(source) = method.provided_source {\n-                        tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(item_def_id.def_id(), source);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-    }\n-\n-    // Adds implementations and traits from external crates to the coherence\n-    // info.\n-    fn add_external_crates(&self) {\n-        let mut impls_seen = HashSet::new();\n-\n-        let crate_store = &self.crate_context.tcx.sess.cstore;\n-        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_impl(crate_store, crate_number, |def_id| {\n-                assert_eq!(crate_number, def_id.krate);\n-                self.add_external_impl(&mut impls_seen, def_id)\n-            })\n-        })\n-    }\n-\n     //\n     // Destructors\n     //\n@@ -395,7 +321,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n@@ -451,7 +377,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return\n             }\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n                    self_type.repr(tcx));\n "}, {"sha": "e9c69c84630ef2efc8f9eca5551c6ae9a8f4213d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "patch": "@@ -48,14 +48,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_defs : Vec<&ty::TraitDef> = {\n-            let d = self.tcx.trait_defs.borrow();\n-            d.values().map(|&v|v).collect()\n-        };\n+        let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n \n         for trait_def in trait_defs {\n-            // FIXME -- it seems like this method actually pushes\n-            // duplicate impls onto the list\n             ty::populate_implementations_for_trait_if_necessary(\n                 self.tcx,\n                 trait_def.trait_ref.def_id);"}]}