{"sha": "d28f7344125b47b7e991413c5612708ce8d5ed77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyOGY3MzQ0MTI1YjQ3YjdlOTkxNDEzYzU2MTI3MDhjZThkNWVkNzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-27T10:16:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-05T09:36:02Z"}, "message": "Refactor so that references to traits are not represented using a type with a\nbare function store (which is not in fact a kind of value) but rather\nty::TraitRef.  Removes many uses of fail!() and other telltale signs of\ntype-semantic mismatch.\n\ncc #4183 (not a fix, but related)", "tree": {"sha": "0598b22426dfd8a61972ecd1beb4591983030529", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0598b22426dfd8a61972ecd1beb4591983030529"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d28f7344125b47b7e991413c5612708ce8d5ed77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d28f7344125b47b7e991413c5612708ce8d5ed77", "html_url": "https://github.com/rust-lang/rust/commit/d28f7344125b47b7e991413c5612708ce8d5ed77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d28f7344125b47b7e991413c5612708ce8d5ed77/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3333b0f1177fd758cfd95d992aed18972ed26dfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3333b0f1177fd758cfd95d992aed18972ed26dfb", "html_url": "https://github.com/rust-lang/rust/commit/3333b0f1177fd758cfd95d992aed18972ed26dfb"}], "stats": {"total": 1933, "additions": 1071, "deletions": 862}, "files": [{"sha": "de1482e2c39188a8f2253c1ae7e2337190232127", "filename": "src/libcore/option.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -46,7 +46,8 @@ use ops::Add;\n use kinds::Copy;\n use util;\n use num::Zero;\n-use iter::{BaseIter, MutableIter};\n+use iter::{BaseIter, MutableIter, ExtendedIter};\n+use iter;\n \n #[cfg(test)] use ptr;\n #[cfg(test)] use str;\n@@ -118,6 +119,31 @@ impl<T> MutableIter<T> for Option<T> {\n     }\n }\n \n+impl<A> ExtendedIter<A> for Option<A> {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n+    }\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n+    }\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n+    }\n+}\n+\n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n     fn is_none(&const self) -> bool {"}, {"sha": "a449c4e73cf7e1b68c13a1349cef51e90071486a", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -443,9 +443,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_trait(&self) -> bool {\n-        self.align_to::<TyVisitor>();\n+        self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n+        self.bump_past::<@TyVisitor>();\n         true\n     }\n "}, {"sha": "98564beeba90136ba0fd12f4d17461bb08dfb800", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -298,7 +298,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     @ProgRes(repr) as @Program\n }\n \n-fn read_all(rd: io::Reader) -> ~str {\n+fn read_all(rd: @io::Reader) -> ~str {\n     let buf = io::with_bytes_writer(|wr| {\n         let mut bytes = [0, ..4096];\n         while !rd.eof() {"}, {"sha": "71a1f1b3f9b2060e3eaf9d0fc503d02fcf316371", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -74,7 +74,9 @@ pub static tag_crate_dep_vers: uint = 0x2cu;\n pub static tag_mod_impl: uint = 0x30u;\n \n pub static tag_item_trait_method: uint = 0x31u;\n-pub static tag_impl_trait: uint = 0x32u;\n+\n+pub static tag_item_trait_ref: uint = 0x32u;\n+pub static tag_item_super_trait_ref: uint = 0x33u;\n \n // discriminator value for variants\n pub static tag_disr_val: uint = 0x34u;"}, {"sha": "74e891a01942ff7404e82489ee43b5fffa943b17", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -139,7 +139,7 @@ pub fn get_provided_trait_methods(tcx: ty::ctxt,\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n@@ -180,6 +180,12 @@ pub fn get_type(tcx: ty::ctxt,\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n+pub fn get_trait_def(tcx: ty::ctxt, def: ast::def_id) -> ty::TraitDef {\n+    let cstore = tcx.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_trait_def(cdata, def.node, tcx)\n+}\n+\n pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n                         def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -204,16 +210,17 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        bounds: @~[],\n-        region_param: None,\n+        generics: ty::Generics {bounds: @~[],\n+                                region_param: None},\n         ty: ty\n     }\n }\n \n // Given a def_id for an impl or class, return the traits it implements,\n // or the empty vector if it's not for an impl or for a class that implements\n // traits\n-pub fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_impl_traits(tcx: ty::ctxt,\n+                       def: ast::def_id) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_traits(cdata, def.node, tcx)"}, {"sha": "d9ef30ff297d0f2b038b30cc5c7c0644366b5c83", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -20,7 +20,7 @@ use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n-                         parse_bare_fn_ty_data};\n+                         parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::{ty, resolve};\n \n use core::hash::HashUtil;\n@@ -256,12 +256,14 @@ pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n     }\n }\n \n-fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n-    let mut results = ~[];\n-    for reader::tagged_docs(item, tag_impl_trait) |ity| {\n-        results.push(doc_type(ity, tcx, cdata));\n-    };\n-    results\n+fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+    parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n+                         |_, did| translate_def_id(cdata, did))\n+}\n+\n+fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+    let tp = reader::get_doc(doc, tag_item_trait_ref);\n+    doc_trait_ref(tp, tcx, cdata)\n }\n \n fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n@@ -371,6 +373,21 @@ pub fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n \n+pub fn get_trait_def(cdata: cmd,\n+                     item_id: ast::node_id,\n+                     tcx: ty::ctxt) -> ty::TraitDef\n+{\n+    let item_doc = lookup_item(item_id, cdata.data);\n+    let tp_bounds = item_ty_param_bounds(item_doc, tcx, cdata,\n+                                         tag_items_data_item_ty_param_bounds);\n+    let rp = item_ty_region_param(item_doc);\n+    ty::TraitDef {\n+        generics: ty::Generics {bounds: tp_bounds,\n+                                region_param: rp},\n+        trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n+    }\n+}\n+\n pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n@@ -382,8 +399,8 @@ pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n     ty::ty_param_bounds_and_ty {\n-        bounds: tp_bounds,\n-        region_param: rp,\n+        generics: ty::Generics {bounds: tp_bounds,\n+                                region_param: rp},\n         ty: t\n     }\n }\n@@ -399,9 +416,19 @@ pub fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-pub fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-                    -> ~[ty::t] {\n-    item_impl_traits(lookup_item(id, cdata.data), tcx, cdata)\n+pub fn get_impl_traits(cdata: cmd,\n+                       id: ast::node_id,\n+                       tcx: ty::ctxt) -> ~[@ty::TraitRef]\n+{\n+    let item_doc = lookup_item(id, cdata.data);\n+    let mut results = ~[];\n+    for reader::tagged_docs(item_doc, tag_item_trait_ref) |tp| {\n+        let trait_ref =\n+            @parse_trait_ref_data(tp.data, cdata.cnum, tp.start, tcx,\n+                                  |_, did| translate_def_id(cdata, did));\n+        results.push(trait_ref);\n+    };\n+    results\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n@@ -735,7 +762,10 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let self_ty = get_self_ty(method_doc);\n     ty::method {\n         ident: name,\n-        tps: bounds,\n+        generics: ty::Generics {\n+            bounds: bounds,\n+            region_param: None\n+        },\n         transformed_self_ty: transformed_self_ty,\n         fty: fty,\n         self_ty: self_ty,\n@@ -784,7 +814,10 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         let self_ty = get_self_ty(mth);\n         let ty_method = ty::method {\n             ident: name,\n-            tps: bounds,\n+            generics: ty::Generics {\n+                bounds: bounds,\n+                region_param: None\n+            },\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: self_ty,\n@@ -804,11 +837,11 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-                    -> ~[ty::t] {\n+                    -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n-    for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n-        results.push(doc_type(trait_doc, tcx, cdata));\n+    for reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+        results.push(@doc_trait_ref(trait_doc, tcx, cdata));\n     }\n     return results;\n }\n@@ -837,8 +870,8 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    // If this impl has a trait ref, don't consider it.\n-    for reader::tagged_docs(item, tag_impl_trait) |_doc| {\n+    // If this impl implements a trait, don't consider it.\n+    for reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n         return None;\n     }\n "}, {"sha": "e251af7c8a85b0cd561ab6bb585345680928b623", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -153,14 +153,23 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n         });\n }\n \n-fn encode_trait_ref(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                    t: @trait_ref) {\n-    ebml_w.start_tag(tag_impl_trait);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n+fn encode_trait_ref(ebml_w: writer::Encoder,\n+                    ecx: @EncodeContext,\n+                    trait_ref: &ty::TraitRef,\n+                    tag: uint)\n+{\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+\n+    ebml_w.start_tag(tag);\n+    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n     ebml_w.end_tag();\n }\n \n-\n // Item info table encoding\n fn encode_family(ebml_w: writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n@@ -579,7 +588,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ecx, ebml_w, method_ty.ident);\n-    encode_ty_type_param_bounds(ebml_w, ecx, method_ty.tps,\n+    encode_ty_type_param_bounds(ebml_w, ecx, method_ty.generics.bounds,\n                                 tag_item_method_tps);\n     encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n@@ -872,8 +881,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n             ebml_w.end_tag();\n         }\n-        for opt_trait.each |associated_trait| {\n-           encode_trait_ref(ebml_w, ecx, *associated_trait);\n+        for opt_trait.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n@@ -894,14 +904,15 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                    &m.generics);\n         }\n       }\n-      item_trait(ref generics, ref traits, ref ms) => {\n+      item_trait(ref generics, ref super_traits, ref ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n+        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n@@ -910,8 +921,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for traits.each |associated_trait| {\n-            encode_trait_ref(ebml_w, ecx, *associated_trait);\n+        for super_traits.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n         ebml_w.end_tag();\n \n@@ -940,7 +952,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                       method_ty.fty.purity));\n \n                     let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_ty_type_param_bounds(ebml_w, ecx, tpt.bounds,\n+                    encode_ty_type_param_bounds(ebml_w, ecx, tpt.generics.bounds,\n                                                 tag_items_data_item_ty_param_bounds);\n                     encode_type(ecx, ebml_w, tpt.ty);\n                 }"}, {"sha": "2ec13abb483d664d7a07bb8dd190af145128719f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -125,6 +125,12 @@ pub fn parse_bare_fn_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::c\n     parse_bare_fn_ty(st, conv)\n }\n \n+pub fn parse_trait_ref_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                            conv: conv_did) -> ty::TraitRef {\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_trait_ref(st, conv)\n+}\n+\n pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                       conv: conv_did) -> ty::arg {\n     let st = parse_state_from_data(data, crate_num, pos, tcx);\n@@ -183,7 +189,6 @@ fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st)),\n-        '.' => ty::BareTraitStore,\n         c => st.tcx.sess.bug(fmt!(\"parse_trait_store(): bad input '%c'\", c))\n     }\n }\n@@ -265,6 +270,12 @@ fn parse_str(st: @mut PState, term: char) -> ~str {\n     return result;\n }\n \n+fn parse_trait_ref(st: @mut PState, conv: conv_did) -> ty::TraitRef {\n+    let def = parse_def(st, NominalType, conv);\n+    let substs = parse_substs(st, conv);\n+    ty::TraitRef {def_id: def, substs: substs}\n+}\n+\n fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(st.tcx),\n@@ -551,7 +562,7 @@ fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,\n           'O' => ty::bound_durable,\n-          'I' => ty::bound_trait(parse_ty(st, conv)),\n+          'I' => ty::bound_trait(@parse_trait_ref(st, conv)),\n           '.' => break,\n           _ => fail!(~\"parse_bounds: bad bounds\")\n         });"}, {"sha": "ca2d66de9c44d6065b2c89b190307c5852e756c3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -214,11 +214,16 @@ pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n+pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n+    w.write_str((cx.ds)(s.def_id));\n+    w.write_char('|');\n+    enc_substs(w, cx, s.substs);\n+}\n+\n pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => w.write_char('~'),\n         ty::BoxTraitStore => w.write_char('@'),\n-        ty::BareTraitStore => w.write_char('.'),\n         ty::RegionTraitStore(re) => {\n             w.write_char('&');\n             enc_region(w, cx, re);\n@@ -415,8 +420,8 @@ pub fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n           ty::bound_const => w.write_char('K'),\n           ty::bound_durable => w.write_char('O'),\n           ty::bound_trait(tp) => {\n-            w.write_char('I');\n-            enc_ty(w, cx, tp);\n+              w.write_char('I');\n+              enc_trait_ref(w, cx, tp);\n           }\n         }\n     }"}, {"sha": "20b72a19df7948a4ee42a22eff12f4433cc127b4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -779,16 +779,20 @@ impl ebml_writer_helpers for writer::Encoder {\n \n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 3) {\n-            do self.emit_field(~\"bounds\", 0) {\n-                do self.emit_from_vec(*tpbt.bounds) |bs| {\n-                    self.emit_bounds(ecx, *bs);\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n+            do self.emit_field(~\"generics\", 0) {\n+                do self.emit_struct(\"Generics\", 2) {\n+                    do self.emit_field(~\"bounds\", 0) {\n+                        do self.emit_from_vec(*tpbt.generics.bounds) |bs| {\n+                            self.emit_bounds(ecx, *bs);\n+                        }\n+                    }\n+                    do self.emit_field(~\"region_param\", 1) {\n+                        tpbt.generics.region_param.encode(self);\n+                    }\n                 }\n             }\n-            do self.emit_field(~\"region_param\", 1u) {\n-                tpbt.region_param.encode(self);\n-            }\n-            do self.emit_field(~\"ty\", 2u) {\n+            do self.emit_field(~\"ty\", 1) {\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -1046,15 +1050,19 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 3) {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n             ty::ty_param_bounds_and_ty {\n-                bounds: self.read_field(~\"bounds\", 0u, || {\n-                    @self.read_to_vec(|| self.read_bounds(xcx) )\n-                }),\n-                region_param: self.read_field(~\"region_param\", 1u, || {\n-                    Decodable::decode(self)\n-                }),\n-                ty: self.read_field(~\"ty\", 2u, || {\n+                generics: do self.read_struct(\"Generics\", 2) {\n+                    ty::Generics {\n+                        bounds: self.read_field(~\"bounds\", 0, || {\n+                            @self.read_to_vec(|| self.read_bounds(xcx) )\n+                        }),\n+                        region_param: self.read_field(~\"region_param\", 1, || {\n+                            Decodable::decode(self)\n+                        })\n+                    }\n+                },\n+                ty: self.read_field(~\"ty\", 1, || {\n                     self.read_ty(xcx)\n                 })\n             }"}, {"sha": "96e8ef40770a238abb741d34b4b044b5c8183fd3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -91,7 +91,7 @@ fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if struct_tpt.bounds.len() == 0 {\n+    if struct_tpt.generics.bounds.len() == 0 {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n             self_r: None,\n             self_ty: None,\n@@ -279,7 +279,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         let bounds = match e.node {\n           expr_path(_) => {\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n-            ty::lookup_item_type(cx.tcx, did).bounds\n+            ty::lookup_item_type(cx.tcx, did).generics.bounds\n           }\n           _ => {\n             // Type substitutions should only occur on paths and\n@@ -340,7 +340,7 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n             // FIXME(#5562): removing this copy causes a segfault before stage2\n             let ts = /*bad*/ copy **ts;\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n-            let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+            let bounds = ty::lookup_item_type(cx.tcx, did).generics.bounds;\n             for vec::each2(ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, *ty, *bound)\n             }"}, {"sha": "b4aff91ed5b280257e7e122a9127273a70ea5823", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -825,8 +825,7 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n       ast::item_enum(*) |\n-      ast::item_struct(*) |\n-      ast::item_trait(*) => check_type(cx, it.id, it.id, it.span,\n+      ast::item_struct(*) => check_type(cx, it.id, it.id, it.span,\n                                        ty::node_id_to_type(cx, it.id)),\n       _ => ()\n     }"}, {"sha": "fcf0b7022a7a7b6cad299dfa55e0fd5b48d6bd74", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -79,6 +79,7 @@ use syntax::opt_vec::OptVec;\n use core::option::Some;\n use core::str::each_split_str;\n use core::hashmap::{HashMap, HashSet};\n+use core::util;\n \n // Definition mapping\n pub type DefMap = @mut HashMap<node_id,def>;\n@@ -3414,7 +3415,6 @@ pub impl Resolver {\n                       self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n-                                            item.span,\n                                             generics,\n                                             implemented_traits,\n                                             self_type,\n@@ -3723,13 +3723,30 @@ pub impl Resolver {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n                 match bound {\n-                    TraitTyParamBound(ty) => self.resolve_type(ty, visitor),\n+                    TraitTyParamBound(tref) => {\n+                        self.resolve_trait_reference(tref, visitor)\n+                    }\n                     RegionTyParamBound => {}\n                 }\n             }\n         }\n     }\n \n+    fn resolve_trait_reference(@mut self,\n+                               trait_reference: &trait_ref,\n+                               visitor: ResolveVisitor) {\n+        match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n+            None => {\n+                self.session.span_err(trait_reference.path.span,\n+                                      ~\"attempt to implement an \\\n+                                        unknown trait\");\n+            }\n+            Some(def) => {\n+                self.record_def(trait_reference.ref_id, def);\n+            }\n+        }\n+    }\n+\n     fn resolve_struct(@mut self,\n                       id: node_id,\n                       generics: &Generics,\n@@ -3797,7 +3814,6 @@ pub impl Resolver {\n \n     fn resolve_implementation(@mut self,\n                               id: node_id,\n-                              span: span,\n                               generics: &Generics,\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n@@ -3816,25 +3832,16 @@ pub impl Resolver {\n             let original_trait_refs;\n             match opt_trait_reference {\n                 Some(trait_reference) => {\n-                    let mut new_trait_refs = ~[];\n-                    match self.resolve_path(\n-                        trait_reference.path, TypeNS, true, visitor) {\n-                        None => {\n-                            self.session.span_err(span,\n-                                                  ~\"attempt to implement an \\\n-                                                    unknown trait\");\n-                        }\n-                        Some(def) => {\n-                            self.record_def(trait_reference.ref_id, def);\n+                    self.resolve_trait_reference(trait_reference, visitor);\n \n-                            // Record the current trait reference.\n-                            new_trait_refs.push(def_id_of_def(def));\n-                        }\n-                    }\n                     // Record the current set of trait references.\n-                    let mut old = Some(new_trait_refs);\n-                    self.current_trait_refs <-> old;\n-                    original_trait_refs = Some(old);\n+                    let mut new_trait_refs = ~[];\n+                    for self.def_map.find(&trait_reference.ref_id).each |&def| {\n+                        new_trait_refs.push(def_id_of_def(*def));\n+                    }\n+                    original_trait_refs = Some(util::replace(\n+                        &mut self.current_trait_refs,\n+                        Some(new_trait_refs)));\n                 }\n                 None => {\n                     original_trait_refs = None;"}, {"sha": "593d37c2ff8d1e9ee4cae429a6320de4c01e622d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -1062,9 +1062,6 @@ pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n         ty::RegionTraitStore(_) => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n         }\n-        ty::BareTraitStore => {\n-            cx.sess.bug(~\"can't make T_opaque_trait with bare trait store\")\n-        }\n     }\n }\n "}, {"sha": "d8c8301a83563332f40d37f9ed426ab8e6ab1495", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -40,7 +40,6 @@ use core::libc::c_uint;\n use core::str;\n use std::time;\n use syntax::ast;\n-use syntax::parse::token::special_idents;\n \n pub fn trans_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_free\");\n@@ -400,11 +399,9 @@ pub fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    let ty_visitor_name = special_idents::ty_visitor;\n-    assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n-    let (trait_id, ty) = *bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n-    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n-    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n+    let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n+    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n     build_return(bcx);\n }\n \n@@ -554,8 +551,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore) |\n-      ty::ty_trait(_, _, ty::BareTraitStore) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n@@ -621,8 +617,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore) |\n-      ty::ty_trait(_, _, ty::BareTraitStore) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx"}, {"sha": "2ca19b90754234d81bc68f4729f1f7ef7b694830", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -87,8 +87,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n             ccx.stats.n_inlines += 1;\n             ccx.external.insert(fn_id, Some(mth.id));\n             let ty::ty_param_bounds_and_ty {\n-                bounds: impl_bnds,\n-                region_param: _,\n+                generics: ty::Generics { bounds: impl_bnds, _ },\n                 ty: _\n             } = ty::lookup_item_type(ccx.tcx, impl_did);\n             if translate &&"}, {"sha": "bbf53480a56fb9f27799df0e74d9d3117909b220", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use back::abi;\n-use driver;\n use lib::llvm::llvm;\n use lib::llvm::ValueRef;\n use lib;\n@@ -302,8 +301,8 @@ pub fn trans_static_method_callee(bcx: block,\n     // found on the type parametesr T1...Tn to find the index of the\n     // one we are interested in.\n     let bound_index = {\n-        let trait_polyty = ty::lookup_item_type(bcx.tcx(), trait_id);\n-        ty::count_traits_and_supertraits(bcx.tcx(), *trait_polyty.bounds)\n+        let trait_def = ty::lookup_trait_def(bcx.tcx(), trait_id);\n+        ty::count_traits_and_supertraits(bcx.tcx(), *trait_def.generics.bounds)\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n@@ -552,8 +551,10 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     // rcvr + method bounds.\n     let ccx = bcx.ccx(), tcx = bcx.tcx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n-    let ty::ty_param_bounds_and_ty {bounds: r_m_bounds, _}\n-        = ty::lookup_item_type(tcx, mth_did);\n+    let ty::ty_param_bounds_and_ty {\n+        generics: ty::Generics {bounds: r_m_bounds, _},\n+        _\n+    } = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n     let m_boundss = vec::slice(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n \n@@ -656,7 +657,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             // payload.\n             match store {\n                 ty::BoxTraitStore |\n-                ty::BareTraitStore |\n                 ty::UniqTraitStore => {\n                     llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n                 }\n@@ -679,7 +679,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n             // Pass a pointer to the box.\n             match store {\n-                ty::BoxTraitStore | ty::BareTraitStore => llself = llbox,\n+                ty::BoxTraitStore => llself = llbox,\n                 _ => bcx.tcx().sess.bug(~\"@self receiver with non-@Trait\")\n             }\n \n@@ -785,19 +785,14 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n     let tcx = ccx.tcx;\n \n     // XXX: This should support multiple traits.\n-    let trt_id = driver::session::expect(\n-        tcx.sess,\n-        ty::ty_to_def_id(ty::impl_traits(tcx,\n-                                         impl_id,\n-                                         ty::BoxTraitStore)[0]),\n-        || ~\"make_impl_vtable: non-trait-type implemented\");\n-\n-    let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n+    let trt_id = ty::impl_trait_refs(tcx, impl_id)[0].def_id;\n+\n+    let has_tps = ty::lookup_item_type(ccx.tcx, impl_id).generics.bounds.len() > 0u;\n     make_vtable(ccx, ty::trait_method_def_ids(tcx, trt_id).map(|method_def_id| {\n         let im = ty::method(tcx, *method_def_id);\n         let fty = ty::subst_tps(tcx, substs, None,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n-        if im.tps.len() > 0u || ty::type_has_self(fty) {\n+        if im.generics.bounds.len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))\n@@ -844,7 +839,7 @@ pub fn trans_trait_cast(bcx: block,\n     let v_ty = expr_ty(bcx, val);\n \n     match store {\n-        ty::RegionTraitStore(_) | ty::BoxTraitStore | ty::BareTraitStore => {\n+        ty::RegionTraitStore(_) | ty::BoxTraitStore => {\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n             // Just store the pointer into the pair.\n             llboxdest = PointerCast(bcx,"}, {"sha": "319f57fb75ce07ba17eaa46dc0e4d0c508f7b0b8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -169,7 +169,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let psubsts = Some(@param_substs {\n         tys: substs,\n         vtables: vtables,\n-        bounds: tpt.bounds,\n+        bounds: tpt.generics.bounds,\n         self_ty: impl_ty_opt\n     });\n \n@@ -291,7 +291,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n         ty::ty_trait(_, _, ref store) => {\n             let sigil = match *store {\n                 ty::UniqTraitStore => ast::OwnedSigil,\n-                ty::BoxTraitStore | ty::BareTraitStore => ast::ManagedSigil,\n+                ty::BoxTraitStore => ast::ManagedSigil,\n                 ty::RegionTraitStore(_) => ast::BorrowedSigil,\n             };\n \n@@ -328,7 +328,7 @@ pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: &[ty::t],\n                     +param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n-        let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n+        let bounds = ty::lookup_item_type(ccx.tcx, item).generics.bounds;\n         let mut i = 0;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];"}, {"sha": "b1d977b7445cca67df82c770c70c3a48739801b9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 137, "deletions": 120, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -25,8 +25,10 @@ use middle;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, vstore_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, tys_to_str};\n+use util::ppaux::{trait_ref_to_str};\n use util::common::{indenter};\n \n+use core;\n use core::cast;\n use core::cmp;\n use core::ops;\n@@ -44,6 +46,7 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust;\n+use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -70,7 +73,7 @@ pub type param_bounds = @~[param_bound];\n \n pub struct method {\n     ident: ast::ident,\n-    tps: @~[param_bounds],\n+    generics: ty::Generics,\n     transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n     self_ty: ast::self_ty_,\n@@ -96,9 +99,8 @@ pub enum vstore {\n \n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum TraitStore {\n-    BareTraitStore,             // a plain trait without a sigil\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n     RegionTraitStore(Region),   // &Trait\n@@ -225,11 +227,6 @@ pub struct ProvidedMethodSource {\n     impl_id: ast::def_id\n }\n \n-pub struct InstantiatedTraitRef {\n-    def_id: ast::def_id,\n-    tpt: ty_param_substs_and_ty\n-}\n-\n pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n@@ -265,8 +262,12 @@ struct ctxt_ {\n     // A cache for the trait_methods() routine\n     trait_methods_cache: @mut HashMap<def_id, @~[@method]>,\n \n+    trait_refs: @mut HashMap<node_id, @TraitRef>,\n+    trait_defs: @mut HashMap<def_id, @TraitDef>,\n+\n     items: ast_map::map,\n     intrinsic_defs: @mut HashMap<ast::ident, (ast::def_id, t)>,\n+    intrinsic_traits: @mut HashMap<ast::ident, @TraitRef>,\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n@@ -286,7 +287,7 @@ struct ctxt_ {\n     // that implementation implements.\n     provided_methods: ProvidedMethodsMap,\n     provided_method_sources: @mut HashMap<ast::def_id, ProvidedMethodSource>,\n-    supertraits: @mut HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+    supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n@@ -536,6 +537,12 @@ pub enum sty {\n     ty_unboxed_vec(mt),\n }\n \n+#[deriving(Eq, IterBytes)]\n+pub struct TraitRef {\n+    def_id: def_id,\n+    substs: substs\n+}\n+\n #[deriving(Eq)]\n pub enum IntVarValue {\n     IntType(ast::int_ty),\n@@ -582,16 +589,17 @@ pub enum type_err {\n     terr_self_substs,\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n-    terr_float_mismatch(expected_found<ast::float_ty>)\n+    terr_float_mismatch(expected_found<ast::float_ty>),\n+    terr_traits(expected_found<ast::def_id>),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum param_bound {\n     bound_copy,\n     bound_durable,\n     bound_owned,\n     bound_const,\n-    bound_trait(t),\n+    bound_trait(@TraitRef),\n }\n \n #[deriving(Eq)]\n@@ -660,19 +668,6 @@ impl cmp::Eq for InferRegion {\n     }\n }\n \n-impl to_bytes::IterBytes for param_bound {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          bound_copy => 0u8.iter_bytes(lsb0, f),\n-          bound_durable => 1u8.iter_bytes(lsb0, f),\n-          bound_owned => 2u8.iter_bytes(lsb0, f),\n-          bound_const => 3u8.iter_bytes(lsb0, f),\n-          bound_trait(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n-        }\n-    }\n-}\n-\n pub trait Vid {\n     fn to_uint(&self) -> uint;\n }\n@@ -759,6 +754,13 @@ impl to_bytes::IterBytes for RegionVid {\n     }\n }\n \n+/// Information about the type/lifetime parametesr associated with an item.\n+/// Analogous to ast::Generics.\n+pub struct Generics {\n+    bounds: @~[param_bounds],\n+    region_param: Option<region_variance>,\n+}\n+\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -770,11 +772,16 @@ impl to_bytes::IterBytes for RegionVid {\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n pub struct ty_param_bounds_and_ty {\n-    bounds: @~[param_bounds],\n-    region_param: Option<region_variance>,\n+    generics: Generics,\n     ty: t\n }\n \n+/// As `ty_param_bounds_and_ty` but for a trait ref.\n+pub struct TraitDef {\n+    generics: Generics,\n+    trait_ref: @ty::TraitRef,\n+}\n+\n pub struct ty_param_substs_and_ty {\n     substs: ty::substs,\n     ty: ty::t\n@@ -829,6 +836,9 @@ pub fn mk_ctxt(s: session::Session,\n         region_paramd_items: region_paramd_items,\n         node_types: @mut SmallIntMap::new(),\n         node_type_substs: @mut HashMap::new(),\n+        trait_refs: @mut HashMap::new(),\n+        trait_defs: @mut HashMap::new(),\n+        intrinsic_traits: @mut HashMap::new(),\n         items: amap,\n         intrinsic_defs: @mut HashMap::new(),\n         freevars: freevars,\n@@ -1412,7 +1422,7 @@ pub fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n         bound_durable => ~\"'static\",\n         bound_owned => ~\"owned\",\n         bound_const => ~\"const\",\n-        bound_trait(t) => ::util::ppaux::ty_to_str(cx, t)\n+        bound_trait(t) => ::util::ppaux::trait_ref_to_str(cx, t)\n     }\n }\n \n@@ -1466,13 +1476,26 @@ pub fn subst(cx: ctxt,\n     }\n }\n \n+pub fn subst_in_trait_ref(cx: ctxt,\n+                          substs: &substs,\n+                          trait_ref: &ty::TraitRef) -> ty::TraitRef\n+{\n+    ty::TraitRef {\n+        def_id: trait_ref.def_id,\n+        substs: subst_in_substs(cx, substs, &trait_ref.substs)\n+    }\n+}\n+\n // Performs substitutions on a set of substitutions (result = sup(sub)) to\n // yield a new set of substitutions. This is used in trait inheritance.\n-pub fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n+pub fn subst_in_substs(cx: ctxt,\n+                       substs: &substs,\n+                       in_substs: &substs) -> substs\n+{\n     substs {\n-        self_r: sup.self_r,\n-        self_ty: sup.self_ty.map(|typ| subst(cx, sub, *typ)),\n-        tps: sup.tps.map(|typ| subst(cx, sub, *typ))\n+        self_r: in_substs.self_r,\n+        self_ty: in_substs.self_ty.map(|&typ| subst(cx, substs, typ)),\n+        tps: in_substs.tps.map(|&typ| subst(cx, substs, typ))\n     }\n }\n \n@@ -1488,6 +1511,11 @@ pub fn type_is_error(ty: t) -> bool {\n     (get(ty).flags & (has_ty_err as uint)) != 0\n }\n \n+pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n+    tref.substs.self_ty.any(|&t| type_is_error(t)) ||\n+        tref.substs.tps.any(|&t| type_is_error(t))\n+}\n+\n pub fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(TyVar(_)) => true,\n@@ -1932,8 +1960,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_OWNED_CLOSURE\n             }\n \n-            ty_trait(_, _, BoxTraitStore) |\n-            ty_trait(_, _, BareTraitStore) => {\n+            ty_trait(_, _, BoxTraitStore) => {\n                 TC_MANAGED\n             }\n \n@@ -2592,17 +2619,6 @@ impl to_bytes::IterBytes for vstore {\n     }\n }\n \n-impl to_bytes::IterBytes for TraitStore {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          BareTraitStore => 0u8.iter_bytes(lsb0, f),\n-          UniqTraitStore => 1u8.iter_bytes(lsb0, f),\n-          BoxTraitStore => 2u8.iter_bytes(lsb0, f),\n-          RegionTraitStore(ref r) => to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n-        }\n-    }\n-}\n-\n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n@@ -2715,6 +2731,16 @@ impl to_bytes::IterBytes for sty {\n     }\n }\n \n+pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n+    match cx.trait_refs.find(&id) {\n+       Some(&t) => t,\n+       None => cx.sess.bug(\n+           fmt!(\"node_id_to_trait_ref: no trait ref for node `%s`\",\n+                ast_map::node_id_to_str(cx.items, id,\n+                                        cx.sess.parse_sess.interner)))\n+    }\n+}\n+\n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.len()));\n     match cx.node_types.find(&(id as uint)) {\n@@ -3025,7 +3051,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // n.b.: When we encode impl methods, the bounds\n             // that we encode include both the impl bounds\n             // and then the method bounds themselves...\n-            ty::lookup_item_type(tcx, did).bounds\n+            ty::lookup_item_type(tcx, did).generics.bounds\n           }\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n@@ -3036,10 +3062,9 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n-            let trt_bounds =\n-                ty::lookup_item_type(tcx, trt_id).bounds;\n+            let trt_bounds = ty::lookup_trait_def(tcx, trt_id).generics.bounds;\n             @(vec::append(/*bad*/copy *trt_bounds,\n-                          *ty::trait_method(tcx, trt_id, n_mth).tps))\n+                          *ty::trait_method(tcx, trt_id, n_mth).generics.bounds))\n           }\n         }\n     }\n@@ -3488,6 +3513,11 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  ty_sort_str(cx, values.expected),\n                  ty_sort_str(cx, values.found))\n         }\n+        terr_traits(values) => {\n+            fmt!(\"expected trait %s but found trait %s\",\n+                 item_path_str(cx, values.expected),\n+                 item_path_str(cx, values.found))\n+        }\n         terr_self_substs => {\n             ~\"inconsistent self substitution\" // XXX this is more of a bug\n         }\n@@ -3565,11 +3595,11 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n }\n \n pub fn trait_supertraits(cx: ctxt,\n-                         id: ast::def_id)\n-                      -> @~[InstantiatedTraitRef] {\n+                         id: ast::def_id) -> @~[@TraitRef]\n+{\n     // Check the cache.\n     match cx.supertraits.find(&id) {\n-        Some(&instantiated_trait_info) => { return instantiated_trait_info; }\n+        Some(&trait_refs) => { return trait_refs; }\n         None => {}  // Continue.\n     }\n \n@@ -3578,25 +3608,10 @@ pub fn trait_supertraits(cx: ctxt,\n     assert!(!is_local(id));\n \n     // Get the supertraits out of the metadata and create the\n-    // InstantiatedTraitRef for each.\n-    let mut result = ~[];\n-    for csearch::get_supertraits(cx, id).each |trait_type| {\n-        match get(*trait_type).sty {\n-            ty_trait(def_id, ref substs, _) => {\n-                result.push(InstantiatedTraitRef {\n-                    def_id: def_id,\n-                    tpt: ty_param_substs_and_ty {\n-                        substs: (/*bad*/copy *substs),\n-                        ty: *trait_type\n-                    }\n-                });\n-            }\n-            _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")\n-        }\n-    }\n-\n-    // Unwrap and return the result.\n-    return @result;\n+    // TraitRef for each.\n+    let result = @csearch::get_supertraits(cx, id);\n+    cx.supertraits.insert(id, result);\n+    return result;\n }\n \n fn lookup_locally_or_in_crate_store<V:Copy>(\n@@ -3659,41 +3674,23 @@ pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n         || @csearch::get_trait_method_def_ids(cx.cstore, id))\n }\n \n-/*\n-  Could this return a list of (def_id, substs) pairs?\n- */\n-pub fn impl_traits(cx: ctxt, id: ast::def_id, store: TraitStore) -> ~[t] {\n-    fn storeify(cx: ctxt, ty: t, store: TraitStore) -> t {\n-        match ty::get(ty).sty {\n-            ty::ty_trait(did, ref substs, trait_store) => {\n-                if store == trait_store {\n-                    ty\n-                } else {\n-                    mk_trait(cx, did, (/*bad*/copy *substs), store)\n-                }\n-            }\n-            _ => cx.sess.bug(~\"impl_traits: not a trait\")\n-        }\n-    }\n-\n+pub fn impl_trait_refs(cx: ctxt, id: ast::def_id) -> ~[@TraitRef] {\n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n         match cx.items.find(&id.node) {\n            Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_impl(_, opt_trait, _, _),\n                         _},\n                     _)) => {\n-\n-               do opt_trait.map_default(~[]) |trait_ref| {\n-                   ~[storeify(cx, node_id_to_type(cx, trait_ref.ref_id),\n-                              store)]\n+               match opt_trait {\n+                   Some(t) => ~[ty::node_id_to_trait_ref(cx, t.ref_id)],\n+                   None => ~[]\n                }\n            }\n            _ => ~[]\n         }\n     } else {\n-        vec::map(csearch::get_impl_traits(cx, id),\n-                 |x| storeify(cx, *x, store))\n+        csearch::get_impl_traits(cx, id)\n     }\n }\n \n@@ -3967,6 +3964,23 @@ pub fn lookup_item_type(cx: ctxt,\n         || csearch::get_type(cx, did))\n }\n \n+/// Given the did of a trait, returns its canonical trait ref.\n+pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n+    match cx.trait_defs.find(&did) {\n+        Some(&trait_def) => {\n+            // The item is in this crate. The caller should have added it to the\n+            // type cache already\n+            return trait_def;\n+        }\n+        None => {\n+            assert!(did.crate != ast::local_crate);\n+            let trait_def = @csearch::get_trait_def(cx, did);\n+            cx.trait_defs.insert(did, trait_def);\n+            return trait_def;\n+        }\n+    }\n+}\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,\n@@ -4250,9 +4264,6 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                 t\n             },\n \n-        ty_trait(did, ref substs, BareTraitStore) =>\n-            mk_trait(cx, did, copy *substs, BoxTraitStore),\n-\n         _ =>\n             t\n     };\n@@ -4318,12 +4329,11 @@ pub fn determine_inherited_purity(parent_purity: ast::purity,\n // list.\n pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n                                          bounds: param_bounds,\n-                                         f: &fn(t) -> bool) {\n+                                         f: &fn(&TraitRef) -> bool) {\n     let mut fin = false;\n \n     for bounds.each |bound| {\n-\n-        let bound_trait_ty = match *bound {\n+        let bound_trait_ref = match *bound {\n             ty::bound_trait(bound_t) => bound_t,\n \n             ty::bound_copy | ty::bound_owned |\n@@ -4332,39 +4342,38 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n             }\n         };\n \n-        let mut supertrait_map = HashMap::new();\n+        let mut supertrait_set = HashMap::new();\n         let mut seen_def_ids = ~[];\n         let mut i = 0;\n-        let trait_ty_id = ty_to_def_id(bound_trait_ty).expect(\n-            ~\"iter_trait_ty_supertraits got a non-trait type\");\n-        let mut trait_ty = bound_trait_ty;\n+        let trait_ty_id = bound_trait_ref.def_id;\n+        let mut trait_ref = bound_trait_ref;\n \n-        debug!(\"iter_bound_traits_and_supertraits: trait_ty = %s\",\n-               ty_to_str(tcx, trait_ty));\n+        debug!(\"iter_bound_traits_and_supertraits: trait_ref = %s\",\n+               trait_ref_to_str(tcx, trait_ref));\n \n         // Add the given trait ty to the hash map\n-        supertrait_map.insert(trait_ty_id, trait_ty);\n+        supertrait_set.insert(trait_ty_id, ());\n         seen_def_ids.push(trait_ty_id);\n \n-        if f(trait_ty) {\n+        if f(trait_ref) {\n             // Add all the supertraits to the hash map,\n             // executing <f> on each of them\n-            while i < supertrait_map.len() && !fin {\n+            while i < supertrait_set.len() && !fin {\n                 let init_trait_id = seen_def_ids[i];\n                 i += 1;\n-                 // Add supertraits to supertrait_map\n-                let supertraits = trait_supertraits(tcx, init_trait_id);\n-                for supertraits.each |supertrait| {\n-                    let super_t = supertrait.tpt.ty;\n-                    let d_id = ty_to_def_id(super_t).expect(\"supertrait \\\n-                        should be a trait ty\");\n-                    if !supertrait_map.contains_key(&d_id) {\n-                        supertrait_map.insert(d_id, super_t);\n-                        trait_ty = super_t;\n+\n+                 // Add supertraits to supertrait_set\n+                let supertrait_refs = trait_supertraits(tcx, init_trait_id);\n+                for supertrait_refs.each |&supertrait_ref| {\n+                    let d_id = supertrait_ref.def_id;\n+                    if !supertrait_set.contains_key(&d_id) {\n+                        // NOTE Could have same trait multiple times\n+                        supertrait_set.insert(d_id, ());\n+                        trait_ref = supertrait_ref;\n                         seen_def_ids.push(d_id);\n                     }\n-                    debug!(\"A super_t = %s\", ty_to_str(tcx, trait_ty));\n-                    if !f(trait_ty) {\n+                    debug!(\"A super_t = %s\", trait_ref_to_str(tcx, trait_ref));\n+                    if !f(trait_ref) {\n                         fin = true;\n                     }\n                 }\n@@ -4401,6 +4410,14 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n     }\n }\n \n+pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n+    let ty_visitor_name = special_idents::ty_visitor;\n+    assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n+    let trait_ref = *tcx.intrinsic_traits.get(&ty_visitor_name);\n+    (trait_ref,\n+     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore))\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "209091ecd6643bd8ad03355fd89d9e0bb9dce41b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 98, "deletions": 65, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -14,14 +14,14 @@\n  * is parameterized by an instance of `AstConv` and a `region_scope`.\n  *\n  * The parameterization of `ast_ty_to_ty()` is because it behaves\n- * somewhat differently during the collect and check phases, particularly\n- * with respect to looking up the types of top-level items.  In the\n- * collect phase, the crate context is used as the `AstConv` instance;\n- * in this phase, the `get_item_ty()` function triggers a recursive call\n- * to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n- * types and report an error).  In the check phase, when the @FnCtxt is\n- * used as the `AstConv`, `get_item_ty()` just looks up the item type in\n- * `tcx.tcache`.\n+ * somewhat differently during the collect and check phases,\n+ * particularly with respect to looking up the types of top-level\n+ * items.  In the collect phase, the crate context is used as the\n+ * `AstConv` instance; in this phase, the `get_item_ty()` function\n+ * triggers a recursive call to `ty_of_item()`  (note that\n+ * `ast_ty_to_ty()` will detect recursive types and report an error).\n+ * In the check phase, when the @FnCtxt is used as the `AstConv`,\n+ * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n  * The `region_scope` trait controls how region references are\n  * handled.  It has two methods which are used to resolve anonymous\n@@ -76,6 +76,7 @@ use util::common::indenter;\n pub trait AstConv {\n     fn tcx(&self) -> ty::ctxt;\n     fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: span) -> ty::t;\n@@ -129,62 +130,96 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n     get_region_reporting_err(self.tcx(), span, opt_lifetime, res)\n }\n \n-pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: &AC,\n-        rscope: &RS,\n-        did: ast::def_id,\n-        path: @ast::path)\n-     -> ty_param_substs_and_ty {\n-    let tcx = self.tcx();\n-    let ty::ty_param_bounds_and_ty {\n-        bounds: decl_bounds,\n-        region_param: decl_rp,\n-        ty: decl_ty\n-    } = self.get_item_ty(did);\n+fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    def_id: ast::def_id,\n+    decl_generics: &ty::Generics,\n+    path: @ast::path) -> ty::substs\n+{\n+    /*!\n+     *\n+     * Given a path `path` that refers to an item `I` with the\n+     * declared generics `decl_generics`, returns an appropriate\n+     * set of substitutions for this particular reference to `I`.\n+     */\n \n-    debug!(\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n-           did, decl_rp);\n+    let tcx = self.tcx();\n \n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let self_r = match (decl_rp, path.rp) {\n-      (None, None) => {\n+    let self_r = match (&decl_generics.region_param, &path.rp) {\n+      (&None, &None) => {\n         None\n       }\n-      (None, Some(_)) => {\n+      (&None, &Some(_)) => {\n         tcx.sess.span_err(\n             path.span,\n             fmt!(\"no region bound is allowed on `%s`, \\\n                   which is not declared as containing region pointers\",\n-                 ty::item_path_str(tcx, did)));\n+                 ty::item_path_str(tcx, def_id)));\n         None\n       }\n-      (Some(_), None) => {\n+      (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n         let r = get_region_reporting_err(self.tcx(), path.span, None, res);\n         Some(r)\n       }\n-      (Some(_), Some(_)) => {\n+      (&Some(_), &Some(_)) => {\n         Some(ast_region_to_region(self, rscope, path.span, path.rp))\n       }\n     };\n \n     // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_bounds, path.types) {\n+    if !vec::same_length(*decl_generics.bounds, path.types) {\n         self.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n-                 (*decl_bounds).len(), path.types.len()));\n+                 decl_generics.bounds.len(), path.types.len()));\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n-    let substs = substs {self_r:self_r, self_ty:None, tps:tps};\n-    let ty = ty::subst(tcx, &substs, decl_ty);\n+    substs {self_r:self_r, self_ty:None, tps:tps}\n+}\n \n+pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    did: ast::def_id,\n+    path: @ast::path) -> ty_param_substs_and_ty\n+{\n+    let tcx = self.tcx();\n+    let ty::ty_param_bounds_and_ty {\n+        generics: generics,\n+        ty: decl_ty\n+    } = self.get_item_ty(did);\n+\n+    let substs = ast_path_substs(self, rscope, did, &generics, path);\n+    let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n+pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    trait_def_id: ast::def_id,\n+    path: @ast::path) -> @ty::TraitRef\n+{\n+    let trait_def =\n+        self.get_trait_def(trait_def_id);\n+    let substs =\n+        ast_path_substs(\n+            self, rscope,\n+            trait_def.trait_ref.def_id, &trait_def.generics,\n+            path);\n+    let trait_ref =\n+        @ty::TraitRef {def_id: trait_def_id,\n+                       substs: substs};\n+    return trait_ref;\n+}\n+\n+\n pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n@@ -243,40 +278,29 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n-                    Some(&ast::def_trait(type_def_id)) => {\n-                        let result = ast_path_to_substs_and_ty(\n-                            self, rscope,\n-                            type_def_id, path);\n-                        match ty::get(result.ty).sty {\n-                            ty::ty_trait(trait_def_id, ref substs, _) => {\n-                                let trait_store = match vst {\n-                                    ty::vstore_box => ty::BoxTraitStore,\n-                                    ty::vstore_uniq => ty::UniqTraitStore,\n-                                    ty::vstore_slice(r) => {\n-                                        ty::RegionTraitStore(r)\n-                                    }\n-                                    ty::vstore_fixed(*) => {\n-                                        tcx.sess.span_err(\n-                                            path.span,\n-                                            ~\"@trait, ~trait or &trait \\\n-                                              are the only supported \\\n-                                              forms of casting-to-\\\n-                                              trait\");\n-                                        ty::BoxTraitStore\n-                                    }\n-                                };\n-                                return ty::mk_trait(tcx,\n-                                                    trait_def_id,\n-                                                    /*bad*/copy *substs,\n-                                                    trait_store);\n-\n+                    Some(&ast::def_trait(trait_def_id)) => {\n+                        let result = ast_path_to_trait_ref(\n+                            self, rscope, trait_def_id, path);\n+                        let trait_store = match vst {\n+                            ty::vstore_box => ty::BoxTraitStore,\n+                            ty::vstore_uniq => ty::UniqTraitStore,\n+                            ty::vstore_slice(r) => {\n+                                ty::RegionTraitStore(r)\n                             }\n-                            _ => {\n-                                tcx.sess.span_bug(\n-                                    a_seq_ty.ty.span,\n-                                    fmt!(\"def_trait but not ty_trait\"));\n+                            ty::vstore_fixed(*) => {\n+                                tcx.sess.span_err(\n+                                    path.span,\n+                                    ~\"@trait, ~trait or &trait \\\n+                                      are the only supported \\\n+                                      forms of casting-to-\\\n+                                      trait\");\n+                                ty::BoxTraitStore\n                             }\n-                        }\n+                        };\n+                        return ty::mk_trait(tcx,\n+                                            result.def_id,\n+                                            copy result.substs,\n+                                            trait_store);\n                     }\n                     _ => {}\n                 }\n@@ -376,7 +400,16 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           Some(&d) => d\n         };\n         match a_def {\n-          ast::def_trait(did) | ast::def_ty(did) | ast::def_struct(did) => {\n+          ast::def_trait(_) => {\n+              let path_str = path_to_str(path, tcx.sess.intr());\n+              tcx.sess.span_err(\n+                  ast_ty.span,\n+                  fmt!(\"reference to trait `%s` where a type is expected; \\\n+                        try `@%s`, `~%s`, or `&%s`\",\n+                       path_str, path_str, path_str, path_str));\n+              ty::mk_err(tcx)\n+          }\n+          ast::def_ty(did) | ast::def_struct(did) => {\n             ast_path_to_ty(self, rscope, did, path).ty\n           }\n           ast::def_prim_ty(nty) => {"}, {"sha": "605caba74a3803dd393e3b19c1da30bffe8e5eb2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -135,7 +135,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                     ty::enum_variant_with_id(tcx, enm, var);\n                 let var_tpt = ty::lookup_item_type(tcx, var);\n                 vinfo.args.map(|t| {\n-                    if var_tpt.bounds.len() == expected_substs.tps.len() {\n+                    if var_tpt.generics.bounds.len() == expected_substs.tps.len() {\n                         ty::subst(tcx, expected_substs, *t)\n                     }\n                     else {"}, {"sha": "fa3cb43d9abe030539bf99605f4ff667c46fb27d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -382,7 +382,7 @@ pub impl<'self> LookupContext<'self> {\n         let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n \n         for bounds.each |bound| {\n-            let bound_trait_ty = match *bound {\n+            let bound_trait_ref = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n                 ty::bound_copy | ty::bound_owned |\n@@ -391,22 +391,10 @@ pub impl<'self> LookupContext<'self> {\n                 }\n             };\n \n-\n-            let bound_substs = match ty::get(bound_trait_ty).sty {\n-                ty::ty_trait(_, ref substs, _) => (/*bad*/copy *substs),\n-                _ => {\n-                    self.bug(fmt!(\"add_candidates_from_param: \\\n-                                   non-trait bound %s\",\n-                                  self.ty_to_str(bound_trait_ty)));\n-                }\n-            };\n-\n-\n             // Loop over the trait and all of its supertraits.\n             let mut worklist = ~[];\n \n-            let init_trait_ty = bound_trait_ty;\n-            let init_substs = bound_substs;\n+            let init_trait_ref = bound_trait_ref;\n \n             // Replace any appearance of `self` with the type of the\n             // generic parameter itself.  Note that this is the only\n@@ -417,37 +405,34 @@ pub impl<'self> LookupContext<'self> {\n             // to self are not permitted).\n             let init_substs = substs {\n                 self_ty: Some(rcvr_ty),\n-                ..init_substs\n+                ..copy bound_trait_ref.substs\n             };\n \n-            worklist.push((init_trait_ty, init_substs));\n+            worklist.push((init_trait_ref.def_id, init_substs));\n \n             let mut i = 0;\n             while i < worklist.len() {\n-                let (init_trait_ty, init_substs) = /*bad*/copy worklist[i];\n+                let (init_trait_id, init_substs) = /*bad*/copy worklist[i];\n                 i += 1;\n \n-                let init_trait_id = ty::ty_to_def_id(init_trait_ty).get();\n-\n                 // Add all the supertraits of this trait to the worklist.\n-                let supertraits = ty::trait_supertraits(tcx,\n-                                                        init_trait_id);\n-                for supertraits.each |supertrait| {\n+                let supertraits = ty::trait_supertraits(tcx, init_trait_id);\n+                for supertraits.each |supertrait_ref| {\n                     debug!(\"adding supertrait: %?\",\n-                           supertrait.def_id);\n+                           supertrait_ref.def_id);\n \n-                    let new_substs = ty::subst_substs(\n+                    let new_substs = ty::subst_in_substs(\n                         tcx,\n-                        &supertrait.tpt.substs,\n-                        &init_substs);\n+                        &init_substs,\n+                        &supertrait_ref.substs);\n \n                     // Again replacing the self type\n                     let new_substs = substs {\n                         self_ty: Some(rcvr_ty),\n                         ..new_substs\n                     };\n \n-                    worklist.push((supertrait.tpt.ty, new_substs));\n+                    worklist.push((supertrait_ref.def_id, new_substs));\n                 }\n \n \n@@ -1116,7 +1101,7 @@ pub impl<'self> LookupContext<'self> {\n         // If they were not explicitly supplied, just construct fresh\n         // type variables.\n         let num_supplied_tps = self.supplied_tps.len();\n-        let num_method_tps = candidate.method_ty.tps.len();\n+        let num_method_tps = candidate.method_ty.generics.bounds.len();\n         let m_substs = {\n             if num_supplied_tps == 0u {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n@@ -1210,7 +1195,7 @@ pub impl<'self> LookupContext<'self> {\n                   self-type through a boxed trait\");\n         }\n \n-        if candidate.method_ty.tps.len() > 0 {\n+        if candidate.method_ty.generics.bounds.len() > 0 {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 ~\"cannot call a generic method through a boxed trait\");"}, {"sha": "957259e7d172ad999f2cc9bba58f6e139ce144ab", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -610,7 +610,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         } else {\n             for m.items.each |item| {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n-                if !tpt.bounds.is_empty() {\n+                if !tpt.generics.bounds.is_empty() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n                         fmt!(\"foreign items may not have type parameters\"));\n@@ -629,6 +629,10 @@ impl AstConv for FnCtxt {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+        ty::lookup_trait_def(self.tcx(), id)\n+    }\n+\n     fn ty_infer(&self, _span: span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n@@ -1064,7 +1068,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let (n_tps, region_param, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (vec::len(*ity.bounds), ity.region_param, ity.ty)\n+        (ity.generics.bounds.len(), ity.generics.region_param, ity.ty)\n     };\n \n     let self_r = if region_param.is_some() {\n@@ -1888,8 +1892,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.region_param;\n+            type_parameter_count = item_type.generics.bounds.len();\n+            region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n \n@@ -1976,8 +1980,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, enum_id);\n-            type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.region_param;\n+            type_parameter_count = item_type.generics.bounds.len();\n+            region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n \n@@ -3147,8 +3151,10 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_fn(_, ast::extern_fn) => {\n         // extern functions are just u8 pointers\n         return ty_param_bounds_and_ty {\n-            bounds: @~[],\n-            region_param: None,\n+            generics: ty::Generics {\n+                bounds: @~[],\n+                region_param: None\n+            },\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 ty::mt {\n@@ -3211,7 +3217,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         region_lb: ty::Region) {\n     debug!(\">>> instantiate_path\");\n \n-    let ty_param_count = vec::len(*tpt.bounds);\n+    let ty_param_count = tpt.generics.bounds.len();\n     let ty_substs_len = vec::len(pth.types);\n \n     debug!(\"ty_param_count=%? ty_substs_len=%?\",\n@@ -3222,7 +3228,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     // (if any) and otherwise using a fresh region variable\n     let self_r = match pth.rp {\n       Some(_) => { // user supplied a lifetime parameter...\n-        match tpt.region_param {\n+        match tpt.generics.region_param {\n           None => { // ...but the type is not lifetime parameterized!\n             fcx.ccx.tcx.sess.span_err\n                 (span, ~\"this item is not region-parameterized\");\n@@ -3235,7 +3241,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n       }\n       None => { // no lifetime parameter supplied, insert default\n         fcx.region_var_if_parameterized(\n-            tpt.region_param, span, region_lb)\n+            tpt.generics.region_param, span, region_lb)\n       }\n     };\n \n@@ -3433,28 +3439,13 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       }\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n-          let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n           assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          assert!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_trait) = *tcx.intrinsic_defs.get(&ty_visitor_name);\n-\n-          let visitor_trait = match ty::get(visitor_trait).sty {\n-            ty::ty_trait(trait_def_id, ref trait_substs, _) => {\n-                ty::mk_trait(tcx,\n-                             trait_def_id,\n-                             copy *trait_substs,\n-                             ty::BoxTraitStore)\n-            }\n-            _ => {\n-                tcx.sess.span_bug(it.span, ~\"TyVisitor wasn't a trait?!\")\n-            }\n-          };\n-\n+          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_copy, td_ptr),\n-                 arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n+                 arg(ast::by_ref, visitor_object_ty)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3700,7 +3691,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                     output: output}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n-    let i_n_tps = (*i_ty.bounds).len();\n+    let i_n_tps = i_ty.generics.bounds.len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n                                          of type parameters: found %u, \\"}, {"sha": "c30765baf37b3a274c201d13f9792c55e981b647", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 142, "deletions": 168, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -70,19 +70,19 @@ pub impl VtableContext {\n     fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n }\n \n-pub fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n+fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         bs.any(|b| {\n             match b { &ty::bound_trait(_) => true, _ => false }\n         })\n     })\n }\n \n-pub fn lookup_vtables(vcx: &VtableContext,\n-                      location_info: &LocationInfo,\n-                      bounds: @~[ty::param_bounds],\n-                      substs: &ty::substs,\n-                      is_early: bool) -> vtable_res {\n+fn lookup_vtables(vcx: &VtableContext,\n+                  location_info: &LocationInfo,\n+                  bounds: @~[ty::param_bounds],\n+                  substs: &ty::substs,\n+                  is_early: bool) -> vtable_res {\n     debug!(\"lookup_vtables(location_info=%?,\n             # bounds=%?, \\\n             substs=%s\",\n@@ -95,30 +95,30 @@ pub fn lookup_vtables(vcx: &VtableContext,\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n         for ty::iter_bound_traits_and_supertraits(\n-            tcx, bounds[i]) |trait_ty|\n+            tcx, bounds[i]) |trait_ref|\n         {\n             debug!(\"about to subst: %?, %?\",\n-                   ppaux::ty_to_str(tcx, trait_ty),\n+                   ppaux::trait_ref_to_str(tcx, trait_ref),\n                    ty::substs_to_str(tcx, substs));\n \n             let new_substs = substs {\n                 self_ty: Some(*ty),\n                 ../*bad*/copy *substs\n             };\n-            let trait_ty = ty::subst(tcx, &new_substs, trait_ty);\n+            let trait_ref = ty::subst_in_trait_ref(tcx, &new_substs, trait_ref);\n \n             debug!(\"after subst: %?\",\n-                   ppaux::ty_to_str(tcx, trait_ty));\n+                   vcx.infcx.trait_ref_to_str(&trait_ref));\n \n-            match lookup_vtable(vcx, location_info, *ty, trait_ty, is_early) {\n+            match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n                 Some(vtable) => result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n                         fmt!(\"failed to find an implementation of \\\n                               trait %s for %s\",\n-                             ppaux::ty_to_str(vcx.tcx(), trait_ty),\n-                             ppaux::ty_to_str(vcx.tcx(), *ty)));\n+                             vcx.infcx.trait_ref_to_str(&trait_ref),\n+                             vcx.infcx.ty_to_str(*ty)));\n                 }\n             }\n         }\n@@ -136,9 +136,9 @@ pub fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                    id: ast::def_id, +substs: ty::substs,\n-                    is_early: bool) -> Option<ty::substs> {\n+fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n+                id: ast::def_id, +substs: ty::substs,\n+                is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n@@ -152,31 +152,58 @@ pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     }\n }\n \n-pub fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n-                        exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n-    demand_suptype(vcx, location_info.span, exp_trait_ty, act_trait_ty)\n+fn relate_trait_refs(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     act_trait_ref: &ty::TraitRef,\n+                     exp_trait_ref: &ty::TraitRef)\n+{\n+    /*!\n+     *\n+     * Checks that an implementation of `act_trait_ref` is suitable\n+     * for use where `exp_trait_ref` is required and reports an\n+     * error otherwise.\n+     */\n+\n+    match infer::mk_sub_trait_refs(vcx.infcx, false, location_info.span,\n+                                   act_trait_ref, exp_trait_ref)\n+    {\n+        result::Ok(()) => {} // Ok.\n+        result::Err(ref err) => {\n+            let r_act_trait_ref =\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n+            let r_exp_trait_ref =\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+            if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n+                !ty::trait_ref_contains_error(&r_exp_trait_ref)\n+            {\n+                let tcx = vcx.tcx();\n+                tcx.sess.span_err(\n+                    location_info.span,\n+                    fmt!(\"expected %s, but found %s (%s)\",\n+                         ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n+                         ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n+                         ty::type_err_to_str(tcx, err)));\n+            }\n+        }\n+    }\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`\n-pub fn lookup_vtable(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n-                     ty: ty::t,\n-                     trait_ty: ty::t,\n-                     is_early: bool)\n-                  -> Option<vtable_origin> {\n-    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n-           vcx.infcx.ty_to_str(ty), vcx.infcx.ty_to_str(trait_ty));\n+fn lookup_vtable(vcx: &VtableContext,\n+                 location_info: &LocationInfo,\n+                 ty: ty::t,\n+                 trait_ref: &ty::TraitRef,\n+                 is_early: bool)\n+    -> Option<vtable_origin>\n+{\n+    debug!(\"lookup_vtable(ty=%s, trait_ref=%s)\",\n+           vcx.infcx.ty_to_str(ty),\n+           vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n     let tcx = vcx.tcx();\n-    let (trait_id, trait_substs, trait_store) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, ref substs, store) =>\n-            (did, (/*bad*/copy *substs), store),\n-        _ => tcx.sess.impossible_case(location_info.span,\n-                                      \"lookup_vtable: \\\n-                                       don't know how to handle a non-trait\")\n-    };\n+\n     let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n@@ -194,37 +221,20 @@ pub fn lookup_vtable(vcx: &VtableContext,\n             let mut n_bound = 0;\n             let bounds = *tcx.ty_param_bounds.get(&did.node);\n             for ty::iter_bound_traits_and_supertraits(\n-                tcx, bounds) |ity| {\n+                tcx, bounds) |bound_trait_ref|\n+            {\n                 debug!(\"checking bounds trait %?\",\n-                       vcx.infcx.ty_to_str(ity));\n-\n-                match ty::get(ity).sty {\n-                    ty::ty_trait(idid, ref isubsts, _) => {\n-                        if trait_id == idid {\n-                            debug!(\"(checking vtable) @0 \\\n-                                    relating ty to trait \\\n-                                    ty with did %?\",\n-                                   idid);\n-\n-                            // Convert `ity` so that it has the right vstore.\n-                            let ity = ty::mk_trait(vcx.tcx(),\n-                                                   idid,\n-                                                   copy *isubsts,\n-                                                   trait_store);\n-\n-                            relate_trait_tys(vcx, location_info,\n-                                             trait_ty, ity);\n-                            let vtable = vtable_param(n, n_bound);\n-                            debug!(\"found param vtable: %?\",\n-                                   vtable);\n-                            return Some(vtable);\n-                        }\n-                    }\n-                    _ => tcx.sess.impossible_case(\n-                        location_info.span,\n-                        \"lookup_vtable: in loop, \\\n-                         don't know how to handle a \\\n-                         non-trait ity\")\n+                       vcx.infcx.trait_ref_to_str(bound_trait_ref));\n+\n+                if bound_trait_ref.def_id == trait_ref.def_id {\n+                    relate_trait_refs(vcx,\n+                                      location_info,\n+                                      bound_trait_ref,\n+                                      trait_ref);\n+                    let vtable = vtable_param(n, n_bound);\n+                    debug!(\"found param vtable: %?\",\n+                           vtable);\n+                    return Some(vtable);\n                 }\n \n                 n_bound += 1;\n@@ -236,18 +246,19 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashSet::new();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(&trait_id) {\n+            match vcx.ccx.coherence_info.extension_methods.find(&trait_ref.def_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n                     let implementations: &mut ~[@Impl] = *implementations;\n+\n                     // implementations is the list of all impls in scope for\n-                    // trait_ty. (Usually, there's just one.)\n+                    // trait_ref. (Usually, there's just one.)\n                     for uint::range(0, implementations.len()) |i| {\n                         let im = implementations[i];\n \n-                        // im is one specific impl of trait_ty.\n+                        // im is one specific impl of trait_ref.\n \n                         // First, ensure we haven't processed this impl yet.\n                         if impls_seen.contains(&im.did) {\n@@ -269,22 +280,15 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                         //   ~[baz<int>, bar, quux]\n                         //\n                         // For each of the traits foo implements, if\n-                        // it's the same trait as trait_ty, we need to\n-                        // unify it with trait_ty in order to get all\n+                        // it's the same trait as trait_ref, we need to\n+                        // unify it with trait_ref in order to get all\n                         // the ty vars sorted out.\n-                        for vec::each(ty::impl_traits(tcx,\n-                                                      im.did,\n-                                                      trait_store)) |of_ty| {\n-                            match ty::get(*of_ty).sty {\n-                                ty::ty_trait(id, _, _) => {\n-                                    // Not the trait we're looking for\n-                                    if id != trait_id { loop; }\n-                                }\n-                                _ => { /* ok */ }\n-                            }\n+                        for ty::impl_trait_refs(tcx, im.did).each |&of_trait_ref|\n+                        {\n+                            if of_trait_ref.def_id != trait_ref.def_id { loop; }\n \n-                            // At this point, we know that of_ty is\n-                            // the same trait as trait_ty, but\n+                            // At this point, we know that of_trait_ref is\n+                            // the same trait as trait_ref, but\n                             // possibly applied to different substs.\n                             //\n                             // Next, we check whether the \"for\" ty in\n@@ -318,39 +322,36 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.ty_to_str(for_ty),\n                                    tys_to_str(vcx.tcx(), substs.tps));\n \n-                            // Next, we unify trait_ty -- the type\n-                            // that we want to cast to -- with of_ty\n+                            // Next, we unify trait_ref -- the type\n+                            // that we want to cast to -- with of_trait_ref\n                             // -- the trait that im implements. At\n                             // this point, we require that they be\n                             // unifiable with each other -- that's\n-                            // what relate_trait_tys does.\n+                            // what relate_trait_refs does.\n                             //\n                             // For example, in the above example,\n-                            // of_ty would be some_trait<T>, so we\n-                            // would be unifying trait_ty<U> (for some\n+                            // of_trait_ref would be some_trait<T>, so we\n+                            // would be unifying trait_ref<U> (for some\n                             // value of U) with some_trait<T>. This\n                             // would fail if T and U weren't\n                             // compatible.\n \n                             debug!(\"(checking vtable) @2 relating trait \\\n-                                    ty %s to of_ty %s\",\n-                                   vcx.infcx.ty_to_str(trait_ty),\n-                                   vcx.infcx.ty_to_str(*of_ty));\n-                            let of_ty = ty::subst(tcx, &substs, *of_ty);\n-                            relate_trait_tys(vcx, location_info, trait_ty,\n-                                             of_ty);\n-\n-                            // Recall that trait_ty -- the trait type\n-                            // we're casting to -- is the trait with\n-                            // id trait_id applied to the substs\n-                            // trait_substs. Now we extract out the\n-                            // types themselves from trait_substs.\n+                                    ty %s to of_trait_ref %s\",\n+                                   vcx.infcx.trait_ref_to_str(trait_ref),\n+                                   vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let trait_tps = /*bad*/copy trait_substs.tps;\n+                            let of_trait_ref =\n+                                ty::subst_in_trait_ref(tcx, &substs, of_trait_ref);\n+                            relate_trait_refs(\n+                                vcx, location_info,\n+                                &of_trait_ref, trait_ref);\n \n-                            debug!(\"Casting to a trait ty whose substs \\\n-                                    (trait_tps) are %s\",\n-                                   tys_to_str(vcx.tcx(), trait_tps));\n+                            // Recall that trait_ref -- the trait type\n+                            // we're casting to -- is the trait with\n+                            // id trait_ref.def_id applied to the substs\n+                            // trait_ref.substs. Now we extract out the\n+                            // types themselves from trait_ref.substs.\n \n                             // Recall that substs is the impl self\n                             // type's list of substitutions. That is,\n@@ -362,7 +363,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n                             let substs_f = match fixup_substs(vcx,\n                                                               location_info,\n-                                                              trait_id,\n+                                                              trait_ref.def_id,\n                                                               substs,\n                                                               is_early) {\n                                 Some(ref substs) => (/*bad*/copy *substs),\n@@ -377,7 +378,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                     they will be unified with the bounds for \\\n                                     the target ty, %s\",\n                                    tys_to_str(vcx.tcx(), substs_f.tps),\n-                                   tys_to_str(vcx.tcx(), trait_tps));\n+                                   vcx.infcx.trait_ref_to_str(trait_ref));\n \n                             // Next, we unify the fixed-up\n                             // substitutions for the impl self ty with\n@@ -386,14 +387,13 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n-                            let im_bs = ty::lookup_item_type(tcx,\n-                                                             im.did).bounds;\n+                            let im_bs =\n+                                ty::lookup_item_type(tcx, im.did).generics.bounds;\n                             connect_trait_tps(vcx,\n                                               location_info,\n-                                              /*bad*/copy substs_f.tps,\n-                                              trait_tps,\n-                                              im.did,\n-                                              trait_store);\n+                                              &substs_f,\n+                                              trait_ref,\n+                                              im.did);\n                             let subres = lookup_vtables(\n                                 vcx, location_info, im_bs, &substs_f,\n                                 is_early);\n@@ -430,10 +430,10 @@ pub fn lookup_vtable(vcx: &VtableContext,\n     return None;\n }\n \n-pub fn fixup_ty(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n-                ty: ty::t,\n-                is_early: bool) -> Option<ty::t> {\n+fn fixup_ty(vcx: &VtableContext,\n+            location_info: &LocationInfo,\n+            ty: ty::t,\n+            is_early: bool) -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n@@ -450,45 +450,23 @@ pub fn fixup_ty(vcx: &VtableContext,\n     }\n }\n \n-// Version of demand::suptype() that takes a vtable context instead of a\n-// function context.\n-pub fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n-    // NB: Order of actual, expected is reversed.\n-    match infer::mk_subty(vcx.infcx, false, sp, a, e) {\n-        result::Ok(()) => {} // Ok.\n-        result::Err(ref err) => {\n-            vcx.infcx.report_mismatched_types(sp, e, a, err);\n-        }\n-    }\n-}\n-\n-pub fn connect_trait_tps(vcx: &VtableContext,\n-                         location_info: &LocationInfo,\n-                         impl_tys: ~[ty::t],\n-                         trait_tys: ~[ty::t],\n-                         impl_did: ast::def_id,\n-                         store: ty::TraitStore) {\n+fn connect_trait_tps(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     impl_substs: &ty::substs,\n+                     trait_ref: &ty::TraitRef,\n+                     impl_did: ast::def_id)\n+{\n     let tcx = vcx.tcx();\n \n     // XXX: This should work for multiple traits.\n-    let ity = ty::impl_traits(tcx, impl_did, store)[0];\n-    let trait_ty = ty::subst_tps(tcx, impl_tys, None, ity);\n-    debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n-           ty::get(trait_ty).sty, impl_did);\n-    match ty::get(trait_ty).sty {\n-     ty::ty_trait(_, ref substs, _) => {\n-         for vec::each2((*substs).tps, trait_tys) |a, b| {\n-            demand_suptype(vcx, location_info.span, *a, *b);\n-         }\n-      }\n-     _ => tcx.sess.impossible_case(location_info.span, \"connect_trait_tps: \\\n-            don't know how to handle a non-trait ty\")\n-    }\n+    let impl_trait_ref = ty::impl_trait_refs(tcx, impl_did)[0];\n+    let impl_trait_ref = ty::subst_in_trait_ref(tcx, impl_substs, impl_trait_ref);\n+    relate_trait_refs(vcx, location_info, trait_ref, &impl_trait_ref);\n }\n \n-pub fn insert_vtables(fcx: @mut FnCtxt,\n-                      callee_id: ast::node_id,\n-                      vtables: vtable_res) {\n+fn insert_vtables(fcx: @mut FnCtxt,\n+                  callee_id: ast::node_id,\n+                  vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n            callee_id, vtables.map(|v| v.to_str(fcx.tcx())));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n@@ -517,15 +495,15 @@ pub fn early_resolve_expr(ex: @ast::expr,\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(/*bad*/copy *item_ty.bounds) {\n-                for item_ty.bounds.each |bounds| {\n+            if has_trait_bounds(/*bad*/copy *item_ty.generics.bounds) {\n+                for item_ty.generics.bounds.each |bounds| {\n                     debug!(\"early_resolve_expr: looking up vtables for bound \\\n                             %s\",\n                            ty::param_bounds_to_str(fcx.tcx(), *bounds));\n                 }\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           item_ty.bounds, substs, is_early);\n+                                           item_ty.generics.bounds, substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -564,7 +542,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       ast::expr_cast(src, _) => {\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n-              ty::ty_trait(_, _, store) => {\n+              ty::ty_trait(target_def_id, ref target_substs, store) => {\n                   // Look up vtables for the type we're casting to,\n                   // passing in the source and target type.  The source\n                   // must be a pointer type suitable to the object sigil,\n@@ -573,7 +551,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                                       fcx.expr_ty(src));\n                   match (&ty::get(ty).sty, store) {\n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                      // XXX: Bare trait store is deprecated.\n                       (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n                           let location_info =\n@@ -582,11 +559,15 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               ccx: fcx.ccx,\n                               infcx: fcx.infcx()\n                           };\n+                          let target_trait_ref = ty::TraitRef {\n+                              def_id: target_def_id,\n+                              substs: copy *target_substs\n+                          };\n                           let vtable_opt =\n                               lookup_vtable(&vcx,\n                                             location_info,\n                                             mt.ty,\n-                                            target_ty,\n+                                            &target_trait_ref,\n                                             is_early);\n                           match vtable_opt {\n                               Some(vtable) => {\n@@ -622,11 +603,12 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                           }\n                       }\n \n-                      (_, ty::BareTraitStore) => {\n+                      (_, ty::UniqTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              ~\"a sigil (`@`, `~`, or `&`) must be specified \\\n-                                when casting to a trait\");\n+                              fmt!(\"can only cast an ~-pointer \\\n+                                    to a ~-object, not a %s\",\n+                                   ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::BoxTraitStore) => {\n@@ -637,14 +619,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n-                      (_, ty::UniqTraitStore) => {\n-                          fcx.ccx.tcx.sess.span_err(\n-                              ex.span,\n-                              fmt!(\"can only cast an ~-pointer \\\n-                                    to a ~-object, not a %s\",\n-                                   ty::ty_sort_str(fcx.tcx(), ty)));\n-                      }\n-\n                       (_, ty::RegionTraitStore(_)) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n@@ -661,9 +635,9 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     }\n }\n \n-pub fn resolve_expr(ex: @ast::expr,\n-                    &&fcx: @mut FnCtxt,\n-                    v: visit::vt<@mut FnCtxt>) {\n+fn resolve_expr(ex: @ast::expr,\n+                &&fcx: @mut FnCtxt,\n+                v: visit::vt<@mut FnCtxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);\n }"}, {"sha": "f6042cf2e0cca3329971d89ff28efb8e37b4e4a7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -358,7 +358,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method.tps.len(),\n+                        n_tps: trait_method.generics.bounds.len(),\n                         ident: trait_method.ident,\n                         self_type: trait_method.self_ty\n                     },\n@@ -542,10 +542,10 @@ pub impl CoherenceChecker {\n                                   -> UniversalQuantificationResult {\n         // NDM--this span is bogus.\n         let self_region =\n-            polytype.region_param.map(\n+            polytype.generics.region_param.map(\n                 |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n \n-        let bounds_count = polytype.bounds.len();\n+        let bounds_count = polytype.generics.bounds.len();\n         let type_parameters =\n             self.inference_context.next_ty_vars(bounds_count);\n \n@@ -565,7 +565,7 @@ pub impl CoherenceChecker {\n         UniversalQuantificationResult {\n             monotype: monotype,\n             type_variables: type_parameters,\n-            bounds: polytype.bounds\n+            bounds: polytype.generics.bounds\n         }\n     }\n \n@@ -864,17 +864,8 @@ pub impl CoherenceChecker {\n             }\n \n             // Record all the trait methods.\n-            for associated_traits.each |trait_type| {\n-                match get(*trait_type).sty {\n-                    ty_trait(trait_id, _, _) => {\n-                        self.add_trait_method(trait_id, *implementation);\n-                    }\n-                    _ => {\n-                        self.crate_context.tcx.sess.bug(~\"trait type \\\n-                                                          returned is not a \\\n-                                                          trait\");\n-                    }\n-                }\n+            for associated_traits.each |trait_ref| {\n+                self.add_trait_method(trait_ref.def_id, *implementation);\n             }\n \n             // Add the implementation to the mapping from\n@@ -923,7 +914,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method_info.ty.tps.len(),\n+                        n_tps: trait_method_info.ty.generics.bounds.len(),\n                         ident: trait_method_info.ty.ident,\n                         self_type: trait_method_info.ty.self_ty\n                     },\n@@ -954,15 +945,7 @@ pub impl CoherenceChecker {\n                                                   def_id);\n                     }\n                     dl_def(def_trait(def_id)) => {\n-                        let tcx = self.crate_context.tcx;\n-                        let polytype = csearch::get_type(tcx, def_id);\n-                        match ty::get(polytype.ty).sty {\n-                            ty::ty_trait(*) => {\n-                                self.add_default_methods_for_external_trait(\n-                                    def_id);\n-                            }\n-                            _ => {}\n-                        }\n+                        self.add_default_methods_for_external_trait(def_id);\n                     }\n                     dl_def(_) | dl_impl(_) | dl_field => {\n                         // Skip this."}, {"sha": "a2245dc82cf80622995236c0c1867c13ccf2cf69", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 252, "deletions": 228, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -33,7 +33,6 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::InstantiatedTraitRef;\n use middle::ty::{substs, ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n@@ -83,12 +82,10 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n                     match intrinsic_item.node {\n                       ast::item_trait(*) => {\n-                        let ty = ty::mk_trait(ccx.tcx,\n-                                              def_id,\n-                                              substs,\n-                                              ty::BareTraitStore);\n-                        ccx.tcx.intrinsic_defs.insert\n-                            (intrinsic_item.ident, (def_id, ty));\n+                          let tref = @ty::TraitRef {def_id: def_id,\n+                                                    substs: substs};\n+                          ccx.tcx.intrinsic_traits.insert\n+                              (intrinsic_item.ident, tref);\n                       }\n \n                       ast::item_enum(*) => {\n@@ -152,6 +149,10 @@ impl AstConv for CrateCtxt {\n         }\n     }\n \n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+        get_trait_def(self, id)\n+    }\n+\n     fn ty_infer(&self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n                                ~\"found `ty_infer` in unexpected place\");\n@@ -186,8 +187,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, generics),\n-                    region_param: rp,\n+                    generics: ty_generics(ccx, rp, generics),\n                     ty: enum_ty\n                 };\n \n@@ -208,8 +208,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             None => {}\n             Some(result_ty) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, generics),\n-                    region_param: rp,\n+                    generics: ty_generics(ccx, rp, generics),\n                     ty: result_ty\n                 };\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -220,8 +219,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            trait_id: ast::node_id,\n-                            trait_ty: ty::t)\n+                            trait_id: ast::node_id)\n {\n     let tcx = ccx.tcx;\n     let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n@@ -230,7 +228,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             node: ast::item_trait(ref generics, _, ref ms),\n             _\n         }, _) => {\n-            let trait_bounds = ty_param_bounds(ccx, generics);\n+            let trait_ty_generics = ty_generics(ccx, region_paramd, generics);\n \n             // For each method, construct a suitable ty::method and\n             // store it into the `tcx.methods` table:\n@@ -252,9 +250,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                 };\n \n                 if ty_method.self_ty == ast::sty_static {\n-                    make_static_method_ty(ccx, region_paramd,\n-                                          ty_method, trait_ty,\n-                                          trait_bounds);\n+                    make_static_method_ty(ccx, trait_id, ty_method,\n+                                          &trait_ty_generics);\n                 }\n \n                 tcx.methods.insert(ty_method.def_id, ty_method);\n@@ -275,12 +272,9 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     }\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n-                             rp: Option<ty::region_variance>,\n+                             trait_id: ast::node_id,\n                              m: &ty::method,\n-                             // Take this as an argument b/c we may check\n-                             // the impl before the trait.\n-                             trait_ty: ty::t,\n-                             trait_bounds: @~[ty::param_bounds]) {\n+                             trait_ty_generics: &ty::Generics) {\n         // We need to create a typaram that replaces self. This param goes\n         // *in between* the typarams from the trait and those from the\n         // method (since its bound can depend on the trait? or\n@@ -291,12 +285,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         let dummy_defid = ast::def_id {crate: 0, node: 0};\n \n-        let non_shifted_trait_tps = do vec::from_fn(trait_bounds.len()) |i| {\n+        let num_trait_bounds = trait_ty_generics.bounds.len();\n+        let non_shifted_trait_tps = do vec::from_fn(num_trait_bounds) |i| {\n             ty::mk_param(ccx.tcx, i, dummy_defid)\n         };\n-        let self_param = ty::mk_param(ccx.tcx, trait_bounds.len(),\n+        let self_param = ty::mk_param(ccx.tcx, num_trait_bounds,\n                                       dummy_defid);\n-        let shifted_method_tps = do vec::from_fn(m.tps.len()) |i| {\n+        let shifted_method_tps = do vec::from_fn(m.generics.bounds.len()) |i| {\n             ty::mk_param(ccx.tcx, i + 1, dummy_defid)\n         };\n \n@@ -308,13 +303,20 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let ty = ty::subst(ccx.tcx,\n                            &substs,\n                            ty::mk_bare_fn(ccx.tcx, copy m.fty));\n-        let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n-                       + *m.tps);\n+        let trait_def = get_trait_def(ccx, local_def(trait_id));\n+        let trait_ref = trait_def.trait_ref;\n+        let mut new_bounds = ~[];\n+        new_bounds.push_all(*trait_ty_generics.bounds);\n+        new_bounds.push(@~[ty::bound_trait(trait_ref)]);\n+        new_bounds.push_all(*m.generics.bounds);\n         ccx.tcx.tcache.insert(m.def_id,\n                               ty_param_bounds_and_ty {\n-                                bounds: bounds,\n-                                region_param: rp,\n-                                ty: ty});\n+                                  generics: ty::Generics {\n+                                      bounds: @new_bounds,\n+                                      region_param: trait_ty_generics.region_param\n+                                  },\n+                                  ty: ty\n+                              });\n     }\n \n     fn ty_method_of_trait_method(self: &CrateCtxt,\n@@ -335,7 +337,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                   trait_self_ty, *m_self_ty, m_decl);\n         ty::method {\n             ident: *m_ident,\n-            tps: ty_param_bounds(self, m_generics),\n+            generics: ty_generics(self, None, m_generics),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: m_self_ty.node,\n@@ -350,25 +352,28 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          trait_refs: &[@ast::trait_ref],\n-                          generics: &ast::Generics) {\n+                          ast_trait_refs: &[@ast::trait_ref],\n+                          generics: &ast::Generics)\n+{\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n-    let mut instantiated = ~[];\n-    for trait_refs.each |trait_ref| {\n-        let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp, generics);\n-        if instantiated.any(|other_trait: &InstantiatedTraitRef|\n-                            { other_trait.def_id == did }) {\n+    let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    for ast_trait_refs.each |&ast_trait_ref| {\n+        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp, generics);\n+\n+        // NOTE Could have same trait multiple times\n+        if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n             tcx.sess.span_err(sp, ~\"Duplicate supertrait in trait \\\n                                      declaration\");\n-            return;\n+            break;\n+        } else {\n+            ty_trait_refs.push(trait_ref);\n         }\n-        instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n     }\n-    tcx.supertraits.insert(local_def(id), @instantiated);\n+    tcx.supertraits.insert(local_def(id), @ty_trait_refs);\n }\n \n /**\n@@ -422,15 +427,15 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         }\n     }\n \n-    if impl_m.tps.len() != trait_m.tps.len() {\n+    if impl_m.generics.bounds.len() != trait_m.generics.bounds.len() {\n         tcx.sess.span_err(\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 *tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n-                 pluralize(impl_m.tps.len(), ~\"parameter\"),\n-                 trait_m.tps.len(),\n-                 pluralize(trait_m.tps.len(), ~\"parameter\")));\n+                 *tcx.sess.str_of(trait_m.ident), impl_m.generics.bounds.len(),\n+                 pluralize(impl_m.generics.bounds.len(), ~\"parameter\"),\n+                 trait_m.generics.bounds.len(),\n+                 pluralize(trait_m.generics.bounds.len(), ~\"parameter\")));\n         return;\n     }\n \n@@ -448,9 +453,9 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // FIXME(#2687)---we should be checking that the bounds of the\n     // trait imply the bounds of the subtype, but it appears\n     // we are...not checking this.\n-    for trait_m.tps.eachi() |i, trait_param_bounds| {\n+    for trait_m.generics.bounds.eachi() |i, trait_param_bounds| {\n         // For each of the corresponding impl ty param's bounds...\n-        let impl_param_bounds = impl_m.tps[i];\n+        let impl_param_bounds = impl_m.generics.bounds[i];\n         // Make sure the bounds lists have the same length\n         // Would be nice to use the ty param names in the error message,\n         // but we don't have easy access to them here\n@@ -490,7 +495,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"impl_fty: %s\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n-        let dummy_tps = do vec::from_fn((*trait_m.tps).len()) |i| {\n+        let dummy_tps = do vec::from_fn(trait_m.generics.bounds.len()) |i| {\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, ast::def_id {crate: 0, node: 0})\n@@ -538,37 +543,23 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    impl_ms: &[ConvertedMethod])\n {\n     let tcx = ccx.tcx;\n-    let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n-\n-    if did.crate == ast::local_crate {\n-        // NB: This is subtle. We need to do this on the type of the trait\n-        // item *itself*, not on the type that includes the parameter\n-        // substitutions provided by the programmer at this particular\n-        // trait ref. Otherwise, we will potentially overwrite the types of\n-        // the methods within the trait with bogus results. (See issue #3903.)\n-\n-        match tcx.items.find(&did.node) {\n-            Some(&ast_map::node_item(item, _)) => {\n-                let tpt = ty_of_item(ccx, item);\n-                ensure_trait_methods(ccx, did.node, tpt.ty);\n-            }\n-            _ => {\n-                tcx.sess.bug(~\"trait ref didn't resolve to trait\");\n-            }\n-        }\n+    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n+\n+    if trait_ref.def_id.crate == ast::local_crate {\n+        ensure_trait_methods(ccx, trait_ref.def_id.node);\n     }\n \n     // Check that each method we impl is a method on the trait\n     // Trait methods we don't implement must be default methods, but if not\n     // we'll catch it in coherence\n-    let trait_ms = ty::trait_methods(tcx, did);\n+    let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_ms.each |impl_m| {\n         match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n                     ccx.tcx, num_impl_tps, impl_m, trait_m,\n-                    &tpt.substs, selfty);\n+                    &trait_ref.substs, selfty);\n             }\n             None => {\n                 // This method is not part of the trait\n@@ -594,8 +585,10 @@ pub fn convert_field(ccx: &CrateCtxt,\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n-                              bounds: bounds,\n-                              region_param: rp,\n+                              generics: ty::Generics {\n+                                  bounds: bounds,\n+                                  region_param: rp\n+                              },\n                               ty: tt\n                           });\n }\n@@ -609,28 +602,34 @@ pub struct ConvertedMethod {\n \n pub fn convert_methods(ccx: &CrateCtxt,\n                        ms: &[@ast::method],\n-                       rp: Option<ty::region_variance>,\n                        untransformed_rcvr_ty: ty::t,\n-                       rcvr_bounds: @~[ty::param_bounds],\n-                       rcvr_generics: &ast::Generics,\n+                       rcvr_ty_generics: &ty::Generics,\n+                       rcvr_ast_generics: &ast::Generics,\n                        rcvr_visibility: ast::visibility)\n                     -> ~[ConvertedMethod]\n {\n     let tcx = ccx.tcx;\n     return vec::map(ms, |m| {\n-        let bounds = ty_param_bounds(ccx, &m.generics);\n-        let mty = @ty_of_method(\n-            ccx, *m, rp, untransformed_rcvr_ty,\n-            rcvr_generics, rcvr_visibility, &m.generics);\n-        let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n+        let m_ty_generics =\n+            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics);\n+        let mty =\n+            @ty_of_method(ccx, *m, rcvr_ty_generics.region_param,\n+                          untransformed_rcvr_ty,\n+                          rcvr_ast_generics, rcvr_visibility,\n+                          &m.generics);\n+        let fty =\n+            ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n \n             // n.b.: the type of a method is parameterized by both\n             // the tps on the receiver and those on the method itself\n             ty_param_bounds_and_ty {\n-                bounds: @(vec::append(/*bad*/copy *rcvr_bounds, *bounds)),\n-                region_param: rp,\n+                generics: ty::Generics {\n+                    bounds: @(vec::append(copy *rcvr_ty_generics.bounds,\n+                                          *m_ty_generics.bounds)),\n+                    region_param: rcvr_ty_generics.region_param\n+                },\n                 ty: fty\n             });\n         write_ty_to_tcx(tcx, m.id, fty);\n@@ -657,7 +656,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                                   m.self_ty, &m.decl);\n         ty::method {\n             ident: m.ident,\n-            tps: ty_param_bounds(ccx, &m.generics),\n+            generics: ty_generics(ccx, None, &m.generics),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: m.self_ty.node,\n@@ -700,16 +699,15 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                                rp);\n       }\n       ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, generics);\n+        let i_ty_generics = ty_generics(ccx, rp, generics);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let selfty = ccx.to_ty(&type_rscope(region_parameterization), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n-                            bounds: i_bounds,\n-                            region_param: rp,\n-                            ty: selfty});\n+                              generics: i_ty_generics,\n+                              ty: selfty});\n \n         // If there is a trait reference, treat the methods as always public.\n         // This is to work around some incorrect behavior in privacy checking:\n@@ -722,27 +720,27 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx, *ms, rp, selfty, i_bounds, generics,\n+        let cms = convert_methods(ccx, *ms, selfty,\n+                                  &i_ty_generics, generics,\n                                   parent_visibility);\n         for opt_trait_ref.each |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n-        let tpt = ty_of_item(ccx, it);\n-        debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n-               it.id, ppaux::ty_to_str(tcx, tpt.ty));\n-        write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        ensure_trait_methods(ccx, it.id, tpt.ty);\n-        ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n-\n-        let (_, provided_methods) =\n-            split_trait_methods(*trait_methods);\n-        let (bounds, _) = mk_substs(ccx, generics, rp);\n-        let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n-        let _ = convert_methods(ccx, provided_methods, rp,\n-                                untransformed_rcvr_ty, bounds, generics,\n-                                it.vis);\n+          let trait_def = trait_def_of_item(ccx, it);\n+          tcx.trait_defs.insert(local_def(it.id), trait_def);\n+          ensure_trait_methods(ccx, it.id);\n+          ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n+\n+          let (_, provided_methods) =\n+              split_trait_methods(*trait_methods);\n+          let (ty_generics, _) = mk_substs(ccx, generics, rp);\n+          let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n+          let _ = convert_methods(ccx, provided_methods,\n+                                  untransformed_rcvr_ty,\n+                                  &ty_generics, generics,\n+                                  it.vis);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n@@ -794,14 +792,16 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           ty_param_bounds_and_ty {\n-                            bounds: tpt.bounds,\n-                            region_param: rp,\n-                            ty: t_dtor});\n+                              generics: ty::Generics {\n+                                  bounds: tpt.generics.bounds,\n+                                  region_param: rp\n+                              },\n+                              ty: t_dtor});\n     };\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n-       convert_field(ccx, rp, tpt.bounds, *f, generics);\n+       convert_field(ccx, rp, tpt.generics.bounds, *f, generics);\n     }\n     let (_, substs) = mk_substs(ccx, generics, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n@@ -824,8 +824,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n-                    bounds: tpt.bounds,\n-                    region_param: tpt.region_param,\n+                    generics: tpt.generics,\n                     ty: ctor_fn_ty\n                 });\n             }\n@@ -842,38 +841,75 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-/*\n-  Instantiates the path for the given trait reference, assuming that\n-  it's bound to a valid trait type. Returns the def_id for the defining\n-  trait. Fails if the type is a type other than an trait type.\n- */\n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n-                             t: @ast::trait_ref,\n+                             ast_trait_ref: @ast::trait_ref,\n                              rp: Option<ty::region_variance>,\n-                             generics: &ast::Generics)\n-    -> (ast::def_id, ty_param_substs_and_ty) {\n-\n-    let sp = t.path.span, err = ~\"can only implement trait types\",\n-        sess = ccx.tcx.sess;\n+                             generics: &ast::Generics) -> @ty::TraitRef\n+{\n+    /*!\n+     * Instantiates the path for the given trait reference, assuming that\n+     * it's bound to a valid trait type. Returns the def_id for the defining\n+     * trait. Fails if the type is a type other than an trait type.\n+     */\n \n     let rp = RegionParameterization::from_variance_and_generics(rp, generics);\n \n     let rscope = type_rscope(rp);\n \n-    match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n-      ast::def_trait(t_id) => {\n-        let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path);\n+    match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n+        ast::def_trait(trait_did) => {\n+            let trait_ref =\n+                astconv::ast_path_to_trait_ref(\n+                    ccx, &rscope, trait_did, ast_trait_ref.path);\n+            ccx.tcx.trait_refs.insert(\n+                ast_trait_ref.ref_id, trait_ref);\n+            return trait_ref;\n+        }\n+        _ => {\n+            ccx.tcx.sess.span_fatal(\n+                ast_trait_ref.path.span,\n+                fmt!(\"%s is not a trait\",\n+                    path_to_str(ast_trait_ref.path,\n+                                ccx.tcx.sess.intr())));\n+        }\n+    }\n+}\n \n-        write_tpt_to_tcx(ccx.tcx, t.ref_id, &tpt);\n+fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::def_id) -> @ty::TraitDef {\n+    if trait_id.crate != ast::local_crate {\n+        ty::lookup_trait_def(ccx.tcx, trait_id)\n+    } else {\n+        match ccx.tcx.items.get(&trait_id.node) {\n+            &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n+            _ => ccx.tcx.sess.bug(fmt!(\"get_trait_def(%d): not an item\",\n+                                       trait_id.node))\n+        }\n+    }\n+}\n \n-        match ty::get(tpt.ty).sty {\n-           ty::ty_trait(*) => {\n-              (t_id, tpt)\n-           }\n-           _ => sess.span_fatal(sp, err),\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: @ast::item) -> @ty::TraitDef {\n+    let def_id = local_def(it.id);\n+    let tcx = ccx.tcx;\n+    match tcx.trait_defs.find(&def_id) {\n+      Some(&def) => return def,\n+      _ => {}\n+    }\n+    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+    match it.node {\n+        ast::item_trait(ref generics, _, _) => {\n+            let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n+            let trait_ref = @ty::TraitRef {def_id: def_id,\n+                                           substs: substs};\n+            let trait_def = @ty::TraitDef {generics: ty_generics,\n+                                           trait_ref: trait_ref};\n+            tcx.trait_defs.insert(def_id, trait_def);\n+            return trait_def;\n+        }\n+        ref s => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                fmt!(\"trait_def_of_item invoked on %?\", s));\n         }\n-      }\n-      _ => sess.span_fatal(sp, err)\n     }\n }\n \n@@ -894,16 +930,19 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_fn(ref decl, purity, _, ref generics, _) => {\n-        let bounds = ty_param_bounds(ccx, generics);\n+        assert!(rp.is_none());\n+        let ty_generics = ty_generics(ccx, None, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx,\n                                           &empty_rscope,\n                                           purity,\n                                           AbiSet::Rust(),\n                                           &generics.lifetimes,\n                                           decl);\n         let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: None,\n+            generics: ty::Generics {\n+                bounds: ty_generics.bounds,\n+                region_param: None\n+            },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n         debug!(\"type of %s (id %d) is %s\",\n@@ -934,8 +973,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n                 }\n             };\n             ty_param_bounds_and_ty {\n-                bounds: ty_param_bounds(ccx, generics),\n-                region_param: rp,\n+                generics: ty_generics(ccx, rp, generics),\n                 ty: ty\n             }\n         };\n@@ -945,37 +983,26 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_enum(_, ref generics) => {\n         // Create a new generic polytype.\n-        let (bounds, substs) = mk_substs(ccx, generics, rp);\n+        let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n+            generics: ty_generics,\n             ty: t\n         };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_trait(ref generics, _, _) => {\n-        let (bounds, substs) = mk_substs(ccx, generics, rp);\n-        let t = ty::mk_trait(tcx,\n-                             local_def(it.id),\n-                             substs,\n-                             ty::BareTraitStore);\n-        let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n-            ty: t\n-        };\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n+      ast::item_trait(*) => {\n+          tcx.sess.span_bug(\n+              it.span,\n+              fmt!(\"Invoked ty_of_item on trait\"));\n       }\n       ast::item_struct(_, ref generics) => {\n-          let (bounds, substs) = mk_substs(ccx, generics, rp);\n+          let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n-            ty: t\n+              generics: ty_generics,\n+              ty: t\n           };\n           tcx.tcache.insert(local_def(it.id), tpt);\n           return tpt;\n@@ -997,76 +1024,82 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt, it: @ast::foreign_item)\n         }\n         ast::foreign_item_const(t) => {\n             ty::ty_param_bounds_and_ty {\n-                bounds: @~[],\n-                region_param: None,\n+                generics: ty::Generics {\n+                    bounds: @~[],\n+                    region_param: None,\n+                },\n                 ty: ast_ty_to_ty(ccx, &empty_rscope, t)\n             }\n         }\n     }\n }\n \n-// Translate the AST's notion of ty param bounds (which are an enum consisting\n-// of a newtyped Ty or a region) to ty's notion of ty param bounds, which can\n-// either be user-defined traits, or one of the four built-in traits (formerly\n-// known as kinds): Const, Copy, Durable, and Send.\n-pub fn compute_bounds(ccx: &CrateCtxt,\n-                      ast_bounds: @OptVec<ast::TyParamBound>)\n-                   -> ty::param_bounds {\n-    @ast_bounds.flat_map_to_vec(|b| {\n-        match b {\n-            &TraitTyParamBound(b) => {\n-                let li = &ccx.tcx.lang_items;\n-                let ity = ast_ty_to_ty(ccx, &empty_rscope, b);\n-                match ty::get(ity).sty {\n-                    ty::ty_trait(did, _, _) => {\n-                        if did == li.owned_trait() {\n-                            ~[ty::bound_owned]\n-                        } else if did == li.copy_trait() {\n-                            ~[ty::bound_copy]\n-                        } else if did == li.const_trait() {\n-                            ~[ty::bound_const]\n-                        } else if did == li.durable_trait() {\n-                            ~[ty::bound_durable]\n-                        } else {\n-                            // Must be a user-defined trait\n-                            ~[ty::bound_trait(ity)]\n-                        }\n-                    }\n-                    _ => {\n-                        ccx.tcx.sess.span_err(\n-                            (*b).span, ~\"type parameter bounds must be \\\n-                                         trait types\");\n-                        ~[]\n-                    }\n+pub fn ty_generics(ccx: &CrateCtxt,\n+                   rp: Option<ty::region_variance>,\n+                   generics: &ast::Generics) -> ty::Generics {\n+    return ty::Generics {\n+        region_param: rp,\n+        bounds: @generics.ty_params.map_to_vec(|param| {\n+            match ccx.tcx.ty_param_bounds.find(&param.id) {\n+                Some(&bs) => bs,\n+                None => {\n+                    let bounds = compute_bounds(ccx, rp, generics, param.bounds);\n+                    ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n+                    bounds\n                 }\n             }\n-            &RegionTyParamBound => ~[ty::bound_durable]\n-        }\n-    })\n-}\n+        })\n+    };\n \n-pub fn ty_param_bounds(ccx: &CrateCtxt,\n-                       generics: &ast::Generics)\n-                    -> @~[ty::param_bounds] {\n-    @do generics.ty_params.map_to_vec |param| {\n-        match ccx.tcx.ty_param_bounds.find(&param.id) {\n-          Some(&bs) => bs,\n-          None => {\n-            let bounds = compute_bounds(ccx, param.bounds);\n-            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n-            bounds\n-          }\n-        }\n+    fn compute_bounds(\n+        ccx: &CrateCtxt,\n+        rp: Option<ty::region_variance>,\n+        generics: &ast::Generics,\n+        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::param_bounds\n+    {\n+        /*!\n+         *\n+         * Translate the AST's notion of ty param bounds (which are an\n+         * enum consisting of a newtyped Ty or a region) to ty's\n+         * notion of ty param bounds, which can either be user-defined\n+         * traits, or one of the four built-in traits (formerly known\n+         * as kinds): Const, Copy, Durable, and Send.\n+         */\n+\n+        @ast_bounds.flat_map_to_vec(|b| {\n+            match b {\n+                &TraitTyParamBound(b) => {\n+                    let li = &ccx.tcx.lang_items;\n+                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics);\n+                    if trait_ref.def_id == li.owned_trait() {\n+                        ~[ty::bound_owned]\n+                    } else if trait_ref.def_id == li.copy_trait() {\n+                        ~[ty::bound_copy]\n+                    } else if trait_ref.def_id == li.const_trait() {\n+                        ~[ty::bound_const]\n+                    } else if trait_ref.def_id == li.durable_trait() {\n+                        ~[ty::bound_durable]\n+                    } else {\n+                        // Must be a user-defined trait\n+                        ~[ty::bound_trait(trait_ref)]\n+                    }\n+                }\n+\n+                &RegionTyParamBound => {\n+                    ~[ty::bound_durable]\n+                }\n+            }\n+        })\n     }\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::fn_decl,\n                              def_id: ast::def_id,\n-                             generics: &ast::Generics)\n+                             ast_generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(ccx, generics);\n-    let region_param_names = RegionParamNames::from_generics(generics);\n+    let ty_generics = ty_generics(ccx, None, ast_generics);\n+    let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n@@ -1081,33 +1114,24 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                             output: output_ty}\n         });\n     let tpt = ty_param_bounds_and_ty {\n-        bounds: bounds,\n-        region_param: None,\n+        generics: ty_generics,\n         ty: t_fn\n     };\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n }\n \n-pub fn mk_generics(ccx: &CrateCtxt, generics: &ast::Generics)\n-    -> (@~[ty::param_bounds], ~[ty::t])\n-{\n-    let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, generics);\n-    (bounds,\n-     generics.ty_params.map_to_vec(|atp| {\n-         let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n-         i += 1u;\n-         t\n-     }))\n-}\n-\n pub fn mk_substs(ccx: &CrateCtxt,\n-                 generics: &ast::Generics,\n-                 rp: Option<ty::region_variance>)\n-              -> (@~[ty::param_bounds], ty::substs)\n+                 ast_generics: &ast::Generics,\n+                 rp: Option<ty::region_variance>) -> (ty::Generics, ty::substs)\n {\n-    let (bounds, params) = mk_generics(ccx, generics);\n+    let mut i = 0;\n+    let ty_generics = ty_generics(ccx, rp, ast_generics);\n+    let params = ast_generics.ty_params.map_to_vec(|atp| {\n+        let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n+        i += 1u;\n+        t\n+    });\n     let self_r = rscope::bound_self_region(rp);\n-    (bounds, substs { self_r: self_r, self_ty: None, tps: params })\n+    (ty_generics, substs {self_r: self_r, self_ty: None, tps: params})\n }"}, {"sha": "69c7b1d616b0a3dce308868b4709eb045f9f8e98", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -90,7 +90,7 @@ pub trait Combine {\n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n     fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n                -> cres<Option<ty::t>>;\n-    fn substs(&self, did: ast::def_id, as_: &ty::substs,\n+    fn substs(&self, generics: &ty::Generics, as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n@@ -114,6 +114,7 @@ pub trait Combine {\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n                  -> cres<ty::TraitStore>;\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>;\n }\n \n pub struct CombineFields {\n@@ -192,32 +193,31 @@ pub fn eq_opt_regions<C:Combine>(\n }\n \n pub fn super_substs<C:Combine>(\n-    self: &C, did: ast::def_id,\n+    self: &C, generics: &ty::Generics,\n     a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n     fn relate_region_param<C:Combine>(\n         self: &C,\n-        did: ast::def_id,\n+        generics: &ty::Generics,\n         a: Option<ty::Region>,\n         b: Option<ty::Region>)\n         -> cres<Option<ty::Region>>\n     {\n-        let polyty = ty::lookup_item_type(self.infcx().tcx, did);\n-        match (polyty.region_param, a, b) {\n-          (None, None, None) => {\n+        match (&generics.region_param, &a, &b) {\n+          (&None, &None, &None) => {\n             Ok(None)\n           }\n-          (Some(ty::rv_invariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_invariant), &Some(a), &Some(b)) => {\n             do eq_regions(self, a, b).then {\n                 Ok(Some(a))\n             }\n           }\n-          (Some(ty::rv_covariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_covariant), &Some(a), &Some(b)) => {\n             do self.regions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n           }\n-          (Some(ty::rv_contravariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_contravariant), &Some(a), &Some(b)) => {\n             do self.contraregions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n@@ -233,14 +233,14 @@ pub fn super_substs<C:Combine>(\n                       b had opt_region %s with variance %?\",\n                       a.inf_str(self.infcx()),\n                       b.inf_str(self.infcx()),\n-                      polyty.region_param));\n+                     generics.region_param));\n           }\n         }\n     }\n \n     do self.tps(a.tps, b.tps).chain |tps| {\n         do self.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do relate_region_param(self, did,\n+            do relate_region_param(self, generics,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n                 Ok(substs {\n@@ -520,26 +520,29 @@ pub fn super_tys<C:Combine>(\n       (ty::ty_enum(a_id, ref a_substs),\n        ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            Ok(ty::mk_enum(tcx, a_id, substs))\n-        }\n+          let type_def = ty::lookup_item_type(tcx, a_id);\n+          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+              Ok(ty::mk_enum(tcx, a_id, substs))\n+          }\n       }\n \n       (ty::ty_trait(a_id, ref a_substs, a_store),\n        ty::ty_trait(b_id, ref b_substs, b_store))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            do self.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s))\n-            }\n-        }\n+          let trait_def = ty::lookup_trait_def(tcx, a_id);\n+          do self.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n+              do self.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n+                  Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s))\n+              }\n+          }\n       }\n \n       (ty::ty_struct(a_id, ref a_substs), ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            Ok(ty::mk_struct(tcx, a_id, substs))\n-        }\n+          let type_def = ty::lookup_item_type(tcx, a_id);\n+          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+              Ok(ty::mk_struct(tcx, a_id, substs))\n+          }\n       }\n \n       (ty::ty_box(ref a_mt), ty::ty_box(ref b_mt)) => {\n@@ -634,3 +637,25 @@ pub fn super_tys<C:Combine>(\n         Ok(ty::mk_mach_float(tcx, val))\n     }\n }\n+\n+pub fn super_trait_refs<C:Combine>(\n+    self: &C, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>\n+{\n+    // Different traits cannot be related\n+\n+    // - NOTE in the future, expand out subtraits!\n+\n+    if a.def_id != b.def_id {\n+        Err(ty::terr_traits(\n+            expected_found(self, a.def_id, b.def_id)))\n+    } else {\n+        let tcx = self.infcx().tcx;\n+        let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n+        let substs = if_ok!(self.substs(&trait_def.generics, &a.substs, &b.substs));\n+        Ok(ty::TraitRef {\n+            def_id: a.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+"}, {"sha": "43f2b0eaf722942b16abbd888550c7076adec7a3", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -299,10 +299,11 @@ impl Combine for Glb {\n         super_closure_tys(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -313,5 +314,9 @@ impl Combine for Glb {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }\n "}, {"sha": "7cf4d25c6702426b74d4d65394465ceea8151b0a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -244,10 +244,11 @@ impl Combine for Lub {\n         super_args(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -258,4 +259,8 @@ impl Combine for Lub {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }"}, {"sha": "58de0122c8c9b95bf2fea43e5f39f8073c5f1253", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -265,7 +265,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::isr_alist;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str};\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str};\n \n use core::cmp::Eq;\n use core::result::{Result, Ok, Err};\n@@ -419,6 +419,23 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n     }.to_ures()\n }\n \n+pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n+                         a_is_expected: bool,\n+                         span: span,\n+                         a: &ty::TraitRef,\n+                         b: &ty::TraitRef)\n+    -> ures\n+{\n+    debug!(\"mk_sub_trait_refs(%s <: %s)\",\n+           a.inf_str(cx), b.inf_str(cx));\n+    do indent {\n+        do cx.commit {\n+            let suber = cx.sub(a_is_expected, span);\n+            suber.trait_refs(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n pub fn mk_coercety(cx: @mut InferCtxt,\n                    a_is_expected: bool,\n                    span: span,\n@@ -700,13 +717,43 @@ pub impl InferCtxt {\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n+    fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n+        let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n+        trait_ref_to_str(self.tcx, &t)\n+    }\n+\n     fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n+    fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n+                                                  trait_ref: &ty::TraitRef)\n+        -> ty::TraitRef\n+    {\n+        // make up a dummy type just to reuse/abuse the resolve machinery\n+        let dummy0 = ty::mk_trait(self.tcx,\n+                                  trait_ref.def_id,\n+                                  copy trait_ref.substs,\n+                                  ty::UniqTraitStore);\n+        let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n+        match ty::get(dummy1).sty {\n+            ty::ty_trait(ref def_id, ref substs, _) => {\n+                ty::TraitRef {def_id: *def_id,\n+                              substs: copy *substs}\n+            }\n+            _ => {\n+                self.tcx.sess.bug(\n+                    fmt!(\"resolve_type_vars_if_possible() yielded %s \\\n+                          when supplied with %s\",\n+                         self.ty_to_str(dummy0),\n+                         self.ty_to_str(dummy1)));\n+            }\n+        }\n+    }\n+\n     fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);"}, {"sha": "2e1be2c380f8f63260554a2b8c81c1d45b91cf18", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -256,10 +256,11 @@ impl Combine for Sub {\n         super_args(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -270,5 +271,9 @@ impl Combine for Sub {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }\n "}, {"sha": "d4959961f12ce01dbe919688f0a411d058da7f31", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -16,7 +16,7 @@ use middle::ty;\n use middle::typeck::infer::{Bound, Bounds};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n-use util::ppaux::{mt_to_str, ty_to_str};\n+use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n \n use syntax::ast;\n \n@@ -91,3 +91,9 @@ impl InferStr for ast::float_ty {\n         self.to_str()\n     }\n }\n+\n+impl InferStr for ty::TraitRef {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        trait_ref_to_str(cx.tcx, self)\n+    }\n+}"}, {"sha": "d3502adb33ab8b8b97f92512a379d6a4cb9f7a49", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -222,8 +222,8 @@ pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        bounds: @~[],\n-        region_param: None,\n+        generics: ty::Generics {bounds: @~[],\n+                                region_param: None},\n         ty: t\n     }\n }"}, {"sha": "cdeb12b80f4486e3497c5f80bbcedebdba8c5f35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -239,7 +239,6 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n \n pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n-      ty::BareTraitStore => ~\"\",\n       ty::UniqTraitStore => ~\"~\",\n       ty::BoxTraitStore => ~\"@\",\n       ty::RegionTraitStore(r) => region_to_str_space(cx, \"&\", r)\n@@ -285,6 +284,12 @@ pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n          ty_to_str(cx, typ.output))\n }\n \n+pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n+    let path = ty::item_path(cx, trait_ref.def_id);\n+    let base = ast_map::path_to_str(path, cx.sess.intr());\n+    parameterized(cx, base, trait_ref.substs.self_r, trait_ref.substs.tps)\n+}\n+\n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n         let ty::arg {mode: mode, ty: ty} = input;"}, {"sha": "ec77b54a853713aea88dd4852280e00b8729ee21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -144,7 +144,7 @@ pub static crate_node_id: node_id = 0;\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n pub enum TyParamBound {\n-    TraitTyParamBound(@Ty),\n+    TraitTyParamBound(@trait_ref),\n     RegionTyParamBound\n }\n "}, {"sha": "39b8d4f2cced361419d51c726fe00951feee7f0a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -227,10 +227,9 @@ priv impl @ext_ctxt {\n         path: @ast::path,\n         bounds: @OptVec<ast::TyParamBound>\n     ) -> ast::TyParam {\n-        let bound = ast::TraitTyParamBound(@ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(path, self.next_id()),\n-            span: span,\n+        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n+            ref_id: self.next_id(),\n+            path: path\n         });\n \n         ast::TyParam {\n@@ -466,10 +465,9 @@ fn mk_impl(\n     // All the type parameters need to bound to the trait.\n     let mut impl_tps = opt_vec::with(ty_param);\n     for generics.ty_params.each |tp| {\n-        let t_bound = ast::TraitTyParamBound(@ast::Ty {\n-            id: cx.next_id(),\n-            node: ast::ty_path(path, cx.next_id()),\n-            span: span,\n+        let t_bound = ast::TraitTyParamBound(@ast::trait_ref {\n+            path: path,\n+            ref_id: cx.next_id(),\n         });\n \n         impl_tps.push(ast::TyParam {"}, {"sha": "43f0c9edcb96437e1db6a0e5d26973d5e8fb1e57", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -337,6 +337,17 @@ pub fn mk_ty_path_global(cx: @ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n+pub fn mk_trait_ref_global(cx: @ext_ctxt,\n+                           span: span,\n+                           +idents: ~[ ast::ident ])\n+    -> @ast::trait_ref\n+{\n+    let path = build::mk_raw_path_global(span, idents);\n+    @ast::trait_ref {\n+        path: path,\n+        ref_id: cx.next_id()\n+    }\n+}\n pub fn mk_simple_ty_path(cx: @ext_ctxt,\n                          span: span,\n                          ident: ast::ident)"}, {"sha": "ccd9a33757dd5f331689318dbdcb01f10f8942f1", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -177,9 +177,9 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n \n     // Create the type parameters.\n     let impl_ty_params = generics.ty_params.map(|ty_param| {\n-        let bound = build::mk_ty_path_global(cx,\n-                                             span,\n-                                             trait_path.map(|x| *x));\n+        let bound = build::mk_trait_ref_global(cx,\n+                                               span,\n+                                               trait_path.map(|x| *x));\n         let bounds = @opt_vec::with(TraitTyParamBound(bound));\n         build::mk_ty_param(cx, ty_param.ident, bounds)\n     });"}, {"sha": "5aa51c262e174ce49d9e5c7066bb0e91c62238b4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -134,7 +134,7 @@ pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n \n fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n+        TraitTyParamBound(ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }"}, {"sha": "3a3597828cd24366238a26729f0346047215cbb7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -2750,8 +2750,8 @@ pub impl Parser {\n                     self.bump();\n                 }\n                 token::MOD_SEP | token::IDENT(*) => {\n-                    let maybe_bound = match *self.token {\n-                        token::MOD_SEP => None,\n+                    let obsolete_bound = match *self.token {\n+                        token::MOD_SEP => false,\n                         token::IDENT(copy sid, _) => {\n                             match *self.id_to_str(sid) {\n                                 ~\"send\" |\n@@ -2761,27 +2761,18 @@ pub impl Parser {\n                                     self.obsolete(\n                                         *self.span,\n                                         ObsoleteLowerCaseKindBounds);\n-\n-                                    // Bogus value, but doesn't matter, since\n-                                    // is an error\n-                                    Some(TraitTyParamBound(\n-                                        self.mk_ty_path(sid)))\n+                                    self.bump();\n+                                    true\n                                 }\n-                                _ => None\n+                                _ => false\n                             }\n                         }\n                         _ => fail!()\n                     };\n \n-                    match maybe_bound {\n-                        Some(bound) => {\n-                            self.bump();\n-                            result.push(bound);\n-                        }\n-                        None => {\n-                            let ty = self.parse_ty(true);\n-                            result.push(TraitTyParamBound(ty));\n-                        }\n+                    if !obsolete_bound {\n+                        let tref = self.parse_trait_ref();\n+                        result.push(TraitTyParamBound(tref));\n                     }\n                 }\n                 _ => break,"}, {"sha": "20fc99baf217904d9c17b45252f10244f449310e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -562,7 +562,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n \n         match opt_trait {\n             Some(t) => {\n-                print_path(s, t.path, false);\n+                print_trait_ref(s, t);\n                 space(s.s);\n                 word_space(s, ~\"for\");\n             }\n@@ -619,6 +619,10 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     (s.ann.post)(ann_node);\n }\n \n+fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n+    print_path(s, t.path, false);\n+}\n+\n pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n@@ -1744,7 +1748,7 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n             }\n \n             match *bound {\n-                TraitTyParamBound(ty) => print_type(s, ty),\n+                TraitTyParamBound(tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(s.s, ~\"'static\"),\n             }\n         }"}, {"sha": "b20c5eeee1f04e82ccd6d459e0f5e7df767d444f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -147,6 +147,10 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     }\n }\n \n+fn visit_trait_ref<E>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n+    visit_path(tref.path, e, v);\n+}\n+\n pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n         item_const(t, ex) => {\n@@ -189,9 +193,9 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n             (v.visit_generics)(tps, e, v);\n-            for traits.each |p| {\n-                visit_path(p.path, e, v);\n-        }\n+            for traits.each |&p| {\n+                visit_trait_ref(p, e, v);\n+            }\n             (v.visit_ty)(ty, e, v);\n             for methods.each |m| {\n                 visit_method_helper(*m, e, v)\n@@ -327,8 +331,8 @@ pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n                                 e: E, v: vt<E>) {\n     for bounds.each |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => (v.visit_ty)(ty, e, v),\n-            RegionTyParamBound => ()\n+            TraitTyParamBound(ty) => visit_trait_ref(ty, e, v),\n+            RegionTyParamBound => {}\n         }\n     }\n }"}, {"sha": "6152e82294d1b51f9d0d4faa28506f0cf48117ae", "filename": "src/test/compile-fail/issue-2330.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -15,7 +15,7 @@ trait channel<T> {\n }\n \n // `chan` is not a trait, it's an enum\n-impl chan for int { //~ ERROR can only implement trait types\n+impl chan for int { //~ ERROR chan is not a trait\n     fn send(&self, v: int) { fail!() }\n }\n "}, {"sha": "220573660c5b08dca07205b2d8f4c6f3283db891", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -12,7 +12,7 @@ trait add {\n     fn plus(&self, x: Self) -> Self;\n }\n \n-fn do_add(x: add, y: add) -> add {\n+fn do_add(x: @add, y: @add) -> @add {\n     x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through a boxed trait\n }\n "}, {"sha": "7c2f8cf98cb8a297f0f5906ae012b7b911d8a984", "filename": "src/test/run-pass/issue-3702.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3702.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     fn to_str(&self) -> ~str;\n   }\n \n-  fn to_string(t: Text) {\n+  fn to_string(t: @Text) {\n     io::println(t.to_str());\n   }\n "}, {"sha": "a27599e6ed00afc66534d747202a60427b38d7a7", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28f7344125b47b7e991413c5612708ce8d5ed77/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d28f7344125b47b7e991413c5612708ce8d5ed77", "patch": "@@ -417,9 +417,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_trait(&self) -> bool {\n-        self.align_to::<TyVisitor>();\n+        self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n+        self.bump_past::<@TyVisitor>();\n         true\n     }\n "}]}