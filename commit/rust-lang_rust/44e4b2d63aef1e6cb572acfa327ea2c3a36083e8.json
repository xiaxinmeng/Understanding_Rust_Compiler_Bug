{"sha": "44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTRiMmQ2M2FlZjFlNmNiNTcyYWNmYTMyN2VhMmMzYTM2MDgzZTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-04T22:55:12Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-04T22:55:12Z"}, "message": "Teach rustc about phi nodes, block relationships. Translate if- and block-expressions.", "tree": {"sha": "d48f06f491e20d4f176c7e1435ba953ec549d72c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48f06f491e20d4f176c7e1435ba953ec549d72c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "html_url": "https://github.com/rust-lang/rust/commit/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87e81b9292d49f1aa09cdcd928113305ad73a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87e81b9292d49f1aa09cdcd928113305ad73a53", "html_url": "https://github.com/rust-lang/rust/commit/a87e81b9292d49f1aa09cdcd928113305ad73a53"}], "stats": {"total": 436, "additions": 324, "deletions": 112}, "files": [{"sha": "48ba9187af8d839a91ea02df77f7ff84211d5cc1", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "patch": "@@ -1,7 +1,10 @@\n \n-import std.util.option;\n+import util.common.option;\n import std.map.hashmap;\n import util.common.span;\n+import util.common.option;\n+import util.common.some;\n+import util.common.none;\n \n type ident = str;\n \n@@ -40,10 +43,10 @@ tag unop {\n }\n \n tag stmt {\n-    stmt_block(block);\n     stmt_decl(@decl);\n     stmt_ret(option[@expr]);\n     stmt_log(@expr);\n+    stmt_expr(@expr);\n }\n \n tag decl {\n@@ -63,6 +66,8 @@ tag expr {\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_cast(@expr, ty);\n+    expr_if(@expr, block, option[block]);\n+    expr_block(block);\n }\n \n tag lit {"}, {"sha": "12a1f072901734d0f3ac9759a5bce31a3d4f93ad", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "patch": "@@ -2,15 +2,9 @@ import std._io;\n import driver.session;\n import util.common;\n import util.common.new_str_hash;\n-\n-// FIXME: import std.util.option and use it here.\n-// import std.util.option;\n-\n-tag option[T] {\n-  none;\n-  some(T);\n-}\n-\n+import util.common.option;\n+import util.common.some;\n+import util.common.none;\n \n state type parser =\n     state obj {\n@@ -414,8 +408,35 @@ io fn parse_or_expr(parser p) -> @ast.expr {\n     ret parse_binary_exprs(p, sub, vec(tup(token.OROR, ast.or)));\n }\n \n+io fn parse_if_expr(parser p) -> @ast.expr {\n+    expect(p, token.IF);\n+    expect(p, token.LPAREN);\n+    auto cond = parse_expr(p);\n+    expect(p, token.RPAREN);\n+    auto thn = parse_block(p);\n+    let option[ast.block] els = none[ast.block];\n+    alt (p.peek()) {\n+        case (token.ELSE) {\n+            p.bump();\n+            els = some(parse_block(p));\n+        }\n+    }\n+    ret @ast.expr_if(cond, thn, els);\n+}\n+\n io fn parse_expr(parser p) -> @ast.expr {\n-    ret parse_or_expr(p);\n+    alt (p.peek()) {\n+        case (token.LBRACE) {\n+            ret @ast.expr_block(parse_block(p));\n+        }\n+        case (token.IF) {\n+            ret parse_if_expr(p);\n+        }\n+        case (_) {\n+            ret parse_or_expr(p);\n+        }\n+\n+    }\n }\n \n io fn parse_stmt(parser p) -> @ast.stmt {\n@@ -426,6 +447,25 @@ io fn parse_stmt(parser p) -> @ast.stmt {\n             expect(p, token.SEMI);\n             ret @ast.stmt_log(e);\n         }\n+\n+        // Handle the (few) block-expr stmts first.\n+\n+        case (token.IF) {\n+            ret @ast.stmt_expr(parse_expr(p));\n+        }\n+\n+        case (token.LBRACE) {\n+            ret @ast.stmt_expr(parse_expr(p));\n+        }\n+\n+\n+        // Remainder are line-expr stmts.\n+\n+        case (_) {\n+            auto e = parse_expr(p);\n+            expect(p, token.SEMI);\n+            ret @ast.stmt_expr(e);\n+        }\n     }\n     p.err(\"expected statement\");\n     fail;"}, {"sha": "220af154e0e66595fd1199d4df2624abaad313d7", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "patch": "@@ -1006,8 +1006,14 @@ obj builder(BuilderRef B) {\n \n \n     /* Miscellaneous instructions */\n-    fn Phi(TypeRef Ty) -> ValueRef {\n-        ret llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n+    fn Phi(TypeRef Ty, vec[ValueRef] vals, vec[BasicBlockRef] bbs) -> ValueRef {\n+        auto phi = llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n+        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        llvm.LLVMAddIncoming(phi,\n+                             _vec.buf[ValueRef](vals),\n+                             _vec.buf[BasicBlockRef](bbs),\n+                             _vec.len[ValueRef](vals));\n+        ret phi;\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {"}, {"sha": "ea64e060b2bb9d6c6fbf4e304075914039f53bdd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 251, "deletions": 98, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "patch": "@@ -11,6 +11,9 @@ import back.abi;\n \n import util.common.istr;\n import util.common.new_str_hash;\n+import util.common.option;\n+import util.common.some;\n+import util.common.none;\n \n import lib.llvm.llvm;\n import lib.llvm.builder;\n@@ -51,7 +54,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n type terminator = fn(@fn_ctxt cx, builder build);\n \n tag cleanup {\n-    clean(fn(@block_ctxt cx) -> @block_ctxt);\n+    clean(fn(@block_ctxt cx) -> result);\n }\n \n state type block_ctxt = rec(BasicBlockRef llbb,\n@@ -61,6 +64,14 @@ state type block_ctxt = rec(BasicBlockRef llbb,\n                             @fn_ctxt fcx);\n \n \n+state type result = rec(mutable @block_ctxt bcx,\n+                        mutable ValueRef val);\n+\n+fn res(@block_ctxt bcx, ValueRef val) -> result {\n+    ret rec(mutable bcx = bcx,\n+            mutable val = val);\n+}\n+\n fn ty_str(TypeRef t) -> str {\n     ret lib.llvm.type_to_str(t);\n }\n@@ -76,10 +87,25 @@ fn val_str(ValueRef v) -> str {\n \n // LLVM type constructors.\n \n-fn T_nil() -> TypeRef {\n+fn T_void() -> TypeRef {\n+    // Note: For the time being llvm is kinda busted here, it has the notion\n+    // of a 'void' type that can only occur as part of the signature of a\n+    // function, but no general unit type of 0-sized value. This is, afaict,\n+    // vestigial from its C heritage, and we'll be attempting to submit a\n+    // patch upstream to fix it. In the mean time we only model function\n+    // outputs (Rust functions and C functions) using T_void, and model the\n+    // Rust general purpose nil type you can construct as 1-bit (always\n+    // zero). This makes the result incorrect for now -- things like a tuple\n+    // of 10 nil values will have 10-bit size -- but it doesn't seem like we\n+    // have any other options until it's fixed upstream.\n     ret llvm.LLVMVoidType();\n }\n \n+fn T_nil() -> TypeRef {\n+    // NB: See above in T_void().\n+    ret llvm.LLVMInt1Type();\n+}\n+\n fn T_i1() -> TypeRef {\n     ret llvm.LLVMInt1Type();\n }\n@@ -196,6 +222,11 @@ fn C_integral(int i, TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntOfString(t, _str.buf(istr(i)), 10);\n }\n \n+fn C_nil() -> ValueRef {\n+    // NB: See comment above in T_void().\n+    ret C_integral(0, T_i1());\n+}\n+\n fn C_bool(bool b) -> ValueRef {\n     if (b) {\n         ret C_integral(1, T_i1());\n@@ -233,7 +264,7 @@ fn decl_cdecl_fn(ModuleRef llmod, str name,\n }\n \n fn decl_glue(ModuleRef llmod, str s) -> ValueRef {\n-    ret decl_cdecl_fn(llmod, s, vec(T_taskptr()), T_nil());\n+    ret decl_cdecl_fn(llmod, s, vec(T_taskptr()), T_void());\n }\n \n fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n@@ -263,7 +294,7 @@ fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n     ret f;\n }\n \n-fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n+fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n     let int n = _vec.len[ValueRef](args) as int;\n     let ValueRef llupcall = get_upcall(cx.fcx.tcx, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n@@ -281,171 +312,239 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n      log \"emitting call to llglue of type: \" + val_str(llglue);\n     */\n \n-    ret cx.build.Call(llglue, call_args);\n+    ret res(cx, cx.build.Call(llglue, call_args));\n }\n \n-fn build_non_gc_free(@block_ctxt cx, ValueRef v) {\n-    trans_upcall(cx, \"upcall_free\", vec(cx.build.PtrToInt(v, T_int()),\n-                                        C_int(0)));\n+fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n+    ret trans_upcall(cx, \"upcall_free\", vec(cx.build.PtrToInt(v, T_int()),\n+                                            C_int(0)));\n }\n \n fn decr_refcnt_and_if_zero(@block_ctxt cx,\n                            ValueRef box_ptr,\n-                           fn(@block_ctxt cx) inner) -> @block_ctxt {\n+                           fn(@block_ctxt cx) -> result inner,\n+                           TypeRef t_else, ValueRef v_else) -> result {\n     auto rc_ptr = cx.build.GEP(box_ptr, vec(C_int(0),\n                                             C_int(abi.box_rc_field_refcnt)));\n     auto rc = cx.build.Load(rc_ptr);\n     rc = cx.build.Sub(rc, C_int(1));\n     cx.build.Store(rc, rc_ptr);\n     auto test = cx.build.ICmp(lib.llvm.LLVMIntEQ, C_int(0), rc);\n-    auto next_cx = new_block_ctxt(cx.fcx, cx.term);\n-    // We terminate the then-block ourselves here with a Br, so\n-    // the terminator we pass in to the inner call is the no-op.\n-    auto then_term = terminate_no_op;\n-    auto then_cx = new_block_ctxt(cx.fcx, then_term);\n-    inner(then_cx);\n-    then_cx.build.Br(next_cx.llbb);\n-    cx.build.CondBr(test, then_cx.llbb, next_cx.llbb);\n-    ret next_cx;\n+    auto next_cx = new_extension_block_ctxt(cx);\n+    auto then_cx = new_empty_block_ctxt(cx.fcx);\n+    auto then_res = inner(then_cx);\n+    then_res.bcx.build.Br(next_cx.llbb);\n+    cx.build.CondBr(test, then_res.bcx.llbb, next_cx.llbb);\n+    auto phi = next_cx.build.Phi(t_else,\n+                                 vec(v_else, then_res.val),\n+                                 vec(cx.llbb, then_res.bcx.llbb));\n+    ret res(next_cx, phi);\n }\n \n-fn drop_str(@block_ctxt cx, ValueRef v) -> @block_ctxt {\n-    ret decr_refcnt_and_if_zero(cx, v, bind build_non_gc_free(_, v));\n+fn trans_drop_str(@block_ctxt cx, ValueRef v) -> result {\n+    ret decr_refcnt_and_if_zero(cx, v,\n+                                bind trans_non_gc_free(_, v),\n+                                T_int(), C_int(0));\n }\n \n-fn trans_lit(@block_ctxt cx, &ast.lit lit) -> ValueRef {\n+fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n     alt (lit) {\n         case (ast.lit_int(?i)) {\n-            ret C_int(i);\n+            ret res(cx, C_int(i));\n         }\n         case (ast.lit_uint(?u)) {\n-            ret C_int(u as int);\n+            ret res(cx, C_int(u as int));\n         }\n         case (ast.lit_char(?c)) {\n-            ret C_integral(c as int, T_i32());\n+            ret res(cx, C_integral(c as int, T_i32()));\n         }\n         case (ast.lit_bool(?b)) {\n-            ret C_bool(b);\n+            ret res(cx, C_bool(b));\n+        }\n+        case (ast.lit_nil) {\n+            ret res(cx, C_nil());\n         }\n         case (ast.lit_str(?s)) {\n             auto len = (_str.byte_len(s) as int) + 1;\n-            auto v = trans_upcall(cx, \"upcall_new_str\",\n-                                  vec(p2i(C_str(cx.fcx.tcx, s)),\n-                                      C_int(len)));\n-            v = cx.build.IntToPtr(v, T_ptr(T_str(len as uint)));\n-            cx.cleanups += vec(clean(bind drop_str(_, v)));\n-            ret v;\n+            auto sub = trans_upcall(cx, \"upcall_new_str\",\n+                                    vec(p2i(C_str(cx.fcx.tcx, s)),\n+                                        C_int(len)));\n+            sub.val = sub.bcx.build.IntToPtr(sub.val,\n+                                             T_ptr(T_str(len as uint)));\n+            cx.cleanups += vec(clean(bind trans_drop_str(_, sub.val)));\n+            ret sub;\n         }\n     }\n }\n \n-fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> ValueRef {\n+fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> result {\n+\n+    auto sub = trans_expr(cx, e);\n+\n     alt (op) {\n         case (ast.bitnot) {\n-            ret cx.build.Not(trans_expr(cx, e));\n+            sub.val = cx.build.Not(sub.val);\n+            ret sub;\n         }\n         case (ast.not) {\n-            ret cx.build.Not(trans_expr(cx, e));\n+            sub.val = cx.build.Not(sub.val);\n+            ret sub;\n         }\n         case (ast.neg) {\n             // FIXME: switch by signedness.\n-            ret cx.build.Neg(trans_expr(cx, e));\n+            sub.val = cx.build.Neg(sub.val);\n+            ret sub;\n         }\n-\n     }\n     cx.fcx.tcx.sess.unimpl(\"expr variant in trans_unary\");\n     fail;\n }\n \n fn trans_binary(@block_ctxt cx, ast.binop op,\n-                &ast.expr a, &ast.expr b) -> ValueRef {\n+                &ast.expr a, &ast.expr b) -> result {\n+\n+    auto lhs = trans_expr(cx, a);\n+    auto sub = trans_expr(lhs.bcx, b);\n+\n     alt (op) {\n         case (ast.add) {\n-            ret cx.build.Add(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Add(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.sub) {\n-            ret cx.build.Sub(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Sub(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.mul) {\n             // FIXME: switch by signedness.\n-            ret cx.build.Mul(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Mul(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.div) {\n             // FIXME: switch by signedness.\n-            ret cx.build.SDiv(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.SDiv(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.rem) {\n             // FIXME: switch by signedness.\n-            ret cx.build.SRem(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.SRem(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.bitor) {\n-            ret cx.build.Or(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Or(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.bitand) {\n-            ret cx.build.And(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.And(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.bitxor) {\n-            ret cx.build.Xor(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Xor(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.lsl) {\n-            ret cx.build.Shl(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.Shl(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.lsr) {\n-            ret cx.build.LShr(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.LShr(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.asr) {\n-            ret cx.build.AShr(trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.AShr(lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.eq) {\n-            ret cx.build.ICmp(lib.llvm.LLVMIntEQ,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntEQ, lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.ne) {\n-            ret cx.build.ICmp(lib.llvm.LLVMIntNE,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntNE, lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.lt) {\n             // FIXME: switch by signedness.\n-            ret cx.build.ICmp(lib.llvm.LLVMIntSLT,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSLT, lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.le) {\n             // FIXME: switch by signedness.\n-            ret cx.build.ICmp(lib.llvm.LLVMIntSLE,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSLE, lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.ge) {\n             // FIXME: switch by signedness.\n-            ret cx.build.ICmp(lib.llvm.LLVMIntSGE,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSGE, lhs.val, sub.val);\n+            ret sub;\n         }\n \n         case (ast.gt) {\n             // FIXME: switch by signedness.\n-            ret cx.build.ICmp(lib.llvm.LLVMIntSGT,\n-                              trans_expr(cx, a), trans_expr(cx, b));\n+            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSGT, lhs.val, sub.val);\n+            ret sub;\n         }\n     }\n     cx.fcx.tcx.sess.unimpl(\"expr variant in trans_binary\");\n     fail;\n }\n \n-fn trans_expr(@block_ctxt cx, &ast.expr e) -> ValueRef {\n+fn trans_if(@block_ctxt cx, &ast.expr cond,\n+            &ast.block thn, &option[ast.block] els) -> result {\n+\n+    auto cond_res = trans_expr(cx, cond);\n+\n+    auto then_cx = new_empty_block_ctxt(cx.fcx);\n+    auto then_res = trans_block(then_cx, thn);\n+\n+    auto next_cx = new_extension_block_ctxt(cx);\n+    then_res.bcx.build.Br(next_cx.llbb);\n+    auto phi;\n+\n+    alt (els) {\n+        case (some[ast.block](?eblk)) {\n+            auto else_cx = new_empty_block_ctxt(cx.fcx);\n+            auto else_res = trans_block(else_cx, eblk);\n+            cond_res.bcx.build.CondBr(cond_res.val,\n+                                      then_cx.llbb,\n+                                      else_cx.llbb);\n+            else_res.bcx.build.Br(next_cx.llbb);\n+            phi = next_cx.build.Phi(T_nil(),\n+                                    vec(then_res.val,\n+                                        else_res.val),\n+                                    vec(then_res.bcx.llbb,\n+                                        else_res.bcx.llbb));\n+        }\n+\n+        case (_) {\n+            cond_res.bcx.build.CondBr(cond_res.val,\n+                                      then_cx.llbb,\n+                                      next_cx.llbb);\n+            phi = next_cx.build.Phi(T_nil(),\n+                                    vec(then_res.val, C_nil()),\n+                                    vec(then_res.bcx.llbb,\n+                                        cond_res.bcx.llbb));\n+        }\n+    }\n+\n+    ret res(next_cx, phi);\n+}\n+\n+fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e) {\n         case (ast.expr_lit(?lit)) {\n             ret trans_lit(cx, *lit);\n@@ -458,54 +557,70 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> ValueRef {\n         case (ast.expr_binary(?op, ?x, ?y)) {\n             ret trans_binary(cx, op, *x, *y);\n         }\n+\n+        case (ast.expr_if(?cond, ?thn, ?els)) {\n+            ret trans_if(cx, *cond, thn, els);\n+        }\n+\n+        case (ast.expr_block(?blk)) {\n+            auto sub_cx = new_empty_block_ctxt(cx.fcx);\n+            auto next_cx = new_extension_block_ctxt(cx);\n+            auto sub = trans_block(sub_cx, blk);\n+\n+            cx.build.Br(sub_cx.llbb);\n+            sub.bcx.build.Br(next_cx.llbb);\n+\n+            ret res(next_cx, sub.val);\n+        }\n     }\n     cx.fcx.tcx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n }\n \n-fn trans_log(@block_ctxt cx, &ast.expr e) {\n+fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e) {\n         case (ast.expr_lit(?lit)) {\n             alt (*lit) {\n                 case (ast.lit_str(_)) {\n-                    auto v = trans_expr(cx, e);\n-                    trans_upcall(cx, \"upcall_log_str\",\n-                                 vec(cx.build.PtrToInt(v, T_int())));\n+                    auto sub = trans_expr(cx, e);\n+                    auto v = sub.bcx.build.PtrToInt(sub.val, T_int());\n+                    ret trans_upcall(sub.bcx,\n+                                     \"upcall_log_str\",\n+                                     vec(v));\n                 }\n+\n                 case (_) {\n-                    auto v = trans_expr(cx, e);\n-                    trans_upcall(cx, \"upcall_log_int\", vec(v));\n+                    auto sub = trans_expr(cx, e);\n+                    ret trans_upcall(sub.bcx,\n+                                     \"upcall_log_int\",\n+                                     vec(sub.val));\n                 }\n             }\n         }\n+\n         case (_) {\n-            auto v = trans_expr(cx, e);\n-            trans_upcall(cx, \"upcall_log_int\", vec(v));\n+            auto sub = trans_expr(cx, e);\n+            ret trans_upcall(sub.bcx, \"upcall_log_int\", vec(sub.val));\n         }\n     }\n }\n \n-fn trans_stmt(@block_ctxt cx, &ast.stmt s) {\n+fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n+    auto sub = res(cx, C_nil());\n     alt (s) {\n         case (ast.stmt_log(?a)) {\n-            trans_log(cx, *a);\n+            sub.bcx = trans_log(cx, *a).bcx;\n+        }\n+\n+        case (ast.stmt_expr(?e)) {\n+            sub.bcx = trans_expr(cx, *e).bcx;\n         }\n+\n         case (_) {\n             cx.fcx.tcx.sess.unimpl(\"stmt variant\");\n         }\n     }\n-}\n-\n-fn terminate_ret_void(@fn_ctxt cx, builder build) {\n-    build.RetVoid();\n-}\n-\n-\n-fn terminate_branch_to(@fn_ctxt cx, builder build, BasicBlockRef bb) {\n-    build.Br(bb);\n-}\n-\n-fn terminate_no_op(@fn_ctxt cx, builder build) {\n+    ret sub;\n }\n \n fn new_builder(BasicBlockRef llbb) -> builder {\n@@ -514,32 +629,72 @@ fn new_builder(BasicBlockRef llbb) -> builder {\n     ret builder(llbuild);\n }\n \n-fn new_block_ctxt(@fn_ctxt cx, terminator term) -> @block_ctxt {\n+// You probably don't want to use this one. See the\n+// next three functions instead.\n+fn new_block_ctxt(@fn_ctxt cx, terminator term,\n+                  vec[cleanup] cleanups) -> @block_ctxt {\n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(cx.llfn, _str.buf(\"\"));\n-    let vec[cleanup] cleanups = vec();\n     ret @rec(llbb=llbb,\n              build=new_builder(llbb),\n              term=term,\n              mutable cleanups=cleanups,\n              fcx=cx);\n }\n \n-fn trans_block(@fn_ctxt cx, &ast.block b, terminator term) {\n-    auto bcx = (new_block_ctxt(cx, term));\n-    for (@ast.stmt s in b) {\n-        trans_stmt(bcx, *s);\n+// Use this when you are making a block_ctxt to replace the\n+// current one, i.e. when chaining together sequences of stmts\n+// or making sub-blocks you will branch back out of and wish to\n+// \"carry on\" in the parent block's context.\n+fn new_extension_block_ctxt(@block_ctxt bcx) -> @block_ctxt {\n+    ret new_block_ctxt(bcx.fcx, bcx.term, bcx.cleanups);\n+}\n+\n+// Use this when you're at the top block of a function or the like.\n+fn new_top_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n+    fn terminate_ret_void(@fn_ctxt cx, builder build) {\n+        build.RetVoid();\n+    }\n+    auto term = terminate_ret_void;\n+    let vec[cleanup] cleanups = vec();\n+    ret new_block_ctxt(fcx, term, cleanups);\n+\n+}\n+\n+// Use this when you are making a block_ctxt to replace the\n+// current one, i.e. when chaining together sequences of stmts\n+// or making sub-blocks you will branch back out of and wish to\n+// \"carry on\" in the parent block's context.\n+fn new_empty_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n+    fn terminate_no_op(@fn_ctxt cx, builder build) {\n     }\n+    auto term = terminate_no_op;\n+    let vec[cleanup] cleanups = vec();\n+    ret new_block_ctxt(fcx, term, cleanups);\n+}\n \n-    for (cleanup c in bcx.cleanups) {\n+fn trans_block_cleanups(@block_ctxt cx) -> @block_ctxt {\n+    auto bcx = cx;\n+    for (cleanup c in cx.cleanups) {\n         alt (c) {\n             case (clean(?cfn)) {\n-                bcx = cfn(bcx);\n+                bcx = cfn(bcx).bcx;\n             }\n         }\n     }\n+    ret bcx;\n+}\n+\n+fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n+    auto bcx = cx;\n+\n+    for (@ast.stmt s in b) {\n+        bcx = trans_stmt(bcx, *s).bcx;\n+    }\n \n-    bcx.term(cx, bcx.build);\n+    bcx = trans_block_cleanups(bcx);\n+    bcx.term(bcx.fcx, bcx.build);\n+    ret res(bcx, C_nil());\n }\n \n fn new_fn_ctxt(@trans_ctxt cx,\n@@ -550,7 +705,7 @@ fn new_fn_ctxt(@trans_ctxt cx,\n                                 T_taskptr()   // taskptr\n                                 );\n     args += T_explicit_args;\n-    let ValueRef llfn = decl_cdecl_fn(cx.llmod, name, args, T_nil());\n+    let ValueRef llfn = decl_cdecl_fn(cx.llmod, name, args, T_void());\n     cx.fns.insert(cx.path, llfn);\n     let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 1u);\n@@ -565,9 +720,8 @@ fn trans_fn(@trans_ctxt cx, &ast._fn f) {\n     let vec[TypeRef] args = vec();\n \n     auto fcx = new_fn_ctxt(cx, cx.path, out, args);\n-    auto term = terminate_ret_void;\n \n-    trans_block(fcx, f.body, term);\n+    trans_block(new_top_block_ctxt(fcx), f.body);\n }\n \n fn trans_item(@trans_ctxt cx, &str name, &ast.item item) {\n@@ -596,7 +750,6 @@ fn p2i(ValueRef v) -> ValueRef {\n fn trans_exit_task_glue(@trans_ctxt cx) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();\n-    auto term = terminate_ret_void;\n \n     auto llfn = cx.glues.exit_task_glue;\n     let ValueRef lloutptr = C_null(T_int());\n@@ -606,7 +759,7 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n                     lltaskptr=lltaskptr,\n                     tcx=cx);\n \n-    auto bcx = new_block_ctxt(fcx, term);\n+    auto bcx = new_top_block_ctxt(fcx);\n     trans_upcall(bcx, \"upcall_exit\", V_args);\n     bcx.term(fcx, bcx.build);\n }\n@@ -705,7 +858,7 @@ fn trans_crate(session.session sess, ast.crate crate) {\n                        */\n                       exit_task_glue =\n                       decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n-                                    vec(T_taskptr()), T_nil()),\n+                                    vec(T_taskptr()), T_void()),\n \n                       upcall_glues =\n                       _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),"}, {"sha": "7b0ffd5b86b4df9d065e74a478c8ec90029e88f2", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e4b2d63aef1e6cb572acfa327ea2c3a36083e8/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=44e4b2d63aef1e6cb572acfa327ea2c3a36083e8", "patch": "@@ -4,6 +4,14 @@ import std._int;\n type pos = rec(uint line, uint col);\n type span = rec(str filename, pos lo, pos hi);\n \n+// FIXME: import std.util.option and use it here.\n+// import std.util.option;\n+\n+tag option[T] {\n+  none;\n+  some(T);\n+}\n+\n tag ty_mach {\n     ty_i8;\n     ty_i16;"}]}