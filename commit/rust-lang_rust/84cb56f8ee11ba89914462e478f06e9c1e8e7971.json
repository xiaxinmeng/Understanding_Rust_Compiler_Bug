{"sha": "84cb56f8ee11ba89914462e478f06e9c1e8e7971", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0Y2I1NmY4ZWUxMWJhODk5MTQ0NjJlNDc4ZjA2ZTljMWU4ZTc5NzE=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-04-28T23:39:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:49:25Z"}, "message": "Add back in a 'old school' error format", "tree": {"sha": "22419ea6949d9db864af11e5e8edd417fd49b992", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22419ea6949d9db864af11e5e8edd417fd49b992"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84cb56f8ee11ba89914462e478f06e9c1e8e7971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84cb56f8ee11ba89914462e478f06e9c1e8e7971", "html_url": "https://github.com/rust-lang/rust/commit/84cb56f8ee11ba89914462e478f06e9c1e8e7971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84cb56f8ee11ba89914462e478f06e9c1e8e7971/comments", "author": null, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49dfac487267b574c802e0bdf5a66c5ff0624340", "url": "https://api.github.com/repos/rust-lang/rust/commits/49dfac487267b574c802e0bdf5a66c5ff0624340", "html_url": "https://github.com/rust-lang/rust/commit/49dfac487267b574c802e0bdf5a66c5ff0624340"}], "stats": {"total": 251, "additions": 201, "deletions": 50}, "files": [{"sha": "7f4d1a9dc349a9e910930e372a2a0403cbdeefd4", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 97, "deletions": 19, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/84cb56f8ee11ba89914462e478f06e9c1e8e7971/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cb56f8ee11ba89914462e478f06e9c1e8e7971/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=84cb56f8ee11ba89914462e478f06e9c1e8e7971", "patch": "@@ -135,6 +135,9 @@ pub struct EmitterWriter {\n     /// Is this the first error emitted thus far? If not, we emit a\n     /// `\\n` before the top-level errors.\n     first: bool,\n+\n+    // For now, allow an old-school mode while we transition\n+    old_school: bool,\n }\n \n impl CoreEmitter for EmitterWriter {\n@@ -170,22 +173,39 @@ impl EmitterWriter {\n                   registry: Option<diagnostics::registry::Registry>,\n                   code_map: Rc<codemap::CodeMap>)\n                   -> EmitterWriter {\n+        let old_school = match ::std::env::var(\"RUST_NEW_ERROR_FORMAT\") {\n+            Ok(_) => false,\n+            Err(_) => true,\n+        };\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n-            EmitterWriter { dst: dst, registry: registry, cm: code_map, first: true }\n+            EmitterWriter { dst: dst,\n+                            registry: registry,\n+                            cm: code_map,\n+                            first: true,\n+                            old_school: old_school }\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n                             registry: registry,\n                             cm: code_map,\n-                            first: true }\n+                            first: true,\n+                            old_school: old_school }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<diagnostics::registry::Registry>,\n                code_map: Rc<codemap::CodeMap>)\n                -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map, first: true }\n+        let old_school = match ::std::env::var(\"RUST_NEW_ERROR_FORMAT\") {\n+            Ok(_) => false,\n+            Err(_) => true,\n+        };\n+        EmitterWriter { dst: Raw(dst),\n+                        registry: registry,\n+                        cm: code_map,\n+                        first: true,\n+                        old_school: old_school }\n     }\n \n     fn emit_message_(&mut self,\n@@ -199,7 +219,9 @@ impl EmitterWriter {\n             if self.first {\n                 self.first = false;\n             } else {\n-                write!(self.dst, \"\\n\")?;\n+                if !self.old_school {\n+                    write!(self.dst, \"\\n\")?;\n+                }\n             }\n         }\n \n@@ -208,7 +230,17 @@ impl EmitterWriter {\n                                        .and_then(|registry| registry.find_description(code))\n                                        .is_some() => {\n                 let code_with_explain = String::from(\"--explain \") + code;\n-                print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+                if self.old_school {\n+                    let loc = match rsp.span().primary_span() {\n+                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+                        Some(ps) => self.cm.span_to_string(ps),\n+                        None => \"\".to_string()\n+                    };\n+                    print_diagnostic(&mut self.dst, &loc, lvl, msg, Some(code))?\n+                }\n+                else {\n+                    print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+                }\n             }\n             _ => {\n                 print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n@@ -239,7 +271,24 @@ impl EmitterWriter {\n                 }\n             }\n         }\n-\n+        if self.old_school {\n+            match code {\n+                Some(code) if self.registry.as_ref()\n+                                        .and_then(|registry| registry.find_description(code))\n+                                        .is_some() => {\n+                    let loc = match rsp.span().primary_span() {\n+                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+                        Some(ps) => self.cm.span_to_string(ps),\n+                        None => \"\".to_string()\n+                    };\n+                    let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n+                        \"` to see a detailed explanation\";\n+                    print_diagnostic(&mut self.dst, &loc, Level::Help, &msg,\n+                        None)?\n+                }\n+                _ => ()\n+            }\n+        }\n         Ok(())\n     }\n \n@@ -282,19 +331,48 @@ impl EmitterWriter {\n     {\n         let mut snippet_data = SnippetData::new(self.cm.clone(),\n                                                 msp.primary_span());\n-        for span_label in msp.span_labels() {\n-            snippet_data.push(span_label.span,\n-                              span_label.is_primary,\n-                              span_label.label);\n+        if self.old_school {\n+            let mut output_vec = vec![];\n+            for span_label in msp.span_labels() {\n+                let mut snippet_data = snippet_data.clone();\n+                snippet_data.push(span_label.span,\n+                                  span_label.is_primary,\n+                                  span_label.label);\n+                if span_label.is_primary {\n+                    output_vec.insert(0, snippet_data);\n+                }\n+                else {\n+                    output_vec.push(snippet_data);\n+                }\n+            }\n+\n+            for snippet_data in output_vec.iter() {\n+                let rendered_lines = snippet_data.render_lines();\n+                for rendered_line in &rendered_lines {\n+                    for styled_string in &rendered_line.text {\n+                        self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n+                        write!(&mut self.dst, \"{}\", styled_string.text)?;\n+                        self.dst.reset_attrs()?;\n+                    }\n+                    write!(&mut self.dst, \"\\n\")?;\n+                }\n+            }\n         }\n-        let rendered_lines = snippet_data.render_lines();\n-        for rendered_line in &rendered_lines {\n-            for styled_string in &rendered_line.text {\n-                self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                self.dst.reset_attrs()?;\n+        else {\n+            for span_label in msp.span_labels() {\n+                snippet_data.push(span_label.span,\n+                                  span_label.is_primary,\n+                                  span_label.label);\n+            }\n+            let rendered_lines = snippet_data.render_lines();\n+            for rendered_line in &rendered_lines {\n+                for styled_string in &rendered_line.text {\n+                    self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n+                    write!(&mut self.dst, \"{}\", styled_string.text)?;\n+                    self.dst.reset_attrs()?;\n+                }\n+                write!(&mut self.dst, \"\\n\")?;\n             }\n-            write!(&mut self.dst, \"\\n\")?;\n         }\n         Ok(())\n     }\n@@ -327,15 +405,13 @@ fn line_num_max_digits(line: &codemap::LineInfo) -> usize {\n     digits\n }\n \n-\n fn print_diagnostic(dst: &mut Destination,\n                     topic: &str,\n                     lvl: Level,\n                     msg: &str,\n                     code: Option<&str>)\n                     -> io::Result<()> {\n     if !topic.is_empty() {\n-        dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n         write!(dst, \"{}: \", topic)?;\n         dst.reset_attrs()?;\n     }\n@@ -346,10 +422,12 @@ fn print_diagnostic(dst: &mut Destination,\n     write!(dst, \": \")?;\n     dst.start_attr(term::Attr::Bold)?;\n     write!(dst, \"{}\", msg)?;\n+\n     if let Some(code) = code {\n         let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n         print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n     }\n+\n     dst.reset_attrs()?;\n     write!(dst, \"\\n\")?;\n     Ok(())"}, {"sha": "18a64cc399c42c7a6a2f03056d173fe0129e8d06", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "modified", "additions": 104, "deletions": 31, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/84cb56f8ee11ba89914462e478f06e9c1e8e7971/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cb56f8ee11ba89914462e478f06e9c1e8e7971/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=84cb56f8ee11ba89914462e478f06e9c1e8e7971", "patch": "@@ -17,11 +17,13 @@ use std::mem;\n \n mod test;\n \n+#[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMap>,\n     files: Vec<FileInfo>,\n }\n \n+#[derive(Clone)]\n pub struct FileInfo {\n     file: Rc<FileMap>,\n \n@@ -35,6 +37,7 @@ pub struct FileInfo {\n     lines: Vec<Line>,\n }\n \n+#[derive(Clone)]\n struct Line {\n     line_index: usize,\n     annotations: Vec<Annotation>,\n@@ -429,35 +432,41 @@ impl FileInfo {\n     }\n \n     fn render_file_lines(&self, codemap: &Rc<CodeMap>) -> Vec<RenderedLine> {\n+        let old_school = match ::std::env::var(\"RUST_NEW_ERROR_FORMAT\") {\n+            Ok(_) => false,\n+            Err(_) => true,\n+        };\n         // As a first step, we elide any instance of more than one\n         // continuous unannotated line.\n \n         let mut lines_iter = self.lines.iter();\n         let mut output = vec![];\n \n         // First insert the name of the file.\n-        match self.primary_span {\n-            Some(span) => {\n-                let lo = codemap.lookup_char_pos(span.lo);\n-                output.push(RenderedLine {\n-                    text: vec![StyledString {\n-                        text: lo.file.name.clone(),\n-                        style: Style::FileNameStyle,\n-                    }, StyledString {\n-                        text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n-                        style: Style::LineAndColumn,\n-                    }],\n-                    kind: RenderedLineKind::PrimaryFileName,\n-                });\n-            }\n-            None => {\n-                output.push(RenderedLine {\n-                    text: vec![StyledString {\n-                        text: self.file.name.clone(),\n-                        style: Style::FileNameStyle,\n-                    }],\n-                    kind: RenderedLineKind::OtherFileName,\n-                });\n+        if !old_school {\n+            match self.primary_span {\n+                Some(span) => {\n+                    let lo = codemap.lookup_char_pos(span.lo);\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: lo.file.name.clone(),\n+                            style: Style::FileNameStyle,\n+                        }, StyledString {\n+                            text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n+                            style: Style::LineAndColumn,\n+                        }],\n+                        kind: RenderedLineKind::PrimaryFileName,\n+                    });\n+                }\n+                None => {\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: self.file.name.clone(),\n+                            style: Style::FileNameStyle,\n+                        }],\n+                        kind: RenderedLineKind::OtherFileName,\n+                    });\n+                }\n             }\n         }\n \n@@ -466,7 +475,31 @@ impl FileInfo {\n             // Consume lines with annotations.\n             while let Some(line) = next_line {\n                 if line.annotations.is_empty() { break; }\n-                output.append(&mut self.render_line(line));\n+\n+                let mut rendered_line = self.render_line(line);\n+                if old_school {\n+                    match self.primary_span {\n+                        Some(span) => {\n+                            let lo = codemap.lookup_char_pos(span.lo);\n+                            rendered_line[0].text.insert(0, StyledString {\n+                                text: format!(\":{} \", lo.line),\n+                                style: Style::LineAndColumn,\n+                            });\n+                            rendered_line[0].text.insert(0, StyledString {\n+                                text: lo.file.name.clone(),\n+                                style: Style::FileNameStyle,\n+                            });\n+                            let gap_amount = rendered_line[0].text[0].text.len() +\n+                                rendered_line[0].text[1].text.len();\n+                            rendered_line[1].text.insert(0, StyledString {\n+                                text: vec![\" \"; gap_amount].join(\"\"),\n+                                style: Style::NoStyle\n+                            });\n+                        }\n+                        _ =>()\n+                    }\n+                }\n+                output.append(&mut rendered_line);\n                 next_line = lines_iter.next();\n             }\n \n@@ -492,6 +525,10 @@ impl FileInfo {\n     }\n \n     fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n+        let old_school = match ::std::env::var(\"RUST_NEW_ERROR_FORMAT\") {\n+            Ok(_) => false,\n+            Err(_) => true,\n+        };\n         let source_string = self.file.get_line(line.line_index)\n                                      .unwrap_or(\"\");\n         let source_kind = RenderedLineKind::SourceText {\n@@ -535,12 +572,34 @@ impl FileInfo {\n \n         // Next, create the highlight line.\n         for annotation in &annotations {\n-            for p in annotation.start_col .. annotation.end_col {\n-                if annotation.is_primary {\n-                    styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n-                    styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n-                } else {\n-                    styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n+            if old_school {\n+                for p in annotation.start_col .. annotation.end_col {\n+                    if p == annotation.start_col {\n+                        styled_buffer.putc(1, p, '^',\n+                            if annotation.is_primary {\n+                                Style::UnderlinePrimary\n+                            } else {\n+                                Style::UnderlineSecondary\n+                            });\n+                    }\n+                    else {\n+                        styled_buffer.putc(1, p, '~',\n+                            if annotation.is_primary {\n+                                Style::UnderlinePrimary\n+                            } else {\n+                                Style::UnderlineSecondary\n+                            });\n+                    }\n+                }\n+            }\n+            else {\n+                for p in annotation.start_col .. annotation.end_col {\n+                    if annotation.is_primary {\n+                        styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n+                        styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n+                    } else {\n+                        styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n+                    }\n                 }\n             }\n         }\n@@ -555,6 +614,9 @@ impl FileInfo {\n         if labeled_annotations.is_empty() {\n             return styled_buffer.render(source_kind);\n         }\n+        if old_school {\n+            return styled_buffer.render(source_kind);\n+        }\n \n         // Now add the text labels. We try, when possible, to stick the rightmost\n         // annotation at the end of the highlight line:\n@@ -647,6 +709,14 @@ impl FileInfo {\n }\n \n fn prepend_prefixes(rendered_lines: &mut [RenderedLine]) {\n+    let old_school = match ::std::env::var(\"RUST_NEW_ERROR_FORMAT\") {\n+        Ok(_) => false,\n+        Err(_) => true,\n+    };\n+    if old_school {\n+        return;\n+    }\n+\n     let prefixes: Vec<_> =\n         rendered_lines.iter()\n                       .map(|rl| rl.kind.prefix())\n@@ -686,11 +756,14 @@ fn prepend_prefixes(rendered_lines: &mut [RenderedLine]) {\n                                                   style: Style::LineNumber})\n             }\n             RenderedLineKind::OtherFileName => {\n-                // >>>>> filename\n+                //   ::: filename\n                 // 22 |>\n                 //   ^\n                 //   padding_len\n-                let dashes = (0..padding_len + 2).map(|_| '>')\n+                let dashes = (0..padding_len - 1).map(|_| ' ')\n+                                                 .chain(Some(':'))\n+                                                 .chain(Some(':'))\n+                                                 .chain(Some(':'))\n                                                  .chain(Some(' '));\n                 line.text.insert(0, StyledString {text: dashes.collect(),\n                                                   style: Style::LineNumber})"}]}