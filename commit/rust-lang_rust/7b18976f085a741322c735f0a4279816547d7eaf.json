{"sha": "7b18976f085a741322c735f0a4279816547d7eaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMTg5NzZmMDg1YTc0MTMyMmM3MzVmMGE0Mjc5ODE2NTQ3ZDdlYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T02:46:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-29T23:21:25Z"}, "message": "Remove all usage of @ast::Crate", "tree": {"sha": "e610f211effee055e5bad662a561f67580e62e45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e610f211effee055e5bad662a561f67580e62e45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b18976f085a741322c735f0a4279816547d7eaf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b18976f085a741322c735f0a4279816547d7eaf", "html_url": "https://github.com/rust-lang/rust/commit/7b18976f085a741322c735f0a4279816547d7eaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b18976f085a741322c735f0a4279816547d7eaf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22ef7e72f4c96b7688dad08c498a4389077d033a", "url": "https://api.github.com/repos/rust-lang/rust/commits/22ef7e72f4c96b7688dad08c498a4389077d033a", "html_url": "https://github.com/rust-lang/rust/commit/22ef7e72f4c96b7688dad08c498a4389077d033a"}], "stats": {"total": 399, "additions": 175, "deletions": 224}, "files": [{"sha": "5fe1a5f723352860195e1e7271f934fe5de3826f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -130,8 +130,8 @@ pub enum input {\n }\n \n pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n-    -> @ast::Crate {\n-    time(sess.time_passes(), ~\"parsing\", || {\n+    -> ast::Crate {\n+    time(sess.time_passes(), ~\"parsing\", (), |_| {\n         match *input {\n             file_input(ref file) => {\n                 parse::parse_crate_from_file(&(*file), cfg.clone(), sess.parse_sess)\n@@ -153,11 +153,11 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n /// standard library and prelude.\n pub fn phase_2_configure_and_expand(sess: Session,\n                                     cfg: ast::CrateConfig,\n-                                    mut crate: @ast::Crate) -> @ast::Crate {\n+                                    mut crate: ast::Crate) -> ast::Crate {\n     let time_passes = sess.time_passes();\n \n     *sess.building_library = session::building_library(sess.opts.crate_type,\n-                                                       crate, sess.opts.test);\n+                                                       &crate, sess.opts.test);\n \n \n     // strip before expansion to allow macros to depend on\n@@ -167,29 +167,29 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     //   mod bar { macro_rules! baz!(() => {{}}) }\n     //\n     // baz! should not use this definition unless foo is enabled.\n-    crate = time(time_passes, ~\"std macros injection\", ||\n+    crate = time(time_passes, ~\"std macros injection\", crate, |crate|\n                  syntax::ext::expand::inject_std_macros(sess.parse_sess,\n                                                         cfg.clone(),\n                                                         crate));\n \n-    crate = time(time_passes, ~\"configuration 1\", ||\n+    crate = time(time_passes, ~\"configuration 1\", crate, |crate|\n                  front::config::strip_unconfigured_items(crate));\n \n-    crate = time(time_passes, ~\"expansion\", ||\n+    crate = time(time_passes, ~\"expansion\", crate, |crate|\n                  syntax::ext::expand::expand_crate(sess.parse_sess, cfg.clone(),\n                                                    crate));\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    crate = time(time_passes, ~\"configuration 2\", ||\n+    crate = time(time_passes, ~\"configuration 2\", crate, |crate|\n                  front::config::strip_unconfigured_items(crate));\n \n-    crate = time(time_passes, ~\"maybe building test harness\", ||\n+    crate = time(time_passes, ~\"maybe building test harness\", crate, |crate|\n                  front::test::modify_for_testing(sess, crate));\n \n-    crate = time(time_passes, ~\"std injection\", ||\n+    crate = time(time_passes, ~\"std injection\", crate, |crate|\n                  front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    crate = time(time_passes, ~\"assigning node ids\", ||\n+    crate = time(time_passes, ~\"assigning node ids\", crate, |crate|\n                  front::assign_node_ids::assign_node_ids(sess, crate));\n \n     return crate;\n@@ -207,41 +207,41 @@ pub struct CrateAnalysis {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n-                                   crate: @ast::Crate) -> CrateAnalysis {\n+                                   crate: &ast::Crate) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n \n-    let ast_map = time(time_passes, ~\"ast indexing\", ||\n+    let ast_map = time(time_passes, ~\"ast indexing\", (), |_|\n                        syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-    time(time_passes, ~\"external crate/lib resolution\", ||\n+    time(time_passes, ~\"external crate/lib resolution\", (), |_|\n          creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n                               sess.filesearch,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n                               sess.opts.is_static,\n                               token::get_ident_interner()));\n \n-    let lang_items = time(time_passes, ~\"language item collection\", ||\n+    let lang_items = time(time_passes, ~\"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(crate, sess));\n \n     let middle::resolve::CrateMap {\n         def_map: def_map,\n         exp_map2: exp_map2,\n         trait_map: trait_map\n     } =\n-        time(time_passes, ~\"resolution\", ||\n+        time(time_passes, ~\"resolution\", (), |_|\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-    time(time_passes, ~\"looking for entry point\",\n-         || middle::entry::find_entry_point(sess, crate, ast_map));\n+    time(time_passes, ~\"looking for entry point\", (),\n+         |_| middle::entry::find_entry_point(sess, crate, ast_map));\n \n-    let freevars = time(time_passes, ~\"freevar finding\", ||\n+    let freevars = time(time_passes, ~\"freevar finding\", (), |_|\n                         freevars::annotate_freevars(def_map, crate));\n \n-    let region_map = time(time_passes, ~\"region resolution\", ||\n+    let region_map = time(time_passes, ~\"region resolution\", (), |_|\n                           middle::region::resolve_crate(sess, def_map, crate));\n \n-    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+    let rp_set = time(time_passes, ~\"region parameterization inference\", (), |_|\n                       middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n@@ -252,53 +252,53 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         ty_cx, trait_map, crate);\n \n     // These next two const passes can probably be merged\n-    time(time_passes, ~\"const marking\", ||\n+    time(time_passes, ~\"const marking\", (), |_|\n          middle::const_eval::process_crate(crate, ty_cx));\n \n-    time(time_passes, ~\"const checking\", ||\n+    time(time_passes, ~\"const checking\", (), |_|\n          middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                           method_map, ty_cx));\n \n     let exported_items =\n-        time(time_passes, ~\"privacy checking\", ||\n+        time(time_passes, ~\"privacy checking\", (), |_|\n              middle::privacy::check_crate(ty_cx, &method_map, &exp_map2, crate));\n \n-    time(time_passes, ~\"effect checking\", ||\n+    time(time_passes, ~\"effect checking\", (), |_|\n          middle::effect::check_crate(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"loop checking\", ||\n+    time(time_passes, ~\"loop checking\", (), |_|\n          middle::check_loop::check_crate(ty_cx, crate));\n \n-    time(time_passes, ~\"stack checking\", ||\n+    time(time_passes, ~\"stack checking\", (), |_|\n          middle::stack_check::stack_check_crate(ty_cx, crate));\n \n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n-        time(time_passes, ~\"compute moves\", ||\n+        time(time_passes, ~\"compute moves\", (), |_|\n              middle::moves::compute_moves(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"match checking\", ||\n+    time(time_passes, ~\"match checking\", (), |_|\n          middle::check_match::check_crate(ty_cx, method_map,\n                                           moves_map, crate));\n \n-    time(time_passes, ~\"liveness checking\", ||\n+    time(time_passes, ~\"liveness checking\", (), |_|\n          middle::liveness::check_crate(ty_cx, method_map,\n                                        capture_map, crate));\n \n     let (root_map, write_guard_map) =\n-        time(time_passes, ~\"borrow checking\", ||\n+        time(time_passes, ~\"borrow checking\", (), |_|\n              middle::borrowck::check_crate(ty_cx, method_map,\n                                            moves_map, moved_variables_set,\n                                            capture_map, crate));\n \n-    time(time_passes, ~\"kind checking\", ||\n+    time(time_passes, ~\"kind checking\", (), |_|\n          kind::check_crate(ty_cx, method_map, crate));\n \n     let reachable_map =\n-        time(time_passes, ~\"reachability checking\", ||\n+        time(time_passes, ~\"reachability checking\", (), |_|\n              reachable::find_reachable(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"lint checking\", ||\n+    time(time_passes, ~\"lint checking\", (), |_|\n          lint::check_crate(ty_cx, crate));\n \n     CrateAnalysis {\n@@ -325,10 +325,10 @@ pub struct CrateTranslation {\n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm(sess: Session,\n-                                 crate: @ast::Crate,\n+                                 crate: ast::Crate,\n                                  analysis: &CrateAnalysis,\n                                  outputs: &OutputFilenames) -> CrateTranslation {\n-    time(sess.time_passes(), ~\"translation\", ||\n+    time(sess.time_passes(), ~\"translation\", crate, |crate|\n          trans::base::trans_crate(sess, crate, analysis,\n                                   &outputs.obj_filename))\n }\n@@ -349,7 +349,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n         let output_type = link::output_type_assembly;\n         let asm_filename = outputs.obj_filename.with_filetype(\"s\");\n \n-        time(sess.time_passes(), ~\"LLVM passes\", ||\n+        time(sess.time_passes(), ~\"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n                                     trans.context,\n                                     trans.module,\n@@ -363,7 +363,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n             os::remove_file(&asm_filename);\n         }\n     } else {\n-        time(sess.time_passes(), ~\"LLVM passes\", ||\n+        time(sess.time_passes(), ~\"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n                                     trans.context,\n                                     trans.module,\n@@ -377,7 +377,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n pub fn phase_6_link_output(sess: Session,\n                            trans: &CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    time(sess.time_passes(), ~\"linking\", ||\n+    time(sess.time_passes(), ~\"linking\", (), |_|\n          link::link_binary(sess,\n                            &outputs.obj_filename,\n                            &outputs.out_filename,\n@@ -430,7 +430,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n             if stop_after_phase_1(sess) { return; }\n             phase_2_configure_and_expand(sess, cfg, crate)\n         };\n-        let analysis = phase_3_run_analysis_passes(sess, expanded_crate);\n+        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate);\n         if stop_after_phase_3(sess) { return; }\n         let outputs = build_output_filenames(input, outdir, output, [], sess);\n         let trans = phase_4_translate_to_llvm(sess, expanded_crate,\n@@ -535,7 +535,7 @@ pub fn pretty_print_input(sess: Session,\n             } as @pprust::pp_ann\n         }\n         PpmTyped => {\n-            let analysis = phase_3_run_analysis_passes(sess, crate);\n+            let analysis = phase_3_run_analysis_passes(sess, &crate);\n             @TypedAnnotation {\n                 analysis: analysis\n             } as @pprust::pp_ann\n@@ -548,7 +548,7 @@ pub fn pretty_print_input(sess: Session,\n         pprust::print_crate(sess.codemap,\n                             token::get_ident_interner(),\n                             sess.span_diagnostic,\n-                            crate,\n+                            &crate,\n                             source_name(input),\n                             rdr,\n                             io::stdout(),"}, {"sha": "3d0b32fcee03a0c762ea630b9c6d4983e21efdc5", "filename": "src/librustc/front/assign_node_ids.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -24,9 +24,9 @@ impl ast_fold for NodeIdAssigner {\n     }\n }\n \n-pub fn assign_node_ids(sess: Session, crate: @ast::Crate) -> @ast::Crate {\n+pub fn assign_node_ids(sess: Session, crate: ast::Crate) -> ast::Crate {\n     let fold = NodeIdAssigner {\n         sess: sess,\n     };\n-    @fold.fold_crate(crate)\n+    fold.fold_crate(crate)\n }"}, {"sha": "b99e154853e0eafd62f0af52cb5fb9db4611e83c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -18,9 +18,10 @@ struct Context<'self> {\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(crate: @ast::Crate) -> @ast::Crate {\n+pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n+    let config = crate.config.clone();\n     do strip_items(crate) |attrs| {\n-        in_cfg(crate.config, attrs)\n+        in_cfg(config, attrs)\n     }\n }\n \n@@ -40,13 +41,13 @@ impl<'self> fold::ast_fold for Context<'self> {\n     }\n }\n \n-pub fn strip_items(crate: &ast::Crate,\n+pub fn strip_items(crate: ast::Crate,\n                    in_cfg: &fn(attrs: &[ast::Attribute]) -> bool)\n-                   -> @ast::Crate {\n+                   -> ast::Crate {\n     let ctxt = Context {\n         in_cfg: in_cfg,\n     };\n-    @ctxt.fold_crate(crate)\n+    ctxt.fold_crate(crate)\n }\n \n fn filter_item(cx: &Context, item: @ast::item) -> Option<@ast::item> {"}, {"sha": "2253f151ddf59d7d53c48b1e88a1e13fdce37560", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -22,9 +22,9 @@ use syntax::opt_vec;\n \n static STD_VERSION: &'static str = \"0.9-pre\";\n \n-pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::Crate)\n-                               -> @ast::Crate {\n-    if use_std(crate) {\n+pub fn maybe_inject_libstd_ref(sess: Session, crate: ast::Crate)\n+                               -> ast::Crate {\n+    if use_std(&crate) {\n         inject_libstd_ref(sess, crate)\n     } else {\n         crate\n@@ -51,7 +51,7 @@ struct StandardLibraryInjector {\n }\n \n impl fold::ast_fold for StandardLibraryInjector {\n-    fn fold_crate(&self, crate: &ast::Crate) -> ast::Crate {\n+    fn fold_crate(&self, crate: ast::Crate) -> ast::Crate {\n         let version = STD_VERSION.to_managed();\n         let vi1 = ast::view_item {\n             node: ast::view_item_extern_mod(self.sess.ident_of(\"std\"),\n@@ -77,10 +77,9 @@ impl fold::ast_fold for StandardLibraryInjector {\n             new_module = self.fold_mod(&new_module);\n         }\n \n-        // FIXME #2543: Bad copy.\n         ast::Crate {\n             module: new_module,\n-            ..(*crate).clone()\n+            ..crate\n         }\n     }\n \n@@ -133,9 +132,9 @@ impl fold::ast_fold for StandardLibraryInjector {\n     }\n }\n \n-fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n+fn inject_libstd_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n     let fold = StandardLibraryInjector {\n         sess: sess,\n     };\n-    @fold.fold_crate(crate)\n+    fold.fold_crate(crate)\n }"}, {"sha": "254116bd5077314e1b087e1e340540f2ba68f940", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -37,17 +37,17 @@ struct Test {\n \n struct TestCtxt {\n     sess: session::Session,\n-    crate: @ast::Crate,\n     path: ~[ast::Ident],\n     ext_cx: @ExtCtxt,\n-    testfns: ~[Test]\n+    testfns: ~[Test],\n+    is_extra: bool,\n+    config: ast::CrateConfig,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: session::Session,\n-                          crate: @ast::Crate)\n-                       -> @ast::Crate {\n+                          crate: ast::Crate) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -65,7 +65,7 @@ struct TestHarnessGenerator {\n }\n \n impl fold::ast_fold for TestHarnessGenerator {\n-    fn fold_crate(&self, c: &ast::Crate) -> ast::Crate {\n+    fn fold_crate(&self, c: ast::Crate) -> ast::Crate {\n         let folded = fold::noop_fold_crate(c, self);\n \n         // Add a special __test module to the crate that will contain code\n@@ -141,14 +141,15 @@ impl fold::ast_fold for TestHarnessGenerator {\n     }\n }\n \n-fn generate_test_harness(sess: session::Session, crate: @ast::Crate)\n-                         -> @ast::Crate {\n+fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n+                         -> ast::Crate {\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n-        crate: crate,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: ~[],\n-        testfns: ~[]\n+        testfns: ~[],\n+        is_extra: is_extra(&crate),\n+        config: crate.config.clone(),\n     };\n \n     let ext_cx = cx.ext_cx;\n@@ -163,12 +164,12 @@ fn generate_test_harness(sess: session::Session, crate: @ast::Crate)\n     let fold = TestHarnessGenerator {\n         cx: cx\n     };\n-    let res = @fold.fold_crate(&*crate);\n+    let res = fold.fold_crate(crate);\n     ext_cx.bt_pop();\n     return res;\n }\n \n-fn strip_test_functions(crate: &ast::Crate) -> @ast::Crate {\n+fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {\n@@ -234,7 +235,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     do i.attrs.iter().any |attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n-            Some(ref cfgs) => attr::test_cfg(cx.crate.config, cfgs.iter().map(|x| *x)),\n+            Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n     }\n@@ -273,7 +274,7 @@ mod __test {\n \n fn mk_std(cx: &TestCtxt) -> ast::view_item {\n     let id_extra = cx.sess.ident_of(\"extra\");\n-    let vi = if is_extra(cx) {\n+    let vi = if cx.is_extra {\n         ast::view_item_use(\n             ~[@nospan(ast::view_path_simple(id_extra,\n                                             path_node(~[id_extra]),\n@@ -371,8 +372,8 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     )).unwrap()\n }\n \n-fn is_extra(cx: &TestCtxt) -> bool {\n-    let items = attr::find_linkage_metas(cx.crate.attrs);\n+fn is_extra(crate: &ast::Crate) -> bool {\n+    let items = attr::find_linkage_metas(crate.attrs);\n     match attr::last_meta_item_value_str_by_name(items, \"name\") {\n         Some(s) if \"extra\" == s => true,\n         _ => false"}, {"sha": "1bc4f18cce944e5fd38e4ef22b97a9074db1f6a9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 45, "deletions": 92, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -37,7 +37,6 @@ use syntax::opt_vec::OptVec;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::str;\n use std::uint;\n use std::hashmap::{HashMap, HashSet};\n use std::util;\n@@ -803,23 +802,21 @@ pub fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n \n pub fn Resolver(session: Session,\n                 lang_items: LanguageItems,\n-                crate: @Crate)\n-             -> Resolver {\n+                crate_span: Span) -> Resolver {\n     let graph_root = @mut NameBindings();\n \n     graph_root.define_module(Public,\n                              NoParentLink,\n                              Some(DefId { crate: 0, node: 0 }),\n                              NormalModuleKind,\n                              false,\n-                             crate.span);\n+                             crate_span);\n \n     let current_module = graph_root.get_module();\n \n     let this = Resolver {\n         session: @session,\n         lang_items: lang_items,\n-        crate: crate,\n \n         // The outermost module has def ID 0; this is not reflected in the\n         // AST.\n@@ -862,7 +859,6 @@ pub fn Resolver(session: Session,\n pub struct Resolver {\n     session: @Session,\n     lang_items: LanguageItems,\n-    crate: @Crate,\n \n     intr: @ident_interner,\n \n@@ -959,8 +955,8 @@ impl<'self> Visitor<()> for UnusedImportCheckVisitor<'self> {\n \n impl Resolver {\n     /// The main name resolution procedure.\n-    pub fn resolve(&mut self) {\n-        self.build_reduced_graph();\n+    pub fn resolve(&mut self, crate: &ast::Crate) {\n+        self.build_reduced_graph(crate);\n         self.session.abort_if_errors();\n \n         self.resolve_imports();\n@@ -969,10 +965,10 @@ impl Resolver {\n         self.record_exports();\n         self.session.abort_if_errors();\n \n-        self.resolve_crate();\n+        self.resolve_crate(crate);\n         self.session.abort_if_errors();\n \n-        self.check_for_unused_imports();\n+        self.check_for_unused_imports(crate);\n     }\n \n     //\n@@ -983,12 +979,12 @@ impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(&mut self) {\n+    pub fn build_reduced_graph(&mut self, crate: &ast::Crate) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n \n         let mut visitor = BuildReducedGraphVisitor { resolver: self, };\n-        visit::walk_crate(&mut visitor, self.crate, initial_parent);\n+        visit::walk_crate(&mut visitor, crate, initial_parent);\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n@@ -3554,10 +3550,10 @@ impl Resolver {\n         return None;\n     }\n \n-    pub fn resolve_crate(&mut self) {\n+    pub fn resolve_crate(&mut self, crate: &ast::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit::walk_crate(self, self.crate, ());\n+        visit::walk_crate(self, crate, ());\n     }\n \n     pub fn resolve_item(&mut self, item: @item) {\n@@ -4986,40 +4982,6 @@ impl Resolver {\n         }\n     }\n \n-    pub fn name_exists_in_scope_struct(&mut self, name: &str) -> bool {\n-        let this = &mut *self;\n-\n-        let mut i = this.type_ribs.len();\n-        while i != 0 {\n-          i -= 1;\n-          match this.type_ribs[i].kind {\n-            MethodRibKind(node_id, _) =>\n-              for item in this.crate.module.items.iter() {\n-                if item.id == node_id {\n-                  match item.node {\n-                    item_struct(class_def, _) => {\n-                      for field in class_def.fields.iter() {\n-                        match field.node.kind {\n-                          unnamed_field => {},\n-                          named_field(ident, _) => {\n-                              if str::eq_slice(this.session.str_of(ident),\n-                                               name) {\n-                                return true\n-                              }\n-                            }\n-                        }\n-                      }\n-                    }\n-                    _ => {}\n-                  }\n-                }\n-            },\n-          _ => {}\n-        }\n-      }\n-      return false;\n-    }\n-\n     pub fn resolve_expr(&mut self, expr: @Expr) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -5060,47 +5022,38 @@ impl Resolver {\n                     }\n                     None => {\n                         let wrong_name = self.path_idents_to_str(path);\n-                        if self.name_exists_in_scope_struct(wrong_name) {\n-                            self.resolve_error(expr.span,\n-                                        fmt!(\"unresolved name `%s`. \\\n-                                            Did you mean `self.%s`?\",\n-                                        wrong_name,\n-                                        wrong_name));\n-                        }\n-                        else {\n-                            // Be helpful if the name refers to a struct\n-                            // (The pattern matching def_tys where the id is in self.structs\n-                            // matches on regular structs while excluding tuple- and enum-like\n-                            // structs, which wouldn't result in this error.)\n-                            match self.with_no_errors(|this|\n-                                this.resolve_path(expr.id, path, TypeNS, false)) {\n-                                Some(DefTy(struct_id))\n-                                  if self.structs.contains(&struct_id) => {\n-                                    self.resolve_error(expr.span,\n-                                            fmt!(\"`%s` is a structure name, but this expression \\\n-                                                uses it like a function name\", wrong_name));\n-\n-                                    self.session.span_note(expr.span, fmt!(\"Did you mean to write: \\\n-                                                `%s { /* fields */ }`?\", wrong_name));\n+                        // Be helpful if the name refers to a struct\n+                        // (The pattern matching def_tys where the id is in self.structs\n+                        // matches on regular structs while excluding tuple- and enum-like\n+                        // structs, which wouldn't result in this error.)\n+                        match self.with_no_errors(|this|\n+                            this.resolve_path(expr.id, path, TypeNS, false)) {\n+                            Some(DefTy(struct_id))\n+                              if self.structs.contains(&struct_id) => {\n+                                self.resolve_error(expr.span,\n+                                        fmt!(\"`%s` is a structure name, but this expression \\\n+                                            uses it like a function name\", wrong_name));\n+\n+                                self.session.span_note(expr.span, fmt!(\"Did you mean to write: \\\n+                                            `%s { /* fields */ }`?\", wrong_name));\n \n-                                }\n-                                _ =>\n-                                   // limit search to 5 to reduce the number\n-                                   // of stupid suggestions\n-                                   match self.find_best_match_for_name(wrong_name, 5) {\n-                                       Some(m) => {\n-                                           self.resolve_error(expr.span,\n-                                               fmt!(\"unresolved name `%s`. \\\n-                                                   Did you mean `%s`?\",\n-                                                   wrong_name, m));\n-                                       }\n-                                       None => {\n-                                           self.resolve_error(expr.span,\n-                                                fmt!(\"unresolved name `%s`.\",\n-                                                    wrong_name));\n-                                       }\n-                                   }\n                             }\n+                            _ =>\n+                               // limit search to 5 to reduce the number\n+                               // of stupid suggestions\n+                               match self.find_best_match_for_name(wrong_name, 5) {\n+                                   Some(m) => {\n+                                       self.resolve_error(expr.span,\n+                                           fmt!(\"unresolved name `%s`. \\\n+                                               Did you mean `%s`?\",\n+                                               wrong_name, m));\n+                                   }\n+                                   None => {\n+                                       self.resolve_error(expr.span,\n+                                            fmt!(\"unresolved name `%s`.\",\n+                                                wrong_name));\n+                                   }\n+                               }\n                         }\n                     }\n                 }\n@@ -5431,9 +5384,9 @@ impl Resolver {\n     // resolve data structures.\n     //\n \n-    pub fn check_for_unused_imports(&self) {\n+    pub fn check_for_unused_imports(&self, crate: &ast::Crate) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, self.crate, ());\n+        visit::walk_crate(&mut visitor, crate, ());\n     }\n \n     pub fn check_for_item_unused_imports(&self, vi: &view_item) {\n@@ -5549,10 +5502,10 @@ pub struct CrateMap {\n /// Entry point to crate resolution.\n pub fn resolve_crate(session: Session,\n                      lang_items: LanguageItems,\n-                     crate: @Crate)\n+                     crate: &Crate)\n                   -> CrateMap {\n-    let mut resolver = Resolver(session, lang_items, crate);\n-    resolver.resolve();\n+    let mut resolver = Resolver(session, lang_items, crate.span);\n+    resolver.resolve(crate);\n     CrateMap {\n         def_map: resolver.def_map,\n         exp_map2: resolver.export_map2,"}, {"sha": "983708183d898eb172ca65396ab4698fec1bf631", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -3075,16 +3075,17 @@ pub fn write_abi_version(ccx: &mut CrateContext) {\n }\n \n pub fn trans_crate(sess: session::Session,\n-                   crate: &ast::Crate,\n+                   crate: ast::Crate,\n                    analysis: &CrateAnalysis,\n                    output: &Path) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     if unsafe { !llvm::LLVMRustStartMultithreading() } {\n-        //sess.bug(\"couldn't enable multi-threaded LLVM\");\n+        sess.bug(\"couldn't enable multi-threaded LLVM\");\n     }\n \n     let mut symbol_hasher = hash::default_state();\n-    let link_meta = link::build_link_meta(sess, crate, output, &mut symbol_hasher);\n+    let link_meta = link::build_link_meta(sess, &crate, output,\n+                                          &mut symbol_hasher);\n \n     // Append \".rc\" to crate name as LLVM module identifier.\n     //\n@@ -3107,7 +3108,7 @@ pub fn trans_crate(sess: session::Session,\n                                      analysis.reachable);\n \n     if ccx.sess.opts.debuginfo {\n-        debuginfo::initialize(ccx, crate);\n+        debuginfo::initialize(ccx, &crate);\n     }\n \n     {\n@@ -3144,7 +3145,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     // Translate the metadata.\n-    write_metadata(ccx, crate);\n+    write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n         io::println(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);"}, {"sha": "fbd3088902fb68b1dfeaad8ef0ec48290f2b944f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -447,17 +447,17 @@ pub fn check_crate(tcx: ty::ctxt,\n         tcx: tcx\n     };\n \n-    time(time_passes, ~\"type collecting\", ||\n+    time(time_passes, ~\"type collecting\", (), |_|\n         collect::collect_item_types(ccx, crate));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n-    time(time_passes, ~\"coherence checking\", ||\n+    time(time_passes, ~\"coherence checking\", (), |_|\n         coherence::check_coherence(ccx, crate));\n \n-    time(time_passes, ~\"type checking\", ||\n+    time(time_passes, ~\"type checking\", (), |_|\n         check::check_item_types(ccx, crate));\n \n     check_for_entry_fn(ccx);"}, {"sha": "3ffbbdd83587d243d55c5def34b9de638a5837f2", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -17,10 +17,10 @@ use syntax::visit::Visitor;\n use std::hashmap::HashSet;\n use extra;\n \n-pub fn time<T>(do_it: bool, what: ~str, thunk: &fn() -> T) -> T {\n-    if !do_it { return thunk(); }\n+pub fn time<T, U>(do_it: bool, what: ~str, u: U, f: &fn(U) -> T) -> T {\n+    if !do_it { return f(u); }\n     let start = extra::time::precise_time_s();\n-    let rv = thunk();\n+    let rv = f(u);\n     let end = extra::time::precise_time_s();\n     println!(\"time: {:3.3f} s\\t{}\", end - start, what);\n     rv"}, {"sha": "ff60241056c3524fc9090754d1790f1f4517cb0e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -24,7 +24,7 @@ use clean;\n use clean::Clean;\n \n pub struct DocContext {\n-    crate: @ast::Crate,\n+    crate: ast::Crate,\n     tycx: middle::ty::ctxt,\n     sess: driver::session::Session\n }\n@@ -60,7 +60,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n \n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = phase_3_run_analysis_passes(sess, crate);\n+    let analysis = phase_3_run_analysis_passes(sess, &crate);\n \n     debug!(\"crate: %?\", crate);\n     DocContext { crate: crate, tycx: analysis.ty_cx, sess: sess }\n@@ -75,7 +75,7 @@ pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n     local_data::set(super::ctxtkey, ctxt);\n \n     let v = @mut RustdocVisitor::new();\n-    v.visit(ctxt.crate);\n+    v.visit(&ctxt.crate);\n \n     v.clean()\n }"}, {"sha": "ebf939c8beabad20c94ee9ba01dd074f22011ef3", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -161,7 +161,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let mut to_run = ~[];       // statements to run (emitted back into code)\n     let new_locals = @mut ~[];  // new locals being defined\n     let mut result = None;      // resultant expression (to print via pp)\n-    do find_main(crate, sess) |blk| {\n+    do find_main(&crate, sess) |blk| {\n         // Fish out all the view items, be sure to record 'extern mod' items\n         // differently beause they must appear before all 'use' statements\n         for vi in blk.view_items.iter() {\n@@ -241,11 +241,11 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n     let crate = driver::phase_1_parse_input(sess, cfg.clone(), &dinput);\n     let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n \n     // Once we're typechecked, record the types of all local variables defined\n     // in this input\n-    do find_main(crate, sess) |blk| {\n+    do find_main(&expanded_crate, sess) |blk| {\n         program.register_new_vars(blk, analysis.ty_cx);\n     }\n \n@@ -264,7 +264,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n     let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n     let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n     driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n \n@@ -283,14 +283,14 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     //\n     return (program, jit::consume_engine());\n \n-    fn parse_input(sess: session::Session, input: &str) -> @ast::Crate {\n+    fn parse_input(sess: session::Session, input: &str) -> ast::Crate {\n         let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n         let input = driver::str_input(code.to_managed());\n         let cfg = driver::build_configuration(sess);\n         driver::phase_1_parse_input(sess, cfg.clone(), &input)\n     }\n \n-    fn find_main(crate: @ast::Crate, sess: session::Session,\n+    fn find_main(crate: &ast::Crate, sess: session::Session,\n                  f: &fn(&ast::Block)) {\n         for item in crate.module.items.iter() {\n             match item.node {\n@@ -358,7 +358,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             println(fmt!(\"compiling %s...\", src_filename));\n             let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n             let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-            let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+            let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n             let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n             driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n             true"}, {"sha": "bb1b5c49870d2827037de27deb25daf52bd3ae13", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -85,7 +85,7 @@ struct PkgScript<'self> {\n     /// The config for compiling the custom build script\n     cfg: ast::CrateConfig,\n     /// The crate for the custom build script\n-    crate: @ast::Crate,\n+    crate: Option<ast::Crate>,\n     /// Directory in which to store build output\n     build_dir: Path\n }\n@@ -125,7 +125,7 @@ impl<'self> PkgScript<'self> {\n             input: script,\n             sess: sess,\n             cfg: cfg,\n-            crate: crate,\n+            crate: Some(crate),\n             build_dir: work_dir\n         }\n     }\n@@ -134,12 +134,13 @@ impl<'self> PkgScript<'self> {\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n     /// calling the package script's configs() function if it exists\n-    fn run_custom(&self, exec: &mut workcache::Exec, sysroot: &Path) -> (~[~str], ExitCode) {\n+    fn run_custom(&mut self, exec: &mut workcache::Exec,\n+                  sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n         debug!(\"Working directory = %s\", self.build_dir.to_str());\n         // Collect together any user-defined commands in the package script\n-        let crate = util::ready_crate(sess, self.crate);\n+        let crate = util::ready_crate(sess, self.crate.take_unwrap());\n         debug!(\"Building output filenames with script name %s\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n@@ -419,10 +420,10 @@ impl CtxMethods for BuildContext {\n                     let sub_id = pkgid.clone();\n                     declare_package_script_dependency(prep, &*pkg_src);\n                     do prep.exec |exec| {\n-                        let pscript = PkgScript::parse(@sub_sysroot.clone(),\n-                                                       package_script_path_clone.clone(),\n-                                                       &sub_ws,\n-                                                       &sub_id);\n+                        let mut pscript = PkgScript::parse(@sub_sysroot.clone(),\n+                                                          package_script_path_clone.clone(),\n+                                                          &sub_ws,\n+                                                          &sub_id);\n \n                         pscript.run_custom(exec, &sub_sysroot)\n                     }"}, {"sha": "af80abdac38a6133f1f458e3cc8c5caa7f5a95fa", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -68,7 +68,6 @@ struct ListenerFn {\n \n struct ReadyCtx {\n     sess: session::Session,\n-    crate: @ast::Crate,\n     ext_cx: @ExtCtxt,\n     path: ~[ast::Ident],\n     fns: ~[ListenerFn]\n@@ -151,18 +150,17 @@ impl fold::ast_fold for CrateSetup {\n \n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n-                   crate: @ast::Crate) -> @ast::Crate {\n+                   crate: ast::Crate) -> ast::Crate {\n     let ctx = @mut ReadyCtx {\n         sess: sess,\n-        crate: crate,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: ~[],\n         fns: ~[]\n     };\n     let fold = CrateSetup {\n         ctx: ctx,\n     };\n-    @fold.fold_crate(crate)\n+    fold.fold_crate(crate)\n }\n \n pub fn compile_input(context: &BuildContext,\n@@ -262,7 +260,7 @@ pub fn compile_input(context: &BuildContext,\n     let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n-    find_and_install_dependencies(context, pkg_id, sess, exec, crate,\n+    find_and_install_dependencies(context, pkg_id, sess, exec, &crate,\n                                   |p| {\n                                       debug!(\"a dependency: %s\", p.to_str());\n                                       // Pass the directory containing a dependency\n@@ -289,10 +287,7 @@ pub fn compile_input(context: &BuildContext,\n                                            pkg_id.path.to_str().to_managed())];\n \n         debug!(\"link options: %?\", link_options);\n-        crate = @ast::Crate {\n-            attrs: ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))],\n-            .. (*crate).clone()\n-        }\n+        crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n     }\n \n     debug!(\"calling compile_crate_from_input, workspace = %s,\n@@ -334,7 +329,7 @@ pub fn compile_crate_from_input(input: &Path,\n                                 sess: session::Session,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n-                                crate: @ast::Crate) -> Option<Path> {\n+                                crate: ast::Crate) -> Option<Path> {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            out_dir.to_str(), sess.building_library);\n \n@@ -352,7 +347,7 @@ pub fn compile_crate_from_input(input: &Path,\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n-    let analysis = driver::phase_3_run_analysis_passes(sess, crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }\n     let translation = driver::phase_4_translate_to_llvm(sess, crate,\n                                                         &analysis,"}, {"sha": "0ca4f4fa1cda2653ad4b403ac4d0d8e4a94568bd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -1143,8 +1143,8 @@ impl ast_fold for Injector {\n // program (ick). This should run before cfg stripping.\n pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n                          cfg: ast::CrateConfig,\n-                         c: @Crate)\n-                         -> @Crate {\n+                         c: Crate)\n+                         -> Crate {\n     let sm = match parse_item_from_source_str(@\"<std-macros>\",\n                                               std_macros(),\n                                               cfg.clone(),\n@@ -1157,7 +1157,7 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n     let injector = @Injector {\n         sm: sm,\n     } as @ast_fold;\n-    @injector.fold_crate(c)\n+    injector.fold_crate(c)\n }\n \n struct NoOpFolder {\n@@ -1214,7 +1214,7 @@ impl ast_fold for MacroExpander {\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::CrateConfig,\n-                    c: &Crate) -> @Crate {\n+                    c: Crate) -> Crate {\n     // adding *another* layer of indirection here so that the block\n     // visitor can swap out one exts table for another for the duration\n     // of the block.  The cleaner alternative would be to thread the\n@@ -1227,7 +1227,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n         cx: cx,\n     } as @ast_fold;\n \n-    let ret = @expander.fold_crate(c);\n+    let ret = expander.fold_crate(c);\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n     return ret;\n }\n@@ -1534,7 +1534,7 @@ mod test {\n         let a2_name = gensym(\"a2\");\n         let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n-        let renamed_ast = renamer.fold_crate(item_ast);\n+        let renamed_ast = renamer.fold_crate(item_ast.clone());\n         let varrefs = @mut ~[];\n         visit::walk_crate(&mut new_path_finder(varrefs), &renamed_ast, ());\n         match varrefs {\n@@ -1557,12 +1557,12 @@ mod test {\n         }\n     }\n \n-    fn fake_print_crate(crate: @ast::Crate) {\n+    fn fake_print_crate(crate: &ast::Crate) {\n         let s = pprust::rust_printer(std::io::stderr(),get_ident_interner());\n         pprust::print_crate_(s, crate);\n     }\n \n-    fn expand_crate_str(crate_str: @str) -> @ast::Crate {\n+    fn expand_crate_str(crate_str: @str) -> ast::Crate {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n         // the cfg argument actually does matter, here...\n         expand_crate(ps,~[],crate_ast)\n@@ -1658,10 +1658,10 @@ mod test {\n         let cr = expand_crate_str(teststr.to_managed());\n         // find the bindings:\n         let bindings = @mut ~[];\n-        visit::walk_crate(&mut new_name_finder(bindings),cr,());\n+        visit::walk_crate(&mut new_name_finder(bindings),&cr,());\n         // find the varrefs:\n         let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs),cr,());\n+        visit::walk_crate(&mut new_path_finder(varrefs),&cr,());\n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n@@ -1721,7 +1721,7 @@ foo_module!()\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n         let bindings = @mut ~[];\n-        visit::walk_crate(&mut new_name_finder(bindings), cr, ());\n+        visit::walk_crate(&mut new_name_finder(bindings), &cr, ());\n         let cxbinds : ~[&ast::Ident] =\n             bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n         let cxbind = match cxbinds {\n@@ -1731,7 +1731,7 @@ foo_module!()\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:\n         let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs), cr, ());\n+        visit::walk_crate(&mut new_path_finder(varrefs), &cr, ());\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n                                           && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))"}, {"sha": "b823ff726ac2925c6bf25a1160337a0bf362a9e8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -16,7 +16,7 @@ use opt_vec::OptVec;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n-    fn fold_crate(&self, c: &Crate) -> Crate {\n+    fn fold_crate(&self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n@@ -691,7 +691,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n     }\n }\n \n-pub fn noop_fold_crate<T:ast_fold>(c: &Crate, folder: &T) -> Crate {\n+pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n     let fold_meta_item = |x| fold_meta_item_(x, folder);\n     let fold_attribute = |x| fold_attribute_(x, folder);\n "}, {"sha": "a492a2283e3a3991b3c3a6066aa18cc0951a236c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -73,7 +73,7 @@ pub fn parse_crate_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n-) -> @ast::Crate {\n+) -> ast::Crate {\n     new_parser_from_file(sess, /*bad*/ cfg.clone(), input).parse_crate_mod()\n     // why is there no p.abort_if_errors here?\n }\n@@ -83,7 +83,7 @@ pub fn parse_crate_from_source_str(\n     source: @str,\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n-) -> @ast::Crate {\n+) -> ast::Crate {\n     let p = new_parser_from_source_str(sess,\n                                        /*bad*/ cfg.clone(),\n                                        name,"}, {"sha": "5a68e32a5332c843fe74ed7779ad9c97846e1113", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -5140,7 +5140,7 @@ impl Parser {\n \n     // Parses a source module as a crate. This is the main\n     // entry point for the parser.\n-    pub fn parse_crate_mod(&self) -> @Crate {\n+    pub fn parse_crate_mod(&self) -> Crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one\n         // of the attrs of an item:\n@@ -5149,7 +5149,7 @@ impl Parser {\n         // parse the items inside the crate:\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n-        @ast::Crate {\n+        ast::Crate {\n             module: m,\n             attrs: inner,\n             config: self.cfg.clone(),"}, {"sha": "942ee88bd0e36715f8f61ef69bbc26b7ccfbd83e", "filename": "src/libsyntax/syntax", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fsyntax", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Fsyntax", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax?ref=7b18976f085a741322c735f0a4279816547d7eaf"}, {"sha": "59a6f0adeb40e5be4ab22567da65576281a88125", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b18976f085a741322c735f0a4279816547d7eaf/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=7b18976f085a741322c735f0a4279816547d7eaf", "patch": "@@ -47,14 +47,14 @@ fn with_error_checking_parse<T>(s: @str, f: &fn(&mut Parser) -> T) -> T {\n }\n \n // parse a string, return a crate.\n-pub fn string_to_crate (source_str : @str) -> @ast::Crate {\n+pub fn string_to_crate (source_str : @str) -> ast::Crate {\n     do with_error_checking_parse(source_str) |p| {\n         p.parse_crate_mod()\n     }\n }\n \n // parse a string, return a crate and the ParseSess\n-pub fn string_to_crate_and_sess (source_str : @str) -> (@ast::Crate,@mut ParseSess) {\n+pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@mut ParseSess) {\n     let (p,ps) = string_to_parser_and_sess(source_str);\n     (p.parse_crate_mod(),ps)\n }"}]}