{"sha": "15507bcb648964752db0d7fd37c4487780a7a5a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NTA3YmNiNjQ4OTY0NzUyZGIwZDdmZDM3YzQ0ODc3ODBhN2E1YTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-13T15:48:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-13T22:33:09Z"}, "message": "remove `metadata_*` from `SharedCrateContext`\n\nNo good reason for them to be in there.", "tree": {"sha": "e2311102d566a2a58cec0c9db5b0039bdaaf65a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2311102d566a2a58cec0c9db5b0039bdaaf65a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15507bcb648964752db0d7fd37c4487780a7a5a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15507bcb648964752db0d7fd37c4487780a7a5a4", "html_url": "https://github.com/rust-lang/rust/commit/15507bcb648964752db0d7fd37c4487780a7a5a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15507bcb648964752db0d7fd37c4487780a7a5a4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea376822a17dd911244c313c5b07dffdfe3c023a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea376822a17dd911244c313c5b07dffdfe3c023a", "html_url": "https://github.com/rust-lang/rust/commit/ea376822a17dd911244c313c5b07dffdfe3c023a"}], "stats": {"total": 56, "additions": 22, "deletions": 34}, "files": [{"sha": "fd8beab92f5ef07b1f142aff107b8ee3947c01e0", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/15507bcb648964752db0d7fd37c4487780a7a5a4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15507bcb648964752db0d7fd37c4487780a7a5a4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=15507bcb648964752db0d7fd37c4487780a7a5a4", "patch": "@@ -32,7 +32,7 @@ use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n-use llvm::{Linkage, ValueRef, Vector, get_param};\n+use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n@@ -56,7 +56,7 @@ use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::{SharedCrateContext, CrateContextList};\n+use context::{self, SharedCrateContext, CrateContextList};\n use debuginfo;\n use declare;\n use machine;\n@@ -726,9 +726,13 @@ fn contains_null(s: &str) -> bool {\n \n fn write_metadata(cx: &SharedCrateContext,\n                   exported_symbols: &NodeSet)\n-                  -> EncodedMetadata {\n+                  -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use flate;\n \n+    let (metadata_llcx, metadata_llmod) = unsafe {\n+        context::create_context_and_module(cx.sess(), \"metadata\")\n+    };\n+\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n@@ -750,30 +754,30 @@ fn write_metadata(cx: &SharedCrateContext,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return EncodedMetadata {\n+        return (metadata_llcx, metadata_llmod, EncodedMetadata {\n             raw_data: vec![],\n             hashes: vec![],\n-        };\n+        });\n     }\n \n     let cstore = &cx.tcx().sess.cstore;\n     let metadata = cstore.encode_metadata(cx.tcx(),\n                                           cx.link_meta(),\n                                           exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n-        return metadata;\n+        return (metadata_llcx, metadata_llmod, metadata);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata.raw_data));\n \n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed);\n-    let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n+    let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n     let name = cx.metadata_symbol_name();\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -787,9 +791,9 @@ fn write_metadata(cx: &SharedCrateContext,\n         // metadata doesn't get loaded into memory.\n         let directive = format!(\".section {}\", section_name);\n         let directive = CString::new(directive).unwrap();\n-        llvm::LLVMSetModuleInlineAsm(cx.metadata_llmod(), directive.as_ptr())\n+        llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return metadata;\n+    return (metadata_llcx, metadata_llmod, metadata);\n }\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n@@ -1070,16 +1074,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              exported_symbols,\n                                              check_overflow);\n     // Translate the metadata.\n-    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, shared_ccx.exported_symbols())\n-    });\n+    let (metadata_llcx, metadata_llmod, metadata) =\n+        time(tcx.sess.time_passes(), \"write metadata\", || {\n+            write_metadata(&shared_ccx, shared_ccx.exported_symbols())\n+        });\n \n     let metadata_module = ModuleTranslation {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         symbol_name_hash: 0, // we always rebuild metadata, at least for now\n         source: ModuleSource::Translated(ModuleLlvm {\n-            llcx: shared_ccx.metadata_llcx(),\n-            llmod: shared_ccx.metadata_llmod(),\n+            llcx: metadata_llcx,\n+            llmod: metadata_llmod,\n         }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");"}, {"sha": "f080cd3eccfcf7e3235cd2950035dd82f050c297", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15507bcb648964752db0d7fd37c4487780a7a5a4/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15507bcb648964752db0d7fd37c4487780a7a5a4/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=15507bcb648964752db0d7fd37c4487780a7a5a4", "patch": "@@ -65,9 +65,6 @@ pub struct Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    metadata_llmod: ModuleRef,\n-    metadata_llcx: ContextRef,\n-\n     exported_symbols: NodeSet,\n     link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -347,7 +344,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n     !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n-unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n+pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n@@ -409,10 +406,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                exported_symbols: NodeSet,\n                check_overflow: bool)\n                -> SharedCrateContext<'b, 'tcx> {\n-        let (metadata_llcx, metadata_llmod) = unsafe {\n-            create_context_and_module(&tcx.sess, \"metadata\")\n-        };\n-\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -459,8 +452,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n         SharedCrateContext {\n-            metadata_llmod: metadata_llmod,\n-            metadata_llcx: metadata_llcx,\n             exported_symbols: exported_symbols,\n             link_meta: link_meta,\n             empty_param_env: tcx.empty_parameter_environment(),\n@@ -492,14 +483,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n     }\n \n-    pub fn metadata_llmod(&self) -> ModuleRef {\n-        self.metadata_llmod\n-    }\n-\n-    pub fn metadata_llcx(&self) -> ContextRef {\n-        self.metadata_llcx\n-    }\n-\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }"}]}